{
  "id": "guide/router",
  "title": "네비게이션: 화면 전환",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/router.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# In-app navigation: routing to views\n-->\n<h1 id=\"네비게이션-화면-전환\">네비게이션: 화면 전환<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#네비게이션-화면-전환\"><i class=\"material-icons\">link</i></a></h1>\n<!--\nIn a single-page app, you change what the user sees by showing or hiding portions of the display that correspond to particular components, rather than going out to the server to get a new page.\nAs users perform application tasks, they need to move between the different [views](guide/glossary#view \"Definition of view\") that you have defined.\n\nTo handle the navigation from one [view](guide/glossary#view) to the next, you use the Angular **`Router`**.\nThe **`Router`** enables navigation by interpreting a browser URL as an instruction to change the view.\n\nTo explore a sample app featuring the router's primary features, see the <live-example></live-example>.\n-->\n<p>단일 페이지 앱에서는 사용자가 보는 화면을 전환할 때 페이지 전체를 서버에서 새로 받아오는 것이 아니라 특정 영역을 표시하거나 감추는 방식을 사용합니다.\n그래서 사용자가 앱을 사용하다 보면 개발자가 사전에 정의해둔 <a href=\"guide/glossary#view\" title=\"Definition of view\">화면</a>을 자주 전환하게 됩니다.</p>\n<p>어떤 <a href=\"guide/glossary#view\">화면</a>을 다른 화면으로 전환하려면 Angular가 제공하는 <strong><code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code></strong>를 사용하면 됩니다.\n<strong><code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code></strong>는 브라우저가 접속한 URL을 해석해서 적절한 화면을 표시하는 역할을 합니다.</p>\n<p>라우터의 주요 기능이 동작하는 것은 <live-example></live-example>에서 직접 확인하거나 다운받아 확인할 수 있습니다.</p>\n<!--\n## Prerequisites\n-->\n<h2 id=\"사전지식\">사전지식<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#사전지식\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nBefore creating a route, you should be familiar with the following:\n\n* [Basics of components](guide/architecture-components)\n* [Basics of templates](guide/glossary#template)\n* An Angular app&mdash;you can generate a basic Angular app using the [Angular CLI](cli).\n\nFor an introduction to Angular with a ready-made app, see [Getting Started](start).\nFor a more in-depth experience of building an Angular app, see the [Tour of Heroes](tutorial) tutorial. Both guide you through using component classes and templates.\n-->\n<p>라우팅 규칙(route)을 정의하기 전에 먼저 이런 내용을 알아두는 것이 좋습니다:</p>\n<ul>\n<li><a href=\"guide/architecture-components\">컴포넌트 기본 지식</a></li>\n<li><a href=\"guide/glossary#template\">템플릿 기본 지식</a></li>\n<li>Angular 앱 — <a href=\"cli\">Angular CLI</a>를 활용하면 Angular 앱을 간단하게 생성할 수 있습니다.</li>\n</ul>\n<p>사전에 준비된 앱을 기반으로 Angular 개발을 시작하려면 <a href=\"start\">시작하기</a> 문서를 참고하세요.\n그리고 <a href=\"tutorial\">히어로들의 여행</a> 튜토리얼을 진행하면 Angular 앱을 개발하는 방법에 대해 좀 더 자세하게 학습할 수 있습니다.\n두 가이드 문서 모두 컴포넌트 클래스와 컴포넌트 템플릿에 대해 다룹니다.</p>\n<hr>\n<a id=\"basics\"></a>\n<!--\n## Generate an app with routing enabled\n-->\n<h2 id=\"라우팅-가능한-상태로-앱-생성하기\">라우팅 가능한 상태로 앱 생성하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#라우팅-가능한-상태로-앱-생성하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe following command uses the Angular CLI to generate a basic Angular app with an app routing module, called `AppRoutingModule`, which is an NgModule where you can configure your routes.\nThe app name in the following example is `routing-app`.\n\n<code-example language=\"none\" class=\"code-shell\">\n  ng new routing-app --routing\n</code-example>\n\nWhen generating a new app, the CLI prompts you to select CSS or a CSS preprocessor.\nFor this example, accept the default of `CSS`.\n-->\n<p>Angular CLI로 다음과 같은 명령을 실행하면 Angular 앱을 생성하면서 <code>AppRoutingModule</code> 이라고 하는 라우팅 모듈을 함께 생성합니다.\n이 모듈은 애플리케이션의 라우팅 규칙을 관리하는 NgModule입니다.\n<code>routing-app</code> 이라는 이름으로 앱을 생성하는 명령은 이렇습니다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng new routing-app --routing\n</code-example>\n<p>애플리케이션을 생성하는 과정에 CSS 전처리기를 사용할 것인지 물어봅니다.\n이번 예제에서는 기본 <code>CSS</code>를 선택합시다.</p>\n<!--\n### Adding components for routing\n-->\n<h3 id=\"라우팅할-컴포넌트-생성하기\">라우팅할 컴포넌트 생성하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#라우팅할-컴포넌트-생성하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nTo use the Angular router, an app needs to have at least two components so that it can navigate from one to the other. To create a component using the CLI, enter the following at the command line where `first` is the name of your component:\n\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component first\n</code-example>\n\nRepeat this step for a second component but give it a different name.\nHere, the new name is `second`.\n\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component second\n</code-example>\n\nThe CLI automatically appends `Component`, so if you were to write `first-component`, your component would be `FirstComponentComponent`.\n\n<a id=\"basics-base-href\"></a>\n\n<div class=\"alert is-helpful\">\n\n  #### `<base href>`\n\n  This guide works with a CLI-generated Angular app.\n  If you are working manually, make sure that you have `<base href=\"/\">` in the `<head>` of your index.html file.\n  This assumes that the `app` folder is the application root, and uses `\"/\"`.\n\n  </code-example>\n\n</div>\n-->\n<p>Angular 라우터를 사용해서 화면을 전환하려면 컴포넌트가 적어도 2개는 있어야 합니다.\n다음 명령을 실행해서 <code>first</code> 라는 이름으로 컴포넌트를 생성합니다:</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component first\n</code-example>\n<p>그리고 다른 이름으로 두 번째 컴포넌트를 생성합니다.\n이번에는 <code>seconds</code> 라는 이름으로 컴포넌트를 생성해 봅시다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component second\n</code-example>\n<p>Angular CLI는 컴포넌트를 생성할 때 자동으로 접미사를 붙이기 때문에, 컴포넌트 이름을 <code>first-component</code> 라고 지정하면 실제 컴포넌트 클래스 이름은 <code>FirstComponentComponent</code>가 됩니다.</p>\n<a id=\"basics-base-href\"></a>\n<div class=\"alert is-helpful\">\n<h4 id=\"base-href\"><code>&#x3C;base href></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#base-href\"><i class=\"material-icons\">link</i></a></h4>\n<p>이 가이드문서는 Angular CLI로 생성한 Angular 앱을 다룹니다.\n만약 Angular CLI를 사용하지 않는다면 index.html 파일의 <code>&#x3C;head></code> 태그에 <code>&#x3C;base href=\"/\"></code> 를 추가해야 합니다.\n이 태그를 추가하면 <code>app</code> 폴더가 애플리케이션 최상위 주소 <code>\"/\"</code> 와 연결됩니다.</p>\n\n</div>\n<!--\n### Importing your new components\n-->\n<h3 id=\"컴포넌트-로드하기\">컴포넌트 로드하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#컴포넌트-로드하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nTo use your new components, import them into `AppRoutingModule` at the top of the file, as follows:\n\n<code-example header=\"AppRoutingModule (excerpt)\">\n\nimport { FirstComponent } from './first/first.component';\nimport { SecondComponent } from './second/second.component';\n\n</code-example>\n-->\n<p>새로 만든 컴포넌트를 사용하려면 <code>AppRoutingModule</code> 파일 제일 위쪽에서 이 컴포넌트들을 로드해야 합니다:</p>\n<code-example header=\"AppRoutingModule (일부)\">\n\nimport { FirstComponent } from './first/first.component';\nimport { SecondComponent } from './second/second.component';\n\n</code-example>\n<a id=\"basic-route\"></a>\n<!--\n## Defining a basic route\n-->\n<h2 id=\"기본-라우팅-규칙-정의하기\">기본 라우팅 규칙 정의하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#기본-라우팅-규칙-정의하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThere are three fundamental building blocks to creating a route.\n\nImport the `AppRoutingModule` into `AppModule` and add it to the `imports` array.\n\nThe Angular CLI performs this step for you.\nHowever, if you are creating an app manually or working with an existing, non-CLI app, verify that the imports and configuration are correct.\nThe following is the default `AppModule` using the CLI with the `--routing` flag.\n\n  <code-example path=\"router/src/app/app.module.8.ts\" header=\"Default CLI AppModule with routing\">\nimport { BrowserModule } from &#39;@angular/platform-browser&#39;;\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { AppRoutingModule } from &#39;./app-routing.module&#39;; // AppRoutingModule을 로드합니다.\nimport { AppComponent } from &#39;./app.component&#39;;\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule,\n    AppRoutingModule // Angular CLI가 AppRoutingModule을 AppModule imports 배열에 자동으로 추가합니다.\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n\n</code-example>\n\n  1. Import `RouterModule` and `Routes` into your routing module.\n\n  The Angular CLI performs this step automatically.\n  The CLI also sets up a `Routes` array for your routes and configures the `imports` and `exports` arrays for `@NgModule()`.\n\n  <code-example path=\"router/src/app/app-routing.module.7.ts\" header=\"CLI app routing module\">\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { Routes, RouterModule } from &#39;@angular/router&#39;; // 라우터 관련 심볼을 로드합니다.\n\nconst routes: Routes = []; // 라우팅 규칙은 이 배열에 등록합니다.\n\n// NgModule의 imports, exports 배열에 RouterModule을 등록합니다.\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n\n\n</code-example>\n\n1. Define your routes in your `Routes` array.\n\n  Each route in this array is a JavaScript object that contains two properties.\n  The first property, `path`, defines the URL path for the route.\n  The second property, `component`, defines the component Angular should use for the corresponding path.\n\n  <code-example path=\"router/src/app/app-routing.module.8.ts\" region=\"routes\" header=\"AppRoutingModule (excerpt)\">\nconst routes: Routes = [\n  { path: &#39;first-component&#39;, component: FirstComponent },\n  { path: &#39;second-component&#39;, component: SecondComponent },\n];\n\n</code-example>\n\n  1. Add your routes to your application.\n\n  Now that you have defined your routes, you can add them to your application.\n  First, add links to the two components.\n  Assign the anchor tag that you want to add the route to the `routerLink` attribute.\n  Set the value of the attribute to the component to show when a user clicks on each link.\n  Next, update your component template to include `<router-outlet>`.\n  This element informs Angular to update the application view with the component for the selected route.\n\n  <code-example path=\"router/src/app/app.component.7.html\" header=\"Template with routerLink and router-outlet\">\n&lt;h1&gt;Angular Router App&lt;/h1&gt;\n&lt;!-- 아래 링크를 클릭하면 AppRoutingModule에 등록된 라우팅 규칙에 따라 화면을 전환합니다. --&gt;\n&lt;nav&gt;\n  &lt;ul&gt;\n    &lt;li&gt;&lt;a routerLink=&quot;/first-component&quot; routerLinkActive=&quot;active&quot;&gt;First Component&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a routerLink=&quot;/second-component&quot; routerLinkActive=&quot;active&quot;&gt;Second Component&lt;/a&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/nav&gt;\n&lt;!-- 라우팅된 화면은 &lt;router-outlet&gt; 위치에 표시됩니다. --&gt;\n&lt;router-outlet&gt;&lt;/router-outlet&gt;\n\n\n</code-example>\n-->\n<p>라우팅 규칙은 세가지 요소로 구성됩니다.</p>\n<p><code>AppModule</code>이 정의된 파일에 <code>AppRoutingModule</code>을 로드하고 이 라우팅 모듈을 <code>AppModule</code> <code>imports</code> 배열에 추가합니다.</p>\n<p>Angular CLI로 앱을 생성했다면 이 과정은 이미 처리되어 있습니다.\n하지만 앱을 직접 생성했거나 이미 있는 앱을 기반으로 작업한다면 라우팅 모듈이 제대로 로드 되었는지, <code>imports</code> 배열에 추가되었는지 꼭 확인해야 합니다.\n아래 코드는 <code>--routing</code> 플래그를 붙여서 Angular CLI로 앱을 생성했을 때 자동으로 생성된 <code>AppModule</code> 코드입니다.</p>\n  <code-example path=\"router/src/app/app.module.8.ts\" header=\"Angular CLI가 자동으로 생성한 AppModule\">\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { AppRoutingModule } from './app-routing.module'; // AppRoutingModule을 로드합니다.\nimport { AppComponent } from './app.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    AppRoutingModule // Angular CLI가 AppRoutingModule을 AppModule imports 배열에 자동으로 추가합니다.\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n\n</code-example>\n<ol>\n<li>\n<p>라우팅 모듈이 정의된 파일에 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>와 <code><a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a></code>를 로드합니다.</p>\n<p>이 과정도 Angular CLI가 자동으로 처리했을 것입니다.\n<code><a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a></code> 배열을 생성하는 것과 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code>의 <code>imports</code> 배열과 <code>exports</code> 배열을 구성하는 것도 Angular CLI가 처리합니다.</p>\n<code-example path=\"router/src/app/app-routing.module.7.ts\" header=\"Angular CLI가 생성한 라우팅 모듈\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a>, <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a> } from '@angular/router'; // 라우터 관련 심볼을 로드합니다.\n\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = []; // 라우팅 규칙은 이 배열에 등록합니다.\n\n// <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>의 imports, exports 배열에 <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>을 등록합니다.\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [<a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>]\n})\nexport class AppRoutingModule { }\n\n\n</code-example>\n</li>\n<li>\n<p>이제 라우팅 규칙을 <code><a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a></code> 배열에 등록합니다.</p>\n<p>라우팅 규칙(route)은 이 배열에 JavaScript 객체 형태로 등록하며, 이 객체는 프로퍼티가 2개 존재합니다.\n첫번째로 <code>path</code> 프로퍼티는 라우팅 규칙에 해당하는 URL 주소를 지정합니다.\n그리고 <code>component</code> 프로퍼티는 해당 URL 주소에 연결될 컴포넌트를 지정합니다.</p>\n<code-example path=\"router/src/app/app-routing.module.8.ts\" region=\"routes\" header=\"AppRoutingModule (일부)\">\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'first-component', component: FirstComponent },\n  { path: 'second-component', component: SecondComponent },\n];\n\n</code-example>\n</li>\n<li>\n<p>라우팅 규칙을 애플리케이션에 등록합니다.</p>\n<p>라우팅 규칙을 모두 정의했다면 이 규칙을 애플리케이션에 등록해야 합니다.\n먼저 두 컴포넌트와 연결되는 링크를 추가합니다.\n링크는 <code>&#x3C;a></code> 엘리먼트에 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> 어트리뷰트를 사용하는 방식으로 구현합니다.\n이 어트리뷰트에는 사용자가 링크를 클릭했을 때 이동할 주소를 지정합니다.\n그리고 컴포넌트 템플릿에 <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code>을 추가합니다.\n<code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code> 엘리먼트는 Angular가 애플리케이션 화면을 전환할 때 관련 컴포넌트가 표시될 위치를 지정하는 엘리먼트입니다.</p>\n<code-example path=\"router/src/app/app.component.7.html\" header=\"routerLink와 router-outlet이 추가된 템플릿\">\n&#x3C;h1>Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a> App&#x3C;/h1>\n&#x3C;!-- 아래 링크를 클릭하면 AppRoutingModule에 등록된 라우팅 규칙에 따라 화면을 전환합니다. -->\n&#x3C;nav>\n  &#x3C;ul>\n    &#x3C;li>&#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/first-component\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">First <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>&#x3C;/a>&#x3C;/li>\n    &#x3C;li>&#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/second-component\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Second <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>&#x3C;/a>&#x3C;/li>\n  &#x3C;/ul>\n&#x3C;/nav>\n&#x3C;!-- 라우팅된 화면은 &#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>> 위치에 표시됩니다. -->\n&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n\n\n</code-example>\n</li>\n</ol>\n<a id=\"route-order\"></a>\n<!--\n### Route order\n-->\n<h3 id=\"라우팅-규칙-적용-순서\">라우팅 규칙 적용 순서<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#라우팅-규칙-적용-순서\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe order of routes is important because the `Router` uses a first-match wins strategy when matching routes, so more specific routes should be placed above less specific routes.\nList routes with a static path first, followed by an empty path route, which matches the default route.\nThe [wildcard route](guide/router#setting-up-wildcard-routes) comes last because it matches every URL and the `Router`  selects it only if no other routes match first.\n-->\n<p>Angular <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>는 라우팅 규칙 중 첫번째로 매칭되는 라우팅 규칙을 적용하기 때문에 라우티 규칙을 등록하는 순서가 중요한데, 구체적인 라우팅 규칙을 가장 먼저 등록하고 덜 구체적인 라우팅 규칙을 나중에 등록하는 것이 좋습니다.\n그래서 고정된 주소를 먼저 등록하며, 그 다음에 빈 주소를 등록하고, 마지막으로 기본 라우팅 규칙을 등록합니다.\n그리고 브라우저가 접속한 주소에 해당하는 라우팅 규칙이 하나도 없을 때 적용되는 <a href=\"guide/router#setting-up-wildcard-routes\">와일드카드 라우팅 규칙</a>은 가장 마지막에 작성합니다.</p>\n<a id=\"getting-route-information\"></a>\n<!--\n## Getting route information\n-->\n<h2 id=\"라우팅-규칙으로-전달된-정보-참조하기\">라우팅 규칙으로 전달된 정보 참조하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#라우팅-규칙으로-전달된-정보-참조하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nOften, as a user navigates your application, you want to pass information from one component to another.\nFor example, consider an application that displays a shopping list of grocery items.\nEach item in the list has a unique `id`.\nTo edit an item, users click an Edit button, which opens an `EditGroceryItem` component.\nYou want that component to retrieve the `id` for the grocery item so it can display the right information to the user.\n\nYou can use a route to pass this type of information to your application components.\nTo do so, you use the [ActivatedRoute](api/router/ActivatedRoute) interface.\n\nTo get information from a route:\n\n  1. Import `ActivatedRoute` and `ParamMap` to your component.\n\n    <code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.ts\" region=\"imports-route-info\" header=\"In the component class (excerpt)\">\nimport { Router, ActivatedRoute, ParamMap } from &#39;@angular/router&#39;;\n\n</code-example>\n\n    These `import` statements add several important elements that your component needs.\n    To learn more about each, see the following API pages:\n\n      * [`Router`](api/router)\n      * [`ActivatedRoute`](api/router/ActivatedRoute)\n      * [`ParamMap`](api/router/ParamMap)\n\n  1. Inject an instance of `ActivatedRoute` by adding it to your application's constructor:\n\n    <code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.ts\" region=\"activated-route\" header=\"In the component class (excerpt)\">\nconstructor(\n  private route: ActivatedRoute,\n) {}\n\n</code-example>\n\n  1. Update the `ngOnInit()` method to access the `ActivatedRoute` and track the `id` parameter:\n\n      <code-example header=\"In the component (excerpt)\">\n        ngOnInit() {\n          this.route.queryParams.subscribe(params => {\n            this.name = params['name'];\n          });\n        }\n      </code-example>\n\n    Note: The preceding example uses a variable, `name`, and assigns it the value based on the `name` parameter.\n\n<a id=\"wildcard-route-how-to\"></a>\n-->\n<p>때로는 사용자가 화면을 전환할 때 교체되는 컴포넌트 사이에 정보를 전달해야 할 때가 있습니다.\n애플리케이션에서 식료품 목록을 보여주고 있다고 합시다.\n목록으로 표시된 개별 식료품에는 고유한 <code>id</code> 값이 있습니다.\n사용자가 식료품 정보를 수정하기 위해 Edit 버튼을 클릭하면 <code>EditGroceryItem</code> 컴포넌트가 화면에 표시될 것입니다.\n이 때 새로 표시되는 컴포넌트는 사용자가 어떤 식료품을 선택했는지 알기 위해 해당 상품에 대한 <code>id</code> 값을 전달받아야 합니다.</p>\n<p>이런 데이터는 라우팅 규칙을 통해 전달할 수 있습니다.\n<a href=\"api/router/ActivatedRoute\">ActivatedRoute</a> 인터페이스를 활용하면 됩니다.</p>\n<p>라우팅 규칙으로 전달된 데이터를 참조해 봅시다:</p>\n<ol>\n<li>\n<p>컴포넌트가 정의된 파일에 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>와 <code><a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a></code> 심볼을 로드합니다.</p>\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.ts\" region=\"imports-route-info\" header=\"In the component class (일부)\">\nimport { <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>, <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, <a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a> } from '@angular/router';\n\n</code-example>\n<p>이 <code>import</code> 구문으로 로드한 클래스를 활용하면 컴포넌트에 필요한 정보를 참조할 수 있습니다.\n각각에 대해 자세하게 알아보려면 개별 API 문서를 참고하세요:</p>\n<ul>\n<li><a href=\"api/router\"><code>Router</code> API 문서</a></li>\n<li><a href=\"api/router/ActivatedRoute\"><code>ActivatedRoute</code> API 문서</a></li>\n<li><a href=\"api/router/ParamMap\"><code>ParamMap</code> API 문서</a></li>\n</ul>\n</li>\n<li>\n<p>생성자에 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 인스턴스를 의존성으로 주입합니다:</p>\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.ts\" region=\"activated-route\" header=\"In the component class (일부)\">\nconstructor(\n  private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>,\n) {}\n\n</code-example>\n</li>\n<li>\n<p><code>ngOnInit()</code> 메소드에서 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 객체 안에 있는 <code>id</code> 인자를 참조합니다:</p>\n<code-example header=\"컴포넌트 코드 (일부)\">\n  ngOnInit() {\n    this.route.queryParams.subscribe(params => {\n      this.id = params['id'];\n    });\n  }\n</code-example>\n</li>\n</ol>\n<a id=\"wildcard-route-how-to\"></a>\n<a id=\"setting-up-wildcard-routes\"></a>\n<!--\n## Setting up wildcard routes\n-->\n<h2 id=\"와일드카드-라우팅-규칙-등록하기\">와일드카드(<code>*</code>) 라우팅 규칙 등록하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#와일드카드-라우팅-규칙-등록하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nA well-functioning application should gracefully handle when users attempt to navigate to a part of your application that does not exist.\nTo add this functionality to your application, you set up a wildcard route.\nThe Angular router selects this route any time the requested URL doesn't match any router paths.\n\nTo set up a wildcard route, add the following code to your `routes` definition.\n\n<code-example header=\"AppRoutingModule (excerpt)\">\n\n{ path: '**', component: <component-name> }\n\n</code-example>\n\n\nThe two asterisks, `**`, indicate to Angular that this `routes` definition is a wildcard route.\nFor the component property, you can define any component in your application.\nCommon choices include an application-specific `PageNotFoundComponent`, which you can define to [display a 404 page](guide/router#404-page-how-to) to your users; or a redirect to your application's main component.\nA wildcard route is the last route because it matches any URL.\nFor more detail on why order matters for routes, see [Route order](guide/router#route-order).\n-->\n<p>완성도 높은 애플리케이션이라면 애플리케이션이 허용하지 않는 주소로 사용자가 접근하는 상황도 자연스럽게 처리해야 합니다.\n이 기능을 구현하려면 와일드카드 라우팅 규칙을 추가하면 됩니다.\n이 규칙을 등록하면 사용자가 등록되지 않은 URL로 화면을 이동하려고 할 때 와일드카드 라우팅 규칙이 적용됩니다.</p>\n<p>와일드카드 라우팅 규칙을 설정하려면 <code>routes</code> 배열에 다음 코드를 추가하면 됩니다.</p>\n<code-example header=\"AppRoutingModule (일부)\">\n\n  { path: '**', component: <component-name> }\n\n</component-name></code-example>\n<p>별표(<code>*</code>, asterisk) 2개가 사용된 <code>**</code>는 Angular가 와일드카드 라우팅 규칙을 구분하기 위한 문자열입니다.\n그리고 <code>component</code>에는 와일드카드 라우팅 규칙이 적용될 때 화면에 표시할 컴포넌트를 지정합니다.\n일반적으로는 <code>PageNotFoundComponent</code>와 같은 컴포넌트를 만들어서 <a href=\"guide/router#404-page-how-to\">404 에러 페이지</a>를 표시하거나, 애플리케이션 최상위 주소로 리다이렉션하는 방법을 선택할 수 있습니다.\n와일드카드 라우팅 규칙은 모든 URL과 매칭되기 때문에 라우팅 규칙 중 가장 나중에 등록해야 합니다.\n라우팅 규칙의 순서에 대해 자세하게 알아보려면 <a href=\"guide/router#route-order\">라우팅 규칙 적용 순서</a> 문서를 참고하세요.</p>\n<a id=\"404-page-how-to\"></a>\n<!--\n## Displaying a 404 page\n-->\n<h2 id=\"404-에러-페이지-표시하기\">404 에러 페이지 표시하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#404-에러-페이지-표시하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nTo display a 404 page, set up a [wildcard route](guide/router#wildcard-route-how-to) with the `component` property set to the component you'd like to use for your 404 page as follows:\n\n<code-example path=\"router/src/app/app-routing.module.8.ts\" region=\"routes-with-wildcard\" header=\"AppRoutingModule (excerpt)\">\nconst routes: Routes = [\n  { path: &#39;first-component&#39;, component: FirstComponent },\n  { path: &#39;second-component&#39;, component: SecondComponent },\n  { path: &#39;**&#39;, component: PageNotFoundComponent },  // 404 에러 화면을 표시하는 와일드카드 라우팅 규칙\n];\n\n</code-example>\n\nThe last route with the `path` of `**` is a wildcard route.\nThe router selects this route if the requested URL doesn't match any of the paths earlier in the list and sends the user to the `PageNotFoundComponent`.\n-->\n<p>404 에러 페이지를 표시하려면 <a href=\"guide/router#wildcard-route-how-to\">와일드카드 라우팅 규칙</a>을 등록할 때 <code>component</code>에 원하는 컴포넌트를 지정하면 됩니다:</p>\n<code-example path=\"router/src/app/app-routing.module.8.ts\" region=\"routes-with-wildcard\" header=\"AppRoutingModule (일부)\">\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'first-component', component: FirstComponent },\n  { path: 'second-component', component: SecondComponent },\n  { path: '**', component: PageNotFoundComponent },  // 404 에러 화면을 표시하는 와일드카드 라우팅 규칙\n];\n\n</code-example>\n<p>마지막에 등록된 <code>path</code>가 <code>**</code>인 라우팅 규칙이 와일드카드 라우팅 규칙입니다.\n이제 접속하려는 URL과 매칭되는 라우팅 규칙을 발견하지 못하면 이 라우팅 규칙이 적용되면서 <code>PageNotFoundComponent</code>가 화면에 표시됩니다.</p>\n<!--\n## Setting up redirects\n-->\n<h2 id=\"리다이렉션-설정하기\">리다이렉션 설정하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#리다이렉션-설정하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nTo set up a redirect, configure a route with the `path` you want to redirect from, the `component` you want to redirect to, and a `pathMatch` value that tells the router how to match the URL.\n\n<code-example path=\"router/src/app/app-routing.module.8.ts\" region=\"redirect\" header=\"AppRoutingModule (excerpt)\">\nconst routes: Routes = [\n  { path: &#39;first-component&#39;, component: FirstComponent },\n  { path: &#39;second-component&#39;, component: SecondComponent },\n  { path: &#39;&#39;,   redirectTo: &#39;/first-component&#39;, pathMatch: &#39;full&#39; }, // `first-component` 주소로 리다이렉트 합니다.\n  { path: &#39;**&#39;, component: PageNotFoundComponent },  // 404 에러 화면을 표시하는 와일드카드 라우팅 규칙\n];\n\n</code-example>\n\nIn this example, the third route is a redirect so that the router defaults to the `first-component` route.\nNotice that this redirect precedes the wildcard route.\nHere, `path: ''` means to use the initial relative URL (`''`).\n\nFor more details on `pathMatch` see [Spotlight on `pathMatch`](guide/router-tutorial-toh#pathmatch).\n-->\n<p>리다이렉션하는 라우팅 규칙을 등록하려면 <code>path</code>에 대상이 될 주소를 지정하고 <code>redirectTo</code>에 리다이렉션할 주소를 지정한 뒤에 <code>pathMatch</code>에 원하는 리다이렉션할 때 적용할 규칙을 지정합니다.</p>\n<code-example path=\"router/src/app/app-routing.module.8.ts\" region=\"redirect\" header=\"AppRoutingModule (일부)\">\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'first-component', component: FirstComponent },\n  { path: 'second-component', component: SecondComponent },\n  { path: '',   redirectTo: '/first-component', pathMatch: 'full' }, // `first-component` 주소로 리다이렉트 합니다.\n  { path: '**', component: PageNotFoundComponent },  // 404 에러 화면을 표시하는 와일드카드 라우팅 규칙\n];\n\n</code-example>\n<p>이 예제에서 세번째 추가된 라우팅 규칙은 기본 주소로 접근했을 때 <code>first-component</code> 주소로 이동하도록 작성한 리다이렉션 라우팅 규칙입니다.\n이 규칙이 와일드카드 라우팅 앞에 온다는 것도 확인해 보세요.\n이 예제에서 작성한 <code>path: ''</code>는 애플리케이션을 접속하는 기본 URL(<code>''</code>)을 의미합니다.</p>\n<p><code>pathMatch</code>에 대해 자세하게 알아보려면 <a href=\"guide/router-tutorial-toh#pathmatch\"><code>pathMatch</code> 자세하게 알아보기</a> 문서를 참고하세요.</p>\n<a id=\"nesting-routes\"></a>\n<!--\n## Nesting routes\n-->\n<h2 id=\"중첩-라우팅-규칙\">중첩 라우팅 규칙<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#중첩-라우팅-규칙\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAs your application grows more complex, you may want to create routes that are relative to a component other than your root component.\nThese types of nested routes are called child routes.\nThis means you're adding a second `<router-outlet>` to your app, because it is in addition to the `<router-outlet>` in `AppComponent`.\n\nIn this example, there are two additional child components, `child-a`, and `child-b`.\nHere, `FirstComponent` has its own `<nav>` and a second `<router-outlet>` in addition to the one in `AppComponent`.\n\n<code-example path=\"router/src/app/app.component.8.html\" region=\"child-routes\" header=\"In the template\">\n&lt;h2&gt;First Component&lt;/h2&gt;\n\n&lt;nav&gt;\n  &lt;ul&gt;\n    &lt;li&gt;&lt;a routerLink=&quot;child-a&quot;&gt;Child A&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a routerLink=&quot;child-b&quot;&gt;Child B&lt;/a&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/nav&gt;\n\n&lt;router-outlet&gt;&lt;/router-outlet&gt;\n\n</code-example>\n\nA child route is like any other route, in that it needs both a `path` and a `component`.\nThe one difference is that you place child routes in a `children` array within the parent route.\n\n<code-example path=\"router/src/app/app-routing.module.9.ts\" region=\"child-routes\" header=\"AppRoutingModule (excerpt)\">\nconst routes: Routes = [\n  {\n    path: &#39;first-component&#39;,\n    component: FirstComponent, // 이 컴포넌트 템플릿에 &lt;router-outlet&gt;이 존재합니다.\n    children: [\n      {\n        path: &#39;child-a&#39;, // 자식 라우팅 규칙과 연결되는 주소\n        component: ChildAComponent, // 라우터가 렌더링하는 자식 컴포넌트\n      },\n      {\n        path: &#39;child-b&#39;,\n        component: ChildBComponent, // 또다른 자식 컴포넌트\n      },\n    ],\n  },\n];\n\n</code-example>\n-->\n<p>애플리케이션이 점점 복잡해지다 보면 특정 컴포넌트 안에서 동작하는 라우팅 규칙을 추가하고 싶은 경우도 있습니다.\n이렇게 중첩된 라우팅 규칙을 자식 라우팅 규칙(child route)이라고 합니다.\n라우팅 규칙을 중첩해서 적용하려면 컴포넌트에 <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code>을 더 추가해야 합니다.\n왜냐하면 첫번째 계층에서 동작하는 라우팅 규칙은 <code>AppComponent</code>의 <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code> 안에서 동작하기 때문입니다.</p>\n<p>아래 예제 코드에는 자식 컴포넌트가 <code>child-a</code>, <code>child-b</code> 2개 존재합니다.\n그리고 <code>FirstComponent</code>에는 <code>&#x3C;nav></code>가 존재하며 <code>AppComponent</code>에 있는 <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code> 외에 또다른 <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code>이 추가되어 있습니다.</p>\n<code-example path=\"router/src/app/app.component.8.html\" region=\"child-routes\" header=\"In the template\">\n&#x3C;h2>First <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>&#x3C;/h2>\n\n&#x3C;nav>\n  &#x3C;ul>\n    &#x3C;li>&#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"child-a\">Child A&#x3C;/a>&#x3C;/li>\n    &#x3C;li>&#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"child-b\">Child B&#x3C;/a>&#x3C;/li>\n  &#x3C;/ul>\n&#x3C;/nav>\n\n&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n\n</code-example>\n<p>자식 라우팅 규칙도 일반 라우팅 규칙과 마찬가지로 <code>path</code>, <code>component</code> 프로퍼티로 정의합니다.\n자식 라우팅 규칙은 부모 라우팅 규칙이 있고, 부모 라우팅 규칙의 <code>children</code> 배열에 정의한다는 점만 다릅니다.</p>\n<code-example path=\"router/src/app/app-routing.module.9.ts\" region=\"child-routes\" header=\"AppRoutingModule (일부)\">\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'first-component',\n    component: FirstComponent, // 이 컴포넌트 템플릿에 &#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>이 존재합니다.\n    children: [\n      {\n        path: 'child-a', // 자식 라우팅 규칙과 연결되는 주소\n        component: ChildAComponent, // 라우터가 렌더링하는 자식 컴포넌트\n      },\n      {\n        path: 'child-b',\n        component: ChildBComponent, // 또다른 자식 컴포넌트\n      },\n    ],\n  },\n];\n\n</code-example>\n<a id=\"using-relative-paths\"></a>\n<!--\n## Using relative paths\n-->\n<h2 id=\"상대주소-사용하기\">상대주소 사용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#상대주소-사용하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nRelative paths allow you to define paths that are relative to the current URL segment.\nThe following example shows a relative route to another component, `second-component`.\n`FirstComponent` and `SecondComponent` are at the same level in the tree, however, the link to `SecondComponent` is situated within the `FirstComponent`, meaning that the router has to go up a level and then into the second directory to find the `SecondComponent`.\nRather than writing out the whole path to get to `SecondComponent`, you can use the `../` notation to go up a level.\n\n<code-example path=\"router/src/app/app.component.8.html\" region=\"relative-route\" header=\"In the template\">\n\n&lt;h2&gt;First Component&lt;/h2&gt;\n\n&lt;nav&gt;\n  &lt;ul&gt;\n    &lt;li&gt;&lt;a routerLink=&quot;../second-component&quot;&gt;Relative Route to second component&lt;/a&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/nav&gt;\n&lt;router-outlet&gt;&lt;/router-outlet&gt;\n\n\n</code-example>\n\nIn addition to `../`, you can use `./` or no leading slash to specify the current level.\n-->\n<p>상대주소를 사용하면 현재 URL를 기준으로 라우팅할 주소를 지정할 수 있습니다.\n아래 예제는 <code>second-component</code>로 이동하는 링크에 상대주소를 적용한 예제 코드입니다.\n<code>FirstComponent</code>와 <code>SecondComponent</code>는 라우팅 계층 트리에서 같은 계층에 있지만 <code>FirstComponent</code> 안에서 <code>SecondComponent</code>로 이동하는 기능을 제공하려고 합니다.\n결국 상위 계층으로 한단계 이동한 후에 <code>SecondComponent</code>를 찾아야 합니다.\n이 때 <code>SecondComponent</code>로 이동하는 전체 경로를 사용하는 대신 상대 주소를 가리키는 방식으로 <code>../</code> 라는 표현을 사용했습니다.</p>\n<code-example path=\"router/src/app/app.component.8.html\" region=\"relative-route\" header=\"In the template\">\n\n&#x3C;h2>First <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>&#x3C;/h2>\n\n&#x3C;nav>\n  &#x3C;ul>\n    &#x3C;li>&#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"../second-component\">Relative <a href=\"api/router/Route\" class=\"code-anchor\">Route</a> to second component&#x3C;/a>&#x3C;/li>\n  &#x3C;/ul>\n&#x3C;/nav>\n&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n\n\n</code-example>\n<p><code>../</code>와 비슷하게 <code>./</code>, <code>.</code>를 사용하면 현재 라우팅 계층의 빈 주소를 가리킵니다.</p>\n<!--\n### Specifying a relative route\n-->\n<h3 id=\"상대-주소로-이동하기\">상대 주소로 이동하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#상대-주소로-이동하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nTo specify a relative route, use the `NavigationExtras` `relativeTo` property.\nIn the component class, import `NavigationExtras` from the `@angular/router`.\n\nThen use `relativeTo` in your navigation method.\nAfter the link parameters array, which here contains `items`, add an object with the `relativeTo` property set to the `ActivatedRoute`, which is `this.route`.\n\n<code-example path=\"router/src/app/app.component.4.ts\" region=\"relative-to\" header=\"RelativeTo\">\ngoToItems() {\n  this.router.navigate([&#39;items&#39;], { relativeTo: this.route });\n}\n\n</code-example>\n\nThe `goToItems()` method interprets the destination URI as relative to the activated route and navigates to the `items` route.\n-->\n<p>상대 라우팅 규칙을 지정하려면 <code><a href=\"api/router/NavigationExtras\" class=\"code-anchor\">NavigationExtras</a></code> 객체의 <code>relativeTo</code> 프로퍼티를 사용하면 됩니다.\n<code><a href=\"api/router/NavigationExtras\" class=\"code-anchor\">NavigationExtras</a></code> 객체는 <code>@angular/router</code>에 정의되어 있는 객체입니다.</p>\n<p>화면을 이동할 때 <code>relativeTo</code> 옵션을 사용해 봅시다.\n아래 예제에서 <code>items</code>로 지정된 링크 인자 배열 뒤에 객체 옵션을 추가하고 이 객체에 <code>relativeTo</code> 프로퍼티로 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>를 지정합니다.\n이 예제의 경우에는 <code>this.route</code> 입니다.</p>\n<code-example path=\"router/src/app/app.component.4.ts\" region=\"relative-to\" header=\"RelativeTo\">\ngoToItems() {\n  this.router.navigate(['items'], { relativeTo: this.route });\n}\n\n</code-example>\n<p>그러면 <code>navigate()</code> 함수가 실행되면서 <code>items</code> 주소로 이동할 때 현재 라우팅 규칙에 대한 상대 주소로 이 주소를 처리합니다.</p>\n<!--\n## Accessing query parameters and fragments\n-->\n<h2 id=\"쿼리-인자-url-조각-참고하기\">쿼리 인자, URL 조각 참고하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#쿼리-인자-url-조각-참고하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nSometimes, a feature of your application requires accessing a part of a route, such as a query parameter or a fragment. The Tour of Heroes app at this stage in the tutorial uses a list view in which you can click on a hero to see details. The router uses an `id` to show the correct hero's details.\n\nFirst, import the following members in the component you want to navigate from.\n\n<code-example header=\"Component import statements (excerpt)\">\n\nimport { ActivatedRoute } from '@angular/router';\nimport { Observable } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\n\n</code-example>\n\nNext inject the activated route service:\n\n<code-example header=\"Component (excerpt)\">\nconstructor(private route: ActivatedRoute) {}\n</code-example>\n\nConfigure the class so that you have an observable, `heroes$`, a `selectedId` to hold the `id` number of the hero, and the heroes in the `ngOnInit()`, add the following code to get the `id` of the selected hero.\nThis code snippet assumes that you have a heroes list, a hero service, a function to get your heroes, and the HTML to render your list and details, just as in the Tour of Heroes example.\n\n<code-example header=\"Component 1 (excerpt)\">\nheroes$: Observable<Hero[]>;\nselectedId: number;\nheroes = HEROES;\n\nngOnInit() {\n  this.heroes$ = this.route.paramMap.pipe(\n    switchMap(params => {\n      this.selectedId = Number(params.get('id'));\n      return this.service.getHeroes();\n    })\n  );\n}\n\n</code-example>\n\n\nNext, in the component that you want to navigate to, import the following members.\n\n<code-example header=\"Component 2 (excerpt)\">\n\nimport { Router, ActivatedRoute, ParamMap } from '@angular/router';\nimport { Observable } from 'rxjs';\n\n</code-example>\n\nInject `ActivatedRoute` and `Router` in the constructor of the component class so they are available to this component:\n\n\n<code-example header=\"Component 2 (excerpt)\">\n\n  hero$: Observable<Hero>;\n\n  constructor(\n    private route: ActivatedRoute,\n    private router: Router  ) {}\n\n  ngOnInit() {\n    const heroId = this.route.snapshot.paramMap.get('id');\n    this.hero$ = this.service.getHero(heroId);\n  }\n\n  gotoItems(hero: Hero) {\n    const heroId = hero ? hero.id : null;\n    // Pass along the hero id if available\n    // so that the HeroList component can select that item.\n    this.router.navigate(['/heroes', { id: heroId }]);\n  }\n\n</code-example>\n-->\n<p>때로는 쿼리 변수나 URL 조각 같은 라우팅 규칙 관련 정보에 접근해야 할 때가 있습니다.\n히어로들의 여행 앱에서도 사용자가 히어로를 클릭하면 상세정보 화면으로 이동하는데, 이 때 히어로의 <code>id</code>를 인자로 받아서 화면을 구성합니다.</p>\n<p>먼저, 아래 심볼들을 컴포넌트 파일에 로드합니다.</p>\n<code-example header=\"Component import statements (일부)\">\n\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\nimport { Observable } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\n\n</code-example>\n<p>그리고 현재 활성화된 라우팅 규칙(<code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>)을 의존성으로 주입합니다:</p>\n<code-example header=\"Component (일부)\">\nconstructor(private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>) {}\n</code-example>\n<p>이제 컴포넌트 클래스 <code>ngOnInit()</code> 안에서 현재 활성화 된 라우팅 규칙으로 전달되는 <code>id</code> 필드를 컴포넌트 클래스의 옵저버블 프로퍼티 <code>heroes$</code>에 할당해 봅시다.\n이 때 히어로 목록은 배열로 존재하며, 관련 서비스가 이미 주입되어 있고, 화면을 표시하는 템플릿 코드도 이미 준비되어 있다고 합시다.</p>\n<code-example header=\"Component 1 (일부)\">\nheroes$: Observable<hero[]>;\nselectedId: number;\nheroes = HEROES;\n\nngOnInit() {\n  this.heroes$ = this.route.paramMap.pipe(\n    switchMap(params => {\n      this.selectedId = Number(params.get('id'));\n      return this.service.getHeroes();\n    })\n  );\n}\n\n</hero[]></code-example>\n<p>다음에는 이동하려는 컴포넌트 파일에 이런 심볼들을 로드합니다:</p>\n<code-example header=\"Component 2 (일부)\">\n\nimport { <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>, <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, <a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a> } from '@angular/router';\nimport { Observable } from 'rxjs';\n\n</code-example>\n<p>컴포넌트 클래스의 생성자에 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>와 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>를 의존성으로 주입하면 라우터 관련 정보를 참조할 수 있습니다:</p>\n<code-example header=\"Component 2 (일부)\">\n\n  hero$: Observable<hero>;\n\n  constructor(\n    private route: ActivatedRoute,\n    private router: Router  ) {}\n\n  ngOnInit() {\n    const heroId = this.route.snapshot.paramMap.get('id');\n    this.hero$ = this.service.getHero(heroId);\n  }\n\n  gotoItems(hero: Hero) {\n    const heroId = hero ? hero.id : null;\n    // 히어로 객체가 전달되면 id를 가져옵니다.\n    // HeroList 컴포넌트로 이동합니다.\n    this.router.navigate(['/heroes', { id: heroId }]);\n  }\n\n</hero></code-example>\n<a id=\"lazy-loading\"></a>\n<!--\n## Lazy loading\n-->\n<h2 id=\"지연-로딩\">지연 로딩<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#지연-로딩\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nYou can configure your routes to lazy load modules, which means that Angular only loads modules as needed, rather than loading all modules when the app launches.\nAdditionally, you can preload parts of your app in the background to improve the user experience.\n\nFor more information on lazy loading and preloading see the dedicated guide [Lazy loading NgModules](guide/lazy-loading-ngmodules).\n-->\n<p>Angular 앱이 실행되는 시점에 로딩되지 않고 필요한 시점에 따로 로딩되는 모듈을 지연 로딩되는 모듈(lazy load module)이라고 합니다.\n모듈을 지연로딩하면 앱 초기 실행시간이 짧아지기 때문에 사용자에게 좀 더 나은 사용성을 제공할 수 있습니다.\n라우팅 규칙을 정의할 때 지연 로딩되는 모듈로 향하는 라우팅 규칙을 정의할 수 있습니다.</p>\n<p>자세한 내용은 지연 로딩과 사전 로딩에 대해 다루는 <a href=\"guide/lazy-loading-ngmodules\">NgModule 지연 로딩</a> 문서를 참고하세요.</p>\n<a id=\"preventing-unauthorized-access\"></a>\n<!--\n## Preventing unauthorized access\n-->\n<h2 id=\"허가되지-않은-접근-차단하기\">허가되지 않은 접근 차단하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#허가되지-않은-접근-차단하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nUse route guards to prevent users from navigating to parts of an app without authorization.\nThe following route guards are available in Angular:\n\n* [`CanActivate`](api/router/CanActivate)\n* [`CanActivateChild`](api/router/CanActivateChild)\n* [`CanDeactivate`](api/router/CanDeactivate)\n* [`Resolve`](api/router/Resolve)\n* [`CanLoad`](api/router/CanLoad)\n\nTo use route guards, consider using component-less routes as this facilitates guarding child routes.\n\nCreate a service for your guard:\n\n\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate guard your-guard\n</code-example>\n\nIn your guard class, implement the guard you want to use.\nThe following example uses `CanActivate` to guard the route.\n\n<code-example header=\"Component (excerpt)\">\nexport class YourGuard implements CanActivate {\n  canActivate(\n    next: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot): boolean {\n      // your  logic goes here\n  }\n}\n</code-example>\n\nIn your routing module, use the appropriate property in your `routes` configuration.\nHere, `canActivate` tells the router to mediate navigation to this particular route.\n\n<code-example header=\"Routing module (excerpt)\">\n{\n  path: '/your-path',\n  component: YourComponent,\n  canActivate: [YourGuard],\n}\n</code-example>\n\nFor more information with a working example, see the [routing tutorial section on route guards](guide/router-tutorial-toh#milestone-5-route-guards).\n-->\n<p>라우팅 가드를 사용하면 허가되지 않은 앱 영역으로 사용자가 이동하는 것을 방지할 수 있습니다.\nAngular는 다음과 같은 라우팅 가드를 제공합니다:</p>\n<ul>\n<li><a href=\"api/router/CanActivate\"><code>CanActivate</code></a></li>\n<li><a href=\"api/router/CanActivateChild\"><code>CanActivateChild</code></a></li>\n<li><a href=\"api/router/CanDeactivate\"><code>CanDeactivate</code></a></li>\n<li><a href=\"api/router/Resolve\"><code>Resolve</code></a></li>\n<li><a href=\"api/router/CanLoad\"><code>CanLoad</code></a></li>\n</ul>\n<p>라우팅 가드를 사용할 때는 컴포넌트가 없는(component-less) 라우팅 규칙을 따로 정의해서 자식 라우팅 규칙을 모두 보호하는 방법도 고려해볼만 합니다.</p>\n<p>Angular CLI로 가드를 생성하려면 이런 명령을 실행하면 됩니다:</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate guard your-guard\n</code-example>\n<p>가드 클래스에는 가드가 동작하는 로직을 작성합니다.\n아래 예제는 <code><a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a></code>를 활용하는 가드 예제 코드입니다.</p>\n<code-example header=\"Component (일부)\">\nexport class YourGuard implements <a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a> {\n  canActivate(\n    next: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>,\n    <a href=\"api/animations/state\" class=\"code-anchor\">state</a>: <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>): boolean {\n      // 인증 로직\n  }\n}\n</code-example>\n<p>그리고 라우팅 모듈에서 <code>routes</code> 배열에 라우팅 가드가 동작할 프로퍼티를 지정하면 됩니다.\n이번 예제에서는 <code>canActivate</code> 프로퍼티를 사용해서 해당 라우팅 규칙을 보호하는 방식으로 구현했습니다.</p>\n<code-example header=\"Routing module (일부)\">\n{\n  path: '/your-path',\n  component: YourComponent,\n  canActivate: [YourGuard],\n}\n</code-example>\n<p>더 자세한 내용은 <a href=\"guide/router-tutorial-toh#milestone-5-route-guards\">라우팅 튜토리얼의 라우팅 가드 섹션</a>을 참고하세요.</p>\n<a id=\"link-parameters-array\"></a>\n<!--\n## Link parameters array\n-->\n<h2 id=\"링크-변수-배열\">링크 변수 배열<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#링크-변수-배열\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nA link parameters array holds the following ingredients for router navigation:\n\n* The path of the route to the destination component.\n* Required and optional route parameters that go into the route URL.\n\nYou can bind the `RouterLink` directive to such an array like this:\n\n<code-example path=\"router/src/app/app.component.3.ts\" header=\"src/app/app.component.ts (h-anchor)\" region=\"h-anchor\">\n&lt;a [routerLink]=&quot;[&#39;/heroes&#39;]&quot;&gt;Heroes&lt;/a&gt;\n\n</code-example>\n\nThe following is a two-element array when specifying a route parameter:\n\n<code-example path=\"router/src/app/heroes/hero-list/hero-list.component.1.html\" header=\"src/app/heroes/hero-list/hero-list.component.html (nav-to-detail)\" region=\"nav-to-detail\">\n&lt;a [routerLink]=&quot;[&#39;/hero&#39;, hero.id]&quot;&gt;\n  &lt;span class=&quot;badge&quot;&gt;{{ hero.id }}&lt;/span&gt;{{ hero.name }}\n&lt;/a&gt;\n\n</code-example>\n\nYou can provide optional route parameters in an object, as in `{ foo: 'foo' }`:\n\n<code-example path=\"router/src/app/app.component.3.ts\" header=\"src/app/app.component.ts (cc-query-params)\" region=\"cc-query-params\">\n&lt;a [routerLink]=&quot;[&#39;/crisis-center&#39;, { foo: &#39;foo&#39; }]&quot;&gt;Crisis Center&lt;/a&gt;\n\n</code-example>\n\nThese three examples cover the needs of an app with one level of routing.\nHowever, with a child router, such as in the crisis center, you create new link array possibilities.\n\nThe following minimal `RouterLink` example builds upon a specified [default child route](guide/router-tutorial-toh#a-crisis-center-with-child-routes) for the crisis center.\n\n<code-example path=\"router/src/app/app.component.3.ts\" header=\"src/app/app.component.ts (cc-anchor-w-default)\" region=\"cc-anchor-w-default\">\n&lt;a [routerLink]=&quot;[&#39;/crisis-center&#39;]&quot;&gt;Crisis Center&lt;/a&gt;\n\n</code-example>\n\nNote the following:\n\n* The first item in the array identifies the parent route (`/crisis-center`).\n* There are no parameters for this parent route.\n* There is no default for the child route so you need to pick one.\n* You're navigating to the `CrisisListComponent`, whose route path is `/`, but you don't need to explicitly add the slash.\n\nConsider the following router link that navigates from the root of the application down to the Dragon Crisis:\n\n<code-example path=\"router/src/app/app.component.3.ts\" header=\"src/app/app.component.ts (Dragon-anchor)\" region=\"Dragon-anchor\">\n&lt;a [routerLink]=&quot;[&#39;/crisis-center&#39;, 1]&quot;&gt;Dragon Crisis&lt;/a&gt;\n\n</code-example>\n\n* The first item in the array identifies the parent route (`/crisis-center`).\n* There are no parameters for this parent route.\n* The second item identifies the child route details about a particular crisis (`/:id`).\n* The details child route requires an `id` route parameter.\n* You added the `id` of the Dragon Crisis as the second item in the array (`1`).\n* The resulting path is `/crisis-center/1`.\n\nYou could also redefine the `AppComponent` template with Crisis Center routes exclusively:\n\n<code-example path=\"router/src/app/app.component.3.ts\" header=\"src/app/app.component.ts (template)\" region=\"template\">\ntemplate: `\n  &lt;h1 class=&quot;title&quot;&gt;Angular Router&lt;/h1&gt;\n  &lt;nav&gt;\n    &lt;a [routerLink]=&quot;[&#39;/crisis-center&#39;]&quot;&gt;Crisis Center&lt;/a&gt;\n    &lt;a [routerLink]=&quot;[&#39;/crisis-center/1&#39;, { foo: &#39;foo&#39; }]&quot;&gt;Dragon Crisis&lt;/a&gt;\n    &lt;a [routerLink]=&quot;[&#39;/crisis-center/2&#39;]&quot;&gt;Shark Crisis&lt;/a&gt;\n  &lt;/nav&gt;\n  &lt;router-outlet&gt;&lt;/router-outlet&gt;\n`\n\n</code-example>\n\nIn summary, you can write applications with one, two or more levels of routing.\nThe link parameters array affords the flexibility to represent any routing depth and any legal sequence of route paths, (required) router parameters, and (optional) route parameter objects.\n-->\n<p>링크 변수 배열(link parameters array)은 현재 라우팅과 관련해서 이런 정보를 담고 있습니다:</p>\n<ul>\n<li>표시되는 컴포넌트와 관련된 라우팅 규칙(route)</li>\n<li>라우팅 규칙 URL에 포함된 필수/옵션 라우팅 변수</li>\n</ul>\n<p><code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 디렉티브가 적용된 링크가 하나 있다고 합시다:</p>\n<code-example path=\"router/src/app/app.component.3.ts\" header=\"src/app/app.component.ts (링크 엘리먼트)\" region=\"h-anchor\">\n&#x3C;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/heroes']\">Heroes&#x3C;/a>\n\n</code-example>\n<p>이 링크가 동작하면서 인자를 함께 전달하려면 디렉티브에 바인딩되는 배열을 다음과 같이 수정하면 됩니다:</p>\n<code-example path=\"router/src/app/heroes/hero-list/hero-list.component.1.html\" header=\"src/app/heroes/hero-list/hero-list.component.html (상세정보로 이동하는 링크)\" region=\"nav-to-detail\">\n&#x3C;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/hero', hero.id]\">\n  &#x3C;span class=\"badge\">{{ hero.id }}&#x3C;/span>{{ hero.name }}\n&#x3C;/a>\n\n</code-example>\n<p>라우팅 인자는 <code>{ foo: 'foo' }</code>와 같은 객체 형태도 전달할 수 있습니다:</p>\n<code-example path=\"router/src/app/app.component.3.ts\" header=\"src/app/app.component.ts (쿼리 인자)\" region=\"cc-query-params\">\n&#x3C;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/crisis-center', { foo: 'foo' }]\">Crisis Center&#x3C;/a>\n\n</code-example>\n<p>이 세가지 예제를 활용하면 한 계층에서 발생하는 라우팅 동작을 거의 구현할 수 있습니다.\n그런데 위기대응센터 화면처럼 자식 라우터가 있다면 조금 다릅니다.</p>\n<p>아래 코드는 위기대응센터 화면에 사용했던 <a href=\"guide/router-tutorial-toh#a-crisis-center-with-child-routes\">기본 자식 라우팅 규칙</a> 링크를 정의한 코드입니다.</p>\n<code-example path=\"router/src/app/app.component.3.ts\" header=\"src/app/app.component.ts (위기대응센터 기본 링크)\" region=\"cc-anchor-w-default\">\n&#x3C;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/crisis-center']\">Crisis Center&#x3C;/a>\n\n</code-example>\n<p>이 코드에서 이런 내용을 확인할 수 있습니다:</p>\n<ul>\n<li>배열의 첫번째 항목은 부모 라우팅 규칙 <code>/crisis-center</code>를 의미합니다.</li>\n<li>부모 라우팅 규칙에 전달되는 라우팅 인자는 없습니다.</li>\n<li>부모 라우팅 규칙의 기본 주소가 없다면 자식 라우팅 규칙 중 하나를 지정해야 합니다.</li>\n<li>기본 주소를 <code>CrisisListComponent</code>와 연결했다면 <code>/crisis-center/</code> 라고 지정해야 하지만, 마지막 슬래시(<code>/</code>)는 생략할 수 있습니다.</li>\n</ul>\n<p>이번에는 위기대응센터 화면에 있는 링크 중에서 Dragon 위기로 이동하는 링크를 살펴봅시다:</p>\n<code-example path=\"router/src/app/app.component.3.ts\" header=\"src/app/app.component.ts (Dragon 링크)\" region=\"Dragon-anchor\">\n&#x3C;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/crisis-center', 1]\">Dragon Crisis&#x3C;/a>\n\n</code-example>\n<ul>\n<li>배열의 첫번째 항목은 부모 라우팅 규칙 <code>/crisis-center</code>를 의미합니다.</li>\n<li>부모 라우팅 규칙에 전달되는 라우팅 인자는 없습니다.</li>\n<li>배열의 두번째 항목은 자식 라우팅 규칙에 적용될 조건(<code>/:id</code>)를 의미합니다.</li>\n<li>자식 라우팅 규칙에서는 라우팅 인자 <code>id</code>를 참조해서 상세정보를 가져옵니다.</li>\n<li>Dragon 위기에 해당하는 <code>id</code> 값(<code>1</code>)은 배열 두번째 항목으로 전달합니다.</li>\n<li>최종 주소는 <code>/crisis-center/1</code>이 됩니다.</li>\n</ul>\n<p>그러면 <code>AppComponent</code> 템플릿을 이렇게 정의할 수 있습니다:</p>\n<code-example path=\"router/src/app/app.component.3.ts\" header=\"src/app/app.component.ts (템플릿)\" region=\"template\">\ntemplate: `\n  &#x3C;h1 class=\"title\">Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>&#x3C;/h1>\n  &#x3C;nav>\n    &#x3C;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/crisis-center']\">Crisis Center&#x3C;/a>\n    &#x3C;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/crisis-center/1', { foo: 'foo' }]\">Dragon Crisis&#x3C;/a>\n    &#x3C;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/crisis-center/2']\">Shark Crisis&#x3C;/a>\n  &#x3C;/nav>\n  &#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n`\n\n</code-example>\n<p>정리하자면, 애플리케이션은 라우팅 계층의 깊이와 관계없이 자유롭게 화면을 전환할 수 있습니다.\n링크 인자 배열을 활용하면 원하는 계층으로 이동하면서, 필수/옵션 라우팅 인자를 함께 전달할 수 있습니다.</p>\n<a id=\"browser-url-styles\"></a>\n<a id=\"location-strategy\"></a>\n<!--\n## `LocationStrategy` and browser URL styles\n-->\n<h2 id=\"locationstrategy-브라우저-url-스타일\"><code><a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a></code>, 브라우저 URL 스타일<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#locationstrategy-브라우저-url-스타일\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nWhen the router navigates to a new component view, it updates the browser's location and history with a URL for that view.\nAs this is a strictly local URL the browser won't send this URL to the server and will not reload the page.\n\nModern HTML5 browsers support <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries\" title=\"HTML5 browser history push-state\">history.pushState</a>, a technique that changes a browser's location and history without triggering a server page request.\nThe router can compose a \"natural\" URL that is indistinguishable from one that would otherwise require a page load.\n\nHere's the Crisis Center URL in this \"HTML5 pushState\" style:\n\n<code-example format=\"nocode\">\n  localhost:3002/crisis-center/\n\n</code-example>\n\nOlder browsers send page requests to the server when the location URL changes unless the change occurs after a \"#\" (called the \"hash\").\nRouters can take advantage of this exception by composing in-application route URLs with hashes.\nHere's a \"hash URL\" that routes to the Crisis Center.\n\n<code-example format=\"nocode\">\n  localhost:3002/src/#/crisis-center/\n\n</code-example>\n\nThe router supports both styles with two `LocationStrategy` providers:\n\n1. `PathLocationStrategy`&mdash;the default \"HTML5 pushState\" style.\n1. `HashLocationStrategy`&mdash;the \"hash URL\" style.\n\nThe `RouterModule.forRoot()` function sets the `LocationStrategy` to the `PathLocationStrategy`, which makes it the default strategy.\nYou also have the option of switching to the `HashLocationStrategy` with an override during the bootstrapping process.\n\n<div class=\"alert is-helpful\">\n\nFor more information on providers and the bootstrap process, see [Dependency Injection](guide/dependency-injection#bootstrap).\n\n</div>\n-->\n<p>화면에 새로운 컴포넌트를 표시하게 되면 브라우저의 주소와 히스토리가 변경됩니다.\n그리고 이 주소는 로컬 환경에만 적용되는 URL이기 때문에 단일 페이지 애플리케이션이 이 주소를 서버로 보내지 않아도 화면을 갱신할 수 있습니다.</p>\n<p>최신 HTML5 브라우저는 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries\" title=\"HTML5 browser history push-state\">history.pushState</a> API를 제공합니다.\n이 API를 활용하면 서버로 새로운 페이지 요청을 보내지 않으면서 브라우저의 주소나 히스토리를 변경할 수 있습니다.\n그리고 Angular 라우터는 새로운 페이지 로드가 필요한 URL과 구별하지 않으면서 자연스러운 URL을 처리할 숭 ㅣㅆ습니다.</p>\n<p>\"HTML5 pushState\" 스타일로 구성되는 위기대응센터 URL은 이렇습니다:</p>\n<code-example format=\"nocode\">\n  localhost:3002/crisis-center/\n\n</code-example>\n<p>오래된 브라우저는 접근하는 URL이 변경될 때 발생하는 새 페이지 요청을 생략하기 위해 해시 기호(<code>#</code>)를 붙이는 방법을 사용하기도 합니다.\n물론 Angular에서는 이런 방식의 URL도 사용할 수 있습니다.\n해시 URL 스타일로 구성되는 위기대응센터 URL은 이렇습니다:</p>\n<code-example format=\"nocode\">\n  localhost:3002/src/#/crisis-center/\n\n</code-example>\n<p>두가지 스타일 중 어떤 스타일을 사용할지는 Angular <code><a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a></code> 프로바이더를 지정하는 방법으로 결정할 수 있습니다.</p>\n<ol>\n<li><code><a href=\"api/common/PathLocationStrategy\" class=\"code-anchor\">PathLocationStrategy</a></code> — HTML5 pushState 스타일을 사용합니다. 이 값이 기본값입니다.</li>\n<li><code><a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a></code> — 해시 URL 스타일을 사용합니다.</li>\n</ol>\n<p>기본 상태에서는 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 함수에서 <code><a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a></code>를 <code><a href=\"api/common/PathLocationStrategy\" class=\"code-anchor\">PathLocationStrategy</a></code>로 설정하고 있습니다.\n<code><a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a></code>를 사용하려면 앱을 부트스트랩 할 때 이 값을 지정하면 됩니다.</p>\n<div class=\"alert is-helpful\">\n<p>부트스트랩 과정에 대해 자세하게 알아보려면 <a href=\"guide/dependency-injection#bootstrap\">의존성 주입</a> 문서를 참고하세요.</p>\n</div>\n<!--\n## Choosing a routing strategy\n-->\n<h2 id=\"url-스타일-결정하기\">URL 스타일 결정하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#url-스타일-결정하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nYou must choose a routing strategy early in the development of you project because once the application is in production, visitors to your site use and depend on application URL references.\n\nAlmost all Angular projects should use the default HTML5 style.\nIt produces URLs that are easier for users to understand and it preserves the option to do server-side rendering.\n\nRendering critical pages on the server is a technique that can greatly improve perceived responsiveness when the app first loads.\nAn app that would otherwise take ten or more seconds to start could be rendered on the server and delivered to the user's device in less than a second.\n\nThis option is only available if application URLs look like normal web URLs without hashes (#) in the middle.\n-->\n<p>URL 스타일은 프로젝트 개발 단계 이전에 결정하는 것이 좋습니다.\n왜냐하면 애플리케이션이 운영중인 상태에서는 제공되는 URL을 기준으로 사용자가 접근하기 때문입니다.</p>\n<p>대부분의 Angular 프로젝트는 기본 HTML5 스타일을 따릅니다.\n이 스타일을 사용하면 사용자가 주소를 이해하기 쉽고 서버사이드 렌더링을 적용하기도 쉽습니다.</p>\n<p>앱 페이지를 서버에서 미리 렌더링하고 제공하는 방식은 애플리케이션의 초기 실행 속도를 높이는 데에 큰 도움이 됩니다.\n서버에서 렌더링하는 데 10초 이상이 걸리더라도 이 페이지가 미리 렌더링 된 후에 사용자 디바이스에서 실행되는 것은 1초도 걸리지 않습니다.</p>\n<p>하지만 이 방식은 중간에 해시 기호(<code>#</code>)가 없는 URL 스타일일때만 가능합니다.</p>\n<h2 id=\"base-href-1\"><code>&#x3C;base href></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#base-href-1\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe router uses the browser's <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries\" title=\"HTML5 browser history push-state\">history.pushState</a> for navigation.\n`pushState` allows you to customize in-app URL paths; for example, `localhost:4200/crisis-center`.\nThe in-app URLs can be indistinguishable from server URLs.\n\nModern HTML5 browsers were the first to support `pushState` which is why many people refer to these URLs as \"HTML5 style\" URLs.\n\n<div class=\"alert is-helpful\">\n\nHTML5 style navigation is the router default.\nIn the [LocationStrategy and browser URL styles](#browser-url-styles) section, learn why HTML5 style is preferable, how to adjust its behavior, and how to switch to the older hash (#) style, if necessary.\n\n</div>\n\nYou must add a <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base\" title=\"base href\">&lt;base href&gt; element</a> to the app's `index.html` for `pushState` routing to work.\nThe browser uses the `<base href>` value to prefix relative URLs when referencing CSS files, scripts, and images.\n\nAdd the `<base>` element just after the  `<head>` tag.\nIf the `app` folder is the application root, as it is for this application,\nset the `href` value in `index.html` as shown here.\n\n<code-example path=\"router/src/index.html\" header=\"src/index.html (base-href)\" region=\"base-href\">\n&lt;base href=&quot;/&quot;&gt;\n\n</code-example>\n-->\n<p>브라우저는 화면을 전환할 때 브라우저의 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries\" title=\"HTML5 browser history push-state\">history.pushState</a>를 활용합니다.\n<code>pushState</code>를 활용하면 앱 URL 주소를 <code>localhost:4200/crisis-center</code> 처럼 구성할 수 있습니다.\n앱 안에서 사용하는 URL과 서버에 요청하는 URL은 다릅니다.</p>\n<p>최근에는 사용자들이 HTML5 스타일로 URL을 사용하기 때문에 최신 HTML5 브라우저도 대부분 <code>pushState</code>를 제공하고 있습니다.</p>\n<div class=\"alert is-helpful\">\n<p>HTML5 스타일로 URL을 구성하는 것이 라우터 기본 설정입니다.\n그리고 <a href=\"guide/router#browser-url-styles\">LocationStrategy, 브라우저 URL 스타일</a> 섹션에서 설명한 것처럼 HTML5 스타일을 사용하는 것이 좋지만, 필요하다면 이전 스타일(<code>#</code>)을 사용할 수도 있습니다.</p>\n</div>\n<p><code>pushState</code> 방식으로 화면을 전환하려면 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base\" title=\"base href\">&#x3C;base href> 엘리먼트</a>를 반드시 <code>index.html</code> 파일에 설정해야 합니다.\n앱에서 상대 URL로 무언가를 요청하면 <code>&#x3C;base href></code>에 지정된 값에 따라 CSS 파일이나 스크립트 파일, 이미지 파일을 로드합니다.</p>\n<p><code>&#x3C;base></code> 엘리먼트는 <code>&#x3C;head></code> 태그 바로 뒤에 추가합니다.\n애플리케이션 최상위 경로가 <code>app</code> 폴더라면 <code>index.html</code> 파일을 이렇게 지정하면 됩니다:</p>\n<code-example path=\"router/src/index.html\" header=\"src/index.html (base-href)\" region=\"base-href\">\n&#x3C;base href=\"/\">\n\n</code-example>\n<!--\n### HTML5 URLs and the  `<base href>`\n-->\n<h3 id=\"html5-url-base-href\">HTML5 URL, <code>&#x3C;base href></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#html5-url-base-href\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe guidelines that follow will refer to different parts of a URL. This diagram outlines what those parts refer to:\n\n```\nfoo://example.com:8042/over/there?name=ferret#nose\n\\_/   \\______________/\\_________/ \\_________/ \\__/\n |           |            |            |        |\nscheme    authority      path        query   fragment\n```\n\nWhile the router uses the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries\" title=\"Browser history push-state\">HTML5 pushState</a> style by default, you must configure that strategy with a `<base href>`.\n\nThe preferred way to configure the strategy is to add a <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base\" title=\"base href\">&lt;base href&gt; element</a> tag in the `<head>` of the `index.html`.\n\n<code-example path=\"router/src/index.html\" header=\"src/index.html (base-href)\" region=\"base-href\">\n&lt;base href=&quot;/&quot;&gt;\n\n</code-example>\n\nWithout that tag, the browser may not be able to load resources\n(images, CSS, scripts) when \"deep linking\" into the app.\n\nSome developers may not be able to add the `<base>` element, perhaps because they don't have access to `<head>` or the `index.html`.\n\nThose developers may still use HTML5 URLs by taking the following two steps:\n\n1. Provide the router with an appropriate `APP_BASE_HREF` value.\n1. Use root URLs (URLs with an `authority`) for all web resources: CSS, images, scripts, and template HTML files.\n\n* The `<base href>` `path` should end with a \"/\", as browsers ignore characters in the `path` that follow the right-most \"/\".\n* If the `<base href>` includes a `query` part, the `query` is only used if the `path` of a link in the page is empty and has no `query`.\nThis means that a `query` in the `<base href>` is only included when using `HashLocationStrategy`.\n* If a link in the page is a root URL (has an `authority`), the `<base href>` is not used. In this way, an `APP_BASE_HREF` with an authority will cause all links created by Angular to ignore the `<base href>` value.\n* A fragment in the `<base href>` is _never_ persisted.\n\nFor more complete information on how `<base href>` is used to construct target URIs, see the [RFC](https://tools.ietf.org/html/rfc3986#section-5.2.2) section on transforming references.\n-->\n<p>URL은 여러가지 요소로 구성되며, URL의 각 영역은 이렇게 나눠볼 수 있습니다:</p>\n<code-example>\nfoo://example.com:8042/over/there?name=ferret#nose\n\\_/   \\______________/\\_________/ \\_________/ \\__/\n |           |            |            |        |\n스킴       도메인        경로         쿼리    프래그먼트\n</code-example>\n<p>기본적으로 Angular 라우터는 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries\" title=\"Browser history push-state\">HTML5 pushState</a> 스타일을 사용하기 때문에 <code>index.html</code> 파일의 <code>&#x3C;head></code> 안에 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base\" title=\"base href\"><code>&#x3C;base href></code></a>를 꼭 지정해야 합니다.</p>\n<code-example path=\"router/src/index.html\" header=\"src/index.html (base-href)\" region=\"base-href\">\n&#x3C;base href=\"/\">\n\n</code-example>\n<p>이 태그가 없으면 브라우저가 로드하는 이미지 파일이나 CSS, 스크립트 파일을 앱 딥 링크(deep link)와 구별할 수 없습니다.</p>\n<p>때로는 <code>index.html</code> 파일이나 <code>&#x3C;head></code> 엘리먼트를 수정할 수 있는 권한이 없는 경우가 있습니다.</p>\n<p>이런 경우에도 HTML5 방식으로 URL을 다루려면 이렇게 하면 됩니다:</p>\n<ol>\n<li>라우터에 <code>APP_BVASE_HREF</code> 옵션을 지정합니다.</li>\n<li>CSS 파일, 이미지 파일, 스크립트 파일, 템플릿 파일 등 모든 리소스에 도메인부터 시작하는 주소를 사용합니다.</li>\n</ol>\n<ul>\n<li><code>&#x3C;base href></code> <code>path</code>는 반드시 \"/\"로 끝나야 합니다. 브라우저는 <code>path</code> 가장 마지막에 사용된 \"/\"는 자동으로 제거합니다.</li>\n<li><code>&#x3C;base href></code>에 쿼리 부분이 추가되면 이 쿼리는 현재 화면에 지정된 경로가 없거나 쿼리가 없는 경우에만 동작합니다.\n이 말은, <code>&#x3C;base href></code>에 사용된 쿼리는 <code><a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a></code>를 사용했을 때만 사용된다는 것을 의미합니다.</li>\n<li>현재 접속한 URL이 최상위 URL(도메인 기본 URL)이라면 <code>&#x3C;base href></code>는 사용되지 않습니다. 이 경우에 Angular는 <code>&#x3C;base href></code>를 무시하고 <code><a href=\"api/common/APP_BASE_HREF\" class=\"code-anchor\">APP_BASE_HREF</a></code>에 설정된 값으로 링크를 처리합니다.</li>\n<li><code>&#x3C;base href></code>에 사용된 프래그먼트는 <em>절대</em> 사용되지 않습니다.</li>\n</ul>\n<p><code>&#x3C;base href></code>이 어떻게 동작하는지, URI을 구성할 때 어떻게 활용되는지 확인하려면 <a href=\"https://tools.ietf.org/html/rfc3986#section-5.2.2\">RFC</a> 문서를 참고하세요.</p>\n<a id=\"hashlocationstrategy\"></a>\n<h3 id=\"hashlocationstrategy\"><code><a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#hashlocationstrategy\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou can use `HashLocationStrategy` by providing the `useHash: true` in an object as the second argument of the `RouterModule.forRoot()` in the `AppModule`.\n\n<code-example path=\"router/src/app/app.module.6.ts\" header=\"src/app/app.module.ts (hash URL strategy)\">\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { BrowserModule } from &#39;@angular/platform-browser&#39;;\nimport { FormsModule } from &#39;@angular/forms&#39;;\nimport { Routes, RouterModule } from &#39;@angular/router&#39;;\n\nimport { AppComponent } from &#39;./app.component&#39;;\nimport { PageNotFoundComponent } from &#39;./page-not-found/page-not-found.component&#39;;\n\nconst routes: Routes = [\n\n];\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    FormsModule,\n    RouterModule.forRoot(routes, { useHash: true })  // .../#/crisis-center/\n  ],\n  declarations: [\n    AppComponent,\n    PageNotFoundComponent\n  ],\n  providers: [\n\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n\n</code-example>\n-->\n<p><code>AppModule</code>에서 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code>를 실행할 때 <code>useHash: true</code> 옵션을 지정하는 방법으로도 <code><a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a></code> 정책을 사용할 수 있습니다.</p>\n<code-example path=\"router/src/app/app.module.6.ts\" header=\"src/app/app.module.ts (해시 URL 정책)\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a>, <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a> } from '@angular/router';\n\nimport { AppComponent } from './app.component';\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\n\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    RouterModule.forRoot(routes, { useHash: true })  // .../#/crisis-center/\n  ],\n  declarations: [\n    AppComponent,\n    PageNotFoundComponent\n  ],\n  providers: [\n\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n\n</code-example>\n<!--\n## Router Reference\n-->\n<h2 id=\"라우터-활용\">라우터 활용<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#라우터-활용\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe folllowing sections highlight some core router concepts.\n-->\n<p>아래 섹션들은 Angular 라우터의 개념 중 중요한 내용에 대해 설명합니다.</p>\n<a id=\"basics-router-imports\"></a>\n<!--\n### Router imports\n-->\n<h3 id=\"라우터-로드하기\">라우터 로드하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#라우터-로드하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe Angular Router is an optional service that presents a particular component view for a given URL.\nIt is not part of the Angular core and thus is in its own library package, `@angular/router`.\n\nImport what you need from it as you would from any other Angular package.\n\n<code-example path=\"router/src/app/app.module.1.ts\" header=\"src/app/app.module.ts (import)\" region=\"import-router\">\nimport { RouterModule, Routes } from &#39;@angular/router&#39;;\n\n</code-example>\n\n\n<div class=\"alert is-helpful\">\n\nFor more on browser URL styles, see [`LocationStrategy` and browser URL styles](#browser-url-styles).\n\n</div>\n-->\n<p>라우터는 URL이 변화하는 것을 감지해서 각 상황마다 적절한 컴포넌트를 화면에 표현하는 서비스입니다.\n그리고 이 서비스는 필수로 도입해야 하는 서비스가 아니기 때문에 <code>@angular/core</code> 패키지가 아니라 <code>@angular/router</code> 라이브러리 패키지로 제공됩니다.</p>\n<p>라우터를 사용하려면 다음과 같이 로드하면 됩니다:</p>\n<code-example path=\"router/src/app/app.module.1.ts\" header=\"src/app/app.module.ts (로드하기)\" region=\"import-router\">\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>URL 구성 스타일에 대해 자세하게 알아보려면 <a href=\"guide/router#browser-url-styles\"><code>LocationStrategy</code>, 브라우저 URL 스타일</a> 섹션을 참고하세요.</p>\n</div>\n<a id=\"basics-config\"></a>\n<a id=\"configuration\"></a>\n<!--\n### Configuration\n-->\n<h3 id=\"라우터-설정하기\">라우터 설정하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#라우터-설정하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nA routed Angular application has one singleton instance of the `Router` service.\nWhen the browser's URL changes, that router looks for a corresponding `Route` from which it can determine the component to display.\n\nA router has no routes until you configure it.\nThe following example creates five route definitions, configures the router via the `RouterModule.forRoot()` method, and adds the result to the `AppModule`'s `imports` array.\n\n<code-example path=\"router/src/app/app.module.0.ts\" header=\"src/app/app.module.ts (excerpt)\">\nconst appRoutes: Routes = [\n  { path: &#39;crisis-center&#39;, component: CrisisListComponent },\n  { path: &#39;hero/:id&#39;,      component: HeroDetailComponent },\n  {\n    path: &#39;heroes&#39;,\n    component: HeroListComponent,\n    data: { title: &#39;Heroes List&#39; }\n  },\n  { path: &#39;&#39;,\n    redirectTo: &#39;/heroes&#39;,\n    pathMatch: &#39;full&#39;\n  },\n  { path: &#39;**&#39;, component: PageNotFoundComponent }\n];\n\n@NgModule({\n  imports: [\n    RouterModule.forRoot(\n      appRoutes,\n      { enableTracing: true } // &lt;-- 디버그 활성화\n    )\n    // 다른 모듈 로드\n  ],\n  ...\n})\nexport class AppModule { }\n\n</code-example>\n-->\n<p>라우터가 적용된 Angular 애플리케이션은 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 서비스 인스턴스를 싱글턴으로 관리합니다.\n그리고 브라우저 URL이 변경되면 라우터가 해당 URL과 관련된 라우팅 규칙(<code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code>)를 찾아 어떤 컴포넌트를 화면에 표시할지 결정합니다.</p>\n<p>라우터를 설정하기 전에는 라우팅 규칙이 아무것도 등록되어 있지 않습니다.\n아래 예제 코드는 라우팅 규칙 5개를 정의하고, 이 라우팅 규칙을 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 함수에 인자로 전달한 후에, <code>AppModule</code> <code>imports</code> 배열에 등록하는 예제 코드입니다.</p>\n<code-example path=\"router/src/app/app.module.0.ts\" header=\"src/app/app.module.ts (일부)\">\nconst appRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'crisis-center', component: CrisisListComponent },\n  { path: 'hero/:id',      component: HeroDetailComponent },\n  {\n    path: 'heroes',\n    component: HeroListComponent,\n    data: { title: 'Heroes List' }\n  },\n  { path: '',\n    redirectTo: '/heroes',\n    pathMatch: 'full'\n  },\n  { path: '**', component: PageNotFoundComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forRoot(\n      appRoutes,\n      { enableTracing: true } // &#x3C;-- 디버그 활성화\n    )\n    // 다른 모듈 로드\n  ],\n  ...\n})\nexport class AppModule { }\n\n</code-example>\n<a id=\"example-config\"></a>\n<!--\nThe `appRoutes` array of routes describes how to navigate.\nPass it to the `RouterModule.forRoot()` method in the module `imports` to configure the router.\n\nEach `Route` maps a URL `path` to a component.\nThere are no leading slashes in the path.\nThe router parses and builds the final URL for you, which allows you to use both relative and absolute paths when navigating between application views.\n\nThe `:id` in the second route is a token for a route parameter.\nIn a URL such as `/hero/42`, \"42\" is the value of the `id` parameter.\nThe corresponding `HeroDetailComponent` uses that value to find and present the hero whose `id` is 42.\n\nThe `data` property in the third route is a place to store arbitrary data associated with\nthis specific route.\nThe data property is accessible within each activated route. Use it to store items such as page titles, breadcrumb text, and other read-only, static data.\nYou can use the [resolve guard](guide/router-tutorial-toh#resolve-guard) to retrieve dynamic data.\n\nThe empty path in the fourth route represents the default path for the application&mdash;the place to go when the path in the URL is empty, as it typically is at the start.\nThis default route redirects to the route for the `/heroes` URL and, therefore, displays the `HeroesListComponent`.\n\nIf you need to see what events are happening during the navigation lifecycle, there is the `enableTracing` option as part of the router's default configuration.\nThis outputs each router event that took place during each navigation lifecycle to the browser console.\nUse `enableTracing` only for debugging purposes.\nYou set the `enableTracing: true` option in the object passed as the second argument to the `RouterModule.forRoot()` method.\n-->\n<p><code>appRoutes</code> 배열에 라우팅 규칙을 등록하면 라우터가 화면을 어떻게 전환할지 지정할 수 있습니다.\n이 배열은 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 메서드에 인자로 전달 한 후에 메서드 실행 결과를 NgModule <code>imports</code> 배열에 등록하면 됩니다.</p>\n<p>개별 <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code>는 URL <code>path</code>와 컴포넌트를 연결합니다.\n그리고 이 때 지정하는 경로는 슬래시(<code>/</code>)로 시작하지 않습니다.\nAngular 애플리케이션 안에서 상대주소와 절대 주소를 자유롭게 사용할 수 있습니다.</p>\n<p>두 번째 라우팅 규칙에 사용된 <code>:id</code>는 라우팅 인자로 활용하는 토큰입니다.\n그래서 URL이 <code>/hero/42</code>와 같이 구성되면 \"42\"가 <code>id</code> 인자로 전달됩니다.\n<code>HeroDetailComponent</code>는 히어로 목록 중 <code>id</code>가 42에 해당하는 히어로 상세정보를 참조하면 됩니다.</p>\n<p>세번째 라우팅 규칙에 사용된 <code>data</code> 프로퍼티는 해당 라우팅 규칙이 실행될 때 사용될 데이터를 지정한 것입니다.\n이 데이터 프로퍼티는 활성화된 라우팅 규칙(<code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>)으로 참조할 수 있습니다.\n이 프로퍼티에는 보통 화면 타이틀이나 브레드크럼(breadcrumb) 텍스트와 같은 읽기 전용 데이터나 정적 데이터를 저장합니다.\n동적 데이터를 가져와야 한다면 <a href=\"guide/router-tutorial-toh#resolve-guard\">리졸브 가드(resolve guard)</a> 문서를 참고하세요.</p>\n<p>네번째 라우팅 규칙에 사용된 빈 경로는 애플리케이션 기본 주소를 의미합니다.\n애플리케이션에 처음 접속하면 빈 URL을 만나게 되는데, 이 라우팅 규칙은 이 때 사용됩니다.\n이 예제 코드에서는 기본 주소로 접속했을 때 <code>/heroes</code> URL로 이동하도록 지정했기 때문에 <code>HeroesListComponent</code>가 표시될 것입니다.</p>\n<p>네비게이션이 동작하는 동안 어떤 이벤트가 발생하는지 확인하려면 라우터를 설정할 때 <code>enableTracing</code> 옵션을 활성화하면 됩니다.\n그러며 네비게이션의 각 라이프싸이클이 실행될 때마다 관련 로그가 브라우저 콘솔에 표시됩니다.\n<code>enableTracing</code> 옵션은 디버깅용으로만 사용하세요.\n<code>enableTracing: true</code> 옵션은 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 메서드의 두번째 인자로 지정합니다.</p>\n<a id=\"basics-router-outlet\"></a>\n<!--\n### Router outlet\n-->\n<h3 id=\"라우팅-영역router-outlet\">라우팅 영역(router outlet)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#라우팅-영역router-outlet\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe `RouterOutlet` is a directive from the router library that is used like a component.\nIt acts as a placeholder that marks the spot in the template where the router should\ndisplay the components for that outlet.\n\n<code-example language=\"html\">\n  &lt;router-outlet>&lt;/router-outlet&gt;\n  &lt;!-- Routed components go here --&gt;\n\n</code-example>\n\nGiven the configuration above, when the browser URL for this application becomes `/heroes`, the router matches that URL to the route path `/heroes` and displays the `HeroListComponent` as a sibling element to the `RouterOutlet` that you've placed in the host component's template.\n-->\n<p><code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>은 라우터가 컴포넌트를 표시할 때 사용하는 디렉티브입니다.\n이 디렉티브를 일반 컴포넌트처럼 사용하면 라우터가 컴포넌트를 화면에 표시할 때 이 디렉티브가 위치한 곳에 컴포넌트 템플릿을 렌더링합니다.</p>\n<code-example language=\"html\">\n  &#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n  &#x3C;!-- 라우팅 규칙에 해당하는 컴포넌트가 여기에 표시됩니다. -->\n\n</code-example>\n<p>이렇게 구현하면 브라우저 URL이 <code>/heroes</code>가 되었을 때 라우터가 해당 URL에 해당하는 라우팅 규칙을 찾은 후에 <code>HeroListComponent</code>를 화면에 표시하는데, 이 때 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>이 있는 근처에 <code>HeroListComponent</code> 템플릿이 표시됩니다.</p>\n<a id=\"basics-router-links\"></a>\n<a id=\"router-link\"></a>\n<!--\n### Router links\n-->\n<h3 id=\"라우터-링크routerlink\">라우터 링크(<code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#라우터-링크routerlink\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nTo navigate as a result of some user action such as the click of an anchor tag, use `RouterLink`.\n\nConsider the following template:\n\n<code-example path=\"router/src/app/app.component.1.html\" header=\"src/app/app.component.html\">\n&lt;h1&gt;Angular Router&lt;/h1&gt;\n&lt;nav&gt;\n  &lt;a routerLink=&quot;/crisis-center&quot; routerLinkActive=&quot;active&quot;&gt;Crisis Center&lt;/a&gt;\n  &lt;a routerLink=&quot;/heroes&quot; routerLinkActive=&quot;active&quot;&gt;Heroes&lt;/a&gt;\n&lt;/nav&gt;\n&lt;router-outlet&gt;&lt;/router-outlet&gt;\n\n</code-example>\n\nThe `RouterLink` directives on the anchor tags give the router control over those elements.\nThe navigation paths are fixed, so you can assign a string to the `routerLink` (a \"one-time\" binding).\n\nHad the navigation path been more dynamic, you could have bound to a template expression that returned an array of route link parameters; that is, the [link parameters array](guide/router#link-parameters-array).\nThe router resolves that array into a complete URL.\n-->\n<p>사용자가 앵커 태그(<code>&#x3C;a></code>)를 클릭할 때 다른 화면으로 이동하려면 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>를 사용하면 됩니다.</p>\n<p>이런 템플릿이 있다고 합시다:</p>\n<code-example path=\"router/src/app/app.component.1.html\" header=\"src/app/app.component.html\">\n&#x3C;h1>Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>&#x3C;/h1>\n&#x3C;nav>\n  &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/crisis-center\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Crisis Center&#x3C;/a>\n  &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/heroes\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Heroes&#x3C;/a>\n&#x3C;/nav>\n&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n\n</code-example>\n<p>앵커 태그에 사용된 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 디렉티브는 앵커 앨리먼트의 조작 권한을 라우터로 넘기는 역할을 합니다.\n이동하려는 주소가 고정되어 있으면 이 주소를 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code>에 문자열로 바인딩하면 되는데, 이 문자열은 한 번만 바인딩되며 이후에는 계속 고정된 값이 사용됩니다.</p>\n<p>이동하려는 주소가 동적으로 구성된다면 라우터 링크 인자를 배열 형태로 반환하는 템플릿 표현식을 바인딩하면 됩니다.\n이런 배열을 <a href=\"guide/router#link-parameters-array\">링크 인자 배열(link parameters array)</a>이라고 합니다.\n라우터는 이 배열을 파싱해서 최종 URL을 구성합니다.</p>\n<a id=\"router-link-active\"></a>\n<!--\n### Active router links\n-->\n<h3 id=\"라우터-링크-활성화하기routerlinkactive\">라우터 링크 활성화하기(<code><a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">RouterLinkActive</a></code>)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#라우터-링크-활성화하기routerlinkactive\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe `RouterLinkActive` directive toggles CSS classes for active `RouterLink` bindings based on the current `RouterState`.\n\nOn each anchor tag, you see a [property binding](guide/property-binding) to the `RouterLinkActive` directive that looks like `routerLinkActive=\"...\"`.\n\nThe template expression to the right of the equal sign, `=`, contains a space-delimited string of CSS classes that the Router adds when this link is active (and removes when the link is inactive).\nYou set the `RouterLinkActive` directive to a string of classes such as `[routerLinkActive]=\"'active fluffy'\"` or bind it to a component property that returns such a string.\n\nActive route links cascade down through each level of the route tree, so parent and child router links can be active at the same time.\nTo override this behavior, you can bind to the `[routerLinkActiveOptions]` input binding with the `{ exact: true }` expression. By using `{ exact: true }`, a given `RouterLink` will only be active if its URL is an exact match to the current URL.\n-->\n<p><code><a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">RouterLinkActive</a></code> 디렉티브는 <code><a href=\"api/router/RouterState\" class=\"code-anchor\">RouterState</a></code>의 현재 상태에 따라 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>가 적용된 엘리먼트에 CSS 클래스를 지정하는 디렉티브입니다.</p>\n<p>이 디렉티브는 앵커 태그에 각각 설정하며, <code><a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"...\"</code>와 같은 방식으로 <a href=\"guide/property-binding\">프로퍼티 바인딩</a>해서 사용합니다.</p>\n<p>이 때 템플릿 표현식의 등호(<code>=</code>) 오른쪽에는 스페이스로 구분되는 CSS 클래스 목록을 문자열로 추가하는데, 해당 링크가 활성화되면 지정된 CSS 클래스가 추가되고, 해당 링크가 비활성화되면 지정된 CSS 클래스가 엘리먼트에서 제거됩니다.\n그리고 <code>[<a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>]=\"'active fluffy'\"</code>와 같은 문법 뿐 아니라 문자열을 반환하는 컴포넌트 프로퍼티를 바인딩할 수도 있습니다.</p>\n<p>라우터 링크를 활성화하는 동작은 라우팅 규칙 트리를 따라 내려가며 부모 라우터와 자식 라우터에 모두 영향을 미치기 때문에 한번에 여러 링크가 활성화될 수도 있습니다.\n이런 상황을 방지하려면 <code>[routerLinkActiveOptions]</code>에 <code>{ exact: true }</code> 옵션을 지정하면 됩니다.\n<code>{ exact: true }</code> 옵션을 지정하면 라우팅 규칙과 브라우저 URL이 정확하게 일치할 때만 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>를 활성화시킵니다.</p>\n<a id=\"basics-router-state\"></a>\n<!--\n### Router state\n-->\n<h3 id=\"라우터-상태routerstate\">라우터 상태(<code><a href=\"api/router/RouterState\" class=\"code-anchor\">RouterState</a></code>)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#라우터-상태routerstate\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAfter the end of each successful navigation lifecycle, the router builds a tree of `ActivatedRoute` objects that make up the current state of the router. You can access the current `RouterState` from anywhere in the application using the `Router` service and the `routerState` property.\n\nEach `ActivatedRoute` in the `RouterState` provides methods to traverse up and down the route tree to get information from parent, child and sibling routes.\n-->\n<p>네비게이션 라이프싸이클의 각 단계가 끝나면 라우터가 각 계층의 라우터 상태를 모아 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 트리 객체를 구성합니다.\n이 때 구성되는 <code><a href=\"api/router/RouterState\" class=\"code-anchor\">RouterState</a></code>는 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 서비스가 제공하는 <code>routerState</code> 프로퍼티로 참조할 수 있습니다.</p>\n<p><code><a href=\"api/router/RouterState\" class=\"code-anchor\">RouterState</a></code>에 있는 개별 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>는 라우팅 규칙 트리에 따라 위쪽이나 아래쪽으로 이동할 수 있기 때문에, 부모/자식/이웃 라우팅 규칙에 대한 정보도 참조할 수 있습니다.</p>\n<a id=\"activated-route\"></a>\n<!--\n### Activated route\n-->\n<h3 id=\"활성화된-라우팅-규칙activatedroute\">활성화된 라우팅 규칙(<code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#활성화된-라우팅-규칙activatedroute\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe route path and parameters are available through an injected router service called the [ActivatedRoute](api/router/ActivatedRoute).\nIt has a great deal of useful information including:\n\n<table>\n  <tr>\n    <th>\n      Property\n    </th>\n\n    <th>\n      Description\n    </th>\n  </tr>\n\n  <tr>\n    <td>\n      <code>url</code>\n    </td>\n    <td>\n\n    An `Observable` of the route path(s), represented as an array of strings for each part of the route path.\n\n    </td>\n  </tr>\n\n  <tr>\n    <td>\n      <code>data</code>\n    </td>\n    <td>\n\n    An `Observable` that contains the `data` object provided for the route.\n    Also contains any resolved values from the [resolve guard](guide/router-tutorial-toh#resolve-guard).\n\n    </td>\n  </tr>\n\n  <tr>\n    <td>\n      <code>paramMap</code>\n    </td>\n    <td>\n\n    An `Observable` that contains a [map](api/router/ParamMap) of the required and [optional parameters](guide/router-tutorial-toh#optional-route-parameters) specific to the route.\n    The map supports retrieving single and multiple values from the same parameter.\n\n    </td>\n  </tr>\n\n  <tr>\n    <td>\n      <code>queryParamMap</code>\n    </td>\n    <td>\n\n    An `Observable` that contains a [map](api/router/ParamMap) of the [query parameters](guide/router-tutorial-toh#query-parameters) available to all routes.\n    The map supports retrieving single and multiple values from the query parameter.\n\n    </td>\n  </tr>\n\n  <tr>\n    <td>\n      <code>fragment</code>\n    </td>\n    <td>\n\n    An `Observable` of the URL [fragment](guide/router-tutorial-toh#fragment) available to all routes.\n\n    </td>\n  </tr>\n\n  <tr>\n    <td>\n      <code>outlet</code>\n    </td>\n    <td>\n\n    The name of the `RouterOutlet` used to render the route.\n    For an unnamed outlet, the outlet name is primary.\n\n    </td>\n  </tr>\n\n  <tr>\n    <td>\n      <code>routeConfig</code>\n    </td>\n    <td>\n\n    The route configuration used for the route that contains the origin path.\n\n    </td>\n  </tr>\n\n    <tr>\n    <td>\n      <code>parent</code>\n    </td>\n    <td>\n\n    The route's parent `ActivatedRoute` when this route is a [child route](guide/router-tutorial-toh#child-routing-component).\n\n    </td>\n  </tr>\n\n  <tr>\n    <td>\n      <code>firstChild</code>\n    </td>\n    <td>\n\n    Contains the first `ActivatedRoute` in the list of this route's child routes.\n\n    </td>\n  </tr>\n\n  <tr>\n    <td>\n      <code>children</code>\n    </td>\n    <td>\n\n    Contains all the [child routes](guide/router-tutorial-toh#child-routing-component) activated under the current route.\n\n    </td>\n  </tr>\n</table>\n\n<div class=\"alert is-helpful\">\n\nTwo older properties are still available, however, their replacements are preferable as they may be deprecated in a future Angular version.\n\n* `params`: An `Observable` that contains the required and [optional parameters](guide/router-tutorial-toh#optional-route-parameters) specific to the route. Use `paramMap` instead.\n\n* `queryParams`: An `Observable` that contains the [query parameters](guide/router-tutorial-toh#query-parameters) available to all routes.\nUse `queryParamMap` instead.\n\n</div>\n-->\n<p>현재 화면에 적용된 라우팅 규칙에 대한 정보는 <a href=\"api/router/ActivatedRoute\">ActivatedRoute</a> 객체로 참조할 수 있습니다.\n이 객체는 이런 정보를 담고 있습니다:</p>\n<table>\n  <tbody><tr>\n    <th>\n      프로퍼티\n    </th>\n    <th>\n      설명\n    </th>\n  </tr>\n  <tr>\n    <td>\n      <code>url</code>\n    </td>\n    <td>\n<p>      라우팅 규칙에 지정된 주소를 <code>Observable</code> 형태로 반환합니다.\n이 때 옵저버블로 전달되는 데이터는 배열 형태이며, 이 배열에는 라우팅 경로의 각 구성요소가 개별 문자열로 담겨 있습니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>data</code>\n    </td>\n    <td>\n<p>      라우팅 규칙에 지정된 <code>data</code> 객체를 <code>Observable</code> 형태로 반환합니다.\n이 객체에는 <a href=\"guide/router-tutorial-toh#resolve-guard\">리졸브 가드(resolve guard)</a> 처리결과가 함께 전달될 수도 있습니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>paramMap</code>\n    </td>\n    <td>\n<p>      라우팅 규칙에 지정된 <a href=\"guide/router-tutorial-toh#optional-route-parameters\">라우팅 변수</a>를 <a href=\"api/router/ParamMap\">map</a>으로 구성해서 <code>Observable</code> 형태로 반환합니다.\n변수 하나에 해당하는 값은 여러개일 수 있습니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>queryParamMap</code>\n    </td>\n    <td>\n<p>      <a href=\"guide/router-tutorial-toh#query-parameters\">쿼리 변수(query parameters)</a>를 <a href=\"api/router/ParamMap\">map</a>으로 구성해서 <code>Observable</code> 형태로 반환합니다.\n쿼리 변수에 해당하는 값은 여러개일 수 있습니다.\n이 프로퍼티는 모든 라우팅 규칙에 존재합니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>fragment</code>\n    </td>\n    <td>\n<p>      URL <a href=\"guide/router-tutorial-toh#fragment\">프래그먼트</a>를 <code>Observable</code> 형태로 반환합니다.\n이 프로퍼티는 모든 라우팅 규칙에 존재합니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>outlet</code>\n    </td>\n    <td>\n<p>      라우팅 규칙이 렌더링할 때 사용한 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>의 이름을 반환합니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>routeConfig</code>\n    </td>\n    <td>\n<p>      라우팅 규칙의 설정 정보를 반환합니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>parent</code>\n    </td>\n    <td>\n<p>      현재 라우팅 규칙이 <a href=\"guide/router-tutorial-toh#child-routing-component\">자식 라우팅 규칙</a>인 경우에 현재 라우팅 규칙의 부모 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>를 반환합니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>firstChild</code>\n    </td>\n    <td>\n<p>      현재 라우팅 규칙에 자식 라우팅 규칙이 존재할 때 첫번째 자식 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>를 반환합니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>children</code>\n    </td>\n    <td>\n<p>      현재 라우팅 규칙에 존재하는 모든 <a href=\"guide/router-tutorial-toh#child-routing-component\">자식 라우팅 규칙</a>을 반환합니다.</p>\n    </td>\n  </tr>\n</tbody></table>\n<div class=\"alert is-helpful\">\n<p>예전에 사용하던 프로퍼티 2개가 아직 제공되고 있기는 하지만, 이 프로퍼티들은 사용하지 않는 것을 권장합니다.\n이후 Angular 버전에서는 제거될 수 있습니다.</p>\n<ul>\n<li>\n<p><code>params</code>: 라우팅 규칙에 포함된 <a href=\"guide/router-tutorial-toh#optional-route-parameters\">라우팅 변수</a>를 <code>Observable</code> 형태로 제공합니다. 이 프로퍼티 대신 <code>paramMap</code>을 사용하세요.</p>\n</li>\n<li>\n<p><code>queryParams</code>: 라우팅 규칙에 포함된 <a href=\"guide/router-tutorial-toh#query-parameters\">쿼리 변수</a>를 <code>Observable</code> 형태로 제공합니다. 이 프로퍼티 대신 <code>queryParamMap</code>을 사용하세요.</p>\n</li>\n</ul>\n</div>\n<a id=\"router-events\"></a>\n<!--\n### Router events\n-->\n<h3 id=\"라우터-이벤트\">라우터 이벤트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#라우터-이벤트\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nDuring each navigation, the `Router` emits navigation events through the `Router.events` property.\nThese events range from when the navigation starts and ends to many points in between. The full list of navigation events is displayed in the table below.\n\n<table>\n  <tr>\n    <th>\n      Router Event\n    </th>\n\n    <th>\n      Description\n    </th>\n  </tr>\n\n  <tr>\n    <td>\n      <code>NavigationStart</code>\n    </td>\n    <td>\n\n      An [event](api/router/NavigationStart) triggered when navigation starts.\n\n    </td>\n  </tr>\n\n  <tr>\n    <td>\n      <code>RouteConfigLoadStart</code>\n    </td>\n    <td>\n\n      An [event](api/router/RouteConfigLoadStart) triggered before the `Router`\n      [lazy loads](guide/router-tutorial-toh#asynchronous-routing) a route configuration.\n\n    </td>\n  </tr>\n\n  <tr>\n    <td>\n      <code>RouteConfigLoadEnd</code>\n    </td>\n    <td>\n\n      An [event](api/router/RouteConfigLoadEnd) triggered after a route has been lazy loaded.\n\n    </td>\n  </tr>\n\n  <tr>\n    <td>\n      <code>RoutesRecognized</code>\n    </td>\n    <td>\n\n      An [event](api/router/RoutesRecognized) triggered when the Router parses the URL and the routes are recognized.\n\n    </td>\n  </tr>\n\n  <tr>\n    <td>\n      <code>GuardsCheckStart</code>\n    </td>\n    <td>\n\n      An [event](api/router/GuardsCheckStart) triggered when the Router begins the Guards phase of routing.\n\n    </td>\n  </tr>\n\n  <tr>\n    <td>\n      <code>ChildActivationStart</code>\n    </td>\n    <td>\n\n      An [event](api/router/ChildActivationStart) triggered when the Router begins activating a route's children.\n\n    </td>\n  </tr>\n\n  <tr>\n    <td>\n      <code>ActivationStart</code>\n    </td>\n    <td>\n\n      An [event](api/router/ActivationStart) triggered when the Router begins activating a route.\n\n    </td>\n  </tr>\n\n  <tr>\n    <td>\n      <code>GuardsCheckEnd</code>\n    </td>\n    <td>\n\n      An [event](api/router/GuardsCheckEnd) triggered when the Router finishes the Guards phase of routing successfully.\n\n    </td>\n  </tr>\n\n  <tr>\n    <td>\n      <code>ResolveStart</code>\n    </td>\n    <td>\n\n      An [event](api/router/ResolveStart) triggered when the Router begins the Resolve phase of routing.\n\n    </td>\n  </tr>\n\n  <tr>\n    <td>\n      <code>ResolveEnd</code>\n    </td>\n    <td>\n\n      An [event](api/router/ResolveEnd) triggered when the Router finishes the Resolve phase of routing successfuly.\n\n    </td>\n  </tr>\n\n  <tr>\n    <td>\n      <code>ChildActivationEnd</code>\n    </td>\n    <td>\n\n      An [event](api/router/ChildActivationEnd) triggered when the Router finishes activating a route's children.\n\n    </td>\n  </tr>\n\n  <tr>\n    <td>\n      <code>ActivationEnd</code>\n    </td>\n    <td>\n\n      An [event](api/router/ActivationStart) triggered when the Router finishes activating a route.\n\n    </td>\n  </tr>\n\n  <tr>\n    <td>\n      <code>NavigationEnd</code>\n    </td>\n    <td>\n\n      An [event](api/router/NavigationEnd) triggered when navigation ends successfully.\n\n    </td>\n  </tr>\n\n  <tr>\n    <td>\n      <code>NavigationCancel</code>\n    </td>\n    <td>\n\n      An [event](api/router/NavigationCancel) triggered when navigation is canceled.\n      This can happen when a [Route Guard](guide/router-tutorial-toh#guards) returns false during navigation,\n      or redirects by returning a `UrlTree`.\n\n    </td>\n  </tr>\n\n  <tr>\n    <td>\n      <code>NavigationError</code>\n    </td>\n    <td>\n\n      An [event](api/router/NavigationError) triggered when navigation fails due to an unexpected error.\n\n    </td>\n  </tr>\n\n  <tr>\n    <td>\n      <code>Scroll</code>\n    </td>\n    <td>\n\n      An [event](api/router/Scroll) that represents a scrolling event.\n\n    </td>\n  </tr>\n</table>\n\nWhen you enable the `enableTracing` option, Angular logs these events to the console.\nFor an example of filtering router navigation events, see the [router section](guide/observables-in-angular#router) of the [Observables in Angular](guide/observables-in-angular) guide.\n-->\n<p>라우터가 동작하며 화면이 전환되는 동안 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>는 각 단계에 해당하는 이벤트를 <code><a href=\"api/router/Router#events\" class=\"code-anchor\">Router.events</a></code> 프로퍼티로 전달합니다.\n이벤트는 화면 전환이 시작되는 시점부터 화면 전환이 종료될 때까지 계속 발생하는데, 전체 이벤트 목록은 아래 표를 참고하세요.</p>\n<table>\n  <tbody><tr>\n    <th>\n      라우터 이벤트\n    </th>\n    <th>\n      설명\n    </th>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/NavigationStart\" class=\"code-anchor\">NavigationStart</a></code>\n    </td>\n    <td>\n<p>      화면  전환을 시작할 때 발생하는 <a href=\"api/router/NavigationStart\">이벤트</a>입니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/RouteConfigLoadStart\" class=\"code-anchor\">RouteConfigLoadStart</a></code>\n    </td>\n    <td>\n<p>      <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>가 라우팅 규칙을 <a href=\"guide/router-tutorial-toh#asynchronous-routing\">지연 로딩</a> 하기 전에 발생하는 <a href=\"api/router/RouteConfigLoadStart\">이벤트</a>입니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/RouteConfigLoadEnd\" class=\"code-anchor\">RouteConfigLoadEnd</a></code>\n    </td>\n    <td>\n<p>      라우팅 규칙이 지연로딩된 후에 발생하는 <a href=\"api/router/RouteConfigLoadEnd\">이벤트</a>입니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/RoutesRecognized\" class=\"code-anchor\">RoutesRecognized</a></code>\n    </td>\n    <td>\n<p>      라우터가 URL을 파싱한 후에 이 URL과 매칭되는 라우팅 규칙을 찾은 후에 발생하는 <a href=\"api/router/RoutesRecognized\">이벤트</a>입니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/GuardsCheckStart\" class=\"code-anchor\">GuardsCheckStart</a></code>\n    </td>\n    <td>\n<p>      라우터가 라우터 가드를 실행하는 시점에 발생하는 <a href=\"api/router/GuardsCheckStart\">이벤트</a>입니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/ChildActivationStart\" class=\"code-anchor\">ChildActivationStart</a></code>\n    </td>\n    <td>\n<p>      라우터가 라우팅 규칙의 자식 라우팅 규칙을 활성화할 때 발생하는 <a href=\"api/router/ChildActivationStart\">이벤트</a>입니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/ActivationStart\" class=\"code-anchor\">ActivationStart</a></code>\n    </td>\n    <td>\n<p>      라우터가 라우팅 규칙을 활성화할 때 발생하는 <a href=\"api/router/ActivationStart\">이벤트</a>입니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/GuardsCheckEnd\" class=\"code-anchor\">GuardsCheckEnd</a></code>\n    </td>\n    <td>\n<p>      라우터가 라우터 가드 실행을 끝낸 시점에 발생하는 <a href=\"api/router/GuardsCheckEnd\">이벤트</a>입니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/ResolveStart\" class=\"code-anchor\">ResolveStart</a></code>\n    </td>\n    <td>\n<p>      라우터가 Resolve 페이즈를 시작할 때 발생하는 <a href=\"api/router/ResolveStart\">이벤트</a>입니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/ResolveEnd\" class=\"code-anchor\">ResolveEnd</a></code>\n    </td>\n    <td>\n<p>      라우터가 실행하는 Resolve 페이즈가 성공했을 때 발생하는 <a href=\"api/router/ResolveEnd\">이벤트</a>입니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/ChildActivationEnd\" class=\"code-anchor\">ChildActivationEnd</a></code>\n    </td>\n    <td>\n<p>      라우터가 자식 라우팅 규칙의 활성화를 끝낸 시점에 발생하는 <a href=\"api/router/ChildActivationEnd\">이벤트</a>입니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/ActivationEnd\" class=\"code-anchor\">ActivationEnd</a></code>\n    </td>\n    <td>\n<p>      라우터가 라우팅 규칙 활성화를 끝낸 시점에 발생하는 <a href=\"api/router/ActivationStart\">이벤트</a>입니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/NavigationEnd\" class=\"code-anchor\">NavigationEnd</a></code>\n    </td>\n    <td>\n<p>      화면 전환 동작이 문제없이 종료되었을 때 발생하는 <a href=\"api/router/NavigationEnd\">이벤트</a>입니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/NavigationCancel\" class=\"code-anchor\">NavigationCancel</a></code>\n    </td>\n    <td>\n<p>      화면 전환 동작이 취소되었을 때 발생하는 <a href=\"api/router/NavigationCancel\">이벤트</a>입니다.\n이 이벤트는 <a href=\"guide/router-tutorial-toh#guards\">라우터 가드</a>가 <code>false</code>를 반환해서 화면 전환을 취소하거나 <code><a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a></code>를 반환해서 다른 화면으로 리다이렉트할 때 발생합니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/NavigationError\" class=\"code-anchor\">NavigationError</a></code>\n    </td>\n    <td>\n<p>      화면 전환 동작이 예상치 못한 이유로 실패했을 때 발생하는 <a href=\"api/router/NavigationError\">이벤트</a>입니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/Scroll\" class=\"code-anchor\">Scroll</a></code>\n    </td>\n    <td>\n<p>      스크롤 이벤트가 발생했을 때 함께 발생하는 <a href=\"api/router/Scroll\">이벤트</a>입니다.</p>\n    </td>\n  </tr>\n</tbody></table>\n<p><code>enableTracing</code> 옵션을 활성화하면 라우터 이벤트가 발생할 때마다 Angular가 콘솔에 로그를 출력합니다.\n이 이벤트들 중에서 원하는 이벤트만 필터링하려면 <a href=\"guide/observables-in-angular\">Angular가 제공하는 옵저버블</a> 문서의 <a href=\"guide/observables-in-angular#router\">라우터 섹션</a>을 참고하세요.</p>\n<!--\n### Router terminology\n-->\n<h3 id=\"라우터-관련-용어\">라우터 관련 용어<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#라우터-관련-용어\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nHere are the key `Router` terms and their meanings:\n\n<table>\n\n  <tr>\n\n    <th>\n      Router Part\n    </th>\n\n    <th>\n      Meaning\n    </th>\n\n  </tr>\n\n  <tr>\n\n    <td>\n      <code>Router</code>\n    </td>\n\n    <td>\n      Displays the application component for the active URL.\n      Manages navigation from one component to the next.\n    </td>\n\n  </tr>\n\n  <tr>\n\n    <td>\n      <code>RouterModule</code>\n    </td>\n\n    <td>\n      A separate NgModule that provides the necessary service providers\n      and directives for navigating through application views.\n    </td>\n\n  </tr>\n\n  <tr>\n\n    <td>\n      <code>Routes</code>\n    </td>\n\n    <td>\n      Defines an array of Routes, each mapping a URL path to a component.\n    </td>\n\n  </tr>\n\n  <tr>\n\n    <td>\n      <code>Route</code>\n    </td>\n\n    <td>\n      Defines how the router should navigate to a component based on a URL pattern.\n      Most routes consist of a path and a component type.\n    </td>\n\n  </tr>\n\n  <tr>\n\n    <td>\n      <code>RouterOutlet</code>\n    </td>\n\n    <td>\n      The directive (<code>&lt;router-outlet></code>) that marks where the router displays a view.\n    </td>\n\n  </tr>\n\n  <tr>\n\n    <td>\n      <code>RouterLink</code>\n    </td>\n\n    <td>\n      The directive for binding a clickable HTML element to a route. Clicking an element with a <code>routerLink</code> directive that is bound to a <i>string</i> or a <i>link parameters array</i> triggers a navigation.\n    </td>\n\n  </tr>\n\n  <tr>\n\n    <td>\n      <code>RouterLinkActive</code>\n    </td>\n\n    <td>\n      The directive for adding/removing classes from an HTML element when an associated <code>routerLink</code> contained on or inside the element becomes active/inactive.\n    </td>\n\n  </tr>\n\n  <tr>\n\n    <td>\n      <code>ActivatedRoute</code>\n    </td>\n\n    <td>\n      A service that is provided to each route component that contains route specific information such as route parameters, static data, resolve data, global query params, and the global fragment.\n    </td>\n\n  </tr>\n\n  <tr>\n\n    <td>\n      <code>RouterState</code>\n    </td>\n\n    <td>\n      The current state of the router including a tree of the currently activated routes together with convenience methods for traversing the route tree.\n    </td>\n\n  </tr>\n\n  <tr>\n\n    <td>\n      <b><i>Link parameters array</i></b>\n    </td>\n\n    <td>\n      An array that the router interprets as a routing instruction.\n      You can bind that array to a <code>RouterLink</code> or pass the array as an argument to the <code>Router.navigate</code> method.\n    </td>\n\n  </tr>\n\n  <tr>\n\n    <td>\n      <b><i>Routing component</i></b>\n    </td>\n\n    <td>\n      An Angular component with a <code>RouterOutlet</code> that displays views based on router navigations.\n    </td>\n\n  </tr>\n\n</table>\n-->\n<p><code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 관련 용어가 어떤 의미로 사용되는지 확인해 보세요:</p>\n<table>\n  <tbody><tr>\n  <th>\n    용어\n  </th>\n  <th>\n    의미\n  </th>\n  </tr>\n  <tr>\n  <td>\n    <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>\n  </td>\n  <td>\n    브라우저 URL에 따라 애플리케이션 컴포넌트를 표시하는 객체입니다.\n    컴포넌트가 다른 컴포넌트로 전환되는 동안 일어나는 과정도 관리합니다.\n  </td>\n  </tr>\n  <tr>\n  <td>\n    <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>\n  </td>\n  <td>\n    라우터 관련 설정을 한 번에 관리하기 위해 NgModule 단위로 묶은 모듈입니다.\n  </td>\n  </tr>\n  <tr>\n  <td>\n    <code><a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a></code>\n  </td>\n  <td>\n    라우팅 규칙(Route)을 배열 형태로 선언한 것이며, 각 라우팅 규칙은 URL 주소와 컴포넌트를 연결합니다.\n  </td>\n  </tr>\n  <tr>\n  <td>\n    <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code>\n  </td>\n  <td>\n    브라우저 URL을 처리해서 컴포넌트를 화면에 표시하는 규칙을 정의한 것입니다.\n    라우팅 규칙은 보통 URL 주소와 컴포넌트로 구성됩니다.\n  </td>\n  </tr>\n  <tr>\n  <td>\n    <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>\n  </td>\n  <td>\n    라우터가 대상 컴포넌트를 화면에 표시할 위치를 지정하는 디렉티브입니다.\n    <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code> 처럼 사용합니다.\n  </td>\n  </tr>\n  <tr>\n  <td>\n    <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>\n  </td>\n  <td>\n    클릭할 수 있는 HTML 엘리먼트를 라우팅 규칙과 연결할 때 사용하는 디렉티브입니다.\n    <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> 디렉티브가 적용된 엘리먼트를 클릭하면 디렉티브에 바인딩 된 <i>문자열</i>이나 <i>링크 변수 배열</i>에 따라 화면이 전환됩니다.\n  </td>\n  </tr>\n  <tr>\n  <td>\n    <code><a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">RouterLinkActive</a></code>\n  </td>\n  <td>\n    <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code>가 적용된 HTML 엘리먼트가 활성화될 때 CSS 클래스를 지정하거나 제거하는 디렉티브입니다.\n  </td>\n  </tr>\n  <tr>\n  <td>\n    <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>\n  </td>\n  <td>\n    현재 적용되는 라우팅 규칙과 관련된 정보를 제공하는 서비스입니다.\n    라우팅 변수나 정적 데이터, 라우터 가드가 처리한 이벤트, 전역 쿼리 변수, 전역 URL 프래그먼트 정보가 담겨 있습니다.\n  </td>\n  </tr>\n  <tr>\n  <td>\n    <code><a href=\"api/router/RouterState\" class=\"code-anchor\">RouterState</a></code>\n  </td>\n  <td>\n    라우터의 현재 상태를 제공하는 서비스입니다.\n    현재 활성화된 라우팅 규칙의 트리 정보와 트리를 탐색할 수 있는 메소드를 제공합니다.\n  </td>\n  </tr>\n  <tr>\n  <td>\n    <b><i>링크 변수 배열<br>(Link parameters array)</i></b>\n  </td>\n  <td>\n    라우터가 동작하는 방식을 지정하는 배열입니다.\n    이 배열은 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>에 바인딩하거나 <code>Router.navigate</code> 메서드의 인자로 사용합니다.\n  </td>\n  </tr>\n  <tr>\n  <td>\n    <b><i>라우팅되는 컴포넌트<br>(Routing component)</i></b>\n  </td>\n  <td>\n    라우터가 화면을 전환하면서 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>에 표시되는 Angular 컴포넌트를 의미합니다.\n  </td>\n  </tr>\n</tbody></table>\n\n</div>\n\n<!-- links to this doc:\n - api/router\n - api/router/ActivatedRoute\n - api/router/NavigationBehaviorOptions\n - api/router/NavigationExtras\n - api/router/Route\n - api/router/Router\n - api/router/RouterEvent\n - api/router/RouterModule\n - api/router/RouterState\n - api/router/Routes\n - api/router/UrlCreationOptions\n - guide/ajs-quick-reference\n - guide/architecture\n - guide/architecture-next-steps\n - guide/browser-support\n - guide/built-in-directives\n - guide/deployment\n - guide/deprecations\n - guide/example-apps-list\n - guide/glossary\n - guide/hierarchical-dependency-injection\n - guide/lazy-loading-ngmodules\n - guide/module-types\n - guide/npm-packages\n - guide/universal\n - guide/upgrade\n - start/start-routing\n-->\n<!-- links from this doc:\n - api/animations/state\n - api/common/APP_BASE_HREF\n - api/common/HashLocationStrategy\n - api/common/LocationStrategy\n - api/common/PathLocationStrategy\n - api/core/Component\n - api/core/NgModule\n - api/forms/FormsModule\n - api/platform-browser/BrowserModule\n - api/router\n - api/router/ActivatedRoute\n - api/router/ActivatedRouteSnapshot\n - api/router/ActivationEnd\n - api/router/ActivationStart\n - api/router/CanActivate\n - api/router/CanActivateChild\n - api/router/CanDeactivate\n - api/router/CanLoad\n - api/router/ChildActivationEnd\n - api/router/ChildActivationStart\n - api/router/GuardsCheckEnd\n - api/router/GuardsCheckStart\n - api/router/NavigationCancel\n - api/router/NavigationEnd\n - api/router/NavigationError\n - api/router/NavigationExtras\n - api/router/NavigationStart\n - api/router/ParamMap\n - api/router/Resolve\n - api/router/ResolveEnd\n - api/router/ResolveStart\n - api/router/Route\n - api/router/RouteConfigLoadEnd\n - api/router/RouteConfigLoadStart\n - api/router/Router\n - api/router/Router#events\n - api/router/RouterLink\n - api/router/RouterLinkActive\n - api/router/RouterModule\n - api/router/RouterModule#forRoot\n - api/router/RouterOutlet\n - api/router/RouterState\n - api/router/RouterStateSnapshot\n - api/router/Routes\n - api/router/RoutesRecognized\n - api/router/Scroll\n - api/router/UrlTree\n - cli\n - guide/architecture-components\n - guide/dependency-injection#bootstrap\n - guide/glossary#template\n - guide/glossary#view\n - guide/lazy-loading-ngmodules\n - guide/observables-in-angular\n - guide/observables-in-angular#router\n - guide/property-binding\n - guide/router#404-page-how-to\n - guide/router#404-에러-페이지-표시하기\n - guide/router#base-href\n - guide/router#base-href-1\n - guide/router#browser-url-styles\n - guide/router#hashlocationstrategy\n - guide/router#html5-url-base-href\n - guide/router#link-parameters-array\n - guide/router#locationstrategy-브라우저-url-스타일\n - guide/router#route-order\n - guide/router#setting-up-wildcard-routes\n - guide/router#url-스타일-결정하기\n - guide/router#wildcard-route-how-to\n - guide/router#기본-라우팅-규칙-정의하기\n - guide/router#네비게이션-화면-전환\n - guide/router#라우터-관련-용어\n - guide/router#라우터-로드하기\n - guide/router#라우터-링크-활성화하기routerlinkactive\n - guide/router#라우터-링크routerlink\n - guide/router#라우터-상태routerstate\n - guide/router#라우터-설정하기\n - guide/router#라우터-이벤트\n - guide/router#라우터-활용\n - guide/router#라우팅-가능한-상태로-앱-생성하기\n - guide/router#라우팅-규칙-적용-순서\n - guide/router#라우팅-규칙으로-전달된-정보-참조하기\n - guide/router#라우팅-영역router-outlet\n - guide/router#라우팅할-컴포넌트-생성하기\n - guide/router#리다이렉션-설정하기\n - guide/router#링크-변수-배열\n - guide/router#사전지식\n - guide/router#상대-주소로-이동하기\n - guide/router#상대주소-사용하기\n - guide/router#와일드카드-라우팅-규칙-등록하기\n - guide/router#중첩-라우팅-규칙\n - guide/router#지연-로딩\n - guide/router#컴포넌트-로드하기\n - guide/router#쿼리-인자-url-조각-참고하기\n - guide/router#허가되지-않은-접근-차단하기\n - guide/router#활성화된-라우팅-규칙activatedroute\n - guide/router-tutorial-toh#a-crisis-center-with-child-routes\n - guide/router-tutorial-toh#asynchronous-routing\n - guide/router-tutorial-toh#child-routing-component\n - guide/router-tutorial-toh#fragment\n - guide/router-tutorial-toh#guards\n - guide/router-tutorial-toh#milestone-5-route-guards\n - guide/router-tutorial-toh#optional-route-parameters\n - guide/router-tutorial-toh#pathmatch\n - guide/router-tutorial-toh#query-parameters\n - guide/router-tutorial-toh#resolve-guard\n - start\n - tutorial\n - https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries\n - https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base\n - https://github.com/angular/angular/edit/master/aio/content/guide/router.md?message=docs%3A%20describe%20your%20change...\n - https://tools.ietf.org/html/rfc3986#section-5.2.2\n-->"
}