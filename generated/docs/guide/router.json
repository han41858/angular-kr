{
  "id": "guide/router",
  "title": "라우팅 & 네비게이션",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/router.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Routing & Navigation\n-->\n<h1 id=\"라우팅--네비게이션\">라우팅 &#x26; 네비게이션<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#라우팅--네비게이션\"><i class=\"material-icons\">link</i></a></h1>\n<!--\nThe Angular **`Router`** enables navigation from one [view](guide/glossary#view) to the next\nas users perform application tasks.\n-->\n<p>Angular가 제공하는 <strong>라우터(<code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a>)</code></strong>를 사용하면 사용자의 동작에 반응하며 <a href=\"guide/glossary#view\">뷰</a>를 전환할 수 있습니다.</p>\n<!--\nThis guide covers the router's primary features, illustrating them through the evolution\nof a small application that you can <live-example>run live in the browser</live-example>.\n-->\n<p>이 문서는 작은 애플리케이션을 점점 확장해 가면서 라우터의 사용방법에 대해 알아봅니다.\n이 문서에서 다루는 예제는 <live-example></live-example>에서 직접 확인하거나 다운받아 실행할 수 있습니다.</p>\n<!-- style for all tables on this page -->\n<style>\n  td, th {vertical-align: top}\n</style>\n<!--\n## Overview\n-->\n<h2 id=\"개요\">개요<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#개요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe browser is a familiar model of application navigation:\n\n* Enter a URL in the address bar and the browser navigates to a corresponding page.\n* Click links on the page and the browser navigates to a new page.\n* Click the browser's back and forward buttons and the browser navigates\n  backward and forward through the history of pages you've seen.\n-->\n<p>브라우저가 제공하는 네비게이션 모델은 이렇습니다.</p>\n<ul>\n<li>주소표시줄에 URL을 입력하면 특정 페이지로 이동합니다.</li>\n<li>페이지에 있는 링크를 클릭하면 새로운 페이지로 이동합니다.</li>\n<li>브라우저의 뒤로 가기/앞으로 가기 버튼을 누르면 사용자가 방문한 페이지 히스토리에 따라 뒤로/앞으로 페이지를 이동합니다.</li>\n</ul>\n<!--\nThe Angular `Router` (\"the router\") borrows from this model.\nIt can interpret a browser URL as an instruction to navigate to a client-generated view.\nIt can pass optional parameters along to the supporting view component that help it decide what specific content to present.\nYou can bind the router to links on a page and it will navigate to\nthe appropriate application view when the user clicks a link.\nYou can navigate imperatively when the user clicks a button, selects from a drop box,\nor in response to some other stimulus from any source. And the router logs activity\nin the browser's history journal so the back and forward buttons work as well.\n-->\n<p>Angular가 제공하는 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>도 이 모델을 따릅니다.\n브라우저에서 접근하는 URL에 해당하는 뷰를 생성해서 사용자가 볼 수 있도록 화면에 표시하며, 이 때 컴포넌트에 추가 정보를 제공하기 위해 라우팅 변수를 사용할 수도 있습니다.\n그리고 라우터를 직접 사용해서 페이지를 이동해도 사용자가 링크를 클릭했을 때 페이지를 이동하는 것과 동일하게 처리합니다.\n이 특징을 활용하면 사용자가 버튼을 클릭했을 때, 드롭 박스에서 항목을 선택했을 때, 비동기 소스로부터 어떤 이벤트를 받았을 때 등 다양한 경우에 페이지를 전환할 수 있습니다.\n라우터는 브라우저의 히스토리 기록도 지원하기 때문에, 라우터로 이동한 페이지는 브라우저의 뒤로 가기/앞으로 가기 버튼으로 이동할 수도 있습니다.</p>\n<a id=\"basics\"></a>\n<!--\n## The Basics\n-->\n<h2 id=\"라우터-기본\">라우터 기본<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#라우터-기본\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThis guide proceeds in phases, marked by milestones, starting from a simple two-pager\nand building toward a modular, multi-view design with child routes.\n\nAn introduction to a few core router concepts will help orient you to the details that follow.\n-->\n<p>이 문서에서는 단순하게 페이지를 전환하는 라우터부터 모듈로 구성하는 라우터, 자식 라우터를 활용한 멀티 뷰 디자인 구현 방법에 대해 차례로 알아봅니다.</p>\n<p>먼저 라우터의 기본 개념부터 알아봅시다.</p>\n<a id=\"basics-base-href\"></a>\n<h3 id=\"base-href\"><em>&#x3C;base href></em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#base-href\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nMost routing applications should add a `<base>` element to the `index.html` as the first child in the  `<head>` tag\nto tell the router how to compose navigation URLs.\n\nIf the `app` folder is the application root, as it is for the sample application,\nset the `href` value *exactly* as shown here.\n-->\n<p>라우터를 사용하는 애플리케이션은 <code>index.html</code>파일의 <code>&#x3C;head></code> 태그 가장 처음에 라우터가 이동하는 URL의 기준점을 지정해야 하는데, 이 때 <code>&#x3C;base></code> 엘리먼트를 사용합니다.</p>\n<p>만약 Angular CLI로 생성한 프로젝트이고, <code>app</code> 폴더가 애플리케이션 최상위 폴더라면 다음과 같이 지정되어 있을 것입니다.</p>\n<code-example path=\"router/src/index.html\" linenums=\"false\" header=\"src/index.html (base-href)\" region=\"base-href\">\n&#x3C;base <a href=\"api/router/RouterLinkWithHref#href\" class=\"code-anchor\">href</a>=\"/\">\n\n</code-example>\n<a id=\"basics-router-imports\"></a>\n<!--\n### Router imports\n-->\n<h3 id=\"라우터-로드하기\">라우터 로드하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#라우터-로드하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe Angular Router is an optional service that presents a particular component view for a given URL.\nIt is not part of the Angular core. It is in its own library package, `@angular/router`.\nImport what you need from it as you would from any other Angular package.\n-->\n<p>라우터는 URL과 컴포넌트를 연결하는 서비스지만, Angular 애플리케이션을 구현하면서 꼭 사용해야 하는 서비스는 아닙니다.\n그래서 라우터는 Angular 코어에서 제외되었으며, <code>@angular/router</code> 라이브러리 패키지로 제공됩니다.\n라우터를 사용하려면 다른 Angular 패키지와 마찬가지로 다음과 같이 로드합니다.</p>\n<code-example path=\"router/src/app/app.module.1.ts\" linenums=\"false\" header=\"src/app/app.module.ts (import)\" region=\"import-router\">\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\nYou'll learn about more options in the [details below](#browser-url-styles).\n-->\n<p>라우터 옵션에 대해서는 <a href=\"guide/router#browser-url-styles\">아래</a>에서 자세하게 다룹니다.</p>\n</div>\n<a id=\"basics-config\"></a>\n<!--\n### Configuration\n-->\n<h3 id=\"라우터-설정\">라우터 설정<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#라우터-설정\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nA routed Angular application has one singleton instance of the *`Router`* service.\nWhen the browser's URL changes, that router looks for a corresponding `Route`\nfrom which it can determine the component to display.\n\nA router has no routes until you configure it.\nThe following example creates five route definitions, configures the router via the `RouterModule.forRoot` method,\nand adds the result to the `AppModule`'s `imports` array.\n-->\n<p>라우터를 사용하는 Angular 애플리케이션이라면 <em><code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code></em> 서비스 인스턴스가 싱글턴으로 존재합니다.\n그래서 브라우저의 URL이 변경되면 이 라우터가 이 변경사항과 관련된 라우팅 규칙(routes)을 찾아서 어떤 컴포넌트를 표시해야 하는지 판단합니다.</p>\n<p>개발자가 설정하기 전에는 아무 라우팅 규칙도 없습니다.\n다음 예제는 라우팅 규칙을 각각 다른 4가지 방식으로 정의한 예제 코드입니다.\n이 라우팅 규칙들은 라우터 모듈의 <code>RouterModule.forRoot</code> 메소드를 사용해서 <code>AppModule</code>의 <code><a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a></code> 배열에 등록되었습니다.</p>\n<!--\n<code-example path=\"router/src/app/app.module.0.ts\" linenums=\"false\" header=\"src/app/app.module.ts (excerpt)\">\n-->\n<code-example path=\"router/src/app/app.module.0.ts\" linenums=\"false\" header=\"src/app/app.module.ts (일부)\">\nconst appRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'crisis-center', component: CrisisListComponent },\n  { path: 'hero/:id',      component: HeroDetailComponent },\n  {\n    path: 'heroes',\n    component: HeroListComponent,\n    data: { title: 'Heroes <a href=\"api/common/NumberSymbol#List\" class=\"code-anchor\">List</a>' }\n  },\n  { path: '',\n    <a href=\"api/router/Route#redirectTo\" class=\"code-anchor\">redirectTo</a>: '/heroes',\n    <a href=\"api/router/Route#pathMatch\" class=\"code-anchor\">pathMatch</a>: '<a href=\"api/core/Version#full\" class=\"code-anchor\">full</a>'\n  },\n  { path: '**', component: PageNotFoundComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    RouterModule.forRoot(\n      appRoutes,\n      { <a href=\"api/router/ExtraOptions#enableTracing\" class=\"code-anchor\">enableTracing</a>: true } // &#x3C;-- 디버그 활성화\n    )\n    // 다른 모듈 로드\n  ],\n  ...\n})\nexport class AppModule { }\n\n</code-example>\n<a id=\"example-config\"></a>\n<!--\nThe `appRoutes` array of *routes* describes how to navigate.\nPass it to the `RouterModule.forRoot` method in the module `imports` to configure the router.\n-->\n<p><code>appRoutes</code> 배열에는 네비게이션을 수행하는 <em>라우팅 규칙(routes)</em>을 정의합니다.\n그러면 라우팅 규칙들이 모듈의 <code><a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a></code> 항목에 사용된 <code>RouterModule.forRoot</code> 메소드의 인자로 전달되어 애플리케이션에 등록됩니다.</p>\n<!--\nEach `Route` maps a URL `path` to a component.\nThere are _no leading slashes_ in the _path_.\nThe router parses and builds the final URL for you,\nallowing you to use both relative and absolute paths when navigating between application views.\n-->\n<p>각각의 라우팅 규칙은 URL <code>path</code>와 컴포넌트를 맵핑합니다.\n이 때 <em>path</em> 가 <em>슬래시(<code>/</code>)</em> 로 시작하면 안되며, 이렇게 지정된 경로는 상대주소와 절대주소 방식으로 모두 동작할 수 있도록 라우터가 파싱해서 등록합니다.</p>\n<!--\nThe `:id` in the second route is a token for a route parameter. In a URL such as `/hero/42`, \"42\"\nis the value of the `id` parameter. The corresponding `HeroDetailComponent`\nwill use that value to find and present the hero whose `id` is 42.\nYou'll learn more about route parameters later in this guide.\n-->\n<p>두 번째 라우팅 규칙에 사용된 <code>:id</code>는 라우팅 변수에 사용하는 토큰인데, 이 코드의 경우에는 <code>/hero/42</code> 경로로 접속했을 때 \"42\"가 <code>id</code> 변수의 값에 할당됩니다.\n그러면 이 경로와 연결된 <code>HeroDetailComponent</code>에서 <code>id</code>가 42인 히어로를 찾아 화면에 표시하는 용도로 사용할 수 있습니다.\n라우팅 변수에 대한 내용은 이 문서의 후반부에 자세하게 알아봅니다.</p>\n<!--\nThe `data` property in the third route is a place to store arbitrary data associated with\nthis specific route. The data property is accessible within each activated route. Use it to store\nitems such as page titles, breadcrumb text, and other read-only, _static_ data.\nYou'll use the [resolve guard](#resolve-guard) to retrieve _dynamic_ data later in the guide.\n-->\n<p>세 번째 라우팅 규칙에 사용된 <code>data</code> 프로퍼티는 라우팅 규칙에 데이터를 전달할 때 사용하는 프로퍼티입니다.\n이렇게 전달한 데이터 프로퍼티는 라우터를 통해 참조할 수 있으며, 페이지 제목이나 간단한 텍스트, 읽기 전용 데이터, 정적 데이터를 저장하는 용도로 활용할 수 있습니다.\n<a href=\"guide/router#resolve-guard\">라우터 가드(resolve guard)</a>를 사용해서 <em>동적</em> 데이터를 전달하는 방법은 이 문서의 후반부에 다룹니다.</p>\n<!--\nThe **empty path** in the fourth route represents the default path for the application,\nthe place to go when the path in the URL is empty, as it typically is at the start.\nThis default route redirects to the route for the `/heroes` URL and, therefore, will display the `HeroesListComponent`.\n-->\n<p>네 번째 라우팅 규칙에 사용된 <strong>빈 주소</strong>는 하위 URL 주소가 없을 때 사용되는 애플리케이션의 기본 주소인데, 보통 애플리케이션의 시작 주소로 사용합니다.\n이 예제에서는 빈 주소로 접속했을 때 <code>/heroes</code> URL로 리다이렉트 하며, 이 동작으로 인해 <code>HeroesListComponent</code>가 화면에 표시될 것입니다.</p>\n<!--\nThe `**` path in the last route is a **wildcard**. The router will select this route\nif the requested URL doesn't match any paths for routes defined earlier in the configuration.\nThis is useful for displaying a \"404 - Not Found\" page or redirecting to another route.\n-->\n<p>마지막 라우팅 규칙에 사용된 <code>**</code>는 <strong>와일드카드(wildcard)</strong>입니다.\n이 라우팅 규칙은 사용자가 요청한 URL에 해당하는 규칙이 없을 때 적용되며, 이 규칙을 사용하면 \"404 - Not Found\" 페이지를 표시하거나 다른 주소로 라우팅하는 용도로 활용할 수 있습니다.</p>\n<!--\n**The order of the routes in the configuration matters** and this is by design. The router uses a **first-match wins**\nstrategy when matching routes, so more specific routes should be placed above less specific routes.\nIn the configuration above, routes with a static path are listed first, followed by an empty path route,\nthat matches the default route.\nThe wildcard route comes last because it matches _every URL_ and should be selected _only_ if no other routes are matched first.\n-->\n<p>Angular 라우터는 <strong>라우팅 규칙이 선언된 순서대로 적용되도록</strong> 설계되었습니다.\n그래서 사용자가 요청한 URL이 라우팅 규칙 여러개와 매칭되더라도 <strong>제일 먼저 매칭된 항목이 동작</strong>하기 때문에, 일반적인 라우팅 규칙보다 세부적인 라우팅 규칙이 먼저 정의되어야 합니다.\n이 코드에서 설정한 것을 보면, 고정된 주소로 지정된 URL이 처음 매칭되며, 라우팅 변수를 사용한 라우팅 규칙이 그 다음으로 매칭되고, 빈 주소에 해당하는 라우팅 규칙, 기본 라우팅 규칙이 순서대로 매칭됩니다.\n와일드카드 라우팅 규칙은 <em>모든 URL</em> 에 매칭되기 때문에 이 규칙은 가장 마지막에 정의되어야 합니다.</p>\n<!--\nIf you need to see what events are happening during the navigation lifecycle, there is the **enableTracing** option as part of the router's default configuration. This outputs each router event that took place during each navigation lifecycle to the browser console. This should only be used for _debugging_ purposes. You set the `enableTracing: true` option in the object passed as the second argument to the `RouterModule.forRoot()` method.\n-->\n<p>네비게이션 라이프싸이클이 실행되는 동안 어떤 이벤트가 발생하는지 확인하려면, 라우터를 설정할 때 <strong>enableTracing</strong> 옵션을 사용하면 됩니다.\n이 옵션이 설정되면 각 네비게이션 라이프싸이클이 실행될 때마다 브라우저에 로그가 출력됩니다.\n이 옵션은 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 메소드의 두 번째 인자로 <code><a href=\"api/router/ExtraOptions#enableTracing\" class=\"code-anchor\">enableTracing</a>: true</code> 를 지정하면 되며,  <em>디버깅</em> 용도로만 사용하는 것이 좋습니다.</p>\n<a id=\"basics-router-outlet\"></a>\n<!--\n### Router outlet\n-->\n<h3 id=\"라우팅-영역-router-outlet\">라우팅 영역 (Router outlet)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#라우팅-영역-router-outlet\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe `RouterOutlet` is a directive from the router library that is used like a component. \nIt acts as a placeholder that marks the spot in the template where the router should \ndisplay the components for that outlet.\n-->\n<p><code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>은 라우터가 제공하는 디렉티브이며, 일반 컴포넌트처럼 사용합니다.\n이 디렉티브는 라우터에 의해 표시되는 컴포넌트가 화면의 어느 위치에 표시될지 지정하는 용도로 사용합니다.</p>\n<!--\n<code-example language=\"html\">\n  &lt;router-outlet>&lt;/router-outlet>\n  &lt;!-- Routed components go here --&gt;\n\n</code-example>\n-->\n<code-example language=\"html\">\n  &#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n  &#x3C;!-- 라우팅 대상이 된 컴포넌트는 여기에 추가됩니다. -->\n\n</code-example>\n<!--\nGiven the configuration above, when the browser URL for this application becomes `/heroes`,\nthe router matches that URL to the route path `/heroes` and displays the `HeroListComponent`\nas a sibling element to the `RouterOutlet` that you've placed in the host component's template.\n-->\n<p>이제 브라우저의 URL이 <code>/heroes</code>가 되면 이 주소에 매칭되는 컴포넌트인 <code>HeroListComponent</code>가 화면에 표시되는데, 이 컴포넌트는 호스트 컴포넌트 템플릿의 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code> 엘리먼트 바로 뒤에 표시됩니다.</p>\n<a id=\"basics-router-links\"></a>\n<a id=\"router-link\"></a>\n<!--\n### Router links\n-->\n<h3 id=\"라우터-링크\">라우터 링크<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#라우터-링크\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nNow you have routes configured and a place to render them, but\nhow do you navigate? The URL could arrive directly from the browser address bar.\nBut most of the time you navigate as a result of some user action such as the click of\nan anchor tag.\n-->\n<p>이제 라우터도 설정했고 주소에 연결된 컴포넌트가 어디에 표시되는지도 알았습니다. 그런데 이 주소로 어떻게 이동할 수 있을까요?\n물론 브라우저 주소 표시줄에 원하는 주소를 바로 입력해서 이동할 수도 있습니다.\n하지만 대부분의 경우는 사용자가 앵커 태그를 클릭하는 것과 같은 사용자 동작에 의해 네비게이션이 이루어집니다.</p>\n<!--\nConsider the following template:\n-->\n<p>다음과 같은 템플릿을 봅시다:</p>\n<code-example path=\"router/src/app/app.component.1.html\" linenums=\"false\" header=\"src/app/app.component.html\">\n&#x3C;h1>Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>&#x3C;/h1>\n&#x3C;nav>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/crisis-center\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Crisis Center&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/heroes\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Heroes&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n&#x3C;/nav>\n&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n\n</code-example>\n<!--\nThe `RouterLink` directives on the anchor tags give the router control over those elements.\nThe navigation paths are fixed, so you can assign a string to the `routerLink` (a \"one-time\" binding).\n-->\n<p>앵커 태그에 사용된 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 디렉티브는 이 앵커 태그의 동작을 라우터에게 위임하는 디렉티브입니다.\n그래서 고정된 주소로 이동하는 경우라면 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code>에 문자열을 할당해도 됩니다. (한 번만 바인딩하는 문법입니다.)</p>\n<!--\nHad the navigation path been more dynamic, you could have bound to a template expression that\nreturned an array of route link parameters (the _link parameters array_).\nThe router resolves that array into a complete URL.\n-->\n<p>네비게이션 경로가 동적으로 할당되는 경우라면, 라우터 링크 변수를 템플릿 표현식으로 바인딩할 수도 있습니다.\n이 때 라우터 링크 변수는 배열로 지정하며, 이 배열은 라우터가 완전한 URL로 변환해서 적용합니다.</p>\n<a id=\"router-link-active\"></a>\n<!--\n### Active router links\n-->\n<h3 id=\"활성화된-라우터-링크-active-router-links\">활성화된 라우터 링크 (Active router links)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#활성화된-라우터-링크-active-router-links\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe `RouterLinkActive` directive toggles css classes for active `RouterLink` bindings based on the current `RouterState`.\n-->\n<p><code><a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">RouterLinkActive</a></code> 디렉티브는 현재 <code><a href=\"api/router/RouterState\" class=\"code-anchor\">RouterState</a></code>에 해당하는 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>에 css 클래스를 지정합니다.</p>\n<!--\nOn each anchor tag, you see a [property binding](guide/template-syntax#property-binding) to the `RouterLinkActive` directive that look like `routerLinkActive=\"...\"`.\n-->\n<p>각 앵커 태그에는 <code><a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"...\"</code>와 같이 <a href=\"guide/template-syntax#%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EB%B0%94%EC%9D%B8%EB%94%A9\">프로퍼티 바인딩</a>된 <code><a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">RouterLinkActive</a></code> 디렉티브가 존재합니다.</p>\n<!--\nThe template expression to the right of the equals (=) contains a space-delimited string of CSS classes\nthat the Router will add when this link is active (and remove when the link is inactive). You set the `RouterLinkActive` \ndirective to a string of classes such as `[routerLinkActive]=\"'active fluffy'\"` or bind it to a component \nproperty that returns such a string. \n-->\n<p>이 템플릿 표현식의 등호(=) 오른쪽에는 공백으로 구분하는 CSS 클래스를 지정하는데, 이 링크가 활성화되면 해당 클래스가 지정되고 링크가 비활성화되면 해당 클래스가 제거됩니다.\n그래서 <code><a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">RouterLinkActive</a></code> 디렉티브에는 <code>[<a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>]=\"'active fluffy'\"</code>와 같은 문자열을 지정하거나 컴포넌트 클래스에서 문자열을 반환하는 프로퍼티나 메소드를 지정할 수 있습니다.</p>\n<!--\nActive route links cascade down through each level of the route tree, so parent and child router links can be active at the same time. To override this behavior, you can bind to the `[routerLinkActiveOptions]` input binding with the `{ exact: true }` expression. By using `{ exact: true }`, a given `RouterLink` will only be active if its URL is an exact match to the current URL.\n-->\n<p>라우팅 규칙은 트리 구조로 구성되기 때문에 부모 컴포넌트의 라우터 링크와 자식 컴포넌트의 라우터 링크가 동시에 활성화될 수도 있습니다. 이 동작을 변경하려면 <code>[<a href=\"api/router/RouterLinkActive#routerLinkActiveOptions\" class=\"code-anchor\">routerLinkActiveOptions</a>]</code>에 <code>{ exact: true }</code>를 바인딩하면 됩니다. 그러면 현재 URL과 정확히 매칭되는 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>만 활성화 됩니다.</p>\n<a id=\"basics-router-state\"></a>\n<!--\n### Router state\n-->\n<h3 id=\"라우터-스테이트-router-state\">라우터 스테이트 (Router state)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#라우터-스테이트-router-state\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAfter the end of each successful navigation lifecycle, the router builds a tree of `ActivatedRoute` objects\nthat make up the current state of the router. You can access the current `RouterState` from anywhere in the\napplication using the `Router` service and the `routerState` property.\n-->\n<p>각각의 네비게이션 라이프싸이클이 끝나면 라우터는 현재 라우터 스테이트를 표현하는 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 트리를 객체 타입으로 생성합니다. 그러면 애플리케이션에서 이 라우터 스테이트를 활용해서 로직을 작성할 수 있습니다.</p>\n<!--\nEach `ActivatedRoute` in the `RouterState` provides methods to traverse up and down the route tree\nto get information from parent, child and sibling routes.\n-->\n<p><code>RouteState</code>에서 제공하는 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>는 라우트 트리에 따라 구성되기 때문에, 부모 라우터와 자식 라우터, 이웃 라우터에 대한 정보도 참조할 수 있습니다.</p>\n<a id=\"activated-route\"></a>\n<!--\n### Activated route\n-->\n<h3 id=\"활성화된-라우팅-규칙-activated-route\">활성화된 라우팅 규칙 (Activated route)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#활성화된-라우팅-규칙-activated-route\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe route path and parameters are available through an injected router service called the\n[ActivatedRoute](api/router/ActivatedRoute).\nIt has a great deal of useful information including:\n-->\n<p>라우팅 주소와 라우팅 인자는 <a href=\"api/router/ActivatedRoute\">ActivatedRoute</a>라는 라우터 서비스 내부 객체를 사용해서 참조할 수 있습니다.\n이 객체는 다음 프로퍼티들을 자주 활용합니다:</p>\n<table>\n  <tbody><tr>\n    <th>\n      <!--\n      Property\n      -->\n      프로퍼티\n    </th>\n    <th>\n      <!--\n      Description\n      -->\n      설명\n    </th>\n  </tr>\n  <tr>\n    <td>\n      <code>url</code>\n    </td>\n    <td>\n    <!--\n    An `Observable` of the route path(s), represented as an array of strings for each part of the route path.\n    -->\n<p>    라우팅 경로를 <code>Observable</code> 타입으로 표현합니다. 이 프로퍼티를 참조하면 라우팅 경로를 구성하는 각 문자열을 배열 형태로 확인할 수 있습니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>data</code>\n    </td>\n    <td>\n    <!--\n    An `Observable` that contains the `data` object provided for the route. Also contains any resolved values from the [resolve guard](#resolve-guard).\n    -->\n<p>    라우팅 규칙에 <code>data</code> 객체가 지정되었을 때 이 데이터를 <code>Observable</code> 타입으로 표현합니다. 이 객체에는 <a href=\"guide/router#resolve-guard\">라우터 가드</a>에서 처리된 내용이 포함될 수도 있습니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>paramMap</code>\n    </td>\n    <td>\n    <!--\n    An `Observable` that contains a [map](api/router/ParamMap) of the required and [optional parameters](#optional-route-parameters) specific to the route. The map supports retrieving single and multiple values from the same parameter.\n    -->\n<p>    라우팅 규칙에 정의된 <a href=\"guide/router#optional-route-parameters\">라우팅 변수</a>를 <a href=\"api/router/ParamMap\">map</a> 타입의 <code>Observable</code>로 표현합니다. 맵을 사용하면 라우팅 규칙에 포함된 라우팅 인자를 한 번에 모두 가져올 수도 있습니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>queryParamMap</code>\n    </td>\n    <td>\n      <!--\n    An `Observable` that contains a [map](api/router/ParamMap) of the [query parameters](#query-parameters) available to all routes.\n    The map supports retrieving single and multiple values from the query parameter.\n    -->\n<p>    라우팅 규칙에서 접근할 수 있는 모든 <a href=\"guide/router#query-parameters\">쿼리 변수</a>를 <a href=\"api/router/ParamMap\">map</a> 타입의 <code>Observable</code>로 표현합니다.\n맵을 사용하면 라우팅 규칙에 포함된 쿼리 변수를 한 번에 모두 가져올 수도 있습니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>fragment</code>\n    </td>\n    <td>\n    <!--\n    An `Observable` of the URL [fragment](#fragment) available to all routes.\n    -->\n<p>    모든 라우팅 규칙에 포함된 URL <a href=\"guide/router#fragment\">조각</a>을 <code>Observable</code> 형태로 표현합니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>outlet</code>\n    </td>\n    <td>\n    <!--\n    The name of the `RouterOutlet` used to render the route. For an unnamed outlet, the outlet name is _primary_.\n    -->\n<p>    라우팅 영역으로 사용되는 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>을 지정할 때 사용합니다. 라우팅 영역에 이름을 지정하지 않으면 <em>primary</em> 가 기본 이름으로 지정됩니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>routeConfig</code>\n    </td>\n    <td>\n    <!--\n    The route configuration used for the route that contains the origin path.\n    -->\n<p>    현재 사용된 라우팅 규칙의 설정을 표현합니다. 이 객체에는 URL 주소에 대한 정보도 포함됩니다.</p>\n    </td>\n  </tr>\n    <tr>\n    <td>\n      <code>parent</code>\n    </td>\n    <td>\n    <!--\n    The route's parent `ActivatedRoute` when this route is a [child route](#child-routing-component).\n    -->\n<p>    현재 라우팅된 것이 <a href=\"guide/router#child-routing-component\">자식 라우팅 규칙</a>이라면, 이 라우팅 규칙의 부모 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>를 표현합니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>firstChild</code>\n    </td>\n    <td>\n    <!--\n    Contains the first `ActivatedRoute` in the list of this route's child routes.\n    -->\n<p>    현재 라우팅 규칙의 자식 라우팅 규칙 중 첫 번째 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>를 표현합니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>children</code>\n    </td>\n    <td>\n    <!--\n    Contains all the [child routes](#child-routing-component) activated under the current route.\n    -->\n<p>    현재 활성화된 라우팅 규칙에 있는 모든 <a href=\"guide/router#child-routing-component\">자식 라우팅 규칙</a>을 표현합니다.</p>\n    </td>\n  </tr>\n</tbody></table>\n<div class=\"alert is-helpful\">\n<!--\nTwo older properties are still available. They are less capable than their replacements, discouraged, and may be deprecated in a future Angular version.\n-->\n<p>예전에 사용하던 두 가지 프로퍼티도 아직 사용할 수 있습니다. 다음 프로퍼티들은 좀 더 많은 기능을 갖도록 변경되었으며, 이후 Angular 버전에서는 사라질 수도 있습니다.</p>\n<!--\n**`params`**&mdash;An `Observable` that contains the required and [optional parameters](#optional-route-parameters) specific to the route. Use `paramMap` instead.\n-->\n<p><strong><code>params</code></strong>—라우팅 규칙에 <a href=\"guide/router#optional-route-parameters\">라우팅 변수</a>가 있는 경우에 이 라우팅 변수의 값을 <code>Observable</code>로 표현합니다. 이 프로퍼티는 <code>paramMap</code>으로 대체되었습니다.</p>\n<!--\n**`queryParams`**&mdash;An `Observable` that contains the [query parameters](#query-parameters) available to all routes.\nUse `queryParamMap` instead.\n-->\n<p><strong><code>queryParams</code></strong>—모든 라우팅 규칙에 있는 <a href=\"guide/router#query-parameters\">쿼리 변수</a>를 <code>Observable</code>로 표현합니다. 이 프로퍼티는 <code>queryParamMap</code>으로 대체되었습니다.</p>\n</div>\n<!--\n### Router events\n-->\n<h3 id=\"라우터-이벤트\">라우터 이벤트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#라우터-이벤트\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nDuring each navigation, the `Router` emits navigation events through the `Router.events` property. These events range from when the navigation starts and ends to many points in between. The full list of navigation events is displayed in the table below.\n-->\n<p><code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>는 네비게이션이 동작할 때마다 <code><a href=\"api/router/Router#events\" class=\"code-anchor\">Router.events</a></code> 프로퍼티를 통해 네비게이션 이벤트를 보냅니다. 이 이벤트는 네비게이션이 시작할 때부터 끝날때까지 각 단계를 표현합니다.</p>\n<table>\n  <tbody><tr>\n    <th>\n      <!--\n      Router Event\n      -->\n      라우터 이벤트\n    </th>\n    <th>\n      <!--\n      Description\n      -->\n      설명\n    </th>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/NavigationStart\" class=\"code-anchor\">NavigationStart</a></code>\n    </td>\n    <td>\n      <!--\n      An [event](api/router/NavigationStart) triggered when navigation starts.\n      -->\n<p>      네비게이션 동작을 시작할 때 발생하는 <a href=\"api/router/NavigationStart\">이벤트</a>입니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/RouteConfigLoadStart\" class=\"code-anchor\">RouteConfigLoadStart</a></code>\n    </td>\n    <td>\n      <!--\n      An [event](api/router/RouteConfigLoadStart) triggered before the `Router`\n      [lazy loads](#asynchronous-routing) a route configuration.\n      -->\n<p>      라우터가 라우팅 규칙을 <a href=\"guide/router#asynchronous-routing\">지연 로딩</a>하기 전에 발생하는 <a href=\"api/router/RouteConfigLoadStart\">이벤트</a>입니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/RouteConfigLoadEnd\" class=\"code-anchor\">RouteConfigLoadEnd</a></code>\n    </td>\n    <td>\n      <!--\n      An [event](api/router/RouteConfigLoadEnd) triggered after a route has been lazy loaded.\n      -->\n<p>      지연 로딩되는 라우팅 규칙이 모두 로딩된 후에 발생하는 <a href=\"api/router/RouteConfigLoadEnd\">이벤트</a>입니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/RoutesRecognized\" class=\"code-anchor\">RoutesRecognized</a></code>\n    </td>\n    <td>\n      <!--\n      An [event](api/router/RoutesRecognized) triggered when the Router parses the URL and the routes are recognized.\n      -->\n<p>      라우터가 URL을 파싱하고 해당하는 라우팅 규칙을 찾았을 때 발생하는 <a href=\"api/router/RoutesRecognized\">이벤트</a>입니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/GuardsCheckStart\" class=\"code-anchor\">GuardsCheckStart</a></code>\n    </td>\n    <td>\n      <!--\n      An [event](api/router/GuardsCheckStart) triggered when the Router begins the Guards phase of routing.\n      -->\n<p>      라우터 가드가 실행되기 전에 발생하는 <a href=\"api/router/GuardsCheckStart\">이벤트</a>입니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/ChildActivationStart\" class=\"code-anchor\">ChildActivationStart</a></code>\n    </td>\n    <td>\n      <!--\n      An [event](api/router/ChildActivationStart) triggered when the Router begins activating a route's children.\n      -->\n<p>      라우터가 자식 라우팅 규칙을 활성화하기 전에 발생하는 <a href=\"api/router/ChildActivationStart\">이벤트</a>입니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/ActivationStart\" class=\"code-anchor\">ActivationStart</a></code>\n    </td>\n    <td>\n      <!--\n      An [event](api/router/ActivationStart) triggered when the Router begins activating a route.\n      -->\n<p>      라우터가 라우팅 규칙을 활성화하기 전에 발생하는 <a href=\"api/router/ActivationStart\">이벤트</a>입니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/GuardsCheckEnd\" class=\"code-anchor\">GuardsCheckEnd</a></code>\n    </td>\n    <td>\n      <!--\n      An [event](api/router/GuardsCheckEnd) triggered when the Router finishes the Guards phase of routing successfully.\n      -->\n<p>      라우터 가드가 실행되고 라우팅이 실제로 동작하려고 할 때 발생하는 <a href=\"api/router/GuardsCheckEnd\">이벤트</a> 입니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/ResolveStart\" class=\"code-anchor\">ResolveStart</a></code>\n    </td>\n    <td>\n      <!--\n      An [event](api/router/ResolveStart) triggered when the Router begins the Resolve phase of routing.\n      -->\n<p>      라우터가 라우팅 규칙을 분석하기 시작할 때 발생하는 <a href=\"api/router/ResolveStart\">이벤트</a>입니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/ResolveEnd\" class=\"code-anchor\">ResolveEnd</a></code>\n    </td>\n    <td>\n      <!--\n      An [event](api/router/ResolveEnd) triggered when the Router finishes the Resolve phase of routing successfuly.\n      -->\n<p>      라우터가 라우팅 규칙을 분석하고 난 후에 발생하는 <a href=\"api/router/ResolveEnd\">이벤트</a>입니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/ChildActivationEnd\" class=\"code-anchor\">ChildActivationEnd</a></code>\n    </td>\n    <td>\n      <!--\n      An [event](api/router/ChildActivationEnd) triggered when the Router finishes activating a route's children.\n      -->\n<p>      라우터가 자식 라우팅 규칙을 활성화 한 후에 발생하는 <a href=\"api/router/ChildActivationEnd\">이벤트</a>입니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/ActivationEnd\" class=\"code-anchor\">ActivationEnd</a></code>\n    </td>\n    <td>\n      <!--\n      An [event](api/router/ActivationStart) triggered when the Router finishes activating a route.\n      -->\n<p>      라우터가 라우팅 규칙을 활성화한 후에 발생하는 <a href=\"api/router/ActivationStart\">이벤트</a>입니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/NavigationEnd\" class=\"code-anchor\">NavigationEnd</a></code>\n    </td>\n    <td>\n      <!--\n      An [event](api/router/NavigationEnd) triggered when navigation ends successfully.\n      -->\n<p>      네비게이션 동작이 성공적으로 끝났을 때 발생하는 <a href=\"api/router/NavigationEnd\">이벤트</a>입니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/NavigationCancel\" class=\"code-anchor\">NavigationCancel</a></code>\n    </td>\n    <td>\n      <!--\n      An [event](api/router/NavigationCancel) triggered when navigation is canceled.\n      This is due to a [Route Guard](#guards) returning false during navigation.\n      -->\n<p>      네비게이션 동작이 중간에 취소되었을 때 발생하는 <a href=\"api/router/NavigationCancel\">이벤트</a>입니다.\n이 이벤트는 <a href=\"guide/router#guards\">라우터 가드</a>가 <code>false</code> 값을 반환하는 경우에 발생합니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/NavigationError\" class=\"code-anchor\">NavigationError</a></code>\n    </td>\n    <td>\n      <!--\n      An [event](api/router/NavigationError) triggered when navigation fails due to an unexpected error.\n      -->\n<p>      네비게이션 동작 중에 에러가 발생해서 네비게이션이 실패했을 때 발생하는 <a href=\"api/router/NavigationError\">이벤트</a>입니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/Scroll\" class=\"code-anchor\">Scroll</a></code>\n    </td>\n    <td>\n      <!--\n      An [event](api/router/Scroll) that represents a scrolling event.\n      -->\n<p>      스크롤 이벤트가 발생했을 때 발생하는 <a href=\"api/router/Scroll\">이벤트</a>입니다.</p>\n    </td>\n  </tr>\n</tbody></table>\n<!--\nThese events are logged to the console when the `enableTracing` option is enabled also. For an example of filtering router navigation events, visit the [router section](guide/observables-in-angular#router) of the [Observables in Angular](guide/observables-in-angular) guide.\n-->\n<p>라우팅 규칙을 설정할 때 <code><a href=\"api/router/ExtraOptions#enableTracing\" class=\"code-anchor\">enableTracing</a></code> 옵션을 활성화하면 이 이벤트들이 발생하는 것을 콘솔로 확인할 수 있습니다. 원하는 네비게이션 이벤트만 확인하려면 <a href=\"guide/observables-in-angular\">Angular에서 옵저버블 활용하기</a> 문서의 <a href=\"guide/observables-in-angular#router\">Router</a> 섹션을 참고하세요.</p>\n<a id=\"basics-summary\"></a>\n<!--\n### Summary\n-->\n<h3 id=\"용어-정리\">용어 정리<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#용어-정리\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe application has a configured router.\nThe shell component has a `RouterOutlet` where it can display views produced by the router.\nIt has `RouterLink`s that users can click to navigate via the router.\n-->\n<p>애플리케이션에서 라우터를 활용할 때 뷰를 표시하는 영역은 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>으로 지정할 수 있습니다.\n그리고 사용자가 링크를 클릭했을 때 네비게이션을 시작하려면 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>를 사용하면 됩니다.</p>\n<!--\nHere are the key `Router` terms and their meanings:\n-->\n<p><code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>에서 사용하는 용어와 의미는 다음과 같이 정리할 수 있습니다:</p>\n<table>\n  <tbody><tr>\n    <th>\n      <!--\n      Router Part\n      -->\n      용어\n    </th>\n    <th>\n      <!---\n      Meaning\n      ---->\n      의미\n    </th>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>\n    </td>\n    <td>\n      <!--\n      Displays the application component for the active URL.\n      Manages navigation from one component to the next.\n      -->\n      주소에 해당하는 애플리케이션 컴포넌트를 화면에 표시하는 서비스입니다.\n      주소가 변경될 때마다 표시하는 컴포넌트도 변경합니다.\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>\n    </td>\n    <td>\n      <!--\n      A separate NgModule that provides the necessary service providers\n      and directives for navigating through application views.\n      -->\n      네비게이션 동작에 필요한 서비스 프로바이더나 디렉티브를 제공하는 NgModule입니다.\n    </td>\n  </tr>\n  <tr>\n    <td>\n      전체 라우팅 규칙 (<code><a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a></code>)\n    </td>\n    <td>\n      <!--\n      Defines an array of Routes, each mapping a URL path to a component.\n      -->\n      URL과 컴포넌트가 매칭되는 라우팅 규칙을 정의하는 배열입니다.\n    </td>\n  </tr>\n  <tr>\n    <td>\n      라우팅 규칙 (<code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code>)\n    </td>\n    <td>\n      <!--\n      Defines how the router should navigate to a component based on a URL pattern.\n      Most routes consist of a path and a component type.\n      -->\n      라우터가 네비게이션하면서 표시할 컴포넌트를 매칭하는 URL 패턴을 지정합니다.\n      라우팅 규칙은 URL 주소와 컴포넌트 타입으로 구성됩니다.\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>\n    </td>\n    <td>\n      <!--\n      The directive (<code>&lt;router-outlet></code>) that marks where the router displays a view.\n      -->\n      라우터가 표시하는 뷰 영역의 위치를 지정하는 디렉티브입니다. <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code>과 같이 사용합니다.\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>\n    </td>\n    <td>\n      <!--\n      The directive for binding a clickable HTML element to\n      a route. Clicking an element with a <code>routerLink</code> directive\n      that is bound to a <i>string</i> or a <i>link parameters array</i> triggers a navigation.\n      -->\n      클릭에 반응하는 HTML 엘리먼트를 라우터와 연결하는 디렉티브입니다. <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code>가 사용된 엘리먼트를 클릭하면, 이 디렉티브에 바인딩된 <i>문자열</i>이나 <i>링크 변수 배열</i>을 사용해서 네비게이션을 시작합니다.\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">RouterLinkActive</a></code>\n    </td>\n    <td>\n      <!--\n      The directive for adding/removing classes from an HTML element when an associated\n      <code>routerLink</code> contained on or inside the element becomes active/inactive.\n      -->\n      <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code>가 지정된 HTML 엘리먼트에 활성/비활성 클래스를 지정할 때 사용하는 디렉티브입니다. 이 디렉티브를 활용하면 스타일 지정을 좀 더 편하게 할 수 있습니다.\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>\n    </td>\n    <td>\n      <!--\n      A service that is provided to each route component that contains route specific\n      information such as route parameters, static data, resolve data, global query params, and the global fragment.\n      -->\n      현재 라우팅 서비스에 사용된 변수, 정적 데이터, 전역 쿼리 변수, URL 등 라우터와 관련된 정보를 제공하는 서비스입니다\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/RouterState\" class=\"code-anchor\">RouterState</a></code>\n    </td>\n    <td>\n      <!--\n      The current state of the router including a tree of the currently activated\n      routes together with convenience methods for traversing the route tree.\n      -->\n      현재 활성화된 라우터를 포함해서 상위 라우팅 트리에 대한 정보를 제공합니다.\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <!--\n      <b><i>Link parameters array</i></b>\n      -->\n      <b><i>링크 변수 배열 (Link parameters array)</i></b>\n    </td>\n    <td>\n      <!--\n      An array that the router interprets as a routing instruction.\n      You can bind that array to a <code>RouterLink</code> or pass the array as an argument to\n      the <code>Router.navigate</code> method.\n      -->\n      라우팅 동작에 사용할 때 라우터가 처리하는 배열입니다.\n      이 배열은 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>에 바인딩하거나, <code>Router.navigate</code> 메소드의 인자로 전달하는 방식으로 사용할 수 있습니다.\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <!--\n      <b><i>Routing component</i></b>\n      -->\n      <b><i>라우팅 컴포넌트</i></b>\n    </td>\n    <td>\n      <!--\n      An Angular component with a <code>RouterOutlet</code> that displays views based on router navigations.\n      -->\n      라우터 네비게이션 동작에 의해 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>에 표시되는 Angular 컴포넌트를 의미합니다.\n    </td>\n  </tr>\n</tbody></table>\n<a id=\"sample-app-intro\"></a>\n<!--\n## The sample application\n-->\n<h2 id=\"예제-애플리케이션\">예제 애플리케이션<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#예제-애플리케이션\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThis guide describes development of a multi-page routed sample application.\nAlong the way, it highlights design decisions and describes key features of the router such as:\n-->\n<p>이 문서에서는 라우터로 페이지를 전환하는 애플리케이션을 예제로 만들어 봅니다.\n이 애플리케이션을 만드는 동안 다음과 같은 내용에 대해 알아볼 것입니다:</p>\n<!--\n* Organizing the application features into modules.\n* Navigating to a component (*Heroes* link to \"Heroes List\").\n* Including a route parameter (passing the Hero `id` while routing to the \"Hero Detail\").\n* Child routes (the *Crisis Center* has its own routes).\n* The `CanActivate` guard (checking route access).\n* The `CanActivateChild` guard (checking child route access).\n* The `CanDeactivate` guard (ask permission to discard unsaved changes).\n* The `Resolve` guard (pre-fetching route data).\n* Lazy loading feature modules.\n* The `CanLoad` guard (check before loading feature module assets).\n-->\n<ul>\n<li>애플리케이션을 모듈 단위로 구성하는 방법</li>\n<li>네비게이션하면서 컴포넌트를 화면에 표시하는 방법</li>\n<li>라우팅 변수 사용하기 (\"히어로 상세정보\" 페이지로 이동할 때 히어로의 <code>id</code>를 라우터로 전달해 봅니다.)</li>\n<li>자식 라우팅 규칙</li>\n<li><code><a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a></code> 가드 (라우팅을 허용할지 판단합니다.)</li>\n<li><code><a href=\"api/router/CanActivateChild\" class=\"code-anchor\">CanActivateChild</a></code> 가드 (자식 라우팅을 허용할지 판단합니다.)</li>\n<li><code><a href=\"api/router/CanDeactivate\" class=\"code-anchor\">CanDeactivate</a></code> 가드 (저장되지 않은 변경사항을 폐기할지 사용자에게 물어봅니다.)</li>\n<li><code><a href=\"api/router/Resolve\" class=\"code-anchor\">Resolve</a></code> 가드 (라우팅 데이터를 미리 받아옵니다.)</li>\n<li>기능모듈 지연로딩하기</li>\n<li><code><a href=\"api/router/CanLoad\" class=\"code-anchor\">CanLoad</a></code> 가드 (기능모듈을 로드할지 확인합니다.)</li>\n</ul>\n<!--\nThe guide proceeds as a sequence of milestones as if you were building the app step-by-step.\nBut, it is not a tutorial and it glosses over details of Angular application construction\nthat are more thoroughly covered elsewhere in the documentation.\n-->\n<p>이 문서는 실제 애플리케이션을 구현하는 것처럼 한 단계씩 순서대로 진행합니다.\n하지만 이 문서에 해당하는 내용 외에도 애플리케이션의 기본 구조 등 다른 문서에서 언급하는 Angular의 기능들도 함께 살펴봅니다.</p>\n<!--\nThe full source for the final version of the app can be seen and downloaded from the <live-example></live-example>.\n-->\n<p>이 문서에서 다루는 예제 코드의 최종 버전은 <live-example></live-example>에서 직접 확인하거나 다운받아 확인할 수 있습니다.</p>\n<!--\n### The sample application in action\n-->\n<h3 id=\"개요-1\">개요<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#개요-1\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nImagine an application that helps the _Hero Employment Agency_ run its business.\nHeroes need work and the agency finds crises for them to solve.\n-->\n<p><em>히어로 관리 회사</em> 에서 업무용으로 사용하는 애플리케이션을 만든다고 합시다.\n히어로는 일자리가 필요하기 때문에 회사에서는 히어로가 해결해야 할 위기를 찾아야 합니다.</p>\n<!--\nThe application has three main feature areas:\n\n1. A *Crisis Center* for maintaining the list of crises for assignment to heroes.\n1. A *Heroes* area for maintaining the list of heroes employed by the agency.\n1. An *Admin* area to manage the list of crises and heroes.\n-->\n<p>그래서 이 애플리케이션은 3가지 기능을 중심으로 개발합니다:\n1. 히어로에게 할당하는 위기를 관리하는 <em>위기대응센터</em> 기능\n1. 회사가 고용하는 히어로를 관리하는 <em>히어로 관리</em> 기능\n1. 히어로와 위기를 관리하는 <em>관리자</em> 기능</p>\n<!--\nTry it by clicking on this <live-example title=\"Hero Employment Agency Live Example\">live example link</live-example>.\n-->\n<p><live-example title=\"Hero Employment Agency Live Example\">예제 애플리케이션</live-example>을 클릭해서 동작을 확인해 보세요.</p>\n<!--\nOnce the app warms up, you'll see a row of navigation buttons\nand the *Heroes* view with its list of heroes.\n-->\n<p>애플리케이션을 실행하고 나면 내비게이션에 사용되는 버튼들과 히어로의 목록을 화면에서 확인할 수 있습니다.</p>\n<figure>\n  <img src=\"generated/images/guide/router/hero-list.png\" alt=\"Hero List\" width=\"250\" height=\"225\">\n</figure>\n<!--\nSelect one hero and the app takes you to a hero editing screen.\n-->\n<p>이 중에 히어로를 한 명 선택하면 히어로의 정보를 수정할 수 있는 화면으로 이동합니다.</p>\n<figure>\n  <img src=\"generated/images/guide/router/hero-detail.png\" alt=\"Crisis Center Detail\" width=\"250\" height=\"162\">\n</figure>\n<!--\nAlter the name.\nClick the \"Back\" button and the app returns to the heroes list which displays the changed hero name.\nNotice that the name change took effect immediately.\n-->\n<p>히어로의 이름을 변경해 봅시다.\n그리고 \"Back\" 버튼을 누르면 히어로의 이름이 수정된 채로 화면에 표시됩니다.\n이 때 히어로의 이름은 \"Back\" 버튼을 눌렀을 때 수정된 값이 반영된 것입니다.</p>\n<!--\nHad you clicked the browser's back button instead of the \"Back\" button,\nthe app would have returned you to the heroes list as well.\nAngular app navigation updates the browser history as normal web navigation does.\n-->\n<p>\"Back\" 버튼 대신 브라우저의 \"뒤로 가기\" 버튼을 클릭해도 히어로의 목록은 동일하게 처리됩니다.\n일반적인 페이지 이동과 마찬가지로, Angular 애플리케이션의 네비게이션도 브라우저 히스토리를 활용합니다.</p>\n<!--\nNow click the *Crisis Center* link for a list of ongoing crises.\n-->\n<p>그리고 <em>위기대응센터</em> 링크를 클릭하면 위기 목록이 화면에 표시됩니다.</p>\n<figure>\n  <img src=\"generated/images/guide/router/crisis-center-list.png\" alt=\"Crisis Center List\" width=\"250\" height=\"209\">\n</figure>\n<!--\nSelect a crisis and the application takes you to a crisis editing screen.\nThe _Crisis Detail_ appears in a child component on the same page, beneath the list.\n-->\n<p>이 화면에서 위기 목록 중 하나를 선택하면 위기 정보를 수정할 수 있는 화면으로 이동합니다.\n이 때 <em>위기 상세정보</em> 화면은 같은 페이지에 자식 컴포넌트로 표시됩니다.</p>\n<!--\nAlter the name of a crisis.\nNotice that the corresponding name in the crisis list does _not_ change.\n-->\n<p>위기의 이름을 수정해 봅시다.\n이 때 목록에 표시된 위기의 이름은 바로 변경되지 <em>않습니다.</em></p>\n<figure>\n  <img src=\"generated/images/guide/router/crisis-center-detail.png\" alt=\"Crisis Center Detail\" width=\"250\" height=\"281\">\n</figure>\n<!--\nUnlike *Hero Detail*, which updates as you type,\n*Crisis Detail* changes are temporary until you either save or discard them by pressing the \"Save\" or \"Cancel\" buttons.\nBoth buttons navigate back to the *Crisis Center* and its list of crises.\n-->\n<p><em>히어로 상세정보</em> 화면에서는 사용자가 입력한 내용이 바로 반영되지만, <em>위기 상세정보</em> 화면에서는 \"Save\" 버튼을 눌러서 저장하거나 \"Cancel\" 버튼을 눌러서 수정사항을 반영하지 않는 방식으로 동작합니다.\n두 버튼은 모두 <em>위기대응센터</em> 화면으로 이동합니다.</p>\n<!--\n***Do not click either button yet***.\nClick the browser back button or the \"Heroes\" link instead.\n-->\n<p><strong><em>하지만 이 버튼은 아직 클릭하지 마세요</em></strong>.\n지금은 브라우저의 뒤로가기 버튼이나 \"Heroes\" 링크를 클릭해 봅시다.</p>\n<!--\nUp pops a dialog box.\n-->\n<p>그러면 다음과 같은 대화상자가 표시됩니다.</p>\n<figure>\n  <img src=\"generated/images/guide/router/confirm-dialog.png\" alt=\"Confirm Dialog\" width=\"250\" height=\"101\">\n</figure>\n<!--\nYou can say \"OK\" and lose your changes or click \"Cancel\" and continue editing.\n-->\n<p>이 화면에서 \"OK\" 버튼을 누르면 변경한 내용을 반영하지 않고, \"Cancel\" 버튼을 누르면 편집을 계속할 수 있습니다.</p>\n<!--\nBehind this behavior is the router's `CanDeactivate` guard.\nThe guard gives you a chance to clean-up or ask the user's permission before navigating away from the current view.\n-->\n<p>이 동작은 라우터의 <code><a href=\"api/router/CanDeactivate\" class=\"code-anchor\">CanDeactivate</a></code> 가드를 사용해서 구현한 것입니다. 이 가드는 현재 화면을 벗어나는 네비게이션이 시작될 때 사용자에게 정말 라우팅을 수행할 것인지 한 번 더 물어보는 용도로 사용할 수 있습니다.</p>\n<!--\nThe `Admin` and `Login` buttons illustrate other router capabilities to be covered later in the guide.\nThis short introduction will do for now.\n-->\n<p><code>Admin</code> 버튼과 <code>Login</code> 버튼은 이후에 설명할 내용이 적용되는 버튼입니다.\n애플리케이션 소개를 간단하게 하기 위해 이 부분은 지금 설명하지 않겠습니다.</p>\n<!--\nProceed to the first application milestone.\n-->\n<p>이제 애플리케이션 개발을 시작해 봅시다.</p>\n<a id=\"getting-started\"></a>\n<!--\n## Milestone 1: Getting started\n-->\n<h2 id=\"1단계--시작하기\">1단계 : 시작하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#1단계--시작하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nBegin with a simple version of the app that navigates between two empty views.\n-->\n<p>처음에는 간단하게 두 화면을 전환하는 네비게이션을 구현해 봅시다.</p>\n<figure>\n  <img src=\"generated/images/guide/router/router-1-anim.gif\" alt=\"App in action\" width=\"250\" height=\"152\">\n</figure>\n<a id=\"import\"></a>\n<!--\nGenerate a sample application to follow the walkthrough.\n-->\n<p>다음 명령을 실행해서 새로운 애플리케이션을 생성합니다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng new angular-router-sample\n</code-example>\n<!--\n### Define Routes\n-->\n<h3 id=\"라우팅-규칙-정의하기\">라우팅 규칙 정의하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#라우팅-규칙-정의하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nA router must be configured with a list of route definitions.\n-->\n<p>라우터를 사용하려면 라우팅 규칙을 먼저 정의해야 합니다.</p>\n<!--\nEach definition translates to a [Route](api/router/Route) object which has two things: a\n`path`, the URL path segment for this route; and a\n`component`, the component associated with this route.\n-->\n<p>라우팅 규칙에는 URL 경로를 지정하는 <code>path</code>와 이 경로에 매칭될 컴포넌트를 지정하는 <code>component</code> 프로퍼티가 지정되며, 각 라우팅 규칙은 <a href=\"api/router/Route\">Route</a> 객체로 변환됩니다.</p>\n<!--\nThe router draws upon its registry of definitions when the browser URL changes\nor when application code tells the router to navigate along a route path.\n-->\n<p>이 라우팅 규칙은 라우터 안에 등록된 이후에 브라우저 URL이 변경되거나 애플리케이션 코드가 네비게이션을 시작할 때 사용됩니다.</p>\n<!--\nIn simpler terms, you might say this of the first route:\n-->\n<p>라우팅 규칙의 역할을 간단하게 설명하면 다음과 같습니다.</p>\n<!--\n* When the browser's location URL changes to match the path segment `/crisis-center`, then\nthe router activates an instance of the `CrisisListComponent` and displays its view.\n-->\n<ul>\n<li>브라우저 URL이 <code>/crisis-center</code>로 변경되면 라우터가 <code>CrisisListComponent</code> 인스턴스를 활성화하고 화면에 표시합니다.</li>\n</ul>\n<!--\n* When the application requests navigation to the path `/crisis-center`, the router\nactivates an instance of `CrisisListComponent`, displays its view, and updates the\nbrowser's address location and history with the URL for that path.\n-->\n<ul>\n<li>애플리케이션에서 <code>/crisis-center</code>로 네비게이션하는 코드가 실행되면 라우터가 <code>CrisisListComponent</code> 인스턴스를 활성화하고 화면에 표시하며, 브라우저의 주소 표시줄을 새로운 주소로 변경하고, 히스토리 방문 기록에도 추가합니다.</li>\n</ul>\n<!--\nThe first configuration defines an array of two routes with simple paths leading to the\n`CrisisListComponent` and `HeroListComponent`. Generate the `CrisisList` and `HeroList` components.\n-->\n<p>이렇게 설정하려면 어떤 주소에 <code>CrisisListComponent</code>나 <code>HeroListComponent</code>를 연결하는 라우팅 규칙을 정의해야 합니다. 먼저 <code>CrisisList</code> 컴포넌트와 <code>HeroList</code> 컴포넌트를 생성합니다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component crisis-list\n</code-example>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component hero-list\n</code-example>\n<!--\nReplace the contents of each component with the sample HTML below.\n-->\n<p>그리고 각 컴포넌트 템플릿의 내용을 다음과 같이 수정합니다.</p>\n<code-tabs>\n\n  <code-pane header=\"src/app/crisis-list/crisis-list.component.html\" path=\"router/src/app/crisis-list/crisis-list.component.html\">\n&#x3C;h2>CRISIS CENTER&#x3C;/h2>\n&#x3C;p><a href=\"api/http/RequestMethod#Get\" class=\"code-anchor\">Get</a> your crisis here&#x3C;/p>\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/hero-list/hero-list.component.html\" path=\"router/src/app/hero-list/hero-list.component.html\" region=\"template\">\n&#x3C;h2>HEROES&#x3C;/h2>\n&#x3C;p><a href=\"api/http/RequestMethod#Get\" class=\"code-anchor\">Get</a> your heroes here&#x3C;/p>\n\n\n</code-pane>\n\n</code-tabs>\n<!--\n### Register Router and Routes\n-->\n<h3 id=\"라우터와-라우팅-규칙-등록하기\">라우터와 라우팅 규칙 등록하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#라우터와-라우팅-규칙-등록하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn order to use the Router, you must first register the `RouterModule` from the `@angular/router` package. Define an array of routes, `appRoutes`, and pass them to the `RouterModule.forRoot()` method. It returns a module, containing the configured `Router` service provider, plus other providers that the routing library requires. Once the application is bootstrapped, the `Router` performs the initial navigation based on the current browser URL.\n-->\n<p>라우터를 사용하려면 먼저 <code>@angular/router</code> 패키지에 있는 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>을 등록해야 합니다. <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 메소드에 라우팅 규칙을 정의한 배열을 전달하면 이 라우팅 규칙이 적용된 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 서비스 프로바이더와 라우팅에 필요한 프로바이더가 모두 포함된 모듈이 반환됩니다. 그리고 애플리케이션이 부트스트랩되고 나면 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>가 현재 브라우저 URL에 해당하는 주소로 초기 네비게이션을 실행합니다.</p>\n<div class=\"alert is-important\">\n  <!--\n  **Note:** The `RouterModule.forRoot` method is a pattern used to register application-wide providers. Read more about application-wide providers in the [Singleton services](guide/singleton-services#forroot) guide.\n  -->\n<p>  <strong>참고:</strong> <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 메소드는 애플리케이션 전역에 사용하는 프로바이더를 등록하는 함수입니다. 애플리케이션 전역 프로바이더에 대해서 더 알아보려면 <a href=\"guide/singleton-services#forroot\">싱글턴 서비스</a> 문서를 참고하세요.</p>\n</div>\n<!--\n<code-example path=\"router/src/app/app.module.1.ts\" linenums=\"false\" header=\"src/app/app.module.ts (first-config)\" region=\"first-config\">\n-->\n<code-example path=\"router/src/app/app.module.1.ts\" linenums=\"false\" header=\"src/app/app.module.ts (첫번째 설정)\" region=\"first-config\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }             from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> }        from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> }          from '@angular/forms';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { AppComponent }          from './app.component';\nimport { CrisisListComponent }   from './crisis-list/crisis-list.component';\nimport { HeroListComponent }     from './hero-list/hero-list.component';\n\nconst appRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'crisis-center', component: CrisisListComponent },\n  { path: 'heroes', component: HeroListComponent },\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    RouterModule.forRoot(\n      appRoutes,\n      { <a href=\"api/router/ExtraOptions#enableTracing\" class=\"code-anchor\">enableTracing</a>: true } // &#x3C;-- 디버그 활성화\n    )\n  ],\n  <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [\n    AppComponent,\n    HeroListComponent,\n    CrisisListComponent,\n  ],\n  <a href=\"api/core/NgModule#bootstrap\" class=\"code-anchor\">bootstrap</a>: [ AppComponent ]\n})\nexport class AppModule { }\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\nAdding the configured `RouterModule` to the `AppModule` is sufficient for simple route configurations. As the application grows, you'll want to [refactor the routing configuration](#refactor-the-routing-configuration-into-a-routing-module) into a separate file and create a **[Routing Module](#routing-module)**, a special type of `Service Module` dedicated to the purpose of routing in feature modules.\n-->\n<p>이렇게 설정된 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>을 <code>AppModule</code>에 로드하면 간단한 네비게이션 설정은 끝납니다. 애플리케이션이 점점 복잡해질수록 라우팅 규칙이 많아지기 때문에 이 규칙들은 <strong><a href=\"guide/router#routing-module\">라우팅 모듈 (Routing module)</a></strong>로 <a href=\"guide/router#%EB%9D%BC%EC%9A%B0%ED%84%B0-%EC%84%A4%EC%A0%95%EC%9D%84-%EB%9D%BC%EC%9A%B0%ED%8C%85-%EB%AA%A8%EB%93%88-%EB%A1%9C-%EC%98%AE%EA%B8%B0%EA%B8%B0\">리팩토링</a>해야 할 수도 있습니다. 라우팅 모듈은 기능 모듈에서 라우팅을 담당하는 코드를 따로 모아 만든 서비스 모듈을 의미합니다.</p>\n</div>\n<!--\nRegistering the `RouterModule.forRoot()` in the `AppModule` imports makes the `Router` service available everywhere in the application.\n-->\n<p><code>Appmodule</code>에 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code>를 등록하면 애플리케이션 전역에서 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 서비스를 사용할 수 있습니다.</p>\n<a id=\"shell\"></a>\n<!--\n### Add the Router Outlet\n-->\n<h3 id=\"라우팅-영역-추가하기\">라우팅 영역 추가하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#라우팅-영역-추가하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe root `AppComponent` is the application shell. It has a title, a navigation bar with two links, and a router outlet where the router swaps components on and off the page. Here's what you get:\n-->\n<p>애플리케이션 가장 밖에 있는 껍데기는 <code>AppComponent</code> 입니다. 이 컴포넌트에는 애플리케이션 이름과 네비게이션 바, 라우팅 영역이 존재하며, 브라우저 주소가 변경되면서 표시되는 컴포넌트는 이 라우팅 영역에 표시됩니다. 다음 그림에서 빨간 사각형으로 표시된 영역이 라우팅 영역입니다:</p>\n<figure>\n  <img src=\"generated/images/guide/router/shell-and-outlet.png\" alt=\"Shell\" width=\"300\" height=\"102\">\n</figure>\n<!--\nThe router outlet serves as a placeholder when the routed components will be rendered below it.\n-->\n<p>라우팅 영역은 라우팅 대상이 되는 컴포넌트가 표시될 위치를 지정하는 용도로 사용합니다. 라우팅 대상 컴포넌트는 라우팅 영역 바로 아래 추가됩니다.</p>\n<a id=\"shell-template\"></a>\n<!--\nThe corresponding component template looks like this:\n-->\n<p>지금까지 설명한 대로 템플릿을 구성하면 다음과 같이 구현할 수 있습니다:</p>\n<code-example path=\"router/src/app/app.component.1.html\" linenums=\"false\" header=\"src/app/app.component.html\">\n&#x3C;h1>Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>&#x3C;/h1>\n&#x3C;nav>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/crisis-center\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Crisis Center&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/heroes\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Heroes&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n&#x3C;/nav>\n&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n\n</code-example>\n<a id=\"wildcard\"></a>\n<!--\n### Define a Wildcard route\n-->\n<h3 id=\"와일드카드-라우팅-규칙\">와일드카드 라우팅 규칙<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#와일드카드-라우팅-규칙\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou've created two routes in the app so far, one to `/crisis-center` and the other to `/heroes`. Any other URL causes the router to throw an error and crash the app.\n-->\n<p>지금까지 작성한 앱에는 라우팅 규칙이 두 개 정의되어 있습니다. 하나는 <code>/crisis-center</code>에 해당하는 라우팅 규칙이며, 다른 하나는 <code>/heroes</code>에 해당하는 라우팅 규칙입니다.\n하지만 이렇게 정의하면 매칭되지 않은 URL로 접속했을 때 라우터에서 에러가 발생하고 앱이 중단됩니다.</p>\n<!--\nAdd a **wildcard** route to intercept invalid URLs and handle them gracefully.\nA _wildcard_ route has a path consisting of two asterisks. It matches _every_ URL.\nThe router will select _this_ route if it can't match a route earlier in the configuration.\nA wildcard route can navigate to a custom \"404 Not Found\" component or [redirect](#redirect) to an existing route.\n-->\n<p>이 에러를 방지하기 위해 잘못된 URL을 매칭하는 <strong>와일드카드</strong> 라우팅 규칙을 추가해 봅시다.\n<em>와일드카드</em> 라우팅 규칙은 아스테리스크 2개(<code>**</code>)를 주소로 지정하는데, 이 규칙은 <em>모든</em> URL과 매칭됩니다.\n그래서 라우터가 이 라우팅 규칙을 만나기 전까지 URL에 매칭되는 라우팅 규칙을 찾지 못하면 <em>이</em> 라우팅 규칙을 매칭시킵니다.\n와일드카드 라우팅 규칙은 \"404 Not Found\" 컴포넌트를 표시하거나 다른 페이지로 <a href=\"guide/router#redirect\">리다이렉트</a>하는 로직을 구현할 때 사용합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nThe router selects the route with a [_first match wins_](#example-config) strategy.\nWildcard routes are the least specific routes in the route configuration.\nBe sure it is the _last_ route in the configuration.\n-->\n<p>라우터는 앱에 등록된 라우팅 규칙 중 <a href=\"guide/router#example-config\">첫 번째 매칭되는</a> 라우팅 규칙을 처리합니다.\n와일드카드 라우팅 규칙은 모든 URL고가 매칭되기 때문에 반드시 <em>마지막</em> 라우팅 규칙으로 등록되어야 합니다.</p>\n</div>\n<!--\nTo test this feature, add a button with a `RouterLink` to the `HeroListComponent` template and set the link to `\"/sidekicks\"`.\n-->\n<p>동작을 테스트하기 위해 <code>HeroListComponent</code> 템플릿에 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>를 사용하는 버튼을 하나 추가하고, 이 버튼의 링크를 <code>\"/sidekicks\"</code>로 지정합니다.</p>\n<!--\n<code-example path=\"router/src/app/hero-list/hero-list.component.html\" linenums=\"false\" header=\"src/app/hero-list/hero-list.component.html (excerpt)\">\n-->\n<code-example path=\"router/src/app/hero-list/hero-list.component.html\" linenums=\"false\" header=\"src/app/hero-list/hero-list.component.html (일부)\">\n&#x3C;h2>HEROES&#x3C;/h2>\n&#x3C;p><a href=\"api/http/RequestMethod#Get\" class=\"code-anchor\">Get</a> your heroes here&#x3C;/p>\n\n&#x3C;button <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/sidekicks\">Go to sidekicks&#x3C;/button>\n\n\n</code-example>\n<!--\nThe application will fail if the user clicks that button because you haven't defined a `\"/sidekicks\"` route yet.\n-->\n<p>애플리케이션을 실행하고 이 버튼을 클릭하면, 아직 <code>\"/sidekicks\"</code>에 대한 라우팅 규칙이 정의되어 있지 않기 때문에 애플리케이션이 에러로 종료됩니다.</p>\n<!--\nInstead of adding the `\"/sidekicks\"` route, define a `wildcard` route instead and have it navigate to a simple `PageNotFoundComponent`.\n-->\n<p>그러면 <code>\"/sidekicks\"</code> 라우팅 규칙을 추가하는 대신 와일드카드 라우팅 규칙을 추가하고, 이 라우팅 규칙을 <code>PageNotFoundComponent</code>와 연결합시다.</p>\n<code-example path=\"router/src/app/app.module.1.ts\" linenums=\"false\" header=\"src/app/app.module.ts (wildcard)\" region=\"wildcard\">\n{ path: '**', component: PageNotFoundComponent }\n\n</code-example>\n<!--\nCreate the `PageNotFoundComponent` to display when users visit invalid URLs.\n-->\n<p>그리고 <code>PageNotFoundComponent</code>를 다음과 같이 정의합니다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component page-not-found\n</code-example>\n<code-example path=\"router/src/app/page-not-found/page-not-found.component.html\" linenums=\"false\" header=\"src/app/page-not-found.component.html (404 component)\">\n&#x3C;h2>Page not found&#x3C;/h2>\n\n</code-example>\n<!--\nNow when the user visits `/sidekicks`, or any other invalid URL, the browser displays \"Page not found\".\nThe browser address bar continues to point to the invalid URL.\n-->\n<p>이제 사용자가 <code>/sidekicks</code>와 같이 등록되지 않은 주소에 접근하면 \"Page not found\" 화면이 표시됩니다.\n이 때 브라우저 주소표시줄의 URL은 변경되지 않고 그대로 표시됩니다.</p>\n<a id=\"redirect\"></a>\n<!--\n### Set up redirects\n-->\n<h3 id=\"리다이렉트-설정하기\">리다이렉트 설정하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#리다이렉트-설정하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nWhen the application launches, the initial URL in the browser bar is something like:\n-->\n<p>애플리케이션이 실행되면 브라우저의 주소 표시줄은 다음과 같이 시작합니다:</p>\n<code-example>\n  localhost:4200\n</code-example>\n<!--\nThat doesn't match any of the concrete configured routes which means\nthe router falls through to the wildcard route and displays the `PageNotFoundComponent`.\n-->\n<p>하지만 이 주소는 지금까지 설정된 라우팅 규칙 중 아무 것에도 해당되지 않기 때문에 마지막 라우팅 규칙으로 넘어가며 화면에 <code>PageNotFoundComponent</code>가 표시됩니다.</p>\n<!--\nThe application needs a **default route** to a valid page.\nThe default page for this app is the list of heroes.\nThe app should navigate there as if the user clicked the \"Heroes\" link or pasted `localhost:4200/heroes` into the address bar.\n-->\n<p>이 동작 대신 애플리케이션에 <strong>기본 페이지로 가는</strong> 라우팅 규칙을 추가하려고 합니다.\n그리고 애플리케이션의 기본 페이지는 히어로의 목록을 표시하는 화면으로 하려고 합니다.\n기본 라우팅 규칙은 사용자가 화면에서 \"Heroes\" 링크를 클릭하거나 주소표시줄에 <code>localhost:4200/heroes</code>를 입력한 것과 같은 동작을 합니다.</p>\n<!--\nThe preferred solution is to add a `redirect` route that translates the initial relative URL (`''`)\nto the desired default path (`/heroes`). The browser address bar shows `.../heroes` as if you'd navigated there directly.\n-->\n<p>가장 좋은 방법은 애플리케이션의 최상위 URL(<code>''</code>)로 접속할 때 기본 주소(<code>/heroes</code>)로 이동하도록 <code>redirect</code> 라우팅 규칙을 추가하는 것입니다. 이 라우팅 규칙을 적용하면 사용자가 직접 <code>.../heroes</code>로 이동한 것과 같은 동작을 합니다.</p>\n<!--\nAdd the default route somewhere _above_ the wildcard route.\nIt's just above the wildcard route in the following excerpt showing the complete `appRoutes` for this milestone.\n-->\n<p>기본 라우팅 규칙은 와일드카드 라우팅 규칙보다 <em>위쪽에</em> 추가해야 합니다.\n그래서 아래 예제에서는 와일드카드 라우팅 규칙 바로 위에 기본 라우팅 규칙을 추가했습니다.</p>\n<code-example path=\"router/src/app/app-routing.module.1.ts\" linenums=\"false\" header=\"src/app/app-routing.module.ts (appRoutes)\" region=\"appRoutes\">\nconst appRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'crisis-center', component: CrisisListComponent },\n  { path: 'heroes',        component: HeroListComponent },\n  { path: '',   <a href=\"api/router/Route#redirectTo\" class=\"code-anchor\">redirectTo</a>: '/heroes', <a href=\"api/router/Route#pathMatch\" class=\"code-anchor\">pathMatch</a>: '<a href=\"api/core/Version#full\" class=\"code-anchor\">full</a>' },\n  { path: '**', component: PageNotFoundComponent }\n];\n\n</code-example>\n<!--\nA redirect route requires a `pathMatch` property to tell the router how to match a URL to the path of a route.\nThe router throws an error if you don't.\nIn this app, the router should select the route to the `HeroListComponent` only when the *entire URL* matches `''`,\nso set the `pathMatch` value to `'full'`.\n-->\n<p>리다이렉트 라우팅 규칙을 사용하려면 브라우저의 URL이 라우팅 규칙과 매칭되는 방법을 지정하기 위해 <code><a href=\"api/router/Route#pathMatch\" class=\"code-anchor\">pathMatch</a></code> 프로퍼티를 함께 사용해야 하는데, 이 프로퍼티가 지정되지 않으면 에러가 발생합니다.\n이 예제에서는 <em>전체 URL</em>이 정확하게 <code>''</code>일 때만 <code>HeroListComponent</code>로 라우팅하기 위해 <code><a href=\"api/router/Route#pathMatch\" class=\"code-anchor\">pathMatch</a></code>의 값을 <code>'<a href=\"api/core/Version#full\" class=\"code-anchor\">full</a>'</code>로 지정했습니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nTechnically, `pathMatch = 'full'` results in a route hit when the *remaining*, unmatched segments of the URL match `''`.\nIn this example, the redirect is in a top level route so the *remaining* URL and the *entire* URL are the same thing.\n-->\n<p>좀 더 자세하게 설명하면, <code><a href=\"api/router/Route#pathMatch\" class=\"code-anchor\">pathMatch</a> = '<a href=\"api/core/Version#full\" class=\"code-anchor\">full</a>'</code>를 지정하면 해당 라우팅 계층의 URL 세그먼트가 <code>''</code>에 해당하는 라우팅 규칙이 추가되는 것입니다.\n그리고 이 예제에서 리다이렉트 라우팅 규칙이 적용된 것은 최상위 계층이기 때문에 <em>전체</em> URL과 해당 계층의 URL 세그먼트는 <code>''</code>로 같습니다.</p>\n<!--\nThe other possible `pathMatch` value is `'prefix'` which tells the router\nto match the redirect route when the *remaining* URL ***begins*** with the redirect route's _prefix_ path.\n-->\n<p><code><a href=\"api/router/Route#pathMatch\" class=\"code-anchor\">pathMatch</a></code>에는 다른 값을 지정할 수도 있습니다. 해당 라우팅 계층에서 <strong><em>특정 문자열로 시작하는</em></strong> 주소일 때 리다이렉트하도록 <code>'prefix'</code> 옵션을 설정할 수도 있습니다.</p>\n<!--\nDon't do that here.\nIf the `pathMatch` value were `'prefix'`, _every_ URL would match `''`.\n-->\n<p>이 예제에서는 이 방법을 사용하지 않았습니다.\n이 예제에서 <code><a href=\"api/router/Route#pathMatch\" class=\"code-anchor\">pathMatch</a></code>에 <code>'prefix'</code>를 사용하면 <em>모든</em> URL이 <code>''</code>와 매칭됩니다.</p>\n<!--\nTry setting it to `'prefix'` then click the `Go to sidekicks` button.\nRemember that's a bad URL and you should see the \"Page not found\" page.\nInstead, you're still on the \"Heroes\" page.\nEnter a bad URL in the browser address bar.\nYou're instantly re-routed to `/heroes`.\n_Every_ URL, good or bad, that falls through to _this_ route definition\nwill be a match.\n-->\n<p><code>Go to sidekicks</code> 버튼을 눌렀을 때 <code>'prefix'</code>를 사용하도록 수정해 보세요.\n지금까지 설정한 라우팅 규칙에서 어떤 주소에 해당하는 라우팅 규칙이 없으면  \"Page not found\" 페이지가 표시됩니다.\n하지만 <code>'prefix'</code>를 사용한 코드에서 해당 버튼을 클릭해도 여전히 \"Heroes\" 페이지가 표시됩니다.\n그리고 브라우저 주소표시줄에 유효하지 않은 URL을 입력해보세요.\n이 경우에도 <code>/heroes</code> 페이지로 이동합니다.\n유효하거나 유효하지 않은 것과 관계없이 <em>모든</em> URL은 이 라우팅 규칙에 매칭됩니다.</p>\n<!--\nThe default route should redirect to the `HeroListComponent` _only_ when the _entire_ url is  `''`.\nRemember to restore the redirect to `pathMatch = 'full'`.\n\nLearn more in Victor Savkin's\n[post on redirects](http://victorsavkin.com/post/146722301646/angular-router-empty-paths-componentless-routes).\n-->\n<p>그래서 기본 라우팅 규칙은 <em>반드시</em> <em>전체</em> URL이 <code>''</code>일 때만 적용되어야 합니다.\n코드를 <code><a href=\"api/router/Route#pathMatch\" class=\"code-anchor\">pathMatch</a> = '<a href=\"api/core/Version#full\" class=\"code-anchor\">full</a>'</code>로 다시 수정하는 것을 잊지 마세요.</p>\n<p>리다이렉트에 대한 내용은 Victor Savkin이 작성한 <a href=\"http://victorsavkin.com/post/146722301646/angular-router-empty-paths-componentless-routes\">블로그 글</a>에서 자세하게 확인할 수 있습니다.</p>\n</div>\n<!--\n### Basics wrap up\n-->\n<h3 id=\"기본내용-정리\">기본내용 정리<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#기본내용-정리\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou've got a very basic navigating app, one that can switch between two views\nwhen the user clicks a link.\n-->\n<p>지금까지 애플리케이션에 네비게이션을 적용하는 방법 중 기본 내용에 대해 알아봤습니다. 이제 사용자가 링크를 클릭하면 서로 다른 뷰를 전환할 수 있습니다.</p>\n<!--\nYou've learned how to do the following:\n\n* Load the router library.\n* Add a nav bar to the shell template with anchor tags, `routerLink`  and `routerLinkActive` directives.\n* Add a `router-outlet` to the shell template where views will be displayed.\n* Configure the router module with `RouterModule.forRoot`.\n* Set the router to compose HTML5 browser URLs.\n* handle invalid routes with a `wildcard` route.\n* navigate to the default route when the app launches with an empty path.\n-->\n<p>지금까지 이런 내용에 대해 알아봤습니다:</p>\n<ul>\n<li>라우터 라이브러리를 로드하는 방법</li>\n<li>앱 컴포넌트 템플릿에 앵커 태그를 추가하고 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code>와 <code><a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a></code> 디렉티브를 적용하는 방법</li>\n<li>라우팅 대상 컴포넌트를 화면에 표시하기 위해 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a></code>을 추가하는 방법</li>\n<li><code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 메소드로 라우팅 모듈을 등록하는 방법</li>\n<li>HTML5 브라우저 URL 형식으로 라우터를 정의하는 방법</li>\n<li><code>wildcard</code> 라우팅 규칙으로 유효하지 않은 주소를 처리하는 방법</li>\n<li>애플리케이션이 처음 실행되고 주소표시줄이 비어있을 때 기본 페이지로 이동하는 라우팅 규칙을 정의하는 방법</li>\n</ul>\n<!--\nThe starter app's structure looks like this:\n-->\n<p>이 상태에서 애플리케이션 구조는 다음과 같습니다:</p>\n<div class=\"filetree\">\n  <div class=\"file\">\n    angular-router-sample\n  </div>\n  <div class=\"children\">\n    <div class=\"file\">\n      src\n    </div>\n    <div class=\"children\">\n      <div class=\"file\">\n        app\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          crisis-list\n        </div>\n        <div class=\"children\">\n          <div class=\"file\">\n<p>            crisis-list.component.css</p>\n          </div>\n          <div class=\"file\">\n<p>            crisis-list.component.html</p>\n          </div>\n          <div class=\"file\">\n<p>            crisis-list.component.ts</p>\n          </div>\n        </div>\n        <div class=\"file\">\n          hero-list\n        </div>\n        <div class=\"children\">\n          <div class=\"file\">\n<p>            hero-list.component.css</p>\n          </div>\n          <div class=\"file\">\n<p>            hero-list.component.html</p>\n          </div>\n          <div class=\"file\">\n<p>            hero-list.component.ts</p>\n          </div>\n          \n        </div>\n        <div class=\"file\">\n          page-not-found\n        </div>\n        <div class=\"children\">\n          <div class=\"file\">\n<p>            page-not-found.component.css</p>\n          </div>\n          <div class=\"file\">\n<p>            page-not-found.component.html</p>\n          </div>\n          <div class=\"file\">\n<p>            page-not-found.component.ts</p>\n          </div>\n          \n        </div>\n        <div class=\"file\">\n          app.component.css\n        </div>\n        <div class=\"file\">\n          app.component.html\n        </div>\n        <div class=\"file\">\n          app.component.ts\n        </div>\n        <div class=\"file\">\n          app.module.ts\n        </div>\n      </div>\n      <div class=\"file\">\n        main.ts\n      </div>\n      <div class=\"file\">\n        index.html\n      </div>\n      <div class=\"file\">\n        styles.css\n      </div>\n      <div class=\"file\">\n        tsconfig.json\n      </div>\n    </div>\n    <div class=\"file\">\n      node_modules ...\n    </div>\n    <div class=\"file\">\n      package.json\n    </div>\n  </div>\n</div>\n<!--\nHere are the files discussed in this milestone.\n-->\n<p>그리고 이 섹션에서 다뤘던 파일들의 내용은 이렇습니다.</p>\n<code-tabs>\n\n  <code-pane header=\"app.component.html\" path=\"router/src/app/app.component.1.html\">\n&#x3C;h1>Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>&#x3C;/h1>\n&#x3C;nav>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/crisis-center\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Crisis Center&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/heroes\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Heroes&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n&#x3C;/nav>\n&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n\n</code-pane>\n\n  <code-pane header=\"app.module.ts\" path=\"router/src/app/app.module.1.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }             from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> }        from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> }          from '@angular/forms';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { AppComponent }          from './app.component';\nimport { CrisisListComponent }   from './crisis-list/crisis-list.component';\nimport { HeroListComponent }     from './hero-list/hero-list.component';\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\n\nconst appRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'crisis-center', component: CrisisListComponent },\n  { path: 'heroes', component: HeroListComponent },\n\n  { path: '',   <a href=\"api/router/Route#redirectTo\" class=\"code-anchor\">redirectTo</a>: '/heroes', <a href=\"api/router/Route#pathMatch\" class=\"code-anchor\">pathMatch</a>: '<a href=\"api/core/Version#full\" class=\"code-anchor\">full</a>' },\n  { path: '**', component: PageNotFoundComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    RouterModule.forRoot(\n      appRoutes,\n      { <a href=\"api/router/ExtraOptions#enableTracing\" class=\"code-anchor\">enableTracing</a>: true } // &#x3C;-- 디버그 활성화\n    )\n  ],\n  <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [\n    AppComponent,\n    HeroListComponent,\n    CrisisListComponent,\n    PageNotFoundComponent\n  ],\n  <a href=\"api/core/NgModule#bootstrap\" class=\"code-anchor\">bootstrap</a>: [ AppComponent ]\n})\nexport class AppModule { }\n\n\n</code-pane>\n\n  <code-pane header=\"hero-list/hero-list.component.html\" path=\"router/src/app/hero-list/hero-list.component.html\">\n&#x3C;h2>HEROES&#x3C;/h2>\n&#x3C;p><a href=\"api/http/RequestMethod#Get\" class=\"code-anchor\">Get</a> your heroes here&#x3C;/p>\n\n&#x3C;button <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/sidekicks\">Go to sidekicks&#x3C;/button>\n\n\n</code-pane>\n\n  <code-pane header=\"crisis-list/crisis-list.component.html\" path=\"router/src/app/crisis-list/crisis-list.component.html\">\n&#x3C;h2>CRISIS CENTER&#x3C;/h2>\n&#x3C;p><a href=\"api/http/RequestMethod#Get\" class=\"code-anchor\">Get</a> your crisis here&#x3C;/p>\n\n\n</code-pane>\n\n  <code-pane header=\"page-not-found/page-not-found.component.html\" path=\"router/src/app/page-not-found/page-not-found.component.html\">\n&#x3C;h2>Page not found&#x3C;/h2>\n\n</code-pane>\n\n  <code-pane header=\"index.html\" path=\"router/src/index.html\">\n&#x3C;html lang=\"en\">\n  &#x3C;head>\n    &#x3C;!-- Set the base <a href=\"api/router/RouterLinkWithHref#href\" class=\"code-anchor\">href</a> -->\n    &#x3C;base <a href=\"api/router/RouterLinkWithHref#href\" class=\"code-anchor\">href</a>=\"/\">\n    &#x3C;title>Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>&#x3C;/title>\n    &#x3C;meta charset=\"UTF-8\">\n    &#x3C;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  &#x3C;/head>\n\n  &#x3C;body>\n    &#x3C;app-root>&#x3C;/app-root>\n  &#x3C;/body>\n\n&#x3C;/html>\n\n</code-pane>\n\n</code-tabs>\n<a id=\"routing-module\"></a>\n<!--\n## Milestone 2: *Routing module*\n-->\n<h2 id=\"2단계-라우팅-모듈-routing-module\">2단계: <em>라우팅 모듈 (Routing module)</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#2단계-라우팅-모듈-routing-module\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nIn the initial route configuration, you provided a simple setup with two routes used\nto configure the application for routing. This is perfectly fine for simple routing.\nAs the application grows and you make use of more `Router` features, such as guards,\nresolvers, and child routing, you'll naturally want to refactor the routing configuration into its own file.\nWe recommend moving the routing information into a special-purpose module called a *Routing Module*.\n-->\n<p>초기 버전의 라우터 설정에는 간단한 라우팅 규칙 2개가 정의되어 있습니다. 라우팅 규칙이 간단하다면 이런 방식으로 정의해도 아무 문제 없습니다. 하지만 애플리케이션이 점점 커지면 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>의 기능을 좀 더 많이 사용하게 되고, 가드나 리졸버, 자식 라우팅과 같은 기능을 도입하게 되면 라우팅 설정을 개별 파일로 리팩토링하는 것이 더 편할 수 있습니다.\nAngular 코어 팀은 라우팅과 관련된 설정을 따로 모아 <em>라우팅 모듈</em> 로 정의하는 것을 권장합니다.</p>\n<!--\nThe **Routing Module** has several characteristics:\n\n* Separates routing concerns from other application concerns.\n* Provides a module to replace or remove when testing the application.\n* Provides a well-known location for routing service providers including guards and resolvers.\n* Does **not** declare components.\n-->\n<p><strong>라우팅 모듈</strong>은 다음과 같은 특징이 있습니다:</p>\n<ul>\n<li>애플리케이션 로직과 라우팅 로직을 분리하기 위해 존재합니다.</li>\n<li>애플리케이션을 테스트할 때 라우팅 모듈을 다른 설정으로 대체하거나 제거한 채로 실행할 수 있습니다.</li>\n<li>라우터 가드나 리졸버에 대한 프로바이더를 제공합니다.</li>\n<li>라우팅 모듈에는 컴포넌트를 등록하지 <strong>않습니다</strong>.</li>\n</ul>\n<a id=\"integrate-routing\"></a>\n<!--\n### Integrate routing with your app\n-->\n<h3 id=\"라우팅-규칙-정리하기\">라우팅 규칙 정리하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#라우팅-규칙-정리하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe sample routing application does not include routing by default.\nWhen you use the [Angular CLI](cli) to create a project that will use routing, set the `--routing` option for the project or app, and for each NgModule. \nWhen you create or initialize a new project (using the CLI [`ng new`](cli/new) command) or a new app (using the [`ng generate app`](cli/generate) command), specify the `--routing` option.  This tells the CLI to include the `@angular/router` npm package and create a file named `app-routing.module.ts`.\nYou can then use routing in any NgModule that you add to the project or app.\n-->\n<p>애플리케이션을 새로 만들면 라우팅 설정이 존재하지 않습니다.\n그런데 애플리케이션을 <a href=\"cli\">Angular CLI</a>로 생성하면서 <code>--routing</code> 옵션을 사용하면 라우팅 모듈을 함께 생성할 수 있습니다.\n이 옵션은 <a href=\"cli/new\"><code>ng new</code></a> 명령으로 새로운 프로젝트를 생성하거나 <a href=\"cli/generate\"><code>ng generate app</code></a>로 새로운 애플리케이션을 생성할 때 사용할 수 있습니다. 그러면 Angular CLI가 <code>@angular/router</code> npm 패키지를 로드하는 <code>app-routing.module.ts</code> 파일을 자동으로 생성합니다.\n라우팅 모듈은 프로젝트와 애플리케이션에 존재하는 모든 NgModule에 적용할 수 있습니다.</p>\n<!--\nFor example, the following command generates an NgModule that can use routing.\n\n```sh\nng generate module my-module --routing\n```\n\nThis creates a separate file named `my-module-routing.module.ts` to store the NgModule's routes.\nThe file includes an empty `Routes` object that you can fill with routes to different components and NgModules.\n-->\n<p>NgModule을 만들면서 라우팅 모듈을 함께 생성하려면 다음 명령을 실행하면 됩니다.</p>\n<code-example language=\"sh\">\nng generate module my-module --routing\n</code-example>\n<p>그러면 NgModule이 생성되면서 이 모듈의 라우팅 설정을 담당하는 <code>my-module-routing.module.ts</code> 파일이 생성됩니다.\n이 파일에는 비어있는 <code><a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a></code> 객체가 정의되어 있기 때문에, 이 객체에 라우팅 규칙을 등록하면 됩니다.</p>\n<a id=\"routing-refactor\"></a>\n<!--\n### Refactor the routing configuration into a _routing module_\n-->\n<h3 id=\"라우터-설정을-라우팅-모듈-로-옮기기\">라우터 설정을 <em>라우팅 모듈</em> 로 옮기기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#라우터-설정을-라우팅-모듈-로-옮기기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nCreate an `AppRouting` module in the `/app` folder to contain the routing configuration.\n-->\n<p><code>/app</code> 폴더에 <code>AppRouting</code> 모듈을 생성하려면 다음 명령을 실행하면 됩니다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate module app-routing --module app --flat\n</code-example>\n<!--\nImport the `CrisisListComponent`, `HeroListComponent`, and `PageNotFoundComponent` symbols\njust like you did in the `app.module.ts`. Then move the `Router` imports\nand routing configuration, including `RouterModule.forRoot`, into this routing module.\n\nRe-export the Angular `RouterModule` by adding it to the module `exports` array.\nBy re-exporting the `RouterModule` here the components declared in `AppModule` will have access to router directives such as `RouterLink` and `RouterOutlet`.\n\nAfter these steps, the file should look like this.\n-->\n<p>그리고 나면 <code>app.module.ts</code> 파일에 작성했던 것처럼 <code>CrisisListComponent</code>, <code>HeroListComponent</code>, <code>PageNotFoundComponent</code> 심볼을 로드해서 라우팅 규칙을 등록하면 됩니다. <code>app.module.ts</code> 파일에 설정했던 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 설정이 라우팅 모듈로 옮겨가기 때문에 <code>RouterModule.forRoot</code> 메소드를 사용하는 부분도 라우팅 모듈로 옮기면 됩니다.</p>\n<p>라우팅 모듈은 Angular에서 제공하는 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>을 모듈의 <code><a href=\"api/core/NgModule#exports\" class=\"code-anchor\">exports</a></code> 배열에 등록해서 모듈 외부로 공개해야 합니다.\n그래야 <code>AppModule</code> 범위에서도 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>나 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>과 같은 라우터 관련 디렉티브를 사용할 수 있습니다.</p>\n<p>이 과정을 마치고 나면 라우팅 모듈이 다음과 같이 구성될 것입니다.</p>\n<code-example path=\"router/src/app/app-routing.module.1.ts\" header=\"src/app/app-routing.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }              from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> }  from '@angular/router';\n\nimport { CrisisListComponent }   from './crisis-list/crisis-list.component';\nimport { HeroListComponent }     from './hero-list/hero-list.component';\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\n\nconst appRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'crisis-center', component: CrisisListComponent },\n  { path: 'heroes',        component: HeroListComponent },\n  { path: '',   <a href=\"api/router/Route#redirectTo\" class=\"code-anchor\">redirectTo</a>: '/heroes', <a href=\"api/router/Route#pathMatch\" class=\"code-anchor\">pathMatch</a>: '<a href=\"api/core/Version#full\" class=\"code-anchor\">full</a>' },\n  { path: '**', component: PageNotFoundComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    RouterModule.forRoot(\n      appRoutes,\n      { <a href=\"api/router/ExtraOptions#enableTracing\" class=\"code-anchor\">enableTracing</a>: true } // &#x3C;-- 디버그 활성화\n    )\n  ],\n  <a href=\"api/core/NgModule#exports\" class=\"code-anchor\">exports</a>: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class AppRoutingModule {}\n\n\n</code-example>\n<!--\nNext, update the `app.module.ts` file, removing `RouterModule.forRoot` in \nthe `imports` array.\n-->\n<p>그 다음에는 <code>app.module.ts</code> 파일에서 이전에 <code><a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a></code> 배열에 등록했던 <code>RouterModule.forRoot</code>를 제거하고 라우팅 모듈을 로드합니다.</p>\n<code-example path=\"router/src/app/app.module.2.ts\" header=\"src/app/app.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }       from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> }  from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> }    from '@angular/forms';\n\nimport { AppComponent }     from './app.component';\nimport { AppRoutingModule } from './app-routing.module';\n\nimport { CrisisListComponent }   from './crisis-list/crisis-list.component';\nimport { HeroListComponent }     from './hero-list/hero-list.component';\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    AppRoutingModule\n  ],\n  <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [\n    AppComponent,\n    HeroListComponent,\n    CrisisListComponent,\n    PageNotFoundComponent\n  ],\n  <a href=\"api/core/NgModule#bootstrap\" class=\"code-anchor\">bootstrap</a>: [ AppComponent ]\n})\nexport class AppModule { }\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\nLater in this guide you will create [multiple routing modules](#heroes-functionality) and discover that\nyou must import those routing modules [in the correct order](#routing-module-order).\n-->\n<p>이 가이드 문서를 따라가다보면 <a href=\"guide/router#heroes-functionality\">라우팅 모듈을 여러개</a> 만들게 될 것입니다. 라우팅 모듈은 모두 <a href=\"guide/router#routing-module-order\">올바른 순서로</a> 로드되어야 합니다.</p>\n</div>\n<!--\nThe application continues to work just the same, and you can use `AppRoutingModule` as\nthe central place to maintain future routing configuration.\n-->\n<p>이렇게 수정해도 애플리케이션은 이전과 똑같이 동작하며, 이렇게 만든 <code>AppRoutingModule</code>은 애플리케이션 전체 라우팅 설정 중에서도 가장 기초적인 부분을 담당할 것입니다.</p>\n<a id=\"why-routing-module\"></a>\n<!--\n### Do you need a _Routing Module_?\n-->\n<h3 id=\"라우팅-모듈-이-꼭-필요한가요\"><em>라우팅 모듈</em> 이 꼭 필요한가요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#라우팅-모듈-이-꼭-필요한가요\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe _Routing Module_ *replaces* the routing configuration in the root or feature module.\n_Either_ configure routes in the Routing Module _or_ within the module itself but not in both.\n-->\n<p><em>라우팅 모듈</em> 은 애플리케이션 최상위 모듈이나 기능 모듈에 있는 라우팅 설정을 <em>대체하는</em> 용도로 사용합니다.\n사실 라우팅 규칙은 라우팅 모듈에 있거나 기능 모듈 안에 있어도 상관없으며, 양쪽 모두에 있는 경우만 피하는 것이 좋습니다.</p>\n<!--\nThe Routing Module is a design choice whose value is most obvious when the configuration is complex\nand includes specialized guard and resolver services.\nIt can seem like overkill when the actual configuration is dead simple.\n-->\n<p>라우팅 규칙에 가드와 리졸버와 같은 기능이 추가되면서 규칙 전체가 복잡해졌을 때 라우터 구성을 따로 분리해서 모듈을 단순하게 유지하는 것이 라우팅 모듈을 사용하는 이유입니다.\n그래서 라우팅 규칙이 복잡하지 않다면 굳이 라우팅 모듈을 사용할 필요는 없습니다.</p>\n<!--\nSome developers skip the Routing Module (for example, `AppRoutingModule`) when the configuration is simple and\nmerge the routing configuration directly into the companion module (for example, `AppModule`).\n\nChoose one pattern or the other and follow that pattern consistently.\n-->\n<p>어떤 개발자들은 라우팅 규칙이 그리 복잡하지 않을 때 라우팅 모듈(ex. <code>AppRoutingModule</code>)을 생략하고 관련 모듈(ex. <code>AppModule</code>)에 라우팅 규칙을 바로 선언하는 것을 선호하기도 합니다.</p>\n<p>라우팅 모듈을 사용하거나 사용하지 않는 것 자체는 중요하지 않습니다. 일관된 패턴으로 코드를 작성하는 것이 중요합니다.</p>\n<!--\nMost developers should always implement a Routing Module for the sake of consistency.\nIt keeps the code clean when configuration becomes complex.\nIt makes testing the feature module easier.\nIts existence calls attention to the fact that a module is routed.\nIt is where developers expect to find and expand routing configuration.\n-->\n<p>그런데 라우팅 모듈을 도입하는 방식으로 코드의 일관성을 유지하는 개발자들이 더 많은 것으로 보입니다. 그리고 라우팅 모듈을 도입했을 때 얻는 장점도 많습니다.\n라우팅 모듈을 도입하면 라우팅 설정의 복잡도와 관계없이 모듈의 코드는 간결하게 유지할 수 있습니다.\n기능 모듈을 테스트하기도 더 편해집니다.\n모듈에서는 라우팅 된 이후의 로직만 신경쓰면 됩니다.\n라우팅 규칙이 정의된 파일을 쉽게 찾을 수 있으며, 확장하기도 편합니다.</p>\n<a id=\"heroes-feature\"></a>\n<!--\n## Milestone 3: Heroes feature\n-->\n<h2 id=\"3단계-히어로-기능-모듈\">3단계: 히어로 기능 모듈<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#3단계-히어로-기능-모듈\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nYou've seen how to navigate using the `RouterLink` directive.\nNow you'll learn the following:\n\n* Organize the app and routes into *feature areas* using modules.\n* Navigate imperatively from one component to another.\n* Pass required and optional information in route parameters.\n-->\n<p>지금까지 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 디렉티브를 사용해서 네비게이션하는 방법에 대해 알아봤습니다.\n이번에는 다음 내용에 대해 알아봅시다:</p>\n<ul>\n<li>애플리케이션 로직과 라우팅 규칙을 <em>기능 단위</em>의 모듈로 재구축합니다.</li>\n<li>화면에 표시된 컴포넌트를 전환할 수 있는 방법에 대해 알아봅니다.</li>\n<li>라우팅 인자에 필수 항목과 옵션 항목을 전달하는 방법에 대해 알아봅니다.</li>\n</ul>\n<!--\nThis example recreates the heroes feature in the \"Services\" episode of the\n[Tour of Heroes tutorial](tutorial/toh-pt4 \"Tour of Heroes: Services\"),\nand you'll be copying much of the code\nfrom the <live-example name=\"toh-pt4\" title=\"Tour of Heroes: Services example code\"></live-example>.\n\nHere's how the user will experience this version of the app:\n-->\n<p>지금부터 살펴볼 예제 프로젝트는 <a href=\"tutorial/toh-pt4\" title=\"Tour of Heroes: Services\">히어로들의 여정</a> 튜토리얼 중 \"서비스\" 에피소드에서 다뤘던 예제입니다.\n코드를 직접 작성해보려면 <live-example name=\"toh-pt4\" title=\"Tour of Heroes: Services example code\"></live-example>에서 코드를 다운받으세요.</p>\n<p>이 섹션에서 다루는 앱은 다음과 같이 동작합니다:</p>\n<figure>\n  <img src=\"generated/images/guide/router/router-2-anim.gif\" alt=\"App in action\" width=\"400\" height=\"475\">\n</figure>\n<!--\nA typical application has multiple *feature areas*,\neach dedicated to a particular business purpose.\n\nWhile you could continue to add files to the `src/app/` folder,\nthat is unrealistic and ultimately not maintainable.\nMost developers prefer to put each feature area in its own folder.\n\nYou are about to break up the app into different *feature modules*, each with its own concerns.\nThen you'll import into the main module and navigate among them.\n-->\n<p>일반적으로 애플리케이션에는 여러 <em>기능 단위</em>가 존재하며, 각각은 용도에 맞게 사용됩니다.</p>\n<p>그런데 단순하게 <code>src/app/</code> 폴더에 파일을 하나씩 추가하는 것은 실제 운영할 애플리케이션에 어울리지 않는 방식이고, 유지보수를 어렵게 만드는 일이기도 합니다.\n그래서 대다수의 개발자들은 새로 추가되는 기능이 그 기능과 관련된 것들과 함께 있는 것을 선호합니다.</p>\n<p>이제 이 관점에 맞게 애플리케이션을 쪼개서 여러 <em>기능 모듈</em>로 나눌 것입니다.\n그리고 이 기능 모듈들을 메인 모듈에 로드하고 브라우저에서 네비게이션하는 방식으로 활용할 것입니다.</p>\n<a id=\"heroes-functionality\"></a>\n<!--\n### Add heroes functionality\n-->\n<h3 id=\"히어로-모듈-추가하기\">히어로 모듈 추가하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#히어로-모듈-추가하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nFollow these steps:\n-->\n<p>다음 순서대로 진행합니다:</p>\n<!--\n* Create a `HeroesModule` with routing in the heroes folder and register it with the root `AppModule`. This is where you'll be implementing the *hero management*.\n-->\n<ul>\n<li><code>HeroesModule</code>을 라우팅 모듈과 함께 <code>heroes</code> 폴더에 생성하고 이 모듈을 <code>AppModule</code>에 등록합니다. <em>히어로 관리 기능</em>은 이 모듈에 구현할 것입니다.</li>\n</ul>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate module heroes/heroes --module app --flat --routing\n</code-example>\n<!--\n* Move the placeholder `hero-list` folder that's in the `app` into the `heroes` folder.\n* Copy the contents of the `heroes/heroes.component.html` from\n  the <live-example name=\"toh-pt4\" title=\"Tour of Heroes: Services example code\">\"Services\" tutorial</live-example> into the `hero-list.component.html` template.\n\n  * Relabel the `<h2>` to `<h2>HEROES</h2>`.\n  * Delete the `<app-hero-detail>` component at the bottom of the template.\n-->\n<ul>\n<li><code>app</code> 폴더에 있는 <code>hero-list</code> 폴더를 <code>heroes</code> 폴더 안으로 옮깁니다.</li>\n<li>\n<p><live-example name=\"toh-pt4\" title=\"Tour of Heroes: Services example code\">\"Services\" 튜토리얼</live-example>의 <code>heroes/heroes.component.html</code> 파일에 있는 내용을 <code>hero-list.component.html</code> 템플릿 안으로 복사합니다.</p>\n<ul>\n<li><code>&#x3C;h2></code> 태그의 내용을 <code>&#x3C;h2>HEROES&#x3C;/h2></code>로 수정합니다.</li>\n<li>템플릿 아래쪽에 있는 <code>&#x3C;app-hero-detail></code> 컴포넌트를 제거합니다.</li>\n</ul>\n</li>\n</ul>\n<!--\n* Copy the contents of the `heroes/heroes.component.css` from the live example into the `hero-list.component.css` file.\n* Copy the contents of the `heroes/heroes.component.ts` from the live example into the `hero-list.component.ts` file.\n\n  * Change the component class name to `HeroListComponent`.\n  * Change the `selector` to `app-hero-list`.\n-->\n<ul>\n<li>\n<p><code>hero-list.component.css</code> 파일에 있는 내용을 <code>heroes/heroes.component.css</code>로 복사합니다.</p>\n</li>\n<li>\n<p><code>hero-list.component.ts</code> 파일에 있는 내용을 <code>heroes/heroes.component.ts</code>로 복사합니다.</p>\n<ul>\n<li>컴포넌트 클래스 이름을 <code>HeroListComponent</code>로 변경합니다.</li>\n<li>컴포넌트 <code>selector</code>를 <code>app-hero-list</code>로 변경합니다.</li>\n</ul>\n</li>\n</ul>\n<div class=\"alert is-helpful\">\n   <!--\n   Selectors are **not required** for _routed components_ due to the components are dynamically inserted when the page is rendered, but are useful for identifying and targeting them in your HTML element tree.\n   -->\n<p>   <em>라우팅 대상이 될 컴포넌트</em> 는 페이지에 동적으로 렌더링되기 때문에 셀렉터를 <strong>지정하지 않아도 됩니다.</strong> 하지만 HTML 엘리먼트 트리에서 이 컴포넌트를 쉽게 찾으려면 셀렉터를 지정하는 것이 좋습니다.</p>\n</div>\n<!--\n* Copy the `hero-detail` folder, the `hero.ts`, `hero.service.ts`,  and `mock-heroes.ts` files into the `heroes` subfolder.\n* Copy the `message.service.ts` into the `src/app` folder.\n* Update the relative path import to the `message.service` in the `hero.service.ts` file.\n-->\n<ul>\n<li><code>hero-detail</code> 폴더에 있는 <code>hero.ts</code>, <code>hero.service.ts</code>, <code>mock-heroes.ts</code> 파일을 <code>heroes</code> 폴더로 옮깁니다.</li>\n<li><code>message.service.ts</code> 파일을 <code>src/app</code> 폴더로 옮깁니다.</li>\n<li><code>hero.service.ts</code> 파일에서 <code>message.service</code>를 로드하던 경로를 수정합니다.</li>\n</ul>\n<!--\nNext, you'll update the `HeroesModule` metadata.\n\n  * Import and add the `HeroDetailComponent` and `HeroListComponent` to the `declarations` array in the `HeroesModule`.\n-->\n<p>그 다음에는 <code>HeroesModule</code> 메타데이터를 수정합니다.</p>\n<ul>\n<li><code>HeroesModule</code>의 <code><a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a></code> 배열에 <code>HeroDetailComponent</code>와 <code>HeroListComponent</code>를 추가합니다.</li>\n</ul>\n<code-example path=\"router/src/app/heroes/heroes.module.ts\" header=\"src/app/heroes/heroes.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }       from '@angular/core';\nimport { <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> }   from '@angular/common';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> }    from '@angular/forms';\n\nimport { HeroListComponent }    from './hero-list/hero-list.component';\nimport { HeroDetailComponent }  from './hero-detail/hero-detail.component';\n\nimport { HeroesRoutingModule } from './heroes-routing.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    HeroesRoutingModule\n  ],\n  <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [\n    HeroListComponent,\n    HeroDetailComponent\n  ]\n})\nexport class HeroesModule {}\n\n</code-example>\n<!--\nWhen you're done, you'll have these *hero management* files:\n-->\n<p>여기까지 하고 나면 이 모듈은 다음과 같이 구성됩니다.</p>\n<div class=\"filetree\">\n  <div class=\"file\">\n    src/app/heroes\n  </div>\n  <div class=\"children\">\n    <div class=\"file\">\n      hero-detail\n    </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          hero-detail.component.css\n        </div>\n        <div class=\"file\">\n          hero-detail.component.html\n        </div>\n        <div class=\"file\">\n          hero-detail.component.ts\n        </div>\n      </div>\n    <div class=\"file\">\n      hero-list\n    </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          hero-list.component.css\n        </div>\n        <div class=\"file\">\n          hero-list.component.html\n        </div>\n        <div class=\"file\">\n          hero-list.component.ts\n        </div>\n      </div>\n    <div class=\"file\">\n      hero.service.ts\n    </div>    \n    <div class=\"file\">\n      hero.ts\n    </div>\n    <div class=\"file\">\n      heroes-routing.module.ts\n    </div>    \n    <div class=\"file\">\n      heroes.module.ts\n    </div>\n    <div class=\"file\">\n      mock-heroes.ts\n    </div>\n    </div>\n  </div>\n</div>\n<a id=\"hero-routing-requirements\"></a>\n<!--\n#### *Hero* feature routing requirements\n-->\n<h4 id=\"히어로-모듈-라우팅\"><em>히어로</em> 모듈 라우팅<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#히어로-모듈-라우팅\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe heroes feature has two interacting components, the hero list and the hero detail.\nThe list view is self-sufficient; you navigate to it, it gets a list of heroes and displays them.\n\nThe detail view is different. It displays a particular hero. It can't know which hero to show on its own.\nThat information must come from outside.\n\nWhen the user selects a hero from the list, the app should navigate to the detail view\nand show that hero.\nYou tell the detail view which hero to display by including the selected hero's id in the route URL.\n\nImport the hero components from their new locations in the `src/app/heroes/` folder, define the two hero routes.\n\nNow that you have routes for the `Heroes` module, register them with the `Router` via the\n`RouterModule` _almost_ as you did in the `AppRoutingModule`.\n\nThere is a small but critical difference.\nIn the `AppRoutingModule`, you used the static **`RouterModule.forRoot`** method to register the routes and application level service providers.\nIn a feature module you use the static **`forChild`** method.\n-->\n<p>히어로 모듈은 히어로의 목록을 표시하는 컴포넌트와 히어로의 상세 정보를 표시하는 컴포넌트로 구성됩니다.\n리스트를 표시하는 컴포넌트는 별다른 것이 없습니다. 사용자가 이 컴포넌트에 해당하는 주소로 이동하면 컴포넌트가 히어로의 목록을 가져와서 화면에 표시할 것입니다.</p>\n<p>하지만 상세정보를 표시하는 컴포넌트는 좀 다릅니다. 이 컴포넌트는 히어로 한 명의 정보를 화면에 표시하는데, 이 컴포넌트는 어떤 히어로를 표시해야 하는지 스스로 알지 못합니다.\n그래서 이 정보는 외부에서 전달해야 합니다.</p>\n<p>사용자가 히어로 목록에서 히어로를 한 명 선택하면 애플리케이션은 상세정보 화면으로 이동하면서 이 히어로의 정보를 표시해야 합니다.\n이 때 히어로의 id를 라우팅 URL에 포함시키면 네비게이션할 때 이 정보를 활용할 수 있습니다.</p>\n<p>새로 만든 <code>src/app/heroes/</code> 폴더로 옮긴 컴포넌트를 대상으로 라우팅 규칙을 정의해 봅시다.</p>\n<p>이 단계가 <code>Heroes</code> 모듈에 라우팅 규칙을 등록하는 단계입니다. 라우팅 규칙은 <code>AppRoutingModule</code>에서 살펴봤던 것처럼 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>을 사용해서 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>에 등록합니다.</p>\n<p>그런데 이 때 꼭 짚고 넘어가야 할 다른 점이 하나 있습니다.\n<code>AppRoutingModule</code>에서는 애플리케이션 계층에 필요한 라우팅 규칙과 서비스 프로바이더를 등록하기 위해 <strong><code>RouterModule.forRoot</code></strong> 메소드를 사용했습니다.\n하지만 기능 모듈에서는 <strong><code>forChild</code></strong> 메소드를 사용해야 합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nOnly call `RouterModule.forRoot` in the root `AppRoutingModule`\n(or the `AppModule` if that's where you register top level application routes).\nIn any other module, you must call the **`RouterModule.forChild`** method to register additional routes.\n-->\n<p><code>RouterModule.forRoot</code> 메소드는 애플리케이션 최상위 라우팅 모듈인 <code>AppRoutingModule</code> (라우팅 모듈이 따로 없다면 <code>AppModule</code>)에서만 사용합니다.\n다른 모듈에서는 서비스 프로바이더를 생략하고 라우팅 규칙만 등록하기 위해 <strong><code>RouterModule.forChild</code></strong> 메소드를 사용합니다.</p>\n</div>\n<!--\nThe updated `HeroesRoutingModule` looks like this:\n-->\n<p>이제 <code>HeroesRoutingModule</code>은 다음과 같이 변경되었습니다.</p>\n<code-example path=\"router/src/app/heroes/heroes-routing.module.1.ts\" header=\"src/app/heroes/heroes-routing.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }             from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { HeroListComponent }    from './hero-list/hero-list.component';\nimport { HeroDetailComponent }  from './hero-detail/hero-detail.component';\n\nconst heroesRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'heroes',  component: HeroListComponent },\n  { path: 'hero/:id', component: HeroDetailComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    RouterModule.forChild(heroesRoutes)\n  ],\n  <a href=\"api/core/NgModule#exports\" class=\"code-anchor\">exports</a>: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class HeroesRoutingModule { }\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\nConsider giving each feature module its own route configuration file.\nIt may seem like overkill early when the feature routes are simple.\nBut routes have a tendency to grow more complex and consistency in patterns pays off over time.\n-->\n<p>기능모듈마다 각각 라우팅 설정 파일을 두는 것을 권장합니다.\n기능모듈에서 관리하는 라우팅 규칙이 복잡하지 않은 개발 초기에는 이 방식이 번거로워 보일 수도 있지만, 애플리케이션이 점점 복잡해질수록 이렇게 관리하는 방식이 더 편합니다.</p>\n</div>\n<a id=\"remove-duplicate-hero-routes\"></a>\n<!--\n#### Remove duplicate hero routes\n-->\n<h4 id=\"중복된-라우팅-규칙-제거하기\">중복된 라우팅 규칙 제거하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#중복된-라우팅-규칙-제거하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe hero routes are currently defined in _two_ places: in the `HeroesRoutingModule`,\nby way of the `HeroesModule`, and in the `AppRoutingModule`.\n\nRoutes provided by feature modules are combined together into their imported module's routes by the router.\nThis allows you to continue defining the feature module routes without modifying the main route configuration.\n\nRemove the `HeroListComponent` import and the `/heroes` route from the `app-routing.module.ts`.\n\n**Leave the default and the wildcard routes!**\nThese are concerns at the top level of the application itself.\n-->\n<p>이제 히어로 모듈과 관련된 라우팅 규칙은 <code>HeroesModule</code>에서 라우팅을 담당하는 <code>HeroesRoutingModule</code>과 <code>AppRoutingModule</code> 두 군데에 존재합니다.</p>\n<p>모듈의 라우팅 규칙은 해당 모듈이 로드하는 기능 모듈의 모든 라우팅 규칙이 조합되어 구성됩니다.\n그래서 라우팅 규칙은 한 모듈에 모두 정의하는 것이 아니라 자식 모듈에 각각 구현해도 됩니다.</p>\n<p>이제 <code>/heroes</code>와 관련된 라우팅 규칙은 <code>app-routing.module.ts</code> 파일에서 제거합니다.</p>\n<p><strong>기본 라우팅 규칙과 와일드카드 라우팅 규칙은 그대로 두세요!</strong>\n이 라우팅 규칙들은 애플리케이션 최상위 계층에서 처리해야 하는 규칙입니다.</p>\n<code-example path=\"router/src/app/app-routing.module.2.ts\" linenums=\"false\" header=\"src/app/app-routing.module.ts (v2)\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }              from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> }  from '@angular/router';\n\nimport { CrisisListComponent }   from './crisis-list/crisis-list.component';\n// import { HeroListComponent }  from './hero-list/hero-list.component';  // &#x3C;-- 이 줄을 삭제합니다.\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\n\nconst appRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'crisis-center', component: CrisisListComponent },\n  // { path: 'heroes',     component: HeroListComponent }, // &#x3C;-- 이 줄을 삭제합니다.\n  { path: '',   <a href=\"api/router/Route#redirectTo\" class=\"code-anchor\">redirectTo</a>: '/heroes', <a href=\"api/router/Route#pathMatch\" class=\"code-anchor\">pathMatch</a>: '<a href=\"api/core/Version#full\" class=\"code-anchor\">full</a>' },\n  { path: '**', component: PageNotFoundComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    RouterModule.forRoot(\n      appRoutes,\n      { <a href=\"api/router/ExtraOptions#enableTracing\" class=\"code-anchor\">enableTracing</a>: true } // &#x3C;-- 디버그 활성화\n    )\n  ],\n  <a href=\"api/core/NgModule#exports\" class=\"code-anchor\">exports</a>: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class AppRoutingModule {}\n\n\n</code-example>\n<a id=\"merge-hero-routes\"></a>\n<!--\n#### Remove heroes declarations\n-->\n<h4 id=\"히어로-컴포넌트-선언-제거하기\">히어로 컴포넌트 선언 제거하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#히어로-컴포넌트-선언-제거하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nRemove the `HeroListComponent` from the `AppModule`'s `declarations` because it's now provided by the `HeroesModule`. You can evolve the hero feature with more components and different routes. That's a key benefit of creating a separate module for each feature area.\n\nAfter these steps, the `AppModule` should look like this:\n-->\n<p>이제 <code>AppModule</code>의 <code><a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a></code> 목록에서 <code>HeroListComponent</code>를 제거합니다. 이 컴포넌트는 <code>HeroesModule</code>에 등록하는 방식으로 사용할 것입니다. 그리고 히어로와 관련된 컴포넌트나 라우팅 규칙이 추가되는 것도 모두 히어로 모듈에 추가할 것입니다. 기능 모듈을 각각 나눠서 정의하는 것은 Angular 구성요소를 효율적으로 관리하기 위한 것입니다.</p>\n<p>여기까지 수정하고 나면 <code>AppModule</code>은 다음과 같습니다:</p>\n<code-example path=\"router/src/app/app.module.3.ts\" header=\"src/app/app.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }       from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> }  from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> }    from '@angular/forms';\n\nimport { AppComponent }     from './app.component';\nimport { AppRoutingModule } from './app-routing.module';\nimport { HeroesModule }     from './heroes/heroes.module';\n\nimport { CrisisListComponent }   from './crisis-list/crisis-list.component';\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    HeroesModule,\n    AppRoutingModule\n  ],\n  <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [\n    AppComponent,\n    CrisisListComponent,\n    PageNotFoundComponent\n  ],\n  <a href=\"api/core/NgModule#bootstrap\" class=\"code-anchor\">bootstrap</a>: [ AppComponent ]\n})\nexport class AppModule { }\n\n</code-example>\n<a id=\"routing-module-order\"></a>\n<!--\n### Module import order matters\n-->\n<h3 id=\"모듈-로드순서-정리하기\">모듈 로드순서 정리하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#모듈-로드순서-정리하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nLook at the module `imports` array. Notice that the `AppRoutingModule` is _last_.\nMost importantly, it comes _after_ the `HeroesModule`.\n-->\n<p>모듈에 선언한 <code><a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a></code> 배열을 봅시다. 이 모듈 설정을 보면 <code>AppRoutingModule</code>이 <em>가장 마지막에</em> 로드되는 것을 확인할 수 있습니다. <code>AppRoutingModule</code>은 반드시 <code>HeroesModule</code>보다 <em>나중에</em> 로드되어야 합니다.</p>\n<code-example path=\"router/src/app/app.module.3.ts\" region=\"module-imports\" header=\"src/app/app.module.ts (module-imports)\" linenums=\"false\">\n<a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n  <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n  <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n  HeroesModule,\n  AppRoutingModule\n],\n\n</code-example>\n<!--\nThe order of route configuration matters.\nThe router accepts the first route that matches a navigation request path.\n\nWhen all routes were in one `AppRoutingModule`,\nyou put the default and [wildcard](#wildcard) routes last, after the `/heroes` route,\nso that the router had a chance to match a URL to the `/heroes` route _before_\nhitting the wildcard route and navigating to \"Page not found\".\n\nThe routes are no longer in one file.\nThey are distributed across two modules, `AppRoutingModule` and `HeroesRoutingModule`.\n\nEach routing module augments the route configuration _in the order of import_.\nIf you list `AppRoutingModule` first, the wildcard route will be registered\n_before_ the hero routes.\nThe wildcard route&mdash;which matches _every_ URL&mdash;will intercept the attempt to navigate to a hero route.\n-->\n<p>라우팅 규칙은 올바른 순서로 등록되어야 합니다.\n라우터는 라우팅 규칙 중 가장 먼저 매칭된 규칙에 따라 네비게이션 동작을 실행합니다.</p>\n<p>그래서 모든 라우팅 규칙을 <code>AppRoutingModule</code>에 정의했을 처럼 \"Page not found\"로 라우팅하는 와일드카드 라우팅 규칙이 적용되기 <em>전에</em> <code>/heroes</code> 라우팅이 적용되어야 하기 때문에 <code>/heroes</code> 라우팅 규칙 뒤에 <a href=\"guide/router#wildcard\">와일드카드</a> 라우팅 규칙을 등록했습니다.</p>\n<p>지금 수정한 예제에서 라우팅 규칙은 한 파일에만 정의되어 있지 않습니다.\n라우팅 규칙은 <code>AppRoutingModule</code>과 <code>HeroesRoutingModule</code>에 나뉘어 정의되어 있습니다.</p>\n<p>애플리케이션 전체 라우팅 규칙이 조합되는 것은 <em>라우팅 모듈을 로드하는 순서에 영향을 받습니다</em> .\n그래서 <code>AppRoutingModule</code>을 먼저 로드하면 와일드카드 라우팅 규칙이 히어로 모듈의 라우팅 규칙보다 <em>먼저</em> 등록됩니다.\n그리고 와일드카드 라우팅 규칙은 <em>모든</em> URL과 매칭되기 때문에 히어로 모듈에 정의한 라우팅 규칙은 동작하지 않습니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nReverse the routing modules and see for yourself that\na click of the heroes link results in \"Page not found\".\nLearn about inspecting the runtime router configuration\n[below](#inspect-config \"Inspect the router config\").\n-->\n<p>라우팅 모듈을 로드하는 순서를 바꾸고 히어로 모듈로 이동하는 링크를 클릭하면 \"Page not found\" 페이지가 표시됩니다.\n애플리케이션이 실행될 때 동작하는 라우터 설정을 확인하는 방법은 <a href=\"guide/router#inspect-config\" title=\"Inspect the router config\">아래</a> 섹션을 참고하세요.</p>\n</div>\n<!--\n### Route Parameters\n-->\n<h3 id=\"라우팅-변수\">라우팅 변수<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#라우팅-변수\"><i class=\"material-icons\">link</i></a></h3>\n<a id=\"route-def-with-parameter\"></a>\n<!--\n#### Route definition with a parameter\n-->\n<h4 id=\"라우팅-규칙에-변수-활용하기\">라우팅 규칙에 변수 활용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#라우팅-규칙에-변수-활용하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nReturn to the `HeroesRoutingModule` and look at the route definitions again.\nThe route to `HeroDetailComponent` has a twist.\n-->\n<p><code>HeroesRoutingModule</code>로 돌아가서 라우팅 규칙을 다시 한 번 봅시다.\n<code>HeroDetailComponent</code>로 라우팅하는 라우팅 규칙은 다음과 같이 정의되어 있습니다.</p>\n<!--\n<code-example path=\"router/src/app/heroes/heroes-routing.module.1.ts\" linenums=\"false\" header=\"src/app/heroes/heroes-routing.module.ts (excerpt)\" region=\"hero-detail-route\">\n-->\n<code-example path=\"router/src/app/heroes/heroes-routing.module.1.ts\" linenums=\"false\" header=\"src/app/heroes/heroes-routing.module.ts (일부)\" region=\"hero-detail-route\">\n{ path: 'hero/:id', component: HeroDetailComponent }\n\n</code-example>\n<!--\nNotice the `:id` token in the path. That creates a slot in the path for a **Route Parameter**.\nIn this case, the router will insert the `id` of a hero into that slot.\n\nIf you tell the router to navigate to the detail component and display \"Magneta\",\nyou expect a hero id to appear in the browser URL like this:\n-->\n<p>URL 경로에 <code>:id</code> 토큰이 사용된 것을 확인해 보세요. 라우팅 경로를 이렇게 지정하면 <strong>라우팅 변수</strong>를 사용한다는 것을 의미합니다.\n라우터는 이 라우팅 규칙의 <code>id</code> 부분에 사용자가 선택한 히어로의 ID를 할당합니다.</p>\n<p>그래서 \"Magneta\"에 해당하는 히어로의 상세 정보화면으로 이동한다면 브라우저의 URL은 다음과 같이 표시될 것입니다:</p>\n<code-example format=\"nocode\">\n  localhost:4200/hero/15\n\n</code-example>\n<!--\nIf a user enters that URL into the browser address bar, the router should recognize the\npattern and go to the same \"Magneta\" detail view.\n-->\n<p>사용자가 브라우저 주소표시줄에 이 URL을 직접 입력해도 라우터는 라우팅 규칙에 등록된 패턴에 따라 \"Magneta\" 히어로의 상세 정보 화면을 표시합니다.</p>\n<div class=\"callout is-helpful\">\n<header>\n  <!--\n  Route parameter: Required or optional?\n  -->\n  라우팅 변수: 필수일까? 생략해도 될까?\n</header>\n<!--\nEmbedding the route parameter token, `:id`,\nin the route definition path is a good choice for this scenario\nbecause the `id` is *required* by the `HeroDetailComponent` and because\nthe value `15` in the path clearly distinguishes the route to \"Magneta\" from\na route for some other hero.\n-->\n<p>이 예제에서 라우팅 변수의 값이 <code>15</code>이면 <code>HeroDetailComponent</code>는 \"Magneta\"의 상세 정보를 화면에 표시합니다. 따라서 라우팅 변수 토큰 <code>:id</code>는 사용자가 선택한 히어로를 정확하게 지정해야 하기 때문에 <em>필수 항목</em>입니다.</p>\n</div>\n<a id=\"route-parameters\"></a>\n<!--\n#### Setting the route parameters in the list view\n-->\n<h4 id=\"리스트-화면에서-라우팅-변수-설정하기\">리스트 화면에서 라우팅 변수 설정하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#리스트-화면에서-라우팅-변수-설정하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nAfter navigating to the `HeroDetailComponent`, you expect to see the details of the selected hero.\nYou need *two* pieces of information: the routing path to the component and the hero's `id`.\n\nAccordingly, the _link parameters array_ has *two* items:  the routing _path_ and a _route parameter_ that specifies the\n`id` of the selected hero.\n-->\n<p><code>HeroDetailComponent</code>로 이동하고 나면 사용자가 선택한 히어로의 정보가 화면에 표시되어야 합니다.\n그러면 이 정보를 컴포넌트에 전달하기 위해 사용자가 선택한 히어로의 <code>id</code>가 컴포넌트로 이동하는 라우팅 경로에 전달되어야 합니다.</p>\n<!--\n<code-example path=\"router/src/app/heroes/hero-list/hero-list.component.1.ts\" linenums=\"false\" header=\"src/app/heroes/hero-list/hero-list.component.ts (link-parameters-array)\" region=\"link-parameters-array\">\n-->\n<code-example path=\"router/src/app/heroes/hero-list/hero-list.component.1.ts\" linenums=\"false\" header=\"src/app/heroes/hero-list/hero-list.component.ts (링크에 사용된 배열 형태의 인자)\" region=\"link-parameters-array\">\n['/hero', hero.id] // { 15 }\n\n</code-example>\n<!--\nThe router composes the destination URL from the array like this:\n`localhost:4200/hero/15`.\n-->\n<p>라우터는 배열 형태로 전달된 이 주소를 <code>localhost:4200/hero/15</code>로 조합합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nHow does the target `HeroDetailComponent` learn about that `id`?\nDon't analyze the URL. Let the router do it.\n\nThe router extracts the route parameter (`id:15`) from the URL and supplies it to\nthe `HeroDetailComponent` via the `ActivatedRoute` service.\n-->\n<p><code>HeroDetailComponent</code>는 선택된 히어로의 <code>id</code>를 어떻게 알 수 있을까요?\n이 때 URL을 직접 참조하는 방법보다 라우터를 활용하는 방법이 더 좋습니다.</p>\n<p>URL에 사용된 라우팅 변수 (<code>id:15</code>)는 라우터가 파싱하며, 이렇게 파싱된 라우팅 변수는 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 서비스를 통해 <code>HeroDetailComponent</code>에서 확인할 수 있습니다.</p>\n</div>\n<a id=\"activated-route\"></a>\n<!--\n### _Activated Route_ in action\n-->\n<h3 id=\"활성화된-라우팅-규칙-activated-route-활용하기\"><em>활성화된 라우팅 규칙 (Activated Route)</em> 활용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#활성화된-라우팅-규칙-activated-route-활용하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nImport the `Router`, `ActivatedRoute`, and `ParamMap` tokens from the router package.\n-->\n<p>라우터 패키지에서 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>, <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>, <code><a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a></code> 토큰을 로드합니다.</p>\n<!--\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.1.ts\" linenums=\"false\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (activated route)\" region=\"imports\">\n-->\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.1.ts\" linenums=\"false\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (활성화된 라우팅 규칙)\" region=\"imports\">\nimport { <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>, <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, <a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a> } from '@angular/router';\n\n</code-example>\n<!--\nImport the `switchMap` operator because you need it later to process the `Observable` route parameters.\n-->\n<p>그리고 <code>Observable</code> 형태로 제공되는 라우팅 인자를 활용하기 위해 <code>switchMap</code> 연산자도 로드합니다.</p>\n<!--\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.3.ts\" linenums=\"false\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (switchMap operator import)\" region=\"rxjs-operator-import\">\n-->\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.3.ts\" linenums=\"false\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (switchMap 연산자 로드)\" region=\"rxjs-operator-import\">\nimport { switchMap } from 'rxjs/operators';\n\n</code-example>\n<a id=\"hero-detail-ctor\"></a>\n<!--\nAs usual, you write a constructor that asks Angular to inject services\nthat the component requires and reference them as private variables.\n-->\n<p>일반적으로 컴포넌트에 서비스를 의존성으로 주입하는 로직은 컴포넌트 클래스의 생성자에 작성하며, 이렇게 주입받은 의존성 객체는 <code>private</code> 프로퍼티로 선언합니다.</p>\n<!--\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.3.ts\" linenums=\"false\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (constructor)\" region=\"ctor\">\n-->\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.3.ts\" linenums=\"false\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (생성자)\" region=\"ctor\">\nconstructor(\n  private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>,\n  private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,\n  private service: HeroService\n) {}\n\n</code-example>\n<!--\nLater, in the `ngOnInit` method, you use the `ActivatedRoute` service to retrieve the parameters for the route,\npull the hero `id` from the parameters and retrieve the hero to display.\n-->\n<p>그리고 생성자 다음에 실행되는 <code>ngOnInit</code> 메소드에는 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 서비스를 사용해서 라우팅 변수를 참조하는 로직을 작성하는데, 화면에 표시할 히어로를 구분하기 위해 라우팅 변수들 중에 <code>id</code>를 조회합니다.</p>\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.3.ts\" linenums=\"false\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (ngOnInit)\" region=\"ngOnInit\">\nngOnInit() {\n  this.hero$ = this.route.paramMap.pipe(\n    switchMap((params: <a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a>) =>\n      this.service.getHero(params.get('id')))\n  );\n}\n\n</code-example>\n<!--\nThe `paramMap` processing is a bit tricky. When the map changes, you `get()`\nthe `id` parameter from the changed parameters.\n\nThen you tell the `HeroService` to fetch the hero with that `id` and return the result of the `HeroService` request.\n\nYou might think to use the RxJS `map` operator.\nBut the `HeroService` returns an `Observable<Hero>`.\nSo you flatten the `Observable` with the `switchMap` operator instead.\n\nThe `switchMap` operator also cancels previous in-flight requests. If the user re-navigates to this route\nwith a new `id` while the `HeroService` is still retrieving the old `id`, `switchMap` discards that old request and returns the hero for the new `id`.\n\nThe observable `Subscription` will be handled by the `AsyncPipe` and the component's `hero` property will be (re)set with the retrieved hero.\n-->\n<p><code>paramMap</code>을 활용하는 방식이 중요합니다. 이 예제가 실행되면 라우팅 변수 맵이 변경될 때마다 변경된 맵을 대상으로 <code>get()</code> 메소드를 실행하고 <code>id</code> 변수의 값을 참조합니다.</p>\n<p>그러면 이렇게 참조한 <code>id</code>를 <code>HeroService</code>에 전달해서 이 <code>id</code>에 해당되는 히어로의 정보를 서버에서 받아옵니다.</p>\n<p>이 과정에 RxJS <code>map</code> 연산자를 사용하는 것이 맞지 않을까 하는 생각이 들 수도 있습니다.\n하지만 <code>HeroService</code>가 반환하는 것은 <code>Observable&#x3C;Hero></code>이기 때문에 이 <code>Observable</code>을 처리하려면 <code>switchMap</code> 연산자를 사용해야 합니다.</p>\n<p><code>switchMap</code> 연산자는 이전에 발생한 요청을 취소하는 역할도 합니다. 서버의 응답을 받기 전에 사용자가 다른 히어로를 선택해서 새로운 <code>id</code>가 <code>HeroService</code>에 전달되면, <code>switchMap</code> 연산자는 이전에 발생한 요청을 취소하고 새로운 <code>id</code>에 해당하는 요청을 생성합니다.</p>\n<p>그리고 이 옵저버블은 컴포넌트의 <code>hero</code> 프로퍼티 값을 할당하거나 재할당하는데, 컴포넌트 템플릿에 사용된 <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">AsyncPipe</a></code>에 의해 구독이 시작됩니다.</p>\n<h4 id=\"parammap-api\"><em>ParamMap</em> API<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#parammap-api\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe `ParamMap` API is inspired by the [URLSearchParams interface](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams). It provides methods\nto handle parameter access for both route parameters (`paramMap`) and query parameters (`queryParamMap`).\n-->\n<p><code><a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a></code> API는 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams\">URLSearchParams 인터페이스</a>를 기반으로 만들어진 것입니다. 이 인터페이스는 라우팅 변수를 참조할 수 있는 <code>paramMap</code>과 쿼리 인자를 참조할 수 있는 <code>queryParamMap</code>을 제공합니다.</p>\n<table>\n  <tbody><tr>\n    <th style=\"width:6rem;\">\n      <!--\n      Member\n      -->\n      메소드\n    </th>\n    <th>\n      <!--\n      Description\n      -->\n      설명\n    </th>\n  </tr>\n  <tr>\n    <td>\n      <!--\n      <code>has(name)</code>\n      -->\n      <code>has(이름)</code>\n    </td>\n    <td>\n    <!--\n    Returns `true` if the parameter name is in the map of parameters.\n    -->\n<p>    인자로 전달된 이름에 해당하는 변수가 있으면 <code>true</code>를 반환합니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <!--\n      <code>get(name)</code>\n      -->\n      <code>get(이름)</code>\n    </td>\n    <td>\n    <!--\n    Returns the parameter name value (a `string`) if present, or `null` if the parameter name is not in the map. Returns the _first_ element if the parameter value is actually an array of values.\n    -->\n<p>    인자로 전달된 이름에 해당하는 변수가 맵에 있으면 그 변수를 <code>string</code> 타입으로 반환하고, 변수가 존재하지 않으면 <code>null</code>을 반환합니다. 해당 변수가 배열 타입이면 <em>첫번째</em> 엘리먼트를 반환합니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <!--\n      <code>getAll(name)</code>\n      -->\n      <code>getAll(이름)</code>\n    </td>\n    <td>\n    <!--\n    Returns a `string array` of the parameter name value if found, or an empty `array` if the parameter name value is not in the map. Use `getAll` when a single parameter could have multiple values.\n    -->\n<p>    인자로 전달된 이름에 해당하는 변수가 맵에 있으면 <code>string</code> 배열 타입으로 반환하고, 변수가 존재하지 않으면 빈 배열을 반환합니다. 이 메소드는 하나의 변수가 여러번 사용될 때 사용합니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/ParamMap#keys\" class=\"code-anchor\">keys</a></code>\n    </td>\n    <td>\n    <!--\n    Returns a `string array` of all parameter names in the map.\n    -->\n<p>    라우팅 변수 맵에 존재하는 모든 인자를 <code>string</code> 배열 타입으로 반환합니다.</p>\n    </td>\n  </tr>\n</tbody></table>\n<a id=\"reuse\"></a>\n<!--\n#### Observable <i>paramMap</i> and component reuse\n-->\n<h4 id=\"parammap-옵저버블과-컴포넌트-재사용\"><i>paramMap</i> 옵저버블과 컴포넌트 재사용<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#parammap-옵저버블과-컴포넌트-재사용\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nIn this example, you retrieve the route parameter map from an `Observable`.\nThat implies that the route parameter map can change during the lifetime of this component.\n\nThey might. By default, the router re-uses a component instance when it re-navigates to the same component type\nwithout visiting a different component first. The route parameters could change each time.\n\nSuppose a parent component navigation bar had \"forward\" and \"back\" buttons\nthat scrolled through the list of heroes.\nEach click navigated imperatively to the `HeroDetailComponent` with the next or previous `id`.\n\nYou don't want the router to remove the current `HeroDetailComponent` instance from the DOM only to re-create it for the next `id`.\nThat could be visibly jarring.\nBetter to simply re-use the same component instance and update the parameter.\n\nUnfortunately, `ngOnInit` is only called once per component instantiation.\nYou need a way to detect when the route parameters change from _within the same instance_.\nThe observable `paramMap` property handles that beautifully.\n-->\n<p>이 예제에서 라우팅 변수 맵은 <code>Observable</code> 타입으입니다.\n그래서 이 맵은 컴포넌트가 동작하는 동안 현재 상태에 따라 계속 갱신됩니다.</p>\n<p>그래서 라우터는 이 컴포넌트 인스턴스를 사용하는 동안 변경되는 라우팅 변수를 추적하면서 재사용할 수 있습니다. 브라우저가 접근하는 URL이 변경되면 라우팅 변수도 상황에 맞게 변경됩니다.</p>\n<p>부모 컴포넌트에 히어로의 리스트를 탐색하는 \"앞으로\", \"뒤로\" 버튼이 있다고 합시다.\n그러면 이 버튼이 클릭될 때마다 <code>HeroDetailComponent</code>에 전달되는 <code>id</code>도 변경될 것입니다.</p>\n<p>이 때 <code>id</code>가 변경되는 것에 반응하기 위해 DOM에서 <code>HeroDetailComponent</code>를 제거했다가 다시 추가할 필요는 없습니다. 이렇게 구현하면 화면이 깜빡이는 불편함만 더해질 뿐 입니다.\n그래서 이 경우에는 컴포넌트 인스턴스를 그대로 사용하면서 라우팅 변수가 변경되는 것에만 반응하는 것이 더 좋습니다.</p>\n<p>하지만 <code>ngOnInit</code> 함수는 컴포넌트의 인스턴스가 생성될 때 딱 한 번만 실행됩니다.\n그래서 <em>컴포넌트 인스턴스를 유지하면서</em> 라우팅 인자가 변경되는 것을 감지하는 방법이 필요합니다.\n<code>paramMap</code> 프로퍼티가 옵저버블로 제공되는 것은 이런 상황을 위한 것입니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nWhen subscribing to an observable in a component, you almost always arrange to unsubscribe when the component is destroyed.\n\nThere are a few exceptional observables where this is not necessary.\nThe `ActivatedRoute` observables are among the exceptions.\n\nThe `ActivatedRoute` and its observables are insulated from the `Router` itself.\nThe `Router` destroys a routed component when it is no longer needed and the injected `ActivatedRoute` dies with it.\n\nFeel free to unsubscribe anyway. It is harmless and never a bad practice.\n-->\n<p>컴포넌트에서 옵저버블을 구독하면 이 컴포넌트가 종료될 때 구독했던 옵저버블을 해지하는 것이 좋다고 알고 있을 것입니다.</p>\n<p>하지만 이런 로직이 필요하지 않은 경우가 있습니다.\n<code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 옵저버블을 사용하는 경우도 이런 예외에 해당됩니다.</p>\n<p><code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>와 이 서비스가 제공하는 옵저버블은 모두 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>가 직접 관리합니다.\n그래서 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>가 라우팅 대상 컴포넌트를 종료하면 이 컴포넌트에 주입되었던 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>도 함께 종료됩니다.</p>\n<p>옵저버블을 해제하지 않았다고 걱정하지 마세요. 프레임워크가 알아서 처리할 것입니다.</p>\n</div>\n<a id=\"snapshot\"></a>\n<!--\n#### _Snapshot_: the _no-observable_ alternative\n-->\n<h4 id=\"스냅샷-옵저버블-대신-사용하기\"><em>스냅샷</em>: 옵저버블 대신 사용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#스냅샷-옵저버블-대신-사용하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\n_This_ application won't re-use the `HeroDetailComponent`.\nThe user always returns to the hero list to select another hero to view.\nThere's no way to navigate from one hero detail to another hero detail\nwithout visiting the list component in between.\nTherefore, the router creates a new `HeroDetailComponent` instance every time.\n\nWhen you know for certain that a `HeroDetailComponent` instance will *never, never, ever*\nbe re-used, you can simplify the code with the *snapshot*.\n\nThe `route.snapshot` provides the initial value of the route parameter map.\nYou can access the parameters directly without subscribing or adding observable operators.\nIt's much simpler to write and read:\n-->\n<p>지금까지 작성한 애플리케이션은 <code>HeroDetailComponent</code> 인스턴스를 재사용하지 않습니다.\n사용자는 히어로 목록에서 히어로를 한 명 선택해서 상세 정보를 확인하고, 다시 목록 화면으로 돌아가는 것을 반복할 뿐입니다.\n지금까지 구현된 시나리오에서 어떤 히어로의 상세정보를 보다가 다른 히어로의 상세정보로 바로 넘어가는 경우는 없습니다.\n그래서 <code>HeroDetailComponent</code>의 인스턴스는 해당 주소에 접근할 때마다 새로 생성됩니다.</p>\n<p><code>HeroDetailComponent</code>의 인스턴스가 <em>절대로</em> 재사용되지 않는다면 <em>스냅샷(snapshot)</em>을 사용하는 것이 더 간단합니다.</p>\n<p><code>route.snapshot</code>은 라우팅 변수 맵의 초기 값을 제공합니다.\n그래서 이 변수를 참조하면 옵저버블을 구독하거나 옵저버블 연산자를 사용하지 않아도 라우팅 변수를 확인할 수 있습니다.\n코드는 이 방식이 더 간단합니다.</p>\n<!--\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.2.ts\" linenums=\"false\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (ngOnInit snapshot)\" region=\"snapshot\">\n-->\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.2.ts\" linenums=\"false\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (ngOnInit 스냅샷)\" region=\"snapshot\">\nngOnInit() {\n  let id = this.route.snapshot.paramMap.get('id');\n\n  this.hero$ = this.service.getHero(id);\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\n**Remember:** you only get the _initial_ value of the parameter map with this technique.\nStick with the observable `paramMap` approach if there's even a chance that the router\ncould re-use the component.\nThis sample stays with the observable `paramMap` strategy just in case.\n-->\n<p><strong>기억하세요:</strong> 스냅샷을 참조하면 라우팅 변수들의 <em>초기값</em> 만 참조할 수 있습니다.\n그래서 라우터가 컴포넌트를 재사용하는 방식으로 구현하는 경우에는 <code>paramMap</code> 옵저버블을 사용해야 합니다.\n이 예제에서는 <code>paramMap</code> 옵저버블을 사용하는 방식으로 계속 설명합니다.</p>\n</div>\n<a id=\"nav-to-list\"></a>\n<!--\n### Navigating back to the list component\n-->\n<h3 id=\"히어로-목록을-표시하는-컴포넌트로-돌아가기\">히어로 목록을 표시하는 컴포넌트로 돌아가기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#히어로-목록을-표시하는-컴포넌트로-돌아가기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe `HeroDetailComponent` has a \"Back\" button wired to its `gotoHeroes` method that navigates imperatively\nback to the `HeroListComponent`.\n\nThe router `navigate` method takes the same one-item _link parameters array_\nthat you can bind to a `[routerLink]` directive.\nIt holds the _path to the `HeroListComponent`_:\n-->\n<p><code>HeroDetailComponent</code>에는 <code>HeroListComponent</code>로 돌아가기 위해 <code>gotoHeroes</code> 메소드를 실행하는 \"Back\" 버튼이 있습니다.</p>\n<p>이 때 라우터가 제공하는 <code>navigate</code> 메소드에 <em>링크 변수 배열 (link parameters array)</em> 을 전달합니다.\n이 배열에는 <em><code>HeroListComponent</code>로 돌아가는 경로</em> 가 지정되어 있습니다:</p>\n<!--\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.1.ts\" linenums=\"false\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (excerpt)\" region=\"gotoHeroes\">\n-->\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.1.ts\" linenums=\"false\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (일부)\" region=\"gotoHeroes\">\ngotoHeroes() {\n  this.router.navigate(['/heroes']);\n}\n\n</code-example>\n<a id=\"optional-route-parameters\"></a>\n<!--\n#### Route Parameters: Required or optional?\n-->\n<h4 id=\"라우팅-변수-필수일까-생략해도-될까\">라우팅 변수: 필수일까? 생략해도 될까?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#라우팅-변수-필수일까-생략해도-될까\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nUse [*route parameters*](#route-parameters) to specify a *required* parameter value *within* the route URL\nas you do when navigating to the `HeroDetailComponent` in order to view the hero with *id* 15:\n-->\n<p><code>HeroDetailComponent</code>를 화면에 표시하면서 특정 히어로를 지정하기 위해 <em>id</em> 15에 해당하는 <a href=\"guide/router#route-parameters\"><em>라우팅 변수</em></a>를 지정해야 했기 때문에 이 라우팅 변수는 필수 항목입니다.</p>\n<code-example format=\"nocode\">\n  localhost:4200/hero/15\n\n</code-example>\n<!--\nYou can also add *optional* information to a route request.\nFor example, when returning to the hero-detail.component.ts list from the hero detail view,\nit would be nice if the viewed hero was preselected in the list.\n-->\n<p>그런데 <em>추가</em> 정보를 제공하기 위해 옵션 라우팅 변수를 사용할 수도 있습니다.\n예를 들면 히어로의 상세정보 화면에서 히어로 목록 화면으로 돌아가면서 이전에 선택되었던 히어로 항목이 어떤 것인지 표시하는 용도로 사용하는 식입니다.</p>\n<figure>\n  <img src=\"generated/images/guide/router/selected-hero.png\" alt=\"Selected hero\" width=\"336\" height=\"110\">\n</figure>\n<!--\nYou'll implement this feature in a moment by including the viewed hero's `id`\nin the URL as an optional parameter when returning from the `HeroDetailComponent`.\n\nOptional information takes other forms. Search criteria are often loosely structured, e.g., `name='wind*'`.\nMultiple values are common&mdash;`after='12/31/2015' & before='1/1/2017'`&mdash;in no\nparticular order&mdash;`before='1/1/2017' & after='12/31/2015'`&mdash; in a\nvariety of formats&mdash;`during='currentYear'`.\n\nThese kinds of parameters don't fit easily in a URL *path*. Even if you could define a suitable URL token scheme,\ndoing so greatly complicates the pattern matching required to translate an incoming URL to a named route.\n\nOptional parameters are the ideal vehicle for conveying arbitrarily complex information during navigation.\nOptional parameters aren't involved in pattern matching and afford flexibility of expression.\n\nThe router supports navigation with optional parameters as well as required route parameters.\nDefine _optional_ parameters in a separate object _after_ you define the required route parameters.\n\nIn general, prefer a *required route parameter* when\nthe value is mandatory (for example, if necessary to distinguish one route path from another);\nprefer an *optional parameter* when the value is optional, complex, and/or multivariate.\n-->\n<p>이런 방식은 <code>HeroDetailComponent</code> 화면에서 봤던 히어로의 <code>id</code>를 히어로 목록에 돌아온 후에도 활용하려고 할 때 사용합니다.</p>\n<p>그런데 추가 정보는 필수 라우팅 변수와 다른 형태가 될 수도 있습니다. 컴포넌트의 결합도를 낮추려고 한다면 <code>name='wind*'</code>와 같이 사용할 수도 있습니다.\n<code>after='12/31/2015' &#x26; before='1/1/2017'</code>와 같이 여러 값을 한 번에 전달할 수도 있으며, 이렇게 사용할 때 인자의 순서는 중요하지 않습니다. <code>before='1/1/2017' &#x26; after='12/31/2015'</code>라고 사용해도 되고 <code>during='currentYear'</code>라고 사용해도 됩니다.</p>\n<p>하지만 이런 형태가 되면 기존에 라우팅 규칙으로 정의했던 URL <em>경로</em> 와는 매칭되지 않을 수 있습니다. 이런 형식의 URL과 매칭되는 라우팅 규칙을 정의하려면 아주 복잡한 패턴 매칭 방법을 구현해야 할 수도 있습니다.</p>\n<p>옵션 라우팅 변수는 애플리케이션을 네비게이션하는 과정에 필요한 정보를 전달하기 위해 사용합니다.\n그리고 이 과정에 라우팅 규칙의 패턴 매칭과 긴밀하게 연결될 필요는 없습니다.</p>\n<p>그래서 라우터는 옵션 라우팅 변수를 일반 라우팅 변수를 사용하는 것처럼 쉽게 사용할 수 있는 문법을 제공합니다.\n일반적으로 라우팅하는 선언 <em>뒤에</em> 객체 형태로 옵션 라우팅 변수를 전달하면 됩니다.</p>\n<p>라우팅 변수가 꼭 필요하다면 <em>필수 라우팅 변수</em>를 사용하는 방식으로 구현하는 것이 좋습니다. 그리고 라우팅 변수를 생략할 수 있거나 이 변수의 형태가 복잡하다면 <em>옵션 라우팅 변수</em>를 사용하는 것이 좋습니다.</p>\n<a id=\"optionally-selecting\"></a>\n<!--\n#### Heroes list: optionally selecting a hero\n-->\n<h4 id=\"히어로-목록-옵션-라우팅-변수로-히어로-선택하기\">히어로 목록: 옵션 라우팅 변수로 히어로 선택하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#히어로-목록-옵션-라우팅-변수로-히어로-선택하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nWhen navigating to the `HeroDetailComponent` you specified the _required_ `id` of the hero-to-edit in the\n*route parameter* and made it the second item of the [_link parameters array_](#link-parameters-array).\n-->\n<p><code>HeroDetailComponent</code>로 네비게이션하는 경우에는 원하는 히어로를 구분하기 위해 <code>id</code> 라우팅 변수가 <em>필수 항목</em> 입니다. 그래서 네비게이션할 때 <a href=\"guide/router#link-parameters-array\"><em>링크 변수 배열</em></a>을 다음과 같이 지정했습니다.</p>\n<!--\n<code-example path=\"router/src/app/heroes/hero-list/hero-list.component.1.ts\" linenums=\"false\" header=\"src/app/heroes/hero-list/hero-list.component.ts (link-parameters-array)\" region=\"link-parameters-array\">\n-->\n<code-example path=\"router/src/app/heroes/hero-list/hero-list.component.1.ts\" linenums=\"false\" header=\"src/app/heroes/hero-list/hero-list.component.ts (링크 변수 배열)\" region=\"link-parameters-array\">\n['/hero', hero.id] // { 15 }\n\n</code-example>\n<!--\nThe router embedded the `id` value in the navigation URL because you had defined it\nas a route parameter with an `:id` placeholder token in the route `path`:\n-->\n<p>그러면 이미 라우팅 규칙에 <code>:id</code> 토큰이 선언되었기 때문에 라우터는 <code>id</code> 값으로 URL을 조합합니다.</p>\n<!--\n<code-example path=\"router/src/app/heroes/heroes-routing.module.1.ts\" linenums=\"false\" header=\"src/app/heroes/heroes-routing.module.ts (hero-detail-route)\" region=\"hero-detail-route\">\n-->\n<code-example path=\"router/src/app/heroes/heroes-routing.module.1.ts\" linenums=\"false\" header=\"src/app/heroes/heroes-routing.module.ts (히어로 상세정보로 라우팅하는 규칙)\" region=\"hero-detail-route\">\n{ path: 'hero/:id', component: HeroDetailComponent }\n\n</code-example>\n<!--\nWhen the user clicks the back button, the `HeroDetailComponent` constructs another _link parameters array_\nwhich it uses to navigate back to the `HeroListComponent`.\n-->\n<p>그리고 <code>HeroDetailComponent</code>에서 사용자가 뒤로가기 버튼을 누르면 화면이 <code>HeroListComponent</code>로 전환되면서 새로운 <em>링크 변수 배열</em> 을 생성합니다.</p>\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.1.ts\" linenums=\"false\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (gotoHeroes)\" region=\"gotoHeroes\">\ngotoHeroes() {\n  this.router.navigate(['/heroes']);\n}\n\n</code-example>\n<!--\nThis array lacks a route parameter because you had no reason to send information to the `HeroListComponent`.\n\nNow you have a reason. You'd like to send the id of the current hero with the navigation request so that the\n`HeroListComponent` can highlight that hero in its list.\nThis is a _nice-to-have_ feature; the list will display perfectly well without it.\n\nSend the `id` with an object that contains an _optional_ `id` parameter.\nFor demonstration purposes, there's an extra junk parameter (`foo`) in the object that the `HeroListComponent` should ignore.\nHere's the revised navigation statement:\n-->\n<p>지금까지는 <code>HeroDetailComponent</code>는 <code>HeroListComponent</code>로 정보를 전달할 필요가 없기 때문에 라우팅 변수를 사용하지 않았습니다.</p>\n<p>이제 정보를 전달해 봅시다. 이제부터는 <code>HeroDetailComponent</code>에 표시하던 히어로의 <code>id</code>를 <code>HeroListComponent</code>로 전달하고, <code>HeroListComponent</code>는 이 <code>id</code>에 해당하는 히어로를 목록에서 찾아 다른 배경색으로 표시하려고 합니다.\n이 기능은 <em>있으면 좋은</em> 기능일 뿐입니다. 이 기능이 없어도 히어로의 목록을 표시하는 기능에는 문제가 없습니다.</p>\n<p><code>HeroDetailComponent</code>는 <code>id</code> 프로퍼티가 있는 <em>옵션</em> 라우팅 변수를 사용합니다.\n그리고 지금 예제에서는 설명을 위해 실제로 사용하지 않는 라우팅 변수(<code>foo</code>)도 객체에 선언했습니다. <code>HeroListComponent</code>는 이 변수를 사용하지 않습니다.\n그러면 히어로의 목록을 표시하는 화면으로 이동하는 로직을 다음과 같이 구현할 수 있습니다:</p>\n<!--\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.3.ts\" linenums=\"false\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (go to heroes)\" region=\"gotoHeroes\">\n-->\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.3.ts\" linenums=\"false\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (히어로 목록 화면으로 이동하기)\" region=\"gotoHeroes\">\ngotoHeroes(hero: Hero) {\n  let heroId = hero ? hero.id : null;\n  // HeroList 컴포넌트에서 히어로를 선택하기 위해 히어로의 id를 전달합니다.\n  // 'foo' 프로퍼티는 사용하지 않는 프로퍼티입니다.\n  this.router.navigate(['/heroes', { id: heroId, foo: 'foo' }]);\n}\n\n</code-example>\n<!--\nThe application still works. Clicking \"back\" returns to the hero list view.\n\nLook at the browser address bar.\n\n\nIt should look something like this, depending on where you run it:\n-->\n<p>애플리케이션은 이전과 마찬가지로 동작합니다. 그리고 <code>HeroDetailComponent</code>에서 \"back\" 버튼을 누르면 히어로의 목록을 표시하는 화면으로 이동합니다.</p>\n<p>브라우저의 주소표시줄이 어떻게 변경되는지 확인해 보세요.</p>\n<p>주소 표시줄은 다음과 같이 표시될 것입니다:</p>\n<code-example language=\"bash\">\n  localhost:4200/heroes;id=15;foo=foo\n\n</code-example>\n<!--\nThe `id` value appears in the URL as (`;id=15;foo=foo`), not in the URL path.\nThe path for the \"Heroes\" route doesn't have an `:id` token.\n\nThe optional route parameters are not separated by \"?\" and \"&\" as they would be in the URL query string.\nThey are **separated by semicolons \";\"**\nThis is *matrix URL* notation&mdash;something you may not have seen before.\n-->\n<p>이 URL에 포함된 <code>id</code> 값은 라우팅 규칙의 URL과 매칭되지 않습니다.\n왜냐하면 히어로의 목록을 표시하는 라우팅 규칙에 <code>:id</code> 토큰이 없기 때문입니다.</p>\n<p>그런데 옵션 라우팅 변수는 일반적인 URL 쿼리 스트링에 사용하는 \"?\"나 \"&#x26;\"로 항목을 구분하지 않습니다.\n옵션 라우팅 변수에서 각 항목은 <strong>세미콜론 \";\"</strong>으로 구분됩니다.\n이 방식은 <em>매트릭스 URL (matrix URL)</em> 표시법입니다.</p>\n<div class=\"alert is-helpful\">\n<!--\n*Matrix URL* notation is an idea first introduced\nin a [1996 proposal](http://www.w3.org/DesignIssues/MatrixURIs.html) by the founder of the web, Tim Berners-Lee.\n\nAlthough matrix notation never made it into the HTML standard, it is legal and\nit became popular among browser routing systems as a way to isolate parameters\nbelonging to parent and child routes. The Router is such a system and provides\nsupport for the matrix notation across browsers.\n\nThe syntax may seem strange to you but users are unlikely to notice or care\nas long as the URL can be emailed and pasted into a browser address bar\nas this one can.\n-->\n<p><em>매트릭스 URL</em> 표기법은 웹을 만든 Tim Berners-Lee가 <a href=\"http://www.w3.org/DesignIssues/MatrixURIs.html\">1996</a>년에 처음 제안한 표기법입니다.</p>\n<p>이 표기법은 HTML 표준이 되지는 못했지만 아직 유효하며, 부모 라우팅과 자식 라우팅에 사용되는 변수를 구분하는 용도로 많이 사용되고 있습니다.\n이 때 라우터는 매트릭스 표기법을 직접 처리하기도 하지만 브라우저에 매트릭스 표기법을 지원하는 용도로도 사용됩니다.</p>\n<p>이 표기법이 낯설어 보일 수도 있지만 사용자가 이 표기법을 꼭 이해해야 하는 것은 아닙니다. 이 표기법을 사용해도 이메일을 보낼 때나 브라우저 주소표시줄에 붙여넣을 때 아무 제약없이 사용할 수 있습니다.</p>\n</div>\n<a id=\"route-parameters-activated-route\"></a>\n<!--\n### Route parameters in the *ActivatedRoute* service\n-->\n<h3 id=\"activatedroute-서비스에서-라우팅-변수-참조하기\"><em>ActivatedRoute</em> 서비스에서 라우팅 변수 참조하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#activatedroute-서비스에서-라우팅-변수-참조하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe list of heroes is unchanged. No hero row is highlighted.\n-->\n<p>아직 히어로의 목록을 표시하는 컴포넌트는 수정하지 않았습니다. 목록에서 배경색이 변경된 항목도 없습니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nThe <live-example></live-example> *does* highlight the selected\nrow because it demonstrates the final state of the application which includes the steps you're *about* to cover.\nAt the moment this guide is describing the state of affairs *prior* to those steps.\n-->\n<p><live-example></live-example>에서 확인하면 히어로의 상세 정보를 확인하고 돌아왔을 때 그 히어로가 목록에서 하이라이트 표시되는 것을 확인할 수 있습니다. 왜냐하면 이 예제에 구현된 코드는 이 단계에서 다루는 내용을 모두 적용한 코드이기 때문입니다.\n이번 섹션에서는 이렇게 구현하는 방법을 설명합니다.</p>\n</div>\n<!--\nThe `HeroListComponent` isn't expecting any parameters at all and wouldn't know what to do with them.\nYou can change that.\n\nPreviously, when navigating from the `HeroListComponent` to the `HeroDetailComponent`,\nyou subscribed to the route parameter map `Observable` and made it available to the `HeroDetailComponent`\nin the `ActivatedRoute` service.\nYou injected that service in the constructor of the `HeroDetailComponent`.\n\nThis time you'll be navigating in the opposite direction, from the `HeroDetailComponent` to the `HeroListComponent`.\n\nFirst you extend the router import statement to include the `ActivatedRoute` service symbol:\n-->\n<p><code>HeroListComponent</code>는 아직 라우팅 변수를 받을 준비가 되어있지 않으며 변수를 받아도 어떤 동작을 해야할지 모릅니다.\n이 내용을 구현해 봅시다.</p>\n<p>이전에는 <code>HeroListComponent</code>에서 <code>HeroDetailComponent</code>로 네비게이션할 때 이 컴포넌트에 주입된 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 서비스에서 제공하는 라우팅 변수 맵 <code>Observable</code>을 구독했었습니다.</p>\n<p>그리고 이번에는 <code>HeroDetailComponent</code>에서 <code>HeroListComponent</code>로 네비게이션하는 경우를 생각해 봅시다.</p>\n<p>먼저 <code>@angular/router</code> 패키지에서 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 서비스 심볼을 로드합니다:</p>\n<code-example path=\"router/src/app/heroes/hero-list/hero-list.component.ts\" linenums=\"false\" header=\"src/app/heroes/hero-list/hero-list.component.ts (import)\" region=\"import-router\">\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\n\n</code-example>\n<!--\nImport the `switchMap` operator to perform an operation on the `Observable` of route parameter map.\n-->\n<p>그리고 <code>switchMap</code> 연산자와 <code>Observable</code> 심볼도 로드합니다.</p>\n<!--\n<code-example path=\"router/src/app/heroes/hero-list/hero-list.component.ts\" linenums=\"false\" header=\"src/app/heroes/hero-list/hero-list.component.ts (rxjs imports)\" region=\"rxjs-imports\">\n-->\n<code-example path=\"router/src/app/heroes/hero-list/hero-list.component.ts\" linenums=\"false\" header=\"src/app/heroes/hero-list/hero-list.component.ts (rxjs 로드)\" region=\"rxjs-imports\">\nimport { Observable } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\n\n</code-example>\n<!--\nThen you inject the `ActivatedRoute` in the `HeroListComponent` constructor.\n-->\n<p>그리고 나면 <code>HeroListComponent</code> 생성자로 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>를 주입합니다.</p>\n<!--\n<code-example path=\"router/src/app/heroes/hero-list/hero-list.component.ts\" linenums=\"false\" header=\"src/app/heroes/hero-list/hero-list.component.ts (constructor and ngOnInit)\" region=\"ctor\">\n-->\n<code-example path=\"router/src/app/heroes/hero-list/hero-list.component.ts\" linenums=\"false\" header=\"src/app/heroes/hero-list/hero-list.component.ts (생성자와 ngOnInit)\" region=\"ctor\">\nexport class HeroListComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  heroes$: Observable&#x3C;Hero[]>;\n  selectedId: number;\n\n  constructor(\n    private service: HeroService,\n    private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>\n  ) {}\n\n  ngOnInit() {\n    this.heroes$ = this.route.paramMap.pipe(\n      switchMap(params => {\n        // `param.get()` 앞에 붙은 (+)는 문자열을 숫자로 변환합니다.\n        this.selectedId = +params.get('id');\n        return this.service.getHeroes();\n      })\n    );\n  }\n}\n\n</code-example>\n<!--\nThe `ActivatedRoute.paramMap` property is an `Observable` map of route parameters. The `paramMap` emits a new map of values that includes `id`\nwhen the user navigates to the component. In `ngOnInit` you subscribe to those values, set the `selectedId`, and get the heroes.\n-->\n<p><code><a href=\"api/router/ActivatedRoute#paramMap\" class=\"code-anchor\">ActivatedRoute.paramMap</a></code> 프로퍼티는 라우팅 변수를 제공하는 <code>Observable</code> 맵입니다. 이 프로퍼티는 사용자가 이 컴포넌트로 네비게이션 할 때마다 <code>id</code>가 포함된 맵을 새로 생성합니다. 그래서 <code>ngOnInit</code> 메소드에서 이 옵저버블을 구독하면 히어로 한 명의 정보를 가져올 때 활용할 수 있습니다.</p>\n<!--\nUpdate the template with a [class binding](guide/template-syntax#class-binding).\nThe binding adds the `selected` CSS class when the comparison returns `true` and removes it when `false`.\nLook for it within the repeated `<li>` tag as shown here:\n-->\n<p>템플릿에 <a href=\"guide/template-syntax#%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%B0%94%EC%9D%B8%EB%94%A9\">CSS 클래스 바인딩</a>을 적용해 봅시다.\n라우팅 변수로 받아온 히어로의 <code>id</code>에 해당하는 엘리먼트에는 <code>selected</code> CSS 클래스를 지정하고, 이 <code>id</code>에 해당하지 않는 엘리먼트에는 <code>selected</code> CSS 클래스를 제거하려고 합니다.\n이 로직은 템플릿에서 반복되는 <code>&#x3C;li></code> 태그에 사용되었습니다:</p>\n<code-example path=\"router/src/app/heroes/hero-list/hero-list.component.html\" linenums=\"false\" header=\"src/app/heroes/hero-list/hero-list.component.html\">\n&#x3C;h2>HEROES&#x3C;/h2>\n&#x3C;ul class=\"heroes\">\n  &#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes$ | <a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>\"\n    [class.selected]=\"hero.id === selectedId\">\n    &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/hero', hero.id]\">\n      &#x3C;span class=\"badge\">{{ hero.id }}&#x3C;/span>{{ hero.name }}\n    &#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n  &#x3C;/li>\n&#x3C;/ul>\n\n&#x3C;button <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/sidekicks\">Go to sidekicks&#x3C;/button>\n\n</code-example>\n<!--\nAdd some styles to apply when the list item is selected.\n-->\n<p>그리고 리스트 항목에 적용되는 스타일을 다음과 같이 정의합니다.</p>\n<code-example path=\"router/src/app/heroes/hero-list/hero-list.component.css\" linenums=\"false\" region=\"selected\" header=\"src/app/heroes/hero-list/hero-list.component.css\">\n.heroes li.selected {\n  background-color: #CFD8DC;\n  color: white;\n}\n.heroes li.selected:hover {\n  background-color: #BBD8DC;\n}\n\n</code-example>\n<!--\nWhen the user navigates from the heroes list to the \"Magneta\" hero and back, \"Magneta\" appears selected:\n-->\n<p>이제 사용자가 히어로 목록에서 \"Magneta\"를 선택했다가 돌아오면 \"Magneta\" 항목이 다음과 같이 표시될 것입니다:</p>\n<figure>\n  <img src=\"generated/images/guide/router/selected-hero.png\" alt=\"Selected List\" width=\"336\" height=\"110\">\n</figure>\n<!--\nThe optional `foo` route parameter is harmless and continues to be ignored.\n-->\n<p><code>foo</code> 옵션 라우팅 변수는 아무 역할도 하지 않습니다.</p>\n<!--\n### Adding routable animations\n-->\n<h3 id=\"라우팅-애니메이션-적용하기\">라우팅 애니메이션 적용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#라우팅-애니메이션-적용하기\"><i class=\"material-icons\">link</i></a></h3>\n<a id=\"route-animation\"></a>\n<!--\n#### Adding animations to the routed component\n-->\n<h4 id=\"컴포넌트를-라우팅하면서-애니메이션-적용하기\">컴포넌트를 라우팅하면서 애니메이션 적용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#컴포넌트를-라우팅하면서-애니메이션-적용하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe heroes feature module is almost complete, but what is a feature without some smooth transitions?\n\nThis section shows you how to add some [animations](guide/animations) to the `HeroDetailComponent`.\n\nFirst import the `BrowserAnimationsModule` and add it to the `imports` array:\n-->\n<p>이제 히어로 기능 모듈은 거의 끝났습니다. 그런데 컴포넌트를 좀 더 자연스럽게 전환하는 방법이 있을까요?</p>\n<p>이번에는 <code>HeroDetailComponent</code>로 화면을 전환하면서 <a href=\"guide/animations\">애니메이션</a>을 적용하는 방법에 대해 알아봅시다.</p>\n<p>먼저 <code>AppModule</code> <code><a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a></code> 배열에 <code><a href=\"api/platform-browser/animations/BrowserAnimationsModule\" class=\"code-anchor\">BrowserAnimationsModule</a></code>을 로드합니다.</p>\n<!--\n<code-example path=\"router/src/app/app.module.ts\" linenums=\"false\" header=\"src/app/app.module.ts (animations-module)\" region=\"animations-module\">\n-->\n<code-example path=\"router/src/app/app.module.ts\" linenums=\"false\" header=\"src/app/app.module.ts (애니메이션 모듈)\" region=\"animations-module\">\nimport { <a href=\"api/platform-browser/animations/BrowserAnimationsModule\" class=\"code-anchor\">BrowserAnimationsModule</a> } from '@angular/platform-browser/animations';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    <a href=\"api/platform-browser/animations/BrowserAnimationsModule\" class=\"code-anchor\">BrowserAnimationsModule</a>,\n  ],\n})\n\n</code-example>\n<!--\nNext, add a `data` object to the routes for `HeroListComponent` and `HeroDetailComponent`. Transitions are based on `states` and you'll use the `animation` data from the route to provide a named animation `state` for the transitions.\n-->\n<p>그리고 <code>HeroListComponent</code>와 <code>HeroDetailComponent</code>에 해당하는 라우팅 규칙에 <code>data</code> 객체를 추가합니다. 이 객체에 <code><a href=\"api/animations/animation\" class=\"code-anchor\">animation</a></code> 데이터를 추가하는데, 전환효과는 이 때 지정된 <code>states</code>를 기반으로 동작할 것입니다.</p>\n<!--\n<code-example path=\"router/src/app/heroes/heroes-routing.module.2.ts\" header=\"src/app/heroes/heroes-routing.module.ts (animation data)\">\n-->\n<code-example path=\"router/src/app/heroes/heroes-routing.module.2.ts\" header=\"src/app/heroes/heroes-routing.module.ts (애니메이션 데이터)\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }             from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { HeroListComponent }    from './hero-list/hero-list.component';\nimport { HeroDetailComponent }  from './hero-detail/hero-detail.component';\n\nconst heroesRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'heroes',  component: HeroListComponent, data: { <a href=\"api/animations/animation\" class=\"code-anchor\">animation</a>: 'heroes' } },\n  { path: 'hero/:id', component: HeroDetailComponent, data: { <a href=\"api/animations/animation\" class=\"code-anchor\">animation</a>: 'hero' } }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    RouterModule.forChild(heroesRoutes)\n  ],\n  <a href=\"api/core/NgModule#exports\" class=\"code-anchor\">exports</a>: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class HeroesRoutingModule { }\n\n</code-example>\n<!--\nCreate an `animations.ts` file in the root `src/app/` folder. The contents look like this:\n-->\n<p>애플리케이션 최상위 폴더인 <code>src/app/</code>에 <code>animations.ts</code> 파일을 생성합니다. 그리고 이 파일의 내용을 다음과 같이 작성합니다:</p>\n<!--\n<code-example path=\"router/src/app/animations.ts\" linenums=\"false\" header=\"src/app/animations.ts (excerpt)\">\n-->\n<code-example path=\"router/src/app/animations.ts\" linenums=\"false\" header=\"src/app/animations.ts (일부)\">\nimport {\n  <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a>, <a href=\"api/animations/animateChild\" class=\"code-anchor\">animateChild</a>, <a href=\"api/animations/group\" class=\"code-anchor\">group</a>,\n  <a href=\"api/animations/transition\" class=\"code-anchor\">transition</a>, <a href=\"api/animations/animate\" class=\"code-anchor\">animate</a>, <a href=\"api/animations/style\" class=\"code-anchor\">style</a>, <a href=\"api/animations/query\" class=\"code-anchor\">query</a>\n} from '@angular/animations';\n\n\n// 라우팅할 때 사용하는 애니메이션\nexport const slideInAnimation =\n  <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a>('routeAnimation', [\n    <a href=\"api/animations/transition\" class=\"code-anchor\">transition</a>('heroes &#x3C;=> hero', [\n      <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({ <a href=\"api/router/Scroll#position\" class=\"code-anchor\">position</a>: 'relative' }),\n      <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':enter, :leave', [\n        <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({\n          <a href=\"api/router/Scroll#position\" class=\"code-anchor\">position</a>: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%'\n        })\n      ]),\n      <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':enter', [\n        <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({ left: '-100%'})\n      ]),\n      <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':leave', <a href=\"api/animations/animateChild\" class=\"code-anchor\">animateChild</a>()),\n      <a href=\"api/animations/group\" class=\"code-anchor\">group</a>([\n        <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':leave', [\n          <a href=\"api/animations/animate\" class=\"code-anchor\">animate</a>('300ms ease-out', <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({ left: '100%'}))\n        ]),\n        <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':enter', [\n          <a href=\"api/animations/animate\" class=\"code-anchor\">animate</a>('300ms ease-out', <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({ left: '0%'}))\n        ])\n      ]),\n      <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':enter', <a href=\"api/animations/animateChild\" class=\"code-anchor\">animateChild</a>()),\n    ])\n  ]);\n\n\n</code-example>\n<!--\nThis file does the following:\n\n* Imports the animation symbols that build the animation triggers, control state, and manage transitions between states.\n\n* Exports a constant named `slideInAnimation` set to an animation trigger named *`routeAnimation`*;\n\n* Defines one *transition* when switching back and forth from the `heroes` and `hero` routes to ease the component in from the left of the screen as it enters the application view (`:enter`), the other to animate the component to the right as it leaves the application view (`:leave`).\n\nYou could also create more transitions for other routes. This trigger is sufficient for the current milestone.\n\nBack in the `AppComponent`, import the `RouterOutlet` token from the `@angular/router` package and the `slideInDownAnimation` from \n`'./animations.ts`.\n\nAdd an `animations` array to the `@Component` metadata's that contains the `slideInDownAnimation`.\n-->\n<p>이 파일의 내용은 이렇습니다:</p>\n<ul>\n<li>\n<p>애니메이션 트리거, 상태 컨트롤, 상태가 변경될 때 적용될 트랜지션을 정의하기 위한 심볼을 로드합니다.</p>\n</li>\n<li>\n<p><em><code>routeAnimation</code></em>라는 이름으로 만든 애니메이션 트리거가 할당된 상수 <code>slideInAnimation</code>를 파일 외부로 공개합니다.</p>\n</li>\n<li>\n<p>이 애니메이션에 정의된 <em>트랜지션</em>은 라우팅 규칙의 상태가 <code>heroes</code>와 <code>hero</code>로 변경될 때마다 새로 들어오는 애플리케이션 뷰(<code>:enter</code>)가 화면 왼쪽에서 나타나고, 이전에 있던 애플리케이션 뷰(<code>:leave</code>)가 화면 오른쪽으로 사라지는 것을 정의한 것입니다.</p>\n</li>\n</ul>\n<p>물론 라우팅 규칙에는 더 많은 트랜지션을 정의할 수도 있습니다. 이 예제에서는 이정도 트리거만 적용해 봅시다.</p>\n<p><code>AppComponent</code>로 돌아가서 <code>@angular/router</code> 패키지에 있는 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code> 토큰과 <code>./animations.ts</code> 파일에 정의한 <code>slideInDownAnimation</code>을 로드합니다.</p>\n<p>그리고 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 메타데이터의 <code>animations</code> 배열에 다음과 같이 <code>slideInDownAnimation</code>을 적용합니다.</p>\n<code-example path=\"router/src/app/app.component.2.ts\" linenums=\"false\" header=\"src/app/app.component.ts (animations)\" region=\"animation-imports\">\nimport { <a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a> } from '@angular/router';\nimport { slideInAnimation } from './animations';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  templateUrl: 'app.component.html',\n  <a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a>: ['app.component.css'],\n  animations: [ slideInAnimation ]\n})\n\n</code-example>\n<!--\nIn order to use the routable animations, you'll need to wrap the `RouterOutlet` inside an element. You'll\nuse the `@routeAnimation` trigger and bind it to the element.\n\nFor the `@routeAnimation` transitions to key off states, you'll need to provide it with the `data` from the `ActivatedRoute`. The `RouterOutlet` is exposed as an `outlet` template variable, so you bind a reference to the router outlet. A variable of `routerOutlet` is an ideal choice.\n-->\n<p>컴포넌트를 라우팅 할 때 애니메이션을 적용하려면 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>을 <code>&#x3C;div></code> 엘리먼트로 한 번 감싸고 이 엘리먼트에 <code>@routeAnimation</code> 트리거를 바인딩하면 됩니다.</p>\n<p><code>@routeAnimation</code> 트랜지션을 특정 상태로 설정하려면 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>를 사용해서 <code>data</code>를 전달하면 됩니다. <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>은 컴포넌트 클래스의 메소드에서 참조하기 위해 <code>outlet</code>이라는 템플릿 변수로 지정했습니다.</p>\n<!--\n<code-example path=\"router/src/app/app.component.2.html\" linenums=\"false\" header=\"src/app/app.component.html (router outlet)\">\n-->\n<code-example path=\"router/src/app/app.component.2.html\" linenums=\"false\" header=\"src/app/app.component.html (라우팅 영역)\">\n&#x3C;h1>Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>&#x3C;/h1>\n&#x3C;nav>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/crisis-center\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Crisis Center&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/heroes\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Heroes&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n&#x3C;/nav>\n&#x3C;div [@routeAnimation]=\"getAnimationData(routerOutlet)\">\n  &#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a> #routerOutlet=\"outlet\">&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n&#x3C;/div>\n\n</code-example>\n<!--\nThe `@routeAnimation` property is bound to the `getAnimationData` with the provided `routerOutlet` reference, so you'll need to define that function in the `AppComponent`. The `getAnimationData` function returns the animation property from the `data` provided through the `ActivatedRoute`. The `animation` property matches the `transition` names you used in the `slideDownAnimation` defined in `animations.ts`.\n-->\n<p>그리고 <code>@routerAnimation</code> 프로퍼티에 <code>routerOutlet</code> 객체를 전달하기 위해 <code>AppComponent</code>에 <code>getAnimationData</code> 함수를 정의합니다. <code>getAnimationData</code> 함수는 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>로 전달된 <code>data</code>에서 애니메이션 프로퍼티 값을 반환합니다. 이렇게 반환된 <code><a href=\"api/animations/animation\" class=\"code-anchor\">animation</a></code> 프로퍼티 값은 <code>animations.ts</code> 파일의 <code>slideDownAnimation</code>에 정의된 <code><a href=\"api/animations/transition\" class=\"code-anchor\">transition</a></code> 이름과 매칭되면서 애니메이션이 동작합니다.</p>\n<!--\n<code-example path=\"router/src/app/app.component.2.ts\" linenums=\"false\" header=\"src/app/app.component.ts (router outlet)\" region=\"function-binding\">\n-->\n<code-example path=\"router/src/app/app.component.2.ts\" linenums=\"false\" header=\"src/app/app.component.ts (라우팅 영역)\" region=\"function-binding\">\nexport class AppComponent {\n  getAnimationData(outlet: <a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a>) {\n    return outlet &#x26;&#x26; outlet.activatedRouteData &#x26;&#x26; outlet.activatedRouteData['<a href=\"api/animations/animation\" class=\"code-anchor\">animation</a>'];\n  }\n}\n\n</code-example>\n<!--\nWhen switching between the two routes, the `HeroDetailComponent` and `HeroListComponent` will ease in from the left when routed to and will slide to the right when navigating away.\n-->\n<p>이제 <code>HeroDetailComponent</code>와 <code>HeroListComponent</code>를 전환하면서 두 라우팅 규칙이 적용되면 네비게이션이 동작할 때마다 화면이 왼쪽으로, 오른쪽으로 전환되는 애니메이션이 동작합니다.</p>\n<a id=\"milestone-3-wrap-up\"></a>\n<!--\n### Milestone 3 wrap up\n-->\n<h3 id=\"3단계-정리\">3단계 정리<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#3단계-정리\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou've learned how to do the following:\n\n* Organize the app into *feature areas*.\n* Navigate imperatively from one component to another.\n* Pass information along in route parameters and subscribe to them in the component.\n* Import the feature area NgModule into the `AppModule`.\n* Applying routable animations based on the page.\n\nAfter these changes, the folder structure looks like this:\n-->\n<p>이번 단계에서는 이런 내용에 대해 알아봤습니다:</p>\n<ul>\n<li>애플리케이션을 <em>기능 단위</em>로 구조화하는 방법</li>\n<li>컴포넌트에서 다른 컴포넌트로 전환하는 방법</li>\n<li>라우팅 변수로 어떤 정보를 전달하고, 이 정보를 컴포넌트에서 받는 방법</li>\n<li>기능 단위로 나눈 NgModule을 <code>AppModule</code>에 로드하는 방법</li>\n<li>라우팅 될 때 컴포넌트에 애니메이션을 적용하는 방법</li>\n</ul>\n<p>그리고 지금까지 내용을 적용하고 난 후의 폴더 구조는 다음과 같습니다:</p>\n<div class=\"filetree\">\n  <div class=\"file\">\n    angular-router-sample\n  </div>\n  <div class=\"children\">\n    <div class=\"file\">\n      src\n    </div>\n    <div class=\"children\">\n      <div class=\"file\">\n        app\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          crisis-list\n        </div>\n          <div class=\"children\">\n            <div class=\"file\">\n              crisis-list.component.css\n            </div>\n            <div class=\"file\">\n              crisis-list.component.html\n            </div>\n            <div class=\"file\">\n              crisis-list.component.ts\n            </div>\n          </div>      \n        <div class=\"file\">\n          heroes\n        </div>\n        <div class=\"children\">\n          <div class=\"file\">\n            hero-detail\n          </div>\n            <div class=\"children\">\n              <div class=\"file\">\n                hero-detail.component.css\n              </div>\n              <div class=\"file\">\n                hero-detail.component.html\n              </div>\n              <div class=\"file\">\n                hero-detail.component.ts\n              </div>\n            </div>\n          <div class=\"file\">\n            hero-list\n          </div>\n            <div class=\"children\">\n              <div class=\"file\">\n                hero-list.component.css\n              </div>\n              <div class=\"file\">\n                hero-list.component.html\n              </div>\n              <div class=\"file\">\n                hero-list.component.ts\n              </div>\n            </div>\n          <div class=\"file\">\n            hero.service.ts\n          </div>    \n          <div class=\"file\">\n            hero.ts\n          </div>\n          <div class=\"file\">\n            heroes-routing.module.ts\n          </div>    \n          <div class=\"file\">\n            heroes.module.ts\n          </div>\n          <div class=\"file\">\n            mock-heroes.ts\n          </div>\n        </div>\n        <div class=\"file\">\n          page-not-found\n        </div>\n        <div class=\"children\">\n          <div class=\"file\">\n<p>            page-not-found.component.css</p>\n          </div>\n          <div class=\"file\">\n<p>            page-not-found.component.html</p>\n          </div>\n          <div class=\"file\">\n<p>            page-not-found.component.ts</p>\n          </div>\n          \n        </div>\n      </div>\n      <div class=\"file\">\n        animations.ts\n      </div>\n      <div class=\"file\">\n        app.component.css\n      </div>\n      <div class=\"file\">\n        app.component.html\n      </div>\n      <div class=\"file\">\n        app.component.ts\n      </div>\n      <div class=\"file\">\n        app.module.ts\n      </div>\n      <div class=\"file\">\n        app-routing.module.ts\n      </div>\n      <div class=\"file\">\n        main.ts\n      </div>\n      <div class=\"file\">\n        message.service.ts\n      </div>      \n      <div class=\"file\">\n        index.html\n      </div>\n      <div class=\"file\">\n        styles.css\n      </div>\n      <div class=\"file\">\n        tsconfig.json\n      </div>\n    </div>\n    <div class=\"file\">\n      node_modules ...\n    </div>\n    <div class=\"file\">\n      package.json\n    </div>\n  </div>\n</div>\n<!--\nHere are the relevant files for this version of the sample application.\n-->\n<p>이번 예제와 관련된 파일의 내용도 확인해 보세요.</p>\n<code-tabs>\n\n  <code-pane header=\"animations.ts\" path=\"router/src/app/animations.ts\">\nimport {\n  <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a>, <a href=\"api/animations/animateChild\" class=\"code-anchor\">animateChild</a>, <a href=\"api/animations/group\" class=\"code-anchor\">group</a>,\n  <a href=\"api/animations/transition\" class=\"code-anchor\">transition</a>, <a href=\"api/animations/animate\" class=\"code-anchor\">animate</a>, <a href=\"api/animations/style\" class=\"code-anchor\">style</a>, <a href=\"api/animations/query\" class=\"code-anchor\">query</a>\n} from '@angular/animations';\n\n\n// 라우팅할 때 사용하는 애니메이션\nexport const slideInAnimation =\n  <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a>('routeAnimation', [\n    <a href=\"api/animations/transition\" class=\"code-anchor\">transition</a>('heroes &#x3C;=> hero', [\n      <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({ <a href=\"api/router/Scroll#position\" class=\"code-anchor\">position</a>: 'relative' }),\n      <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':enter, :leave', [\n        <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({\n          <a href=\"api/router/Scroll#position\" class=\"code-anchor\">position</a>: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%'\n        })\n      ]),\n      <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':enter', [\n        <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({ left: '-100%'})\n      ]),\n      <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':leave', <a href=\"api/animations/animateChild\" class=\"code-anchor\">animateChild</a>()),\n      <a href=\"api/animations/group\" class=\"code-anchor\">group</a>([\n        <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':leave', [\n          <a href=\"api/animations/animate\" class=\"code-anchor\">animate</a>('300ms ease-out', <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({ left: '100%'}))\n        ]),\n        <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':enter', [\n          <a href=\"api/animations/animate\" class=\"code-anchor\">animate</a>('300ms ease-out', <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({ left: '0%'}))\n        ])\n      ]),\n      <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':enter', <a href=\"api/animations/animateChild\" class=\"code-anchor\">animateChild</a>()),\n    ])\n  ]);\n\n\n</code-pane>  \n\n  <code-pane header=\"app.component.html\" path=\"router/src/app/app.component.2.html\">\n&#x3C;h1>Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>&#x3C;/h1>\n&#x3C;nav>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/crisis-center\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Crisis Center&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/heroes\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Heroes&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n&#x3C;/nav>\n&#x3C;div [@routeAnimation]=\"getAnimationData(routerOutlet)\">\n  &#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a> #routerOutlet=\"outlet\">&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n&#x3C;/div>\n\n</code-pane>\n\n  <code-pane header=\"app.component.ts\" path=\"router/src/app/app.component.2.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { <a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a> } from '@angular/router';\nimport { slideInAnimation } from './animations';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  templateUrl: 'app.component.html',\n  <a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a>: ['app.component.css'],\n  animations: [ slideInAnimation ]\n})\nexport class AppComponent {\n  getAnimationData(outlet: <a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a>) {\n    return outlet &#x26;&#x26; outlet.activatedRouteData &#x26;&#x26; outlet.activatedRouteData['<a href=\"api/animations/animation\" class=\"code-anchor\">animation</a>'];\n  }\n}\n\n\n</code-pane>\n\n  <code-pane header=\"app.module.ts\" path=\"router/src/app/app.module.3.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }       from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> }  from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> }    from '@angular/forms';\n\nimport { AppComponent }     from './app.component';\nimport { AppRoutingModule } from './app-routing.module';\nimport { HeroesModule }     from './heroes/heroes.module';\n\nimport { CrisisListComponent }   from './crisis-list/crisis-list.component';\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    HeroesModule,\n    AppRoutingModule\n  ],\n  <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [\n    AppComponent,\n    CrisisListComponent,\n    PageNotFoundComponent\n  ],\n  <a href=\"api/core/NgModule#bootstrap\" class=\"code-anchor\">bootstrap</a>: [ AppComponent ]\n})\nexport class AppModule { }\n\n</code-pane>\n\n  <code-pane header=\"app-routing.module.ts\" path=\"router/src/app/app-routing.module.2.ts\" region=\"milestone3\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }              from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> }  from '@angular/router';\n\nimport { CrisisListComponent }   from './crisis-list/crisis-list.component';\n/* . . . */\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\n\nconst appRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'crisis-center', component: CrisisListComponent },\n/* . . . */\n  { path: '',   <a href=\"api/router/Route#redirectTo\" class=\"code-anchor\">redirectTo</a>: '/heroes', <a href=\"api/router/Route#pathMatch\" class=\"code-anchor\">pathMatch</a>: '<a href=\"api/core/Version#full\" class=\"code-anchor\">full</a>' },\n  { path: '**', component: PageNotFoundComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    RouterModule.forRoot(\n      appRoutes,\n      { <a href=\"api/router/ExtraOptions#enableTracing\" class=\"code-anchor\">enableTracing</a>: true } // &#x3C;-- 디버그 활성화\n    )\n  ],\n  <a href=\"api/core/NgModule#exports\" class=\"code-anchor\">exports</a>: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class AppRoutingModule {}\n\n</code-pane>\n\n  <code-pane header=\"hero-list.component.css\" path=\"router/src/app/heroes/hero-list/hero-list.component.css\">\n/* HeroListComponent에만 적용되는 CSS 스타일 */\n.heroes {\n  margin: 0 0 2em 0;\n  list-style-type: none;\n  padding: 0;\n  width: 15em;\n}\n.heroes li {\n  <a href=\"api/router/Scroll#position\" class=\"code-anchor\">position</a>: relative;\n  cursor: pointer;\n  background-color: #EEE;\n  margin: .5em;\n  padding: .3em 0;\n  height: 1.6em;\n  border-radius: 4px;\n}\n\n.heroes li:hover {\n  color: #607D8B;\n  background-color: #DDD;\n  left: .1em;\n}\n\n.heroes <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> {\n  color: #888;\n  text-decoration: none;\n  <a href=\"api/router/Scroll#position\" class=\"code-anchor\">position</a>: relative;\n  display: block;\n}\n\n.heroes <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>:hover {\n  color:#607D8B;\n}\n\n.heroes .badge {\n  display: inline-block;\n  font-size: small;\n  color: white;\n  padding: 0.8em 0.7em 0 0.7em;\n  background-color: #607D8B;\n  line-height: 1em;\n  <a href=\"api/router/Scroll#position\" class=\"code-anchor\">position</a>: relative;\n  left: -1px;\n  top: -4px;\n  height: 1.8em;\n  min-width: 16px;\n  text-align: right;\n  margin-right: .8em;\n  border-radius: 4px 0 0 4px;\n}\n\nbutton {\n  background-color: #eee;\n  border: none;\n  padding: 5px 10px;\n  border-radius: 4px;\n  cursor: pointer;\n  cursor: hand;\n  font-family: Arial;\n}\n\nbutton:hover {\n  background-color: #cfd8dc;\n}\n\nbutton.delete {\n  <a href=\"api/router/Scroll#position\" class=\"code-anchor\">position</a>: relative;\n  left: 194px;\n  top: -32px;\n  background-color: gray !important;\n  color: white;\n}\n\n.heroes li.selected {\n  background-color: #CFD8DC;\n  color: white;\n}\n.heroes li.selected:hover {\n  background-color: #BBD8DC;\n}\n\n</code-pane>  \n\n  <code-pane header=\"hero-list.component.html\" path=\"router/src/app/heroes/hero-list/hero-list.component.html\">\n&#x3C;h2>HEROES&#x3C;/h2>\n&#x3C;ul class=\"heroes\">\n  &#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes$ | <a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>\"\n    [class.selected]=\"hero.id === selectedId\">\n    &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/hero', hero.id]\">\n      &#x3C;span class=\"badge\">{{ hero.id }}&#x3C;/span>{{ hero.name }}\n    &#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n  &#x3C;/li>\n&#x3C;/ul>\n\n&#x3C;button <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/sidekicks\">Go to sidekicks&#x3C;/button>\n\n</code-pane>  \n\n  <code-pane header=\"hero-list.component.ts\" path=\"router/src/app/heroes/hero-list/hero-list.component.ts\">\n// TODO: CrisisCenter와 비슷하게 수정\nimport { Observable } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\n\nimport { HeroService }  from '../hero.service';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-list',\n  templateUrl: './hero-list.component.html',\n  <a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a>: ['./hero-list.component.css']\n})\nexport class HeroListComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  heroes$: Observable&#x3C;Hero[]>;\n  selectedId: number;\n\n  constructor(\n    private service: HeroService,\n    private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>\n  ) {}\n\n  ngOnInit() {\n    this.heroes$ = this.route.paramMap.pipe(\n      switchMap(params => {\n        // `param.get()` 앞에 붙은 (+)는 문자열을 숫자로 변환합니다.\n        this.selectedId = +params.get('id');\n        return this.service.getHeroes();\n      })\n    );\n  }\n}\n\n\n</code-pane>\n\n  <code-pane header=\"hero-detail.component.html\" path=\"router/src/app/heroes/hero-detail/hero-detail.component.html\">\n&#x3C;h2>HEROES&#x3C;/h2>\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero$ | <a href=\"api/core/testing/async\" class=\"code-anchor\">async</a> as hero\">\n  &#x3C;h3>\"{{ hero.name }}\"&#x3C;/h3>\n  &#x3C;div>\n    &#x3C;label>Id: &#x3C;/label>{{ hero.id }}&#x3C;/div>\n  &#x3C;div>\n    &#x3C;label>Name: &#x3C;/label>\n    &#x3C;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.name\" placeholder=\"name\"/>\n  &#x3C;/div>\n  &#x3C;p>\n    &#x3C;button (click)=\"gotoHeroes(hero)\">Back&#x3C;/button>\n  &#x3C;/p>\n&#x3C;/div>\n\n</code-pane>\n\n  <code-pane header=\"hero-detail.component.ts\" path=\"router/src/app/heroes/hero-detail/hero-detail.component.3.ts\">\nimport { switchMap } from 'rxjs/operators';\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\nimport { <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>, <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, <a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a> } from '@angular/router';\nimport { Observable } from 'rxjs';\n\nimport { HeroService }  from '../hero.service';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-detail',\n  templateUrl: './hero-detail.component.html',\n  <a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a>: ['./hero-detail.component.css']\n})\nexport class HeroDetailComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  hero$: Observable&#x3C;Hero>;\n\n  constructor(\n    private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>,\n    private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,\n    private service: HeroService\n  ) {}\n\n  ngOnInit() {\n    this.hero$ = this.route.paramMap.pipe(\n      switchMap((params: <a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a>) =>\n        this.service.getHero(params.get('id')))\n    );\n  }\n\n  gotoHeroes(hero: Hero) {\n    let heroId = hero ? hero.id : null;\n    // HeroList 컴포넌트에서 히어로를 선택하기 위해 히어로의 id를 전달합니다.\n    // 'foo' 프로퍼티는 사용하지 않는 프로퍼티입니다.\n    this.router.navigate(['/heroes', { id: heroId, foo: 'foo' }]);\n  }\n}\n\n/*\n  this.router.navigate(['/superheroes', { id: heroId, foo: 'foo' }]);\n*/\n\n\n</code-pane>\n\n  <code-pane header=\"hero.service.ts\" path=\"router/src/app/heroes/hero.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\nimport { Observable, of } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport { Hero } from './hero';\nimport { HEROES } from './mock-heroes';\nimport { MessageService } from '../message.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class HeroService {\n\n  constructor(private messageService: MessageService) { }\n\n  getHeroes(): Observable&#x3C;Hero[]> {\n    // TODO: 메시지는 히어로 목록을 가져온 _뒤에_ 보내기\n    this.messageService.add('HeroService: fetched heroes');\n    return of(HEROES);\n  }\n\n  getHero(id: number | string) {\n    return this.getHeroes().pipe(\n      // `id` 앞에 사용된 `+`는 문자열을 숫자로 변환합니다.\n      map((heroes: Hero[]) => heroes.find(hero => hero.id === +id))\n    );\n  }\n}\n\n\n\n</code-pane>\n\n  <code-pane header=\"heroes.module.ts\" path=\"router/src/app/heroes/heroes.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }       from '@angular/core';\nimport { <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> }   from '@angular/common';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> }    from '@angular/forms';\n\nimport { HeroListComponent }    from './hero-list/hero-list.component';\nimport { HeroDetailComponent }  from './hero-detail/hero-detail.component';\n\nimport { HeroesRoutingModule } from './heroes-routing.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    HeroesRoutingModule\n  ],\n  <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [\n    HeroListComponent,\n    HeroDetailComponent\n  ]\n})\nexport class HeroesModule {}\n\n</code-pane>\n\n  <code-pane header=\"heroes-routing.module.ts\" path=\"router/src/app/heroes/heroes-routing.module.2.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }             from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { HeroListComponent }    from './hero-list/hero-list.component';\nimport { HeroDetailComponent }  from './hero-detail/hero-detail.component';\n\nconst heroesRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'heroes',  component: HeroListComponent, data: { <a href=\"api/animations/animation\" class=\"code-anchor\">animation</a>: 'heroes' } },\n  { path: 'hero/:id', component: HeroDetailComponent, data: { <a href=\"api/animations/animation\" class=\"code-anchor\">animation</a>: 'hero' } }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    RouterModule.forChild(heroesRoutes)\n  ],\n  <a href=\"api/core/NgModule#exports\" class=\"code-anchor\">exports</a>: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class HeroesRoutingModule { }\n\n</code-pane>\n\n  <code-pane header=\"message.service.ts\" path=\"router/src/app/message.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class MessageService {\n  <a href=\"api/service-worker/SwPush#messages\" class=\"code-anchor\">messages</a>: string[] = [];\n\n  add(<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>: string) {\n    this.messages.push(<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>);\n  }\n\n  clear() {\n    this.messages = [];\n  }\n}\n\n\n</code-pane>  \n\n</code-tabs>\n<a id=\"milestone-4\"></a>\n<!--\n## Milestone 4: Crisis center feature\n-->\n<h2 id=\"4단계-위기대응센터-기능모듈\">4단계: 위기대응센터 기능모듈<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#4단계-위기대응센터-기능모듈\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nIt's time to add real features to the app's current placeholder crisis center.\n\nBegin by imitating the heroes feature:\n\n* Create a `crisis-center` subfolder in the `src/app` folder.\n* Copy the files and folders from `app/heroes` into the new `crisis-center` folder.\n* In the new files, change every mention of \"hero\" to \"crisis\", and \"heroes\" to \"crises\".\n* Rename the NgModule files to `crisis-center.module.ts` and `crisis-center-routing.module.ts`.\n\nYou'll use mock crises instead of mock heroes:\n-->\n<p>이번에는 애플리케이션에 위기대응센터 기능 모듈을 추가해 봅시다.</p>\n<p>이 모듈은 히어로 기능 모듈을 구현했던 방식과 비슷하게 구현합니다.</p>\n<ul>\n<li><code>src/app</code> 폴더에 <code>crisis-center</code> 폴더를 생성합니다.</li>\n<li><code>app/heroes</code> 폴더에 있는 파일들을 <code>crisis-center</code> 폴더에 복사합니다.</li>\n<li>복사한 파일에서 \"hero\" 키워드를 \"crisis\"로, \"heroes\" 키워드를 \"crises\"로 변경합니다.</li>\n<li>NgModule이 정의된 파일들의 이름을 <code>crisis-center.module.ts</code>와 <code>crisis-center-routing.module.ts</code>로 변경합니다.</li>\n</ul>\n<p>그리고 히어로 모킹 목록 대신 다음과 같은 모킹 목록을 사용합니다:</p>\n<code-example path=\"router/src/app/crisis-center/mock-crises.ts\" header=\"src/app/crisis-center/mock-crises.ts\">\nimport { Crisis } from './crisis';\n\nexport const CRISES: Crisis[] = [\n  { id: 1, name: 'Dragon Burning Cities' },\n  { id: 2, name: 'Sky Rains Great White Sharks' },\n  { id: 3, name: 'Giant Asteroid Heading For Earth' },\n  { id: 4, name: 'Procrastinators Meeting Delayed Again' },\n]\n\n\n</code-example>\n<!--\nThe resulting crisis center is a foundation for introducing a new concept&mdash;**child routing**.\nYou can leave *Heroes* in its current state as a contrast with the *Crisis Center*\nand decide later if the differences are worthwhile.\n-->\n<p>이제부터 위기대응센터를 만들면서 <strong>자식 라우팅</strong>에 대한 컨셉을 알아봅시다.\n이전에 구현했던 <em>히어로</em> 기능 모듈은 새로 만드는 <em>위기대응센터</em> 기능 모듈과 비교해보기 위해 그대로 둔 채 작업합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nIn keeping with the\n<a href=\"https://blog.8thlight.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html\" title=\"Separation of Concerns\">*Separation of Concerns* principle</a>,\nchanges to the *Crisis Center* won't affect the `AppModule` or\nany other feature's component.\n-->\n<p><a href=\"https://blog.8thlight.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html\" title=\"Separation of Concerns\"><em>관심의 분리 (Separation of Concerns)</em> 원칙</a>에 따라 <em>위기대응센터</em>에 대한 코드를 수정하는 것은 <code>AppModule</code>과 다른 기능 모듈의 컴포넌트에 영향을 주지 않는 것으로 간주합니다.</p>\n</div>\n<a id=\"crisis-child-routes\"></a>\n<!--\n### A crisis center with child routes\n-->\n<h3 id=\"위기대응센터와-자식-라우팅-규칙\">위기대응센터와 자식 라우팅 규칙<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#위기대응센터와-자식-라우팅-규칙\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThis section shows you how to organize the crisis center\nto conform to the following recommended pattern for Angular applications:\n\n* Each feature area resides in its own folder.\n* Each feature has its own Angular feature module.\n* Each area has its own area root component.\n* Each area root component has its own router outlet and child routes.\n* Feature area routes rarely (if ever) cross with routes of other features.\n\nIf your app had many feature areas, the app component trees might look like this:\n-->\n<p>이번 섹션에서는 Angular가 권장하는 방식으로 위기관리센터 기능모듈을 개발해 봅시다:</p>\n<ul>\n<li>특정 업무 도메인과 관련된 항목들은 모두 한 폴더에 둡니다.</li>\n<li>특정 업무 도메인은 Angular 기능 모듈로 표현합니다.</li>\n<li>각 기능 모듈에는 최상위 컴포넌트가 존재합니다.</li>\n<li>각 기능 모듈의 최상위 컴포넌트에는 라우팅 영역이 존재하며, 자식 라우팅 규칙도 존재합니다.</li>\n<li>특정 기능 모듈의 라우팅 규칙은 다른 기능 모듈로 이동하는 라우팅 규칙을 최대한 사용하지 않는 것이 좋습니다.</li>\n</ul>\n<p>그래서 애플리케이션에 많은 기능이 추가된다면 컴포넌트 트리가 다음과 같은 모습이 될 것입니다:</p>\n<figure>\n  <img src=\"generated/images/guide/router/component-tree.png\" alt=\"Component Tree\" width=\"473\" height=\"258\">\n</figure>\n<a id=\"child-routing-component\"></a>\n<!--\n### Child routing component\n-->\n<h3 id=\"자식-라우팅-컴포넌트\">자식 라우팅 컴포넌트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#자식-라우팅-컴포넌트\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nGenerate a `CrisisCenter` component in the `crisis-center` folder:\n-->\n<p>다음 명령을 실행해서 <code>crisis-center</code> 폴더에 <code>CrisisCenter</code> 컴포넌트를 생성합니다:</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component crisis-center/crisis-center\n</code-example>\n<!--\nUpdate the component template to look like this:\n-->\n<p>그리고 이 컴포넌트의 템플릿을 다음과 같이 작성합니다:</p>\n<code-example path=\"router/src/app/crisis-center/crisis-center/crisis-center.component.html\" linenums=\"false\" header=\"src/app/crisis-center/crisis-center/crisis-center.component.html\">\n&#x3C;h2>CRISIS CENTER&#x3C;/h2>\n&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n\n</code-example>\n<!--\nThe `CrisisCenterComponent` has the following in common with the `AppComponent`:\n\n* It is the *root* of the crisis center area,\njust as `AppComponent` is the root of the entire application.\n* It is a *shell* for the crisis management feature area,\njust as the `AppComponent` is a shell to manage the high-level workflow.\n\nLike most shells, the `CrisisCenterComponent` class is very simple, simpler even than `AppComponent`:\nit has no business logic, and its template has no links, just a title and\n`<router-outlet>` for the crisis center child component.\n-->\n<p><code>CrisisCenterComponent</code>는 다음과 같은 점에서 <code>AppComponent</code>와 비슷합니다:</p>\n<ul>\n<li>애플리케이션 전체 영역에서 <code>AppComponent</code>가 최상위 컴포넌트인 것처럼, 이 컴포넌트는 위기대응센터와 관련된 기능모듈의 <em>최상위</em> 컴포넌트입니다.</li>\n<li>애플리케이션이 동작하는 영역이 <code>AppComponent</code>인 것처럼, 이 컴포넌트는 위기대응센터와 관련된 기능이 동작하는 영역입니다.</li>\n</ul>\n<p>영역만 정의하는 컴포넌트의 역할에 맞게, <code>CrisisCenterComponent</code> 클래스는 아주 간단하게 작성합니다. 이 클래스에는 비즈니스 로직이 없고 템플릿에 링크도 없으며, 단지 이 기능의 이름과 자식 컴포넌트가 표시될 <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code>만 존재합니다. <code>AppComponent</code>보다도 간단합니다.</p>\n<a id=\"child-route-config\"></a>\n<!--\n### Child route configuration\n-->\n<h3 id=\"자식-라우팅-규칙\">자식 라우팅 규칙<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#자식-라우팅-규칙\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAs a host page for the \"Crisis Center\" feature, generate a `CrisisCenterHome` component in the `crisis-center` folder.\n-->\n<p>\"위기대응센터\" 기능 모듈의 첫 페이지는 <code>crisis-center</code> 폴더의 <code>CrisisCenterHome</code> 컴포넌트가 담당합니다. 다음 명령을 실행해서 이 컴포넌트를 생성합니다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component crisis-center/crisis-center-home\n</code-example>\n<!--\nUpdate the template with a welcome message to the `Crisis Center`.\n-->\n<p>그리고 이 컴포넌트의 템플릿을 다음과 같이 수정합니다.</p>\n<code-example path=\"router/src/app/crisis-center/crisis-center-home/crisis-center-home.component.html\" linenums=\"false\" header=\"src/app/crisis-center/crisis-center-home/crisis-center-home.component.html\">\n&#x3C;p>Welcome to the Crisis Center&#x3C;/p>\n\n</code-example>\n<!--\nUpdate the `crisis-center-routing.module.ts` you renamed after copying it from `heroes-routing.module.ts` file.\nThis time, you define **child routes** *within* the parent `crisis-center` route.\n-->\n<p><code>heroes-routing.module.ts</code> 파일을 복사해서 가져온 <code>crisis-center-routing.module.ts</code> 파일의 내용을 수정합시다.\n이 예제에서 정의하는 <strong>자식 라우팅 규칙</strong>은 모두 <code>crisis-center</code> 주소의 하위 주소로 구성됩니다.</p>\n<code-example path=\"router/src/app/crisis-center/crisis-center-routing.module.1.ts\" linenums=\"false\" header=\"src/app/crisis-center/crisis-center-routing.module.ts (Routes)\" region=\"routes\">\nconst crisisCenterRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'crisis-center',\n    component: CrisisCenterComponent,\n    children: [\n      {\n        path: '',\n        component: CrisisListComponent,\n        children: [\n          {\n            path: ':id',\n            component: CrisisDetailComponent\n          },\n          {\n            path: '',\n            component: CrisisCenterHomeComponent\n          }\n        ]\n      }\n    ]\n  }\n];\n\n</code-example>\n<!--\nNotice that the parent `crisis-center` route has a `children` property\nwith a single route containing the `CrisisListComponent`. The `CrisisListComponent` route\nalso has a `children` array with two routes.\n\nThese two routes navigate to the crisis center child components,\n`CrisisCenterHomeComponent` and `CrisisDetailComponent`, respectively.\n-->\n<p><code>crisis-center</code> 주소에 해당하는 라우팅 규칙에는 <code>CrisisListComponent</code> 컴포넌트가 연결되어 있으며, <code>children</code> 프로퍼티도 존재합니다. <code>CrisisListComponent</code> 라우팅 규칙은 <code>children</code> 배열에 정의된 라우팅 규칙 두 개를 처리합니다.</p>\n<p>그리고 <code>CrisisListComponent</code> 라우팅 규칙의 자식 라우팅 규칙은 <code>CrisisCenterHomeComponent</code>와 <code>CrisisDetailComponent</code>와 연결됩니다.</p>\n<!--\nThere are *important differences* in the way the router treats these _child routes_.\n\nThe router displays the components of these routes in the `RouterOutlet`\nof the `CrisisCenterComponent`, not in the `RouterOutlet` of the `AppComponent` shell.\n\nThe `CrisisListComponent` contains the crisis list and a `RouterOutlet` to\ndisplay the `Crisis Center Home` and `Crisis Detail` route components.\n\nThe `Crisis Detail` route is a child of the `Crisis List`. The router [reuses components](#reuse)\nby default, so the `Crisis Detail` component will be re-used as you select different crises.\nIn contrast, back in the `Hero Detail` route, the component was recreated each time you selected a different hero.\n-->\n<p>이 때 <em>자식 라우팅 규칙</em> 을 처리하면서 <code>AppComponent</code>에서 했던 것과 <em>다른 점</em>이 있습니다.</p>\n<p>자식 라우팅으로 정의된 컴포넌트는 <code>AppComponent</code>의 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>이 아니라 <code>CrisisCenterComponent</code>의 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>에 표시됩니다.</p>\n<p><code>CrisisListComponent</code>는 발생한 위기들의 목록을 표시하면서 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>에 <code>위기대응센터 홈</code> 컴포넌트나 <code>위기 상세정보</code> 컴포넌트를 표시할 것입니다.</p>\n<p><code>위기 상세정보</code>에 연결된 라우팅 규칙은 <code>위기 목록</code>의 자식 라우팅 규칙입니다. 기본적으로 <code>위기 상세정보</code> 라우팅 규칙은 <a href=\"guide/router#reuse\">재사용되는 컴포넌트</a>이며, 사용자가 위기 목록에서 특정 위기를 선택할 때마다 재사용될 것입니다.\n하지만 이와 다르게 <code>Hero Detail</code> 라우팅 규칙은 사용자가 히어로 목록에서 특정 히어로를 선택할 때마다 인스턴스가 다시 생성됩니다.</p>\n<!--\nAt the top level, paths that begin with `/` refer to the root of the application.\nBut child routes *extend* the path of the parent route.\nWith each step down the route tree,\nyou add a slash followed by the route path, unless the path is _empty_.\n\nApply that logic to navigation within the crisis center for which the parent path is `/crisis-center`.\n\n* To navigate to the `CrisisCenterHomeComponent`, the full URL is `/crisis-center` (`/crisis-center` + `''` + `''`).\n\n* To navigate to the `CrisisDetailComponent` for a crisis with `id=2`, the full URL is\n`/crisis-center/2` (`/crisis-center` + `''` +  `'/2'`).\n\nThe absolute URL for the latter example, including the `localhost` origin, is\n-->\n<p>애플리케이션 최상위 계층의 URL은 <code>/</code>로 시작합니다.\n하지만 자식 라우팅 규칙은 부모 라우팅 규칙을 <em>확장</em>하는 개념이기 때문에 <code>/</code>로 시작하지 않습니다.\n자식 라우팅 규칙의 단계를 따라가면서 <em>빈 주소가 지정되어도</em> 이 경로들은 슬래시(<code>/</code>)로 조합됩니다.</p>\n<p>이 개념을 적용하면 위기대응센터 기능모듈이 시작되는 주소를 <code>/crisis-center</code>로 지정할 수 있습니다.</p>\n<ul>\n<li>\n<p><code>CrisisCenterHomeComponent</code>가 표시되는 페이지로 이동하는 전체 URL은 <code>/crisis-center</code> (<code>/crisis-center</code> + <code>''</code> + <code>''</code>) 입니다.</p>\n</li>\n<li>\n<p><code>id=2</code>인 <code>CrisisDetailComponent</code>가 표시되는 페이지로 이동하는 전체 URL은 <code>/crisis-center/2</code> (<code>/crisis-center</code> + <code>''</code> +  <code>'/2'</code>) 입니다.</p>\n</li>\n</ul>\n<p>그리고 절대 URL은 <code>localhost</code>와 같은 도메인을 포함해야 하기 때문에 다음과 같습니다.</p>\n<code-example>\n  localhost:4200/crisis-center/2\n\n</code-example>\n<!--\nHere's the complete `crisis-center-routing.module.ts` file with its imports.\n-->\n<p>이 내용이 모두 구성된 <code>crisis-center-routing.module.ts</code> 파일의 내용은 다음과 같습니다.</p>\n<!--\n<code-example path=\"router/src/app/crisis-center/crisis-center-routing.module.1.ts\" linenums=\"false\" header=\"src/app/crisis-center/crisis-center-routing.module.ts (excerpt)\">\n-->\n<code-example path=\"router/src/app/crisis-center/crisis-center-routing.module.1.ts\" linenums=\"false\" header=\"src/app/crisis-center/crisis-center-routing.module.ts (일부)\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }             from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { CrisisCenterHomeComponent } from './crisis-center-home/crisis-center-home.component';\nimport { CrisisListComponent }       from './crisis-list/crisis-list.component';\nimport { CrisisCenterComponent }     from './crisis-center/crisis-center.component';\nimport { CrisisDetailComponent }     from './crisis-detail/crisis-detail.component';\n\nconst crisisCenterRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'crisis-center',\n    component: CrisisCenterComponent,\n    children: [\n      {\n        path: '',\n        component: CrisisListComponent,\n        children: [\n          {\n            path: ':id',\n            component: CrisisDetailComponent\n          },\n          {\n            path: '',\n            component: CrisisCenterHomeComponent\n          }\n        ]\n      }\n    ]\n  }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    RouterModule.forChild(crisisCenterRoutes)\n  ],\n  <a href=\"api/core/NgModule#exports\" class=\"code-anchor\">exports</a>: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class CrisisCenterRoutingModule { }\n\n</code-example>\n<a id=\"import-crisis-module\"></a>\n<!--\n### Import crisis center module into the *AppModule* routes\n-->\n<h3 id=\"appmodule-라우팅-규칙에-위기대응센터-모듈-로드하기\"><em>AppModule</em> 라우팅 규칙에 위기대응센터 모듈 로드하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#appmodule-라우팅-규칙에-위기대응센터-모듈-로드하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAs with the `HeroesModule`, you must add the `CrisisCenterModule` to the `imports` array of the `AppModule`\n_before_ the `AppRoutingModule`:\n-->\n<p><code>HeroesModule</code>과 마찬가지로 <code>CrisisCenterModule</code>도 <code>AppModule</code>의 <code><a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a></code> 배열에 로드해야 하는데, 이 때 <code>AppRoutingModule</code>보다 <em>먼저</em> 로드해야 합니다:</p>\n<code-tabs>\n\n  <code-pane path=\"router/src/app/crisis-center/crisis-center.module.ts\" header=\"src/app/crisis-center/crisis-center.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }       from '@angular/core';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> }    from '@angular/forms';\nimport { <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> }   from '@angular/common';\n\nimport { CrisisCenterHomeComponent } from './crisis-center-home/crisis-center-home.component';\nimport { CrisisListComponent }       from './crisis-list/crisis-list.component';\nimport { CrisisCenterComponent }     from './crisis-center/crisis-center.component';\nimport { CrisisDetailComponent }     from './crisis-detail/crisis-detail.component';\n\nimport { CrisisCenterRoutingModule } from './crisis-center-routing.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    CrisisCenterRoutingModule\n  ],\n  <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [\n    CrisisCenterComponent,\n    CrisisListComponent,\n    CrisisCenterHomeComponent,\n    CrisisDetailComponent\n  ]\n})\nexport class CrisisCenterModule {}\n\n\n</code-pane> \n\n  <!--\n  <code-pane path=\"router/src/app/app.module.4.ts\" linenums=\"false\" header=\"src/app/app.module.ts (import CrisisCenterModule)\" region=\"crisis-center-module\">\n  -->\n  <code-pane path=\"router/src/app/app.module.4.ts\" linenums=\"false\" header=\"src/app/app.module.ts (CrisisCenterModule 로드)\" region=\"crisis-center-module\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }       from '@angular/core';\nimport { <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> }   from '@angular/common';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> }    from '@angular/forms';\n\nimport { AppComponent }            from './app.component';\nimport { PageNotFoundComponent }   from './page-not-found/page-not-found.component';\nimport { ComposeMessageComponent } from './compose-message/compose-message.component';\n\nimport { AppRoutingModule }        from './app-routing.module';\nimport { HeroesModule }            from './heroes/heroes.module';\nimport { CrisisCenterModule }      from './crisis-center/crisis-center.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    HeroesModule,\n    CrisisCenterModule,\n    AppRoutingModule\n  ],\n  <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [\n    AppComponent,\n    PageNotFoundComponent\n  ],\n  <a href=\"api/core/NgModule#bootstrap\" class=\"code-anchor\">bootstrap</a>: [ AppComponent ]\n})\nexport class AppModule { }\n\n</code-pane>\n\n</code-tabs>\n<!--\nRemove the initial crisis center route from the `app-routing.module.ts`.\nThe feature routes are now provided by the `HeroesModule` and the `CrisisCenter` modules.\n\nThe `app-routing.module.ts` file retains the top-level application routes such as the default and wildcard routes.\n-->\n<p>그리고 <code>app-routing.module.ts</code>에 정의했던 <code>crisis-center</code> 라우팅 규칙을 제거합니다.\n이제 기능 모듈과 관련된 라우팅 규칙은 <code>HeroesModule</code>과 <code>CrisisCenterModule</code>이 담당합니다.</p>\n<p><code>app-routing.module.ts</code> 파일에는 이제 애플리케이션 최상위 계층에 해당하는 기본 라우팅 규칙과 와일드카드 라우팅 규칙만 남게 됩니다.</p>\n<code-example path=\"router/src/app/app-routing.module.3.ts\" linenums=\"false\" header=\"src/app/app-routing.module.ts (v3)\" region=\"v3\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }                from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> }    from '@angular/router';\n\nimport { PageNotFoundComponent }  from './page-not-found/page-not-found.component';\n\nconst appRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: '',   <a href=\"api/router/Route#redirectTo\" class=\"code-anchor\">redirectTo</a>: '/heroes', <a href=\"api/router/Route#pathMatch\" class=\"code-anchor\">pathMatch</a>: '<a href=\"api/core/Version#full\" class=\"code-anchor\">full</a>' },\n  { path: '**', component: PageNotFoundComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    RouterModule.forRoot(\n      appRoutes,\n      { <a href=\"api/router/ExtraOptions#enableTracing\" class=\"code-anchor\">enableTracing</a>: true } // &#x3C;-- 디버그 활성화\n    )\n  ],\n  <a href=\"api/core/NgModule#exports\" class=\"code-anchor\">exports</a>: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class AppRoutingModule {}\n\n\n</code-example>\n<a id=\"relative-navigation\"></a>\n<!--\n### Relative navigation\n-->\n<h3 id=\"상대주소로-이동하기\">상대주소로 이동하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#상대주소로-이동하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nWhile building out the crisis center feature, you navigated to the\ncrisis detail route using an **absolute path** that begins with a _slash_.\n\nThe router matches such _absolute_ paths to routes starting from the top of the route configuration.\n\nYou could continue to use absolute paths like this to navigate inside the *Crisis Center*\nfeature, but that pins the links to the parent routing structure.\nIf you changed the parent `/crisis-center` path, you would have to change the link parameters array.\n\nYou can free the links from this dependency by defining paths that are **relative** to the current URL segment.\nNavigation _within_ the feature area remains intact even if you change the parent route path to the feature.\n\nHere's an example:\n-->\n<p>위기대응센터 기능모듈을 구현하기 전에는 라우팅 규칙에 <em>슬래시(<code>/</code>)</em> 로 시작하는 <strong>절대 주소</strong>를 사용했습니다.</p>\n<p>이렇게 구현하면 라우터는 애플리케이션 최상위 URL부터 시작하는 <em>절대</em> 주소를 연결합니다.</p>\n<p>물론 <em>위기대응센터</em> 모듈 안에서 네비게이션할 때도 절대주소를 사용할 수 있지만, 이 방식은 <code>/crisis-center</code> 주소부터 시작되는 라우팅 전체 구조를 이 모듈이 알아야 합니다.\n그리고 <code>/crisis-center</code> 주소를 다른 주소로 변경하면 이 주소와 관련된 모든 주소를 변경해야 합니다.</p>\n<p>그래서 특정 모듈에서 정의하는 라우팅 규칙이 상위 라우팅 규칙과 의존성을 갖는 것을 피하려면 <strong>상대</strong> 주소로 지정하는 것이 좋습니다.\n그러면 해당 모듈 안에서 정의하는 모든 라우팅 주소는 상위 라우팅 규칙과 독립적으로 구성할 수 있습니다.</p>\n<p>상대 주소를 사용하면 다음과 같이 구현합니다:</p>\n<div class=\"alert is-helpful\">\n<!--\nThe router supports directory-like syntax in a _link parameters list_ to help guide route name lookup:\n\n`./` or `no leading slash` is relative to the current level.\n\n`../` to go up one level in the route path.\n\nYou can combine relative navigation syntax with an ancestor path.\nIf you must navigate to a sibling route, you could use the `../<sibling>` convention to go up\none level, then over and down the sibling route path.\n-->\n<p>라우터는 폴더 구조에 사용하는 것과 비슷한 문법을 지원합니다.</p>\n<p><code>./</code>나 <code>슬래시 없이</code> 사용하면 현재 계층을 가리킵니다.</p>\n<p><code>../</code>는 한단계 위 계층의 주소를 가리킵니다.</p>\n<p>이 주소들은 문자열과 조합해서 사용할 수도 있습니다.\n그래서 이웃한 라우팅 주소로 이동하려면 한단계 위 계층에서 이웃한 라우팅 주소를 가리키는 의미로 <code>../&#x3C;이웃></code> 이라고 사용할 수 있습니다.</p>\n</div>\n<!--\nTo navigate a relative path with the `Router.navigate` method, you must supply the `ActivatedRoute`\nto give the router knowledge of where you are in the current route tree.\n\nAfter the _link parameters array_, add an object with a `relativeTo` property set to the `ActivatedRoute`.\nThe router then calculates the target URL based on the active route's location.\n-->\n<p><code>Router.navigate</code> 함수에 상대주소를 사용하려면 라우팅 트리에서 현재 위치를 알아내기 위해 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>를 참고해야 합니다.</p>\n<p>그리고 이렇게 찾아온 라우팅 규칙을 <code>navigate</code> 함수에 인자로 전달하는 <em>링크 인자 배열</em> 뒤에 객체 형태로 전달하는데, <code><a href=\"api/router/NavigationExtras#relativeTo\" class=\"code-anchor\">relativeTo</a></code> 프로퍼티에 이 라우팅 규칙을 전달하면, 라우터가 현재 활성화된 라우팅 규칙을 기준으로 상대 주소를 계산합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\n**Always** specify the complete _absolute_ path when calling router's `navigateByUrl` method.\n-->\n<p>라우터가 제공하는 <code>navigateByUrl</code> 메소드는 <strong>언제나</strong> <em>절대</em> 주소를 기준으로 이동합니다.</p>\n</div>\n<a id=\"nav-to-crisis\"></a>\n<!--\n### Navigate to crisis list with a relative URL\n-->\n<h3 id=\"상대주소를-사용해서-목록-화면으로-이동하기\">상대주소를 사용해서 목록 화면으로 이동하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#상대주소를-사용해서-목록-화면으로-이동하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou've already injected the `ActivatedRoute` that you need to compose the relative navigation path.\n\nWhen using a `RouterLink` to navigate instead of the `Router` service, you'd use the _same_\nlink parameters array, but you wouldn't provide the object with the `relativeTo` property.\nThe `ActivatedRoute` is implicit in a `RouterLink` directive.\n\n\nUpdate the `gotoCrises` method of the `CrisisDetailComponent` to navigate back to the *Crisis Center* list using relative path navigation.\n-->\n<p>이전 코드에서는 상대주소로 이동하기 위해 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>를 컴포넌트에 의존성으로 주입했습니다.</p>\n<p>그리고 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 서비스 대신 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>를 사용해도 이전과 <em>같은</em> 링크 인자 배열을 전달하는데, 이번에는 이전에 사용하지 않았던 <code><a href=\"api/router/NavigationExtras#relativeTo\" class=\"code-anchor\">relativeTo</a></code> 프로퍼티를 함께 사용합니다.\n이 시점에 존재하는 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>는 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 디렉티브의 동작에 영향을 미칩니다.</p>\n<p><code>CrisisDetailComponent</code>에 정의된 <code>gotoCrises</code> 메소드를 수정해서 상대주소를 사용하는 방법으로 <em>위기대응센터</em> 화면으로 이동해 봅시다.</p>\n<!--\n<code-example path=\"router/src/app/crisis-center/crisis-detail/crisis-detail.component.ts\" linenums=\"false\" header=\"src/app/crisis-center/crisis-detail/crisis-detail.component.ts (relative navigation)\" region=\"gotoCrises-navigate\">\n-->\n<code-example path=\"router/src/app/crisis-center/crisis-detail/crisis-detail.component.ts\" linenums=\"false\" header=\"src/app/crisis-center/crisis-detail/crisis-detail.component.ts (상대 주소로 이동)\" region=\"gotoCrises-navigate\">\n// 상대주소를 사용해서 목록 화면으로 돌아갑니다.\nthis.router.navigate(['../', { id: crisisId, foo: 'foo' }], { <a href=\"api/router/NavigationExtras#relativeTo\" class=\"code-anchor\">relativeTo</a>: this.route });\n\n</code-example>\n<!--\nNotice that the path goes up a level using the `../` syntax.\nIf the current crisis `id` is `3`, the resulting path back to the crisis list is  `/crisis-center/;id=3;foo=foo`.\n-->\n<p>이<code>../</code>을 사용했기 때문에 주소는 한단계 위 계층부터 시작된다는 것을 잊지 마세요.\n<code>id</code>가 <code>3</code>이라면 최종 경로는 <code>/crisis-center/;id=3;foo=foo</code>가 됩니다.</p>\n<a id=\"named-outlets\"></a>\n<!--\n### Displaying multiple routes in named outlets\n-->\n<h3 id=\"이름을-지정해서-라우팅-영역-여러개-표시하기\">이름을 지정해서 라우팅 영역 여러개 표시하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#이름을-지정해서-라우팅-영역-여러개-표시하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou decide to give users a way to contact the crisis center.\nWhen a user clicks a \"Contact\" button, you want to display a message in a popup view.\n\nThe popup should stay open, even when switching between pages in the application, until the user closes it\nby sending the message or canceling.\nClearly you can't put the popup in the same outlet as the other pages.\n\nUntil now, you've defined a single outlet and you've nested child routes\nunder that outlet to group routes together.\nThe router only supports one primary _unnamed_ outlet per template.\n\nA template can also have any number of _named_ outlets.\nEach named outlet has its own set of routes with their own components.\nMultiple outlets can be displaying different content, determined by different routes, all at the same time.\n\nAdd an outlet named \"popup\" in the `AppComponent`, directly below the unnamed outlet.\n-->\n<p>이번에는 위기대응센터에 직접 연락할 수 있는 기능을 구현해 봅시다.\n사용자가 \"Contact\" 버튼을 클릭하면 팝업을 띄워서 위기대응센터로 보낼 메시지를 입력하게 하려고 합니다.</p>\n<p>그런데 이 팝업은 사용자가 메시지를 보내거나 취소해서 닫지 않는 한 다른 페이지로 이동해도 계속 떠있게 하려고 합니다.\n그래서 이 팝업은 페이지를 표시하는 라우팅 영역에 함께 넣을 수 없습니다.</p>\n<p>하지만 지금까지는 라우팅 영역을 하나만 두는 방법이나, 이 라우팅 영역 아래 자식 라우팅 규칙을 적용하는 방법만 다뤘습니다.\n기본적으로 라우팅 영역에 <em>이름을 지정하지 않으면</em> 템플릿에 있는 라우팅 영역 중 하나만 동작합니다.</p>\n<p>라우팅 영역에 <em>이름을 지정하면</em> 템플릿에 있는 여러 라우팅 영역을 동시에 조작할 수 있습니다.\n이 방식을 활용하면 각각의 라우팅 영역에 서로 다른 라우팅 규칙을 적용해서 여러 컴포넌트를 동시에 표시할 수 있습니다.</p>\n<p><code>AppComponent</code>에 있는 이름없는 라우팅 영역 바로 아래 \"popup\"이라는 이름으로 라우팅 영역을 추가해 봅시다.</p>\n<code-example path=\"router/src/app/app.component.4.html\" linenums=\"false\" header=\"src/app/app.component.html (outlets)\" region=\"outlets\">\n&#x3C;div [@routeAnimation]=\"getAnimationData(routerOutlet)\">\n  &#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a> #routerOutlet=\"outlet\">&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n&#x3C;/div>\n&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a> name=\"popup\">&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n\n</code-example>\n<!--\nThat's where a popup will go, once you learn how to route a popup component to it.\n-->\n<p>팝업은 이 라우팅 영역에 들어갈 것입니다. 이제부터 팝업 컴포넌트를 표시하기 위해 라우팅 규칙을 어떻게 활용해야 하는지 알아봅시다.</p>\n<a id=\"secondary-routes\"></a>\n<!--\n#### Secondary routes\n-->\n<h4 id=\"서브-라우팅-규칙-secondary-routes\">서브 라우팅 규칙 (Secondary routes)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#서브-라우팅-규칙-secondary-routes\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nNamed outlets are the targets of  _secondary routes_.\n\nSecondary routes look like primary routes and you configure them the same way.\nThey differ in a few key respects.\n\n* They are independent of each other.\n* They work in combination with other routes.\n* They are displayed in named outlets.\n\nGenerate a new component to compose the message.\n-->\n<p>방금 이름을 지정해서 만든 라우팅 영역은 <em>서브 라우팅 규칙</em> 의 타겟이 될 것입니다.</p>\n<p>서브 라우팅 규칙은 기본 라우팅 규칙을 사용하는 것과 거의 비슷합니다.\n그러나 다른 점도 있습니다.</p>\n<ul>\n<li>서브 라우팅 규칙은 다른 라우팅 규칙과 독립적으로 동작합니다.</li>\n<li>다른 라우팅 규칙과 조합할 수 있습니다.</li>\n<li>서브 라우팅 규칙에 연결된 컴포넌트는 이름을 지정한 라우팅 영역에 표시됩니다.</li>\n</ul>\n<p>다음 명령을 실행해서 메시지를 입력받을 컴포넌트를 생성합니다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component compose-message\n</code-example>\n<!--\nIt displays a simple form with a header, an input box for the message,\nand two buttons, \"Send\" and \"Cancel\".\n-->\n<p>이 컴포넌트에는 간단한 헤더와 메시지를 입력받을 입력 필드, \"Send\" 버튼과 \"Cancel\" 버튼이 존재합니다.</p>\n<figure>\n  <img src=\"generated/images/guide/router/contact-popup.png\" alt=\"Contact popup\" width=\"250\" height=\"262\">\n</figure>\n<!--\nHere's the component, its template and styles:\n-->\n<p>이 컴포넌트 템플릿과 스타일은 다음과 같이 작성합니다.</p>\n<code-tabs>\n\n  <code-pane header=\"src/app/compose-message/compose-message.component.css\" path=\"router/src/app/compose-message/compose-message.component.css\">\n:<a href=\"api/core/Directive#host\" class=\"code-anchor\">host</a> {\n  <a href=\"api/router/Scroll#position\" class=\"code-anchor\">position</a>: relative; bottom: 10%;\n}\n\n</code-pane>\n\n  <code-pane header=\"src/app/compose-message/compose-message.component.html\" path=\"router/src/app/compose-message/compose-message.component.html\">\n&#x3C;h3>Contact Crisis Center&#x3C;/h3>\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"details\">\n  {{ details }}\n&#x3C;/div>\n&#x3C;div>\n  &#x3C;div>\n    &#x3C;label>Message: &#x3C;/label>\n  &#x3C;/div>\n  &#x3C;div>\n    &#x3C;<a href=\"api/forms/DefaultValueAccessor\" class=\"code-anchor\">textarea</a> [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>\" rows=\"10\" cols=\"35\" [disabled]=\"sending\">&#x3C;/<a href=\"api/forms/DefaultValueAccessor\" class=\"code-anchor\">textarea</a>>\n  &#x3C;/div>\n&#x3C;/div>\n&#x3C;p *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"!sending\">\n  &#x3C;button (click)=\"send()\">Send&#x3C;/button>\n  &#x3C;button (click)=\"cancel()\">Cancel&#x3C;/button>\n&#x3C;/p>\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/compose-message/compose-message.component.ts\" path=\"router/src/app/compose-message/compose-message.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/HostBinding\" class=\"code-anchor\">HostBinding</a> } from '@angular/core';\nimport { <a href=\"api/router/Router\" class=\"code-anchor\">Router</a> }                 from '@angular/router';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-compose-message',\n  templateUrl: './compose-message.component.html',\n  <a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a>: ['./compose-message.component.css']\n})\nexport class ComposeMessageComponent {\n  details: string;\n  <a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>: string;\n  sending = false;\n\n  constructor(private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {}\n\n  send() {\n    this.sending = true;\n    this.details = 'Sending Message...';\n\n    setTimeout(() => {\n      this.sending = false;\n      this.closePopup();\n    }, 1000);\n  }\n\n  cancel() {\n    this.closePopup();\n  }\n\n  closePopup() {\n    // 이름을 지정한 라우팅 영역에 `null` 값을 지정하면 라우팅 영역의 내용을 모두 비웁니다.\n    this.router.navigate([{ outlets: { popup: null }}]);\n  }\n}\n\n\n</code-pane>\n\n</code-tabs>\n<!--\nIt looks about the same as any other component you've seen in this guide.\nThere are two noteworthy differences.\n\nNote that the `send()` method simulates latency by waiting a second before \"sending\" the message and closing the popup.\n\nThe `closePopup()` method closes the popup view by navigating to the popup outlet with a `null`.\nThat's a peculiarity covered [below](#clear-secondary-routes).\n-->\n<p>이 컴포넌트의 내용은 지금까지 봤던 다른 컴포넌트와 거의 비슷하며, 두가지 정도가 다릅니다.</p>\n<p><code>send()</code> 메소드는 서버와 통신하는 것을 흉내내기 위해 시간을 약간 지연한 후에 팝업을 닫습니다.</p>\n<p><code>closePopup()</code> 메소드는 팝업 라우팅 영역의 값을 <code>null</code>로 할당하면서 팝업을 닫습니다.\n이 내용은 약간 이상해 보이지만 <a href=\"guide/router#clear-secondary-routes\">아래</a>에서 자세하게 다룹니다.</p>\n<a id=\"add-secondary-route\"></a>\n<!--\n#### Add a secondary route\n-->\n<h4 id=\"서브-라우팅-규칙-추가하기\">서브 라우팅 규칙 추가하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#서브-라우팅-규칙-추가하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nOpen the `AppRoutingModule` and add a new `compose` route to the `appRoutes`.\n-->\n<p><code>AppRoutingModule</code>을 열고 <code>appRoutes</code>에 <code>compose</code> 라우팅 규칙을 추가합니다.</p>\n<!--\n<code-example path=\"router/src/app/app-routing.module.3.ts\" linenums=\"false\" header=\"src/app/app-routing.module.ts (compose route)\" region=\"compose\">\n-->\n<code-example path=\"router/src/app/app-routing.module.3.ts\" linenums=\"false\" header=\"src/app/app-routing.module.ts (compose 라우팅 규칙)\" region=\"compose\">\n{\n  path: 'compose',\n  component: ComposeMessageComponent,\n  outlet: 'popup'\n},\n\n</code-example>\n<!--\nThe `path` and `component` properties should be familiar.\nThere's a new property, `outlet`, set to `'popup'`.\nThis route now targets the popup outlet and the `ComposeMessageComponent` will display there.\n\nThe user needs a way to open the popup.\nOpen the `AppComponent` and add a \"Contact\" link.\n-->\n<p><code>path</code>와 <code>component</code> 프로퍼티는 이제 익숙할 것입니다.\n그런데 이 라우팅 규칙에는 <code>outlet</code> 프로퍼티에 <code>'popup'</code>이 할당되어 있습니다.\n이제 이 라우팅 규칙은 팝업 라우팅 영역을 대상으로 동작하며 <code>ComposeMessageComponent</code>도 팝업 라우팅 영역에 표시됩니다.</p>\n<p>사용자가 팝업을 열 방법이 필요합니다.\n<code>AppComponent</code>를 열고 다음과 같이 \"Contact\" 링크를 추가합니다.</p>\n<!--\n<code-example path=\"router/src/app/app.component.4.html\" linenums=\"false\" header=\"src/app/app.component.html (contact-link)\" region=\"contact-link\">\n-->\n<code-example path=\"router/src/app/app.component.4.html\" linenums=\"false\" header=\"src/app/app.component.html (contact 링크)\" region=\"contact-link\">\n&#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"[{ outlets: { popup: ['compose'] } }]\">Contact&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n\n</code-example>\n<!--\nAlthough the `compose` route is pinned to the \"popup\" outlet, that's not sufficient for wiring the route to a `RouterLink` directive.\nYou have to specify the named outlet in a _link parameters array_ and bind it to the `RouterLink` with a property binding.\n\nThe _link parameters array_ contains an object with a single `outlets` property whose value\nis another object keyed by one (or more) outlet names.\nIn this case there is only the \"popup\" outlet property and its value is another _link parameters array_ that specifies the `compose` route.\n\nYou are in effect saying, _when the user clicks this link, display the component associated with the `compose` route in the `popup` outlet_.\n-->\n<p>그런데 <code>compose</code> 라우팅 규칙에 \"popup\" 라우팅 영역을 연결한 것만으로는 충분하지 않습니다. 이 라우팅 규칙을 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 디렉티브와 연결하려면 <em>링크 인자 배열</em> 을 지정하면서 <code>outlets</code> 프로퍼티를 한 번 더 지정해야 합니다.</p>\n<p>이 예제에 사용된 <em>링크 인자 배열</em> 에는 <code>compose</code> 주소에 해당하는 컴포넌트가 표시될 라우팅 영역을 지정하기 위해 <code>outlets</code> 프로퍼티가 있는 객체를 사용했습니다.\n이 코드에서 라우팅 영역은 \"popup\" 라우팅 영역만 지정되었지만, <code>compose</code> 라우팅 규칙에 따라 또 다른 <em>링크 인자 배열</em> 이 전달될 수도 있습니다.</p>\n<p>이제 이 코드는 <em>사용자가 이 링크를 클릭하면 <code>compose</code> 라우팅 규칙에 해당하는 컴포넌트를 <code>popup</code> 라우팅 영역에 표시하라</em> 는 것을 의미합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nThis `outlets` object within an outer object was completely unnecessary\nwhen there was only one route and one _unnamed_ outlet to think about.\n\nThe router assumed that your route specification targeted the _unnamed_ primary outlet\nand created these objects for you.\n\nRouting to a named outlet has revealed a previously hidden router truth:\nyou can target multiple outlets with multiple routes in the same `RouterLink` directive.\n\nYou're not actually doing that here.\nBut to target a named outlet, you must use the richer, more verbose syntax.\n-->\n<p>만약 템플릿에 라우팅 영역이 하나만 있고 이 라우팅 영역에 <em>이름이 지정되지 않았다면</em> <code>outlets</code> 객체는 필요없습니다.</p>\n<p>왜냐하면 라우터는 기본적으로 <em>이름이 지정되지 않은</em> 기본 라우팅 영역을 대상으로 동작하기 때문에 <code>outlets</code> 객체가 라우터 내부적으로 생성되기 때문입니다.</p>\n<p>라우팅 영역에 이름을 지정하는 것을 활용하면 라우터를 다른 방식으로 활용할 수도 있습니다:\n이 방식을 활용하면 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 디렉티브 하나로 여러 라우팅 영역에 서로 다른 라우팅 규칙을 적용할 수 있습니다.</p>\n<p>물론 당장 이렇게 구현할 필요는 없습니다.\n하지만 라우팅 영역에 이름을 지정하는 방식을 활용하면 Angular 라우터 문법을 좀 더 다양하게 활용할 수 있습니다.</p>\n</div>\n<a id=\"secondary-route-navigation\"></a>\n<!--\n#### Secondary route navigation: merging routes during navigation\n-->\n<h4 id=\"서브-라우팅-규칙-활용하기-라우팅-규칙-머지하기\">서브 라우팅 규칙 활용하기: 라우팅 규칙 머지하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#서브-라우팅-규칙-활용하기-라우팅-규칙-머지하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nNavigate to the _Crisis Center_ and click \"Contact\".\nyou should see something like the following URL in the browser address bar.\n-->\n<p><em>위기대응센터</em> 로 이동해서 \"Contact\" 버튼을 클릭해 봅시다.\n그러면 브라우저의 주소표시줄에 다음과 같은 URL이 적용되는 것을 확인할 수 있습니다.</p>\n<code-example>\n  <a href=\"api/common/http\" class=\"code-anchor\">http</a>://.../crisis-center(popup:compose)\n\n</code-example>\n<!--\nThe interesting part of the URL follows the `...`:\n\n* The `crisis-center` is the primary navigation.\n* Parentheses surround the secondary route.\n* The secondary route consists of an outlet name (`popup`), a `colon` separator, and the secondary route path (`compose`).\n\nClick the _Heroes_ link and look at the URL again.\n-->\n<p>여기에서 <code>...</code> 뒤에 붙는 주소가 중요합니다:</p>\n<ul>\n<li><code>crisis-center</code>는 기본 라우팅 주소입니다.</li>\n<li>서브 라우팅 규칙은 괄호(<code>(</code>, <code>)</code>)로 묶입니다.</li>\n<li>서브 라우팅 규칙은 라우팅 영역의 이름(<code>popup</code>)과 구분자(<code>:</code>), 서브 라우팅 규칙의 주소(<code>compose</code>)로 구성됩니다.</li>\n</ul>\n<p>그리고 <code>Heroes</code> 링크를 클릭하면 URL이 다음과 같이 변경됩니다.</p>\n<code-example>\n  <a href=\"api/common/http\" class=\"code-anchor\">http</a>://.../heroes(popup:compose)\n</code-example>\n<!--\nThe primary navigation part has changed; the secondary route is the same.\n\nThe router is keeping track of two separate branches in a navigation tree and generating a representation of that tree in the URL.\n\nYou can add many more outlets and routes, at the top level and in nested levels, creating a navigation tree with many branches.\nThe router will generate the URL to go with it.\n\nYou can tell the router to navigate an entire tree at once by filling out the `outlets` object mentioned above.\nThen pass that object inside a _link parameters array_  to the `router.navigate` method.\n\nExperiment with these possibilities at your leisure.\n-->\n<p>기본 라우팅 주소는 변경되었지만 서브 라우팅 주소는 변경되지 않았습니다.</p>\n<p>이 때 라우터는 네비게이션 트리를 이중으로 관리하면서 기본 라우팅 규칙과 서브 라우팅 규칙에 해당하는 URL을 자동으로 조합해서 표현합니다.</p>\n<p>원한다면 좀 더 많은 라우팅 영역에 각각 라우팅 규칙을 적용할 수 있는데, 이 때 라우팅 규칙의 어떤 계층에 이 내용이 정의되는지는 중요하지 않습니다. 라우팅 규칙은 자유롭게 구성할 수 있으며, 라우터는 이 관계를 모두 조합해서 URL을 구성할 것입니다.</p>\n<p>그리고 위에서 언급한 것처럼 <code>outlets</code> 객체를 활용하면 모든 라우팅 영역을 한 번에 바꿀 수도 있습니다.\n이 내용에 해당되는 <em>링크 인자 배열</em> 을 <code>router.navigate</code> 메소드에 전달하면 됩니다.</p>\n<p>어떻게 활용할 수 있는지 직접 코드를 작성하며 확인해 보세요.</p>\n<a id=\"clear-secondary-routes\"></a>\n<!--\n#### Clearing secondary routes\n-->\n<h4 id=\"서브-라우팅-규칙-해제하기\">서브 라우팅 규칙 해제하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#서브-라우팅-규칙-해제하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nAs you've learned, a component in an outlet persists until you navigate away to a new component.\nSecondary outlets are no different in this regard.\n\nEach secondary outlet has its own navigation, independent of the navigation driving the primary outlet.\nChanging a current route that displays in the primary outlet has no effect on the popup outlet.\nThat's why the popup stays visible as you navigate among the crises and heroes.\n\nClicking the \"send\" or \"cancel\" buttons _does_ clear the popup view.\nTo see how, look at the `closePopup()` method again:\n-->\n<p>지금까지 알아본 것처럼 라우팅 영역에 표시되는 컴포넌트는 다른 주소로 이동하지 않는 이상 계속 남아있습니다.\n이 점은 서브 라우팅 영역도 마찬가지입니다.</p>\n<p>서브 라우팅 영역은 기본 라우팅 영역과도 독립적인 네비게이션 로직으로 동작합니다.\n그래서 기본 라우팅 영역의 주소를 변경해도 팝업 라우팅 영역은 영향을 받지 않습니다.\n결국 위기대응센터 페이지와 히어로 페이지를 왔다갔다 해도 팝업은 계속 화면에 표시될 것입니다.</p>\n<p>팝업에 있는 \"send\" 버튼이나 \"cancel\" 버튼을 누르면 팝업 뷰를 비웁니다.\n<code>closePopup()</code> 메소드를 다시 한 번 봅시다:</p>\n<code-example path=\"router/src/app/compose-message/compose-message.component.ts\" linenums=\"false\" header=\"src/app/compose-message/compose-message.component.ts (closePopup)\" region=\"closePopup\">\nclosePopup() {\n  // 이름을 지정한 라우팅 영역에 `null` 값을 지정하면 라우팅 영역의 내용을 모두 비웁니다.\n  this.router.navigate([{ outlets: { popup: null }}]);\n}\n\n</code-example>\n<!--\nIt navigates imperatively with the `Router.navigate()` method, passing in a [link parameters array](#link-parameters-array).\n\nLike the array bound to the _Contact_ `RouterLink` in the `AppComponent`,\nthis one includes an object with an `outlets` property.\nThe `outlets` property value is another object with outlet names for keys.\nThe only named outlet is `'popup'`.\n\nThis time, the value of `'popup'` is `null`. That's not a route, but it is a legitimate value.\nSetting the popup `RouterOutlet` to `null` clears the outlet and removes\nthe secondary popup route from the current URL.\n-->\n<p><code><a href=\"api/router/Router#navigate\" class=\"code-anchor\">Router.navigate()</a></code> 메소드를 사용하려면 반드시 <a href=\"guide/router#link-parameters-array\">링크 변수 배열</a>을 전달해야 합니다.</p>\n<p>그리고 <code>AppComponent</code>에 있는 <em>Contact</em> <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>에 바인딩했던 것처럼, 링크 변수 배열에 <code>outlets</code> 프로퍼티가 있는 객체를 전달해야 합니다.\n<code>outlets</code> 프로퍼티는 라우팅 영역의 이름이 키인 객체입니다.\n그리고 지금까지 작성한 예제에는 <code>'popup'</code>이라는 라우팅 영역 하나만 존재합니다.</p>\n<p>위 코드에서 <code>'popup'</code>에 할당된 값은 <code>null</code>입니다. 이 값이 라우팅 규칙은 아니지만 라우팅 영역을 설정할 때는 유효한 값입니다.\n팝업 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>의 값을 <code>null</code>로 할당하면 이 라우팅 영역을 비우기 때문에 브라우저 주소표시줄의 URL에서 서브 라우팅 규칙도 제거됩니다.</p>\n<a id=\"guards\"></a>\n<!--\n## Milestone 5: Route guards\n-->\n<h2 id=\"5단계-라우팅-가드-route-guards\">5단계: 라우팅 가드 (Route guards)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#5단계-라우팅-가드-route-guards\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAt the moment, *any* user can navigate *anywhere* in the application *anytime*.\nThat's not always the right thing to do.\n\n* Perhaps the user is not authorized to navigate to the target component.\n* Maybe the user must login (*authenticate*) first.\n* Maybe you should fetch some data before you display the target component.\n* You might want to save pending changes before leaving a component.\n* You might ask the user if it's OK to discard pending changes rather than save them.\n\nYou add _guards_ to the route configuration to handle these scenarios.\n\nA guard's return value controls the router's behavior:\n\n* If it returns `true`, the navigation process continues.\n* If it returns `false`, the navigation process stops and the user stays put.\n* If it returns a `UrlTree`, the current navigation cancels and a new navigation is initiated to the `UrlTree` returned.\n-->\n<p>지금까지 작성한 애플리케이션은 <em>아무</em> 사용자가 애플리케이션의 <em>모든 페이지에</em> <em>아무때나</em> 접근할 수 있습니다.\n하지만 이 방법이 언제나 괜찮은 것은 아닙니다.</p>\n<ul>\n<li>어떤 컴포넌트는 인증받지 않은 사용자가 접근할 수 없어야 합니다.</li>\n<li>어쩌면 사용자가 로그인을 먼저 해야할 수도 있습니다.</li>\n<li>컴포넌트가 표시되기 전에 서버에서 데이터를 가져와야 할 수도 있습니다.</li>\n<li>컴포넌트를 떠나기 전에 변경된 내용을 저장해야 하는 경우도 있습니다.</li>\n<li>변경된 내용을 저장하지 않는다면 이 내용을 폐기할지 사용자에게 물어봐야 할 수도 있습니다.</li>\n</ul>\n<p>이런 경우에 <em>라우팅 가드</em> 를 사용하면 라우팅 동작을 제어할 수 있습니다.</p>\n<p>라우팅 가드는 <code>boolean</code> 값을 반환해서 라우터의 동작을 제어합니다:</p>\n<ul>\n<li><code>true</code>를 반환하면 네비게이션 동작을 계속합니다.</li>\n<li><code>false</code>를 반환하면 네비게이션 동작을 멈춥니다.</li>\n<li>If it returns a <code><a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a></code>, the current navigation cancels and a new navigation is initiated to the <code><a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a></code> returned.</li>\n</ul>\n<div class=\"alert is-helpful\">\n<p><strong>Note:</strong> The guard can also tell the router to navigate elsewhere, effectively canceling the current navigation. When\ndoing so inside a guard, the guard should return <code>false</code>;</p>\n<!--\n**Note:** The guard can also tell the router to navigate elsewhere, effectively canceling the current navigation.\n-->\n<p><strong>참고:</strong> 라우팅 가드를 사용하면 지금 동작하는 네비게이션을 취소하고 다른 곳으로 이동하게 할 수 있습니다.\n이 경우에는 현재 실행되는 라우팅 가드가 <code>false</code>를 반환해야 합니다.</p>\n</div>\n<!--\nThe guard *might* return its boolean answer synchronously.\nBut in many cases, the guard can't produce an answer synchronously.\nThe guard could ask the user a question, save changes to the server, or fetch fresh data.\nThese are all asynchronous operations.\n\nAccordingly, a routing guard can return an `Observable<boolean>` or a `Promise<boolean>` and the\nrouter will wait for the observable to resolve to `true` or `false`.\n-->\n<p>라우팅 가드는 불리언 값을 동기 방식(synchronously)으로 반환할 수도 있습니다.\n하지만 라우팅 가드는 동기 방식으로 값을 반환할 수 없는 경우가 더 많습니다.\n사용자에게 어떤 것을 물어봐야 하거나, 서버에 변경사항을 저장하는 경우, 새로운 데이터를 가져와야 하는 경우가 그렇습니다.\n이런 동작은 모두 비동기로 실행됩니다.</p>\n<p>그래서 라우팅 가드는 <code>Observable&#x3C;boolean></code> 타입이나 <code>Promise&#x3C;boolean></code> 타입을 반환할 수 있으며, 이 타입을 사용하면 라우팅 가드의 내부 로직이 완료될 때까지 라우터의 동작이 중단됩니다.</p>\n<div class=\"alert is-critical\">\n<!--\n**Note:** The observable provided to the Router _must_ also complete. If the observable does not complete, the navigation will not continue.\n-->\n<p><strong>참고:</strong> 라우팅 가드 내부 로직에 사용되는 옵저버블은 <em>반드시</em> 종료되어야 합니다. 옵저버블이 종료되지 않으면 네비게이션도 진행되지 않습니다.</p>\n</div>\n<!--\nThe router supports multiple guard interfaces:\n\n* [`CanActivate`](api/router/CanActivate) to mediate navigation *to* a route.\n\n* [`CanActivateChild`](api/router/CanActivateChild) to mediate navigation *to* a child route.\n\n* [`CanDeactivate`](api/router/CanDeactivate) to mediate navigation *away* from the current route.\n\n* [`Resolve`](api/router/Resolve) to perform route data retrieval *before* route activation.\n\n* [`CanLoad`](api/router/CanLoad) to mediate navigation *to* a feature module loaded _asynchronously_.\n-->\n<p>라우터는 몇 가지 라우팅 가드 인터페이스를 제공합니다:</p>\n<ul>\n<li>\n<p>라우팅 규칙을 <em>적용하는 동작</em>은 <a href=\"api/router/CanActivate\"><code>CanActivate</code></a>로 제어할 수 있습니다.</p>\n</li>\n<li>\n<p>자식 라우팅 규칙을 <em>적용하는 동작</em>은 <a href=\"api/router/CanActivateChild\"><code>CanActivateChild</code></a>로 제어할 수 있습니다.</p>\n</li>\n<li>\n<p>현재 라우팅 규칙에서 <em>벗어나는 동작</em>은 <a href=\"api/router/CanDeactivate\"><code>CanDeactivate</code></a>로 제어할 수 있습니다.</p>\n</li>\n<li>\n<p>라우팅 규칙이 <em>적용되기 전에</em> 라우팅 데이터를 받아오는 동작은 <a href=\"api/router/Resolve\"><code>Resolve</code></a>로 제어할 수 있습니다.</p>\n</li>\n<li>\n<p>기능 모듈을 <em>비동기로</em> 로드하는 동작은 <a href=\"api/router/CanLoad\"><code>CanLoad</code></a>로 제어할 수 있습니다.</p>\n</li>\n</ul>\n<!--\nYou can have multiple guards at every level of a routing hierarchy.\nThe router checks the `CanDeactivate` and `CanActivateChild` guards first, from the deepest child route to the top.\nThen it checks the `CanActivate` guards from the top down to the deepest child route. If the feature module\nis loaded asynchronously, the `CanLoad` guard is checked before the module is loaded.\nIf _any_ guard returns false, pending guards that have not completed will be canceled,\nand the entire navigation is canceled.\n\nThere are several examples over the next few sections.\n-->\n<p>라우팅 가드는 라우팅 계층 어디에라도 몇개씩 자유롭게 적용할 수 있습니다.\n라우터는 가장 안쪽의 자식 라우팅 규칙부터 상위 라우팅 계층을 향해 <code><a href=\"api/router/CanDeactivate\" class=\"code-anchor\">CanDeactivate</a></code>와 <code><a href=\"api/router/CanActivateChild\" class=\"code-anchor\">CanActivateChild</a></code> 가드를 제일 먼저 실행합니다.\n그리고 최상위 라우팅 계층부터 가장 안쪽의 자식 라우팅 규칙까지 <code><a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a></code> 가드를 실행하는데, 이 과정에 기능 모듈이 비동기로 로드되면 이 모듈이 로드되기 전에 <code><a href=\"api/router/CanLoad\" class=\"code-anchor\">CanLoad</a></code> 가드가 실행됩니다.\n이 과정이 수행되면서 <em>어떤</em> 가드에서 <code>false</code>를 반환하면 아직 실행되지 않은 라우팅 가드는 실행이 취소되며 모든 네비게이션 동작도 취소됩니다.</p>\n<p>이 시나리오를 예제와 함께 확인해 봅시다.</p>\n<a id=\"can-activate-guard\"></a>\n<!--\n### _CanActivate_: requiring authentication\n-->\n<h3 id=\"canactivate-사용자-인증이-필요한-경우\"><em>CanActivate</em>: 사용자 인증이 필요한 경우<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#canactivate-사용자-인증이-필요한-경우\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nApplications often restrict access to a feature area based on who the user is.\nYou could permit access only to authenticated users or to users with a specific role.\nYou might block or limit access until the user's account is activated.\n\nThe `CanActivate` guard is the tool to manage these navigation business rules.\n-->\n<p>애플리케이션은 보통 특정 기능에 접근할 수 있는 사용자를 제한하는 경우가 많습니다.\n그래서 사용자가 로그인을 하거나 특정 권한이 있어야 접근할 수 있도록 설정할 수 있습니다.\n조건에 맞지 않으면 접근을 제한할 것입니다.</p>\n<p>이런 네비게이션 동작은 <code><a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a></code> 가드를 사용해서 제어할 수 있습니다.</p>\n<!--\n#### Add an admin feature module\n-->\n<h4 id=\"관리자-기능-모듈-추가하기\">관리자 기능 모듈 추가하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#관리자-기능-모듈-추가하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nIn this next section, you'll extend the crisis center with some new *administrative* features.\nThose features aren't defined yet.\nBut you can start by adding a new feature module named `AdminModule`.\n\nGenerate an `admin` folder with a feature module file and a routing configuration file.\n-->\n<p>이번 섹션에서는 위기대응센터에 <em>관리자</em> 기능을 추가해 봅시다.\n관리자 기능 모듈은 아직 정의되지 않았습니다.\n그래서 <code>AdminModule</code>이라는 기능모듈을 생성하는 것부터 시작합니다.</p>\n<p>다음 명령을 실행해서 <code>admin</code> 폴더와 <code>AdminModule</code>을 생성하고 이 때 라우팅 설정 파일도 함께 생성합니다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate module admin --routing\n</code-example>\n<!--\nNext, generate the supporting components.\n-->\n<p>그리고 관련 컴포넌트들을 생성합니다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component admin/admin-dashboard\n</code-example>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component admin/admin\n</code-example>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component admin/manage-crises\n</code-example>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component admin/manage-heroes\n</code-example>\n<!--\nThe admin feature file structure looks like this:\n-->\n<p>그러면 다음과 같이 관리자 모듈이 구성될 것입니다:</p>\n<div class=\"filetree\">\n  <div class=\"file\">\n    src/app/admin\n  </div>\n  <div class=\"children\">\n    <div class=\"file\">\n      admin\n    </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          admin.component.css\n        </div>\n        <div class=\"file\">\n          admin.component.html\n        </div>\n        <div class=\"file\">\n          admin.component.ts\n        </div>\n      </div>\n    <div class=\"file\">\n      admin-dashboard\n    </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          admin-dashboard.component.css\n        </div>\n        <div class=\"file\">\n          admin-dashboard.component.html\n        </div>\n        <div class=\"file\">\n          admin-dashboard.component.ts\n        </div>\n      </div>\n    <div class=\"file\">\n      manage-crises\n    </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          manage-crises.component.css\n        </div>\n        <div class=\"file\">\n          manage-crises.component.html\n        </div>\n        <div class=\"file\">\n          manage-crises.component.ts\n        </div>\n      </div>\n    <div class=\"file\">\n      manage-heroes\n    </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          manage-heroes.component.css\n        </div>\n        <div class=\"file\">\n          manage-heroes.component.html\n        </div>\n        <div class=\"file\">\n          manage-heroes.component.ts\n        </div>\n      </div>\n    <div class=\"file\">\n      admin.module.ts\n    </div>\n    <div class=\"file\">\n      admin-routing.module.ts\n    </div>\n  </div>\n</div>\n<!--\nThe admin feature module contains the `AdminComponent` used for routing within the\nfeature module, a dashboard route and two unfinished components to manage crises and heroes.\n-->\n<p>관리자 모듈의 진입점은 <code>AdminComponent</code>입니다. 그리고 이 모듈에는 대시보드 컴포넌트와 위기를 관리하는 컴포넌트, 히어로를 관리하는 컴포넌트가 존재합니다.</p>\n<code-tabs>\n\n  <code-pane header=\"src/app/admin/admin/admin.component.html\" linenums=\"false\" path=\"router/src/app/admin/admin/admin.component.html\">\n&#x3C;h3>ADMIN&#x3C;/h3>\n&#x3C;nav>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"./\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\"\n    [<a href=\"api/router/RouterLinkActive#routerLinkActiveOptions\" class=\"code-anchor\">routerLinkActiveOptions</a>]=\"{ exact: true }\">Dashboard&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"./crises\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Manage Crises&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"./heroes\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Manage Heroes&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n&#x3C;/nav>\n&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n\n</code-pane>\n\n  <code-pane header=\"src/app/admin/admin-dashboard/admin-dashboard.component.html\" linenums=\"false\" path=\"router/src/app/admin/admin-dashboard/admin-dashboard.component.1.html\">\n&#x3C;p>Dashboard&#x3C;/p>\n\n</code-pane>\n\n  <code-pane header=\"src/app/admin/admin.module.ts\" path=\"router/src/app/admin/admin.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }       from '@angular/core';\nimport { <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> }   from '@angular/common';\n\nimport { AdminComponent }           from './admin/admin.component';\nimport { AdminDashboardComponent }  from './admin-dashboard/admin-dashboard.component';\nimport { ManageCrisesComponent }    from './manage-crises/manage-crises.component';\nimport { ManageHeroesComponent }    from './manage-heroes/manage-heroes.component';\n\nimport { AdminRoutingModule }       from './admin-routing.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>,\n    AdminRoutingModule\n  ],\n  <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [\n    AdminComponent,\n    AdminDashboardComponent,\n    ManageCrisesComponent,\n    ManageHeroesComponent\n  ]\n})\nexport class AdminModule {}\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/admin/manage-crises/manage-crises.component.html\" linenums=\"false\" path=\"router/src/app/admin/manage-crises/manage-crises.component.html\">\n&#x3C;p>Manage your crises here&#x3C;/p>\n\n</code-pane>\n\n  <code-pane header=\"src/app/admin/manage-heroes/manage-heroes.component.html\" linenums=\"false\" path=\"router/src/app/admin/manage-heroes/manage-heroes.component.html\">\n&#x3C;p>Manage your heroes here&#x3C;/p>\n\n</code-pane>\n\n</code-tabs>\n<div class=\"alert is-helpful\">\n<!--\nAlthough the admin dashboard `RouterLink` only contains a relative slash without an additional URL segment, it\nis considered a match to any route within the admin feature area. You only want the `Dashboard` link to be active when the user visits that route. Adding an additional binding to the `Dashboard` routerLink,`[routerLinkActiveOptions]=\"{ exact: true }\"`, marks the `./` link as active when the user navigates to the `/admin` URL and not when navigating to any of the child routes.\n-->\n<p>대시보드로 이동하는 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>에는 추가 URL 없이 현재 위치를 가리키는 상대주소가 지정되었는데, 이 주소는 관리자 기능 모듈의 진입 주소인 <code>/admin</code>을 가리킵니다.\n사용자가 이 링크를 클릭하면 <code>Dashboard</code>가 화면에 표시될 것입니다.\n이 동작을 위해 <code>Dashboard</code>로 이동하는 라우터 링크에는 <code>[<a href=\"api/router/RouterLinkActive#routerLinkActiveOptions\" class=\"code-anchor\">routerLinkActiveOptions</a>]=\"{ exact: true }\"</code> 옵션이 사용되었습니다. 이제 사용자가 자식 라우팅 주소로 이동하지 않고 <code>/admin</code> URL로 이동하면 대시보드가 화면에 표시됩니다.</p>\n</div>\n<a id=\"component-less-route\"></a>\n<!--\n##### Component-less route: grouping routes without a component\n-->\n<h5 id=\"컴포넌트가-없는-라우팅-규칙-라우팅-규칙을-그룹으로-묶기\">컴포넌트가 없는 라우팅 규칙: 라우팅 규칙을 그룹으로 묶기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#컴포넌트가-없는-라우팅-규칙-라우팅-규칙을-그룹으로-묶기\"><i class=\"material-icons\">link</i></a></h5>\n<!--\nThe initial admin routing configuration:\n-->\n<p>관리자 모듈의 초기 라우팅 설정은 다음과 같습니다:</p>\n<!--\n<code-example path=\"router/src/app/admin/admin-routing.module.1.ts\" linenums=\"false\" header=\"src/app/admin/admin-routing.module.ts (admin routing)\" region=\"admin-routes\">\n-->\n<code-example path=\"router/src/app/admin/admin-routing.module.1.ts\" linenums=\"false\" header=\"src/app/admin/admin-routing.module.ts (관리자 모듈의 라우팅 규칙)\" region=\"admin-routes\">\nconst adminRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'admin',\n    component: AdminComponent,\n    children: [\n      {\n        path: '',\n        children: [\n          { path: 'crises', component: ManageCrisesComponent },\n          { path: 'heroes', component: ManageHeroesComponent },\n          { path: '', component: AdminDashboardComponent }\n        ]\n      }\n    ]\n  }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    RouterModule.forChild(adminRoutes)\n  ],\n  <a href=\"api/core/NgModule#exports\" class=\"code-anchor\">exports</a>: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class AdminRoutingModule {}\n\n</code-example>\n<!--\nLooking at the child route under the `AdminComponent`, there is a `path` and a `children`\nproperty but it's not using a `component`.\nYou haven't made a mistake in the configuration.\nYou've defined a _component-less_ route.\n\nThe goal is to group the `Crisis Center` management routes under the `admin` path.\nYou don't need a component to do it.\nA _component-less_ route makes it easier to [guard child routes](#can-activate-child-guard).\n\n\nNext, import the `AdminModule` into `app.module.ts` and add it to the `imports` array\nto register the admin routes.\n-->\n<p><code>AdminComponent</code>의 자식 라우팅 규칙 중에는 <code>path</code>와 <code>children</code> 프로퍼티가 있지만 <code>component</code>가 없는 라우팅 규칙이 있습니다.\n이 라우팅 규칙은 잘못 작성한 것이 아니라 <em>컴포넌트가 없는</em> 라우팅 규칙을 정의한 것입니다.</p>\n<p>이 라우팅 규칙을 사용한 목적은 <code>위기대응센터</code>과 관리하는 모든 라우팅 규칙을 <code>admin</code> 주소 안으로 묶기 위한 것입니다.\n이런 용도로 사용할 때 이 라우팅 규칙에  컴포넌트를 지정할 필요는 없습니다.\n<em>컴포넌트가 없는</em> 라우팅 규칙은 <a href=\"guide/router#can-activate-child-guard\">자식 라우팅 규칙에 적용하는 라우팅 가드</a>를 좀 더 편하게 지정하기 위해 사용합니다.</p>\n<!--\n<code-example path=\"router/src/app/app.module.4.ts\" linenums=\"false\" header=\"src/app/app.module.ts (admin module)\" region=\"admin-module\">\n-->\n<code-example path=\"router/src/app/app.module.4.ts\" linenums=\"false\" header=\"src/app/app.module.ts (관리자 모듈)\" region=\"admin-module\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }       from '@angular/core';\nimport { <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> }   from '@angular/common';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> }    from '@angular/forms';\n\nimport { AppComponent }            from './app.component';\nimport { PageNotFoundComponent }   from './page-not-found/page-not-found.component';\nimport { ComposeMessageComponent } from './compose-message/compose-message.component';\n\nimport { AppRoutingModule }        from './app-routing.module';\nimport { HeroesModule }            from './heroes/heroes.module';\nimport { CrisisCenterModule }      from './crisis-center/crisis-center.module';\n\nimport { AdminModule }             from './admin/admin.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    HeroesModule,\n    CrisisCenterModule,\n    AdminModule,\n    AppRoutingModule\n  ],\n  <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [\n    AppComponent,\n    ComposeMessageComponent,\n    PageNotFoundComponent\n  ],\n  <a href=\"api/core/NgModule#bootstrap\" class=\"code-anchor\">bootstrap</a>: [ AppComponent ]\n})\nexport class AppModule { }\n\n\n</code-example>\n<!--\nAdd an \"Admin\" link to the `AppComponent` shell so that users can get to this feature.\n-->\n<p>이제 사용자가 관리자 기능에 접근할 수 있도록 <code>AppComponent</code>에 \"Admin\" 링크를 추가합니다.</p>\n<!--\n<code-example path=\"router/src/app/app.component.5.html\" linenums=\"false\" header=\"src/app/app.component.html (template)\">\n-->\n<code-example path=\"router/src/app/app.component.5.html\" linenums=\"false\" header=\"src/app/app.component.html (템플릿)\">\n&#x3C;h1 class=\"title\">Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>&#x3C;/h1>\n&#x3C;nav>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/crisis-center\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Crisis Center&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/heroes\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Heroes&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/admin\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Admin&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"[{ outlets: { popup: ['compose'] } }]\">Contact&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n&#x3C;/nav>\n&#x3C;div [@routeAnimation]=\"getAnimationData(routerOutlet)\">\n  &#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a> #routerOutlet=\"outlet\">&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n&#x3C;/div>\n&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a> name=\"popup\">&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n\n</code-example>\n<a id=\"guard-admin-feature\"></a>\n<!--\n#### Guard the admin feature\n-->\n<h4 id=\"관리자-모듈로-접근하는-동작-제한하기\">관리자 모듈로 접근하는 동작 제한하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#관리자-모듈로-접근하는-동작-제한하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nCurrently every route within the *Crisis Center* is open to everyone.\nThe new *admin* feature should be accessible only to authenticated users.\n\nYou could hide the link until the user logs in. But that's tricky and difficult to maintain.\n\nInstead you'll write a `canActivate()` guard method to redirect anonymous users to the\nlogin page when they try to enter the admin area.\n\nThis is a general purpose guard&mdash;you can imagine other features\nthat require authenticated users&mdash;so you generate an\n`AuthGuard` in the `auth` folder.\n-->\n<p>지금까지 작성한 애플리케이션은 모든 사용자가 \"위기대응센터\"에 접근할 수 있습니다.\n하지만 새로 추가한 <em>관리자</em> 모듈은 미리 인증된 사용자만 접근할 수 있도록 하려고 합니다.</p>\n<p>사용자가 로그인하지 않으면 링크를 감출 수도 있지만 이 방법은 간단한 트릭일 뿐 완벽한 방법이 아닙니다.</p>\n<p>이 방법보다는 로그인하지 않은 사용자가 관리자 페이지에 접근할 때 <code><a href=\"api/router/Route#canActivate\" class=\"code-anchor\">canActivate</a>()</code> 가드를 사용해서 로그인 페이지로 대신 이동하게 하는 것이 더 좋습니다.</p>\n<p>라우팅 가드는 보통 페이지에 접근하는 권한을 제어하는 용도로 사용합니다.\n다음 명령을 실행해서 <code>auth</code> 폴더에 <code>AuthGuard</code>를 생성합니다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate guard auth/auth\n</code-example>\n<!--\nAt the moment you're interested in seeing how guards work so the first version does nothing useful.\nIt simply logs to console and `returns` true immediately, allowing navigation to proceed:\n-->\n<p>이렇게 만든 라우팅 가드는 아직 별다른 동작을 하지 않습니다.\n이 가드는 단순하게 콘솔에 로그를 출력하고 <code>true</code>를 바로 반환합니다. 따라서 네비게이션 동작도 그대로 진행됩니다:</p>\n<!--\n<code-example path=\"router/src/app/auth/auth.guard.1.ts\" linenums=\"false\" header=\"src/app/auth/auth.guard.ts (excerpt)\">\n-->\n<code-example path=\"router/src/app/auth/auth.guard.1.ts\" linenums=\"false\" header=\"src/app/auth/auth.guard.ts (일부)\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { <a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a>, <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>, <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a> } from '@angular/router';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class AuthGuard implements <a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a> {\n  <a href=\"api/router/Route#canActivate\" class=\"code-anchor\">canActivate</a>(\n    next: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>,\n    <a href=\"api/animations/state\" class=\"code-anchor\">state</a>: <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>): boolean {\n    console.log('AuthGuard#<a href=\"api/router/Route#canActivate\" class=\"code-anchor\">canActivate</a> called');\n    return true;\n  }\n}\n\n\n</code-example>\n<!--\nNext, open `admin-routing.module.ts `, import the `AuthGuard` class, and\nupdate the admin route with a `canActivate` guard property that references it:\n-->\n<p>이제 <code>admin-routing.module.ts</code> 파일을 열고 <code>AuthGuard</code> 클래스를 로드한 후에 관리자 페이지에 연결된 라우팅 규칙에 <code><a href=\"api/router/Route#canActivate\" class=\"code-anchor\">canActivate</a></code> 가드를 다음과 같이 적용합니다:</p>\n<!--\n<code-example path=\"router/src/app/admin/admin-routing.module.2.ts\" linenums=\"false\" header=\"src/app/admin/admin-routing.module.ts (guarded admin route)\" region=\"admin-route\">\n-->\n<code-example path=\"router/src/app/admin/admin-routing.module.2.ts\" linenums=\"false\" header=\"src/app/admin/admin-routing.module.ts (관리자 페이지에 라우팅 가드 적용하기)\" region=\"admin-route\">\nimport { AuthGuard }                from '../auth/auth.guard';\n\nconst adminRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'admin',\n    component: AdminComponent,\n    <a href=\"api/router/Route#canActivate\" class=\"code-anchor\">canActivate</a>: [AuthGuard],\n    children: [\n      {\n        path: '',\n        children: [\n          { path: 'crises', component: ManageCrisesComponent },\n          { path: 'heroes', component: ManageHeroesComponent },\n          { path: '', component: AdminDashboardComponent }\n        ],\n      }\n    ]\n  }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    RouterModule.forChild(adminRoutes)\n  ],\n  <a href=\"api/core/NgModule#exports\" class=\"code-anchor\">exports</a>: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class AdminRoutingModule {}\n\n</code-example>\n <!--\nThe admin feature is now protected by the guard, albeit protected poorly.\n-->\n<p>아직 라우팅 가드가 실제로 동작하지는 않지만 관리자 모듈이 라우팅 가드로 보호되었습니다.</p>\n<a id=\"teach-auth\"></a>\n<!--\n#### Teach *AuthGuard* to authenticate\n-->\n<h4 id=\"authguard-구현하기\"><em>AuthGuard</em> 구현하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#authguard-구현하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nMake the `AuthGuard` at least pretend to authenticate.\n\nThe `AuthGuard` should call an application service that can login a user and retain information about the current user. Generate a new `AuthService` in the `auth` folder:\n-->\n<p>이제 인증기능을 수행하는 <code>AuthGuard</code>를 구현해 봅시다.</p>\n<p><code>AuthGuard</code>는 애플리케이션에 있는 서비스를 사용해서 사용자가 로그인한 정보를 가져와야 합니다. 다음 명령을 실행해서 <code>admin</code> 폴더에 <code>AuthService</code>를 생성합니다:</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate service auth/auth\n</code-example>\n<!--\nUpdate the `AuthService` to log in the user:\n-->\n<p>그리고 <code>AuthService</code>를 사용해서 사용자가 로그인했는지 확인할 수 있도록 다음과 같이 코드를 작성합니다:</p>\n<!--\n<code-example path=\"router/src/app/auth/auth.service.ts\" linenums=\"false\" header=\"src/app/auth/auth.service.ts (excerpt)\">\n-->\n<code-example path=\"router/src/app/auth/auth.service.ts\" linenums=\"false\" header=\"src/app/auth/auth.service.ts (일부)\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\nimport { Observable, of } from 'rxjs';\nimport { tap, delay } from 'rxjs/operators';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class AuthService {\n  isLoggedIn = false;\n\n  // 사용자가 로그인한 후에 이동할 <a href=\"api/core/SecurityContext#URL\" class=\"code-anchor\">URL</a>을 저장합니다.\n  redirectUrl: string;\n\n  login(): Observable&#x3C;boolean> {\n    return of(true).pipe(\n      delay(1000),\n      tap(val => this.isLoggedIn = true)\n    );\n  }\n\n  logout(): void {\n    this.isLoggedIn = false;\n  }\n}\n\n\n</code-example>\n<!--\nAlthough it doesn't actually log in, it has what you need for this discussion.\nIt has an `isLoggedIn` flag to tell you whether the user is authenticated.\nIts `login` method simulates an API call to an external service by returning an\nobservable that resolves successfully after a short pause.\nThe `redirectUrl` property will store the attempted URL so you can navigate to it after authenticating.\n\nRevise the `AuthGuard` to call it.\n-->\n<p>이 코드에 로그인 기능을 실제로 구현한 것은 아니지만, 이 문서에서 다루는 내용을 설명하기에는 이 정도면 충분합니다.\n사용자가 로그인을 했으면 <code>isLoggedIn</code> 플래그에 <code>true</code>를 할당합니다.\n<code>login</code> 메소드는 서버로 통신한 것을 흉내내기 위해 시간을 약간 지연시킨 후에 <code>Observable</code>을 반환합니다.\n그리고 <code>redirectUrl</code> 프로퍼티에는 사용자가 로그인 한 후에 리다이렉트할 URL을 저장해 둡니다.</p>\n<p>실제로 사용할 수 있는 수준으로 코드를 작성하면 <code>AuthGuard</code>는 다음과 같이 구현할 수 있습니다.</p>\n<code-example path=\"router/src/app/auth/auth.guard.2.ts\" linenums=\"false\" header=\"src/app/auth/auth.guard.ts (v2)\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { <a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a>, <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>, <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>, <a href=\"api/router/Router\" class=\"code-anchor\">Router</a> } from '@angular/router';\n\nimport { AuthService }      from './auth.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class AuthGuard implements <a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a> {\n  constructor(private authService: AuthService, private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {}\n\n  <a href=\"api/router/Route#canActivate\" class=\"code-anchor\">canActivate</a>(\n    next: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>,\n    <a href=\"api/animations/state\" class=\"code-anchor\">state</a>: <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>): boolean {\n    let url: string = state.url;\n\n    return this.checkLogin(url);\n  }\n\n  checkLogin(url: string): boolean {\n    if (this.authService.isLoggedIn) { return true; }\n\n    // 로그인한 후 리다이렉트할 수 있도록 <a href=\"api/core/SecurityContext#URL\" class=\"code-anchor\">URL</a>을 저장합니다.\n    this.authService.redirectUrl = url;\n\n    // 로그인하지 않았기 때문에 로그인 페이지로 이동합니다.\n    this.router.navigate(['/login']);\n    return false;\n  }\n}\n\n</code-example>\n<!--\nNotice that you *inject* the `AuthService` and the `Router` in the constructor.\nYou haven't provided the `AuthService` yet but it's good to know that you can inject helpful services into routing guards.\n\nThis guard returns a synchronous boolean result.\nIf the user is logged in, it returns true and the navigation continues.\n\nThe `ActivatedRouteSnapshot` contains the _future_ route that will be activated and the `RouterStateSnapshot`\ncontains the _future_ `RouterState` of the application, should you pass through the guard check.\n\nIf the user is not logged in, you store the attempted URL the user came from using the `RouterStateSnapshot.url` and\ntell the router to navigate to a login page&mdash;a page you haven't created yet.\nThis secondary navigation automatically cancels the current navigation; `checkLogin()` returns\n`false` just to be clear about that.\n-->\n<p>생성자로 <code>AuthService</code>와 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>가 <em>의존성으로 주입</em>되는 것을 확인해 보세요.\n아직 <code>AuthService</code>는 구현하지 않았지만, 라우팅 가드에 필요한 서비스는 이런 방식으로 주입할 수 있습니다.</p>\n<p>이 라우팅 가드는 불리언 값을 동기 방식으로 반환합니다.\n그리고 사용자가 로그인했다면 <code>true</code>를 반환하기 때문에 원래 실행하던 네비게이션 로직을 그대로 실행합니다.</p>\n<p><code><a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a></code>에는 로그인 상태를 확인한 <em>이후에</em> 활성화될 라우팅 규칙이 전달되며, <code><a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a></code>에는 이 시점에 사용될 <code><a href=\"api/router/RouterState\" class=\"code-anchor\">RouterState</a></code>이 전달됩니다. 그래서 라우팅 가드가 제대로 동작하려면 이 정보들이 전달되어야 합니다.</p>\n<p>사용자가 로그인하지 않았으면 원래 네비게이션 하려던 URL을 <code><a href=\"api/router/RouterStateSnapshot#url\" class=\"code-anchor\">RouterStateSnapshot.url</a></code>에서 참조해서 프로퍼티로 저장한 후에 로그인 페이지로 이동합니다. (아직 로그인 페이지는 구현되지 않았습니다.)\n그리고 <code>checkLogin()</code> 메소드가 <code>false</code>를 반환하기 때문에 현재 실행되고 있는 네비게이션 동작을 중단합니다.</p>\n<a id=\"add-login-component\"></a>\n<!--\n#### Add the *LoginComponent*\n-->\n<h4 id=\"logincomponent-구현하기\"><code>LoginComponent</code> 구현하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#logincomponent-구현하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nYou need a `LoginComponent` for the user to log in to the app. After logging in, you'll redirect\nto the stored URL if available, or use the default URL.\nThere is nothing new about this component or the way you wire it into the router configuration.\n-->\n<p>이제 사용자가 애플리케이션에 로그인하려면 <code>LoginComponent</code>가 필요합니다.\n이 컴포넌트에서 사용자가 로그인하고 나면 원래 이동하려던 페이지로 이동하며, 대상 페이지가 저장되지 않았다면 기본 URL로 이동할 것입니다.\n이 컴포넌트는 라우팅 설정에 활용된다는 것을 제외하면 이전에 다뤘던 컴포넌트와 거의 비슷합니다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component auth/login\n</code-example>\n<!--\nRegister a `/login` route in the `auth/auth-routing.module.ts`. In `app.module.ts`, import and add the `AuthModule` to the `AppModule` imports.\n-->\n<p><code>auth/auth-routing.module.ts</code> 파일에 <code>/login</code> 라우팅 규칙을 추가합니다.\n그리고 <code>app.module.ts</code> 파일에 정의된 <code>AppModule</code>에 <code>AuthModule</code>을 로드합니다.</p>\n<code-tabs>\n\n  <code-pane header=\"src/app/app.module.ts\" path=\"router/src/app/app.module.ts\" region=\"auth\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }       from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> }  from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> }    from '@angular/forms';\nimport { <a href=\"api/platform-browser/animations/BrowserAnimationsModule\" class=\"code-anchor\">BrowserAnimationsModule</a> } from '@angular/platform-browser/animations';\n\nimport { AppComponent }            from './app.component';\nimport { PageNotFoundComponent }   from './page-not-found/page-not-found.component';\nimport { ComposeMessageComponent } from './compose-message/compose-message.component';\n\nimport { AppRoutingModule }        from './app-routing.module';\nimport { HeroesModule }            from './heroes/heroes.module';\nimport { AuthModule }              from './auth/auth.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/platform-browser/animations/BrowserAnimationsModule\" class=\"code-anchor\">BrowserAnimationsModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    HeroesModule,\n    AuthModule,\n    AppRoutingModule,\n  ],\n  <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [\n    AppComponent,\n    ComposeMessageComponent,\n    PageNotFoundComponent\n  ],\n  <a href=\"api/core/NgModule#bootstrap\" class=\"code-anchor\">bootstrap</a>: [ AppComponent ]\n})\nexport class AppModule {\n}\n\n</code-pane>\n\n  <code-pane header=\"src/app/auth/login/login.component.html\" path=\"router/src/app/auth/login/login.component.html\">\n&#x3C;h2>LOGIN&#x3C;/h2>\n&#x3C;p>{{<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>}}&#x3C;/p>\n&#x3C;p>\n  &#x3C;button (click)=\"login()\"  *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"!authService.isLoggedIn\">Login&#x3C;/button>\n  &#x3C;button (click)=\"logout()\" *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"authService.isLoggedIn\">Logout&#x3C;/button>\n&#x3C;/p>\n\n</code-pane>  \n\n  <code-pane header=\"src/app/auth/login/login.component.ts\" path=\"router/src/app/auth/login/login.component.1.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> }   from '@angular/core';\nimport { <a href=\"api/router/Router\" class=\"code-anchor\">Router</a> }      from '@angular/router';\nimport { AuthService } from '../auth.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-login',\n  templateUrl: './login.component.html',\n  <a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a>: ['./login.component.css']\n})\nexport class LoginComponent {\n  <a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>: string;\n\n  constructor(public authService: AuthService, public router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {\n    this.setMessage();\n  }\n\n  setMessage() {\n    this.message = 'Logged ' + (this.authService.isLoggedIn ? 'in' : 'out');\n  }\n\n  login() {\n    this.message = 'Trying to <a href=\"api/animations/browser/testing/MockAnimationDriver#log\" class=\"code-anchor\">log</a> in ...';\n\n    this.authService.login().subscribe(() => {\n      this.setMessage();\n      if (this.authService.isLoggedIn) {\n        // AuthService에서 리다이렉트할 <a href=\"api/core/SecurityContext#URL\" class=\"code-anchor\">URL</a>을 가져옵니다.\n        // 저장된 주소가 없으면 기본 페이지로 이동합니다.\n        let redirect = this.authService.redirectUrl ? this.authService.redirectUrl : '/crisis-center/admin';\n\n        // 최종 주소로 이동합니다.\n        this.router.navigate([redirect]);\n      }\n    });\n  }\n\n  logout() {\n    this.authService.logout();\n    this.setMessage();\n  }\n}\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/auth/auth.module.ts\" path=\"router/src/app/auth/auth.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }       from '@angular/core';\nimport { <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> }   from '@angular/common';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> }    from '@angular/forms';\n\nimport { LoginComponent }    from './login/login.component';\nimport { AuthRoutingModule } from './auth-routing.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    AuthRoutingModule\n  ],\n  <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [\n    LoginComponent\n  ]\n})\nexport class AuthModule {}\n\n</code-pane>\n\n</code-tabs>\n<a id=\"can-activate-child-guard\"></a>\n<!--\n### _CanActivateChild_: guarding child routes\n-->\n<h3 id=\"canactivatechild-자식-라우팅-제어하기\"><em>CanActivateChild</em>: 자식 라우팅 제어하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#canactivatechild-자식-라우팅-제어하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou can also protect child routes with the `CanActivateChild` guard.\nThe `CanActivateChild` guard is similar to the `CanActivate` guard.\nThe key difference is that it runs _before_  any child route is activated.\n\nYou protected the admin feature module from unauthorized access.\nYou should also protect child routes _within_ the feature module.\n\nExtend the `AuthGuard` to protect when navigating between the `admin` routes.\nOpen `auth.guard.ts` and add the `CanActivateChild` interface to the imported tokens from the router package.\n\nNext, implement the `canActivateChild()` method which takes the same arguments as the `canActivate()` method:\nan `ActivatedRouteSnapshot` and `RouterStateSnapshot`.\nThe `canActivateChild()` method can return an `Observable<boolean>` or `Promise<boolean>` for\nasync checks and a `boolean` for sync checks.\nThis one returns a `boolean`:\n-->\n<p><code><a href=\"api/router/CanActivateChild\" class=\"code-anchor\">CanActivateChild</a></code> 라우팅 가드를 사용하면 자식 라우팅을 제어할 수 있습니다.\n<code><a href=\"api/router/CanActivateChild\" class=\"code-anchor\">CanActivateChild</a></code>는 자식 라우팅 규칙이 활성화되기 <em>전에</em> 실행된다는 점만 빼면 <code><a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a></code> 가드와 비슷합니다.</p>\n<p>지금까지는 허가받지 않은 사용자가 관리자 기능 모듈에 접근하는 것을 제한했었습니다.\n그런데 이 로직이 제대로 동작하려면 기능 모듈 <em>안쪽에서</em> 자식 라우팅 규칙이 활성화되는 것도 검사해야 합니다.</p>\n<p>이번에는 <code>AuthGuard</code>를 수정해서 <code>admin</code> 주소 안쪽에서 페이지가 전환되는 것을 제어해 봅시다.\n<code>auth.guard.ts</code> 파일을 열고 라우터 패키지에서 <code><a href=\"api/router/CanActivateChild\" class=\"code-anchor\">CanActivateChild</a></code> 인터페이스를 로드합니다.</p>\n<p>그리고 <code><a href=\"api/router/Route#canActivate\" class=\"code-anchor\">canActivate</a>()</code> 메소드를 구현했던 것처럼 <code><a href=\"api/router/Route#canActivateChild\" class=\"code-anchor\">canActivateChild</a>()</code> 메소드를 구현합니다. 이 때 이 함수에는 <code><a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a></code>과 <code><a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a></code>이 인자로 전달됩니다.\n<code><a href=\"api/router/Route#canActivateChild\" class=\"code-anchor\">canActivateChild</a>()</code> 메소드를 비동기로 실행하려면 <code>Observable&#x3C;boolean></code>이나 <code>Promise&#x3C;boolean></code>을 반환하고, 동기 방식으로 실행하려면 <code>boolean</code> 타입을 반환하면 됩니다.\n이 예제에서는 <code>boolean</code> 타입을 반환합니다:</p>\n<!--\n<code-example path=\"router/src/app/auth/auth.guard.3.ts\" linenums=\"false\" header=\"src/app/auth/auth.guard.ts (excerpt)\" region=\"can-activate-child\">\n-->\n<code-example path=\"router/src/app/auth/auth.guard.3.ts\" linenums=\"false\" header=\"src/app/auth/auth.guard.ts (일부)\" region=\"can-activate-child\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> }       from '@angular/core';\nimport {\n  <a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a>, <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,\n  <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>,\n  <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>,\n  <a href=\"api/router/CanActivateChild\" class=\"code-anchor\">CanActivateChild</a>\n}                           from '@angular/router';\nimport { AuthService }      from './auth.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class AuthGuard implements <a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a>, <a href=\"api/router/CanActivateChild\" class=\"code-anchor\">CanActivateChild</a> {\n  constructor(private authService: AuthService, private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {}\n\n  <a href=\"api/router/Route#canActivate\" class=\"code-anchor\">canActivate</a>(\n    route: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>,\n    <a href=\"api/animations/state\" class=\"code-anchor\">state</a>: <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>): boolean {\n    let url: string = state.url;\n\n    return this.checkLogin(url);\n  }\n\n  <a href=\"api/router/Route#canActivateChild\" class=\"code-anchor\">canActivateChild</a>(\n    route: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>,\n    <a href=\"api/animations/state\" class=\"code-anchor\">state</a>: <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>): boolean {\n    return this.canActivate(route, <a href=\"api/animations/state\" class=\"code-anchor\">state</a>);\n  }\n\n/* . . . */\n}\n\n</code-example>\n<!--\nAdd the same `AuthGuard` to the `component-less` admin route to protect all other child routes at one time\ninstead of adding the `AuthGuard` to each route individually.\n-->\n<p>이제 컴포넌트 없이 선언한 관리자 라우팅 규칙의 자식 라우팅 규칙에 다음과 같이 <code>AuthGuard</code>를 적용합니다. 이제 이 컴포넌트의 자식 라우팅 규칙은 모두 라우팅 가드로 보호됩니다.</p>\n<!--\n<code-example path=\"router/src/app/admin/admin-routing.module.3.ts\" linenums=\"false\" header=\"src/app/admin/admin-routing.module.ts (excerpt)\" region=\"can-activate-child\">\n-->\n<code-example path=\"router/src/app/admin/admin-routing.module.3.ts\" linenums=\"false\" header=\"src/app/admin/admin-routing.module.ts (일부)\" region=\"can-activate-child\">\nconst adminRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'admin',\n    component: AdminComponent,\n    <a href=\"api/router/Route#canActivate\" class=\"code-anchor\">canActivate</a>: [AuthGuard],\n    children: [\n      {\n        path: '',\n        <a href=\"api/router/Route#canActivateChild\" class=\"code-anchor\">canActivateChild</a>: [AuthGuard],\n        children: [\n          { path: 'crises', component: ManageCrisesComponent },\n          { path: 'heroes', component: ManageHeroesComponent },\n          { path: '', component: AdminDashboardComponent }\n        ]\n      }\n    ]\n  }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    RouterModule.forChild(adminRoutes)\n  ],\n  <a href=\"api/core/NgModule#exports\" class=\"code-anchor\">exports</a>: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class AdminRoutingModule {}\n\n</code-example>\n<a id=\"can-deactivate-guard\"></a>\n<!--\n### _CanDeactivate_: handling unsaved changes\n-->\n<h3 id=\"candeactivate-저장되지-않은-변경사항-체크하기\"><em>CanDeactivate</em>: 저장되지 않은 변경사항 체크하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#candeactivate-저장되지-않은-변경사항-체크하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nBack in the \"Heroes\" workflow, the app accepts every change to a hero immediately without hesitation or validation.\n-->\n<p>\"Heroes\"가 동작하던 것을 다시 생각해보면, 이 앱은 히어로의 정보가 변경된 것을 검사하지 않고 바로 저장합니다.</p>\n<!--\nIn the real world, you might have to accumulate the users changes.\nYou might have to validate across fields.\nYou might have to validate on the server.\nYou might have to hold changes in a pending state until the user confirms them *as a group* or\ncancels and reverts all changes.\n-->\n<p>하지만 실제 운영환경에서는 사용자가 변경한 내용을 추적해야 하는 경우가 많습니다.\n필드를 검사해야 할 수도 있고, 서버로 전달된 데이터를 검사해야 할 수도 있으며, <em>여러개를 수정했을 때</em> 이 내용을 모두 반영할 것인지, 아니면 모두 취소할 것인지 정해지기 전까지는 상태를 유지해야 할 수도 있습니다.</p>\n<!--\nWhat do you do about unapproved, unsaved changes when the user navigates away?\nYou can't just leave and risk losing the user's changes; that would be a terrible experience.\n-->\n<p>사용자가 화면에 있는 내용을 변경했는데 이 내용을 저장하지 않고 다른 페이지로 이동하려고 한다면 어떻게 해야 할까요?\n이 때 다른 페이지로 바로 이동하면 사용자가 변경한 내용이 모두 사라집니다. 사용자의 입장에서는 굉장히 불편할 수 있습니다.</p>\n<!--\nIt's better to pause and let the user decide what to do.\nIf the user cancels, you'll stay put and allow more changes.\nIf the user approves, the app can save.\n-->\n<p>이것보다는 사용자가 결정을 내릴때까지 페이지 이동을 잠시 멈추는 것이 더 좋습니다.\n사용자가 페이지 이동을 취소하면 현재 페이지의 내용을 그대로 유지할 수 있으며, 사용자가 저장하기로 결정하면 변경사항을 모두 서버로 전달할 수도 있습니다.</p>\n<!--\nYou still might delay navigation until the save succeeds.\nIf you let the user move to the next screen immediately and\nthe save were to fail (perhaps the data are ruled invalid), you would lose the context of the error.\n-->\n<p>그리고 사용자가 변경사항을 저장하기로 하면 서버로 보낸 요청이 완료될 때까지 잠시 네비게이션을 미룰 수도 있습니다.\n서버로 보낸 데이터나 형식이 잘못된 것을 무시하고 다음 화면으로 바로 넘어가면, 데이터를 저장하면서 발생한 에러를 처리할 수 없습니다.</p>\n<!--\nYou can't block while waiting for the server&mdash;that's not possible in a browser.\nYou need to stop the navigation while you wait, asynchronously, for the server\nto return with its answer.\n-->\n<p>브라우저 자체 기능만으로는 서버의 응답이 올 때까지 페이지 이동을 보류해둘 수 없습니다.\n그래서 서버의 응답이 올 때까지 네비게이션을 멈춰두는 기능이 필요합니다.</p>\n<!--\nYou need the `CanDeactivate` guard.\n-->\n<p><code><a href=\"api/router/CanDeactivate\" class=\"code-anchor\">CanDeactivate</a></code> 라우팅 가드는 이런 경우에 사용합니다.</p>\n<a id=\"cancel-save\"></a>\n<!--\n#### Cancel and save\n-->\n<h4 id=\"페이지-이동을-취소하고-저장하기\">페이지 이동을 취소하고 저장하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#페이지-이동을-취소하고-저장하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe sample application doesn't talk to a server.\nFortunately, you have another way to demonstrate an asynchronous router hook.\n\nUsers update crisis information in the `CrisisDetailComponent`.\nUnlike the `HeroDetailComponent`, the user changes do not update the crisis entity immediately.\nInstead, the app updates the entity when the user presses the *Save* button and\ndiscards the changes when the user presses the *Cancel* button.\n\nBoth buttons navigate back to the crisis list after save or cancel.\n-->\n<p>이 문서에서 다루는 애플리케이션은 서버와 통신을 하지 않습니다.\n하지만 라우터 후킹 함수를 사용하면 이 시나리오를 흉내낼 수 있습니다.</p>\n<p>사용자가 <code>CrisisDetailComponent</code>에서 위기사항에 대한 정보를 수정했다고 합시다.\n이 때 <code>HeroDetailComponent</code>와는 다르게, 사용자가 변경한 내용을 바로 저장하지 않으려고 합니다.\n이 컴포넌트에서는 사용자가 <em>Save</em> 버튼을 클릭했을 때 변경내용을 저장하고, 사용자가 <em>Cancel</em> 버튼을 클릭하면 변경사항을 폐기합니다.</p>\n<p>그리고 두 버튼을 클릭하면 모두 이전 페이지인 위기 목록 페이지로 이동합니다.</p>\n<!--\n<code-example path=\"router/src/app/crisis-center/crisis-detail/crisis-detail.component.ts\" linenums=\"false\" header=\"src/app/crisis-center/crisis-detail/crisis-detail.component.ts (cancel and save methods)\" region=\"cancel-save\">\n-->\n<code-example path=\"router/src/app/crisis-center/crisis-detail/crisis-detail.component.ts\" linenums=\"false\" header=\"src/app/crisis-center/crisis-detail/crisis-detail.component.ts (cancel, save 메소드)\" region=\"cancel-save\">\ncancel() {\n  this.gotoCrises();\n}\n\nsave() {\n  this.crisis.name = this.editName;\n  this.gotoCrises();\n}\n\n</code-example>\n<!--\nWhat if the user tries to navigate away without saving or canceling?\nThe user could push the browser back button or click the heroes link.\nBoth actions trigger a navigation.\nShould the app save or cancel automatically?\n\nThis demo does neither. Instead, it asks the user to make that choice explicitly\nin a confirmation dialog box that *waits asynchronously for the user's\nanswer*.\n-->\n<p>사용자가 변경사항을 저장하거나 취소하지 않고 다른 페이지로 이동하려고 하는 상황은 어떤 상황일까요?\n이런 상황은 브라우저의 뒤로 가기 버튼을 클릭하거나 목록으로 이동하는 링크를 클릭했을 때 발생할 수 있습니다.\n두가지 경우 모두 네비게이션이 실행됩니다.\n그러면 앱에서 자동으로 변경사항을 저장하거나 취소해야 할까요?</p>\n<p>저장하거나 취소하는 것을 임의로 간주하고 이렇게 로직을 구현할 수도 있습니다. 하지만 이 예제에서는 팝업을 띄워서 사용자가 명시적으로 선택하도록 구현해 봅시다. 사용자가 응답할 때까지 페이지를 전환하는 동작은 <em>비동기적으로 중단</em>됩니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nYou could wait for the user's answer with synchronous, blocking code.\nThe app will be more responsive&mdash;and can do other work&mdash;by\nwaiting for the user's answer asynchronously. Waiting for the user asynchronously\nis like waiting for the server asynchronously.\n-->\n<p>사용자의 응답을 기다리는 것을 동기 방식으로 할 수도 있습니다.\n하지만 이런 경우에는 앱이 다른 작업을 하지 못하고 사용자의 응답이 있을 때까지 대기해야 합니다.\n사용자의 응답을 기다리는 것도 서버의 응답을 기다리는 것처럼 비동기로 하는 것이 좋습니다.</p>\n</div>\n<!--\nGenerate a `Dialog` service to handle user confirmation.\n-->\n<p>사용자의 입력을 받기 위해 <code>Dialog</code> 서비스를 구현합니다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate service dialog\n</code-example>\n<!--\nAdd a `confirm()` method to the `DialogService` to prompt the user to confirm their intent. The `window.confirm` is a _blocking_ action that displays a modal dialog and waits for user interaction.\n-->\n<p>그리고 사용자의 응답을 받기 위해 <code>DialogService</code>에 <code>confirm()</code> 메소드를 추가합니다.\n<code>window.confirm</code> 메소드는 사용자가 응답할 때까지 화면에서 발생할 수 있는 동작을 <em>멈춥니다</em>.</p>\n<code-example path=\"router/src/app/dialog.service.ts\" header=\"src/app/dialog.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { Observable, of } from 'rxjs';\n\n/**\n * 비동기 모달 팝업 서비스\n * DialogService는 예제를 확인하기 위해 간단하게 구현한 서비스입니다.\n * TODO: window.confirm을 사용하지 않는 방식이 더 좋습니다.\n */\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class DialogService {\n  /**\n   * 어떤 행동을 할지 사용자에게 물어봅니다. `<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>`는 사용자에게 안내할 문구입니다.\n   * `true`를 반환하면 사용자가 확정한 것으로 처리하고, `false`를 반환하면 취소한 것으로 처리합니다.\n   * 결과는 Observable 타입으로 반환합니다.\n   */\n  confirm(<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>?: string): Observable&#x3C;boolean> {\n    const confirmation = window.confirm(<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a> || 'Is it OK?');\n\n    return of(confirmation);\n  };\n}\n\n\n</code-example>\n<!--\nIt returns an `Observable` that *resolves* when the user eventually decides what to do: either\nto discard changes and navigate away (`true`) or to preserve the pending changes and stay in the crisis editor (`false`).\n-->\n<p>이 함수는 사용자의 응답을 <code>Observable</code> 타입으로 반환합니다. 사용자가 <code>true</code>를 선택하면 변경사항을 버리고 다른 페이지로 이동하며, 사용자가 <code>false</code>를 선택하면 네비게이션을 멈추고 현재 페이지에 머물러 있을 것입니다.</p>\n<a id=\"CanDeactivate\"></a>\n<!--\nGenerate a _guard_ that checks for the presence of a `canDeactivate()` method in a component&mdash;any component.\n-->\n<p>다음 명령을 실행해서 <em>라우팅 가드</em> 를 생성합니다. 이 가드는 컴포넌트에 있는 <code><a href=\"api/router/Route#canDeactivate\" class=\"code-anchor\">canDeactivate</a>()</code> 메소드를 실행하는 역할을 합니다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate guard can-deactivate\n</code-example>\n<!--\nThe `CrisisDetailComponent` will have this method.\nBut the guard doesn't have to know that.\nThe guard shouldn't know the details of any component's deactivation method.\nIt need only detect that the component has a `canDeactivate()` method and call it.\nThis approach makes the guard reusable.\n-->\n<p><code>CrisisDetailComponent</code>에는 이미 <code><a href=\"api/router/Route#canDeactivate\" class=\"code-anchor\">canDeactivate</a>()</code> 메소드가 구현되어 있습니다.\n하지만 이 라우팅 가드가 컴포넌트의 <code><a href=\"api/router/Route#canDeactivate\" class=\"code-anchor\">canDeactivate</a>()</code> 메소드의 로직을 알아야 할 필요는 없습니다.\n이 라우팅 가드는 단순하게 컴포넌트에 <code><a href=\"api/router/Route#canDeactivate\" class=\"code-anchor\">canDeactivate</a>()</code> 메소드가 정의되어 있는지 확인하고, 정의되어 있다면 이 메소드를 실행하기만 할 뿐입니다.\n이렇게 구현하면 이 라우팅 가드를 다른 컴포넌트를 대상으로도 재사용할 수 있습니다.</p>\n<code-example path=\"router/src/app/can-deactivate.guard.ts\" header=\"src/app/can-deactivate.guard.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> }    from '@angular/core';\nimport { <a href=\"api/router/CanDeactivate\" class=\"code-anchor\">CanDeactivate</a> } from '@angular/router';\nimport { Observable }    from 'rxjs';\n\nexport interface CanComponentDeactivate {\n <a href=\"api/router/Route#canDeactivate\" class=\"code-anchor\">canDeactivate</a>: () => Observable&#x3C;boolean> | Promise&#x3C;boolean> | boolean;\n}\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class CanDeactivateGuard implements <a href=\"api/router/CanDeactivate\" class=\"code-anchor\">CanDeactivate</a>&#x3C;CanComponentDeactivate> {\n  <a href=\"api/router/Route#canDeactivate\" class=\"code-anchor\">canDeactivate</a>(component: CanComponentDeactivate) {\n    return component.canDeactivate ? component.canDeactivate() : true;\n  }\n}\n\n\n</code-example>\n<!--\nAlternatively, you could make a component-specific `CanDeactivate` guard for the `CrisisDetailComponent`.\nThe `canDeactivate()` method provides you with the current\ninstance of the `component`, the current `ActivatedRoute`,\nand `RouterStateSnapshot` in case you needed to access\nsome external information. This would be useful if you only\nwanted to use this guard for this component and needed to get\nthe component's properties or confirm whether the router should allow navigation away from it.\n-->\n<p>이 방식 대신 <code>CrisisDetailComponent</code>에만 적용되는 <code><a href=\"api/router/CanDeactivate\" class=\"code-anchor\">CanDeactivate</a></code> 가드를 구현할 수도 있습니다.\n그러면 이 라우팅 가드의 <code><a href=\"api/router/Route#canDeactivate\" class=\"code-anchor\">canDeactivate</a>()</code> 메소드는 현재 컴포넌트의 인스턴스와 현재 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>, <code><a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a></code>, 필요하다면 더 많은 정보에 접근해야 합니다.\n이 라우팅 가드가 딱 이 컴포넌트에만 사용된다면 이렇게 구현할 수도 있습니다.</p>\n<!--\n<code-example path=\"router/src/app/can-deactivate.guard.1.ts\" linenums=\"false\" header=\"src/app/can-deactivate.guard.ts (component-specific)\">\n-->\n<code-example path=\"router/src/app/can-deactivate.guard.1.ts\" linenums=\"false\" header=\"src/app/can-deactivate.guard.ts (특정 컴포넌트를 위한 라우팅 가드)\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> }           from '@angular/core';\nimport { Observable }           from 'rxjs';\nimport { <a href=\"api/router/CanDeactivate\" class=\"code-anchor\">CanDeactivate</a>,\n         <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>,\n         <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a> }  from '@angular/router';\n\nimport { CrisisDetailComponent } from './crisis-center/crisis-detail/crisis-detail.component';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class CanDeactivateGuard implements <a href=\"api/router/CanDeactivate\" class=\"code-anchor\">CanDeactivate</a>&#x3C;CrisisDetailComponent> {\n\n  <a href=\"api/router/Route#canDeactivate\" class=\"code-anchor\">canDeactivate</a>(\n    component: CrisisDetailComponent,\n    route: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>,\n    <a href=\"api/animations/state\" class=\"code-anchor\">state</a>: <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>\n  ): Observable&#x3C;boolean> | boolean {\n    // 위기 관리 센터의 ID를 가져옵니다.\n    console.log(route.paramMap.get('id'));\n\n    // 현재 <a href=\"api/core/SecurityContext#URL\" class=\"code-anchor\">URL</a>을 확인합니다.\n    console.log(state.url);\n\n    // 위기 목록이 없거나 변경되지 않았으면 `true`를 바로 반환합니다.\n    if (!component.crisis || component.crisis.name === component.editName) {\n      return true;\n    }\n    // 내용이 변경된 경우에는 사용자에게 물어보는 팝업을 띄웁니다.\n    // 그리고 사용자가 응답한 값을 Observable 타입으로 반환합니다.\n    return component.dialogService.confirm('Discard <a href=\"api/core/QueryList#changes\" class=\"code-anchor\">changes</a>?');\n  }\n}\n\n\n</code-example>\n<!--\nLooking back at the `CrisisDetailComponent`, it implements the confirmation workflow for unsaved changes.\n-->\n<p>다시 <code>CrisisDetailComponent</code>를 보면, 변경되지 않은 내용을 확인하는 로직은 다음과 같이 구현되어 있습니다.</p>\n<!--\n<code-example path=\"router/src/app/crisis-center/crisis-detail/crisis-detail.component.ts\" linenums=\"false\" header=\"src/app/crisis-center/crisis-detail/crisis-detail.component.ts (excerpt)\" region=\"canDeactivate\">\n-->\n<code-example path=\"router/src/app/crisis-center/crisis-detail/crisis-detail.component.ts\" linenums=\"false\" header=\"src/app/crisis-center/crisis-detail/crisis-detail.component.ts (일부)\" region=\"canDeactivate\">\n<a href=\"api/router/Route#canDeactivate\" class=\"code-anchor\">canDeactivate</a>(): Observable&#x3C;boolean> | boolean {\n  // 위기 목록이 없거나 변경되지 않았으면 `true`를 바로 반환합니다.\n  if (!this.crisis || this.crisis.name === this.editName) {\n    return true;\n  }\n  // 내용이 변경된 경우에는 사용자에게 물어보는 팝업을 띄웁니다.\n  // 그리고 사용자가 응답한 값을 Observable 타입으로 반환합니다.\n  return this.dialogService.confirm('Discard <a href=\"api/core/QueryList#changes\" class=\"code-anchor\">changes</a>?');\n}\n\n</code-example>\n<!--\nNotice that the `canDeactivate()` method *can* return synchronously;\nit returns `true` immediately if there is no crisis or there are no pending changes.\nBut it can also return a `Promise` or an `Observable` and the router will wait for that\nto resolve to truthy (navigate) or falsy (stay put).\n-->\n<p><code><a href=\"api/router/Route#canDeactivate\" class=\"code-anchor\">canDeactivate</a>()</code> 메소드는 값을 <em>동기 방식으로</em> 반환할 수도 있습니다.\n만약 위기 목록이 없거나 변경된 내용이 없으면 이 메소드는 <code>true</code>를 즉시 반환합니다.\n하지만 이 메소드가 <code>Promise</code>나 <code>Observable</code> 타입을 반환한다면 이 객체들이 처리될 때까지 라우터는 동작하지 않고 멈춥니다.</p>\n<!--\nAdd the `Guard` to the crisis detail route in `crisis-center-routing.module.ts` using the `canDeactivate` array property.\n-->\n<p>이제 이 라우팅 가드를 <code>crisis-center-routing.module.ts</code>에 다음과 같이 추가합니다.</p>\n<code-example path=\"router/src/app/crisis-center/crisis-center-routing.module.3.ts\" linenums=\"false\" header=\"src/app/crisis-center/crisis-center-routing.module.ts (can deactivate guard)\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }             from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { CrisisCenterHomeComponent } from './crisis-center-home/crisis-center-home.component';\nimport { CrisisListComponent }       from './crisis-list/crisis-list.component';\nimport { CrisisCenterComponent }     from './crisis-center/crisis-center.component';\nimport { CrisisDetailComponent }     from './crisis-detail/crisis-detail.component';\n\nimport { CanDeactivateGuard }    from '../can-deactivate.guard';\n\nconst crisisCenterRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'crisis-center',\n    component: CrisisCenterComponent,\n    children: [\n      {\n        path: '',\n        component: CrisisListComponent,\n        children: [\n          {\n            path: ':id',\n            component: CrisisDetailComponent,\n            <a href=\"api/router/Route#canDeactivate\" class=\"code-anchor\">canDeactivate</a>: [CanDeactivateGuard]\n          },\n          {\n            path: '',\n            component: CrisisCenterHomeComponent\n          }\n        ]\n      }\n    ]\n  }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    RouterModule.forChild(crisisCenterRoutes)\n  ],\n  <a href=\"api/core/NgModule#exports\" class=\"code-anchor\">exports</a>: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class CrisisCenterRoutingModule { }\n\n\n</code-example>\n<!--\nNow you have given the user a safeguard against unsaved changes.\n-->\n<p>이제 사용자가 저장하지 않고 놓친 변경사항은 라우팅 가드로 한 번 더 확인하게 할 수 있습니다.</p>\n<a id=\"Resolve\"></a>\n<a id=\"resolve-guard\"></a>\n<!--\n### _Resolve_: pre-fetching component data\n-->\n<h3 id=\"resolve-컴포넌트에-필요한-데이터-미리-가져오기\"><em>Resolve</em>: 컴포넌트에 필요한 데이터 미리 가져오기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#resolve-컴포넌트에-필요한-데이터-미리-가져오기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn the `Hero Detail` and `Crisis Detail`, the app waited until the route was activated to fetch the respective hero or crisis.\n\nThis worked well, but there's a better way.\nIf you were using a real world API, there might be some delay before the data to display is returned from the server.\nYou don't want to display a blank component while waiting for the data.\n-->\n<p><code>Hero Detail</code>과 <code>Crisis Detail</code> 화면은 히어로의 목록이나 위기목록을 서버에서 받아오기 전까지는 라우팅 규칙이 활성화되지 않습니다.</p>\n<p>이렇게 구현해도 문제는 없지만, 더 좋은 방법이 있습니다.\n그리고 실제 운영환경에서는 데이터를 가져올 때 시간이 걸리기 때문에 화면에 데이터가 표시되는 것도 약간 지연됩니다.\n이 때 컴포넌트는 빈 화면으로 표시되는데, 이렇게 동작하는 것을 좀 더 개선하는 방법에 대해 알아봅시다.</p>\n<!--\nIt's preferable to pre-fetch data from the server so it's ready the\nmoment the route is activated. This also allows you to handle errors before routing to the component.\nThere's no point in navigating to a crisis detail for an `id` that doesn't have a record.\nIt'd be better to send the user back to the `Crisis List` that shows only valid crisis centers.\n\nIn summary, you want to delay rendering the routed component until all necessary data have been fetched.\n\nYou need a *resolver*.\n-->\n<p>컴포넌트를 전환하면서 라우팅 규칙이 활성화되기 전에 서버에서 데이터를 먼저 받아올 수 있는데, 이 방법을 사용하면 서버와 통신할 때 발생할 수 있는 에러를 컴포넌트가 전환되기 전에 처리할 수 있습니다.\n그리고 좀 더 사용방법을 고민해 보면 위기 상세정보 화면으로 이동했지만 <code>id</code>에 해당하는 데이터가 없을 때에도 활용할 수 있습니다.\n해당하는 데이터가 없다면 다시 위기목록 화면으로 전환할 수도 있습니다.</p>\n<p>요약하자면, 컴포넌트에 필요한 데이터가 모두 준비될 때까지 라우팅 동작을 지연시킬 수 있습니다.</p>\n<p>이 동작은 <em>리졸버(resolver)</em>로 처리합니다.</p>\n<a id=\"fetch-before-navigating\"></a>\n<!--\n#### Fetch data before navigating\n-->\n<h4 id=\"페이지를-이동하기-전에-데이터-먼저-받아오기\">페이지를 이동하기 전에 데이터 먼저 받아오기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#페이지를-이동하기-전에-데이터-먼저-받아오기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nAt the moment, the `CrisisDetailComponent` retrieves the selected crisis.\nIf the crisis is not found, it navigates back to the crisis list view.\n\nThe experience might be better if all of this were handled first, before the route is activated.\nA `CrisisDetailResolver` service could retrieve a `Crisis` or navigate away if the `Crisis` does not exist\n_before_ activating the route and creating the `CrisisDetailComponent`.\n\nGenerate a `CrisisDetailResolver` service file within the `Crisis Center` feature area.\n-->\n<p>지금까지 작성한 예제에서 <code>CrisisDetailComponent</code>는 이전 화면에서 선택한 위기의 상세정보를 받아옵니다.\n그리고 해당 위기가 존재하지 않으면 위기 목록 화면으로 다시 돌아갑니다.</p>\n<p>하지만 이 과정이 네비게이션을 하기 전에 모두 끝난다면 사용자가 경험하는 UX는 좀 더 나아질 것입니다.\n지금부터 구현할 <code>CrisisDetailResolver</code> 서비스는 <code>CrisisDetailComponent</code>로 페이지를 전환하기 <em>전에</em> 미리 <code>Crisis</code>를 받아오는데, 해당 데이터가 없으면 다른 페이지로 이동하도록 구현할 것입니다.</p>\n<p>다음 명령을 실행해서 <code>Crisis Center</code> 모듈에 <code>CrisisDetailResolver</code> 서비스를 생성합니다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate service crisis-center/crisis-detail-resolver\n</code-example>\n<code-example path=\"router/src/app/crisis-center/crisis-detail-resolver.service.1.ts\" header=\"src/app/crisis-center/crisis-detail-resolver.service.ts (generated)\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class CrisisDetailResolverService {\n\n  constructor() { }\n\n}\n\n\n</code-example>\n<!--\nTake the relevant parts of the crisis retrieval logic in `CrisisDetailComponent.ngOnInit`\nand move them into the `CrisisDetailResolverService`.\nImport the `Crisis` model, `CrisisService`, and the `Router`\nso you can navigate elsewhere if you can't fetch the crisis.\n-->\n<p>그리고 이제부터 라우팅 가드에서 담당할 로직을 <code>CrisisDetailComponent.ngOnInit</code>에서 <code>CrisisDetailResolverService</code>로 옮깁니다.\n이 때 <code>Crisis</code> 모델과 <code>CrisisService</code>, <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 객체가 의존성으로 필요하며, 해당 데이터를 가져오기 못하면 다른 곳으로 이동하게 할 것입니다.</p>\n<!--\nBe explicit. Implement the `Resolve` interface with a type of `Crisis`.\n\nInject the `CrisisService` and `Router` and implement the `resolve()` method.\nThat method could return a `Promise`, an `Observable`, or a synchronous return value.\n-->\n<p>타입은 명확하게 지정합니다. 이 클래스는 <code><a href=\"api/router/Resolve\" class=\"code-anchor\">Resolve</a></code> 인터페이스를 바탕으로 구현하며, 처리하는 객체의 타입은 <code>Crisis</code>입니다.</p>\n<p><code>CrisisService</code>와 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 객체는 <code><a href=\"api/core/ReflectiveInjector#resolve\" class=\"code-anchor\">resolve()</a></code> 메소드에 주입합니다.\n이 메소드는 <code>Promise</code>나 <code>observable</code>, 동기방식으로 결과를 반환할 수 있습니다.</p>\n<!--\nThe `CrisisService.getCrisis` method returns an observable, in order to prevent the route from loading until the data is fetched.\nThe `Router` guards require an observable to `complete`, meaning it has emitted all\nof its values. You use the `take` operator with an argument of `1` to ensure that the\nObservable completes after retrieving the first value from the Observable returned by the\n`getCrisis` method.\n-->\n<p><code>CrisisService.getCrisis</code> 메소드는 옵저버블을 반환하는데, 이 메소드가 옵저버블을 반환하기 전까지 라우팅 규칙은 활성화되지 않습니다.\n그리고 이 라우팅 가드는 옵저버블이 완료되어야 종료됩니다.\n그래서 <code>take</code> 연산자에 <code>1</code> 인자를 전달해서 이 옵저버블이 <code>getCrisis</code> 메소드로부터 데이터를 하나 받으면 옵저버블 자체를 종료하도록 구현했습니다.</p>\n<!--\nIf it doesn't return a valid `Crisis`, return an empty `Observable`, canceling the previous in-flight navigation to the `CrisisDetailComponent` and navigate the user back to the `CrisisListComponent`. The update resolver service looks like this:\n-->\n<p>만약 해당되는 <code>Crisis</code> 객체를 반환하지 못해서 <code>Observable</code>이 빈 값을 반환하게 되면 <code>CrisisDetailComponent</code>로 이동하던 네비게이션 로직이 취소되며 다시 <code>CrisisListComponent</code>로 이동합니다. 리졸버 서비스를 이런 로직으로 구현하면 다음과 같이 구현할 수 있습니다:</p>\n<code-example path=\"router/src/app/crisis-center/crisis-detail-resolver.service.ts\" header=\"src/app/crisis-center/crisis-detail-resolver.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> }             from '@angular/core';\nimport {\n  <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>, <a href=\"api/router/Resolve\" class=\"code-anchor\">Resolve</a>,\n  <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>,\n  <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>\n}                                 from '@angular/router';\nimport { Observable, of, EMPTY }  from 'rxjs';\nimport { mergeMap, take }         from 'rxjs/operators';\n\nimport { CrisisService }  from './crisis.service';\nimport { Crisis } from './crisis';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class CrisisDetailResolverService implements <a href=\"api/router/Resolve\" class=\"code-anchor\">Resolve</a>&#x3C;Crisis> {\n  constructor(private cs: CrisisService, private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {}\n\n  <a href=\"api/router/Route#resolve\" class=\"code-anchor\">resolve</a>(route: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>, <a href=\"api/animations/state\" class=\"code-anchor\">state</a>: <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>): Observable&#x3C;Crisis> | Observable&#x3C;never> {\n    let id = route.paramMap.get('id');\n\n    return this.cs.getCrisis(id).pipe(\n      take(1),\n      mergeMap(crisis => {\n        if (crisis) {\n          return of(crisis);\n        } else { // id에 해당하는 데이터를 찾지 못한 경우\n          this.router.navigate(['/crisis-center']);\n          return EMPTY;\n        }\n      })\n    );\n  }\n}\n\n\n</code-example>\n<!--\nImport this resolver in the `crisis-center-routing.module.ts`\nand add a `resolve` object to the `CrisisDetailComponent` route configuration.\n-->\n<p>이 리졸버를 <code>crisis-center-routing.module.ts</code>에 로드하고 <code>CrisisDetailComponent</code> 라우팅 규칙에 <code><a href=\"api/router/Route#resolve\" class=\"code-anchor\">resolve</a></code> 객체로 추가합니다.</p>\n<!--\n<code-example path=\"router/src/app/crisis-center/crisis-center-routing.module.4.ts\" linenums=\"false\" header=\"src/app/crisis-center/crisis-center-routing.module.ts (resolver)\">\n-->\n<code-example path=\"router/src/app/crisis-center/crisis-center-routing.module.4.ts\" linenums=\"false\" header=\"src/app/crisis-center/crisis-center-routing.module.ts (리졸버)\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }             from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { CrisisCenterHomeComponent } from './crisis-center-home/crisis-center-home.component';\nimport { CrisisListComponent }       from './crisis-list/crisis-list.component';\nimport { CrisisCenterComponent }     from './crisis-center/crisis-center.component';\nimport { CrisisDetailComponent }     from './crisis-detail/crisis-detail.component';\n\nimport { CanDeactivateGuard }             from '../can-deactivate.guard';\nimport { CrisisDetailResolverService }    from './crisis-detail-resolver.service';\n\nconst crisisCenterRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'crisis-center',\n    component: CrisisCenterComponent,\n    children: [\n      {\n        path: '',\n        component: CrisisListComponent,\n        children: [\n          {\n            path: ':id',\n            component: CrisisDetailComponent,\n            <a href=\"api/router/Route#canDeactivate\" class=\"code-anchor\">canDeactivate</a>: [CanDeactivateGuard],\n            <a href=\"api/router/Route#resolve\" class=\"code-anchor\">resolve</a>: {\n              crisis: CrisisDetailResolverService\n            }\n          },\n          {\n            path: '',\n            component: CrisisCenterHomeComponent\n          }\n        ]\n      }\n    ]\n  }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    RouterModule.forChild(crisisCenterRoutes)\n  ],\n  <a href=\"api/core/NgModule#exports\" class=\"code-anchor\">exports</a>: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class CrisisCenterRoutingModule { }\n\n</code-example>\n<!--\nThe `CrisisDetailComponent` should no longer fetch the crisis.\nUpdate the `CrisisDetailComponent` to get the crisis from the  `ActivatedRoute.data.crisis` property instead;\nthat's where you said it should be when you re-configured the route.\nIt will be there when the `CrisisDetailComponent` ask for it.\n-->\n<p><code>CrisisDetailComponent</code>는 이제 위기에 대한 상세정보를 직접 서버에서 가져오지 않습니다.\n<code>CrisisDetailComponent</code>는 <code>ActivatedRoute.data.crisis</code> 프로퍼티로 이 데이터를 참조합니다.\n이 데이터는 위에서 수정한 라우팅 규칙에 의해 전달됩니다.</p>\n<code-example path=\"router/src/app/crisis-center/crisis-detail/crisis-detail.component.ts\" linenums=\"false\" header=\"src/app/crisis-center/crisis-detail/crisis-detail.component.ts (ngOnInit v2)\" region=\"ngOnInit\">\nngOnInit() {\n  this.route.data\n    .subscribe((data: { crisis: Crisis }) => {\n      this.editName = data.crisis.name;\n      this.crisis = data.crisis;\n    });\n}\n\n</code-example>\n<!--\n**Two critical points**\n-->\n<p><strong>2가지 중요한 내용</strong></p>\n<!--\n1. The router's `Resolve` interface is optional.\nThe `CrisisDetailResolverService` doesn't inherit from a base class.\nThe router looks for that method and calls it if found.\n-->\n<ol>\n<li>라우터가 제공하는 <code><a href=\"api/router/Resolve\" class=\"code-anchor\">Resolve</a></code> 인터페이스를 꼭 사용해야 하는 것은 아닙니다.\n그리고 <code>CrisisDetailResolverService</code>는 베이스 클래스를 바탕으로 상속한 것도 아닙니다.\n라우터는 단순하게 관련된 메소드가 있는지 검사하고 실행할 뿐입니다.</li>\n</ol>\n<!--\n1. Rely on the router to call the resolver.\nDon't worry about all the ways that the user  could navigate away.\nThat's the router's job. Write this class and let the router take it from there.\n\nThe relevant *Crisis Center* code for this milestone follows.\n-->\n<ol start=\"2\">\n<li>리졸버를 실행하는 것은 라우터입니다.\n더이상 사용자가 다른 페이지로 마음대로 이동하는 것을 걱정하지 않아도 됩니다.\n구현한 클래스를 라우터에 전달하기만 하면 이 동작을 라우터가 직접 관리합니다.</li>\n</ol>\n<p>지금까지 작성한 <em>위기대응센터</em>의 코드는 다음과 같습니다.</p>\n<code-tabs>\n\n  <code-pane header=\"app.component.html\" path=\"router/src/app/app.component.html\">\n&#x3C;h1 class=\"title\">Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>&#x3C;/h1>\n&#x3C;nav>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/crisis-center\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Crisis Center&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/superheroes\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Heroes&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/admin\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Admin&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/login\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Login&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"[{ outlets: { popup: ['compose'] } }]\">Contact&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n&#x3C;/nav>\n&#x3C;div [@routeAnimation]=\"getAnimationData(routerOutlet)\">\n  &#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a> #routerOutlet=\"outlet\">&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n&#x3C;/div>\n&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a> name=\"popup\">&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n\n</code-pane>\n\n  <code-pane header=\"crisis-center-home.component.html\" path=\"router/src/app/crisis-center/crisis-center-home/crisis-center-home.component.html\">\n&#x3C;p>Welcome to the Crisis Center&#x3C;/p>\n\n</code-pane>\n\n  <code-pane header=\"crisis-center.component.html\" path=\"router/src/app/crisis-center/crisis-center/crisis-center.component.html\">\n&#x3C;h2>CRISIS CENTER&#x3C;/h2>\n&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n\n</code-pane>\n\n  <code-pane header=\"crisis-center-routing.module.ts\" path=\"router/src/app/crisis-center/crisis-center-routing.module.4.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }             from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { CrisisCenterHomeComponent } from './crisis-center-home/crisis-center-home.component';\nimport { CrisisListComponent }       from './crisis-list/crisis-list.component';\nimport { CrisisCenterComponent }     from './crisis-center/crisis-center.component';\nimport { CrisisDetailComponent }     from './crisis-detail/crisis-detail.component';\n\nimport { CanDeactivateGuard }             from '../can-deactivate.guard';\nimport { CrisisDetailResolverService }    from './crisis-detail-resolver.service';\n\nconst crisisCenterRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'crisis-center',\n    component: CrisisCenterComponent,\n    children: [\n      {\n        path: '',\n        component: CrisisListComponent,\n        children: [\n          {\n            path: ':id',\n            component: CrisisDetailComponent,\n            <a href=\"api/router/Route#canDeactivate\" class=\"code-anchor\">canDeactivate</a>: [CanDeactivateGuard],\n            <a href=\"api/router/Route#resolve\" class=\"code-anchor\">resolve</a>: {\n              crisis: CrisisDetailResolverService\n            }\n          },\n          {\n            path: '',\n            component: CrisisCenterHomeComponent\n          }\n        ]\n      }\n    ]\n  }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    RouterModule.forChild(crisisCenterRoutes)\n  ],\n  <a href=\"api/core/NgModule#exports\" class=\"code-anchor\">exports</a>: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class CrisisCenterRoutingModule { }\n\n</code-pane>\n\n  <code-pane header=\"crisis-list.component.html\" path=\"router/src/app/crisis-center/crisis-list/crisis-list.component.html\">\n&#x3C;ul class=\"crises\">\n  &#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let crisis of crises$ | <a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>\"\n    [class.selected]=\"crisis.id === selectedId\">\n    &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"[crisis.id]\">\n      &#x3C;span class=\"badge\">{{ crisis.id }}&#x3C;/span>{{ crisis.name }}\n    &#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n  &#x3C;/li>\n&#x3C;/ul>\n\n&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n\n</code-pane>\n\n  <code-pane header=\"crisis-list.component.ts\" path=\"router/src/app/crisis-center/crisis-list/crisis-list.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> }  from '@angular/core';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> }     from '@angular/router';\n\nimport { CrisisService }  from '../crisis.service';\nimport { Crisis }         from '../crisis';\nimport { Observable }     from 'rxjs';\nimport { switchMap }      from 'rxjs/operators';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-crisis-list',\n  templateUrl: './crisis-list.component.html',\n  <a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a>: ['./crisis-list.component.css']\n})\nexport class CrisisListComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  crises$: Observable&#x3C;Crisis[]>;\n  selectedId: number;\n\n  constructor(\n    private service: CrisisService,\n    private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>\n  ) {}\n\n  ngOnInit() {\n    this.crises$ = this.route.paramMap.pipe(\n      switchMap(params => {\n        this.selectedId = +params.get('id');\n        return this.service.getCrises();\n      })\n    );\n  }\n}\n\n\n</code-pane>\n\n  <code-pane header=\"crisis-detail.component.html\" path=\"router/src/app/crisis-center/crisis-detail/crisis-detail.component.html\">\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"crisis\">\n  &#x3C;h3>\"{{ editName }}\"&#x3C;/h3>\n  &#x3C;div>\n    &#x3C;label>Id: &#x3C;/label>{{ crisis.id }}&#x3C;/div>\n  &#x3C;div>\n    &#x3C;label>Name: &#x3C;/label>\n    &#x3C;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"editName\" placeholder=\"name\"/>\n  &#x3C;/div>\n  &#x3C;p>\n    &#x3C;button (click)=\"save()\">Save&#x3C;/button>\n    &#x3C;button (click)=\"cancel()\">Cancel&#x3C;/button>\n  &#x3C;/p>\n&#x3C;/div>\n\n</code-pane>\n\n  <code-pane header=\"crisis-detail.component.html\" path=\"router/src/app/crisis-center/crisis-detail/crisis-detail.component.html\">\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"crisis\">\n  &#x3C;h3>\"{{ editName }}\"&#x3C;/h3>\n  &#x3C;div>\n    &#x3C;label>Id: &#x3C;/label>{{ crisis.id }}&#x3C;/div>\n  &#x3C;div>\n    &#x3C;label>Name: &#x3C;/label>\n    &#x3C;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"editName\" placeholder=\"name\"/>\n  &#x3C;/div>\n  &#x3C;p>\n    &#x3C;button (click)=\"save()\">Save&#x3C;/button>\n    &#x3C;button (click)=\"cancel()\">Cancel&#x3C;/button>\n  &#x3C;/p>\n&#x3C;/div>\n\n</code-pane>\n\n  <code-pane header=\"crisis-detail-resolver.service.ts\" path=\"router/src/app/crisis-center/crisis-detail-resolver.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> }             from '@angular/core';\nimport {\n  <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>, <a href=\"api/router/Resolve\" class=\"code-anchor\">Resolve</a>,\n  <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>,\n  <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>\n}                                 from '@angular/router';\nimport { Observable, of, EMPTY }  from 'rxjs';\nimport { mergeMap, take }         from 'rxjs/operators';\n\nimport { CrisisService }  from './crisis.service';\nimport { Crisis } from './crisis';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class CrisisDetailResolverService implements <a href=\"api/router/Resolve\" class=\"code-anchor\">Resolve</a>&#x3C;Crisis> {\n  constructor(private cs: CrisisService, private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {}\n\n  <a href=\"api/router/Route#resolve\" class=\"code-anchor\">resolve</a>(route: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>, <a href=\"api/animations/state\" class=\"code-anchor\">state</a>: <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>): Observable&#x3C;Crisis> | Observable&#x3C;never> {\n    let id = route.paramMap.get('id');\n\n    return this.cs.getCrisis(id).pipe(\n      take(1),\n      mergeMap(crisis => {\n        if (crisis) {\n          return of(crisis);\n        } else { // id에 해당하는 데이터를 찾지 못한 경우\n          this.router.navigate(['/crisis-center']);\n          return EMPTY;\n        }\n      })\n    );\n  }\n}\n\n\n</code-pane>\n\n  <code-pane header=\"crisis.service.ts\" path=\"router/src/app/crisis-center/crisis.service.ts\">\nimport { BehaviorSubject } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { MessageService } from '../message.service';\nimport { Crisis } from './crisis';\nimport { CRISES } from './mock-crises';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class CrisisService {\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> nextCrisisId = 100;\n  private crises$: BehaviorSubject&#x3C;Crisis[]> = new BehaviorSubject&#x3C;Crisis[]>(CRISES);\n\n  constructor(private messageService: MessageService) { }\n\n  getCrises() { return this.crises$; }\n\n  getCrisis(id: number | string) {\n    return this.getCrises().pipe(\n      map(crises => crises.find(crisis => crisis.id === +id))\n    );\n  }\n\n}\n\n\n</code-pane>\n\n  <code-pane header=\"dialog.service.ts\" path=\"router/src/app/dialog.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { Observable, of } from 'rxjs';\n\n/**\n * 비동기 모달 팝업 서비스\n * DialogService는 예제를 확인하기 위해 간단하게 구현한 서비스입니다.\n * TODO: window.confirm을 사용하지 않는 방식이 더 좋습니다.\n */\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class DialogService {\n  /**\n   * 어떤 행동을 할지 사용자에게 물어봅니다. `<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>`는 사용자에게 안내할 문구입니다.\n   * `true`를 반환하면 사용자가 확정한 것으로 처리하고, `false`를 반환하면 취소한 것으로 처리합니다.\n   * 결과는 Observable 타입으로 반환합니다.\n   */\n  confirm(<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>?: string): Observable&#x3C;boolean> {\n    const confirmation = window.confirm(<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a> || 'Is it OK?');\n\n    return of(confirmation);\n  };\n}\n\n\n</code-pane>\n\n</code-tabs>\n<p>라우팅 가드</p>\n<code-tabs>\n\n  <code-pane header=\"auth.guard.ts\" path=\"router/src/app/auth/auth.guard.3.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> }       from '@angular/core';\nimport {\n  <a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a>, <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,\n  <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>,\n  <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>,\n  <a href=\"api/router/CanActivateChild\" class=\"code-anchor\">CanActivateChild</a>\n}                           from '@angular/router';\nimport { AuthService }      from './auth.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class AuthGuard implements <a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a>, <a href=\"api/router/CanActivateChild\" class=\"code-anchor\">CanActivateChild</a> {\n  constructor(private authService: AuthService, private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {}\n\n  <a href=\"api/router/Route#canActivate\" class=\"code-anchor\">canActivate</a>(\n    route: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>,\n    <a href=\"api/animations/state\" class=\"code-anchor\">state</a>: <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>): boolean {\n    let url: string = state.url;\n\n    return this.checkLogin(url);\n  }\n\n  <a href=\"api/router/Route#canActivateChild\" class=\"code-anchor\">canActivateChild</a>(\n    route: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>,\n    <a href=\"api/animations/state\" class=\"code-anchor\">state</a>: <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>): boolean {\n    return this.canActivate(route, <a href=\"api/animations/state\" class=\"code-anchor\">state</a>);\n  }\n\n  checkLogin(url: string): boolean {\n    if (this.authService.isLoggedIn) { return true; }\n\n    // 로그인한 후에 이동할 <a href=\"api/core/SecurityContext#URL\" class=\"code-anchor\">URL</a>을 저장해 둡니다.\n    this.authService.redirectUrl = url;\n\n    // 로그인 페이지로 이동합니다.\n    this.router.navigate(['/login']);\n    return false;\n  }\n}\n\n\n</code-pane>\n\n  <code-pane header=\"can-deactivate.guard.ts\" path=\"router/src/app/can-deactivate.guard.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> }    from '@angular/core';\nimport { <a href=\"api/router/CanDeactivate\" class=\"code-anchor\">CanDeactivate</a> } from '@angular/router';\nimport { Observable }    from 'rxjs';\n\nexport interface CanComponentDeactivate {\n <a href=\"api/router/Route#canDeactivate\" class=\"code-anchor\">canDeactivate</a>: () => Observable&#x3C;boolean> | Promise&#x3C;boolean> | boolean;\n}\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class CanDeactivateGuard implements <a href=\"api/router/CanDeactivate\" class=\"code-anchor\">CanDeactivate</a>&#x3C;CanComponentDeactivate> {\n  <a href=\"api/router/Route#canDeactivate\" class=\"code-anchor\">canDeactivate</a>(component: CanComponentDeactivate) {\n    return component.canDeactivate ? component.canDeactivate() : true;\n  }\n}\n\n\n</code-pane>\n\n</code-tabs>\n<a id=\"query-parameters\"></a>\n<a id=\"fragment\"></a>\n<!--\n### Query parameters and fragments\n-->\n<h3 id=\"쿼리-파라미터query-parameters와-프래그먼트fragments-활용하기\">쿼리 파라미터(Query parameters)와 프래그먼트(Fragments) 활용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#쿼리-파라미터query-parameters와-프래그먼트fragments-활용하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn the [route parameters](#optional-route-parameters) example, you only dealt with parameters specific to\nthe route, but what if you wanted optional parameters available to all routes?\nThis is where query parameters come into play.\n-->\n<p><a href=\"guide/router#optional-route-parameters\">라우팅 변수</a> 예제에서 다뤘던 것처럼, 라우팅 규칙에는 변수를 할당할 수 있습니다. 그런데 라우팅 변수가 항상 존재하지 않고 생략될 수도 있는 상황이라면 어떻게 해야 할까요?\n이 섹션에서는 쿼리 파라미터를 사용하는 방법에 대해 알아봅시다.</p>\n<!--\n[Fragments](https://en.wikipedia.org/wiki/Fragment_identifier) refer to certain elements on the page\nidentified with an `id` attribute.\n-->\n<p><a href=\"https://en.wikipedia.org/wiki/Fragment_identifier\">프래그먼트(fragments)</a>은 현재 페이지에 존재하는 엘리먼트 중에서 특정 <code>id</code> 어트리뷰트에 해당하는 엘리먼트를 의미합니다.</p>\n<!--\nUpdate the `AuthGuard` to provide a `session_id` query that will remain after navigating to another route.\n\nAdd an `anchor` element so you can jump to a certain point on the page.\n\nAdd the `NavigationExtras` object to the `router.navigate` method that navigates you to the `/login` route.\n-->\n<p><code>AuthGuard</code>가 다음번에 적용될 라우팅 규칙에 <code>session_id</code>를 제공할 수 있도록 수정해 봅시다.</p>\n<p>이 데이터는 <code><a href=\"api/router/Scroll#anchor\" class=\"code-anchor\">anchor</a></code> 엘리먼트에 적용되어 특정 페이지로 이동하는 용도로 사용할 것입니다.</p>\n<p>이렇게 구현하려면 <code>/login</code> 페이지로 이동하기 위해 <code>router.navigate</code> 메소드를 실행할 때 인자로 <code><a href=\"api/router/NavigationExtras\" class=\"code-anchor\">NavigationExtras</a></code> 객체를 전달하면 됩니다.</p>\n<code-example path=\"router/src/app/auth/auth.guard.4.ts\" linenums=\"false\" header=\"src/app/auth/auth.guard.ts (v3)\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> }       from '@angular/core';\nimport {\n  <a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a>, <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,\n  <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>,\n  <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>,\n  <a href=\"api/router/CanActivateChild\" class=\"code-anchor\">CanActivateChild</a>,\n  <a href=\"api/router/NavigationExtras\" class=\"code-anchor\">NavigationExtras</a>\n}                           from '@angular/router';\nimport { AuthService }      from './auth.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class AuthGuard implements <a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a>, <a href=\"api/router/CanActivateChild\" class=\"code-anchor\">CanActivateChild</a> {\n  constructor(private authService: AuthService, private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {}\n\n  <a href=\"api/router/Route#canActivate\" class=\"code-anchor\">canActivate</a>(route: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>, <a href=\"api/animations/state\" class=\"code-anchor\">state</a>: <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>): boolean {\n    let url: string = state.url;\n\n    return this.checkLogin(url);\n  }\n\n  <a href=\"api/router/Route#canActivateChild\" class=\"code-anchor\">canActivateChild</a>(route: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>, <a href=\"api/animations/state\" class=\"code-anchor\">state</a>: <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>): boolean {\n    return this.canActivate(route, <a href=\"api/animations/state\" class=\"code-anchor\">state</a>);\n  }\n\n  checkLogin(url: string): boolean {\n    if (this.authService.isLoggedIn) { return true; }\n\n    // 리다이렉트할 <a href=\"api/core/SecurityContext#URL\" class=\"code-anchor\">URL</a>을 저장해 둡니다.\n    this.authService.redirectUrl = url;\n\n    // 더미 세션 ID를 생성합니다.\n    let sessionId = 123456789;\n\n    // 전역 쿼리 파라미터와 프래그먼트를 <a href=\"api/router/NavigationExtras\" class=\"code-anchor\">NavigationExtras</a> 객체타입으로 전달합니다.\n    let navigationExtras: <a href=\"api/router/NavigationExtras\" class=\"code-anchor\">NavigationExtras</a> = {\n      queryParams: { 'session_id': sessionId },\n      fragment: '<a href=\"api/router/Scroll#anchor\" class=\"code-anchor\">anchor</a>'\n    };\n\n    // 로그인 페이지로 이동하면서 인자를 함께 전달합니다.\n    this.router.navigate(['/login'], navigationExtras);\n    return false;\n  }\n}\n\n\n</code-example>\n<!--\nYou can also preserve query parameters and fragments across navigations without having to provide them\nagain when navigating. In the `LoginComponent`, you'll add an *object* as the\nsecond argument in the `router.navigate` function\nand provide the `queryParamsHandling` and `preserveFragment` to pass along the current query parameters\nand fragment to the next route.\n-->\n<p>쿼리 파라미터와 프래그먼트는 보통 네비게이션 과정 중에 활용하지만, 네비게이션이 실행된 이후에 사용할 수 있도록 보관해 둘 수도 있습니다.\n<code>LoginComponent</code>에서 <code>router.navigate</code> 함수에 <code><a href=\"api/router/NavigationExtras\" class=\"code-anchor\">NavigationExtras</a></code> 객체를 전달할 때 객체에 <code>queryParamsHandling</code> 프로퍼티와 <code>preserveFragment</code> 프로퍼티를 지정하면 됩니다.\n그러면 다음에 적용될 라우팅 규칙에 이 데이터를 활용할 수 있습니다.</p>\n<code-example path=\"router/src/app/auth/login/login.component.ts\" linenums=\"false\" header=\"src/app/auth/login/login.component.ts (preserve)\" region=\"preserve\">\n// 전역 쿼리 파라미터와 프래그먼트를 <a href=\"api/router/NavigationExtras\" class=\"code-anchor\">NavigationExtras</a> 객체타입으로 전달합니다.\nlet navigationExtras: <a href=\"api/router/NavigationExtras\" class=\"code-anchor\">NavigationExtras</a> = {\n  queryParamsHandling: 'preserve',\n  preserveFragment: true\n};\n\n// 리다이렉트 합니다.\nthis.router.navigate([redirect], navigationExtras);\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\nThe `queryParamsHandling` feature also provides a `merge` option, which will preserve and combine the current query parameters with any provided query parameters\nwhen navigating.\n-->\n<p><code>queryParamsHandling</code>에는 <code>merge</code> 옵션을 사용할 수도 있습니다. 이 옵션을 사용하면 현재 시점에 존재하는 쿼리 파라미터와 새로 추가되는 쿼리 파라미터를 조합합니다.</p>\n</div>\n<!--\nAs you'll be navigating to the *Admin Dashboard* route after logging in, you'll update it to handle the\nquery parameters and fragment.\n-->\n<p>이제 사용자가 로그인한 후에 <em>관리자 대시보드</em>로 이동하면 이 쿼리 파라미터와 프래그먼트를 참조할 수 있습니다.</p>\n<code-example path=\"router/src/app/admin/admin-dashboard/admin-dashboard.component.1.ts\" linenums=\"false\" header=\"src/app/admin/admin-dashboard/admin-dashboard.component.ts (v2)\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> }  from '@angular/core';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> }     from '@angular/router';\nimport { Observable }         from 'rxjs';\nimport { map }                from 'rxjs/operators';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-admin-dashboard',\n  templateUrl: './admin-dashboard.component.html',\n  <a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a>: ['./admin-dashboard.component.css']\n})\nexport class AdminDashboardComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  sessionId: Observable&#x3C;string>;\n  token: Observable&#x3C;string>;\n\n  constructor(private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>) {}\n\n  ngOnInit() {\n    // 세션 ID가 있으면 가져옵니다.\n    this.sessionId = this.route\n      .queryParamMap\n      .pipe(map(params => params.get('session_id') || '<a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">None</a>'));\n\n    // 프래그먼트가 있으면 가져옵니다.\n    this.token = this.route\n      .fragment\n      .pipe(map(fragment => fragment || '<a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">None</a>'));\n  }\n}\n\n\n</code-example>\n<!--\n*Query parameters* and *fragments* are also available through the `ActivatedRoute` service.\nJust like *route parameters*, the query parameters and fragments are provided as an `Observable`.\nThe updated *Crisis Admin* component feeds the `Observable` directly into the template using the `AsyncPipe`.\n-->\n<p><em>쿼리 파라미터</em>와 <em>프래그먼트</em>는 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 서비스를 참조하는 방식으로 사용할 수도 있습니다.\n이 때 일반적인 <em>라우팅 변수</em>와 마찬가지로, 쿼리 파라미터와 프래그먼트도 <code>Observable</code> 타입으로 제공됩니다.\n그리고 컴포넌트에서는 <code>Observable</code> 타입의 데이터를 템플릿에서 <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">AsyncPipe</a></code>로 참조합니다.</p>\n<!--\nNow, you can click on the *Admin* button, which takes you to the *Login*\npage with the provided `queryParamMap` and `fragment`. After you click the login button, notice that\nyou have been redirected to the `Admin Dashboard` page with the query parameters and fragment still intact in the address bar.\n-->\n<p>이제 사용자가 <em>Admin</em> 버튼을 클릭하면 <em>Login</em> 페이지로 이동하면서 <code>queryparamMap</code>과 <code>fragment</code>가 지정됩니다. 그리고 로그인 버튼을 클릭하면 관리자 대시보드 페이지로 리다이렉트 되는데, 이 때 쿼리 파라미터와 프래그먼트가 그대로 보존되는 것을 주소표시줄에서 확인할 수 있습니다.</p>\n<!--\nYou can use these persistent bits of information for things that need to be provided across pages like\nauthentication tokens or session ids.\n-->\n<p>이 방식은 페이지를 전환하는 동안 인증 토큰이나 세션 ID를 그대로 유지해야 할 때 활용할 수 있습니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nThe `query params` and `fragment` can also be preserved using a `RouterLink` with\nthe `queryParamsHandling` and `preserveFragment` bindings respectively.\n-->\n<p><code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>에 <code>queryParamsHandling</code>과 <code>preserveFragment</code>를 입력값으로 바인딩하는 방식으로도 사용할 수 있습니다.</p>\n</div>\n<a id=\"asynchronous-routing\"></a>\n<!--\n## Milestone 6: Asynchronous routing\n-->\n<h2 id=\"6단계-비동기-라우팅\">6단계: 비동기 라우팅<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#6단계-비동기-라우팅\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAs you've worked through the milestones, the application has naturally gotten larger.\nAs you continue to build out feature areas, the overall application size will continue to grow.\nAt some point you'll reach a tipping point where the application takes a long time to load.\n-->\n<p>지금까지 진행하는 동안 애플리케이션은 점점 복잡해졌습니다.\n게다가 앞으로 새로운 기능을 추가할 때마다 애플리케이션의 용량도 점점 커질 것입니다.\n그러면 언젠가 애플리케이션이 시작되는 것이 느리다고 느껴지는 때가 찾아옵니다.</p>\n<!--\nHow do you combat this problem?  With asynchronous routing, which loads feature modules _lazily_, on request.\nLazy loading has multiple benefits.\n\n* You can load feature areas only when requested by the user.\n* You can speed up load time for users that only visit certain areas of the application.\n* You can continue expanding lazy loaded feature areas without increasing the size of the initial load bundle.\n-->\n<p>이 문제는 어떻게 해결할 수 있을까요? 비동기 라우팅을 활용하면 기능 모듈이 필요할 때까지 <em>기다렸다가</em> 필요할 때 비동기로 로드할 수 있습니다.</p>\n<ul>\n<li>사용자에게 필요한 기능 모듈만 로드할 수 있습니다.</li>\n<li>특정 페이지에 직접 접근한다면 애플리케이션이 실행되는 속도를 빠르게 할 수 있습니다.</li>\n<li>애플리케이션 실행에 꼭 필요한 용량은 그대로 둔 채로 기능 모듈을 붙이는 방식으로 확장할 수 있습니다.</li>\n</ul>\n<!--\nYou're already part of the way there.\nBy organizing the application into modules&mdash;`AppModule`,\n`HeroesModule`, `AdminModule` and `CrisisCenterModule`&mdash;you\nhave natural candidates for lazy loading.\n\nSome modules, like `AppModule`, must be loaded from the start.\nBut others can and should be lazy loaded.\nThe `AdminModule`, for example, is needed by a few authorized users, so\nyou should only load it when requested by the right people.\n-->\n<p>비동기 라우팅은 이미 적용할 준비가 되어 있습니다.\n애플리케이션을 <code>AppModule</code>, <code>HeroesModule</code>, <code>AdminModule</code>, <code>CrisisCenterModule</code>과 같은 모듈 단위로 구축하는 과정은 모듈을 지연로딩할 수 있는 준비를 한 것이기도 합니다.</p>\n<p><code>AppModule</code>은 애플리케이션이 실행되기 전에 반드시 로드되어야 합니다.\n하지만 다른 모듈은 모두 지연로딩할 수 있습니다.\n<code>AdminModule</code>을 생각해 보면, 이 모듈은 아주 일부의 사용자만 사용하기 때문에 해당 기능이 필요한 사용자만 이 모듈을 로드하는 것이 좋습니다.</p>\n<a id=\"lazy-loading-route-config\"></a>\n<!--\n### Lazy Loading route configuration\n-->\n<h4 id=\"지연로딩-라우팅-규칙-설정\">지연로딩 라우팅 규칙 설정<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#지연로딩-라우팅-규칙-설정\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nChange the `admin` **path** in the `admin-routing.module.ts` from `'admin'` to an empty string, `''`, the _empty path_.\n-->\n<p><code>admin-routing.module.ts</code> 파일에서 <code>admin</code>에 해당하는 라우팅 규칙의 주소를 <code>admin</code>이 아니라 <code>''</code> 빈 문자열로 변경합니다.</p>\n<!--\nThe `Router` supports  *empty path* routes;\nuse them to group routes together without adding any additional path segments to the URL.\nUsers will still visit `/admin` and the `AdminComponent` still serves as the *Routing Component* containing child routes.\n-->\n<p><code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>는 <em>빈 주소</em> 를 사용하는 라우팅 규칙을 지원합니다. 이 방식을 사용하면 현재 URL을 변경하지 않으면서 여러 라우팅 경로를 그룹으로 묶을 수 있습니다.\n이 기능을 사용하는 사용자는 여전히 <code>/admin</code>으로 접속할 것이며 자식 라우팅 규칙에 해당하는 <em>라우팅 컴포넌트</em> 도 여전히 <code>AdminComponent</code>로 제공됩니다.</p>\n<!--\nOpen the `AppRoutingModule` and add a new `admin` route to its `appRoutes` array.\n\nGive it a `loadChildren` property instead of a `children` property, set to the address of the `AdminModule`.\nThe address is the `AdminModule` file location (relative to the app root),\nfollowed by a `#` separator, followed by the name of the exported module class, `AdminModule`.\n-->\n<p><code>AppRoutingModule</code>을 열고 <code>appRoutes</code> 배열에 새로운 <code>admin</code> 라우팅을 추가합니다.</p>\n<p>그리고 <code>children</code> 프로퍼티 대신 <code><a href=\"api/router/Route#loadChildren\" class=\"code-anchor\">loadChildren</a></code> 프로퍼티를 사용해서 <code>AdminModule</code>의 위치를 지정합니다.\n이 때 지정하는 <code>AdminModule</code>의 위치는 애플리케이션 최상위 폴더부터 시작되는 상대주소입니다. 파일의 경로까지 지정했으면 <code>#</code> 구분자를 붙이고 지연로딩 하려는 모듈의 이름을 지정합니다.</p>\n<!--\n<code-example path=\"router/src/app/app-routing.module.5.ts\" region=\"admin-1\" header=\"app-routing.module.ts (load children)\">\n-->\n<code-example path=\"router/src/app/app-routing.module.5.ts\" region=\"admin-1\" header=\"app-routing.module.ts (loadChildren)\">\n{\n  path: 'admin',\n  <a href=\"api/router/Route#loadChildren\" class=\"code-anchor\">loadChildren</a>: './admin/admin.module#AdminModule',\n},\n\n</code-example>\n<div class=\"alert is-important\">\n<!--\n*Note*: When using absolute paths, the `NgModule` file location must begin with `src/app` in order to resolve correctly. For custom [path mapping with absolute paths](https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping), the `baseUrl` and `paths` properties in the project `tsconfig.json` must be configured.\n-->\n<p><em>참고</em>: 만약 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>의 경로를 절대주소로 참조하려면 이 주소는 <code>src/app</code>로 시작해야 합니다.\n이 주소는 TypeScript에서 <a href=\"https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping\">절대 주소를 맵핑</a>하는 설정의 영향을 받기 때문에 <code>tsconfig.json</code> 파일의 <code>baseUrl</code>과 <code>paths</code> 프로퍼티를 설정해야 합니다.</p>\n</div>\n<!--\nWhen the router navigates to this route, it uses the `loadChildren` string to dynamically load the `AdminModule`.\nThen it adds the `AdminModule` routes to its current route configuration.\nFinally, it loads the requested route to the destination admin component.\n\nThe lazy loading and re-configuration happen just once, when the route is _first_ requested;\nthe module and routes are available immediately for subsequent requests.\n-->\n<p>이제 라우터가 이 라우팅 규칙을 만나면 <code><a href=\"api/router/Route#loadChildren\" class=\"code-anchor\">loadChildren</a></code> 문자열에 설정된 값으로 <code>AdminModule</code>을 로드합니다.\n그리고 <code>AdminModule</code>에 정의된 라우팅 규칙은 애플리케이션 전체 라우팅 규칙과 조합됩니다.\n결국 기존에 사용하던 대로 <code>admin</code> 주소로 접근하면 <code>AdminComponent</code>가 화면에 표시됩니다.</p>\n<p>모듈 지연로딩은 이 라우팅 규칙이 <em>처음</em> 요청받았을 때 한 번만 실행됩니다.\n이후에 이 주소로 라우팅하면 이미 로드된 모듈과 조합된 라우팅 규칙을 그대로 사용합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nAngular provides a built-in module loader that supports SystemJS to load modules asynchronously. If you were\nusing another bundling tool, such as Webpack, you would use the Webpack mechanism for asynchronously loading modules.\n-->\n<p>Angular는 모듈을 지연로딩 할 때 SystemJS 모듈 로더를 사용합니다.\nWebpack과 같은 다른 번들링 툴을 직접 사용한다면 Webpack에서 제공하는 비동기 모듈 로딩 메커니즘을 사용해야 합니다.</p>\n</div>\n<!--\nTake the final step and detach the admin feature set from the main application.\nThe root `AppModule` must neither load nor reference the `AdminModule` or its files.\n\nIn `app.module.ts`, remove the `AdminModule` import statement from the top of the file\nand remove the `AdminModule` from the NgModule's `imports` array.\n-->\n<p>마지막 단계는 관리자 기능모듈을 애플리케이션의 다른 모듈과 분리하는 것입니다.\n<code>AdminModule</code>을 지연로딩하려면 <code>AppModule</code>은 <code>AdminModule</code>이나 이 모듈 내부의 파일들을 직접 로드하거나 참조하면 안됩니다.</p>\n<p><code>app.module.ts</code> 파일 제일 위쪽에서 <code>AdminModule</code>을 로드하는 구문을 제거하고, <code>AppModule</code>의 <code><a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a></code> 배열에서도 <code>AdminModule</code>을 제거합니다.</p>\n<a id=\"can-load-guard\"></a>\n<!--\n### _CanLoad_ Guard: guarding unauthorized loading of feature modules\n-->\n<h3 id=\"canload-가드-로그인하지-않은-사용자의-모듈-로딩-방지하기\"><em>CanLoad</em> 가드: 로그인하지 않은 사용자의 모듈 로딩 방지하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#canload-가드-로그인하지-않은-사용자의-모듈-로딩-방지하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou're already protecting the `AdminModule` with a `CanActivate` guard that prevents unauthorized users from\naccessing the admin feature area.\nIt redirects to the  login page if the user is not authorized.\n\nBut the router is still loading the `AdminModule` even if the user can't visit any of its components.\nIdeally, you'd only load the `AdminModule` if the user is logged in.\n-->\n<p>지금도 <code>AdminModule</code>은 <code><a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a></code> 라우팅 가드에 의해 보호받고 있기 때문에 로그인하지 않은 사용자가 이 모듈에 접근하는 것은 제한할 수 있습니다.\n로그인하지 않은 사용자가 이 모듈에 접근하면 로그인 페이지로 리다이렉트 됩니다.</p>\n<p>하지만 이 경우에 사용자가 <code>AdminModule</code>의 컴포넌트 중 아무것도 화면에서 확인하지 못했지만 <code>AdminModule</code> 자체는 로딩이 완료됩니다.\n이 모듈은 사용자가 로그인한 후에 실제로 활용할 때만 로딩하는 것이 이상적입니다.</p>\n<!--\nAdd a **`CanLoad`** guard that only loads the `AdminModule` once the user is logged in _and_ attempts to access the admin feature area.\n\nThe existing `AuthGuard` already has the essential logic in\nits `checkLogin()` method to support the `CanLoad` guard.\n\nOpen `auth.guard.ts`.\nImport the `CanLoad` interface from `@angular/router`.\nAdd it to the `AuthGuard` class's `implements` list.\nThen implement `canLoad()` as follows:\n-->\n<p><strong><code><a href=\"api/router/CanLoad\" class=\"code-anchor\">CanLoad</a></code></strong> 라우팅 가드는 로그인 한 사용자가 <code>AdminModule</code> 모듈에 해당하는 주소에 접근했을 때만 <code>AdminModule</code>을 지연로딩하도록 제어할 때 사용합니다.</p>\n<p>이전에 만든 <code>AuthGuard</code>에 있는 <code>checkLogin()</code> 메소드는 <code><a href=\"api/router/CanLoad\" class=\"code-anchor\">CanLoad</a></code> 라우팅 가드에서도 그대로 활용할 수 있습니다.</p>\n<p>구현방법은 이렇습니다.\n먼저 <code>auth.guard.ts</code> 파일을 엽니다.\n그리고 <code>@angular/router</code> 패키지에서 <code><a href=\"api/router/CanLoad\" class=\"code-anchor\">CanLoad</a></code> 인터페이스를 로드합니다.\n<code>AuthGuard</code> 클래스의 <code>implements</code> 목록에 이 인터페이스를 추가합니다.\n<code><a href=\"api/router/Route#canLoad\" class=\"code-anchor\">canLoad</a>()</code> 메소드는 다음과 같이 구현합니다:</p>\n<!--\n<code-example path=\"router/src/app/auth/auth.guard.ts\" linenums=\"false\" header=\"src/app/auth/auth.guard.ts (CanLoad guard)\" region=\"canLoad\">\n-->\n<code-example path=\"router/src/app/auth/auth.guard.ts\" linenums=\"false\" header=\"src/app/auth/auth.guard.ts (CanLoad 라우팅 가드)\" region=\"canLoad\">\n<a href=\"api/router/Route#canLoad\" class=\"code-anchor\">canLoad</a>(route: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>): boolean {\n  let url = `/${route.path}`;\n\n  return this.checkLogin(url);\n}\n\n</code-example>\n<!--\nThe router sets the `canLoad()` method's `route` parameter to the intended destination URL.\nThe `checkLogin()` method redirects to that URL once the user has logged in.\n\nNow import the `AuthGuard` into the `AppRoutingModule` and add the `AuthGuard` to the `canLoad`\narray property for the `admin` route.\nThe completed admin route looks like this:\n-->\n<p> <code><a href=\"api/router/Route#canLoad\" class=\"code-anchor\">canLoad</a>()</code> 메소드는 이동하려는 URL을 <code>route</code> 인자로 받습니다.\n그리고 <code>checkLogin()</code> 메소드가 실행되는데, 사용자가 로그인했다면 지금 이동하려던 주소로 그대로 리다이렉트 합니다.</p>\n<p> 이제 <code>AppRoutingModule</code>에 <code>AuthGuard</code>를 로드하고 이 라우팅 가드를 <code>admin</code> 라우팅 규칙의 <code><a href=\"api/router/Route#canLoad\" class=\"code-anchor\">canLoad</a></code> 배열 프로퍼티에 다음과 같이 추가합니다.</p>\n<!--\n<code-example path=\"router/src/app/app-routing.module.5.ts\" region=\"admin\" header=\"app-routing.module.ts (lazy admin route)\">\n-->\n<code-example path=\"router/src/app/app-routing.module.5.ts\" region=\"admin\" header=\"app-routing.module.ts (지연로딩하는 admin 라우팅 규칙)\">\n{\n  path: 'admin',\n  <a href=\"api/router/Route#loadChildren\" class=\"code-anchor\">loadChildren</a>: './admin/admin.module#AdminModule',\n  <a href=\"api/router/Route#canLoad\" class=\"code-anchor\">canLoad</a>: [AuthGuard]\n},\n\n</code-example>\n<a id=\"preloading\"></a>\n<!--\n### Preloading: background loading of feature areas\n-->\n<h3 id=\"사전로딩preloading-기능-모듈을-백그라운드에서-로딩하기\">사전로딩(Preloading): 기능 모듈을 백그라운드에서 로딩하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#사전로딩preloading-기능-모듈을-백그라운드에서-로딩하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou've learned how to load modules on-demand.\nYou can also load modules asynchronously with _preloading_.\n\nThis may seem like what the app has been doing all along. Not quite.\nThe `AppModule` is loaded when the application starts; that's _eager_ loading.\nNow the `AdminModule` loads only when the user clicks on a link; that's _lazy_ loading.\n-->\n<p>지금까지 모듈을 필요할 때만 로딩하는 방법에 대해 알아봤습니다.\n그런데 모듈은 필요한 경우를 대비해서 <em>미리</em> 비동기로 로딩할 수도 있습니다.</p>\n<p>이제까지 만들었던 앱을 생각해봅시다.\n<code>AppModule</code>은 애플리케이션이 시작될 때 <em>즉시</em> 로딩됩니다.\n그리고 <code>AdminModule</code>은 사용자가 링크를 클릭 했을 때 <em>지연</em> 로딩됩니다.</p>\n<!--\n_Preloading_ is something in between.\nConsider the _Crisis Center_.\nIt isn't the first view that a user sees.\nBy default, the _Heroes_ are the first view.\nFor the smallest initial payload and fastest launch time,\nyou should eagerly load the `AppModule` and the `HeroesModule`.\n-->\n<p><em>사전로딩(preloading)</em> 은 두 방식의 중간 정도 되는 개념입니다.\n<em>위기대응센터</em> 를 생각해 봅시다.\n이 모듈은 사용자가 처음 애플리케이션을 실행했을 때 보는 화면이 아닙니다.\n기본적으로 이 애플리케이션의 첫 화면은 <em>히어로</em> 화면입니다.\n그래서 애플리케이션의 실행 속도를 빠르게 하려면 <code>AppModule</code>과 <code>HeroesModule</code>은 즉시 로딩하는 것이 좋습니다.</p>\n<!--\nYou could lazy load the _Crisis Center_.\nBut you're almost certain that the user will visit the _Crisis Center_ within minutes of launching the app.\nIdeally, the app would launch with just the `AppModule` and the `HeroesModule` loaded\nand then, almost immediately, load the `CrisisCenterModule` in the background.\nBy the time the user navigates to the _Crisis Center_, its module will have been loaded and ready to go.\n\nThat's _preloading_.\n-->\n<p><em>위기대응센터</em> 는 물론 지연로딩 할 수도 있습니다.\n하지만 대부분의 사용자가 <em>위기대응센터</em> 에 접속한다고 합시다.\n이 경우에 이상적인 경우를 생각해보면, 애플리케이션이 실행될 때는 <code>AppModule</code>과 <code>HeroesModule</code>을 즉시 로드한 채로 실행하지만, 그 이후에 바로 <code>CrisisCenterModule</code>을 백그라운드에서 로드하는 것이 좋을 것입니다.\n이렇게 구현하면 사용자가 <em>위기대응센터</em> 로 이동했을 때 이미 로드된 모듈을 바로 사용할 수 있습니다.</p>\n<p>이것이 <em>사전로딩</em> 입니다.</p>\n<a id=\"how-preloading\"></a>\n<!--\n#### How preloading works\n-->\n<h4 id=\"사전로딩이-동작하는-방식\">사전로딩이 동작하는 방식<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#사전로딩이-동작하는-방식\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nAfter each _successful_ navigation, the router looks in its configuration for an unloaded module that it can preload.\nWhether it preloads a module, and which modules it preloads, depends upon the *preload strategy*.\n-->\n<p>네비게이션이 <em>성공적으로</em> 실행되고 나면 라우터는 라우터 설정에서 사전로딩할 수 있는 모듈 중에 로드되지 않은 것을 찾습니다.\n이 때 모듈을 사전로딩 할지 판단하는데, 이 동작은 <em>사전로딩 정책(preload strategy)</em>에 따라 달라집니다.</p>\n<!--\nThe `Router` offers two preloading strategies out of the box:\n\n* No preloading at all which is the default. Lazy loaded feature areas are still loaded on demand.\n* Preloading of all lazy loaded feature areas.\n-->\n<p><code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>는 두 가지 방식의 사전로딩 정책을 제공합니다:</p>\n<ul>\n<li>기본값은 모듈을 사전로딩하지 않는 것입니다. 지연로딩은 원래 의도대로 지연 로딩 됩니다.</li>\n<li>지연로딩되는 모든 모듈을 사전로딩합니다.</li>\n</ul>\n<!--\nOut of the box, the router either never preloads, or preloads every lazy load module.\nThe `Router` also supports [custom preloading strategies](#custom-preloading) for\nfine control over which modules to preload and when.\n\nIn this next section, you'll update the `CrisisCenterModule` to load lazily\nby default and use the `PreloadAllModules` strategy\nto load it (and _all other_ lazy loaded modules) as soon as possible.\n-->\n<p>라우터는 모든 모듈을 사전로딩하지 않거나, 모든 모듈을 사전로딩합니다.\n그리고 특정 모듈만 사전로딩하려면 <a href=\"guide/router#custom-preloading\">커스텀 사전로딩 정책</a>을 정의해서 사용할 수도 있습니다.</p>\n<p>이제부터 <code>CrisisCenterModule</code>은 지금과 마찬가지로 지연로딩하고, 다른 모듈은 모두 <code><a href=\"api/router/PreloadAllModules\" class=\"code-anchor\">PreloadAllModules</a></code> 정책을 사용해서 사전로딩하는 방법에 대해 알아봅시다.</p>\n<a id=\"lazy-load-crisis-center\"></a>\n<!--\n#### Lazy load the _crisis center_\n-->\n<h4 id=\"위기대응센터-지연로딩하기\"><em>위기대응센터</em> 지연로딩하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#위기대응센터-지연로딩하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nUpdate the route configuration to lazy load the `CrisisCenterModule`.\nTake the same steps you used to configure `AdminModule` for lazy load.\n\n1. Change the `crisis-center` path in the `CrisisCenterRoutingModule` to an empty string.\n\n1. Add a `crisis-center` route to the `AppRoutingModule`.\n\n1. Set the `loadChildren` string to load the `CrisisCenterModule`.\n\n1. Remove all mention of the `CrisisCenterModule` from `app.module.ts`.\n\n\nHere are the updated modules _before enabling preload_:\n-->\n<p><code>CrisisCenterModule</code>을 지연로딩할 수 있도록 라우팅 규칙을 수정합니다.\n이 과정은 <code>AdminModule</code>에 지연로딩을 적용했던 과정과 같습니다.</p>\n<ol>\n<li>\n<p><code>CrisisCenterRoutingModule</code>에서 <code>crisis-center</code>에 해당되는 주소를 빈 문자열로 수정합니다.</p>\n</li>\n<li>\n<p><code>crisis-center</code> 라우팅 규칙을 <code>AppRoutingModule</code>에 추가합니다.</p>\n</li>\n<li>\n<p><code><a href=\"api/router/Route#loadChildren\" class=\"code-anchor\">loadChildren</a></code>을 사용해서 <code>CrisisCenterModule</code>을 지연로딩 합니다.</p>\n</li>\n<li>\n<p><code>app.module.ts</code> 파일에서 <code>CrisisCenterModule</code>과 관련된 코드를 모두 제거합니다.</p>\n</li>\n</ol>\n<p>그러면 애플리케이션 코드는 다음과 같이 변경될 것입니다:</p>\n<code-tabs>\n\n  <code-pane header=\"app.module.ts\" path=\"router/src/app/app.module.ts\" region=\"preload\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }       from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> }  from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> }    from '@angular/forms';\nimport { <a href=\"api/platform-browser/animations/BrowserAnimationsModule\" class=\"code-anchor\">BrowserAnimationsModule</a> } from '@angular/platform-browser/animations';\n\nimport { <a href=\"api/router/Router\" class=\"code-anchor\">Router</a> } from '@angular/router';\n\nimport { AppComponent }            from './app.component';\nimport { PageNotFoundComponent }   from './page-not-found/page-not-found.component';\nimport { ComposeMessageComponent } from './compose-message/compose-message.component';\n\nimport { AppRoutingModule }        from './app-routing.module';\nimport { HeroesModule }            from './heroes/heroes.module';\nimport { AuthModule }              from './auth/auth.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/platform-browser/animations/BrowserAnimationsModule\" class=\"code-anchor\">BrowserAnimationsModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    HeroesModule,\n    AuthModule,\n    AppRoutingModule,\n  ],\n  <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [\n    AppComponent,\n    ComposeMessageComponent,\n    PageNotFoundComponent\n  ],\n  <a href=\"api/core/NgModule#bootstrap\" class=\"code-anchor\">bootstrap</a>: [ AppComponent ]\n})\nexport class AppModule {\n}\n\n</code-pane>\n\n  <code-pane header=\"app-routing.module.ts\" path=\"router/src/app/app-routing.module.6.ts\" region=\"preload-v1\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }     from '@angular/core';\nimport {\n  <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a>,\n} from '@angular/router';\n\nimport { ComposeMessageComponent } from './compose-message/compose-message.component';\nimport { PageNotFoundComponent }   from './page-not-found/page-not-found.component';\n\nimport { AuthGuard }               from './auth/auth.guard';\n\nconst appRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'compose',\n    component: ComposeMessageComponent,\n    outlet: 'popup'\n  },\n  {\n    path: 'admin',\n    <a href=\"api/router/Route#loadChildren\" class=\"code-anchor\">loadChildren</a>: './admin/admin.module#AdminModule',\n    <a href=\"api/router/Route#canLoad\" class=\"code-anchor\">canLoad</a>: [AuthGuard]\n  },\n  {\n    path: 'crisis-center',\n    <a href=\"api/router/Route#loadChildren\" class=\"code-anchor\">loadChildren</a>: './crisis-center/crisis-center.module#CrisisCenterModule'\n  },\n  { path: '',   <a href=\"api/router/Route#redirectTo\" class=\"code-anchor\">redirectTo</a>: '/heroes', <a href=\"api/router/Route#pathMatch\" class=\"code-anchor\">pathMatch</a>: '<a href=\"api/core/Version#full\" class=\"code-anchor\">full</a>' },\n  { path: '**', component: PageNotFoundComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    RouterModule.forRoot(\n      appRoutes,\n    )\n  ],\n  <a href=\"api/core/NgModule#exports\" class=\"code-anchor\">exports</a>: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class AppRoutingModule {}\n\n\n</code-pane>\n\n  <code-pane header=\"crisis-center-routing.module.ts\" path=\"router/src/app/crisis-center/crisis-center-routing.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }             from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { CrisisCenterHomeComponent } from './crisis-center-home/crisis-center-home.component';\nimport { CrisisListComponent }       from './crisis-list/crisis-list.component';\nimport { CrisisCenterComponent }     from './crisis-center/crisis-center.component';\nimport { CrisisDetailComponent }     from './crisis-detail/crisis-detail.component';\n\nimport { CanDeactivateGuard }             from '../can-deactivate.guard';\nimport { CrisisDetailResolverService }    from './crisis-detail-resolver.service';\n\nconst crisisCenterRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: '',\n    component: CrisisCenterComponent,\n    children: [\n      {\n        path: '',\n        component: CrisisListComponent,\n        children: [\n          {\n            path: ':id',\n            component: CrisisDetailComponent,\n            <a href=\"api/router/Route#canDeactivate\" class=\"code-anchor\">canDeactivate</a>: [CanDeactivateGuard],\n            <a href=\"api/router/Route#resolve\" class=\"code-anchor\">resolve</a>: {\n              crisis: CrisisDetailResolverService\n            }\n          },\n          {\n            path: '',\n            component: CrisisCenterHomeComponent\n          }\n        ]\n      }\n    ]\n  }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    RouterModule.forChild(crisisCenterRoutes)\n  ],\n  <a href=\"api/core/NgModule#exports\" class=\"code-anchor\">exports</a>: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class CrisisCenterRoutingModule { }\n\n</code-pane>\n\n</code-tabs>\n<!--\nYou could try this now and confirm that the  `CrisisCenterModule` loads after you click the \"Crisis Center\" button.\n\nTo enable preloading of all lazy loaded modules, import the `PreloadAllModules` token from the Angular router package.\n\nThe second argument in the `RouterModule.forRoot` method takes an object for additional configuration options.\nThe `preloadingStrategy` is one of those options.\nAdd the `PreloadAllModules` token to the `forRoot` call:\n-->\n<p>이렇게 구현한 후에 사용자가 \"Crisis Center\" 버튼을 클릭하면 <code>CrisisCenterModule</code>이 로드되는 것을 확인할 수 있습니다.</p>\n<p>그리고 지연로딩되는 모듈을 모두 사전로딩하려면 라우터 패키지에서 <code><a href=\"api/router/PreloadAllModules\" class=\"code-anchor\">PreloadAllModules</a></code>를 로드해서 적용하면 됩니다.</p>\n<p><code>RouterModule.forRoot</code> 메소드는 두 번째 인자로 라우터 설정 옵션을 받을 수 있는데, <code><a href=\"api/router/ExtraOptions#preloadingStrategy\" class=\"code-anchor\">preloadingStrategy</a></code>가 여기에 적용할 수 있는 옵션  중 하나입니다.\n<code>forRoot</code> 메소드에 다음과 같이 <code><a href=\"api/router/PreloadAllModules\" class=\"code-anchor\">PreloadAllModules</a></code> 토큰을 추가합니다.</p>\n<!--\n<code-example path=\"router/src/app/app-routing.module.6.ts\" linenums=\"false\" header=\"src/app/app-routing.module.ts (preload all)\" region=\"forRoot\">\n-->\n<code-example path=\"router/src/app/app-routing.module.6.ts\" linenums=\"false\" header=\"src/app/app-routing.module.ts (모두 사전로딩)\" region=\"forRoot\">\nRouterModule.forRoot(\n  appRoutes,\n  {\n    <a href=\"api/router/ExtraOptions#enableTracing\" class=\"code-anchor\">enableTracing</a>: true, // &#x3C;-- 디버그 활성화\n    <a href=\"api/router/ExtraOptions#preloadingStrategy\" class=\"code-anchor\">preloadingStrategy</a>: <a href=\"api/router/PreloadAllModules\" class=\"code-anchor\">PreloadAllModules</a>\n  }\n)\n\n</code-example>\n<!--\nThis tells the `Router` preloader to immediately load _all_ lazy loaded routes (routes with a `loadChildren` property).\n\nWhen you visit `http://localhost:4200`, the `/heroes` route loads immediately upon launch\nand the router starts loading the `CrisisCenterModule` right after the `HeroesModule` loads.\n\nSurprisingly, the `AdminModule` does _not_ preload. Something is blocking it.\n-->\n<p>이렇게 구현하면 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>는 지연로딩이 적용된 라우팅 규칙(<code><a href=\"api/router/Route#loadChildren\" class=\"code-anchor\">loadChildren</a></code> 프로퍼티가 있는 라우팅 규칙)을 <em>모두</em> 사전로딩합니다.</p>\n<p>그래서 <code><a href=\"api/common/http\" class=\"code-anchor\">http</a>://localhost:4200</code>에 접속하면 <code>/heroes</code> 주소로 자동으로 이동하는데, 이 때 <code>HeroesModule</code>이 로드된 직후에 <code>CrisisCenterModule</code>이 바로 로딩되기 시작합니다.</p>\n<p>그리고 <code>AdminModule</code>은 사전로딩되지 <em>않습니다</em>. 이 모듈은 라우팅 가드로 보호되기 때문입니다.</p>\n<a id=\"preload-canload\"></a>\n<!--\n#### CanLoad blocks preload\n-->\n<h4 id=\"canload는-사전로딩을-막습니다\">CanLoad는 사전로딩을 막습니다.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#canload는-사전로딩을-막습니다\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe `PreloadAllModules` strategy does not load feature areas protected by a [CanLoad](#can-load-guard) guard.\nThis is by design.\n-->\n<p><code><a href=\"api/router/PreloadAllModules\" class=\"code-anchor\">PreloadAllModules</a></code> 정책을 사용해도 <a href=\"guide/router#can-load-guard\">CanLoad</a>로 보호되는 기능 모듈은 로드되지 않습니다.\n이것은 Angular가 의도한 디자인입니다.</p>\n<!--\nYou added a `CanLoad` guard to the route in the `AdminModule` a few steps back\nto block loading of that module until the user is authorized.\nThat `CanLoad` guard takes precedence over the preload strategy.\n-->\n<p>이전 단계에서 <code>AdminModule</code>에 해당하는 라우팅 규칙에 <code><a href=\"api/router/CanLoad\" class=\"code-anchor\">CanLoad</a></code> 라우팅 가드를 적용했습니다. 이 라우팅 가드는 허용되지 않은 사용자가 모듈을 로드하는 것을 방지합니다.\n그래서 <code><a href=\"api/router/CanLoad\" class=\"code-anchor\">CanLoad</a></code> 가드는 사전로딩 정책보다 우선 순위가 높습니다.</p>\n<!--\nIf you want to preload a module _and_ guard against unauthorized access,\ndrop the `canLoad()` guard method and rely on the [canActivate()](#can-activate-guard) guard alone.\n-->\n<p>만약 모듈을 사전로딩하면서 허용되지 않은 사용자가 모듈에 접근하는 것 동시에 제한하려고 한다면 <code><a href=\"api/router/Route#canLoad\" class=\"code-anchor\">canLoad</a>()</code> 가드를 제거하고 <a href=\"guide/router#can-activate-guard\">canActivate()</a>만 단독으로 사용해야 합니다.</p>\n<a id=\"custom-preloading\"></a>\n<!--\n### Custom Preloading Strategy\n-->\n<h3 id=\"커스텀-사전로딩-정책\">커스텀 사전로딩 정책<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#커스텀-사전로딩-정책\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nPreloading every lazy loaded modules works well in many situations,\nbut it isn't always the right choice, especially on mobile devices and over low bandwidth connections.\nYou may choose to preload only certain feature modules, based on user metrics and other business and technical factors.\n-->\n<p>지연로딩되는 모듈을 사전로딩하는 것은 대부분의 경우에 문제없이 활용할 수 있지만 이 방식이 항상 최선인 것은 아닙니다. 대역폭이 상대적으로 작은 모바일 장치의 경우가 특히 그렇습니다.\n이런 경우에는 개발자의 의도나 애플리케이션의 필요에 따라, 기술적인 이슈를 고려하며 특정 기능모듈만 선택적으로 사전로딩하는 것이 나을 수 있습니다.</p>\n<!--\nYou can control what and how the router preloads with a custom preloading strategy.\n\nIn this section, you'll add a custom strategy that _only_ preloads routes whose `data.preload` flag is set to `true`.\nRecall that you can add anything to the `data` property of a route.\n\nSet the `data.preload` flag in the `crisis-center` route in the `AppRoutingModule`.\n-->\n<p>커스텀 사전로딩 정책을 작성하면 라우터의 사전로딩 동작을 더 구체적으로 제어할 수 있습니다.</p>\n<p>이번 섹션에서는 커스텀 사전로딩 정책을 작성해서 라우팅 규칙의 <code>data.preload</code> 플래그가 <code>true</code>인 모듈만 사전로딩하도록 구현해 봅시다.\n이전에 살펴봤던 것처럼 라우팅 규칙에는 <code>data</code> 프로퍼티를 사용해서 인자를 전달할 수 있습니다.</p>\n<p><code>AppRoutingModule</code>에 정의된 <code>crisis-center</code> 라우팅 규칙에 <code>data.preload</code> 플래그를 다음과 같이 설정합니다.</p>\n<!--\n<code-example path=\"router/src/app/app-routing.module.ts\" linenums=\"false\" header=\"src/app/app-routing.module.ts (route data preload)\" region=\"preload-v2\">\n-->\n<code-example path=\"router/src/app/app-routing.module.ts\" linenums=\"false\" header=\"src/app/app-routing.module.ts (사전로딩 설정)\" region=\"preload-v2\">\n{\n  path: 'crisis-center',\n  <a href=\"api/router/Route#loadChildren\" class=\"code-anchor\">loadChildren</a>: './crisis-center/crisis-center.module#CrisisCenterModule',\n  data: { preload: true }\n},\n\n</code-example>\n<!--\nGenerate a new `SelectivePreloadingStrategy` service.\n-->\n<p>그리고 다음 명령을 실행해서 <code>SelectivePreloadingStrategy</code> 서비스를 생성합니다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate service selective-preloading-strategy\n</code-example>\n<!--\n<code-example path=\"router/src/app/selective-preloading-strategy.service.ts\" linenums=\"false\" header=\"src/app/selective-preloading-strategy.service.ts (excerpt)\">\n-->\n<code-example path=\"router/src/app/selective-preloading-strategy.service.ts\" linenums=\"false\" header=\"src/app/selective-preloading-strategy.service.ts (일부)\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { <a href=\"api/router/PreloadingStrategy\" class=\"code-anchor\">PreloadingStrategy</a>, <a href=\"api/router/Route\" class=\"code-anchor\">Route</a> } from '@angular/router';\nimport { Observable, of } from 'rxjs';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class SelectivePreloadingStrategyService implements <a href=\"api/router/PreloadingStrategy\" class=\"code-anchor\">PreloadingStrategy</a> {\n  preloadedModules: string[] = [];\n\n  preload(route: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>, load: () => Observable&#x3C;any>): Observable&#x3C;any> {\n    if (route.data &#x26;&#x26; route.data['preload']) {\n      // 사전로딩할 모듈의 라우팅 규칙을 배열에 추가합니다.\n      this.preloadedModules.push(route.path);\n\n      // 라우팅 규칙을 확인하기 위해 콘솔에 출력합니다.\n      console.log('Preloaded: ' + route.path);\n\n      return load();\n    } else {\n      return of(null);\n    }\n  }\n}\n\n\n</code-example>\n<!--\n`SelectivePreloadingStrategyService` implements the `PreloadingStrategy`, which has one method, `preload`.\n\nThe router calls the `preload` method with two arguments:\n\n1. The route to consider.\n1. A loader function that can load the routed module asynchronously.\n-->\n<p><code>SelectivePreloadingStrategyService</code>는 <code><a href=\"api/router/PreloadingStrategy\" class=\"code-anchor\">PreloadingStrategy</a></code> 인터페이스를 기반으로 구현하기 때문에 <code>preload</code> 메소드를 작성해야 합니다.</p>\n<p>그러면 라우터가 이 <code>preload</code> 메소드를 실행할 때 두 개의 인자를 함께 전달합니다:</p>\n<ol>\n<li>판단 대상이 되는 라우팅 규칙</li>\n<li>모듈을 비동기로 로드하는 함수</li>\n</ol>\n<!--\nAn implementation of `preload` must return an `Observable`.\nIf the route should preload, it returns the observable returned by calling the loader function.\nIf the route should _not_ preload, it returns an `Observable` of `null`.\n-->\n<p><code>preload</code> 메소드는 반드시 <code>Observable</code>을 반환해야 합니다.\n그리고 라우팅 규칙을 사전로딩하려면 로더 함수를 실행한 결과를 반환하면 됩니다.\n라우팅 규칙을 사전로딩하지 <em>않으려면</em> <code>null</code>을 <code>Observable</code> 타입으로 반환하면 됩니다.</p>\n<!--\nIn this sample, the  `preload` method loads the route if the route's `data.preload` flag is truthy.\n\nIt also has a side-effect.\n`SelectivePreloadingStrategyService` logs the `path` of a selected route in its public `preloadedModules` array.\n\nShortly, you'll extend the `AdminDashboardComponent` to inject this service and display its `preloadedModules` array.\n-->\n<p>이 예제에서는 <code>data.preload</code> 플래그 값에 따라 <code>preload</code> 메소드가 라우팅 규칙을 로드한 결과를 반환하거나 <code>null</code> 값을 반환합니다.</p>\n<p>그리고 이 함수는 또 다른 동작을 하나 합니다.\n<code>SelectivePreloadingStrategyService</code>는 처리되고 있는 라우팅 규칙을 콘솔에 출력하면서 이 서비스 인스턴스의 <code>preloadedModules</code> 배열에 이 라우팅 규칙을 추가합니다.</p>\n<p>그래서 <code>AdminDashboardComponent</code>에서 이 서비스를 의존성으로 주입받으면서 <code>preloadedModules</code> 배열에 있는 내용을 확인하는 용도로 확장할 수도 있습니다.</p>\n<!--\nBut first, make a few changes to the `AppRoutingModule`.\n\n1. Import `SelectivePreloadingStrategyService` into `AppRoutingModule`.\n1. Replace the `PreloadAllModules` strategy in the call to `forRoot` with this `SelectivePreloadingStrategyService`.\n1. Add the `SelectivePreloadingStrategyService` strategy to the `AppRoutingModule` providers array so it can be injected\nelsewhere in the app.\n-->\n<p>그러기 위해서는 먼저 <code>AppRoutingModule</code>을 조금 수정해야 합니다.</p>\n<ol>\n<li><code>AppRoutingModule</code>에 <code>SelectivePreloadingStrategyService</code>를 로드합니다.</li>\n<li><code>forRoot</code>에 적용했던 <code><a href=\"api/router/PreloadAllModules\" class=\"code-anchor\">PreloadAllModules</a></code> 정책을 <code>SelectivePreloadingStrategyService</code>로 변경합니다.</li>\n<li>애플리케이션 전역에 사용할 수 있도록 <code>SelectivePreloadingStrategyService</code> 정책을 <code>AppRoutingModule</code> 프로바이더 배열에 추가합니다.</li>\n</ol>\n<!--\nNow edit the `AdminDashboardComponent` to display the log of preloaded routes.\n\n1. Import the `SelectivePreloadingStrategyService`.\n1. Inject it into the dashboard's constructor.\n1. Update the template to display the strategy service's `preloadedModules` array.\n\nWhen you're done it looks like this.\n-->\n<p>그리고 이제 사전로딩되는 라우팅 규칙을 확인하기 위해 <code>AdminDashboardComponent</code>를 수정합니다.</p>\n<ol>\n<li><code>SelectivePreloadingStrategyService</code>를 로드합니다.</li>\n<li>컴포넌트의 생성자에 이 서비스를 주입합니다.</li>\n<li>서비스의 <code>preloadedModules</code> 배열을 화면에 표시하도록 템플릿을 수정합니다.</li>\n</ol>\n<p>이렇게 작성하면 다음과 같은 코드가 됩니다.</p>\n<!--\n<code-example path=\"router/src/app/admin/admin-dashboard/admin-dashboard.component.ts\" linenums=\"false\" header=\"src/app/admin/admin-dashboard/admin-dashboard.component.ts (preloaded modules)\">\n-->\n<code-example path=\"router/src/app/admin/admin-dashboard/admin-dashboard.component.ts\" linenums=\"false\" header=\"src/app/admin/admin-dashboard/admin-dashboard.component.ts (사전로딩하는 모듈 확인하기)\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> }    from '@angular/core';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> }       from '@angular/router';\nimport { Observable }           from 'rxjs';\nimport { map }                  from 'rxjs/operators';\n\nimport { SelectivePreloadingStrategyService } from '../../selective-preloading-strategy.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-admin-dashboard',\n  templateUrl: './admin-dashboard.component.html',\n  <a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a>: ['./admin-dashboard.component.css']\n})\nexport class AdminDashboardComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  sessionId: Observable&#x3C;string>;\n  token: Observable&#x3C;string>;\n  modules: string[];\n\n  constructor(\n    private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>,\n    preloadStrategy: SelectivePreloadingStrategyService\n  ) {\n    this.modules = preloadStrategy.preloadedModules;\n  }\n\n  ngOnInit() {\n    // 세션 ID가 있으면 가져옵니다.\n    this.sessionId = this.route\n      .queryParamMap\n      .pipe(map(params => params.get('session_id') || '<a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">None</a>'));\n\n    // 프래그먼트가 있으면 가져옵니다.\n    this.token = this.route\n      .fragment\n      .pipe(map(fragment => fragment || '<a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">None</a>'));\n  }\n}\n\n\n</code-example>\n<!--\nOnce the application loads the initial route, the `CrisisCenterModule` is preloaded.\nVerify this by logging in to the `Admin` feature area and noting that the `crisis-center` is listed in the `Preloaded Modules`.\nIt's also logged to the browser's console.\n-->\n<p>이제 애플리케이션이 실행되고 초기 라우팅 동작이 끝나고 나면 <code>CrisisCenterModule</code>이 사전로딩됩니다.\n이 동작은 <code>Admin</code> 기능 모듈에서 화면에 표시하는 내용으로 확인할 수 있으며, <code>crisis-center</code> 라우팅 규칙은 이 목록에 표함되지 않는 것도 확인할 수 있습니다.\n이 내용은 브라우저 콘솔에도 동일하게 표시됩니다.</p>\n<a id=\"redirect-advanced\"></a>\n<!--\n## Migrating URLs with Redirects\n-->\n<h2 id=\"리다이렉트로-url-마이그레이션-하기\">리다이렉트로 URL 마이그레이션 하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#리다이렉트로-url-마이그레이션-하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nYou've setup the routes for navigating around your application. You've used navigation imperatively and declaratively to many different routes. But like any application, requirements change over time. You've setup links and navigation to `/heroes` and `/hero/:id` from the `HeroListComponent` and `HeroDetailComponent` components. If there was a requirement that links to `heroes` become `superheroes`, you still want the previous URLs to navigate correctly. You also don't want to go and update every link in your application, so redirects makes refactoring routes trivial.\n-->\n<p>라우팅 규칙은 애플리케이션에서 네비게이션 동작을 실행하기 위해 작성합니다.\n이 때 명시적으로 네비게이션을 실행하기 위해 여러가지 라우팅 규칙을 작성해보기도 했습니다.\n하지만 애플리케이션을 개발하면서 요구사항은 언제나 바뀔 수 있습니다.\n지금까지는 <code>HeroListComponent</code>와 <code>HeroDetailComponent</code>로 네비게이션하기 위해 <code>/heroes</code>와 <code>/hero/:id</code> 라우팅 규칙을 정의했습니다.\n그런데 요구사항이 변경되어 <code>heroes</code> 주소가 <code>superheroes</code>로 변경해야 하지만, 이전에 제공하던 URL도 그대로 제공해야 한다고 합시다.\n개발자의 입장에서도 애플리케이션에 존재하는 모든 링크를 수정하는 것은 반가운 일이 아닙니다. 그래서 이전 주소를 새로운 주소로 리다이렉트하는 방식으로 리팩토링하는 방법에 대해 알아봅시다.</p>\n<a id=\"url-refactor\"></a>\n<!--\n### Changing /heroes to /superheroes\n-->\n<h3 id=\"heroes를-superheroes로-변경하기\">/heroes를 /superheroes로 변경하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#heroes를-superheroes로-변경하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nLet's take the `Hero` routes and migrate them to new URLs. The `Router` checks for redirects in your configuration before navigating, so each redirect is triggered when needed. To support this change, you'll add redirects from the old routes to the new routes in the `heroes-routing.module`.\n-->\n<p><code>Hero</code>와 관련된 라우팅 규칙을 모두 새로운 URL로 마이그레이션 해봅시다.\n<code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>는 네비게이션 동작을 실행하기 전에 해당 라우팅 규칙에 리다이렉트 설정이 있는지 확인하며, 리다이렉트 설정이 있으면 해당 주소로 이동합니다.\n그래서 <code>heroes-routing.module</code>에서 원래 사용하던 주소는 새로운 주소로 리다이렉트하는 설정을 추가해야 합니다.</p>\n<!--\n<code-example path=\"router/src/app/heroes/heroes-routing.module.ts\" linenums=\"false\" header=\"src/app/heroes/heroes-routing.module.ts (heroes redirects)\">\n-->\n<code-example path=\"router/src/app/heroes/heroes-routing.module.ts\" linenums=\"false\" header=\"src/app/heroes/heroes-routing.module.ts (heroes 리다이렉트)\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }             from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { HeroListComponent }    from './hero-list/hero-list.component';\nimport { HeroDetailComponent }  from './hero-detail/hero-detail.component';\n\nconst heroesRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'heroes', <a href=\"api/router/Route#redirectTo\" class=\"code-anchor\">redirectTo</a>: '/superheroes' },\n  { path: 'hero/:id', <a href=\"api/router/Route#redirectTo\" class=\"code-anchor\">redirectTo</a>: '/superhero/:id' },\n  { path: 'superheroes',  component: HeroListComponent, data: { <a href=\"api/animations/animation\" class=\"code-anchor\">animation</a>: 'heroes' } },\n  { path: 'superhero/:id', component: HeroDetailComponent, data: { <a href=\"api/animations/animation\" class=\"code-anchor\">animation</a>: 'hero' } }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    RouterModule.forChild(heroesRoutes)\n  ],\n  <a href=\"api/core/NgModule#exports\" class=\"code-anchor\">exports</a>: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class HeroesRoutingModule { }\n\n</code-example>\n<!--\nYou'll notice two different types of redirects. The first change is from  `/heroes` to `/superheroes` without any parameters. This is a straightforward redirect, unlike the change from `/hero/:id` to `/superhero/:id`, which includes the `:id` route parameter. Router redirects also use powerful pattern matching, so the `Router` inspects the URL and replaces route parameters in the `path` with their appropriate destination. Previously, you navigated to a URL such as `/hero/15` with a route parameter `id` of `15`.\n-->\n<p>이 코드에서 두가지 종류의 리다이렉트를 확인할 수 있습니다.\n첫번째는 라우팅 변수 없이 <code>/heroes</code>에서 <code>/superheroes</code>로 리다이렉트하는 라우팅 규칙입니다.\n이 방식은 <code>/hero/:id</code>를 <code>/superhero/:id</code>로 리다이렉트할 때 라우팅 변수 <code>:id</code>를 사용하는 것과 비교했을 때 좀 더 간단합니다.\n그리고 라우터는 훌륭한 패턴 매칭 시스젬을 제공하기 때문에 네비게이션하는 주소에 존재하는 라우팅 변수를 추출할 수 있습니다.\n위에서 살펴본 것처럼 <code>/hero/15</code> 라는 주소로 이동할 때 라우터가 추출하는 라우팅 변수 <code>id</code>의 값은 <code>15</code>입니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nThe `Router` also supports [query parameters](#query-parameters) and the [fragment](#fragment) when using redirects.\n\n* When using absolute redirects, the `Router` will use the query parameters and the fragment from the redirectTo in the route config.\n* When using relative redirects, the `Router` use the query params and the fragment from the source URL.\n-->\n<p><code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>에서 리다이렉트를 할 때도 <a href=\"guide/router#query-parameters\">쿼리 파라미터</a>와 <a href=\"guide/router#fragment\">프래그먼트</a>를 사용할 수 있습니다.</p>\n<ul>\n<li>절대 주소로 리다이렉트 하면 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>는 라우팅 규칙의 <code>reditercTo</code>에 해당하는 쿼리 파라미터와 프래그먼트를 활용합니다.</li>\n<li>상대 주소로 리다이렉트 하면 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>는 해당 URL에 해당하는 쿼리 파라미터와 프래그먼트를 활용합니다.</li>\n</ul>\n</div>\n<!--\nBefore updating the `app-routing.module.ts`, you'll need to consider an important rule. Currently, our empty path route redirects to `/heroes`, which redirects to `/superheroes`. This _won't_ work and is by design as the `Router` handles redirects once at each level of routing configuration. This prevents chaining of redirects, which can lead to endless redirect loops.\n\nSo instead, you'll update the empty path route in `app-routing.module.ts` to redirect to `/superheroes`.\n-->\n<p>그런데 <code>app-routing.module.ts</code> 파일을 수정하기 전에 중요하게 짚고 넘어가야 할 것이 있습니다.\n애플리케이션이 처음 실행되면 빈 문자열 라우팅 규칙이 적용되기 때문에 <code>/heroes</code>로 리다이렉트하는데, <code>/heroes</code> 주소는 <code>/superheroes</code>로 다시 리다이렉트 될것이라 생각할 수 있습니다.\n하지만 라우터는 한 번에 라우팅 규칙 하나만 처리하기 때문에 이런 리다이렉션은 동작하지 않습니다.\n이 방식은 리다이렉션 체이닝 때문에 발생할 수 있는 무한루프를 방지하기 위한 것이기도 합니다.</p>\n<!--\n<code-example path=\"router/src/app/app-routing.module.ts\" linenums=\"false\" header=\"src/app/app-routing.module.ts (superheroes redirect)\">\n-->\n<code-example path=\"router/src/app/app-routing.module.ts\" linenums=\"false\" header=\"src/app/app-routing.module.ts (superheroes 리다이렉트)\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }             from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { ComposeMessageComponent }  from './compose-message/compose-message.component';\nimport { PageNotFoundComponent }    from './page-not-found/page-not-found.component';\n\nimport { AuthGuard }                          from './auth/auth.guard';\nimport { SelectivePreloadingStrategyService } from './selective-preloading-strategy.service';\n\nconst appRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'compose',\n    component: ComposeMessageComponent,\n    outlet: 'popup'\n  },\n  {\n    path: 'admin',\n    <a href=\"api/router/Route#loadChildren\" class=\"code-anchor\">loadChildren</a>: './admin/admin.module#AdminModule',\n    <a href=\"api/router/Route#canLoad\" class=\"code-anchor\">canLoad</a>: [AuthGuard]\n  },\n  {\n    path: 'crisis-center',\n    <a href=\"api/router/Route#loadChildren\" class=\"code-anchor\">loadChildren</a>: './crisis-center/crisis-center.module#CrisisCenterModule',\n    data: { preload: true }\n  },\n  { path: '',   <a href=\"api/router/Route#redirectTo\" class=\"code-anchor\">redirectTo</a>: '/superheroes', <a href=\"api/router/Route#pathMatch\" class=\"code-anchor\">pathMatch</a>: '<a href=\"api/core/Version#full\" class=\"code-anchor\">full</a>' },\n  { path: '**', component: PageNotFoundComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    RouterModule.forRoot(\n      appRoutes,\n      {\n        <a href=\"api/router/ExtraOptions#enableTracing\" class=\"code-anchor\">enableTracing</a>: false, // &#x3C;-- 디버그 활성화\n        <a href=\"api/router/ExtraOptions#preloadingStrategy\" class=\"code-anchor\">preloadingStrategy</a>: SelectivePreloadingStrategyService,\n      }\n    )\n  ],\n  <a href=\"api/core/NgModule#exports\" class=\"code-anchor\">exports</a>: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class AppRoutingModule { }\n\n\n</code-example>\n<!--\n`RouterLink`s aren't tied to route configuration, so you'll need to update the associated router links so they remain active when the new route is active. You'll update the `app.component.ts` template for the `/heroes` routerLink.\n-->\n<p><code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>는 라우팅 규칙 설정과 직접적으로 연결되지 않기 때문에 변경된 주소로 이동할 수 있도록 라우터 링크의 설정을 수정해야 합니다.\n<code>app.component.ts</code> 템플릿에 있는 라우터 링크 중 <code>/heroes</code>로 이동하던 라우터 링크를 다음과 같이 변경합니다.</p>\n<!--\n<code-example path=\"router/src/app/app.component.html\" linenums=\"false\" header=\"src/app/app.component.html (superheroes active routerLink)\">\n-->\n<code-example path=\"router/src/app/app.component.html\" linenums=\"false\" header=\"src/app/app.component.html (superheroes 라우터 링크)\">\n&#x3C;h1 class=\"title\">Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>&#x3C;/h1>\n&#x3C;nav>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/crisis-center\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Crisis Center&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/superheroes\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Heroes&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/admin\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Admin&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/login\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Login&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"[{ outlets: { popup: ['compose'] } }]\">Contact&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n&#x3C;/nav>\n&#x3C;div [@routeAnimation]=\"getAnimationData(routerOutlet)\">\n  &#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a> #routerOutlet=\"outlet\">&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n&#x3C;/div>\n&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a> name=\"popup\">&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n\n</code-example>\n<!--\nUpdate the `goToHeroes()` method in the `hero-detail.component.ts` to navigate back to `/superheroes` with the optional route parameters.\n-->\n<p>그리고 <code>hero-detail.component.ts</code> 파일에 있는 <code>goToHeroes()</code> 메소드에서도 <code>/superheroes</code>로 이동하도록 수정합니다.</p>\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.ts\" linenums=\"false\" region=\"redirect\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (goToHeroes)\">\ngotoHeroes(hero: Hero) {\n  let heroId = hero ? hero.id : null;\n  // HeroList 컴포넌트에 하이라이트를 표시하기 위해 히어로의 id가 존재하면 전달합니다.\n  // 'foo' 프로퍼티는 사용하지 않지만 이렇게 전달할 수도 있습니다.\n  this.router.navigate(['/superheroes', { id: heroId, foo: 'foo' }]);\n}\n\n</code-example>\n<!--\nWith the redirects setup, all previous routes now point to their new destinations and both URLs still function as intended.\n-->\n<p>여기까지 수정하고 나면 기존에 동작하던 라우팅 규칙은 모두 새로운 주소로 연결됩니다.</p>\n<a id=\"inspect-config\"></a>\n<!--\n## Inspect the router's configuration\n-->\n<h2 id=\"라우터-설정-확인하기\">라우터 설정 확인하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#라우터-설정-확인하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nYou put a lot of effort into configuring the router in several routing module files\nand were careful to list them [in the proper order](#routing-module-order).\nAre routes actually evaluated as you planned?\nHow is the router really configured?\n\nYou can inspect the router's current configuration any time by injecting it and\nexamining its `config` property.\nFor example, update the `AppModule` as follows and look in the browser console window\nto see the finished route configuration.\n-->\n<p>라우팅 규칙은 여러 모듈에 분산되어 작성될 수 있기 때문에 이 라우팅 규칙들은 <a href=\"guide/router#routing-module-order\">올바른 순서로</a> 등록되어야 합니다.\n라우팅 규칙이 최종적으로 어떻게 조합되었는지 확인하는 방법이 있을까요?\n라우터는 실제로 어떻게 설정되었을까요?</p>\n<p>라우터의 설정값은 <code><a href=\"api/router/Router#config\" class=\"code-anchor\">config</a></code> 프로퍼티를 참조하면 확인할 수 있습니다.\n간단하게 <code>AppModule</code>을 다음과 같이 수정하고 브라우저 콘솔을 확인하면, 브라우저 콘솔로 라우터 설정을 확인할 수 있습니다.</p>\n<code-example path=\"router/src/app/app.module.7.ts\" linenums=\"false\" header=\"src/app/app.module.ts (inspect the router config)\" region=\"inspect-config\">\nexport class AppModule {\n  // 디버그용: 라우터 설정값 확인하기\n  constructor(router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {\n    // 라우터 설정 객체의 프로퍼티 중 함수는 이름만 출력하도록 조정합니다.\n    const replacer = (key, value) => (typeof value === 'function') ? value.name : value;\n\n    console.log('<a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a>: ', JSON.stringify(router.config, replacer, 2));\n  }\n}\n\n</code-example>\n<a id=\"final-app\"></a>\n<!--\n## Wrap up and final app\n-->\n<h2 id=\"정리하기\">정리하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#정리하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nYou've covered a lot of ground in this guide and the application is too big to reprint here.\nPlease visit the <live-example title=\"Router Sample in Stackblitz\"></live-example>\nwhere you can download the final source code.\n-->\n<p>이 가이드에서는 라우터와 네비게이션에 대한 내용을 방대하게 살펴봤기 때문에 애플리케이션 코드를 여기에 모두 나열하기에는 너무 내용이 많습니다.\n예제로 다룬 코드의 최종 버전은 <live-example title=\"Router Sample in Stackblitz\"></live-example>에서 확인하거나 다운받아 확인하는 것을 권장합니다.</p>\n<a id=\"appendices\"></a>\n<!--\n## Appendices\n-->\n<h2 id=\"부록\">부록<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#부록\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe balance of this guide is a set of appendices that\nelaborate some of the points you covered quickly above.\n\nThe appendix material isn't essential. Continued reading is for the curious.\n-->\n<p>지금까지 설명한 내용중 간단하게 짚고 넘어갔던 부분은 부록으로 제공합니다.</p>\n<p>부록에서 설명하는 내용을 꼭 알아야 하는 것은 아닙니다. 참고삼아 읽어보세요.</p>\n<a id=\"link-parameters-array\"></a>\n<!--\n### Appendix: link parameters array\n-->\n<h3 id=\"부록-링크-파라미터-배열-link-parameters-array\">부록: 링크 파라미터 배열 (link parameters array)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#부록-링크-파라미터-배열-link-parameters-array\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nA link parameters array holds the following ingredients for router navigation:\n\n* The *path* of the route to the destination component.\n* Required and optional route parameters that go into the route URL.\n\nYou can bind the `RouterLink` directive to such an array like this:\n-->\n<p>링크 파라미터 배열은 라우터가 네비게이션할 때 필요한 정보를 지정하는 용도로 사용합니다:</p>\n<ul>\n<li>화면에 표시할 컴포넌트에 해당하는 <em>주소</em>를 지정할 수 있습니다.</li>\n<li>목적지로 이동할 때 사용하는 필수 라우팅 변수나 옵션 라우팅 변수를 지정할 수 있습니다.</li>\n</ul>\n<p>그래서 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 디렉티브는 다음과 같이 사용하는 것이 일반적입니다:</p>\n<code-example path=\"router/src/app/app.component.3.ts\" linenums=\"false\" header=\"src/app/app.component.ts (h-anchor)\" region=\"h-anchor\">\n&#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/heroes']\">Heroes&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n\n</code-example>\n<!--\nYou've written a two element array when specifying a route parameter like this:\n-->\n<p>라우팅 변수를 지정하려면 다음과 같이 엘리먼트가 2개인 배열을 사용할 수 있습니다:</p>\n<code-example path=\"router/src/app/heroes/hero-list/hero-list.component.1.html\" linenums=\"false\" header=\"src/app/heroes/hero-list/hero-list.component.html (nav-to-detail)\" region=\"nav-to-detail\">\n&#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/hero', hero.id]\">\n  &#x3C;span class=\"badge\">{{ hero.id }}&#x3C;/span>{{ hero.name }}\n&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n\n</code-example>\n<!--\nYou can provide optional route parameters in an object like this:\n-->\n<p>옵션 인자는 다음과 같이 객체 형태로 전달할 수도 있습니다:</p>\n<code-example path=\"router/src/app/app.component.3.ts\" linenums=\"false\" header=\"src/app/app.component.ts (cc-query-params)\" region=\"cc-query-params\">\n&#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/crisis-center', { foo: 'foo' }]\">Crisis Center&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n\n</code-example>\n<!--\nThese three examples cover the need for an app with one level routing.\nThe moment you add a child router, such as the crisis center, you create new link array possibilities.\n\nRecall that you specified a default child route for the crisis center so this simple `RouterLink` is fine.\n-->\n<p>이 3가지 예제로도 애플리케이션에 필요한 기본 라우팅은 모두 처리할 수 있습니다.\n그리고 위기대응센터와 같은 자식 라우터를 활용한다면 이 배열을 좀 더 확장해서 사용할 수도 있습니다.</p>\n<p>기본 자식 라우팅 규칙을 지정했다면 다음과 같이 간단하게 사용할 수 있습니다.</p>\n<code-example path=\"router/src/app/app.component.3.ts\" linenums=\"false\" header=\"src/app/app.component.ts (cc-anchor-w-default)\" region=\"cc-anchor-w-default\">\n&#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/crisis-center']\">Crisis Center&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n\n</code-example>\n<!--\nParse it out.\n\n* The first item in the array identifies the parent route (`/crisis-center`).\n* There are no parameters for this parent route so you're done with it.\n* There is no default for the child route so you need to pick one.\n* You're navigating to the `CrisisListComponent`, whose route path is `/`, but you don't need to explicitly add the slash.\n* Voilà! `['/crisis-center']`.\n\nTake it a step further. Consider the following router link that\nnavigates from the root of the application down to the *Dragon Crisis*:\n-->\n<p>이 코드는 다음과 같이 해석할 수 있습니다.</p>\n<ul>\n<li>배열의 첫번째 항목은 새로 적용될 부모 라우팅 규칙(<code>/crisis-center</code>)을 의미합니다.</li>\n<li>부모 라우팅 규칙에 사용되는 라우팅 변수는 없습니다.</li>\n<li>자식 라우터의 기본 라우팅 규칙은 지정되지 않았기 때문에 하나를 골라야 합니다.</li>\n<li>이동하려는 컴포넌트는 <code>CrisisListComponent</code>이며 이 라우팅 규칙의 주소는 '/'로 지정되어 있지만, 슬래시는 생략해도 됩니다.</li>\n<li>배열의 최종 형태는 <code>['/crisis-center']</code>가 됩니다.</li>\n</ul>\n<code-example path=\"router/src/app/app.component.3.ts\" linenums=\"false\" header=\"src/app/app.component.ts (Dragon-anchor)\" region=\"Dragon-anchor\">\n&#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/crisis-center', 1]\">Dragon Crisis&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n\n</code-example>\n<!--\n* The first item in the array identifies the parent route (`/crisis-center`).\n* There are no parameters for this parent route so you're done with it.\n* The second item identifies the child route details about a particular crisis (`/:id`).\n* The details child route requires an `id` route parameter.\n* You added the `id` of the *Dragon Crisis* as the second item in the array (`1`).\n* The resulting path is `/crisis-center/1`.\n\n\nIf you wanted to, you could redefine the `AppComponent` template with *Crisis Center* routes exclusively:\n-->\n<ul>\n<li>배열의 첫번째 항목은 새로 적용될 부모 라우팅 규칙(<code>/crisis-center</code>)을 의미합니다.</li>\n<li>부모 라우팅 규칙에 사용되는 라우팅 변수는 없습니다.</li>\n<li>배열의 두번째 아이템은 자식 라우팅 규칙에서 표시할 특정 위기의 <code>id</code>를 의미합니다. 이 변수는 <code>/:id</code>와 맵핑됩니다.</li>\n<li>세부정보를 표시하는 자식 라우팅 규칙에는 <code>id</code> 라우팅 변수가 필요합니다.</li>\n<li><em>용 출현 위기</em>에 해당하는 <code>id</code>를 지정하기 위해 배열의 두 번째 아이템에는 <code>1</code>을 지정합니다.</li>\n<li>최종 주소는 <code>/crisis-center/1</code>이 됩니다.</li>\n</ul>\n<!--\n<code-example path=\"router/src/app/app.component.3.ts\" linenums=\"false\" header=\"src/app/app.component.ts (template)\" region=\"template\">\n-->\n<code-example path=\"router/src/app/app.component.3.ts\" linenums=\"false\" header=\"src/app/app.component.ts (템플릿)\" region=\"template\">\n<a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n  &#x3C;h1 class=\"title\">Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>&#x3C;/h1>\n  &#x3C;nav>\n    &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/crisis-center']\">Crisis Center&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n    &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/crisis-center/1', { foo: 'foo' }]\">Dragon Crisis&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n    &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/crisis-center/2']\">Shark Crisis&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n  &#x3C;/nav>\n  &#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n`\n\n</code-example>\n<!--\nIn sum, you can write applications with one, two or more levels of routing.\nThe link parameters array affords the flexibility to represent any routing depth and\nany legal sequence of route paths, (required) router parameters, and (optional) route parameter objects.\n-->\n<p>라우팅 규칙은 여러개를 한 번에 적용할 수 있습니다.\n링크 파라미터 배열은 자유로운 라우팅을 위해 유연하게 설계되었으며, 필수 라우팅 변수나 옵션 라우팅 변수도, 객체 형태의 라우팅 변수도 모두 처리할 수 있습니다.</p>\n<a id=\"browser-url-styles\"></a>\n<a id=\"location-strategy\"></a>\n<!--\n### Appendix: *LocationStrategy* and browser URL styles\n-->\n<h3 id=\"부록-locationstrategy와-브라우저-url-스타일\">부록: <em>LocationStrategy</em>와 브라우저 URL 스타일<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#부록-locationstrategy와-브라우저-url-스타일\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nWhen the router navigates to a new component view, it updates the browser's location and history\nwith a URL for that view.\nThis is a strictly local URL. The browser shouldn't send this URL to the server\nand should not reload the page.\n-->\n<p>라우터는 새로운 컴포넌트를 화면에 띄울 때 이 컴포넌트에 해당하는 주소를 브라우저의 현재 위치에 반영하고 히스토리에도 추가합니다.\n이 때 사용하는 주소는 온전히 로컬 URL입니다. 브라우저는 이 URL을 서버로 보내거나 새로운 주소로 다시 접속하지 않습니다.</p>\n<!--\nModern HTML5 browsers support\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries\" title=\"HTML5 browser history push-state\">history.pushState</a>,\na technique that changes a browser's location and history without triggering a server page request.\nThe router can compose a \"natural\" URL that is indistinguishable from\none that would otherwise require a page load.\n-->\n<p>최신 HTML5를 지원하는 브라우저는 현재 주소를 바꾸면서 서버로 추가 요청을 보내지 않을 때 사용하는 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries\" title=\"HTML5 browser history push-state\">history.pushState</a>를 제공합니다.\n그래서 Angular 라우터도 페이지를 새로 로드하지 않으면서 URL을 \"자연스럽게\" 변경할 수 있습니다.</p>\n<!--\nHere's the *Crisis Center* URL in this \"HTML5 pushState\" style:\n-->\n<p><em>위기대응센터</em>에 해당하는 URL을 \"HTML5 pushState\" 스타일로 표현하면 다음과 같습니다:</p>\n<code-example format=\"nocode\">\n  localhost:3002/crisis-center/\n\n</code-example>\n<!--\nOlder browsers send page requests to the server when the location URL changes\n_unless_ the change occurs after a \"#\" (called the \"hash\").\nRouters can take advantage of this exception by composing in-application route\nURLs with hashes.  Here's a \"hash URL\" that routes to the *Crisis Center*.\n-->\n<p>하지만 최신 스펙을 제공하지 않는 브라우저는 URL이 변경될 때마다 서버로 새로운 페이지 요청을 보내는데, 이 동작은 해시(\"#\") 이후의 주소가 바뀔 때도 마찬가지입니다.\n그래서 라우터는 이렇게 주소가 바뀌는 동작은 애플리케이션 안에서 라우팅할 수 있도록 예외로 처리합니다.\n<em>위기대응센터</em>에 해당하는 URL을 \"해시방식의 URL\" 스타일로 표현하면 다음과 같습니다:</p>\n<code-example format=\"nocode\">\n  localhost:3002/src/#/crisis-center/\n\n</code-example>\n<!--\nThe router supports both styles with two `LocationStrategy` providers:\n\n1. `PathLocationStrategy`&mdash;the default \"HTML5 pushState\" style.\n1. `HashLocationStrategy`&mdash;the \"hash URL\" style.\n\nThe `RouterModule.forRoot` function sets the `LocationStrategy` to the `PathLocationStrategy`,\nmaking it the default strategy.\nYou can switch to the `HashLocationStrategy` with an override during the bootstrapping process if you prefer it.\n-->\n<p><code><a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a></code> 프로바이더를 사용하면 이 두 동작 중 어떤 방식을 사용할지 선택할 수 있습니다.</p>\n<ol>\n<li><code><a href=\"api/common/PathLocationStrategy\" class=\"code-anchor\">PathLocationStrategy</a></code>—기본값이며 \"HTML5 pushState\" 스타일을 사용합니다.</li>\n<li><code><a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a></code>—\"해시방식의 URL\" 스타일을 사용합니다.</li>\n</ol>\n<p>이 옵션은 <code>RouterModule.forRoot</code> 함수에 지정합니다.\n그래서 <code><a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a></code> 방식을 사용하려면 부트스트랩 과정에 이 옵션을 적용하면 됩니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nLearn about providers and the bootstrap process in the\n[Dependency Injection guide](guide/dependency-injection#bootstrap).\n-->\n<p>부트스트랩 단계에서 프로바이더를 등록하는 방법을 더 알아보려면 <a href=\"guide/dependency-injection#bootstrap\">의존성 주입 가이드</a> 문서를 참고하세요.</p>\n</div>\n<!--\n#### Which strategy is best?\n-->\n<h4 id=\"어떤-방식이-제일-좋은가요\">어떤 방식이 제일 좋은가요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#어떤-방식이-제일-좋은가요\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nYou must choose a strategy and you need to make the right call early in the project.\nIt won't be easy to change later once the application is in production\nand there are lots of application URL references in the wild.\n-->\n<p>브라우저에서 URL을 표시하는 정책은 프로젝트 초반에 결정해야 합니다.\n왜냐하면 URL을 사용하는 부분이 이미 많은 곳에 적용되어 운영중인 애플리케이션에서 이 정책을 변경하는 것은 매우 어렵기 때문입니다.</p>\n<!--\nAlmost all Angular projects should use the default HTML5 style.\nIt produces URLs that are easier for users to understand.\nAnd it preserves the option to do _server-side rendering_ later.\n-->\n<p>대부분의 Angular 프로젝트는 HTML5 스타일을 그대로 사용하는 것이 좋습니다.\nHTML5 스타일을 사용하는 것이 사용자가 더 이해하기 쉽기도 합니다.\n그리고 이 정책을 사용하면 이후에 <em>서버사이드 렌더링</em> 을 적용하기도 쉽습니다.</p>\n<!--\nRendering critical pages on the server is a technique that can greatly improve\nperceived responsiveness when the app first loads.\nAn app that would otherwise take ten or more seconds to start\ncould be rendered on the server and delivered to the user's device\nin less than a second.\n-->\n<p>페이지를 서버에서 렌더링하는 것은 앱 실행 속도를 비약적으로 향상시킬 수 있는 테크닉입니다.\n실행하는 데에 10초 이상 걸리는 앱을 서버에서 렌더링하면 사용자의 디바이스에서 1초 안에 실행되게 할 수 있습니다. </p>\n<!--\nThis option is only available if application URLs look like normal web URLs\nwithout hashes (#) in the middle.\n-->\n<p>하지만 이 방식은 애플리케이션의 URL이 해시(#) 없이 일반적으로 사용하는 웹 URL 형식일 때만 유효합니다.</p>\n<!--\nStick with the default unless you have a compelling reason to\nresort to hash routes.\n-->\n<p>해시 라우팅을 반드시 사용해야 하는 경우가 아니라면 기본 방식을 사용하는 것이 좋습니다.</p>\n<!--\n#### The *&lt;base href>*\n-->\n<h4 id=\"base-href-1\"><em>&#x3C;base href></em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#base-href-1\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe router uses the browser's\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries\" title=\"HTML5 browser history push-state\">history.pushState</a>\nfor navigation. Thanks to `pushState`, you can make in-app URL paths look the way you want them to\nlook, e.g. `localhost:4200/crisis-center`. The in-app URLs can be indistinguishable from server URLs.\n-->\n<p>라우터는 네비게이션 동작을 실행할 때 브라우저가 제공하는 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries\" title=\"HTML5 browser history push-state\">history.pushState</a> API를 사용합니다.\n애플리케이션에서 동작하는 URL을 이해하기 쉽게 <code>localhost:4200/crisis-center</code>와 같은 형식으로 표시할 수 있도 <code>pushState</code> 덕분입니다.\n애플리케이션 안에서 사용하는 URL은 서버에 요청하는 URL과 같은 형식이기 때문에 이질감없이 사용할 수 있습니다.</p>\n<!--\nModern HTML5 browsers were the first to support `pushState` which is why many people refer to these URLs as\n\"HTML5 style\" URLs.\n-->\n<p>많은 개발자들이 이런 URL 방식을 선호하기 때문에 최근 HTML5 스펙을 지원하는 브라우저는 모두 <code>pushState</code>를 지원하고 있습니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nHTML5 style navigation is the router default.\nIn the [LocationStrategy and browser URL styles](#browser-url-styles) Appendix,\nlearn why HTML5 style is preferred, how to adjust its behavior, and how to switch to the\nolder hash (#) style, if necessary.\n-->\n<p>라우터를 기본 설정으로 사용하면 HTML5 스타일로 네비게이션합니다.\n왜 HTML5 스타일이 더 인기가 있는지, 두 방식의 동작이 어떻게 다른지, 이전 방식인 해시(#) 스타일로 바꾸는지 알아보려면 부록 <a href=\"guide/router#browser-url-styles\">LocationStrategy와 브라우저 URL 스타일</a>을 참고하세요.</p>\n</div>\n<!--\nYou must **add a\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base\" title=\"base href\">&lt;base href&gt; element</a>**\nto the app's `index.html` for `pushState` routing to work.\nThe browser uses the `<base href>` value to prefix *relative* URLs when referencing\nCSS files, scripts, and images.\n\nAdd the `<base>` element just after the  `<head>` tag.\nIf the `app` folder is the application root, as it is for this application,\nset the `href` value in **`index.html`** *exactly* as shown here.\n-->\n<p><code>pushState</code>를 사용하는 라우팅이 제대로 동작하려면 애플리케이션의 <code>index.html</code> 파일에 <strong><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base\" title=\"base href\">&#x3C;base href> 엘리먼트</a></strong>를 추가해야 합니다.\n그러면 브라우저는 <code>&#x3C;base <a href=\"api/router/RouterLinkWithHref#href\" class=\"code-anchor\">href</a>></code>에 지정된 주소를 기준으로 CSS 파일과 스크립트, 이미지 파일에 대한 <em>상대</em> 주소를 참조합니다.</p>\n<p><code>&#x3C;base></code> 엘리먼트는 <code>&#x3C;head></code> 태그 바로 아래에 추가하는 것이 좋습니다.\n이 예제에서 살펴본 것처럼 애플리케이션의 최상위 폴더가 <code>app</code> 폴더라면 <strong><code>index.html</code></strong>에 지정하는 <code><a href=\"api/router/RouterLinkWithHref#href\" class=\"code-anchor\">href</a></code> 값을 다음과 같이 지정하면 됩니다.</p>\n<code-example path=\"router/src/index.html\" linenums=\"false\" header=\"src/index.html (base-href)\" region=\"base-href\">\n&#x3C;base <a href=\"api/router/RouterLinkWithHref#href\" class=\"code-anchor\">href</a>=\"/\">\n\n</code-example>\n<!--\n#### HTML5 URLs and the  *&lt;base href>*\n-->\n<h4 id=\"html5-방식의-url과-base-href\">HTML5 방식의 URL과 <em>&#x3C;base href></em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#html5-방식의-url과-base-href\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nWhile the router uses the\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries\" title=\"Browser history push-state\">HTML5 pushState</a>\nstyle by default, you *must* configure that strategy with a **base href**.\n\nThe preferred way to configure the strategy is to add a\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base\" title=\"base href\">&lt;base href&gt; element</a>\ntag in the `<head>` of the `index.html`.\n-->\n<p>라우터가 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries\" title=\"Browser history push-state\">HTML5 pushState</a> 스타일을 기본 옵션으로 사용한다고 해도 <strong>base href</strong>는 <em>반드시</em> 설정해야 합니다.</p>\n<p>그리고 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base\" title=\"base href\">&#x3C;base href> 엘리먼트</a>를 가장 간단하게 설정하는 방법은 <code>index.html</code> 파일의 <code>&#x3C;head></code> 태그 안에 이 엘리먼트를 추가하는 것입니다.</p>\n<code-example path=\"router/src/index.html\" linenums=\"false\" header=\"src/index.html (base-href)\" region=\"base-href\">\n&#x3C;base <a href=\"api/router/RouterLinkWithHref#href\" class=\"code-anchor\">href</a>=\"/\">\n\n</code-example>\n<!--\nWithout that tag, the browser may not be able to load resources\n(images, CSS, scripts) when \"deep linking\" into the app.\nBad things could happen when someone pastes an application link into the\nbrowser's address bar or clicks such a link in an email.\n-->\n<p>이 태그가 없으면 애플리케이션의 \"딥 링크 (deep linking)\" 기능으로 참조하는 이미지 파일이나 CSS, 스크립트 파일을 로드할 수 없습니다.\n그리고 애플리케이션이 동작하던 주소를 브라우저 주소표시줄에 그대로 붙여넣거나 이메일에 있던 링크를 클릭해도 애플리케이션은 제대로 동작하지 않습니다.</p>\n<!--\nSome developers may not be able to add the `<base>` element, perhaps because they don't have\naccess to `<head>` or the `index.html`.\n-->\n<p><code>index.html</code> 파일이나 <code>&#x3C;head></code> 태그를 직접 수정할 수 없는 이유가 있어서 <code>&#x3C;base></code> 엘리먼트를 적용할 수 없을 수도 있습니다.</p>\n<!--\nThose developers may still use HTML5 URLs by taking two remedial steps:\n\n1. Provide the router with an appropriate [APP_BASE_HREF][] value.\n1. Use _root URLs_ for all web resources: CSS, images, scripts, and template HTML files.\n-->\n<p>이 경우에는 다음과 같이 우회하는 방법으로 HTML5 방식의 URL을 사용할 수 있습니다.</p>\n<ol>\n<li>라우터에 [APP_BASE_HREF][] 값을 직접 설정합니다.</li>\n<li>CSS 파일이나 이미지 파일, 스크립트 파일, 템플릿 HTML 파일을 모두 <em>루트 URL</em> 부터 시작하도록 작성합니다.</li>\n</ol>\n<a id=\"hashlocationstrategy\"></a>\n<h4 id=\"hashlocationstrategy\"><em>HashLocationStrategy</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#hashlocationstrategy\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nYou can go old-school with the `HashLocationStrategy` by\nproviding the `useHash: true` in an object as the second argument of the `RouterModule.forRoot`\nin the `AppModule`.\n-->\n<p><code>AppModule</code>에 등록하는 <code>RouterModule.forRoot</code> 메소드에는 두 번째 인자로 옵션을 지정할 수 있는데, 이 객체에 <code><a href=\"api/router/ExtraOptions#useHash\" class=\"code-anchor\">useHash</a>: true</code>를 지정하면 <code><a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a></code> 방식을 사용할 수 있습니다.</p>\n<!--\n<code-example path=\"router/src/app/app.module.6.ts\" linenums=\"false\" header=\"src/app/app.module.ts (hash URL strategy)\">\n-->\n<code-example path=\"router/src/app/app.module.6.ts\" linenums=\"false\" header=\"src/app/app.module.ts (해시 URL 정책)\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }             from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> }        from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> }          from '@angular/forms';\nimport { <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a>, <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a> } from '@angular/router';\n\nimport { AppComponent }          from './app.component';\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\n\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    RouterModule.forRoot(routes, { <a href=\"api/router/ExtraOptions#useHash\" class=\"code-anchor\">useHash</a>: true })  // .../#/crisis-center/\n  ],\n  <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [\n    AppComponent,\n    PageNotFoundComponent\n  ],\n  providers: [\n\n  ],\n  <a href=\"api/core/NgModule#bootstrap\" class=\"code-anchor\">bootstrap</a>: [ AppComponent ]\n})\nexport class AppModule { }\n\n\n</code-example>\n\n\n\n<!-- links to this doc:\n - api/router\n - guide/ajs-quick-reference\n - guide/architecture\n - guide/change-log\n - guide/deployment\n - guide/glossary\n - guide/hierarchical-dependency-injection\n - guide/lazy-loading-ngmodules\n - guide/npm-packages\n - guide/sharing-ngmodules\n - guide/template-syntax\n - guide/testing\n - guide/universal\n - guide/upgrade\n-->\n<!-- links from this doc:\n - api/animations/animate\n - api/animations/animateChild\n - api/animations/animation\n - api/animations/browser/testing/MockAnimationDriver#log\n - api/animations/group\n - api/animations/query\n - api/animations/state\n - api/animations/style\n - api/animations/transition\n - api/animations/trigger\n - api/common/AsyncPipe\n - api/common/CommonModule\n - api/common/HashLocationStrategy\n - api/common/LocationStrategy\n - api/common/NgForOf\n - api/common/NgIf\n - api/common/NumberSymbol#List\n - api/common/PathLocationStrategy\n - api/common/http\n - api/common/http/HttpErrorResponse#message\n - api/core/Component\n - api/core/Component#styleUrls\n - api/core/Component#template\n - api/core/Directive#host\n - api/core/HostBinding\n - api/core/Injectable\n - api/core/Injectable#providedIn\n - api/core/NgModule\n - api/core/NgModule#bootstrap\n - api/core/NgModule#declarations\n - api/core/NgModule#exports\n - api/core/NgModule#imports\n - api/core/OnInit\n - api/core/QueryList#changes\n - api/core/ReflectiveInjector#resolve\n - api/core/SecurityContext#URL\n - api/core/Version#full\n - api/core/ViewEncapsulation#None\n - api/core/testing/async\n - api/forms/DefaultValueAccessor\n - api/forms/FormsModule\n - api/forms/NgModel\n - api/http/RequestMethod#Get\n - api/platform-browser/BrowserModule\n - api/platform-browser/animations/BrowserAnimationsModule\n - api/router/ActivatedRoute\n - api/router/ActivatedRoute#paramMap\n - api/router/ActivatedRouteSnapshot\n - api/router/ActivationEnd\n - api/router/ActivationStart\n - api/router/CanActivate\n - api/router/CanActivateChild\n - api/router/CanDeactivate\n - api/router/CanLoad\n - api/router/ChildActivationEnd\n - api/router/ChildActivationStart\n - api/router/ExtraOptions#enableTracing\n - api/router/ExtraOptions#preloadingStrategy\n - api/router/ExtraOptions#useHash\n - api/router/GuardsCheckEnd\n - api/router/GuardsCheckStart\n - api/router/NavigationCancel\n - api/router/NavigationEnd\n - api/router/NavigationError\n - api/router/NavigationExtras\n - api/router/NavigationExtras#relativeTo\n - api/router/NavigationStart\n - api/router/ParamMap\n - api/router/ParamMap#keys\n - api/router/PreloadAllModules\n - api/router/PreloadingStrategy\n - api/router/Resolve\n - api/router/ResolveEnd\n - api/router/ResolveStart\n - api/router/Route\n - api/router/Route#canActivate\n - api/router/Route#canActivateChild\n - api/router/Route#canDeactivate\n - api/router/Route#canLoad\n - api/router/Route#loadChildren\n - api/router/Route#pathMatch\n - api/router/Route#redirectTo\n - api/router/Route#resolve\n - api/router/RouteConfigLoadEnd\n - api/router/RouteConfigLoadStart\n - api/router/Router\n - api/router/Router#config\n - api/router/Router#events\n - api/router/Router#navigate\n - api/router/RouterLink\n - api/router/RouterLinkActive\n - api/router/RouterLinkActive#routerLinkActiveOptions\n - api/router/RouterLinkWithHref\n - api/router/RouterLinkWithHref#href\n - api/router/RouterModule\n - api/router/RouterModule#forRoot\n - api/router/RouterOutlet\n - api/router/RouterState\n - api/router/RouterStateSnapshot\n - api/router/RouterStateSnapshot#url\n - api/router/Routes\n - api/router/RoutesRecognized\n - api/router/Scroll\n - api/router/Scroll#anchor\n - api/router/Scroll#position\n - api/router/UrlTree\n - api/service-worker/SwPush#messages\n - api/upgrade/static\n - cli\n - cli/generate\n - cli/new\n - guide/animations\n - guide/dependency-injection#bootstrap\n - guide/glossary#view\n - guide/observables-in-angular\n - guide/observables-in-angular#router\n - guide/router#%EB%9D%BC%EC%9A%B0%ED%84%B0-%EC%84%A4%EC%A0%95%EC%9D%84-%EB%9D%BC%EC%9A%B0%ED%8C%85-%EB%AA%A8%EB%93%88-%EB%A1%9C-%EC%98%AE%EA%B8%B0%EA%B8%B0\n - guide/router#1단계--시작하기\n - guide/router#2단계-라우팅-모듈-routing-module\n - guide/router#3단계-정리\n - guide/router#3단계-히어로-기능-모듈\n - guide/router#4단계-위기대응센터-기능모듈\n - guide/router#5단계-라우팅-가드-route-guards\n - guide/router#6단계-비동기-라우팅\n - guide/router#activatedroute-서비스에서-라우팅-변수-참조하기\n - guide/router#appmodule-라우팅-규칙에-위기대응센터-모듈-로드하기\n - guide/router#asynchronous-routing\n - guide/router#authguard-구현하기\n - guide/router#base-href\n - guide/router#base-href-1\n - guide/router#browser-url-styles\n - guide/router#can-activate-child-guard\n - guide/router#can-activate-guard\n - guide/router#can-load-guard\n - guide/router#canactivate-사용자-인증이-필요한-경우\n - guide/router#canactivatechild-자식-라우팅-제어하기\n - guide/router#candeactivate-저장되지-않은-변경사항-체크하기\n - guide/router#canload-가드-로그인하지-않은-사용자의-모듈-로딩-방지하기\n - guide/router#canload는-사전로딩을-막습니다\n - guide/router#child-routing-component\n - guide/router#clear-secondary-routes\n - guide/router#custom-preloading\n - guide/router#example-config\n - guide/router#fragment\n - guide/router#guards\n - guide/router#hashlocationstrategy\n - guide/router#heroes-functionality\n - guide/router#heroes를-superheroes로-변경하기\n - guide/router#html5-방식의-url과-base-href\n - guide/router#inspect-config\n - guide/router#link-parameters-array\n - guide/router#logincomponent-구현하기\n - guide/router#optional-route-parameters\n - guide/router#parammap-api\n - guide/router#parammap-옵저버블과-컴포넌트-재사용\n - guide/router#query-parameters\n - guide/router#redirect\n - guide/router#resolve-guard\n - guide/router#resolve-컴포넌트에-필요한-데이터-미리-가져오기\n - guide/router#reuse\n - guide/router#route-parameters\n - guide/router#routing-module\n - guide/router#routing-module-order\n - guide/router#wildcard\n - guide/router#개요\n - guide/router#개요-1\n - guide/router#관리자-기능-모듈-추가하기\n - guide/router#관리자-모듈로-접근하는-동작-제한하기\n - guide/router#기본내용-정리\n - guide/router#라우터-기본\n - guide/router#라우터-로드하기\n - guide/router#라우터-링크\n - guide/router#라우터-설정\n - guide/router#라우터-설정-확인하기\n - guide/router#라우터-설정을-라우팅-모듈-로-옮기기\n - guide/router#라우터-스테이트-router-state\n - guide/router#라우터-이벤트\n - guide/router#라우터와-라우팅-규칙-등록하기\n - guide/router#라우팅--네비게이션\n - guide/router#라우팅-규칙-정리하기\n - guide/router#라우팅-규칙-정의하기\n - guide/router#라우팅-규칙에-변수-활용하기\n - guide/router#라우팅-모듈-이-꼭-필요한가요\n - guide/router#라우팅-변수\n - guide/router#라우팅-변수-필수일까-생략해도-될까\n - guide/router#라우팅-애니메이션-적용하기\n - guide/router#라우팅-영역-router-outlet\n - guide/router#라우팅-영역-추가하기\n - guide/router#리다이렉트-설정하기\n - guide/router#리다이렉트로-url-마이그레이션-하기\n - guide/router#리스트-화면에서-라우팅-변수-설정하기\n - guide/router#모듈-로드순서-정리하기\n - guide/router#부록\n - guide/router#부록-locationstrategy와-브라우저-url-스타일\n - guide/router#부록-링크-파라미터-배열-link-parameters-array\n - guide/router#사전로딩preloading-기능-모듈을-백그라운드에서-로딩하기\n - guide/router#사전로딩이-동작하는-방식\n - guide/router#상대주소로-이동하기\n - guide/router#상대주소를-사용해서-목록-화면으로-이동하기\n - guide/router#서브-라우팅-규칙-secondary-routes\n - guide/router#서브-라우팅-규칙-추가하기\n - guide/router#서브-라우팅-규칙-해제하기\n - guide/router#서브-라우팅-규칙-활용하기-라우팅-규칙-머지하기\n - guide/router#스냅샷-옵저버블-대신-사용하기\n - guide/router#어떤-방식이-제일-좋은가요\n - guide/router#예제-애플리케이션\n - guide/router#와일드카드-라우팅-규칙\n - guide/router#용어-정리\n - guide/router#위기대응센터-지연로딩하기\n - guide/router#위기대응센터와-자식-라우팅-규칙\n - guide/router#이름을-지정해서-라우팅-영역-여러개-표시하기\n - guide/router#자식-라우팅-규칙\n - guide/router#자식-라우팅-컴포넌트\n - guide/router#정리하기\n - guide/router#중복된-라우팅-규칙-제거하기\n - guide/router#지연로딩-라우팅-규칙-설정\n - guide/router#커스텀-사전로딩-정책\n - guide/router#컴포넌트가-없는-라우팅-규칙-라우팅-규칙을-그룹으로-묶기\n - guide/router#컴포넌트를-라우팅하면서-애니메이션-적용하기\n - guide/router#쿼리-파라미터query-parameters와-프래그먼트fragments-활용하기\n - guide/router#페이지-이동을-취소하고-저장하기\n - guide/router#페이지를-이동하기-전에-데이터-먼저-받아오기\n - guide/router#활성화된-라우터-링크-active-router-links\n - guide/router#활성화된-라우팅-규칙-activated-route\n - guide/router#활성화된-라우팅-규칙-activated-route-활용하기\n - guide/router#히어로-모듈-라우팅\n - guide/router#히어로-모듈-추가하기\n - guide/router#히어로-목록-옵션-라우팅-변수로-히어로-선택하기\n - guide/router#히어로-목록을-표시하는-컴포넌트로-돌아가기\n - guide/router#히어로-컴포넌트-선언-제거하기\n - guide/singleton-services#forroot\n - guide/template-syntax#%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%B0%94%EC%9D%B8%EB%94%A9\n - guide/template-syntax#%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EB%B0%94%EC%9D%B8%EB%94%A9\n - tutorial/toh-pt4\n - http://victorsavkin.com/post/146722301646/angular-router-empty-paths-componentless-routes\n - http://www.w3.org/DesignIssues/MatrixURIs.html\n - https://blog.8thlight.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html\n - https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries\n - https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams\n - https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base\n - https://en.wikipedia.org/wiki/Fragment_identifier\n - https://github.com/angular/angular/edit/master/aio/content/guide/router.md?message=docs%3A%20describe%20your%20change...\n - https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping\n-->"
}