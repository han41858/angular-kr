{
  "id": "guide/property-binding-best-practices",
  "title": "프로퍼티 바인딩 모범 사례",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/property-binding-best-practices.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Property binding best practices\n-->\n<h1 id=\"프로퍼티-바인딩-모범-사례\">프로퍼티 바인딩 모범 사례<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/property-binding-best-practices#프로퍼티-바인딩-모범-사례\"><i class=\"material-icons\">link</i></a></h1>\n<!--\nBy following a few guidelines, you can use property binding in a way that helps you minimize bugs and keep your code readable.\n\n<div class=\"alert is-helpful\">\n\nSee the <live-example name=\"property-binding\"></live-example> for a working example containing the code snippets in this guide.\n\n</div>\n-->\n<p>이 문서는 프로퍼티 바인딩을 사용할 때 지키면 좋은 내용에 대해 설명합니다.\n버그를 줄이고 가독성을 높이는 데에 도움이 될 것입니다.</p>\n<div class=\"alert is-helpful\">\n<p>이 문서에서 설명하는 내용은 <live-example name=\"property-binding\"></live-example>에서 직접 확인하거나 다운받아 확인할 수 있습니다.</p>\n</div>\n<!--\n## Avoid side effects\n-->\n<h2 id=\"부수-효과-피하기\">부수 효과 피하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/property-binding-best-practices#부수-효과-피하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nEvaluation of a template expression should have no visible side effects.\nUse the syntax for template expressions to help avoid side effects.\nIn general, the correct syntax prevents you from assigning a value to anything in a property binding expression.\nThe syntax also prevents you from using increment and decrement operators.\n-->\n<p>템플릿 표현식은 부수 효과(side effects)를 발생시키지 않는 것이 좋습니다.\n그리고 템플릿 표현식 문법도 부수 효과를 발생시키지 않는 방향으로 제공됩니다.\n그래서 프로퍼티 바인딩 표현식에서는 값을 할당하는 문법은 사용할 수 없습니다.\n같은 이유로 템플릿 표현식에는 증감 연산자도 사용할 수 없습니다.</p>\n<!--\n### An example of producing side effects\n-->\n<h3 id=\"부수-효과를-유발하는-경우\">부수 효과를 유발하는 경우<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/property-binding-best-practices#부수-효과를-유발하는-경우\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIf you had an expression that changed the value of something else that you were binding to, that change of value would be a side effect.\nAngular might or might not display the changed value.\nIf Angular does detect the change, it throws an error.\n\nAs a best practice, use only properties and methods that return values.\n-->\n<p>템플릿 표현식에서 바인딩한 대상 이외의 값을 변경하는 경우에는 부수 효과가 발생할 수 있습니다.\nAngular가 이런 경우를 감지하면 에러를 발생시킵니다.</p>\n<p>프로퍼티를 단순하게 지정하거나 값을 반환하는 메서드를 사용하는 것이 가장 좋습니다.</p>\n<!--\n## Return the proper type\n-->\n<h2 id=\"정확한-타입-반환하기\">정확한 타입 반환하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/property-binding-best-practices#정확한-타입-반환하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nA template expression should evaluate to the type of value that the target property expects.\nFor example, return a string if the target property expects a string, a number if it expects a number, or an object if it expects an object.\n-->\n<p>템플릿 표현식이 평가된 결과는 바인딩 대상 프로퍼티의 타입과 같아야 합니다.\n바인딩 대상 프로퍼티가 문자열이라면 템플릿 표현식도 문자열을 반환해야 하며, 숫자, 객체인 경우도 마찬가지입니다.</p>\n<!--\n### Passing in a string\n-->\n<h3 id=\"문자열-전달하기\">문자열 전달하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/property-binding-best-practices#문자열-전달하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn the following example, the `childItem` property of the `ItemDetailComponent` expects a string.\n\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"model-property-binding\" header=\"src/app/app.component.html\">\n&lt;app-item-detail [childItem]=&quot;parentItem&quot;&gt;&lt;/app-item-detail&gt;\n\n</code-example>\n\nYou can confirm this expectation by looking in the `ItemDetailComponent` where the `@Input()` type is `string`:\n\n<code-example path=\"property-binding/src/app/item-detail/item-detail.component.ts\" region=\"input-type\" header=\"src/app/item-detail/item-detail.component.ts (setting the @Input() type)\">\n@Input() childItem: string;\n\n</code-example>\n\nThe `parentItem` in `AppComponent` is a string, which means that the expression, `parentItem` within `[childItem]=\"parentItem\"`, evaluates to a string.\n\n<code-example path=\"property-binding/src/app/app.component.ts\" region=\"parent-data-type\" header=\"src/app/app.component.ts\">\nparentItem = &#39;lamp&#39;;\n\n</code-example>\n\nIf `parentItem` were some other type, you would need to specify `childItem`  `@Input()` as that type as well.\n-->\n<p>아래 예제에서 <code>ItemDetailComponent</code>에 있는 <code>childItem</code> 프로퍼티는 문자열을 받아야 합니다.</p>\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"model-property-binding\" header=\"src/app/app.component.html\">\n&#x3C;app-item-detail [childItem]=\"parentItem\">&#x3C;/app-item-detail>\n\n</code-example>\n<p>이 타입은 <code>ItemDetailComponent</code>에 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터가 붙은 <code>childItem</code> 프로퍼티 타입이 <code>string</code>인 것으로도 확인할 수 있습니다:</p>\n<code-example path=\"property-binding/src/app/item-detail/item-detail.component.ts\" region=\"input-type\" header=\"src/app/item-detail/item-detail.component.ts (@Input() 프로퍼티에 지정된 타입)\">\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() childItem: string;\n\n</code-example>\n<p><code>AppComponent</code>에 정의된 <code>parentItem</code> 프로퍼티 타입은 문자열입니다.\n그래서 <code>[childItem]=\"parentItem\"</code>에 사용된 <code>parentItem</code>도 문자열로 평가됩니다.</p>\n<code-example path=\"property-binding/src/app/app.component.ts\" region=\"parent-data-type\" header=\"src/app/app.component.ts\">\nparentItem = 'lamp';\n\n</code-example>\n<p>만약 <code>parentItem</code>을 다른 타입으로 변경하면 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터가 지정된 <code>childItem</code> 타입도 변경되어야 합니다.</p>\n<!--\n### Passing in an object\n-->\n<h3 id=\"객체-전달하기\">객체 전달하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/property-binding-best-practices#객체-전달하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn this example, `ItemListComponent` is a child component of `AppComponent` and the `items` property expects an array of objects.\n\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"pass-object\" header=\"src/app/app.component.html\">\n&lt;app-item-list [items]=&quot;currentItems&quot;&gt;&lt;/app-item-list&gt;\n\n</code-example>\n\nIn the `ItemListComponent` the `@Input()`, `items`, has a type of `Item[]`.\n\n<code-example path=\"property-binding/src/app/item-list/item-list.component.ts\" region=\"item-input\" header=\"src/app/item-list.component.ts\">\n@Input() items: Item[];\n\n</code-example>\n\nNotice that `Item` is an object that it has two properties; an `id` and a `name`.\n\n<code-example path=\"property-binding/src/app/item.ts\" region=\"item-class\" header=\"src/app/item.ts\">\nexport interface Item {\n  id: number;\n  name: string;\n}\n\n</code-example>\n\nIn `app.component.ts`, `currentItems` is an array of objects in the same shape as the `Item` object in `items.ts`, with an `id` and a `name`.\n\n<code-example path=\"property-binding/src/app/app.component.ts\" region=\"pass-object\" header=\"src/app.component.ts\">\ncurrentItems = [{\n  id: 21,\n  name: &#39;phone&#39;\n}];\n\n</code-example>\n\nBy supplying an object in the same shape, you satisfy the expectations of `items` when Angular evaluates the expression `currentItems`.\n-->\n<p>예제로 다루는 <code>ItemListComponent</code>는 <code>AppComponent</code>의 자식 컴포넌트이며 <code>items</code> 프로퍼티는 객체 배열을 받아야 합니다.</p>\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"pass-object\" header=\"src/app/app.component.html\">\n&#x3C;app-item-list [items]=\"currentItems\">&#x3C;/app-item-list>\n\n</code-example>\n<p><code>ItemListComponent</code>에서 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터가 지정된 <code>items</code> 타입도 <code>Item[]</code> 타입입니다.</p>\n<code-example path=\"property-binding/src/app/item-list/item-list.component.ts\" region=\"item-input\" header=\"src/app/item-list.component.ts\">\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() items: Item[];\n\n</code-example>\n<p><code>Item</code> 객체에는 프로퍼티가 <code>id</code>, <code>name</code> 이렇게 2개 있습니다.</p>\n<code-example path=\"property-binding/src/app/item.ts\" region=\"item-class\" header=\"src/app/item.ts\">\nexport interface Item {\n  id: number;\n  name: string;\n}\n\n</code-example>\n<p><code>app.component.ts</code>에서 <code>currentItems</code>는 객체 배열이며 <code>items.ts</code>에 정의된 <code>Item</code> 모양과 똑같이 <code>id</code> 프로퍼티와 <code>name</code> 프로퍼티가 있습니다.</p>\n<code-example path=\"property-binding/src/app/app.component.ts\" region=\"pass-object\" header=\"src/app.component.ts\">\ncurrentItems = [{\n  id: 21,\n  name: 'phone'\n}];\n\n</code-example>\n<p>그래서 객체의 형식이 같기 때문에 <code>currentItems</code> 표현식이 평가된 결과를 <code>items</code>에 바인딩할 수 있습니다.</p>\n\n</div>\n\n<!-- links to this doc:\n - guide/property-binding\n-->\n<!-- links from this doc:\n - api/core/Input\n - guide/property-binding-best-practices#객체-전달하기\n - guide/property-binding-best-practices#문자열-전달하기\n - guide/property-binding-best-practices#부수-효과-피하기\n - guide/property-binding-best-practices#부수-효과를-유발하는-경우\n - guide/property-binding-best-practices#정확한-타입-반환하기\n - guide/property-binding-best-practices#프로퍼티-바인딩-모범-사례\n - https://github.com/angular/angular/edit/master/aio/content/guide/property-binding-best-practices.md?message=docs%3A%20describe%20your%20change...\n-->"
}