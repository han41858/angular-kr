{
  "id": "guide/dependency-injection-navtree",
  "title": "컴포넌트 트리 참조하기",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/dependency-injection-navtree.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Navigate the component tree with DI\n-->\n<h1 id=\"컴포넌트-트리-참조하기\">컴포넌트 트리 참조하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#컴포넌트-트리-참조하기\"><i class=\"material-icons\">link</i></a></h1>\n<!--\n<div class=\"callout is-critical\">\n<header>Marked for archiving</header>\n\nTo ensure that you have the best experience possible, this topic is marked for archiving until we determine\nthat it clearly conveys the most accurate information possible.\n\nIn the meantime, this topic might be helpful: [Hierarchical injectors](guide/hierarchical-dependency-injection).\n\nIf you think this content should not be archived, please file a [GitHub issue](https://github.com/angular/angular/issues/new?template=3-docs-bug.md).\n\n</div>\n\nApplication components often need to share information.\nYou can often use loosely coupled techniques for sharing information,\nsuch as data binding and service sharing,\nbut sometimes it makes sense for one component to have a direct reference to another component.\nYou need a direct reference, for instance, to access values or call methods on that component.\n\nObtaining a component reference is a bit tricky in Angular.\nAngular components themselves do not have a tree that you can\ninspect or navigate programmatically. The parent-child relationship is indirect,\nestablished through the components' [view objects](guide/glossary#view).\n\nEach component has a *host view*, and can have additional *embedded views*.\nAn embedded view in component A is the\nhost view of component B, which can in turn have embedded view.\nThis means that there is a [view hierarchy](guide/glossary#view-hierarchy) for each component,\nof which that component's host view is the root.\n\nThere is an API for navigating *down* the view hierarchy.\nCheck out `Query`, `QueryList`, `ViewChildren`, and `ContentChildren`\nin the [API Reference](api/).\n\nThere is no public API for acquiring a parent reference.\nHowever, because every component instance is added to an injector's container,\nyou can use Angular dependency injection to reach a parent component.\n\nThis section describes some techniques for doing that.\n-->\n<div class=\"callout is-critical\">\n<header>Marked for archiving</header>\n<p>To ensure that you have the best experience possible, this topic is marked for archiving until we determine\nthat it clearly conveys the most accurate information possible.</p>\n<p>In the meantime, this topic might be helpful: <a href=\"guide/hierarchical-dependency-injection\">Hierarchical injectors</a>.</p>\n<p>If you think this content should not be archived, please file a <a href=\"https://github.com/angular/angular/issues/new?template=3-docs-bug.md\">GitHub issue</a>.</p>\n</div>\n<p>애플리케이션에 있는 컴포넌트들은 서로 데이터를 공유하기도 합니다.\n이 때 컴포넌트에 데이터를 바인딩하거나 서비스를 공유하면 컴포넌트간 결합도를 높이지 않으면서도 데이터를 공유할 수 있지만, 때로는 필요한 컴포넌트를 직접 값을 참조하거나 이 컴포넌트에 있는 함수를 실행하는 것이 편할 때도 있습니다.</p>\n<p>Angular에서도 약간의 트릭을 활용하면 컴포넌트를 직접 참조할 수 있습니다.\n다만, Angular 컴포넌트에는 트리 정보가 없습니다. 부모-자식 연결 관계는 간접적이며, 컴포넌트의 <a href=\"guide/glossary#view\">뷰 객체</a>를 통해서만 연결됩니다.</p>\n<p>컴포넌트에는 <em>호스트 뷰(host view)</em>가 존재하며, 추가로 <em>내장 뷰(embedded view)</em>가 존재할 수도 있습니다.\n컴포넌트 A의 내장 뷰는 컴포넌트 B의 호스트 뷰가 될 수 있으며, 컴포넌트 B의 내장 뷰는 또 다른 호스트 뷰가 될 수 있습니다.\n다르게 표현하면, 컴포넌트에는 <a href=\"guide/glossary#view-hierarchy\">뷰 계층(view hierarchy)</a>이 존재하며 컴포넌트 호스트 뷰는 또 다른 컴포넌트의 부모가 될 수 있습니다.</p>\n<p>뷰 계층을 <em>따라 내려가면서</em> 자식 컴포넌트를 참조할 수 있는 API는 몇 개가 있습니다.\n<a href=\"api/\">API 문서</a>에서 <code><a href=\"api/core/Query\" class=\"code-anchor\">Query</a></code>, <code><a href=\"api/core/QueryList\" class=\"code-anchor\">QueryList</a></code>, <code><a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code>, <code><a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code>을 찾아 보세요.</p>\n<p>부모 컴포넌트를 참조할 수 있는 API는 따로 없습니다.\n하지만 모든 컴포넌트 인스턴스는 인젝터 컨테이너에 등록되기 때문에, Angular 의존성 주입 메커니즘을 활용하면 부모 컴포넌트를 찾을 수 있습니다.</p>\n<p>이 문서는 이 테크닉에 대해 소개합니다.</p>\n<a id=\"find-parent\"></a>\n<a id=\"known-parent\"></a>\n<!--\n### Find a parent component of known type\n-->\n<h3 id=\"타입으로-부모-컴포넌트-찾기\">타입으로 부모 컴포넌트 찾기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#타입으로-부모-컴포넌트-찾기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou use standard class injection to acquire a parent component whose type you know.\n\nIn the following example, the parent `AlexComponent` has several children including a `CathyComponent`:\n-->\n<p>부모 컴포넌트의 타입을 알고 있다면 클래스를 주입하는 일반적인 방법으로 부모 컴포넌트를 참조할 수 있습니다.</p>\n<p>아래 예제 코드에서 부모 컴포넌트인 <code>AlexComponent</code>에는 <code>CathyComponent</code>와 같은 자식 컴포넌트가 몇 개 존재합니다:</p>\n<a id=\"alex\"></a>\n<!--\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-1\" header=\"parent-finder.component.ts (AlexComponent v.1)\">\n@Component({\n  selector: &#39;alex&#39;,\n  template: `\n    &lt;div class=&quot;a&quot;&gt;\n      &lt;h3&gt;{{name}}&lt;/h3&gt;\n      &lt;cathy&gt;&lt;/cathy&gt;\n      &lt;craig&gt;&lt;/craig&gt;\n      &lt;carol&gt;&lt;/carol&gt;\n    &lt;/div&gt;`,\n})\nexport class AlexComponent extends Base\n{\n  name = &#39;Alex&#39;;\n}\n\n</code-example>\n\n\n\n*Cathy* reports whether or not she has access to *Alex*\nafter injecting an `AlexComponent` into her constructor:\n\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"cathy\" header=\"parent-finder.component.ts (CathyComponent)\">\n@Component({\n  selector: &#39;cathy&#39;,\n  template: `\n  &lt;div class=&quot;c&quot;&gt;\n    &lt;h3&gt;Cathy&lt;/h3&gt;\n    {{alex ? &#39;Found&#39; : &#39;Did not find&#39;}} Alex via the component class.&lt;br&gt;\n  &lt;/div&gt;`\n})\nexport class CathyComponent {\n  constructor( @Optional() public alex?: AlexComponent ) { }\n}\n\n</code-example>\n\n\n\nNotice that even though the [@Optional](guide/dependency-injection-in-action#optional) qualifier\nis there for safety,\nthe <live-example name=\"dependency-injection-in-action\"></live-example>\nconfirms that the `alex` parameter is set.\n-->\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-1\" header=\"parent-finder.component.ts (AlexComponent v.1)\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'alex',\n  template: `\n    &#x3C;div class=\"a\">\n      &#x3C;h3>{{name}}&#x3C;/h3>\n      &#x3C;cathy>&#x3C;/cathy>\n      &#x3C;craig>&#x3C;/craig>\n      &#x3C;carol>&#x3C;/carol>\n    &#x3C;/div>`,\n})\nexport class AlexComponent extends Base\n{\n  name = 'Alex';\n}\n\n</code-example>\n<p>그러면 생성자를 통해 <code>AlexComponent</code>를 주입할 수 있으며, <em>Cathy</em>가 <em>Alex</em>를 찾았는지 여부는 템플릿에 다음과 같이 표시할 수 있습니다:</p>\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"cathy\" header=\"parent-finder.component.ts (CathyComponent)\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'cathy',\n  template: `\n  &#x3C;div class=\"c\">\n    &#x3C;h3>Cathy&#x3C;/h3>\n    {{alex ? 'Found' : 'Did not find'}} Alex via the component class.&#x3C;br>\n  &#x3C;/div>`\n})\nexport class CathyComponent {\n  constructor( @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public alex?: AlexComponent ) { }\n}\n\n</code-example>\n<p>이 코드에는 <a href=\"guide/dependency-injection-in-action#optional\">@Optional</a> 데코레이터가 사용되었지만, 이와 관계없이 <live-example name=\"dependency-injection-in-action\"></live-example>를 확인해보면 <code>alex</code> 인자에 부모 컴포넌트가 제대로 할당되는 것을 확인할 수 있습니다.</p>\n<a id=\"base-parent\"></a>\n<!--\n### Unable to find a parent by its base class\n-->\n<h3 id=\"부모-클래스가-상속받은-클래스로는-참조할-수-없습니다\">부모 클래스가 상속받은 클래스로는 참조할 수 없습니다.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#부모-클래스가-상속받은-클래스로는-참조할-수-없습니다\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nWhat if you *don't* know the concrete parent component class?\n\nA re-usable component might be a child of multiple components.\nImagine a component for rendering breaking news about a financial instrument.\nFor business reasons, this news component makes frequent calls\ndirectly into its parent instrument as changing market data streams by.\n\nThe app probably defines more than a dozen financial instrument components.\nIf you're lucky, they all implement the same base class\nwhose API your `NewsComponent` understands.\n\n\n<div class=\"alert is-helpful\">\n\n\n\nLooking for components that implement an interface would be better.\nThat's not possible because TypeScript interfaces disappear\nfrom the transpiled JavaScript, which doesn't support interfaces.\nThere's no artifact to look for.\n\n</div>\n\n\n\nThis isn't necessarily good design.\nThis example is examining *whether a component can\ninject its parent via the parent's base class*.\n\nThe sample's `CraigComponent` explores this question. [Looking back](#alex),\nyou see that the `Alex` component *extends* (*inherits*) from a class named `Base`.\n\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-class-signature\" header=\"parent-finder.component.ts (Alex class signature)\">\nexport class AlexComponent extends Base\n\n</code-example>\n\n\n\nThe `CraigComponent` tries to inject `Base` into its `alex` constructor parameter and reports if it succeeded.\n\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"craig\" header=\"parent-finder.component.ts (CraigComponent)\">\n@Component({\n  selector: &#39;craig&#39;,\n  template: `\n  &lt;div class=&quot;c&quot;&gt;\n    &lt;h3&gt;Craig&lt;/h3&gt;\n    {{alex ? &#39;Found&#39; : &#39;Did not find&#39;}} Alex via the base class.\n  &lt;/div&gt;`\n})\nexport class CraigComponent {\n  constructor( @Optional() public alex?: Base ) { }\n}\n\n</code-example>\n\n\n\nUnfortunately, this doesn't work.\nThe <live-example name=\"dependency-injection-in-action\"></live-example>\nconfirms that the `alex` parameter is null.\n*You cannot inject a parent by its base class.*\n-->\n<p>부모 컴포넌트의 정확한 클래스를 <em>몰라도</em> 가능할까요?</p>\n<p>재사용하기 위해 만든 컴포넌트라면 여러 컴포넌트의 자식 컴포넌트로 존재할 수도 있습니다.\n금융 앱에서 뉴스를 제공하는 컴포넌트가 있다고 합시다.\n이 뉴스 컴포넌트는 부모 컴포넌트를 직접 참조하고 메소드를 실행해서 데이터를 받아오는 구조로 구현되었습니다.</p>\n<p>이 앱에는 금융 업무와 관련된 컴포넌트가 아주 많이 정의되어 있을 수도 있습니다.\n그리고 이 컴포넌트들이 모두 <code>NewsComponent</code>가 알고 있는 API를 가진 어떤 기본 클래스를 상속받아 구현된다고 합시다.</p>\n<div class=\"alert is-helpful\">\n<p>인터페이스를 사용해도 컴포넌트를 찾을 수 있지 않을까 생각해 볼 수 있습니다.\n하지만 인터페이스는 TypeScript에만 존재하며 애플리케이션 코드가 JavaScript로 변환되고 나면 인터페이스의 개념은 사라집니다.\n찾아야 할 타입이 없어지는 셈입니다.</p>\n</div>\n<p>하지만 이런 구조는 좋은 디자인이 아닙니다.\n<em>부모 클래스가 상속받는 클래스를</em> 생성자에 주입하는 예제를 살펴봅시다.</p>\n<p>이번 섹션은 <code>CraigComponent</code>를 사용해서 확인합니다.\n<a href=\"guide/dependency-injection-navtree#alex\">이전에 본 것과 마찬가지로</a> <code>AlexComponent</code>는 <code>Base</code> 클래스를 상속받아 구현한 클래스입니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-class-signature\" header=\"parent-finder.component.ts (Alex 클래스 선언부)\">\nexport class AlexComponent extends Base\n\n</code-example>\n<p>그리고 <code>CraigComponent</code>는 <code>Base</code> 타입으로 <code>alex</code>에 부모 컴포넌트를 주입하려고 하며, 부모 컴포넌트를 찾았는지 여부는 템플릿에 표시합니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"craig\" header=\"parent-finder.component.ts (CraigComponent)\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'craig',\n  template: `\n  &#x3C;div class=\"c\">\n    &#x3C;h3>Craig&#x3C;/h3>\n    {{alex ? 'Found' : 'Did not find'}} Alex via the base class.\n  &#x3C;/div>`\n})\nexport class CraigComponent {\n  constructor( @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public alex?: Base ) { }\n}\n\n</code-example>\n<p>하지만 이 코드는 동작하지 않습니다.\n<live-example name=\"dependency-injection-in-action\"></live-example>에서도 확인할 수 있듯이 <code>alex</code>에 할당되는 값은 <code>null</code>입니다.\n<em>부모 객체가 상속하는 클래스 타입</em> 으로는 부모 컴포넌트를 주입할 수 없습니다.</p>\n<a id=\"class-interface-parent\"></a>\n<!--\n### Find a parent by its class interface\n-->\n<h3 id=\"클래스-인터페이스로-부모-컴포넌트-찾기\">클래스 인터페이스로 부모 컴포넌트 찾기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#클래스-인터페이스로-부모-컴포넌트-찾기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou can find a parent component with a [class interface](guide/dependency-injection-in-action#class-interface).\n\nThe parent must cooperate by providing an *alias* to itself in the name of a class interface token.\n\nRecall that Angular always adds a component instance to its own injector;\nthat's why you could inject *Alex* into *Cathy* [earlier](#known-parent).\n\nWrite an [*alias provider*](guide/dependency-injection-in-action#useexisting)&mdash;a `provide` object literal with a `useExisting`\ndefinition&mdash;that creates an *alternative* way to inject the same component instance\nand add that provider to the `providers` array of the `@Component()` metadata for the `AlexComponent`.\n-->\n<p><a href=\"guide/dependency-injection-in-action#class-interface\">클래스 인터페이스</a>를 사용해도 부모 컴포넌트를 찾을 수 있습니다.</p>\n<p>이 때 부모 컴포넌트는 반드시 이 클래스 인터페이스 토큰을 사용해서 <em>별칭 프로바이더</em>로 등록되어 있어야 합니다.</p>\n<p>Angular는 컴포넌트 인스턴스를 이 컴포넌트의 인젝터에 관리한다는 것을 떠올려 보세요.\n그래서 <a href=\"guide/dependency-injection-navtree#known-parent\">이전</a>에 살펴봤던 것처럼 <em>Alex</em>를 <em>Cathy</em>에 의존성으로 주입할 수 있었던 것입니다.</p>\n<p>컴포넌트 인스턴스가 공유되는 것을 피하기 위해 <code>AlexComponent</code>의 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 메타데이터 <code>providers</code> 배열에 <code>useExisting</code>을 사용해서 <a href=\"guide/dependency-injection-in-action#useexisting\"><em>별칭 프로바이더</em></a>를 다음과 같이 등록합니다.</p>\n<a id=\"alex-providers\"></a>\n<!--\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-providers\" header=\"parent-finder.component.ts (AlexComponent providers)\">\nproviders: [{ provide: Parent, useExisting: forwardRef(() =&gt; AlexComponent) }],\n\n</code-example>\n\n\n[Parent](#parent-token) is the provider's class interface token.\nThe [*forwardRef*](guide/dependency-injection-in-action#forwardref) breaks the circular reference you just created by having the `AlexComponent` refer to itself.\n\n*Carol*, the third of *Alex*'s child components, injects the parent into its `parent` parameter,\nthe same way you've done it before.\n\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"carol-class\" header=\"parent-finder.component.ts (CarolComponent class)\">\nexport class CarolComponent {\n  name = &#39;Carol&#39;;\n  constructor( @Optional() public parent?: Parent ) { }\n}\n\n</code-example>\n\n\n\nHere's *Alex* and family in action.\n\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/dependency-injection-in-action/alex.png\" alt=\"Alex in action\">\n</div>\n-->\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-providers\" header=\"parent-finder.component.ts (AlexComponent providers 배열)\">\nproviders: [{ provide: Parent, useExisting: <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() => AlexComponent) }],\n\n</code-example>\n<p>이 코드에서 <a href=\"guide/dependency-injection-navtree#parent-token\">Parent</a> 토큰은 프로바이더의 클래스 인터페이스 토큰입니다.\n그리고 <code>AlexComponent</code>가 자신을 직접 참조해서 순환 참조가 발생하는 것을 피하기 위해 <a href=\"guide/dependency-injection-in-action#forwardref\"><em>forwardRef</em></a>를 사용했습니다.</p>\n<p>그러면 <em>Alex</em>의 자식 컴포넌트인 <em>Carol</em>은 이전에 살펴봤던 것과 마찬가지 방법으로 <code>parent</code> 인자에 부모 컴포넌트를 주입받을 수 있습니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"carol-class\" header=\"parent-finder.component.ts (CarolComponent 클래스)\">\nexport class CarolComponent {\n  name = 'Carol';\n  constructor( @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public parent?: Parent ) { }\n}\n\n</code-example>\n<p>이제 <em>Alex</em> 컴포넌트를 실행하면 다음 그림처럼 동작하는 것을 확인할 수 있습니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/dependency-injection-in-action/alex.png\" alt=\"Alex in action\" width=\"302\" height=\"374\">\n</div>\n<a id=\"parent-tree\"></a>\n<!--\n### Find a parent in a tree with _@SkipSelf()_\n-->\n<h3 id=\"skipself-로-부모-컴포넌트-찾기\"><em>@SkipSelf()</em> 로 부모 컴포넌트 찾기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#skipself-로-부모-컴포넌트-찾기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nImagine one branch of a component hierarchy: *Alice* -> *Barry* -> *Carol*.\nBoth *Alice* and *Barry* implement the `Parent` class interface.\n\n*Barry* is the problem. He needs to reach his parent, *Alice*, and also be a parent to *Carol*.\nThat means he must both *inject* the `Parent` class interface to get *Alice* and\n*provide* a `Parent` to satisfy *Carol*.\n\nHere's *Barry*.\n\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"barry\" header=\"parent-finder.component.ts (BarryComponent)\">\nconst templateB = `\n  &lt;div class=&quot;b&quot;&gt;\n    &lt;div&gt;\n      &lt;h3&gt;{{name}}&lt;/h3&gt;\n      &lt;p&gt;My parent is {{parent?.name}}&lt;/p&gt;\n    &lt;/div&gt;\n    &lt;carol&gt;&lt;/carol&gt;\n    &lt;chris&gt;&lt;/chris&gt;\n  &lt;/div&gt;`;\n\n@Component({\n  selector:   &#39;barry&#39;,\n  template:   templateB,\n  providers:  [{ provide: Parent, useExisting: forwardRef(() =&gt; BarryComponent) }]\n})\nexport class BarryComponent implements Parent {\n  name = &#39;Barry&#39;;\n  constructor( @SkipSelf() @Optional() public parent?: Parent ) { }\n}\n\n</code-example>\n\n\n\n*Barry*'s `providers` array looks just like [*Alex*'s](#alex-providers).\nIf you're going to keep writing [*alias providers*](guide/dependency-injection-in-action#useexisting) like this you should create a helper function.\n\nFor now, focus on *Barry*'s constructor.\n\n<code-tabs>\n\n  <code-pane header=\"Barry's constructor\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"barry-ctor\">\nconstructor( @SkipSelf() @Optional() public parent?: Parent ) { }\n\n</code-pane>\n\n  <code-pane header=\"Carol's constructor\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"carol-ctor\">\nconstructor( @Optional() public parent?: Parent ) { }\n\n</code-pane>\n\n</code-tabs>\n\n\nIt's identical to *Carol*'s constructor except for the additional `@SkipSelf` decorator.\n\n`@SkipSelf` is essential for two reasons:\n\n1. It tells the injector to start its search for a `Parent` dependency in a component *above* itself,\nwhich *is* what parent means.\n\n2. Angular throws a cyclic dependency error if you omit the `@SkipSelf` decorator.\n\n  `NG0200: Circular dependency in DI detected for BethComponent. Dependency path: BethComponent -> Parent -> BethComponent`\n\nHere's *Alice*, *Barry*, and family in action.\n\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/dependency-injection-in-action/alice.png\" alt=\"Alice in action\">\n</div>\n-->\n<p>컴포넌트 계층이 <em>Alice</em> -> <em>Barry</em> -> <em>Carol</em>와 같이 구성되어 있다고 합시다.\n이 때 <em>Alice</em>와 <em>Barry</em>는 둘 다 <code>Parent</code> 클래스 인터페이스로 구현되었습니다.</p>\n<p>이 때 <em>Barry</em>가 문제입니다. <em>Barry</em>는 부모 컴포넌트인 <em>Alice</em>를 찾으려고 하지만, <em>Barry</em> 역시 <em>Carol</em>의 부모 컴포넌트입니다.\n그래서 <em>Barry</em>가 부모 컴포넌트인 <em>Alice</em>를 찾고, <em>Carol</em>도 부모 컴포넌트인 <em>Barry</em>를 찾을 수 있으려면 프로바이더를 조정해야 합니다.</p>\n<p><em>Barry</em>는 이렇게 구현되어 있습니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"barry\" header=\"parent-finder.component.ts (BarryComponent)\">\nconst templateB = `\n  &#x3C;div class=\"b\">\n    &#x3C;div>\n      &#x3C;h3>{{name}}&#x3C;/h3>\n      &#x3C;p>My parent is {{parent?.name}}&#x3C;/p>\n    &#x3C;/div>\n    &#x3C;carol>&#x3C;/carol>\n    &#x3C;chris>&#x3C;/chris>\n  &#x3C;/div>`;\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector:   'barry',\n  template:   templateB,\n  providers:  [{ provide: Parent, useExisting: <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() => BarryComponent) }]\n})\nexport class BarryComponent implements Parent {\n  name = 'Barry';\n  constructor( @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public parent?: Parent ) { }\n}\n\n</code-example>\n<p><em>Barry</em>의 <code>providers</code> 설정은 <a href=\"guide/dependency-injection-navtree#alex-providers\"><em>Alex</em>에 설정한 것</a>과 같습니다.\n하지만 <a href=\"guide/dependency-injection-in-action#useexisting\"><em>별칭 프로바이더</em></a>를 사용한다면 <em>Alex</em>와 <em>Barry</em>를 구별하기 위해 헬퍼 함수를 사용할 수 밖에 없습니다.</p>\n<code-tabs>\n\n  <code-pane header=\"Barry&#x27;s constructor\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"barry-ctor\">\nconstructor( @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public parent?: Parent ) { }\n\n</code-pane>\n\n  <code-pane header=\"Carol&#x27;s constructor\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"carol-ctor\">\nconstructor( @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public parent?: Parent ) { }\n\n</code-pane>\n\n</code-tabs>\n<p><code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 데코레이터가 사용된 것만 빼면 <em>Barry</em>의 생성자와 <em>Carol</em>의 생성자는 동일합니다.</p>\n<p>이 코드에서 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code>는 두가지 역할을 합니다:</p>\n<ol>\n<li>\n<p>의존성 객체로 요청받은 <code>Parent</code>를 이 컴포넌트 <em>위부터</em> 찾도록 지정합니다. 이 경우는 <em>Barry</em>에 지정했기 때문에 <em>Alex</em>에서부터 찾습니다.</p>\n</li>\n<li>\n<p>순환 참조를 방지할 수 있습니다. <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 데코레이터가 없으면 다음과 같은 에러가 발생합니다.</p>\n<p><code>NG0200: Circular dependency in DI detected for BethComponent. Dependency path: BethComponent -> Parent -> BethComponent</code></p>\n</li>\n</ol>\n<p>이제 <em>Alice</em>, <em>Barry</em>, <em>Barry</em>의 가족 컴포넌트들은 다음과 같이 동작합니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/dependency-injection-in-action/alice.png\" alt=\"Alice in action\" width=\"298\" height=\"631\">\n</div>\n<a id=\"parent-token\"></a>\n<!--\n###  Parent class interface\n-->\n<h3 id=\"부모-클래스-인터페이스\">부모 클래스 인터페이스<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#부모-클래스-인터페이스\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou [learned earlier](guide/dependency-injection-in-action#class-interface) that a class interface is an abstract class used as an interface rather than as a base class.\n\nThe example defines a `Parent` class interface.\n\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"parent\" header=\"parent-finder.component.ts (Parent class-interface)\">\nexport abstract class Parent { name: string; }\n\n</code-example>\n\n\n\nThe `Parent` class interface defines a `name` property with a type declaration but *no implementation*.\nThe `name` property is the only member of a parent component that a child component can call.\nSuch a narrow interface helps decouple the child component class from its parent components.\n\nA component that could serve as a parent *should* implement the class interface as the `AliceComponent` does.\n\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alice-class-signature\" header=\"parent-finder.component.ts (AliceComponent class signature)\">\nexport class AliceComponent implements Parent\n\n</code-example>\n\n\n\nDoing so adds clarity to the code. But it's not technically necessary.\nAlthough `AlexComponent` has a `name` property, as required by its `Base` class,\nits class signature doesn't mention `Parent`.\n\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-class-signature\" header=\"parent-finder.component.ts (AlexComponent class signature)\">\nexport class AlexComponent extends Base\n\n</code-example>\n\n\n\n<div class=\"alert is-helpful\">\n\n\n\n`AlexComponent` *should* implement `Parent` as a matter of proper style.\nIt doesn't in this example *only* to demonstrate that the code will compile and run without the interface.\n\n\n</div>\n-->\n<p><a href=\"guide/dependency-injection-in-action#class-interface\">이전 문서에서</a> 클래스 인터페이스는 추상 클래스이며, 상속받기 위해 사용하는 것이 아니라 의존성을 주입할 때 사용하는 것이라고 언급했었습니다.</p>\n<p>그리고 <code>Parent</code> 클래스 인터페이스는 다음과 같이 구현되어 있습니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"parent\" header=\"parent-finder.component.ts (부모 클래스 인터페이스)\">\nexport abstract class Parent { name: string; }\n\n</code-example>\n<p><code>Parent</code> 클래스 인터페이스에는 타입이 지정된 <code>name</code> 프로퍼티가 존재하지만 <em>이 클래스에 구현된 내용은 아무것도 없습니다</em>.\n<code>name</code> 프로퍼티는 자식 컴포넌트가 참조할 수 있는 부모 컴포넌트의 멤버일 뿐입니다.\n이렇게 클래스 인터페이스로 API를 제한하면 부모 컴포넌트와 자식 컴포넌트의 결합도를 낮출 수 있습니다.</p>\n<p>그러면 부모 컴포넌트는 반드시 이 클래스 인터페이스를 사용해서 구현해야 합니다. <code>AliceComponent</code>가 이렇게 구현되었습니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alice-class-signature\" header=\"parent-finder.component.ts (AliceComponent 클래스 선언)\">\nexport class AliceComponent implements Parent\n\n</code-example>\n<p>이렇게 구현하면 코드도 간단해지지만 문법적으로 꼭 이래야만 하는 것은 아닙니다.\n<code>Base</code> 클래스에 선언한 대로 <code>AlexComponent</code>에도 <code>name</code> 프로퍼티가 존재하지만, 이 클래스 선언은 <code>Parent</code>을 활용한 것이 아닙니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-class-signature\" header=\"parent-finder.component.ts (AlexComponent 클래스 선언)\">\nexport class AlexComponent extends Base\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p><code>AlexComponent</code>는 <code>Parent</code> 클래스를 활용하는 방식으로 구현하는 것이 더 좋습니다.\n이 코드에서는 설명을 하기 위해 이렇게 구현했지만, 인터페이스는 컴파일 된 이후 코드에 존재하지 않습니다.</p>\n</div>\n\n</div>\n\n<!-- links to this doc:\n - api/core/TemplateRef\n-->\n<!-- links from this doc:\n - api/\n - api/core/Component\n - api/core/ContentChildren\n - api/core/Optional\n - api/core/Query\n - api/core/QueryList\n - api/core/SkipSelf\n - api/core/ViewChildren\n - api/core/forwardRef\n - guide/dependency-injection-in-action#class-interface\n - guide/dependency-injection-in-action#forwardref\n - guide/dependency-injection-in-action#optional\n - guide/dependency-injection-in-action#useexisting\n - guide/dependency-injection-navtree#alex\n - guide/dependency-injection-navtree#alex-providers\n - guide/dependency-injection-navtree#known-parent\n - guide/dependency-injection-navtree#parent-token\n - guide/dependency-injection-navtree#skipself-로-부모-컴포넌트-찾기\n - guide/dependency-injection-navtree#부모-클래스-인터페이스\n - guide/dependency-injection-navtree#부모-클래스가-상속받은-클래스로는-참조할-수-없습니다\n - guide/dependency-injection-navtree#컴포넌트-트리-참조하기\n - guide/dependency-injection-navtree#클래스-인터페이스로-부모-컴포넌트-찾기\n - guide/dependency-injection-navtree#타입으로-부모-컴포넌트-찾기\n - guide/glossary#view\n - guide/glossary#view-hierarchy\n - guide/hierarchical-dependency-injection\n - https://github.com/angular/angular/edit/master/aio/content/guide/dependency-injection-navtree.md?message=docs%3A%20describe%20your%20change...\n - https://github.com/angular/angular/issues/new?template=3-docs-bug.md\n-->"
}