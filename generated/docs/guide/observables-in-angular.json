{
  "id": "guide/observables-in-angular",
  "title": "Angular가 제공하는 옵저버블",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/observables-in-angular.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Observables in Angular\n-->\n<h1 id=\"angular가-제공하는-옵저버블\">Angular가 제공하는 옵저버블<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables-in-angular#angular가-제공하는-옵저버블\"><i class=\"material-icons\">link</i></a></h1>\n<!--\nAngular makes use of observables as an interface to handle a variety of common asynchronous operations. For example:\n\n* You can define [custom events](guide/template-syntax#custom-events-with-eventemitter) that send observable output data from a child to a parent component.\n* The HTTP module uses observables to handle AJAX requests and responses.\n* The Router and Forms modules use observables to listen for and respond to user-input events.\n-->\n<p>Angular는 비동기 로직을 처리할 때 옵저버블을 다양하게 사용합니다. 몇 가지 예를 들면 다음과 같은 경우에 옵저버블을 사용합니다:</p>\n<ul>\n<li>자식 컴포넌트에서 부모 컴포넌트로 데이터를 전달할 때 옵저버블 형태로 <a href=\"guide/template-syntax#custom-events-with-eventemitter\">커스텀 이벤트</a>를 보낼 수 있습니다.</li>\n<li>HTTP 모듈이 AJAX 요청을 보내거나 응답을 받아 처리할 때 옵저버블을 사용합니다.</li>\n<li>라우터와 폼 모듈이 사용자 입력 이벤트를 감지할 때 옵저버블을 사용합니다.</li>\n</ul>\n<!--\n## Transmitting data between components\n-->\n<h2 id=\"컴포넌트간-데이터-전달하기\">컴포넌트간 데이터 전달하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables-in-angular#컴포넌트간-데이터-전달하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAngular provides an `EventEmitter` class that is used when publishing values from a component through the [`@Output()` decorator](guide/template-syntax#how-to-use-output).\n`EventEmitter` extends [RxJS `Subject`](https://rxjs.dev/api/index/class/Subject), adding an `emit()` method so it can send arbitrary values.\nWhen you call `emit()`, it passes the emitted value to the `next()` method of any subscribed observer.\n\nA good example of usage can be found in the [EventEmitter](api/core/EventEmitter) documentation. Here is the example component that listens for open and close events:\n\n`<zippy (open)=\"onOpen($event)\" (close)=\"onClose($event)\"></zippy>`\n\nHere is the component definition:\n\n<code-example path=\"observables-in-angular/src/main.ts\" header=\"EventEmitter\" region=\"eventemitter\">\n\n@Component({\n  selector: &#39;zippy&#39;,\n  template: `\n  &lt;div class=&quot;zippy&quot;&gt;\n    &lt;div (click)=&quot;toggle()&quot;&gt;Toggle&lt;/div&gt;\n    &lt;div [hidden]=&quot;!visible&quot;&gt;\n      &lt;ng-content&gt;&lt;/ng-content&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;`})\n\nexport class ZippyComponent {\n  visible = true;\n  @Output() open = new EventEmitter&lt;any&gt;();\n  @Output() close = new EventEmitter&lt;any&gt;();\n\n  toggle() {\n    this.visible = !this.visible;\n    if (this.visible) {\n      this.open.emit(null);\n    } else {\n      this.close.emit(null);\n    }\n  }\n}\n\n\n</code-example>\n-->\n<p>컴포넌트 밖으로 데이터를 보내려면 <a href=\"guide/template-syntax#how-to-use-output\"><code>@Output()</code> 데코레이터</a>가 지정된 프로퍼티에 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 인스턴스를 사용합니다.\n<code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code>는 <a href=\"https://rxjs.dev/api/index/class/Subject\">RxJS가 제공하는 <code>Subject</code></a> 클래스를 확장한 클래스입니다.\n<code>Subject</code>에 있는 기능 외에 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code>가 제공하는 <code>emit()</code> 메소드를 사용하면 데이터를 옵저버블에 실어 보낼 수 있습니다.\n그리고 이렇게 보낸 데이터는 이 옵저버블을 구독하는 옵저버의 <code>next()</code> 메소드가 받을 수 있습니다.</p>\n<p><code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 클래스를 사용하는 방법은 <a href=\"api/core/EventEmitter\">EventEmitter</a> 문서에서 확인할 수 있습니다.\n이 문서에서는 컴포넌트의 <code>open</code> 이벤트와 <code>close</code> 이벤트를 감지하는 예제를 살펴봅시다.</p>\n<p><code>&#x3C;zippy (open)=\"onOpen($event)\" (close)=\"onClose($event)\">&#x3C;/zippy></code></p>\n<p>이 컴포넌트는 다음과 같이 정의되어 있습니다:</p>\n<code-example path=\"observables-in-angular/src/main.ts\" header=\"EventEmitter\" region=\"eventemitter\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'zippy',\n  template: `\n  &#x3C;div class=\"zippy\">\n    &#x3C;div (click)=\"toggle()\">Toggle&#x3C;/div>\n    &#x3C;div [hidden]=\"!visible\">\n      &#x3C;ng-content>&#x3C;/ng-content>\n    &#x3C;/div>\n  &#x3C;/div>`})\n\nexport class ZippyComponent {\n  visible = true;\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() open = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;any>();\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() close = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;any>();\n\n  toggle() {\n    this.visible = !this.visible;\n    if (this.visible) {\n      this.open.emit(null);\n    } else {\n      this.close.emit(null);\n    }\n  }\n}\n\n\n</code-example>\n<h2 id=\"http\">HTTP<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables-in-angular#http\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAngular’s `HttpClient` returns observables from HTTP method calls. For instance, `http.get(‘/api’)` returns an observable. This provides several advantages over promise-based HTTP APIs:\n\n* Observables do not mutate the server response (as can occur through chained `.then()` calls on promises). Instead, you can use a series of operators to transform values as needed.\n* HTTP requests are cancellable through the `unsubscribe()` method.\n* Requests can be configured to get progress event updates.\n* Failed requests can be retried easily.\n-->\n<p>Angular에서 제공하는 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>는 HTTP 요청 결과를 옵저버블로 반환합니다.\n그래서 <code>http.get(‘/api’)</code>를 실행한 결과도 옵저버블입니다.\n옵저버블을 사용하는 방식은 Promise를 사용하는 방식과 비교했을 때 더 좋은 점이 몇가지 있습니다:</p>\n<ul>\n<li>옵저버블은 서버에서 받은 응답을 다른 객체로 변환하지 않습니다. Promise를 사용하면 <code>.then()</code>으로 체이닝 할때마다 새로운 객체가 생성되던 것과는 다릅니다. 대신, 옵저버블은 연산자를 사용해서 옵저버블의 모양을 조작합니다.</li>\n<li><code>unsubscribe()</code> 메소드를 실행하면 아직 완료되지 않은 HTTP 요청을 취소할 수 있습니다.</li>\n<li>서버의 응답 진행률을 확인할 수 있습니다.</li>\n<li>실패한 요청을 재시도하는 것도 간단합니다.</li>\n</ul>\n<!--\n## Async pipe\n-->\n<h2 id=\"async-파이프\">Async 파이프<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables-in-angular#async-파이프\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe [AsyncPipe](api/common/AsyncPipe) subscribes to an observable or promise and returns the latest value it has emitted. When a new value is emitted, the pipe marks the component to be checked for changes.\n\nThe following example binds the `time` observable to the component's view. The observable continuously updates the view with the current time.\n\n<code-example path=\"observables-in-angular/src/main.ts\" header=\"Using async pipe\" region=\"pipe\">\n\n@Component({\n  selector: &#39;async-observable-pipe&#39;,\n  template: `&lt;div&gt;&lt;code&gt;observable|async&lt;/code&gt;:\n       Time: {{ time | async }}&lt;/div&gt;`\n})\nexport class AsyncObservablePipeComponent {\n  time = new Observable&lt;string&gt;(observer =&gt; {\n    setInterval(() =&gt; observer.next(new Date().toString()), 1000);\n  });\n}\n\n\n</code-example>\n-->\n<p><a href=\"api/common/AsyncPipe\">AsyncPipe</a>는 옵저버블이나 Promise를 구독하고, 이 객체가 담고 있는 마지막 값을 반환합니다. 그리고 새로운 값이 전달되면 컴포넌트가 변화를 감지하도록 알립니다.</p>\n<p>아래 예제는 컴포넌트의 뷰에서 옵저버블 타입인 <code>time</code> 프로퍼티를 바인딩하는 예제입니다. 이 옵저버블은 컴포넌트에서 새로운 스트림을 생성할 때마다 계속 갱신됩니다.</p>\n<code-example path=\"observables-in-angular/src/main.ts\" header=\"Async 파이프 사용하기\" region=\"pipe\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'async-observable-pipe',\n  template: `&#x3C;div>&#x3C;code>observable|async&#x3C;/code>:\n       <a href=\"api/common/Time\" class=\"code-anchor\">Time</a>: {{ time | async }}&#x3C;/div>`\n})\nexport class AsyncObservablePipeComponent {\n  time = new Observable&#x3C;string>(observer => {\n    setInterval(() => observer.next(new Date().toString()), 1000);\n  });\n}\n\n\n</code-example>\n<h2 id=\"router\">Router<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables-in-angular#router\"><i class=\"material-icons\">link</i></a></h2>\n<!--\n[`Router.events`](api/router/Router#events) provides events as observables. You can use the `filter()` operator from RxJS to look for events of interest, and subscribe to them in order to make decisions based on the sequence of events in the navigation process. Here's an example:\n\n<code-example path=\"observables-in-angular/src/main.ts\" header=\"Router events\" region=\"router\">\n\nimport { Router, NavigationStart } from &#39;@angular/router&#39;;\nimport { filter } from &#39;rxjs/operators&#39;;\n\n@Component({\n  selector: &#39;app-routable&#39;,\n  templateUrl: &#39;./routable.component.html&#39;,\n  styleUrls: [&#39;./routable.component.css&#39;]\n})\nexport class Routable1Component implements OnInit {\n\n  navStart: Observable&lt;NavigationStart&gt;;\n\n  constructor(private router: Router) {\n    // NavigationStart 이벤트에 해당하는 옵저버블만 받습니다.\n    this.navStart = router.events.pipe(\n      filter(evt =&gt; evt instanceof NavigationStart)\n    ) as Observable&lt;NavigationStart&gt;;\n  }\n\n  ngOnInit() {\n    this.navStart.subscribe(evt =&gt; console.log(&#39;Navigation Started!&#39;));\n  }\n}\n\n\n</code-example>\n\nThe [ActivatedRoute](api/router/ActivatedRoute) is an injected router service that makes use of observables to get information about a route path and parameters. For example, `ActivatedRoute.url` contains an observable that reports the route path or paths. Here's an example:\n\n<code-example path=\"observables-in-angular/src/main.ts\" header=\"ActivatedRoute\" region=\"activated_route\">\n\nimport { ActivatedRoute } from &#39;@angular/router&#39;;\n\n@Component({\n  selector: &#39;app-routable&#39;,\n  templateUrl: &#39;./routable.component.html&#39;,\n  styleUrls: [&#39;./routable.component.css&#39;]\n})\nexport class Routable2Component implements OnInit {\n  constructor(private activatedRoute: ActivatedRoute) {}\n\n  ngOnInit() {\n    this.activatedRoute.url\n      .subscribe(url =&gt; console.log(&#39;The URL changed to: &#39; + url));\n  }\n}\n\n\n</code-example>\n-->\n<p><a href=\"api/router/Router#events\"><code>Router.events</code></a>는 라우팅 이벤트를 옵저버블로 전달합니다.\n이 중 필요한 이벤트만 처리하려면 RxJS에서 제공하는 <code>filter()</code> 연산자를 사용할 수 있으며, 이 프로퍼티를 구독하면 네비게이션 진행상황에 맞게 이벤트를 처리할 수 있습니다.</p>\n<code-example path=\"observables-in-angular/src/main.ts\" header=\"라우터 이벤트\" region=\"router\">\n\nimport { <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>, <a href=\"api/router/NavigationStart\" class=\"code-anchor\">NavigationStart</a> } from '@angular/router';\nimport { filter } from 'rxjs/operators';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-routable',\n  templateUrl: './routable.component.html',\n  styleUrls: ['./routable.component.css']\n})\nexport class Routable1Component implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n\n  navStart: Observable&#x3C;<a href=\"api/router/NavigationStart\" class=\"code-anchor\">NavigationStart</a>>;\n\n  constructor(private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {\n    // <a href=\"api/router/NavigationStart\" class=\"code-anchor\">NavigationStart</a> 이벤트에 해당하는 옵저버블만 받습니다.\n    this.navStart = router.events.pipe(\n      filter(evt => evt instanceof <a href=\"api/router/NavigationStart\" class=\"code-anchor\">NavigationStart</a>)\n    ) as Observable&#x3C;<a href=\"api/router/NavigationStart\" class=\"code-anchor\">NavigationStart</a>>;\n  }\n\n  ngOnInit() {\n    this.navStart.subscribe(evt => console.log('<a href=\"api/router/Navigation\" class=\"code-anchor\">Navigation</a> Started!'));\n  }\n}\n\n\n</code-example>\n<p><a href=\"api/router/ActivatedRoute\">ActivatedRoute</a>도 현재 라우팅 경로나 라우팅 인자를 옵저버블로 제공합니다.\n그래서 이 서비스의 프로퍼티 중 <code><a href=\"api/router/ActivatedRoute#url\" class=\"code-anchor\">ActivatedRoute.url</a></code>를 구독해도 현재 라우팅 경로를 확인할 수 있습니다.\n예제를 봅시다:</p>\n<code-example path=\"observables-in-angular/src/main.ts\" header=\"ActivatedRoute\" region=\"activated_route\">\n\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-routable',\n  templateUrl: './routable.component.html',\n  styleUrls: ['./routable.component.css']\n})\nexport class Routable2Component implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  constructor(private activatedRoute: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>) {}\n\n  ngOnInit() {\n    this.activatedRoute.url\n      .subscribe(url => console.log('The URL changed to: ' + url));\n  }\n}\n\n\n</code-example>\n<!--\n## Reactive forms\n-->\n<h2 id=\"반응형-폼\">반응형 폼<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables-in-angular#반응형-폼\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nReactive forms have properties that use observables to monitor form control values. The [`FormControl`](api/forms/FormControl) properties `valueChanges` and `statusChanges` contain observables that raise change events. Subscribing to an observable form-control property is a way of triggering application logic within the component class. For example:\n\n<code-example path=\"observables-in-angular/src/main.ts\" header=\"Reactive forms\" region=\"forms\">\n\nimport { FormGroup } from &#39;@angular/forms&#39;;\n\n@Component({\n  selector: &#39;my-component&#39;,\n  template: &#39;MyComponent Template&#39;\n})\nexport class MyComponent implements OnInit {\n  nameChangeLog: string[] = [];\n  heroForm: FormGroup;\n\n  ngOnInit() {\n    this.logNameChange();\n  }\n  logNameChange() {\n    const nameControl = this.heroForm.get(&#39;name&#39;);\n    nameControl.valueChanges.forEach(\n      (value: string) =&gt; this.nameChangeLog.push(value)\n    );\n  }\n}\n\n\n</code-example>\n-->\n<p>반응형 폼에서 폼 컨트롤의 값을 추적할 때도 옵저버블을 사용할 수 있습니다.\n예를 들면 <a href=\"api/forms/FormControl\"><code>FormControl</code></a>의 프로퍼티 중 <code>valueChanges</code>와 <code>statusChanges</code>를 구독하면 폼 컨트롤의 값과 상태가 변하는 것을 확인할 수 있습니다.\n폼 컨트롤의 옵저버블 프로퍼티를 구독하면 컴포넌트 클래스에서 애플리케이션 로직을 자유롭게 작성할 수 있습니다.\n예제 코드를 봅시다:</p>\n<code-example path=\"observables-in-angular/src/main.ts\" header=\"반응형 폼\" region=\"forms\">\n\nimport { <a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a> } from '@angular/forms';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: 'MyComponent Template'\n})\nexport class MyComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  nameChangeLog: string[] = [];\n  heroForm: <a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a>;\n\n  ngOnInit() {\n    this.logNameChange();\n  }\n  logNameChange() {\n    const nameControl = this.heroForm.get('name');\n    nameControl.valueChanges.forEach(\n      (value: string) => this.nameChangeLog.push(value)\n    );\n  }\n}\n\n\n</code-example>\n\n</div>\n\n<!-- links to this doc:\n - api/core/EventEmitter\n - guide/router\n-->\n<!-- links from this doc:\n - api/common/AsyncPipe\n - api/common/Time\n - api/common/http/HttpClient\n - api/core/Component\n - api/core/EventEmitter\n - api/core/OnInit\n - api/core/Output\n - api/forms/FormControl\n - api/forms/FormGroup\n - api/router/ActivatedRoute\n - api/router/ActivatedRoute#url\n - api/router/Navigation\n - api/router/NavigationStart\n - api/router/Router\n - api/router/Router#events\n - guide/observables-in-angular#angular가-제공하는-옵저버블\n - guide/observables-in-angular#async-파이프\n - guide/observables-in-angular#http\n - guide/observables-in-angular#router\n - guide/observables-in-angular#반응형-폼\n - guide/observables-in-angular#컴포넌트간-데이터-전달하기\n - guide/template-syntax#custom-events-with-eventemitter\n - guide/template-syntax#how-to-use-output\n - https://github.com/angular/angular/edit/master/aio/content/guide/observables-in-angular.md?message=docs%3A%20describe%20your%20change...\n - https://rxjs.dev/api/index/class/Subject\n-->"
}