{
  "id": "guide/testing-components-scenarios",
  "title": "컴포넌트 테스트 시나리오",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/testing-components-scenarios.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Component testing scenarios\n-->\n<h1 id=\"컴포넌트-테스트-시나리오\">컴포넌트 테스트 시나리오<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#컴포넌트-테스트-시나리오\"><i class=\"material-icons\">link</i></a></h1>\n<!--\nThis guide explores common component testing use cases.\n\n<div class=\"alert is-helpful\">\n\n  For the sample app that the testing guides describe, see the <live-example name=\"testing\" embedded-style noDownload>sample app</live-example>.\n\n  For the tests features in the testing guides, see <live-example name=\"testing\" stackblitz=\"specs\" noDownload>tests</live-example>.\n\n</div>\n-->\n<p>이 문서에서는 컴포넌트를 다양하게 테스트하는 방법에 대해 알아봅시다.</p>\n<div class=\"alert is-helpful\">\n<p>이 문서에서 다루는 예제 앱은 <live-example name=\"testing\" embedded-style=\"\" nodownload=\"\">sample app</live-example>에서 확인할 수 있습니다.</p>\n<p>이 문서에서 설명하는 테스트 기능은 <live-example name=\"testing\" stackblitz=\"specs\" nodownload=\"\">tests</live-example>에서 확인할 수 있습니다.</p>\n</div>\n<!--\n## Component binding\n-->\n<h2 id=\"컴포넌트-바인딩\">컴포넌트 바인딩<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#컴포넌트-바인딩\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nIn the example app, the `BannerComponent` presents static title text in the HTML template.\n\nAfter a few changes, the `BannerComponent` presents a dynamic title by binding to\nthe component's `title` property like this.\n\n<code-example path=\"testing/src/app/banner/banner.component.ts\" region=\"component\" header=\"app/banner/banner.component.ts\">\n@Component({\n  selector: &#39;app-banner&#39;,\n  template: &#39;&lt;h1&gt;{{title}}&lt;/h1&gt;&#39;,\n  styles: [&#39;h1 { color: green; font-size: 350%}&#39;]\n})\nexport class BannerComponent {\n  title = &#39;Test Tour of Heroes&#39;;\n}\n\n</code-example>\n\nAs minimal as this is, you decide to add a test to confirm that component\nactually displays the right content where you think it should.\n-->\n<p>예제 앱에서 <code>BannerComponent</code> 템플릿에 있는 <code>title</code> 프로퍼티는 부모 컴포넌트와 바인딩되어 있기 때문에 동적으로 변경될 수 있습니다.</p>\n<code-example path=\"testing/src/app/banner/banner.component.ts\" region=\"component\" header=\"app/banner/banner.component.ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-banner',\n  template: '&#x3C;h1>{{title}}&#x3C;/h1>',\n  styles: ['h1 { color: green; font-size: 350%}']\n})\nexport class BannerComponent {\n  title = 'Test Tour of Heroes';\n}\n\n</code-example>\n<p>이 컴포넌트를 가장 간단하게 테스트하려면 컴포넌트로 문자열을 바인딩했을때 이 문자열이 실제로 표시되는지 확인하면 됩니다.</p>\n<!--\n#### Query for the _&lt;h1&gt;_\n-->\n<h4 id=\"h1-쿼리하기\"><em>&#x3C;h1></em> 쿼리하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#h1-쿼리하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nYou'll write a sequence of tests that inspect the value of the `<h1>` element\nthat wraps the _title_ property interpolation binding.\n\nYou update the `beforeEach` to find that element with a standard HTML `querySelector`\nand assign it to the `h1` variable.\n\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"setup\" header=\"app/banner/banner.component.spec.ts (setup)\">\nlet component: BannerComponent;\nlet fixture: ComponentFixture&lt;BannerComponent&gt;;\nlet h1: HTMLElement;\n\nbeforeEach(() =&gt; {\n  TestBed.configureTestingModule({\n    declarations: [ BannerComponent ],\n  });\n  fixture = TestBed.createComponent(BannerComponent);\n  component = fixture.componentInstance; // BannerComponent 인스턴스\n  h1 = fixture.nativeElement.querySelector(&#39;h1&#39;);\n});\n\n</code-example>\n-->\n<p><em>title</em> 프로퍼티가 제대로 문자열 바인딩 되었는지 확인하려면 <code>&#x3C;h1></code> 엘리먼트의 값을 검사하면 됩니다.</p>\n<p>표준 HTML <code>querySelector</code>를 사용해서 <code>h1</code> 엘리먼트를 참조하도록 <code>beforeEach()</code>를 수정해 봅시다.</p>\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"setup\" header=\"app/banner/banner.component.spec.ts (환경설정)\">\nlet component: BannerComponent;\nlet fixture: <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>&#x3C;BannerComponent>;\nlet h1: HTMLElement;\n\nbeforeEach(() => {\n  TestBed.configureTestingModule({\n    declarations: [ BannerComponent ],\n  });\n  fixture = TestBed.createComponent(BannerComponent);\n  component = fixture.componentInstance; // BannerComponent 인스턴스\n  h1 = fixture.nativeElement.querySelector('h1');\n});\n\n</code-example>\n<a id=\"detect-changes\"></a>\n<!--\n#### _createComponent()_ does not bind data\n-->\n<h4 id=\"createcomponent-는-데이터를-바인딩하지-않습니다\"><em>createComponent()</em> 는 데이터를 바인딩하지 않습니다.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#createcomponent-는-데이터를-바인딩하지-않습니다\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nFor your first test you'd like to see that the screen displays the default `title`.\nYour instinct is to write a test that immediately inspects the `<h1>` like this:\n\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"expect-h1-default-v1\">\nit(&#39;should display original title&#39;, () =&gt; {\n  expect(h1.textContent).toContain(component.title);\n});\n\n</code-example>\n\n_That test fails_ with the message:\n\n```javascript\nexpected '' to contain 'Test Tour of Heroes'.\n```\n\nBinding happens when Angular performs **change detection**.\n\nIn production, change detection kicks in automatically\nwhen Angular creates a component or the user enters a keystroke or\nan asynchronous activity (e.g., AJAX) completes.\n\nThe `TestBed.createComponent` does _not_ trigger change detection; a fact confirmed in the revised test:\n\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"test-w-o-detect-changes\">\nit(&#39;no title in the DOM after createComponent()&#39;, () =&gt; {\n  expect(h1.textContent).toEqual(&#39;&#39;);\n});\n\n</code-example>\n-->\n<p>이제 <code>title</code> 프로퍼티에 할당된 문자열이 제대로 표시되는지 확인해 보려고 합니다.\n<code>&#x3C;h1></code> 엘리먼트를 검사하는 코드는 이렇게 작성해볼 수 있습니다:</p>\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"expect-h1-default-v1\">\nit('should display original title', () => {\n  expect(h1.textContent).toContain(component.title);\n});\n\n</code-example>\n<p>하지만 이 테스트는 이런 메시지를 출력하면서 실패합니다:</p>\n<code-example language=\"javascript\">\nexpected '' to contain 'Test Tour of Heroes'.\n</code-example>\n<p>데이터 바인딩은 Angular가 <strong>변화를 감지(change detection)</strong> 했을 때 발생합니다.</p>\n<p>실제 운영환경에서는 Angular가 컴포넌트를 생성하거나 사용자가 키를 입력했을 때, AJAX와 같은 비동기 작업이 끝났을 때 변화 감지 로직이 자동으로 실행됩니다.</p>\n<p>하지만 <code>TestBed.createComponent</code> 만으로는 변화 감지 로직이 시작되지 않습니다.\n그래서 지금 시점에는 <code>&#x3C;h1></code> 엘리먼트의 값은 빈 문자열입니다:</p>\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"test-w-o-detect-changes\">\nit('no title in the DOM after createComponent()', () => {\n  expect(h1.textContent).toEqual('');\n});\n\n</code-example>\n<h4 id=\"detectchanges\"><em>detectChanges()</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#detectchanges\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nYou must tell the `TestBed` to perform data binding by calling `fixture.detectChanges()`.\nOnly then does the `<h1>` have the expected title.\n\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"expect-h1-default\">\nit(&#39;should display original title after detectChanges()&#39;, () =&gt; {\n  fixture.detectChanges();\n  expect(h1.textContent).toContain(component.title);\n});\n\n</code-example>\n\nDelayed change detection is intentional and useful.\nIt gives the tester an opportunity to inspect and change the state of\nthe component _before Angular initiates data binding and calls [lifecycle hooks](guide/lifecycle-hooks)_.\n\nHere's another test that changes the component's `title` property _before_ calling `fixture.detectChanges()`.\n\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"after-change\">\nit(&#39;should display a different test title&#39;, () =&gt; {\n  component.title = &#39;Test Title&#39;;\n  fixture.detectChanges();\n  expect(h1.textContent).toContain(&#39;Test Title&#39;);\n});\n\n</code-example>\n-->\n<p>데이터를 바인딩하려면 <code>fixture.detectChanges()</code> 를 실행해야 합니다.\n이 메서드를 실행하고 나면 <code>&#x3C;h1></code> 엘리먼트에 컴포넌트 클래스에 있는 문자열이 바인딩되는 것을 확인할 수 있습니다.</p>\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"expect-h1-default\">\nit('should display original title after detectChanges()', () => {\n  fixture.detectChanges();\n  expect(h1.textContent).toContain(component.title);\n});\n\n</code-example>\n<p>변화 감지 로직을 수동으로 시작하는 것은 더 나은 활용도를 위해 의도된 것입니다.\n변화 감지 로직이 자동이 실행되지 않기 때문에 개발자가 데이터가 바인딩되기 전 상태를 검사할 수 있으며, <a href=\"guide/lifecycle-hooks\">라이프싸이클 후킹 메서드</a>가 실행되면서 데이터가 어떻게 변경되는지 원하는 시점마다 확인할 수 있습니다.</p>\n<p><code>title</code> 프로퍼티는 이렇게 테스트할 수도 있습니다.</p>\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"after-change\">\nit('should display a different test title', () => {\n  component.title = 'Test <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a>';\n  fixture.detectChanges();\n  expect(h1.textContent).toContain('Test <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a>');\n});\n\n</code-example>\n<a id=\"auto-detect-changes\"></a>\n<a id=\"automatic-change-detection\"></a>\n<!--\n#### Automatic change detection\n-->\n<h4 id=\"변화-감지-로직을-자동으로-실행하기\">변화 감지 로직을 자동으로 실행하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#변화-감지-로직을-자동으로-실행하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe `BannerComponent` tests frequently call `detectChanges`.\nSome testers prefer that the Angular test environment run change detection automatically.\n\nThat's possible by configuring the `TestBed` with the `ComponentFixtureAutoDetect` provider.\nFirst import it from the testing utility library:\n\n<code-example path=\"testing/src/app/banner/banner.component.detect-changes.spec.ts\" region=\"import-ComponentFixtureAutoDetect\" header=\"app/banner/banner.component.detect-changes.spec.ts (import)\">\nimport { ComponentFixtureAutoDetect } from &#39;@angular/core/testing&#39;;\n\n</code-example>\n\nThen add it to the `providers` array of the testing module configuration:\n\n<code-example path=\"testing/src/app/banner/banner.component.detect-changes.spec.ts\" region=\"auto-detect\" header=\"app/banner/banner.component.detect-changes.spec.ts (AutoDetect)\">\nTestBed.configureTestingModule({\n  declarations: [ BannerComponent ],\n  providers: [\n    { provide: ComponentFixtureAutoDetect, useValue: true }\n  ]\n});\n\n</code-example>\n\nHere are three tests that illustrate how automatic change detection works.\n\n<code-example path=\"testing/src/app/banner/banner.component.detect-changes.spec.ts\" region=\"auto-detect-tests\" header=\"app/banner/banner.component.detect-changes.spec.ts (AutoDetect Tests)\">\nit(&#39;should display original title&#39;, () =&gt; {\n  // 만세! `fixture.detectChanges()`는 더이상 필요 없습니다.\n  expect(h1.textContent).toContain(comp.title);\n});\n\nit(&#39;should still see original title after comp.title change&#39;, () =&gt; {\n  const oldTitle = comp.title;\n  comp.title = &#39;Test Title&#39;;\n  // 화면에 표시되는 문자열은 갱신되지 않습니다. 이 경우에는 변화감지 로직이 실행되지 않았습니다 :(\n  expect(h1.textContent).toContain(oldTitle);\n});\n\nit(&#39;should display updated title after detectChanges&#39;, () =&gt; {\n  comp.title = &#39;Test Title&#39;;\n  fixture.detectChanges(); // 명시적으로 변화감지 로직을 실행합니다.\n  expect(h1.textContent).toContain(comp.title);\n});\n\n</code-example>\n\nThe first test shows the benefit of automatic change detection.\n\nThe second and third test reveal an important limitation.\nThe Angular testing environment does _not_ know that the test changed the component's `title`.\nThe `ComponentFixtureAutoDetect` service responds to _asynchronous activities_ such as promise resolution, timers, and DOM events.\nBut a direct, synchronous update of the component property is invisible.\nThe test must call `fixture.detectChanges()` manually to trigger another cycle of change detection.\n\n<div class=\"alert is-helpful\">\n\nRather than wonder when the test fixture will or won't perform change detection,\nthe samples in this guide _always call_ `detectChanges()` _explicitly_.\nThere is no harm in calling `detectChanges()` more often than is strictly necessary.\n\n</div>\n-->\n<p>지금까지 작성한 테스트 코드에서는 <code>detectChanges</code>를 계속해서 호출해야 합니다.\n하지만 변화 감지 로직이 자동으로 실행되는 것을 선호하는 개발자도 있습니다.</p>\n<p>변화 감지 로직을 자동으로 실행하려면 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>를 설정할 때 <code><a href=\"api/core/testing/ComponentFixtureAutoDetect\" class=\"code-anchor\">ComponentFixtureAutoDetect</a></code> 프로바이더를 지정하면 됩니다.\n먼저 테스트 라이브러리에서 이 심볼을 로드합니다:</p>\n<code-example path=\"testing/src/app/banner/banner.component.detect-changes.spec.ts\" region=\"import-ComponentFixtureAutoDetect\" header=\"app/banner/banner.component.detect-changes.spec.ts (심볼 로드하기)\">\nimport { <a href=\"api/core/testing/ComponentFixtureAutoDetect\" class=\"code-anchor\">ComponentFixtureAutoDetect</a> } from '@angular/core/testing';\n\n</code-example>\n<p>그리고 테스트 모듈 설정의 <code>providers</code> 배열에 이 심볼을 추가합니다:</p>\n<code-example path=\"testing/src/app/banner/banner.component.detect-changes.spec.ts\" region=\"auto-detect\" header=\"app/banner/banner.component.detect-changes.spec.ts (변화 감지 자동으로 실행하기)\">\nTestBed.configureTestingModule({\n  declarations: [ BannerComponent ],\n  providers: [\n    { provide: <a href=\"api/core/testing/ComponentFixtureAutoDetect\" class=\"code-anchor\">ComponentFixtureAutoDetect</a>, useValue: true }\n  ]\n});\n\n</code-example>\n<p>이 설정에 맞게 테스트 코드를 작성해보면 이렇습니다.</p>\n<code-example path=\"testing/src/app/banner/banner.component.detect-changes.spec.ts\" region=\"auto-detect-tests\" header=\"app/banner/banner.component.detect-changes.spec.ts (변화 감지가 자동으로 동작하는 테스트 코드)\">\nit('should display original title', () => {\n  // 만세! `fixture.detectChanges()`는 더이상 필요 없습니다.\n  expect(h1.textContent).toContain(comp.title);\n});\n\nit('should still see original title after comp.title change', () => {\n  const oldTitle = comp.title;\n  comp.title = 'Test <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a>';\n  // 화면에 표시되는 문자열은 갱신되지 않습니다. 이 경우에는 변화감지 로직이 실행되지 않았습니다 :(\n  expect(h1.textContent).toContain(oldTitle);\n});\n\nit('should display updated title after detectChanges', () => {\n  comp.title = 'Test <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a>';\n  fixture.detectChanges(); // 명시적으로 변화감지 로직을 실행합니다.\n  expect(h1.textContent).toContain(comp.title);\n});\n\n</code-example>\n<p>변화 감지 로직이 자동으로 실행되면 첫 번째 테스트 코드처럼 아주 간단한 테스트 코드를 작성할 수 있습니다.</p>\n<p>그리고 두 번째 테스트 코드와 세 번째 테스트 코드를 보면 이 환경설정의 한계를 확인할 수 있습니다.\nAngular 테스트 환경에서는 컴포넌트의 <code>title</code> 값이 변경된 것을 직접 감지할 수 없습니다.\n<code><a href=\"api/core/testing/ComponentFixtureAutoDetect\" class=\"code-anchor\">ComponentFixtureAutoDetect</a></code> 서비스는 프라미스(Promise)가 완료되거나 타이머 이벤트, DOM 이벤트와 같은 <em>비동기 작업</em> 에만 반응합니다.\n그래서 컴포넌트 프로퍼티를 직접 수정하면 이 수정사항은 화면에 반영되지 않습니다.\n이런 경우에는 변화 감지가 필요한 시점에 <code>fixture.detectChanges()</code>를 직접 실행해주면 됩니다.</p>\n<div class=\"alert is-helpful\">\n<p>이 문서에서는 변화 감지 로직이 자동으로 실행되는 것이 고민하는 대신 <em>명시적으로</em> <code>detectChanges()</code>를 실행하는 방식을 사용합니다.\n<code>detectChanges()</code>는 꼭 필요한 상황이 아닐 때 더 실행되더라도 문제가 발생하지 않습니다.</p>\n</div>\n<hr>\n<a id=\"dispatch-event\"></a>\n<!--\n#### Change an input value with _dispatchEvent()_\n-->\n<h4 id=\"dispatchevent-로-입력값-변경하기\"><em>dispatchEvent()</em> 로 입력값 변경하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#dispatchevent-로-입력값-변경하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nTo simulate user input, you can find the input element and set its `value` property.\n\nYou will call `fixture.detectChanges()` to trigger Angular's change detection.\nBut there is an essential, intermediate step.\n\nAngular doesn't know that you set the input element's `value` property.\nIt won't read that property until you raise the element's `input` event by calling `dispatchEvent()`.\n_Then_ you call `detectChanges()`.\n\nThe following example demonstrates the proper sequence.\n\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"title-case-pipe\" header=\"app/hero/hero-detail.component.spec.ts (pipe test)\">\nit(&#39;should convert hero name to Title Case&#39;, () =&gt; {\n  // 이름에 해당하는 input 엘리먼트와 이 이름을 화면에 표시하는 span 엘리먼트를 DOM에서 참조합니다.\n  const hostElement = fixture.nativeElement;\n  const nameInput: HTMLInputElement = hostElement.querySelector(&#39;input&#39;);\n  const nameDisplay: HTMLElement = hostElement.querySelector(&#39;span&#39;);\n\n  // 사용자가 입력한 것처럼 입력 필드의 내용을 변경합니다.\n  nameInput.value = &#39;quick BROWN  fOx&#39;;\n\n  // 엘리먼트의 값이 변경되었다는 것을 Angular에게 알리기 위해 DOM 이벤트를 생성합니다.\n  // IE와 같이 오래된 브라우저에서는 CustomEvent 를 사용해야 합니다. 아래 문서를 참고하세요.\n  // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill\n  nameInput.dispatchEvent(new Event(&#39;input&#39;));\n\n  // Angular가 화면을 갱신하도록 detectChanges() 함수를 실행합니다.\n  fixture.detectChanges();\n\n  expect(nameDisplay.textContent).toBe(&#39;Quick Brown  Fox&#39;);\n});\n\n</code-example>\n-->\n<p>사용자가 입력하는 것을 시뮬레이션하려면 입력 엘리먼트를 찾아서 이 엘리먼트의 <code>value</code> 프로퍼티 값을 설정하면 됩니다.</p>\n<p>그리고 <code>fixture.detectChanges()</code> 를 실행하면 Angular 변화 감지 로직을 시작할 수 있습니다.\n하지만 이 과정에서 꼭 필요한 단계가 하나 빠졌습니다.</p>\n<p>Angular는 입력 엘리먼트의 <code>value</code> 프로퍼티 값이 변경된 것을 알 수 없습니다.\n그래서 <code>dispatchEvent()</code>를 실행해서 엘리먼트에서 <code>input</code> 이벤트가 발생했다는 것을 알려야 Angular가 프로퍼티 값이 변경된 것을 확인할 수 있습니다.</p>\n<p>아래 테스트 코드처럼 작성하면 됩니다.</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"title-case-pipe\" header=\"app/hero/hero-detail.component.spec.ts (파이프 테스트)\">\nit('should convert hero name to <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a> Case', () => {\n  // 이름에 해당하는 input 엘리먼트와 이 이름을 화면에 표시하는 span 엘리먼트를 DOM에서 참조합니다.\n  const hostElement = fixture.nativeElement;\n  const nameInput: HTMLInputElement = hostElement.querySelector('input');\n  const nameDisplay: HTMLElement = hostElement.querySelector('span');\n\n  // 사용자가 입력한 것처럼 입력 필드의 내용을 변경합니다.\n  nameInput.value = 'quick BROWN  fOx';\n\n  // 엘리먼트의 값이 변경되었다는 것을 Angular에게 알리기 위해 DOM 이벤트를 생성합니다.\n  // IE와 같이 오래된 브라우저에서는 CustomEvent 를 사용해야 합니다. 아래 문서를 참고하세요.\n  // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill\n  nameInput.dispatchEvent(new <a href=\"api/router/Event\" class=\"code-anchor\">Event</a>('input'));\n\n  // Angular가 화면을 갱신하도록 detectChanges() 함수를 실행합니다.\n  fixture.detectChanges();\n\n  expect(nameDisplay.textContent).toBe('Quick Brown  Fox');\n});\n\n</code-example>\n<hr>\n<!--\n## Component with external files\n-->\n<h2 id=\"외부-파일을-사용하는-컴포넌트\">외부 파일을 사용하는 컴포넌트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#외부-파일을-사용하는-컴포넌트\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe `BannerComponent` above is defined with an _inline template_ and _inline css_, specified in the `@Component.template` and `@Component.styles` properties respectively.\n\nMany components specify _external templates_ and _external css_ with the\n`@Component.templateUrl` and `@Component.styleUrls` properties respectively,\nas the following variant of `BannerComponent` does.\n\n<code-example path=\"testing/src/app/banner/banner-external.component.ts\" region=\"metadata\" header=\"app/banner/banner-external.component.ts (metadata)\">\n@Component({\n  selector: &#39;app-banner&#39;,\n  templateUrl: &#39;./banner-external.component.html&#39;,\n  styleUrls:  [&#39;./banner-external.component.css&#39;]\n})\n\n</code-example>\n\nThis syntax tells the Angular compiler to read the external files during component compilation.\n\nThat's not a problem when you run the CLI `ng test` command because it\n_compiles the app before running the tests_.\n\nHowever, if you run the tests in a **non-CLI environment**,\ntests of this component may fail.\nFor example, if you run the `BannerComponent` tests in a web coding environment such as [plunker](https://plnkr.co/), you'll see a message like this one:\n\n<code-example language=\"sh\" class=\"code-shell\" hideCopy>\nError: This test module uses the component BannerComponent\nwhich is using a \"templateUrl\" or \"styleUrls\", but they were never compiled.\nPlease call \"TestBed.compileComponents\" before your test.\n</code-example>\n\nYou get this test failure message when the runtime environment\ncompiles the source code _during the tests themselves_.\n\nTo correct the problem, call `compileComponents()` as explained [below](#compile-components).\n-->\n<p>이전 섹션에서 살펴본 <code>BannerComponent</code>는 <code>@<a href=\"api/core/Component#template\" class=\"code-anchor\">Component.template</a></code>과 <code>@<a href=\"api/core/Component#styles\" class=\"code-anchor\">Component.styles</a></code> 프로퍼티를 사용해서 <em>인라인 템플릿</em> 과 <em>인라인 CSS</em> 로 구성되어 있습니다.</p>\n<p>하지만 컴포넌트는 대부분 <code>@<a href=\"api/core/Component#templateUrl\" class=\"code-anchor\">Component.templateUrl</a></code>과 <code>@<a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">Component.styleUrls</a></code>를 사용해서 <em>별도 템플릿</em> 파일과 <em>별도 CSS</em> 파일로 구성됩니다.</p>\n<code-example path=\"testing/src/app/banner/banner-external.component.ts\" region=\"metadata\" header=\"app/banner/banner-external.component.ts (메타데이터)\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-banner',\n  templateUrl: './banner-external.component.html',\n  styleUrls:  ['./banner-external.component.css']\n})\n\n</code-example>\n<p>이렇게 구현하면 Angular가 컴포넌트를 컴파일 할 때 외부에서 해당 파일을 불러옵니다.</p>\n<p>Angular CLI로 <code>ng test</code> 명령을 사용한다면 <em>테스트가 실행되기 전에 앱이 컴파일되기 때문에</em> 아무런 문제가 없습니다.</p>\n<p>하지만 <strong>Angular CLI를 사용하지 않는 환경</strong> 에서는 문제가 발생할 수 있습니다.\n실제로 <code>BannerComponent</code> 테스트 코드를 <a href=\"https://plnkr.co/\">plunker</a> 환경에서 실행한다면 이런 오류가 발생합니다:</p>\n<code-example language=\"sh\" class=\"code-shell\" hidecopy=\"\">\nError: This test module uses the component BannerComponent\nwhich is using a \"templateUrl\" or \"styleUrls\", but they were never compiled.\nPlease call \"TestBed.compileComponents\" before your test.\n</code-example>\n<p>이 문제를 해결하려면 <a href=\"guide/testing-components-scenarios#compile-components\">아래</a>에서 설명하는 대로 <code>compileComponents()</code> 메서드를 실행해주면 됩니다.</p>\n<a id=\"component-with-dependency\"></a>\n<!--\n## Component with a dependency\n-->\n<h2 id=\"의존성-객체가-주입되는-컴포넌트\">의존성 객체가 주입되는 컴포넌트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#의존성-객체가-주입되는-컴포넌트\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nComponents often have service dependencies.\n\nThe `WelcomeComponent` displays a welcome message to the logged in user.\nIt knows who the user is based on a property of the injected `UserService`:\n\n<code-example path=\"testing/src/app/welcome/welcome.component.ts\" header=\"app/welcome/welcome.component.ts\">\nimport { Component, OnInit } from &#39;@angular/core&#39;;\nimport { UserService } from &#39;../model/user.service&#39;;\n\n@Component({\n  selector: &#39;app-welcome&#39;,\n  template: &#39;&lt;h3 class=&quot;welcome&quot;&gt;&lt;i&gt;{{welcome}}&lt;/i&gt;&lt;/h3&gt;&#39;\n})\nexport class WelcomeComponent implements OnInit {\n  welcome: string;\n  constructor(private userService: UserService) { }\n\n  ngOnInit(): void {\n    this.welcome = this.userService.isLoggedIn ?\n      &#39;Welcome, &#39; + this.userService.user.name : &#39;Please log in.&#39;;\n  }\n}\n\n\n</code-example>\n\nThe `WelcomeComponent` has decision logic that interacts with the service, logic that makes this component worth testing.\nHere's the testing module configuration for the spec file:\n\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"config-test-module\" header=\"app/welcome/welcome.component.spec.ts\">\nTestBed.configureTestingModule({\n   declarations: [ WelcomeComponent ],\n// providers: [ UserService ],  // NO! 프로바이더에 실제 서비스 클래스를 등록하면 안됩니다!\n                                // 목 서비스를 등록하세요.\n   providers: [ { provide: UserService, useValue: userServiceStub } ],\n});\n\n</code-example>\n\nThis time, in addition to declaring the _component-under-test_,\nthe configuration adds a `UserService` provider to the `providers` list.\nBut not the real `UserService`.\n-->\n<p>컴포넌트에는 의존성 객체가 주입되기도 합니다.</p>\n<p><code>WelcomeComponent</code>는 로그인한 사용자에게 환영 메시지를 표시하는 컴포넌트입니다.\n이 컴포넌트는 로그인한 사용자가 누군지 알아내기 위해 <code>UserService</code>를 의존성으로 주입받습니다:</p>\n<code-example path=\"testing/src/app/welcome/welcome.component.ts\" header=\"app/welcome/welcome.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\nimport { UserService } from '../model/user.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-welcome',\n  template: '&#x3C;h3 class=\"welcome\">&#x3C;i>{{welcome}}&#x3C;/i>&#x3C;/h3>'\n})\nexport class WelcomeComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  welcome: string;\n  constructor(private userService: UserService) { }\n\n  ngOnInit(): void {\n    this.welcome = this.userService.isLoggedIn ?\n      'Welcome, ' + this.userService.user.name : 'Please log in.';\n  }\n}\n\n\n</code-example>\n<p>그러면 <code>WelcomeComponent</code>와 <code>UserService</code>가 상호작용하는 로직을 테스트 코드로 작성해볼 수 있습니다.\n테스트 모듈은 이렇게 구성합니다:</p>\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"config-test-module\" header=\"app/welcome/welcome.component.spec.ts\">\nTestBed.configureTestingModule({\n   declarations: [ WelcomeComponent ],\n// providers: [ UserService ],  // NO! 프로바이더에 실제 서비스 클래스를 등록하면 안됩니다!\n                                // 목 서비스를 등록하세요.\n   providers: [ { provide: UserService, useValue: userServiceStub } ],\n});\n\n</code-example>\n<p>이제 <code>providers</code> 배열에 <code>UserService</code> 프로바이더를 추가해서 테스트 코드를 작성해 봅시다.\n하지만 실제 <code>UserService</code>를 사용하지는 않을 것입니다.</p>\n<a id=\"service-test-doubles\"></a>\n<!--\n#### Provide service test doubles\n-->\n<h4 id=\"목-서비스-프로바이더-등록하기\">목 서비스 프로바이더 등록하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#목-서비스-프로바이더-등록하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nA _component-under-test_ doesn't have to be injected with real services.\nIn fact, it is usually better if they are test doubles (stubs, fakes, spies, or mocks).\nThe purpose of the spec is to test the component, not the service,\nand real services can be trouble.\n\nInjecting the real `UserService` could be a nightmare.\nThe real service might ask the user for login credentials and\nattempt to reach an authentication server.\nThese behaviors can be hard to intercept.\nIt is far easier and safer to create and register a test double in place of the real `UserService`.\n\nThis particular test suite supplies a minimal mock of the `UserService` that satisfies the needs of the `WelcomeComponent` and its tests:\n\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"user-service-stub\" header=\"app/welcome/welcome.component.spec.ts\">\nlet userServiceStub: Partial&lt;UserService&gt;;\n\n  userServiceStub = {\n    isLoggedIn: true,\n    user: { name: &#39;Test User&#39; },\n  };\n\n</code-example>\n-->\n<p>컴포넌트를 테스트할 때는 실제 서비스 객체를 주입하지 않고 목 객체를 주입하는 것이 더 편합니다.\n목 객체는 mocks, subs, fakes, spies과 같은 용어로 언급하기도 합니다.\n컴포넌트를 테스트하는 이유는 컴포넌트의 기능을 검사하는 것이지 서비스를 검사하는 것이 아닙니다.</p>\n<p>컴포넌트에 실제 서비스 객체를 주입하면 상황이 복잡해지기만 할 뿐입니다.\n<code>UserService</code>가 실제로 사용되는 객체로 주입되면 이 서비스는 사용자의 로그인 정보를 확인하기 위해 인증 서버로 HTTP 요청을 보낼 수 있습니다.\n이 동작은 중간에 가로채기도 힘듭니다.\n이것보다는 만들기 쉽고 활용하기도 쉬운 목 객체를 활용하는 방법이 훨씬 쉽습니다.</p>\n<p>아래 코드는 <code>WelcomeComponent</code>를 테스트할 때 꼭 필요한 내용만 구현한 <code>UserService</code> 목 객체 코드입니다:</p>\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"user-service-stub\" header=\"app/welcome/welcome.component.spec.ts\">\nlet userServiceStub: Partial&#x3C;UserService>;\n\n  userServiceStub = {\n    isLoggedIn: true,\n    user: { name: 'Test User' },\n  };\n\n</code-example>\n<a id=\"get-injected-service\"></a>\n<a id=\"get-injected-services\"></a>\n<!--\n#### Get injected services\n-->\n<h4 id=\"의존성으로-주입한-서비스-참조하기\">의존성으로 주입한 서비스 참조하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#의존성으로-주입한-서비스-참조하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe tests need access to the (stub) `UserService` injected into the `WelcomeComponent`.\n\nAngular has a hierarchical injection system.\nThere can be injectors at multiple levels, from the root injector created by the `TestBed`\ndown through the component tree.\n\nThe safest way to get the injected service, the way that **_always works_**,\nis to **get it from the injector of the _component-under-test_**.\nThe component injector is a property of the fixture's `DebugElement`.\n\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"injected-service\" header=\"WelcomeComponent's injector\">\n// 컴포넌트에 주입된 UserService를 가져옵니다.\nuserService = fixture.debugElement.injector.get(UserService);\n\n</code-example>\n-->\n<p>테스트 코드를 작성하다보면 <code>WelcomeComponent</code>에 주입된 (목) <code>UserService</code>를 참조해야 하는 경우가 있습니다.</p>\n<p>Angular는 의존성 주입 시스템을 계층으로 구성합니다.\n그래서 최상위 인젝터(injector)부터 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 안에 있는 테스트 대상 컴포넌트까지 존재하는 트리 여러 계층에 인젝터가 존재할 수 있습니다.</p>\n<p>의존성으로 주입된 서비스 객체를 참조하는 방법 중 가장 안전하고, <strong><em>언제나 동작하는</em></strong> 방법은 테스트하는 컴포넌트 안에 있는 인젝터를 사용하는 방법입니다.\n컴포넌트 인젝터는 픽스쳐의 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>로 참조할 수 있습니다.</p>\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"injected-service\" header=\"WelcomeComponent&#x27;s injector\">\n// 컴포넌트에 주입된 UserService를 가져옵니다.\nuserService = fixture.debugElement.injector.get(UserService);\n\n</code-example>\n<a id=\"testbed-inject\"></a>\n<h4 id=\"testbedinject\"><em>TestBed.inject()</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#testbedinject\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nYou _may_ also be able to get the service from the root injector via `TestBed.inject()`.\nThis is easier to remember and less verbose.\nBut it only works when Angular injects the component with the service instance in the test's root injector.\n\nIn this test suite, the _only_ provider of `UserService` is the root testing module,\nso it is safe to call `TestBed.inject()` as follows:\n\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"inject-from-testbed\" header=\"TestBed injector\">\n// 최상위 인젝터에서 UserService를 가져옵니다.\nuserService = TestBed.inject(UserService);\n\n</code-example>\n\n<div class=\"alert is-helpful\">\n\nFor a use case in which `TestBed.inject()` does not work,\nsee the [_Override component providers_](#component-override) section that\nexplains when and why you must get the service from the component's injector instead.\n\n</div>\n-->\n<p>의존성으로 주입된 서비스의 인스턴스는 최상위 인젝터 <code>TestBed.inject()</code>를 사용해서 참조할 수도 있습니다.\n이 방법은 쉽고 간단하며 번거롭지도 않습니다.\n하지만 이 방법은 테스트 모듈의 인젝터에 등록된 서비스 인스턴스를 컴포넌트에 주입했을 때만 동작합니다.</p>\n<p>이 문서에서 다루는 테스트 코드는 테스트 모듈 계층에 <code>UserService</code>를 직접 등록하기 때문에 <code>TestBed.inject()</code>를 사용할 수 있습니다:</p>\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"inject-from-testbed\" header=\"TestBed injector\">\n// 최상위 인젝터에서 UserService를 가져옵니다.\nuserService = TestBed.inject(UserService);\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>컴포넌트 인젝터에 서비스 프로바이더가 등록되면 <code>TestBed.inject()</code>로 인스턴스를 참조하지 못할 수 있습니다.\n자세한 내용은 <a href=\"guide/testing-components-scenarios#component-override\">컴포넌트 프로바이더 오버라이드하기</a> 섹션을 참고하세요.</p>\n</div>\n<a id=\"welcome-spec-setup\"></a>\n<!--\n#### Final setup and tests\n-->\n<h4 id=\"환경설정-마무리-테스트\">환경설정 마무리, 테스트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#환경설정-마무리-테스트\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nHere's the complete `beforeEach()`, using `TestBed.inject()`:\n\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"setup\" header=\"app/welcome/welcome.component.spec.ts\">\nlet userServiceStub: Partial&lt;UserService&gt;;\n\nbeforeEach(() =&gt; {\n  // 테스트하기 위해 만든 목 UserService\n  userServiceStub = {\n    isLoggedIn: true,\n    user: { name: &#39;Test User&#39; },\n  };\n\n  TestBed.configureTestingModule({\n     declarations: [ WelcomeComponent ],\n     providers: [ { provide: UserService, useValue: userServiceStub } ],\n  });\n\n  fixture = TestBed.createComponent(WelcomeComponent);\n  comp    = fixture.componentInstance;\n\n  // 최상위 인젝터에서 UserService를 가져옵니다.\n  userService = TestBed.inject(UserService);\n\n  // 클래스 이름으로 CSS 셀렉터를 사용해서 &quot;welcome&quot; 엘리먼트를 가져옵니다.\n  el = fixture.nativeElement.querySelector(&#39;.welcome&#39;);\n});\n\n</code-example>\n\nAnd here are some tests:\n\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"tests\" header=\"app/welcome/welcome.component.spec.ts\">\nit(&#39;should welcome the user&#39;, () =&gt; {\n  fixture.detectChanges();\n  const content = el.textContent;\n  expect(content).toContain(&#39;Welcome&#39;, &#39;&quot;Welcome ...&quot;&#39;);\n  expect(content).toContain(&#39;Test User&#39;, &#39;expected name&#39;);\n});\n\nit(&#39;should welcome &quot;Bubba&quot;&#39;, () =&gt; {\n  userService.user.name = &#39;Bubba&#39;; // 환영 메시지는 아직 표시되지 않습니다.\n  fixture.detectChanges();\n  expect(el.textContent).toContain(&#39;Bubba&#39;);\n});\n\nit(&#39;should request login if not logged in&#39;, () =&gt; {\n  userService.isLoggedIn = false; // 환영 메시지는 아직 표시되지 않습니다.\n  fixture.detectChanges();\n  const content = el.textContent;\n  expect(content).not.toContain(&#39;Welcome&#39;, &#39;not welcomed&#39;);\n  expect(content).toMatch(/log in/i, &#39;&quot;log in&quot;&#39;);\n});\n\n</code-example>\n\nThe first is a sanity test; it confirms that the stubbed `UserService` is called and working.\n\n<div class=\"alert is-helpful\">\n\nThe second parameter to the Jasmine matcher (e.g., `'expected name'`) is an optional failure label.\nIf the expectation fails, Jasmine appends this label to the expectation failure message.\nIn a spec with multiple expectations, it can help clarify what went wrong and which expectation failed.\n\n</div>\n\nThe remaining tests confirm the logic of the component when the service returns different values.\nThe second test validates the effect of changing the user name.\nThe third test checks that the component displays the proper message when there is no logged-in user.\n-->\n<p><code>TestBed.inject()</code>를 활용해서 작성한 <code>beforeEach()</code> 코드는 이렇습니다:</p>\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"setup\" header=\"app/welcome/welcome.component.spec.ts\">\nlet userServiceStub: Partial&#x3C;UserService>;\n\nbeforeEach(() => {\n  // 테스트하기 위해 만든 목 UserService\n  userServiceStub = {\n    isLoggedIn: true,\n    user: { name: 'Test User' },\n  };\n\n  TestBed.configureTestingModule({\n     declarations: [ WelcomeComponent ],\n     providers: [ { provide: UserService, useValue: userServiceStub } ],\n  });\n\n  fixture = TestBed.createComponent(WelcomeComponent);\n  comp    = fixture.componentInstance;\n\n  // 최상위 인젝터에서 UserService를 가져옵니다.\n  userService = TestBed.inject(UserService);\n\n  // 클래스 이름으로 CSS 셀렉터를 사용해서 \"welcome\" 엘리먼트를 가져옵니다.\n  el = fixture.nativeElement.querySelector('.welcome');\n});\n\n</code-example>\n<p>그리고 테스트 코드는 이렇습니다:</p>\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"tests\" header=\"app/welcome/welcome.component.spec.ts\">\nit('should welcome the user', () => {\n  fixture.detectChanges();\n  const content = el.textContent;\n  expect(content).toContain('Welcome', '\"Welcome ...\"');\n  expect(content).toContain('Test User', 'expected name');\n});\n\nit('should welcome \"Bubba\"', () => {\n  userService.user.name = 'Bubba'; // 환영 메시지는 아직 표시되지 않습니다.\n  fixture.detectChanges();\n  expect(el.textContent).toContain('Bubba');\n});\n\nit('should request login if not logged in', () => {\n  userService.isLoggedIn = false; // 환영 메시지는 아직 표시되지 않습니다.\n  fixture.detectChanges();\n  const content = el.textContent;\n  expect(content).not.toContain('Welcome', 'not welcomed');\n  expect(content).toMatch(/log in/i, '\"log in\"');\n});\n\n</code-example>\n<p>첫 번째 테스트 코드는 테스트 코드 자체가 잘 동작하는지 확인하는 테스트 코드입니다.\n이 테스트 코드는 <code>UserService</code> 목 객체가 제대로 동작하는지 검사합니다.</p>\n<div class=\"alert is-helpful\">\n<p>Jasmine 검증식(matcher)에 두 번째로 전달하는 인자(<code>'expected name'</code>)는 생략할 수 있으며, 이 인자를 지정하면 해당 검증식이 실패했을 때 인자로 지정한 문구가 표시됩니다.\n테스트 코드에 검증식이 여러개 사용되며 이중에 어떤 것이 실패했는지 빠르게 확인하려면 이 인자를 활용하는 것이 좋습니다.</p>\n</div>\n<p>두 번째 테스트 코드와 세 번째 테스트 코드는 컴포넌트가 서비스와 제대로 상호작용하는지 확인하는 코드입니다.\n두 번째 테스트 코드는 사용자의 이름이 변경된 것을 확인하는 코드입니다.\n그리고 세 번째 코드는 사용자가 로그인하지 않았을 때 적절한 메시지를 화면에 표시하는지 확인하는 코드입니다.</p>\n<hr>\n<a id=\"component-with-async-service\"></a>\n<!--\n## Component with async service\n-->\n<h2 id=\"비동기-서비스를-주입받는-컴포넌트\">비동기 서비스를 주입받는 컴포넌트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#비동기-서비스를-주입받는-컴포넌트\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nIn this sample, the `AboutComponent` template hosts a `TwainComponent`.\nThe `TwainComponent` displays Mark Twain quotes.\n\n<code-example path=\"testing/src/app/twain/twain.component.ts\" region=\"template\" header=\"app/twain/twain.component.ts (template)\">\ntemplate: `\n  &lt;p class=&quot;twain&quot;&gt;&lt;i&gt;{{quote | async}}&lt;/i&gt;&lt;/p&gt;\n  &lt;button (click)=&quot;getQuote()&quot;&gt;Next quote&lt;/button&gt;\n  &lt;p class=&quot;error&quot; *ngIf=&quot;errorMessage&quot;&gt;{{ errorMessage }}&lt;/p&gt;`,\n\n</code-example>\n\nNote that the value of the component's `quote` property passes through an `AsyncPipe`.\nThat means the property returns either a `Promise` or an `Observable`.\n\nIn this example, the `TwainComponent.getQuote()` method tells you that\nthe `quote` property returns an `Observable`.\n\n<code-example path=\"testing/src/app/twain/twain.component.ts\" region=\"get-quote\" header=\"app/twain/twain.component.ts (getQuote)\">\ngetQuote() {\n  this.errorMessage = &#39;&#39;;\n  this.quote = this.twainService.getQuote().pipe(\n    startWith(&#39;...&#39;),\n    catchError( (err: any) =&gt; {\n      // 이번 싸이클에서 errorMessage가 한 번 할당되었기 때문에 한 싸이클 기다립니다.\n      setTimeout(() =&gt; this.errorMessage = err.message || err.toString());\n      return of(&#39;...&#39;); // quote 프로퍼티의 값을 &#39;...&#39;로 재설정합니다.\n    })\n  );\n\n</code-example>\n\nThe `TwainComponent` gets quotes from an injected `TwainService`.\nThe component starts the returned `Observable` with a placeholder value (`'...'`),\nbefore the service can return its first quote.\n\nThe `catchError` intercepts service errors, prepares an error message,\nand returns the placeholder value on the success channel.\nIt must wait a tick to set the `errorMessage`\nin order to avoid updating that message twice in the same change detection cycle.\n\nThese are all features you'll want to test.\n-->\n<p>이번에는 <code>AboutComponent</code> 템플릿에 <code>TwainComponent</code>가 존재하는 예제에 대해 알아봅시다.\n<code>TwainComponent</code>는 마크 트웨인(Mark Twain)의 명언을 화면에 표시하는 컴포넌트입니다.</p>\n<code-example path=\"testing/src/app/twain/twain.component.ts\" region=\"template\" header=\"app/twain/twain.component.ts (템플릿)\">\ntemplate: `\n  &#x3C;p class=\"twain\">&#x3C;i>{{quote | <a href=\"api/common/AsyncPipe\" class=\"code-anchor\">async</a>}}&#x3C;/i>&#x3C;/p>\n  &#x3C;button (click)=\"getQuote()\">Next quote&#x3C;/button>\n  &#x3C;p class=\"error\" *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"errorMessage\">{{ errorMessage }}&#x3C;/p>`,\n\n</code-example>\n<p>컴포넌트의 <code>quote</code> 프로퍼티는 <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">AsyncPipe</a></code>를 거쳐 화면에 표시됩니다.\n이 말은 프로퍼티 자체가 반환하는 타입은 <code>Promise</code>나 <code>Observable</code>이라는 뜻입니다.</p>\n<p>그리고 <code>TwainComponent.getQuote()</code> 메서드도 <code>quote</code>와 마찬가지로 <code>Observable</code> 타입을 반환합니다.</p>\n<code-example path=\"testing/src/app/twain/twain.component.ts\" region=\"get-quote\" header=\"app/twain/twain.component.ts (getQuote())\">\ngetQuote() {\n  this.errorMessage = '';\n  this.quote = this.twainService.getQuote().pipe(\n    startWith('...'),\n    catchError( (err: any) => {\n      // 이번 싸이클에서 errorMessage가 한 번 할당되었기 때문에 한 싸이클 기다립니다.\n      setTimeout(() => this.errorMessage = err.message || err.toString());\n      return of('...'); // quote 프로퍼티의 값을 '...'로 재설정합니다.\n    })\n  );\n\n</code-example>\n<p><code>TwainComponent</code>는 <code>TwainService</code>를 의존성으로 주입받습니다.\n이 컴포넌트는 인스턴스가 생성된 후에 <code>Observable</code>을 구독하며 이후에 서비스에서 받아온 명언을 <code>'...'</code>라고 표시된 부분에 표시합니다.</p>\n<p><code>catchError</code>는 서비스에서 발생한 에러를 가로채며 에러 메시지를 표시하거나 템플릿에 표시되는 문구를 초기값으로 되돌립니다.\n그리고 같은 변화 감지 싸이클에서 메시지가 두 번 변경되는 것을 방지하기 위해 <code>errorMessage</code>가 제대로 할당되기까지 실행 싸이클을 한 번 기다려야 합니다.</p>\n<p>이런 테스트 코드를 작성해 봅시다.</p>\n<!--\n#### Testing with a spy\n-->\n<h4 id=\"스파이-활용하기\">스파이 활용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#스파이-활용하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nWhen testing a component, only the service's public API should matter.\nIn general, tests themselves should not make calls to remote servers.\nThey should emulate such calls. The setup in this `app/twain/twain.component.spec.ts` shows one way to do that:\n\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"setup\" header=\"app/twain/twain.component.spec.ts (setup)\">\nbeforeEach(() =&gt; {\n  testQuote = &#39;Test Quote&#39;;\n\n  // `getQuote()` 스파이 메소드가 선언된 가짜 TwainService 객체를 정의합니다.\n  const twainService = jasmine.createSpyObj(&#39;TwainService&#39;, [&#39;getQuote&#39;]);\n  // `getQuote()` 메소드는 테스트 데이터를 Observable 형태로 즉시 반환합니다.\n  getQuoteSpy = twainService.getQuote.and.returnValue(of(testQuote));\n\n  TestBed.configureTestingModule({\n    declarations: [TwainComponent],\n    providers: [{provide: TwainService, useValue: twainService}]\n  });\n\n  fixture = TestBed.createComponent(TwainComponent);\n  component = fixture.componentInstance;\n  quoteEl = fixture.nativeElement.querySelector(&#39;.twain&#39;);\n});\n\n</code-example>\n\n<a id=\"service-spy\"></a>\n\nFocus on the spy.\n\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"spy\">\n// `getQuote()` 스파이 메소드가 선언된 가짜 TwainService 객체를 정의합니다.\nconst twainService = jasmine.createSpyObj(&#39;TwainService&#39;, [&#39;getQuote&#39;]);\n// `getQuote()` 메소드는 테스트 데이터를 Observable 형태로 즉시 반환합니다.\ngetQuoteSpy = twainService.getQuote.and.returnValue(of(testQuote));\n\n</code-example>\n\nThe spy is designed such that any call to `getQuote` receives an observable with a test quote.\nUnlike the real `getQuote()` method, this spy bypasses the server\nand returns a synchronous observable whose value is available immediately.\n\nYou can write many useful tests with this spy, even though its `Observable` is synchronous.\n-->\n<p>컴포넌트를 테스트할 때는 이 컴포넌트에 주입되는 서비스 클래스의 public API만 신경쓰면 됩니다.\n그리고 일반적으로 리모트 서버로 보내는 HTTP 요청은 생략하고 다른 로직으로 대체합니다.\n그래서 <code>app/twain/twain.component.spec.ts</code> 파일의 환경설정 코드는 이렇게 구성되어 있습니다:</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"setup\" header=\"app/twain/twain.component.spec.ts (환경설정)\">\nbeforeEach(() => {\n  testQuote = 'Test Quote';\n\n  // `getQuote()` 스파이 메소드가 선언된 가짜 TwainService 객체를 정의합니다.\n  const twainService = jasmine.createSpyObj('TwainService', ['getQuote']);\n  // `getQuote()` 메소드는 테스트 데이터를 Observable 형태로 즉시 반환합니다.\n  getQuoteSpy = twainService.getQuote.and.returnValue(of(testQuote));\n\n  TestBed.configureTestingModule({\n    declarations: [TwainComponent],\n    providers: [{provide: TwainService, useValue: twainService}]\n  });\n\n  fixture = TestBed.createComponent(TwainComponent);\n  component = fixture.componentInstance;\n  quoteEl = fixture.nativeElement.querySelector('.twain');\n});\n\n</code-example>\n<a id=\"service-spy\"></a>\n<p>스파이 코드를 선언한 부분을 봅시다.</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"spy\">\n// `getQuote()` 스파이 메소드가 선언된 가짜 TwainService 객체를 정의합니다.\nconst twainService = jasmine.createSpyObj('TwainService', ['getQuote']);\n// `getQuote()` 메소드는 테스트 데이터를 Observable 형태로 즉시 반환합니다.\ngetQuoteSpy = twainService.getQuote.and.returnValue(of(testQuote));\n\n</code-example>\n<p>이 스파이는 테스트 동작에 사용되는 <code>getQuote</code> 옵저버블을 대신합니다.\n이 객체는 실제 <code>getQuote()</code> 메서드가 서버로 요청을 보내고 받는 동작을 실제로 수행하지 않고 동기 방식으로 옵저버블로 데이터를 전달합니다.</p>\n<p>스파이를 활용하면 테스트 코드를 간단하게 작성할 수 있습니다.\n게다가 이 스파이는 동기 방식으로 동작하기 때문에 비동기 옵저버블을 다루는 것보다 편합니다.</p>\n<a id=\"sync-tests\"></a>\n<!--\n#### Synchronous tests\n-->\n<h4 id=\"동기-테스트\">동기 테스트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#동기-테스트\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nA key advantage of a synchronous `Observable` is that\nyou can often turn asynchronous processes into synchronous tests.\n\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"sync-test\">\nit(&#39;should show quote after component initialized&#39;, () =&gt; {\n  fixture.detectChanges();  // onInit()\n\n  // 스파이 메소드가 반환한 결과는 컴포넌트가 초기화된 이후에 바로 표시됩니다.\n  expect(quoteEl.textContent).toBe(testQuote);\n  expect(getQuoteSpy.calls.any()).toBe(true, &#39;getQuote called&#39;);\n});\n\n</code-example>\n\nBecause the spy result returns synchronously, the `getQuote()` method updates\nthe message on screen immediately _after_\nthe first change detection cycle during which Angular calls `ngOnInit`.\n\nYou're not so lucky when testing the error path.\nAlthough the service spy will return an error synchronously,\nthe component method calls `setTimeout()`.\nThe test must wait at least one full turn of the JavaScript engine before the\nvalue becomes available. The test must become _asynchronous_.\n-->\n<p><code>Observable</code>을 동기 방식으로 사용했을 때 가장 좋은 점은 비동기 동작을 동기 방식으로 변경할 수 있다는 것입니다.</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"sync-test\">\nit('should show quote after component initialized', () => {\n  fixture.detectChanges();  // onInit()\n\n  // 스파이 메소드가 반환한 결과는 컴포넌트가 초기화된 이후에 바로 표시됩니다.\n  expect(quoteEl.textContent).toBe(testQuote);\n  expect(getQuoteSpy.calls.any()).toBe(true, 'getQuote called');\n});\n\n</code-example>\n<p>이 스파이는 데이터를 즉시 반환하는 옵저버블이기 때문에 <code>getQuote()</code> 메서드로 받아오는 메시지도 Angular가 <code>ngOnInit</code> 라이프 싸이클 메서드를 실행하자마자 즉시 화면에 표시됩니다.</p>\n<p>하지만 에러가 발생했을 때는 상황이 조금 다릅니다.\n스파이 서비스가 에러를 에러를 동기 방식으로 반환하기는 하지만 컴포넌트 메서드가 <code>setTimeout()</code>을 실행하기 때문입니다.\n그래서 이 테스트 코드에서 새로 할당된 값을 확인하려면 JavaScript 엔진 실행 싸이클을 한 번 기다려야 합니다.\n결국 테스트가 <em>비동기로</em> 동작해야 합니다.</p>\n<a id=\"fake-async\"></a>\n<!--\n#### Async test with _fakeAsync()_\n-->\n<h4 id=\"fakeasync-로-비동기-테스트하기\"><em>fakeAsync()</em> 로 비동기 테스트하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#fakeasync-로-비동기-테스트하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nTo use `fakeAsync()` functionality, you must import `zone.js/dist/zone-testing` in your test setup file.\nIf you created your project with the Angular CLI, `zone-testing` is already imported in `src/test.ts`.\n\nThe following test confirms the expected behavior when the service returns an `ErrorObservable`.\n\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"error-test\">\nit(&#39;should display error when TwainService fails&#39;, fakeAsync(() =&gt; {\n     // 스파이 메소드가 에러를 Observable 타입으로 반환합니다.\n     getQuoteSpy.and.returnValue(throwError(&#39;TwainService test failure&#39;));\n\n     fixture.detectChanges();  // onInit()\n     // 스파이가 보내는 에러는 init이 실행된 직후에 받습니다.\n\n     tick();  // 컴포넌트가 실행한 setTimeout()을 끝냅니다.\n\n     fixture.detectChanges();  // setTimeout() 안에서 변경한 errorMessage를 반영합니다.\n\n     expect(errorMessage()).toMatch(/test failure/, &#39;should display error&#39;);\n     expect(quoteEl.textContent).toBe(&#39;...&#39;, &#39;should show placeholder&#39;);\n   }));\n\n</code-example>\n\nNote that the `it()` function receives an argument of the following form.\n\n```javascript\nfakeAsync(() => { /* test body */ })\n```\n\nThe `fakeAsync()` function enables a linear coding style by running the test body in a special `fakeAsync test zone`.\nThe test body appears to be synchronous.\nThere is no nested syntax (like a `Promise.then()`) to disrupt the flow of control.\n\n<div class=\"alert is-helpful\">\n\nLimitation: The `fakeAsync()` function won't work if the test body makes an `XMLHttpRequest` (XHR) call.\nXHR calls within a test are rare, but if you need to call XHR, see [`waitForAsync()`](#waitForAsync), below.\n\n</div>\n-->\n<p><code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 기능을 사용하려면 테스트 환경설정 파일에서 <code>zone.js/dist/zone-testing</code> 라이브러리를 로드해야 합니다.\n그리고 Angular CLI로 프로젝트를 생성했다면 <code>src/test.ts</code> 파일에 <code>zone-testing</code>이 이미 추가되어 있습니다.</p>\n<p>아래 코드는 서비스가 <code>ErrorObservable</code>을 반환했을 때 에러를 처리하는 테스트 코드입니다.</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"error-test\">\nit('should display error when TwainService fails', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() => {\n     // 스파이 메소드가 에러를 Observable 타입으로 반환합니다.\n     getQuoteSpy.and.returnValue(throwError('TwainService test failure'));\n\n     fixture.detectChanges();  // onInit()\n     // 스파이가 보내는 에러는 init이 실행된 직후에 받습니다.\n\n     <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>();  // 컴포넌트가 실행한 setTimeout()을 끝냅니다.\n\n     fixture.detectChanges();  // setTimeout() 안에서 변경한 errorMessage를 반영합니다.\n\n     expect(errorMessage()).toMatch(/test failure/, 'should display error');\n     expect(quoteEl.textContent).toBe('...', 'should show placeholder');\n   }));\n\n</code-example>\n<p>이 코드에서 <code>it()</code> 함수가 받는 인자의 형태는 이렇습니다.</p>\n<code-example language=\"javascript\">\n<a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() => { /* 테스트 코드 */ })\n</code-example>\n<p><code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 함수를 활용하면 테스트 코드가 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a> 테스트 존</code> 안에서 실행되기 때문에 코드를 동기 방식으로 작성할 수 있습니다.\n그리고 테스트 코드도 동기 방식으로 실행되는 것처럼 보입니다.\n코드 실행 흐름을 헷갈리게 만드는 <code>Promise.then()</code>와 같은 문법은 사용하지 않아도 됩니다.</p>\n<div class=\"alert is-helpful\">\n<p>한계: <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 함수 안에서 <code>XMLHttpRequest</code> (XHR)를 활용하는 코드는 제대로 동작하지 않습니다.\n테스트 코드에서 XHR 요청을 실제로 보내는 경우는 거의 없습니다.\n실제로 요청을 보내야 한다면 <a href=\"guide/testing-components-scenarios#waitForAsync\"><code>waitForAsync()</code></a> 섹션을 참고하세요.</p>\n</div>\n<a id=\"tick\"></a>\n<!--\n#### The _tick()_ function\n-->\n<h4 id=\"tick-함수\"><em>tick()</em> 함수<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#tick-함수\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nYou do have to call [tick()](api/core/testing/tick) to advance the (virtual) clock.\n\nCalling [tick()](api/core/testing/tick) simulates the passage of time until all pending asynchronous activities finish.\nIn this case, it waits for the error handler's `setTimeout()`.\n\nThe [tick()](api/core/testing/tick) function accepts milliseconds and tickOptions as parameters, the millisecond (defaults to 0 if not provided) parameter represents how much the virtual clock advances. For example, if you have a `setTimeout(fn, 100)` in a `fakeAsync()` test, you need to use tick(100) to trigger the fn callback. The tickOptions is an optional parameter with a property called `processNewMacroTasksSynchronously` (defaults to true) that represents whether to invoke new generated macro tasks when ticking.\n\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-tick\">\nit(&#39;should run timeout callback with delay after call tick with millis&#39;, fakeAsync(() =&gt; {\n     let called = false;\n     setTimeout(() =&gt; {\n       called = true;\n     }, 100);\n     tick(100);\n     expect(called).toBe(true);\n   }));\n\n</code-example>\n\nThe [tick()](api/core/testing/tick) function is one of the Angular testing utilities that you import with `TestBed`.\nIt's a companion to `fakeAsync()` and you can only call it within a `fakeAsync()` body.\n-->\n<p><a href=\"api/core/testing/tick\">tick()</a> 함수는 (가상) 시계를 앞으로 감는 용도로 사용합니다.</p>\n<p>그래서 <a href=\"api/core/testing/tick\">tick()</a> 함수를 실행하면 다음 비동기 작업이 있는 시점까지 시간이 지난 것으로 간주할 수 있습니다.\n위 섹션에서 다룬 코드에서는 에러가 처리되는 <code>setTimeout()</code> 시점으로 이동합니다.</p>\n<p><a href=\"api/core/testing/tick\">tick()</a> 함수는 밀리초 단위 숫자나 <code>tickOptions</code> 객체를 인자로 받아서 원하는 시간 만큼 이동할 수 있으며, 인자 없이 사용하면 0이 사용됩니다.\n그래서 아래 코드처럼 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 안에서 <code>setTimeout(fn, 100)</code>을 사용한 후에 <code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>()</code>을 실행하면 타이머 콜백 함수를 실행할 수 있습니다.\n<code>tickOptions</code>는 옵션 객체이며 <code>processNewMacroTasksSynchronously</code> 프로퍼티를 지정할 수 있습니다.\n이 옵션의 기본값은 <code>true</code>이고, <code>true</code>를 사용하면 다음 매크로 태스크를 즉시 실행합니다.</p>\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-tick\">\nit('should run timeout callback with delay after call <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a> with millis', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() => {\n     let called = false;\n     setTimeout(() => {\n       called = true;\n     }, 100);\n     <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(100);\n     expect(called).toBe(true);\n   }));\n\n</code-example>\n<p><a href=\"api/core/testing/tick\">tick()</a> 함수는 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 라이브러리가 제공하는 함수 중 하나이며 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 안에서만 사용할 수 있습니다.</p>\n<h4 id=\"tickoptions\">tickOptions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#tickoptions\"><i class=\"material-icons\">link</i></a></h4>\n<!--\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-tick-new-macro-task-sync\">\nit(&#39;should run new macro task callback with delay after call tick with millis&#39;,\n   fakeAsync(() =&gt; {\n     function nestedTimer(cb: () =&gt; any): void {\n       setTimeout(() =&gt; setTimeout(() =&gt; cb()));\n     }\n     const callback = jasmine.createSpy(&#39;callback&#39;);\n     nestedTimer(callback);\n     expect(callback).not.toHaveBeenCalled();\n     tick(0);\n     // 중첩된 setTimeout도 함께 실행됩니다.\n     expect(callback).toHaveBeenCalled();\n   }));\n\n</code-example>\n\nIn this example, we have a new macro task (nested setTimeout), by default, when we `tick`, the setTimeout `outside` and `nested` will both be triggered.\n\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-tick-new-macro-task-async\">\nit(&#39;should not run new macro task callback with delay after call tick with millis&#39;,\n   fakeAsync(() =&gt; {\n     function nestedTimer(cb: () =&gt; any): void {\n       setTimeout(() =&gt; setTimeout(() =&gt; cb()));\n     }\n     const callback = jasmine.createSpy(&#39;callback&#39;);\n     nestedTimer(callback);\n     expect(callback).not.toHaveBeenCalled();\n     tick(0, {processNewMacroTasksSynchronously: false});\n     // the nested timeout will not be triggered\n     expect(callback).not.toHaveBeenCalled();\n     tick(0);\n     expect(callback).toHaveBeenCalled();\n   }));\n\n</code-example>\n\nAnd in some case, we don't want to trigger the new macro task when ticking, we can use `tick(milliseconds, {processNewMacroTasksSynchronously: false})` to not invoke new macro task.\n-->\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-tick-new-macro-task-sync\">\nit('should run new macro task callback with delay after call <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a> with millis',\n   <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() => {\n     function nestedTimer(cb: () => any): void {\n       setTimeout(() => setTimeout(() => cb()));\n     }\n     const callback = jasmine.createSpy('callback');\n     nestedTimer(callback);\n     expect(callback).not.toHaveBeenCalled();\n     <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(0);\n     // 중첩된 setTimeout도 함께 실행됩니다.\n     expect(callback).toHaveBeenCalled();\n   }));\n\n</code-example>\n<p>위 예제에서 <code>setTimeout()</code> 안에는 또다른 매크로 태스크(setTimeout)이 있는데, <code>setTimeout</code> 밖에서 <code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a></code> 함수를 실행하면 <code>setTimeout</code> 콜백과 그 안쪽에 있는 <code>setTimeout</code> 콜백이 동시에 실행됩니다.</p>\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-tick-new-macro-task-async\">\nit('should not run new macro task callback with delay after call <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a> with millis',\n   <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() => {\n     function nestedTimer(cb: () => any): void {\n       setTimeout(() => setTimeout(() => cb()));\n     }\n     const callback = jasmine.createSpy('callback');\n     nestedTimer(callback);\n     expect(callback).not.toHaveBeenCalled();\n     <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(0, {processNewMacroTasksSynchronously: false});\n     // the nested timeout will not be triggered\n     expect(callback).not.toHaveBeenCalled();\n     <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(0);\n     expect(callback).toHaveBeenCalled();\n   }));\n\n</code-example>\n<p>상황에 따라 원하는 타이머만 실행하려면 <code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(밀리초, {processNewMacroTasksSynchronously: false})</code>라고 실행하면 됩니다.</p>\n<!--\n#### Comparing dates inside fakeAsync()\n-->\n<h4 id=\"fakeasync-안에서-시간-확인하기\"><code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 안에서 시간 확인하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#fakeasync-안에서-시간-확인하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\n`fakeAsync()` simulates passage of time, which allows you to calculate the difference between dates inside `fakeAsync()`.\n\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-date\">\nit(&#39;should get Date diff correctly in fakeAsync&#39;, fakeAsync(() =&gt; {\n     const start = Date.now();\n     tick(100);\n     const end = Date.now();\n     expect(end - start).toBe(100);\n   }));\n\n</code-example>\n-->\n<p><code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>는 시간이 경과하는 것을 시뮬레이션하는 함수입니다.\n그래서 아래 코드처럼 구현하면 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 안에서 얼마나 시간이 흘렀는지 확인할 수 있습니다.</p>\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-date\">\nit('should get Date diff correctly in <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() => {\n     const start = Date.now();\n     <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(100);\n     const end = Date.now();\n     expect(end - start).toBe(100);\n   }));\n\n</code-example>\n<!--\n#### jasmine.clock with fakeAsync()\n-->\n<h4 id=\"jasmineclock과-함께-사용하기\">jasmine.clock과 함께 사용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#jasmineclock과-함께-사용하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nJasmine also provides a `clock` feature to mock dates. Angular automatically runs tests that are run after\n`jasmine.clock().install()` is called inside a `fakeAsync()` method until `jasmine.clock().uninstall()` is called. `fakeAsync()` is not needed and throws an error if nested.\n\nBy default, this feature is disabled. To enable it, set a global flag before importing `zone-testing`.\n\nIf you use the Angular CLI, configure this flag in `src/test.ts`.\n\n```\n(window as any)['__zone_symbol__fakeAsyncPatchLock'] = true;\nimport 'zone.js/dist/zone-testing';\n```\n\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-clock\">\ndescribe(&#39;use jasmine.clock()&#39;, () =&gt; {\n  // zone.js/dist/zone-testing 패키지를 로드하기 전에 __zone_symbol_fakeAsyncPatchLock 플래그 설정이 필요합니다.\n  beforeEach(() =&gt; {\n    jasmine.clock().install();\n  });\n  afterEach(() =&gt; {\n    jasmine.clock().uninstall();\n  });\n  it(&#39;should auto enter fakeAsync&#39;, () =&gt; {\n    // 이 코드는 fakeAsync 테스트 존 안에서 실행됩니다.\n    // 이 때 fakeAsync()를 명시적으로 실행할 필요는 없습니다.\n    let called = false;\n    setTimeout(() =&gt; {\n      called = true;\n    }, 100);\n    jasmine.clock().tick(100);\n    expect(called).toBe(true);\n  });\n});\n\n</code-example>\n-->\n<p>Jasmine도 시간을 조작하는 <code>clock</code> 기능을 제공합니다.\nAngular는 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 함수 안에서 <code>jasmine.clock().install()</code>이 실행되면 <code>jasmine.clock().uninstall()</code>이 실행되기 전까지 테스트 코드의 시간을 자동으로 진행합니다.\n<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>와 비슷한 동작을 하기 때문에 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>를 명시적으로 실행할 필요는 없으며, <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>가 필요한 상황이라면 에러가 발생합니다.</p>\n<p>이 기능은 기본적으로 비활성화되어 있습니다.\n이 기능을 활성화하려면 <code>zone-testing</code>을 로드하기 전에 전역 플래그 값을 지정해야 합니다.</p>\n<p>Angular CLI로 생성한 프로젝트라면 <code>src/test.ts</code> 파일에 이렇게 지정하면 됩니다.</p>\n<code-example>\n(window as any)['__zone_symbol__fakeAsyncPatchLock'] = true;\nimport 'zone.js/dist/zone-testing';\n</code-example>\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-clock\">\ndescribe('use jasmine.clock()', () => {\n  // zone.js/dist/zone-testing 패키지를 로드하기 전에 __zone_symbol_fakeAsyncPatchLock 플래그 설정이 필요합니다.\n  beforeEach(() => {\n    jasmine.clock().install();\n  });\n  afterEach(() => {\n    jasmine.clock().uninstall();\n  });\n  it('should auto enter <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>', () => {\n    // 이 코드는 <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a> 테스트 존 안에서 실행됩니다.\n    // 이 때 <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()를 명시적으로 실행할 필요는 없습니다.\n    let called = false;\n    setTimeout(() => {\n      called = true;\n    }, 100);\n    jasmine.clock().tick(100);\n    expect(called).toBe(true);\n  });\n});\n\n</code-example>\n<!--\n#### Using the RxJS scheduler inside fakeAsync()\n-->\n<h4 id=\"fakeasync-안에서-rxjs-스케쥴러-사용하기\"><code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 안에서 RxJS 스케쥴러 사용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#fakeasync-안에서-rxjs-스케쥴러-사용하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nYou can also use RxJS scheduler in `fakeAsync()` just like using `setTimeout()` or `setInterval()`, but you need to import `zone.js/dist/zone-patch-rxjs-fake-async` to patch RxJS scheduler.\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-rxjs\">\nit(&#39;should get Date diff correctly in fakeAsync with rxjs scheduler&#39;, fakeAsync(() =&gt; {\n    // rxjs 스케쥴러를 사용하기 위해 `import &#39;zone.js/dist/zone-patch-rxjs-fake-async&#39;를 추가해야 합니다.\n    let result = null;\n    of(&#39;hello&#39;).pipe(delay(1000)).subscribe(v =&gt; {\n       result = v;\n     });\n    expect(result).toBeNull();\n    tick(1000);\n    expect(result).toBe(&#39;hello&#39;);\n\n     const start = new Date().getTime();\n     let dateDiff = 0;\n     interval(1000).pipe(take(2)).subscribe(() =&gt; dateDiff = (new Date().getTime() - start));\n\n     tick(1000);\n     expect(dateDiff).toBe(1000);\n     tick(1000);\n     expect(dateDiff).toBe(2000);\n   }));\n\n</code-example>\n-->\n<p>RxJS 스케쥴러는 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 안에서 <code>setTimeout()</code>이나 <code>setInterval()</code>과 비슷하게 사용할 수 있지만, RxJS 스케쥴러를 사용하려면 <code>zone.js/dist/zone-patch-rxjs-fake-async</code> 라이브러리를 추가로 로드해야 합니다.</p>\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-rxjs\">\nit('should get Date diff correctly in <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a> with rxjs scheduler', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() => {\n    // rxjs 스케쥴러를 사용하기 위해 `import 'zone.js/dist/zone-patch-rxjs-fake-async'를 추가해야 합니다.\n    let result = null;\n    of('hello').pipe(delay(1000)).subscribe(v => {\n       result = v;\n     });\n    expect(result).toBeNull();\n    <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(1000);\n    expect(result).toBe('hello');\n\n     const start = new Date().getTime();\n     let dateDiff = 0;\n     interval(1000).pipe(take(2)).subscribe(() => dateDiff = (new Date().getTime() - start));\n\n     <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(1000);\n     expect(dateDiff).toBe(1000);\n     <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(1000);\n     expect(dateDiff).toBe(2000);\n   }));\n\n</code-example>\n<!--\n#### Support more macroTasks\n-->\n<h4 id=\"매크로-태스크-지원하기\">매크로 태스크 지원하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#매크로-태스크-지원하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nBy default, `fakeAsync()` supports the following macro tasks.\n\n- `setTimeout`\n- `setInterval`\n- `requestAnimationFrame`\n- `webkitRequestAnimationFrame`\n- `mozRequestAnimationFrame`\n\nIf you run other macro tasks such as `HTMLCanvasElement.toBlob()`, an _\"Unknown macroTask scheduled in fake async test\"_ error will be thrown.\n\n<code-tabs>\n  <code-pane header=\"src/app/shared/canvas.component.spec.ts (failing)\" path=\"testing/src/app/shared/canvas.component.spec.ts\" region=\"without-toBlob-macrotask\">\nimport { fakeAsync, TestBed, tick, waitForAsync } from &#39;@angular/core/testing&#39;;\n\nimport { CanvasComponent } from &#39;./canvas.component&#39;;\n\ndescribe(&#39;CanvasComponent&#39;, () =&gt; {\n  beforeEach(waitForAsync(() =&gt; {\n    TestBed\n        .configureTestingModule({\n          declarations: [CanvasComponent],\n        })\n        .compileComponents();\n  }));\n\n  it(&#39;should be able to generate blob data from canvas&#39;, fakeAsync(() =&gt; {\n       const fixture = TestBed.createComponent(CanvasComponent);\n       const canvasComp = fixture.componentInstance;\n\n       fixture.detectChanges();\n       expect(canvasComp.blobSize).toBe(0);\n\n       tick();\n       expect(canvasComp.blobSize).toBeGreaterThan(0);\n     }));\n});\n\n</code-pane>\n  <code-pane header=\"src/app/shared/canvas.component.ts\" path=\"testing/src/app/shared/canvas.component.ts\" region=\"main\">\nimport { Component, AfterViewInit, ViewChild, ElementRef } from &#39;@angular/core&#39;;\n\n@Component({\n  selector: &#39;sample-canvas&#39;,\n  template: &#39;&lt;canvas #sampleCanvas width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt;&#39;,\n})\nexport class CanvasComponent implements AfterViewInit {\n  blobSize = 0;\n  @ViewChild(&#39;sampleCanvas&#39;) sampleCanvas: ElementRef;\n\n  ngAfterViewInit() {\n    const canvas: HTMLCanvasElement = this.sampleCanvas.nativeElement;\n    const context = canvas.getContext(&#39;2d&#39;);\n\n    context.clearRect(0, 0, 200, 200);\n    context.fillStyle = &#39;#FF1122&#39;;\n    context.fillRect(0, 0, 200, 200);\n\n    canvas.toBlob(blob =&gt; {\n      this.blobSize = blob.size;\n    });\n  }\n}\n\n</code-pane>\n</code-tabs>\n\nIf you want to support such a case, you need to define the macro task you want to support in `beforeEach()`.\nFor example:\n\n<code-example header=\"src/app/shared/canvas.component.spec.ts (excerpt)\" path=\"testing/src/app/shared/canvas.component.spec.ts\" region=\"enable-toBlob-macrotask\">\nbeforeEach(() =&gt; {\n  (window as any).__zone_symbol__FakeAsyncTestMacroTask = [\n    {\n      source: &#39;HTMLCanvasElement.toBlob&#39;,\n      callbackArgs: [{size: 200}],\n    },\n  ];\n});\n\n</code-example>\n\nNote that in order to make the `<canvas>` element Zone.js-aware in your app, you need to import the `zone-patch-canvas` patch (either in `polyfills.ts` or in the specific file that uses `<canvas>`):\n\n<code-example header=\"src/polyfills.ts or src/app/shared/canvas.component.ts\" path=\"testing/src/app/shared/canvas.component.ts\" region=\"import-canvas-patch\">\n// 비동기 `HTMLCanvasElement` 메서드(ex. `.toBlob()`)를 지원하기 위해 패치를 로드합니다.\n// 이 패치는 `polyfills.ts` 파일이나 `HTMLCanvasElement` 파일에 적용하면 됩니다.\nimport &#39;zone.js/dist/zone-patch-canvas&#39;;\n\n</code-example>\n-->\n<p><code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 안에서는 이런 매크로 태스크를 지원합니다.</p>\n<ul>\n<li><code>setTimeout</code></li>\n<li><code>setInterval</code></li>\n<li><code>requestAnimationFrame</code></li>\n<li><code>webkitRequestAnimationFrame</code></li>\n<li><code>mozRequestAnimationFrame</code></li>\n</ul>\n<p>하지만 <code>HTMLCanvasElement.toBlob()</code>를 실행하면 <em>\"Unknown macroTask scheduled in fake async test\"</em> 에러가 발생합니다.</p>\n<code-tabs>\n  <code-pane header=\"src/app/shared/canvas.component.spec.ts (테스트 실패)\" path=\"testing/src/app/shared/canvas.component.spec.ts\" region=\"without-toBlob-macrotask\">\nimport { <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>, <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>, <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>, <a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a> } from '@angular/core/testing';\n\nimport { CanvasComponent } from './canvas.component';\n\ndescribe('CanvasComponent', () => {\n  beforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() => {\n    <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n        .configureTestingModule({\n          declarations: [CanvasComponent],\n        })\n        .compileComponents();\n  }));\n\n  it('should be able to generate blob data from canvas', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() => {\n       const fixture = TestBed.createComponent(CanvasComponent);\n       const canvasComp = fixture.componentInstance;\n\n       fixture.detectChanges();\n       expect(canvasComp.blobSize).toBe(0);\n\n       <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>();\n       expect(canvasComp.blobSize).toBeGreaterThan(0);\n     }));\n});\n\n</code-pane>\n  <code-pane header=\"src/app/shared/canvas.component.ts\" path=\"testing/src/app/shared/canvas.component.ts\" region=\"main\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a>, <a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'sample-canvas',\n  template: '&#x3C;canvas #sampleCanvas width=\"200\" height=\"200\">&#x3C;/canvas>',\n})\nexport class CanvasComponent implements <a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a> {\n  blobSize = 0;\n  @<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>('sampleCanvas') sampleCanvas: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>;\n\n  ngAfterViewInit() {\n    const canvas: HTMLCanvasElement = this.sampleCanvas.nativeElement;\n    const context = canvas.getContext('2d');\n\n    context.clearRect(0, 0, 200, 200);\n    context.fillStyle = '#FF1122';\n    context.fillRect(0, 0, 200, 200);\n\n    canvas.toBlob(blob => {\n      this.blobSize = blob.size;\n    });\n  }\n}\n\n</code-pane>\n</code-tabs>\n<p>이런 코드를 사용하려면 <code>beforeEach()</code> 함수에 매크로 태스크를 직접 정의해야 합니다:</p>\n<code-example header=\"src/app/shared/canvas.component.spec.ts (일부)\" path=\"testing/src/app/shared/canvas.component.spec.ts\" region=\"enable-toBlob-macrotask\">\nbeforeEach(() => {\n  (window as any).__zone_symbol__FakeAsyncTestMacroTask = [\n    {\n      source: 'HTMLCanvasElement.toBlob',\n      callbackArgs: [{size: 200}],\n    },\n  ];\n});\n\n</code-example>\n<p><code>&#x3C;canvas></code> 엘리먼트와 같이 Zone.js와 관련된 엘리먼트를 테스트하려면 <code>zone-patch-canvas</code> 패치를 추가해야 할 수도 있습니다.\n이 패치는 적용하려는 곳이 여러 곳이면 <code>polyfills.ts</code> 파일에, 파일 하나에만 적용하려면 <code>&#x3C;canvas></code>가 사용된 파일에 적용하면 됩니다:</p>\n<code-example header=\"src/polyfills.ts or src/app/shared/canvas.component.ts\" path=\"testing/src/app/shared/canvas.component.ts\" region=\"import-canvas-patch\">\n// 비동기 `HTMLCanvasElement` 메서드(ex. `.toBlob()`)를 지원하기 위해 패치를 로드합니다.\n// 이 패치는 `polyfills.ts` 파일이나 `HTMLCanvasElement` 파일에 적용하면 됩니다.\nimport 'zone.js/dist/zone-patch-canvas';\n\n</code-example>\n<!--\n#### Async observables\n-->\n<h4 id=\"비동기-옵저버블\">비동기 옵저버블<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#비동기-옵저버블\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nYou might be satisfied with the test coverage of these tests.\n\nHowever, you might be troubled by the fact that the real service doesn't quite behave this way.\nThe real service sends requests to a remote server.\nA server takes time to respond and the response certainly won't be available immediately\nas in the previous two tests.\n\nYour tests will reflect the real world more faithfully if you return an _asynchronous_ observable\nfrom the `getQuote()` spy like this.\n\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"async-setup\">\n// `asyncData()` 헬퍼 함수를 사용해서 옵저버블을 비동기로 처리합니다.\ngetQuoteSpy.and.returnValue(asyncData(testQuote));\n\n</code-example>\n-->\n<p>테스트 코드에 대한 테스트 커버리지 정보가 함께 제공되면 더 나을 수 있습니다.</p>\n<p>하지만 실제 서비스 객체를 사용하면서 이런 기능을 구현하기는 쉽지 않습니다.\n실세 서비스 객체는 리모트 서버로 HTTP 요청을 보낼 수도 있기 때문입니다.\n서버로 HTTP 요청을 보내면 응답을 받기까지 시간이 필요하기 때문에 이전에 살펴봤던 두 테스트 코드처럼 즉시 완료할 수 없습니다.</p>\n<p>그렇다면 비동기로 동작하는 옵저버블을 흉내내기 위해 <code>getQuote()</code> 스파이를 만들어서 사용하면 됩니다.</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"async-setup\">\n// `asyncData()` 헬퍼 함수를 사용해서 옵저버블을 비동기로 처리합니다.\ngetQuoteSpy.and.returnValue(asyncData(testQuote));\n\n</code-example>\n<!--\n#### Async observable helpers\n-->\n<h4 id=\"비동기-옵저버블-헬퍼\">비동기 옵저버블 헬퍼<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#비동기-옵저버블-헬퍼\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe async observable was produced by an `asyncData` helper.\nThe `asyncData` helper is a utility function that you'll have to write yourself, or you can copy this one from the sample code.\n\n<code-example path=\"testing/src/testing/async-observable-helpers.ts\" region=\"async-data\" header=\"testing/async-observable-helpers.ts\">\n/**\n * JS 실행 싸이클이 한 번 실행된 뒤에\n * Observable을 보내고 바로 종료합니다.\n */\nexport function asyncData&lt;T&gt;(data: T) {\n  return defer(() =&gt; Promise.resolve(data));\n}\n\n</code-example>\n\nThis helper's observable emits the `data` value in the next turn of the JavaScript engine.\n\nThe [RxJS `defer()` operator](http://reactivex.io/documentation/operators/defer.html) returns an observable.\nIt takes a factory function that returns either a promise or an observable.\nWhen something subscribes to _defer_'s observable,\nit adds the subscriber to a new observable created with that factory.\n\nThe `defer()` operator transforms the `Promise.resolve()` into a new observable that,\nlike `HttpClient`, emits once and completes.\nSubscribers are unsubscribed after they receive the data value.\n\nThere's a similar helper for producing an async error.\n\n<code-example path=\"testing/src/testing/async-observable-helpers.ts\" region=\"async-error\">\n/**\n * JS 실행 싸이클이 한 번 실행된 뒤에\n * 에러 Observable을 보내고 바로 종료합니다.\n */\nexport function asyncError&lt;T&gt;(errorObject: any) {\n  return defer(() =&gt; Promise.reject(errorObject));\n}\n\n</code-example>\n-->\n<p><code>asyncData</code> 헬퍼 함수는 비동기 옵저버블을 만들어서 반환합니다.\n그렇다면 이 헬퍼 함수는 개발자가 원하는 대로 만들어서 사용해도 되고 아래 코드를 기반으로 활용해도 됩니다.</p>\n<code-example path=\"testing/src/testing/async-observable-helpers.ts\" region=\"async-data\" header=\"testing/async-observable-helpers.ts\">\n/**\n * JS 실행 싸이클이 한 번 실행된 뒤에\n * Observable을 보내고 바로 종료합니다.\n */\nexport function asyncData&#x3C;T>(data: T) {\n  return defer(() => Promise.resolve(data));\n}\n\n</code-example>\n<p>이 헬퍼 함수는 JavaScript 엔진의 다음 실행 싸이클에 <code>data</code> 값을 옵저버블로 보냅니다.</p>\n<p><a href=\"http://reactivex.io/documentation/operators/defer.html\">RxJS <code>defer()</code> 연산자</a>는 팩토리 함수를 인자로 받아서 프라미스나 옵저버블을 반환합니다.\n그리고 누군가 이 옵저버블을 반환하면 새로운 옵저버블이 생성됩니다.</p>\n<p><code>defer()</code> 연산자는 <code>Promise.resolve()</code>를 옵저버블로 변환하며 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>와 비슷하게 데이터를 하나 전달하고 종료됩니다.\n데이터를 받은 구독자들도 모두 구독이 해지됩니다.</p>\n<p>비동기 에러를 발생시키는 헬퍼는 이렇게 구현합니다.</p>\n<code-example path=\"testing/src/testing/async-observable-helpers.ts\" region=\"async-error\">\n/**\n * JS 실행 싸이클이 한 번 실행된 뒤에\n * 에러 Observable을 보내고 바로 종료합니다.\n */\nexport function asyncError&#x3C;T>(errorObject: any) {\n  return defer(() => Promise.reject(errorObject));\n}\n\n</code-example>\n<!--\n#### More async tests\n-->\n<h4 id=\"비동기-더-활용하기\">비동기 더 활용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#비동기-더-활용하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nNow that the `getQuote()` spy is returning async observables,\nmost of your tests will have to be async as well.\n\nHere's a `fakeAsync()` test that demonstrates the data flow you'd expect\nin the real world.\n\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"fake-async-test\">\nit(&#39;should show quote after getQuote (fakeAsync)&#39;, fakeAsync(() =&gt; {\n     fixture.detectChanges();  // ngOnInit()\n     expect(quoteEl.textContent).toBe(&#39;...&#39;, &#39;should show placeholder&#39;);\n\n     tick();                   // 옵저버블을 실행합니다.\n     fixture.detectChanges();  // 화면을 갱신합니다.\n\n     expect(quoteEl.textContent).toBe(testQuote, &#39;should show quote&#39;);\n     expect(errorMessage()).toBeNull(&#39;should not show error&#39;);\n   }));\n\n</code-example>\n\nNotice that the quote element displays the placeholder value (`'...'`) after `ngOnInit()`.\nThe first quote hasn't arrived yet.\n\nTo flush the first quote from the observable, you call [tick()](api/core/testing/tick).\nThen call `detectChanges()` to tell Angular to update the screen.\n\nThen you can assert that the quote element displays the expected text.\n-->\n<p>이제 <code>getQuote()</code> 스파이는 비동기 옵저버블을 반환하기 때문에, 테스트 코드도 비동기로 실행되어야 합니다.</p>\n<p>그래서 실제 운영 환경에서 동작하는 흐름과 동일하게 실행하기 위해 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>를 사용해야 합니다.</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"fake-async-test\">\nit('should show quote after getQuote (<a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>)', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() => {\n     fixture.detectChanges();  // ngOnInit()\n     expect(quoteEl.textContent).toBe('...', 'should show placeholder');\n\n     <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>();                   // 옵저버블을 실행합니다.\n     fixture.detectChanges();  // 화면을 갱신합니다.\n\n     expect(quoteEl.textContent).toBe(testQuote, 'should show quote');\n     expect(errorMessage()).toBeNull('should not show error');\n   }));\n\n</code-example>\n<p><code>ngOnInit()</code>이 실행된 후에는 명언이 표시되는 엘리먼트가 <code>'...'</code>로 표시됩니다.\n아직 첫 번째 응답은 받지 못했습니다.</p>\n<p>이제 옵저버블로 전달되는 첫번째 명언을 표시하려면 <a href=\"api/core/testing/tick\">tick()</a>을 실행하면 됩니다.\n그리고 <code>detectChanges()</code>를 실행하면 Angular가 화면을 갱신합니다.</p>\n<p>이제 화면에 표시되는 엘리먼트가 원하는 문구가 맞는지 확인하면 됩니다.</p>\n<a id=\"waitForAsync\"></a>\n<!--\n#### Async test with _waitForAsync()_\n-->\n<h4 id=\"waitforasync-로-비동기-테스트하기\"><code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 로 비동기 테스트하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#waitforasync-로-비동기-테스트하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nTo use `waitForAsync()` functionality, you must import `zone.js/dist/zone-testing` in your test setup file.\nIf you created your project with the Angular CLI, `zone-testing` is already imported in `src/test.ts`.\n\n<div class=\"alert is-helpful\">\n\nThe `TestBed.compileComponents()` method (see [below](#compile-components)) calls `XHR`\nto read external template and css files during \"just-in-time\" compilation.\nWrite tests that call `compileComponents()` with the `waitForAsync()` utility.\n\n</div>\n\nHere's the previous `fakeAsync()` test, re-written with the `waitForAsync()` utility.\n\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"async-test\">\nit(&#39;should show quote after getQuote (async)&#39;, waitForAsync(() =&gt; {\n     fixture.detectChanges();  // ngOnInit()\n     expect(quoteEl.textContent).toBe(&#39;...&#39;, &#39;should show placeholder&#39;);\n\n     fixture.whenStable().then(() =&gt; {  // 비동기 getQuote를 기다립니다.\n       fixture.detectChanges();         // 화면을 갱신합니다.\n       expect(quoteEl.textContent).toBe(testQuote);\n       expect(errorMessage()).toBeNull(&#39;should not show error&#39;);\n     });\n   }));\n\n</code-example>\n\nThe `waitForAsync()` utility hides some asynchronous boilerplate by arranging for the tester's code\nto run in a special _async test zone_.\nYou don't need to pass Jasmine's `done()` into the test and call `done()` because it is `undefined` in promise or observable callbacks.\n\nBut the test's asynchronous nature is revealed by the call to `fixture.whenStable()`,\nwhich breaks the linear flow of control.\n\nWhen using an `intervalTimer()` such as `setInterval()` in `waitForAsync()`, remember to cancel the timer with `clearInterval()` after the test, otherwise the `waitForAsync()` never ends.\n-->\n<p><code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 함수를 사용하려면 테스트 환경설정 파일에 <code>zone.js/dist/zone-testing</code>을 로드해야 합니다.\nAngular CLI로 프로젝트를 생성했다면 <code>src/test.ts</code> 파일에서 이미 <code>zone-testing</code>을 로드하고 있습니다.</p>\n<div class=\"alert is-helpful\">\n<p><code>TestBed.compileComponents()</code> 메서드(<a href=\"guide/testing-components-scenarios#compile-components\">아래</a> 참고)는 JIT 컴파일 중에 외부 템플릿 파일과 CSS 파일을 읽어오기 위해 <code>XHR</code> 요청을 보냅니다.\n그래서 <code>compileComponents()</code>를 실행하기 위해 <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 유틸리티를 사용해야 합니다.</p>\n</div>\n<p>이전에 작성했던 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 테스트 코드를 <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code>를 활용하는 방식으로 재작성해보면 이렇습니다.</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"async-test\">\nit('should show quote after getQuote (async)', <a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() => {\n     fixture.detectChanges();  // ngOnInit()\n     expect(quoteEl.textContent).toBe('...', 'should show placeholder');\n\n     fixture.whenStable().then(() => {  // 비동기 getQuote를 기다립니다.\n       fixture.detectChanges();         // 화면을 갱신합니다.\n       expect(quoteEl.textContent).toBe(testQuote);\n       expect(errorMessage()).toBeNull('should not show error');\n     });\n   }));\n\n</code-example>\n<p><code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 유틸리티는 비동기 로직들을 자동으로 재구성해서 <em>비동기 테스트 존</em> 안에서 실행합니다.\n그래서 Jasmine이 제공하는 <code>done()</code> 함수를 테스트 함수에 전달할 필요가 없으며 명시적으로 <code>done()</code>을 실행할 필요도 없습니다.</p>\n<p>비동기로 실행되는 코드는 <code>fixture.whenStable()</code>을 활용하면 동기 방식으로 구성할 수 있습니다.</p>\n<p><code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 안에서 <code>setInterval()</code>과 같은 타이머를 사용하면 테스트가 종료된 후에 <code>clearInterval()</code>로 타이머를 종료해야 합니다.\n이 타이머를 종료하지 않으면 <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code>는 종료되지 않습니다.</p>\n<a id=\"when-stable\"></a>\n<h4 id=\"whenstable\"><em>whenStable</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#whenstable\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe test must wait for the `getQuote()` observable to emit the next quote.\nInstead of calling [tick()](api/core/testing/tick), it calls `fixture.whenStable()`.\n\nThe `fixture.whenStable()` returns a promise that resolves when the JavaScript engine's\ntask queue becomes empty.\nIn this example, the task queue becomes empty when the observable emits the first quote.\n\nThe test resumes within the promise callback, which calls `detectChanges()` to\nupdate the quote element with the expected text.\n-->\n<p><code>getQuote()</code> 테스트 코드는 옵저버블로 데이터가 전달될 때까지 계속 기다립니다.\n이 때 <a href=\"api/core/testing/tick\">tick()</a>를 실행해도 되지만 <code>fixture.whenStable()</code>를 활용해도 됩니다.</p>\n<p><code>fixture.whenStable()</code>은 JavaScript 엔진의 태스크 큐가 비는 시점에 프라미스가 완료된 상태를 반환합니다.\n이 예제에서 태스크 큐는 옵저버블로 첫번째 데이터가 전달된 후에 비게 됩니다.</p>\n<p>그러면 프라미스 콜백으로 지정된 테스트 코드가 계속 실행되면서 <code>detectChanges()</code>가 실행되고 화면에 보이는 엘리먼트의 문구를 갱신합니다.</p>\n<a id=\"jasmine-done\"></a>\n<h4 id=\"jasmine-done\">Jasmine <em>done()</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#jasmine-done\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nWhile the `waitForAsync()` and `fakeAsync()` functions greatly\nsimplify Angular asynchronous testing,\nyou can still fall back to the traditional technique\nand pass `it` a function that takes a\n[`done` callback](https://jasmine.github.io/2.0/introduction.html#section-Asynchronous_Support).\n\nYou can't call `done()` in `waitForAsync()` or `fakeAsync()` functions, because the `done parameter`\nis `undefined`.\n\nNow you are responsible for chaining promises, handling errors, and calling `done()` at the appropriate moments.\n\nWriting test functions with `done()`, is more cumbersome than `waitForAsync()`and `fakeAsync()`, but it is occasionally necessary when code involves the `intervalTimer()` like `setInterval`.\n\nHere are two more versions of the previous test, written with `done()`.\nThe first one subscribes to the `Observable` exposed to the template by the component's `quote` property.\n\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"quote-done-test\">\nit(&#39;should show last quote (quote done)&#39;, (done: DoneFn) =&gt; {\n  fixture.detectChanges();\n\n  component.quote.pipe(last()).subscribe(() =&gt; {\n    fixture.detectChanges();  // 화면을 갱신합니다.\n    expect(quoteEl.textContent).toBe(testQuote);\n    expect(errorMessage()).toBeNull(&#39;should not show error&#39;);\n    done();\n  });\n});\n\n</code-example>\n\nThe RxJS `last()` operator emits the observable's last value before completing, which will be the test quote.\nThe `subscribe` callback calls `detectChanges()` to\nupdate the quote element with the test quote, in the same manner as the earlier tests.\n\nIn some tests, you're more interested in how an injected service method was called and what values it returned,\nthan what appears on screen.\n\nA service spy, such as the `qetQuote()` spy of the fake `TwainService`,\ncan give you that information and make assertions about the state of the view.\n\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"spy-done-test\">\nit(&#39;should show quote after getQuote (spy done)&#39;, (done: DoneFn) =&gt; {\n  fixture.detectChanges();\n\n  // 컴포넌트가 받는 문자열은 스파이가 마지막으로 실행되었을 때 반환하는 값으로 참조할 수도 있습니다.\n  getQuoteSpy.calls.mostRecent().returnValue.subscribe(() =&gt; {\n    fixture.detectChanges();  // 화면을 갱신합니다.\n    expect(quoteEl.textContent).toBe(testQuote);\n    expect(errorMessage()).toBeNull(&#39;should not show error&#39;);\n    done();\n  });\n});\n\n</code-example>\n-->\n<p><code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code>와 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>가 Angular에서 진행되는 비동기 테스트 코드를 아주 단순하게 만들어주기는 하지만, <code>it</code> 함수에 <a href=\"https://jasmine.github.io/2.0/introduction.html#section-Asynchronous_Support\"><code>done</code> 콜백</a>을 전달하는 기존 방식도 활용할 수 있습니다.</p>\n<p>하지만 <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code>나 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 함수 안에서 <code>done()</code> 함수를 실행할 수는 없습니다.\n왜냐라면 <code>done()</code> 함수의 인자는 항상 <code>undefined</code>이기 때문입니다.</p>\n<p>Jasmine <code>done()</code> 함수를 직접 활용하는 경우에는 프라미스나 에러를 직접 처리해야 하며 <code>done()</code>도 적절한 시점에 실행해야 합니다.</p>\n<p>그래서 <code>done()</code>을 직접 활용하면 <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code>나 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>를 활용하는 것보다 신경쓸 내용이 많지만, <code>setInterval</code>같은 인터벌 함수를 사용하는 경우에는 이 방식을 꼭 사용해야 하는 경우도 있습니다.</p>\n<p>이전에 작성한 테스트 코드를 <code>done()</code>을 활용하는 방식으로 작성해보면 이렇습니다.\n첫번째로 살펴볼 코드는 컴포넌트의 <code>quote</code> 옵저버블 프로퍼티를 구독해서 테스트하는 코드입니다.</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"quote-done-test\">\nit('should show last quote (quote done)', (done: DoneFn) => {\n  fixture.detectChanges();\n\n  component.quote.pipe(last()).subscribe(() => {\n    fixture.detectChanges();  // 화면을 갱신합니다.\n    expect(quoteEl.textContent).toBe(testQuote);\n    expect(errorMessage()).toBeNull('should not show error');\n    done();\n  });\n});\n\n</code-example>\n<p>RxJS <code>last()</code> 연산자는 옵저버블이 종료되기 전까지 전달된 데이터 중 마지막 데이터를 스트림으로 보냅니다.\n그래서 <code>subscribe()</code> 콜백에서는 <code>detectChanges()</code>를 실행해서 엘리먼트의 문구를 마지막 데이터로 갱신하며, 나머지 코드는 위 코드와 비슷합니다.</p>\n<p>경우에 따라서는 의존성으로 주입된 서비스의 메서드를 어떻게 실행하고 어떤 값을 반환하며, 화면에 어떻게 반영되는지가 더 중요할 수 있습니다.</p>\n<p>가짜 <code>TwainService</code>에 <code>getQuote()</code> 스파이를 만드는 방식을 활용하면 원하는 시점에 화면이 어떤 상태가 되는지 원하는 대로 검증할 수 있습니다.</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"spy-done-test\">\nit('should show quote after getQuote (spy done)', (done: DoneFn) => {\n  fixture.detectChanges();\n\n  // 컴포넌트가 받는 문자열은 스파이가 마지막으로 실행되었을 때 반환하는 값으로 참조할 수도 있습니다.\n  getQuoteSpy.calls.mostRecent().returnValue.subscribe(() => {\n    fixture.detectChanges();  // 화면을 갱신합니다.\n    expect(quoteEl.textContent).toBe(testQuote);\n    expect(errorMessage()).toBeNull('should not show error');\n    done();\n  });\n});\n\n</code-example>\n<hr>\n<a id=\"marble-testing\"></a>\n<!--\n## Component marble tests\n-->\n<h2 id=\"컴포넌트-마블-테스트\">컴포넌트 마블 테스트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#컴포넌트-마블-테스트\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe previous `TwainComponent` tests simulated an asynchronous observable response\nfrom the `TwainService` with the `asyncData` and `asyncError` utilities.\n\nThese are short, simple functions that you can write yourself.\nUnfortunately, they're too simple for many common scenarios.\nAn observable often emits multiple times, perhaps after a significant delay.\nA component may coordinate multiple observables\nwith overlapping sequences of values and errors.\n\n**RxJS marble testing** is a great way to test observable scenarios,\nboth simple and complex.\nYou've likely seen the [marble diagrams](http://rxmarbles.com/)\nthat illustrate how observables work.\nMarble testing uses a similar marble language to\nspecify the observable streams and expectations in your tests.\n\nThe following examples revisit two of the `TwainComponent` tests\nwith marble testing.\n\nStart by installing the `jasmine-marbles` npm package.\nThen import the symbols you need.\n\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"import-marbles\" header=\"app/twain/twain.component.marbles.spec.ts (import marbles)\">\nimport { cold, getTestScheduler } from &#39;jasmine-marbles&#39;;\n\n</code-example>\n\nHere's the complete test for getting a quote:\n\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"get-quote-test\">\nit(&#39;should show quote after getQuote (marbles)&#39;, () =&gt; {\n  // 옵저버블은 약간 지연된 후 테스트 문장을 전달하고 종료됩니다.\n  const q$ = cold(&#39;---x|&#39;, { x: testQuote });\n  getQuoteSpy.and.returnValue( q$ );\n\n  fixture.detectChanges(); // ngOnInit()\n  expect(quoteEl.textContent).toBe(&#39;...&#39;, &#39;should show placeholder&#39;);\n\n  getTestScheduler().flush(); // 옵저버블을 실행합니다.\n\n  fixture.detectChanges(); // 화면을 갱신합니다.\n\n  expect(quoteEl.textContent).toBe(testQuote, &#39;should show quote&#39;);\n  expect(errorMessage()).toBeNull(&#39;should not show error&#39;);\n});\n\n</code-example>\n\nNotice that the Jasmine test is synchronous. There's no `fakeAsync()`.\nMarble testing uses a test scheduler to simulate the passage of time\nin a synchronous test.\n\nThe beauty of marble testing is in the visual definition of the observable streams.\nThis test defines a [_cold_ observable](#cold-observable) that waits\nthree [frames](#marble-frame) (`---`),\nemits a value (`x`), and completes (`|`).\nIn the second argument you map the value marker (`x`) to the emitted value (`testQuote`).\n\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"test-quote-marbles\">\nconst q$ = cold(&#39;---x|&#39;, { x: testQuote });\n\n</code-example>\n\nThe marble library constructs the corresponding observable, which the\ntest sets as the `getQuote` spy's return value.\n\nWhen you're ready to activate the marble observables,\nyou tell the `TestScheduler` to _flush_ its queue of prepared tasks like this.\n\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"test-scheduler-flush\">\ngetTestScheduler().flush(); // 옵저버블을 실행합니다.\n\n</code-example>\n\nThis step serves a purpose analogous to [tick()](api/core/testing/tick) and `whenStable()` in the\nearlier `fakeAsync()` and `waitForAsync()` examples.\nThe balance of the test is the same as those examples.\n-->\n<p>이전 섹션에서 살펴본 <code>TwainComponent</code> 테스트 코드는 <code>TwainService</code>에서 전달되는 비동기 옵저버블을 처리하기 위해 <code>asyncData</code>와 <code>asyncError</code> 유틸 함수를 사용했습니다.</p>\n<p>이정도 함수는 짧고 간단하기 때문에 직접 만들어서 쓰기에 문제될 정도는 아닙니다.\n하지만 보통은 이보다 복잡한 시나리오로 동작합니다.\n옵저버블로 데이터가 여러번 전달될 수 있으며 데이터가 전달되는 사이에 시간 간격이 있는 경우도 있습니다.\n그리고 옵저버블 여러 개를 활용하면서 전달되는 데이터와 에러를 다양하게 활용할 수도 있습니다.</p>\n<p><strong>RxJS 마블(marble) 테스트</strong>를 활용하면 간단한 시나리오는 물론이고 복잡한 시나리오로 동작하는 옵저버블도 테스트할 수 있습니다.\n옵저버블이 동작하는 모습을 표현하는 <a href=\"http://rxmarbles.com/\">마블 다이어그램</a>을 본 적이 있을 것입니다.\n마블 테스트는 이와 비슷한 문법을 사용해서 옵저버블이 정해진 대로 동작하는지 검사하는 방식입니다.</p>\n<p>이번 섹션에서는 <code>TwainComponent</code>에 마블 테스트를 적용해 봅시다.</p>\n<p>먼저, <code>jasmine-marbles</code> npm 패키지를 설치하고 마블 테스트에 필요한 심볼을 로드합니다.</p>\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"import-marbles\" header=\"app/twain/twain.component.marbles.spec.ts (심볼 로드하기)\">\nimport { cold, getTestScheduler } from 'jasmine-marbles';\n\n</code-example>\n<p>테스트 코드를 마블 테스트 방식으로 작성하면 이렇습니다:</p>\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"get-quote-test\">\nit('should show quote after getQuote (marbles)', () => {\n  // 옵저버블은 약간 지연된 후 테스트 문장을 전달하고 종료됩니다.\n  const q$ = cold('---x|', { x: testQuote });\n  getQuoteSpy.and.returnValue( q$ );\n\n  fixture.detectChanges(); // ngOnInit()\n  expect(quoteEl.textContent).toBe('...', 'should show placeholder');\n\n  getTestScheduler().flush(); // 옵저버블을 실행합니다.\n\n  fixture.detectChanges(); // 화면을 갱신합니다.\n\n  expect(quoteEl.textContent).toBe(testQuote, 'should show quote');\n  expect(errorMessage()).toBeNull('should not show error');\n});\n\n</code-example>\n<p>Jasmine 테스트 코드는 동기 방식으로 동작한다는 것을 잊지 마세요.\n그래서 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>가 사용되지 않았습니다.\n마블 테스트는 시간이 지난 것을 동기 테스트 코드 안에서 시뮬레이션하기 위해 별도 테스트 스케쥴러를 사용합니다.</p>\n<p>마블 테스트가 좋은 점은 옵저버블 스트림으로 전달되는 데이터를 시각적으로 표현할 수 있다는 것입니다.\n아래 코드는 3 <a href=\"guide/testing-components-scenarios#marble-frame\">프레임</a> (<code>---</code>) 동안 기다렸다가 데이터(<code>x</code>)를 전달하고 종료되는(<code>|</code>) <a href=\"guide/testing-components-scenarios#cold-observable\"><em>콜드(cold)</em> 옵저버블</a>을 정의하는 코드입니다.\n두 번째 인자는 데이터가 전달되는 시점(<code>x</code>)에 실제로 전달될 데이터(<code>testQuote</code>)입니다.</p>\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"test-quote-marbles\">\nconst q$ = cold('---x|', { x: testQuote });\n\n</code-example>\n<p>그리고 마블 라이브러리는 옵저버블 관련 기능을 제공하기 때문에 <code>getQuote</code>에 스파이를 연결할 수 있습니다.</p>\n<p>마블 옵저버블을 시작할 준비가 되었다면 <code>TestScheduler.flush()</code>를 실행해서 큐에 있는 내용을 비우면 됩니다.</p>\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"test-scheduler-flush\">\ngetTestScheduler().flush(); // 옵저버블을 실행합니다.\n\n</code-example>\n<p>지금 단계에서는 이전에 사용했던 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>, <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code>와 비슷한 용도로 <a href=\"api/core/testing/tick\">tick()</a>과 <code>whenStable()</code>를 사용했습니다.\n다른 부분은 이전에 살펴봤던 코드와 같습니다.</p>\n<!--\n#### Marble error testing\n-->\n<h4 id=\"마블-테스트--에러-처리\">마블 테스트 : 에러 처리<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#마블-테스트--에러-처리\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nHere's the marble testing version of the `getQuote()` error test.\n\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"error-test\">\nit(&#39;should display error when TwainService fails&#39;, fakeAsync(() =&gt; {\n  // 옵저버블은 약간 지연된 후 에러를 전달하고 종료됩니다.\n  const q$ = cold(&#39;---#|&#39;, null, new Error(&#39;TwainService test failure&#39;));\n  getQuoteSpy.and.returnValue( q$ );\n\n  fixture.detectChanges(); // ngOnInit()\n  expect(quoteEl.textContent).toBe(&#39;...&#39;, &#39;should show placeholder&#39;);\n\n  getTestScheduler().flush(); // 옵저버블을 실행합니다.\n  tick();                     // 컴포넌트가 사용하는 setTimeout()을 처리합니다.\n  fixture.detectChanges();    // 화면을 갱신합니다.\n\n  expect(errorMessage()).toMatch(/test failure/, &#39;should display error&#39;);\n  expect(quoteEl.textContent).toBe(&#39;...&#39;, &#39;should show placeholder&#39;);\n}));\n\n</code-example>\n\nIt's still an async test, calling `fakeAsync()` and [tick()](api/core/testing/tick), because the component itself\ncalls `setTimeout()` when processing errors.\n\nLook at the marble observable definition.\n\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"error-marbles\">\nconst q$ = cold(&#39;---#|&#39;, null, new Error(&#39;TwainService test failure&#39;));\n\n</code-example>\n\nThis is a _cold_ observable that waits three frames and then emits an error,\nThe hash (`#`) indicates the timing of the error that is specified in the third argument.\nThe second argument is null because the observable never emits a value.\n-->\n<p><code>getQuote()</code> 에러 테스트 코드를 마블 테스트 방식으로 작성해보면 이렇습니다.</p>\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"error-test\">\nit('should display error when TwainService fails', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() => {\n  // 옵저버블은 약간 지연된 후 에러를 전달하고 종료됩니다.\n  const q$ = cold('---#|', null, new Error('TwainService test failure'));\n  getQuoteSpy.and.returnValue( q$ );\n\n  fixture.detectChanges(); // ngOnInit()\n  expect(quoteEl.textContent).toBe('...', 'should show placeholder');\n\n  getTestScheduler().flush(); // 옵저버블을 실행합니다.\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>();                     // 컴포넌트가 사용하는 setTimeout()을 처리합니다.\n  fixture.detectChanges();    // 화면을 갱신합니다.\n\n  expect(errorMessage()).toMatch(/test failure/, 'should display error');\n  expect(quoteEl.textContent).toBe('...', 'should show placeholder');\n}));\n\n</code-example>\n<p>이 테스트 코드도 <code>setTimeout()</code> 안에서 비동기로 에러가 발생하기 때문에 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>와 <a href=\"api/core/testing/tick\">tick()</a>을 사용했습니다.</p>\n<p>마블 스타일로 에러 옵저버블을 정의해보면 이렇습니다.</p>\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"error-marbles\">\nconst q$ = cold('---#|', null, new Error('TwainService test failure'));\n\n</code-example>\n<p>이 옵저버블은 3 프레임을 기다린 후에 에러를 발생시키는 <em>콜드</em> 옵저버블입니다.\n그리고 세 번째 인자는 에러가 발생하는 시점(<code>#</code>)에 실제로 전달될 에러 객체입니다.\n두 번째 인자는 옵저버블로 전달될 데이터를 지정하지만, 이 예제에서는 데이터를 전달하지 않기 때문에 null을 지정했습니다.</p>\n<!--\n#### Learn about marble testing\n-->\n<h4 id=\"마블-테스트-활용하기\">마블 테스트 활용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#마블-테스트-활용하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\n<a id=\"marble-frame\"></a>\nA _marble frame_ is a virtual unit of testing time.\nEach symbol (`-`, `x`, `|`, `#`) marks the passing of one frame.\n\n<a id=\"cold-observable\"></a>\nA _cold_ observable doesn't produce values until you subscribe to it.\nMost of your application observables are cold.\nAll [_HttpClient_](guide/http) methods return cold observables.\n\nA _hot_ observable is already producing values _before_ you subscribe to it.\nThe [_Router.events_](api/router/Router#events) observable,\nwhich reports router activity, is a _hot_ observable.\n\nRxJS marble testing is a rich subject, beyond the scope of this guide.\nLearn about it on the web, starting with the\n[official documentation](https://rxjs.dev/guide/testing/marble-testing).\n-->\n<a id=\"marble-frame\"></a>\n<p><em>마블 프레임(marble frame)</em> 은 테스트 환경에서 동작하는 가상 시간 단위입니다.\n그리고 마블 프레임에서 사용하는 개별 심볼(<code>-</code>, <code>x</code>, <code>|</code>, <code>#</code>)은 프레임 하나를 차지합니다.</p>\n<a id=\"cold-observable\"></a>\n<p><em>콜드(cold)</em> 옵저버블은 누군가가 옵저버블을 구독하기 전까지는 데이터를 전달하지 않습니다.\n그리고 애플리케이션에서 사용하는 옵저버블 대부분은 콜드 옵저버블입니다.\n<a href=\"guide/http\"><em>HttpClient</em></a> 메서드들도 모두 콜드 옵저버블을 반환합니다.</p>\n<p><em>핫(hot)</em> 옵저버블은 누군가 옵저버블을 구독하지 않아도 데이터를 보냅니다.\n라우터의 상태를 옵저버블로 전달하는 <a href=\"api/router/Router#events\"><em>Router.events</em></a> 프로퍼티가 <em>핫</em> 옵저버블입니다.</p>\n<p>RxJS 마블 테스트는 이 문서에서 다루는 내용 말고도 수많은 옵저버블 생성자를 지원합니다.\n자세한 내용은 <a href=\"https://rxjs.dev/guide/testing/marble-testing\">공식 문서</a>를 참고하세요.</p>\n<hr>\n<a id=\"component-with-input-output\"></a>\n<!--\n## Component with inputs and outputs\n-->\n<h2 id=\"입출력-프로퍼티가-있는-컴포넌트\">입출력 프로퍼티가 있는 컴포넌트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#입출력-프로퍼티가-있는-컴포넌트\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nA component with inputs and outputs typically appears inside the view template of a host component.\nThe host uses a property binding to set the input property and an event binding to\nlisten to events raised by the output property.\n\nThe testing goal is to verify that such bindings work as expected.\nThe tests should set input values and listen for output events.\n\nThe `DashboardHeroComponent` is a tiny example of a component in this role.\nIt displays an individual hero provided by the `DashboardComponent`.\nClicking that hero tells the `DashboardComponent` that the user has selected the hero.\n\nThe `DashboardHeroComponent` is embedded in the `DashboardComponent` template like this:\n\n<code-example path=\"testing/src/app/dashboard/dashboard.component.html\" region=\"dashboard-hero\" header=\"app/dashboard/dashboard.component.html (excerpt)\">\n&lt;dashboard-hero *ngFor=&quot;let hero of heroes&quot;  class=&quot;col-1-4&quot;\n  [hero]=hero  (selected)=&quot;gotoDetail($event)&quot; &gt;\n&lt;/dashboard-hero&gt;\n\n</code-example>\n\nThe `DashboardHeroComponent` appears in an `*ngFor` repeater, which sets each component's `hero` input property\nto the looping value and listens for the component's `selected` event.\n\nHere's the component's full definition:\n\n<a id=\"dashboard-hero-component\"></a>\n\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.ts\" region=\"component\" header=\"app/dashboard/dashboard-hero.component.ts (component)\">\n@Component({\n  selector: &#39;dashboard-hero&#39;,\n  template: `\n    &lt;div (click)=&quot;click()&quot; class=&quot;hero&quot;&gt;\n      {{hero.name | uppercase}}\n    &lt;/div&gt;`,\n  styleUrls: [ &#39;./dashboard-hero.component.css&#39; ]\n})\nexport class DashboardHeroComponent {\n  @Input() hero: Hero;\n  @Output() selected = new EventEmitter&lt;Hero&gt;();\n  click() { this.selected.emit(this.hero); }\n}\n\n</code-example>\n\nWhile testing a component this simple has little intrinsic value, it's worth knowing how.\nYou can use one of these approaches:\n\n- Test it as used by `DashboardComponent`.\n- Test it as a stand-alone component.\n- Test it as used by a substitute for `DashboardComponent`.\n\nA quick look at the `DashboardComponent` constructor discourages the first approach:\n\n<code-example path=\"testing/src/app/dashboard/dashboard.component.ts\" region=\"ctor\" header=\"app/dashboard/dashboard.component.ts (constructor)\">\nconstructor(\n  private router: Router,\n  private heroService: HeroService) {\n}\n\n</code-example>\n\nThe `DashboardComponent` depends on the Angular router and the `HeroService`.\nYou'd probably have to replace them both with test doubles, which is a lot of work.\nThe router seems particularly challenging.\n\n<div class=\"alert is-helpful\">\n\nThe [discussion below](#routing-component) covers testing components that require the router.\n\n</div>\n\nThe immediate goal is to test the `DashboardHeroComponent`, not the `DashboardComponent`,\nso, try the second and third options.\n-->\n<p>컴포넌트에는 입력 프로퍼티와 출력 프로퍼티가 존재하는 경우가 많습니다.\n이 컴포넌트는 호스트 엘리먼트에서 바인딩한 데이터로 프로퍼티 값을 설정하며 출력 프로퍼티로 호스트 컴포넌트에 이벤트를 보냅니다.</p>\n<p>컴포넌트를 테스트할 때는 이런 입출력 프로퍼티가 정해진 대로 바인딩되었는지 검사하는 것도 중요합니다.\n입력값이 제대로 프로퍼티에 할당되었는지, 출력 이벤트는 제대로 감지되는지 확인하는 테스트 코드를 작성하면 됩니다.</p>\n<p>이런 내용을 <code>DashboardHeroComponent</code>로 확인해 봅시다.\n이 컴포넌트는 <code>DashboardComponent</code>에서 받은 개별 히어로 데이터를 화면에 표시합니다.\n그리고 히어로 이름을 클릭하면 사용자가 선택한 히어로를 <code>DashboardComponent</code>로 보냅니다.</p>\n<p><code>DashboardHeroComponent</code>는 <code>DashboardComponent</code> 템플릿에 이렇게 사용되었습니다:</p>\n<code-example path=\"testing/src/app/dashboard/dashboard.component.html\" region=\"dashboard-hero\" header=\"app/dashboard/dashboard.component.html (일부)\">\n&#x3C;dashboard-hero *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"  class=\"col-1-4\"\n  [hero]=hero  (selected)=\"gotoDetail($event)\" >\n&#x3C;/dashboard-hero>\n\n</code-example>\n<p><code>DashboardHeroComponent</code>는 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>로 반복되면서 개별 컴포넌트마다 <code>hero</code>를 입력 프로퍼티로 전달합니다.\n그리고 <code>selected</code> 이벤트를 감지하는 방식으로 구현되었습니다.</p>\n<p>컴포넌트 전체 코드는 이렇게 구현되었습니다:</p>\n<a id=\"dashboard-hero-component\"></a>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.ts\" region=\"component\" header=\"app/dashboard/dashboard-hero.component.ts (컴포넌트)\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'dashboard-hero',\n  template: `\n    &#x3C;div (click)=\"click()\" class=\"hero\">\n      {{hero.name | <a href=\"api/common/UpperCasePipe\" class=\"code-anchor\">uppercase</a>}}\n    &#x3C;/div>`,\n  styleUrls: [ './dashboard-hero.component.css' ]\n})\nexport class DashboardHeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() selected = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;Hero>();\n  click() { this.selected.emit(this.hero); }\n}\n\n</code-example>\n<p>이 컴포넌트는 아주 간단하지만 테스트로 다루기에는 충분합니다.\n이런 방식을 사용할 수 있습니다:</p>\n<ul>\n<li><code>DashboardComponent</code> 위에서 테스트합니다.</li>\n<li>이 컴포넌트만 단독으로 테스트합니다.</li>\n<li><code>DashboardComponent</code>를 대체한 상태로 테스트합니다.</li>\n</ul>\n<p>첫 번째 방식으로 진행하기 위해 <code>DashboardComponent</code>의 생성자를 확인해보면 이렇습니다:</p>\n<code-example path=\"testing/src/app/dashboard/dashboard.component.ts\" region=\"ctor\" header=\"app/dashboard/dashboard.component.ts (컴포넌트 생성자)\">\nconstructor(\n  private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,\n  private heroService: HeroService) {\n}\n\n</code-example>\n<p><code>DashboardComponent</code>는 Angular 라우터와 <code>HeroService</code>를 의존성으로 주입받습니다.\n그래서 이 객체들은 목 객체로 대체해야 할 수 있습니다.\n실제 객체를 활용하면 테스트 코드가 복잡해집니다.</p>\n<div class=\"alert is-helpful\">\n<p>컴포넌트를 테스트할 때 라우터를 대체하는 방법은 <a href=\"guide/testing-components-scenarios#routing-component\">아래에서 설명</a>합니다.</p>\n</div>\n<p>지금 작성하는 테스트 코드의 목적은 <code>DashboardHeroComponent</code>를 테스트하는 것이지 <code>DashboardComponent</code>를 테스트하는 것이 아닙니다.\n그러니 첫 번째 방법은 생략하고 두 번째 방법과 세 번째 방법으로 테스트 코드를 작성해 봅시다.</p>\n<a id=\"dashboard-standalone\"></a>\n<!--\n#### Test _DashboardHeroComponent_ stand-alone\n-->\n<h4 id=\"dashboardherocomponent-단독으로-테스트하기\"><em>DashboardHeroComponent</em> 단독으로 테스트하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#dashboardherocomponent-단독으로-테스트하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nHere's the meat of the spec file setup.\n\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"setup\" header=\"app/dashboard/dashboard-hero.component.spec.ts (setup)\">\nTestBed\n    .configureTestingModule({declarations: [DashboardHeroComponent]})\nfixture = TestBed.createComponent(DashboardHeroComponent);\ncomp = fixture.componentInstance;\n\n// 컴포넌트의 DebugElement와 HTMLElement를 참조합니다.\nheroDe = fixture.debugElement.query(By.css(&#39;.hero&#39;));\nheroEl = heroDe.nativeElement;\n\n// 컴포넌트에 사용할 히어로 정보를 선언합니다.\nexpectedHero = {id: 42, name: &#39;Test Name&#39;};\n\n// 부모 컴포넌트에서 입력 프로퍼티로 받는 과정을 처리합니다.\ncomp.hero = expectedHero;\n\n// 초기 데이터 바인딩을 실행합니다.\nfixture.detectChanges();\n\n</code-example>\n\nNote how the setup code assigns a test hero (`expectedHero`) to the component's `hero` property,\nemulating the way the `DashboardComponent` would set it\nvia the property binding in its repeater.\n\nThe following test verifies that the hero name is propagated to the template via a binding.\n\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"name-test\">\nit(&#39;should display hero name in uppercase&#39;, () =&gt; {\n  const expectedPipedName = expectedHero.name.toUpperCase();\n  expect(heroEl.textContent).toContain(expectedPipedName);\n});\n\n</code-example>\n\nBecause the [template](#dashboard-hero-component) passes the hero name through the Angular `UpperCasePipe`,\nthe test must match the element value with the upper-cased name.\n\n<div class=\"alert is-helpful\">\n\nThis small test demonstrates how Angular tests can verify a component's visual\nrepresentation&mdash;something not possible with\n[component class tests](guide/testing-components-basics#component-class-testing)&mdash;at\nlow cost and without resorting to much slower and more complicated end-to-end tests.\n\n</div>\n-->\n<p>테스트 코드의 환경설정 부분은 이렇습니다.</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"setup\" header=\"app/dashboard/dashboard-hero.component.spec.ts (환경설정)\">\n<a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n    .configureTestingModule({declarations: [DashboardHeroComponent]})\nfixture = TestBed.createComponent(DashboardHeroComponent);\ncomp = fixture.componentInstance;\n\n// 컴포넌트의 <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>와 HTMLElement를 참조합니다.\nheroDe = fixture.debugElement.query(By.css('.hero'));\nheroEl = heroDe.nativeElement;\n\n// 컴포넌트에 사용할 히어로 정보를 선언합니다.\nexpectedHero = {id: 42, name: 'Test Name'};\n\n// 부모 컴포넌트에서 입력 프로퍼티로 받는 과정을 처리합니다.\ncomp.hero = expectedHero;\n\n// 초기 데이터 바인딩을 실행합니다.\nfixture.detectChanges();\n\n</code-example>\n<p>이 환경설정 코드에서 히어로 데이터 <code>expectedHero</code>를 자식 컴포넌트 <code>hero</code> 프로퍼티로 어떻게 전달하는지 확인해 보세요.\n이 코드는 <code>DashboardComponent</code>가 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 안에서 프로퍼티 바인딩하는 것을 대신하는 코드입니다.</p>\n<p>아래 코드는 이렇게 전달된 히어로의 이름이 템플릿에 제대로 표시되는지 확인하는 테스트 코드입니다.</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"name-test\">\nit('should display hero name in uppercase', () => {\n  const expectedPipedName = expectedHero.name.toUpperCase();\n  expect(heroEl.textContent).toContain(expectedPipedName);\n});\n\n</code-example>\n<p><code>DashboardHeroComponent</code>의 <a href=\"guide/testing-components-scenarios#dashboard-hero-component\">템플릿</a>은 히어로 이름을 Angular가 제공하는 <code><a href=\"api/common/UpperCasePipe\" class=\"code-anchor\">UpperCasePipe</a></code>로 전달하기 때문에 테스트 코드에서 히어로 이름을 확인할 때도 대문자로 확인합니다.</p>\n<div class=\"alert is-helpful\">\n<p>이번 섹션에서는 <a href=\"guide/testing-components-basics#component-class-testing\">컴포넌트 클래스 테스트</a>로는 확인하기 어려운 컴포넌트의 시각 표현 부분을 테스트하는 것에 대해 다뤘습니다.\n엔드-투-엔드 테스트로 같은 내용을 검증하는 테스트 코드를 작성하는 것보다 훨씬 빠르고 간단합니다.</p>\n</div>\n<!--\n#### Clicking\n-->\n<h4 id=\"클릭-확인\">클릭 확인<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#클릭-확인\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nClicking the hero should raise a `selected` event that\nthe host component (`DashboardComponent` presumably) can hear:\n\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"click-test\">\nit(&#39;should raise selected event when clicked (triggerEventHandler)&#39;, () =&gt; {\n  let selectedHero: Hero;\n  comp.selected.subscribe((hero: Hero) =&gt; selectedHero = hero);\n\n  heroDe.triggerEventHandler(&#39;click&#39;, null);\n  expect(selectedHero).toBe(expectedHero);\n});\n\n</code-example>\n\nThe component's `selected` property returns an `EventEmitter`,\nwhich looks like an RxJS synchronous `Observable` to consumers.\nThe test subscribes to it _explicitly_ just as the host component does _implicitly_.\n\nIf the component behaves as expected, clicking the hero's element\nshould tell the component's `selected` property to emit the `hero` object.\n\nThe test detects that event through its subscription to `selected`.\n-->\n<p>히어로를 클릭하면 <code>selected</code> 이벤트가 발생해야 하며 이 이벤트는 호스트 컴포넌트인 <code>DashboardComponent</code>가 받는다는 것을 테스트 코드로 작성하면 이렇습니다:</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"click-test\">\nit('should raise selected event when clicked (triggerEventHandler)', () => {\n  let selectedHero: Hero;\n  comp.selected.subscribe((hero: Hero) => selectedHero = hero);\n\n  heroDe.triggerEventHandler('click', null);\n  expect(selectedHero).toBe(expectedHero);\n});\n\n</code-example>\n<p>컴포넌트의 <code>selected</code> 프로퍼티는 RxJS 동기 <code>Observable</code>과 비슷한 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 객체를 반환합니다.\n이 때 호스트 컴포넌트는 이 옵저버블을 <em>암묵적으로</em> 구독하지만 테스트 코드에서는 <em>명시적으로</em> 구독해야 합니다.</p>\n<p>컴포넌트가 제대로 동작한다면 히어로 엘리먼트를 클릭했을 때 <code>selected</code> 프로퍼티로 <code>hero</code> 객체가 전달되어야 합니다.</p>\n<p>이벤트로 전달된 객체는 <code>selected</code> 프로퍼티를 구독한 이후에 확인할 수 있습니다.</p>\n<a id=\"trigger-event-handler\"></a>\n<h4 id=\"triggereventhandler\"><em>triggerEventHandler</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#triggereventhandler\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe `heroDe` in the previous test is a `DebugElement` that represents the hero `<div>`.\n\nIt has Angular properties and methods that abstract interaction with the native element.\nThis test calls the `DebugElement.triggerEventHandler` with the \"click\" event name.\nThe \"click\" event binding responds by calling `DashboardHeroComponent.click()`.\n\nThe Angular `DebugElement.triggerEventHandler` can raise _any data-bound event_ by its _event name_.\nThe second parameter is the event object passed to the handler.\n\nThe test triggered a \"click\" event with a `null` event object.\n\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"trigger-event-handler\">\nheroDe.triggerEventHandler(&#39;click&#39;, null);\n\n</code-example>\n\nThe test assumes (correctly in this case) that the runtime\nevent handler&mdash;the component's `click()` method&mdash;doesn't\ncare about the event object.\n\n<div class=\"alert is-helpful\">\n\nOther handlers are less forgiving. For example, the `RouterLink`\ndirective expects an object with a `button` property\nthat identifies which mouse button (if any) was pressed during the click.\nThe `RouterLink` directive throws an error if the event object is missing.\n\n</div>\n-->\n<p>위 테스트에서 사용했던 <code>heroDe</code>는 히어로 <code>&#x3C;div></code>를 의미하는 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 객체입니다.</p>\n<p>이 객체는 브라우저의 표준 엘리먼트와 상호작용할 수 있는 프로퍼티와 메서드를 제공합니다.\n그래서 이 테스트 코드에서는 <code>DebugElement.triggerEventHandler()</code> 함수로 클릭 이벤트를 직접 실행했습니다.\n그리고 클릭 이벤트는 <code>DashboardHeroComponent.click()</code>을 실행하도록 이벤트 바인딩되어 있습니다.</p>\n<p><code>DebugElement.triggerEventHandler()</code> 메서드는 이벤트 이름과 전달되는 이벤트 객체를 자유롭게 선택할 수 있습니다.\n핸들러에 전달되는 이벤트 객체는 두 번째 인자로 전달합니다.</p>\n<p>결국 이 테스트 코드는 <code>null</code> 객체로 \"click\" 이벤트를 발생시킵니다.</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"trigger-event-handler\">\nheroDe.triggerEventHandler('click', null);\n\n</code-example>\n<p>이 테스트 코드에서는 호스트 컴포넌트의 <code>click()</code> 메서드가 이벤트 객체는 신경쓰지 않는다고 간주합시다.</p>\n<div class=\"alert is-helpful\">\n<p>핸들러는 보통 이렇게 관대하지 않습니다.\n예를 들면 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 디렉티브는 클릭이 어떤 마우스 버튼에서 발생했는지 확인하기 위해 <code>button</code> 프로퍼티가 필요합니다.\n이벤트 객체가 누락되면 에러가 발생합니다.</p>\n</div>\n<!--\n#### Click the element\n-->\n<h4 id=\"엘리먼트-클릭하기\">엘리먼트 클릭하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#엘리먼트-클릭하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe following test alternative calls the native element's own `click()` method,\nwhich is perfectly fine for _this component_.\n\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"click-test-2\">\nit(&#39;should raise selected event when clicked (element.click)&#39;, () =&gt; {\n  let selectedHero: Hero;\n  comp.selected.subscribe((hero: Hero) =&gt; selectedHero = hero);\n\n  heroEl.click();\n  expect(selectedHero).toBe(expectedHero);\n});\n\n</code-example>\n-->\n<p>아래 코드는 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>를 활용하는 대신 표준 엘리먼트가 제공하는 <code>click()</code> 메서드를 활용하는 코드입니다.\n<em>이 컴포넌트</em> 는 이렇게 테스트해도 원하는 내용을 확인할 수 있습니다.</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"click-test-2\">\nit('should raise selected event when clicked (element.click)', () => {\n  let selectedHero: Hero;\n  comp.selected.subscribe((hero: Hero) => selectedHero = hero);\n\n  heroEl.click();\n  expect(selectedHero).toBe(expectedHero);\n});\n\n</code-example>\n<a id=\"click-helper\"></a>\n<!--\n#### _click()_ helper\n-->\n<h4 id=\"click-헬퍼\"><em>click()</em> 헬퍼<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#click-헬퍼\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nClicking a button, an anchor, or an arbitrary HTML element is a common test task.\n\nMake that consistent and easy by encapsulating the _click-triggering_ process\nin a helper such as the `click()` function below:\n\n<code-example path=\"testing/src/testing/index.ts\" region=\"click-event\" header=\"testing/index.ts (click helper)\">\n/** RouterLink 이벤트 핸들러를 위해 버튼 이벤트 객체의 일부를 다시 선언합니다. */\nexport const ButtonClickEvents = {\n   left:  { button: 0 },\n   right: { button: 2 }\n};\n\n/** 엘리먼트 클릭을 처리합니다. 이벤트 객체의 기본값은 마우스 왼쪽 버튼 클릭 이벤트입니다. */\nexport function click(el: DebugElement | HTMLElement, eventObj: any = ButtonClickEvents.left): void {\n  if (el instanceof HTMLElement) {\n    el.click();\n  } else {\n    el.triggerEventHandler(&#39;click&#39;, eventObj);\n  }\n}\n\n</code-example>\n\nThe first parameter is the _element-to-click_. If you wish, you can pass a\ncustom event object as the second parameter. The default is a (partial)\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\">left-button mouse event object</a>\naccepted by many handlers including the `RouterLink` directive.\n\n<div class=\"alert is-important\">\n\nThe `click()` helper function is **not** one of the Angular testing utilities.\nIt's a function defined in _this guide's sample code_.\nAll of the sample tests use it.\nIf you like it, add it to your own collection of helpers.\n\n</div>\n\nHere's the previous test, rewritten using the click helper.\n\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"click-test-3\" header=\"app/dashboard/dashboard-hero.component.spec.ts (test with click helper)\">\nit(&#39;should raise selected event when clicked (click helper)&#39;, () =&gt; {\n  let selectedHero: Hero;\n  comp.selected.subscribe((hero: Hero) =&gt; selectedHero = hero);\n\n  click(heroDe);  // DebugElement로 클릭 헬퍼를 실행합니다.\n  click(heroEl);  // 네이티브 엘리먼트로 클릭 헬퍼를 실행합니다.\n\n  expect(selectedHero).toBe(expectedHero);\n});\n\n</code-example>\n-->\n<p>버튼이나 앵커같은 HTML 엘리먼트를 클릭하는 동작은 테스트 코드에 자주 사용됩니다.</p>\n<p>그렇다면 클릭을 트리거링하는 과정을 일관되고 쉽게 사용하기 위해 이런 헬퍼 함수를 정의할 수 있습니다:</p>\n<code-example path=\"testing/src/testing/index.ts\" region=\"click-event\" header=\"testing/index.ts (클릭 헬퍼)\">\n/** <a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a> 이벤트 핸들러를 위해 버튼 이벤트 객체의 일부를 다시 선언합니다. */\nexport const ButtonClickEvents = {\n   left:  { button: 0 },\n   right: { button: 2 }\n};\n\n/** 엘리먼트 클릭을 처리합니다. 이벤트 객체의 기본값은 마우스 왼쪽 버튼 클릭 이벤트입니다. */\nexport function click(el: <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> | HTMLElement, eventObj: any = ButtonClickEvents.left): void {\n  if (el instanceof HTMLElement) {\n    el.click();\n  } else {\n    el.triggerEventHandler('click', eventObj);\n  }\n}\n\n</code-example>\n<p>첫 번째 인자는 클릭할 엘리먼트입니다.\n그리고 필요한 경우에는 두 번째 인자로 커스텀 이벤트 객체를 전달할 수 있습니다.\n기본값은 일반적으로 활용되는 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\">마우스 왼쪽 버튼 이벤트 객체</a>를 사용했니다.</p>\n<div class=\"alert is-important\">\n<p><code>click()</code> 헬퍼 함수는 Angular가 제공하는 테스트 관련 기능이 <strong>아닙니다</strong>.\n이 함수는 가이드 문서에서 예제를 설명하기 위해 정의한 코드이며 테스트 코드에서만 이 헬퍼 함수를 사용합니다.\n이런 함수가 더 있다면 헬퍼들을 모아서 따로 구성하는 것도 좋습니다.</p>\n</div>\n<p>이전에 작성한 테스트 코드를 클릭 헬퍼를 사용하는 방식으로 수정하면 이렇습니다:</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"click-test-3\" header=\"app/dashboard/dashboard-hero.component.spec.ts (클릭 헬퍼를 사용하는 테스트 코드)\">\nit('should raise selected event when clicked (click helper)', () => {\n  let selectedHero: Hero;\n  comp.selected.subscribe((hero: Hero) => selectedHero = hero);\n\n  click(heroDe);  // <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>로 클릭 헬퍼를 실행합니다.\n  click(heroEl);  // 네이티브 엘리먼트로 클릭 헬퍼를 실행합니다.\n\n  expect(selectedHero).toBe(expectedHero);\n});\n\n</code-example>\n<hr>\n<a id=\"component-inside-test-host\"></a>\n<!--\n## Component inside a test host\n-->\n<h2 id=\"테스트-호스트-안에서-테스트하기\">테스트 호스트 안에서 테스트하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#테스트-호스트-안에서-테스트하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe previous tests played the role of the host `DashboardComponent` themselves.\nBut does the `DashboardHeroComponent` work correctly when properly data-bound to a host component?\n\nYou could test with the actual `DashboardComponent`.\nBut doing so could require a lot of setup,\nespecially when its template features an `*ngFor` repeater,\nother components, layout HTML, additional bindings,\na constructor that injects multiple services,\nand it starts interacting with those services right away.\n\nImagine the effort to disable these distractions, just to prove a point\nthat can be made satisfactorily with a _test host_ like this one:\n\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"test-host\" header=\"app/dashboard/dashboard-hero.component.spec.ts (test host)\">\n@Component({\n  template: `\n    &lt;dashboard-hero\n      [hero]=&quot;hero&quot; (selected)=&quot;onSelected($event)&quot;&gt;\n    &lt;/dashboard-hero&gt;`\n})\nclass TestHostComponent {\n  hero: Hero = {id: 42, name: &#39;Test Name&#39;};\n  selectedHero: Hero;\n  onSelected(hero: Hero) {\n    this.selectedHero = hero;\n  }\n}\n\n</code-example>\n\nThis test host binds to `DashboardHeroComponent` as the `DashboardComponent` would\nbut without the noise of the `Router`, the `HeroService`, or the `*ngFor` repeater.\n\nThe test host sets the component's `hero` input property with its test hero.\nIt binds the component's `selected` event with its `onSelected` handler,\nwhich records the emitted hero in its `selectedHero` property.\n\nLater, the tests will be able to easily check `selectedHero` to verify that the\n`DashboardHeroComponent.selected` event emitted the expected hero.\n\nThe setup for the _test-host_ tests is similar to the setup for the stand-alone tests:\n\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"test-host-setup\" header=\"app/dashboard/dashboard-hero.component.spec.ts (test host setup)\">\nTestBed\n    .configureTestingModule({declarations: [DashboardHeroComponent, TestHostComponent]})\n// DashboardHeroComponent 대신 TestHostComponent를 생성합니다.\nfixture = TestBed.createComponent(TestHostComponent);\ntestHost = fixture.componentInstance;\nheroEl = fixture.nativeElement.querySelector(&#39;.hero&#39;);\nfixture.detectChanges();  // 초기 데이터 바인딩을 실행합니다.\n\n</code-example>\n\nThis testing module configuration shows three important differences:\n\n1. It _declares_ both the `DashboardHeroComponent` and the `TestHostComponent`.\n1. It _creates_ the `TestHostComponent` instead of the `DashboardHeroComponent`.\n1. The `TestHostComponent` sets the `DashboardHeroComponent.hero` with a binding.\n\nThe `createComponent` returns a `fixture` that holds an instance of `TestHostComponent` instead of an instance of `DashboardHeroComponent`.\n\nCreating the `TestHostComponent` has the side-effect of creating a `DashboardHeroComponent`\nbecause the latter appears within the template of the former.\nThe query for the hero element (`heroEl`) still finds it in the test DOM,\nalbeit at greater depth in the element tree than before.\n\nThe tests themselves are almost identical to the stand-alone version:\n\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"test-host-tests\" header=\"app/dashboard/dashboard-hero.component.spec.ts (test-host)\">\nit(&#39;should display hero name&#39;, () =&gt; {\n  const expectedPipedName = testHost.hero.name.toUpperCase();\n  expect(heroEl.textContent).toContain(expectedPipedName);\n});\n\nit(&#39;should raise selected event when clicked&#39;, () =&gt; {\n  click(heroEl);\n  // 선택된 히어로는 데이터 바인딩한 히어로와 같아야 합니다.\n  expect(testHost.selectedHero).toBe(testHost.hero);\n});\n\n</code-example>\n\nOnly the selected event test differs. It confirms that the selected `DashboardHeroComponent` hero\nreally does find its way up through the event binding to the host component.\n-->\n<p>이전에 살펴본 테스트 코드에서 호스트 엘리먼트의 역할은 <code>DashboardComponent</code>가 직접 합니다.\n그런데 호스트 컴포넌트가 바뀐 경우에도 데이터 바인딩만 제대로 된다면 <code>DashboardHeroComponent</code>가 동작할까요?</p>\n<p><code>DashboardHeroComponent</code>를 테스트할 때 실제 호스트 컴포넌트인 <code>DashboardComponent</code>를 사용해도 테스트를 진행할 수 있습니다.\n하지만 실제 호스트 컴포넌트를 사용하기 위해 설정해야 할 내용이 훨씬 많아질 수 있습니다.\n<code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>는 물론이고 상호작용하는 컴포넌트나 서비스가 더 필요할 수 있고, 바인딩되는 프로퍼티가 더 있을 수 있으며 HTML 레이아웃도 동적으로 변경될 수 있습니다.</p>\n<p>이런 요구조건을 다 만족시키기 위해 노력하는 것보다는 검증하려는 컴포넌트만 집중하기 위해 <em>테스트 호스트</em> 를 따로 만드는 것이 좋습니다:</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"test-host\" header=\"app/dashboard/dashboard-hero.component.spec.ts (테스트 호스트)\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  template: `\n    &#x3C;dashboard-hero\n      [hero]=\"hero\" (selected)=\"onSelected($event)\">\n    &#x3C;/dashboard-hero>`\n})\nclass TestHostComponent {\n  hero: Hero = {id: 42, name: 'Test Name'};\n  selectedHero: Hero;\n  onSelected(hero: Hero) {\n    this.selectedHero = hero;\n  }\n}\n\n</code-example>\n<p>이 테스트 호스트는 <code>DashboardComponent</code>와 같은 방식으로 <code>DashboardHeroComponent</code>를 바인딩하면서도, <code>DashboardHeroComponent</code>에 사용하던 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>, <code>HeroService</code>, <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>를 신경쓰지 않을 수 있습니다.</p>\n<p>그리고 컴포넌트에 있는 테스트 히어로 데이터로 <code>DashboardHeroComponent</code>의 <code>hero</code> 프로퍼티를 바인딩하며, <code>onSelected</code> 핸들러로 <code>selected</code> 이벤트를 감지합니다.</p>\n<p><code>DashboardHeroComponent</code>에서 <code>selected</code> 이벤트가 발생하면 히어로 데이터가 <code>selectedHero</code> 프로퍼티에 할당되기 때문에 데이터가 제대로 전달되었는지 확인할 수 있습니다.</p>\n<p><em>테스트 호스트</em> 를 활용하는 테스트 코드는 컴포넌트만 단독으로 테스트했던 코드와 비슷합니다:</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"test-host-setup\" header=\"app/dashboard/dashboard-hero.component.spec.ts (테스트 호스트 환경설정)\">\n<a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n    .configureTestingModule({declarations: [DashboardHeroComponent, TestHostComponent]})\n// DashboardHeroComponent 대신 TestHostComponent를 생성합니다.\nfixture = TestBed.createComponent(TestHostComponent);\ntestHost = fixture.componentInstance;\nheroEl = fixture.nativeElement.querySelector('.hero');\nfixture.detectChanges();  // 초기 데이터 바인딩을 실행합니다.\n\n</code-example>\n<p>이 테스트 모듈 환경설정에서 이전과 다른 부분이 3가지 있습니다:</p>\n<ol>\n<li><code>DashboardHeroComponent</code>와 함께 <code>TestHostComponent</code>를 등록합니다.</li>\n<li><code>DashboardHeroComponent</code> 대신 <code>TestHostComponent</code>를 생성합니다.</li>\n<li><code>DashboardHeroComponent.hero</code> 프로퍼티는 <code>TestHostComponent</code>가 바인딩합니다.</li>\n</ol>\n<p><code>createComponent()</code>를 실행하면 이제 <code>DashboardHeroComponent</code> 인스턴스가 아니라 <code>TestHostComponent</code> 인스턴스가 포함된 <code>fixture</code>를 반환합니다.</p>\n<p><code>TestHostComponent</code>를 생성하면 이 컴포넌트 템플릿에 사용된 <code>DashboardHeroComponent</code>도 함께 생성됩니다.\n그래서 테스트 DOM에서 히어로 엘리먼트(<code>heroEl</code>)를 쿼리하면 엘리먼트 트리를 깊이 들어가지 않아도 원하는 컴포넌트를 찾을 수 있습니다.</p>\n<p>나머지 코드는 컴포넌트를 단독으로 테스트했던 코드와 거의 비슷합니다:</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"test-host-tests\" header=\"app/dashboard/dashboard-hero.component.spec.ts (호스트 테스트하기)\">\nit('should display hero name', () => {\n  const expectedPipedName = testHost.hero.name.toUpperCase();\n  expect(heroEl.textContent).toContain(expectedPipedName);\n});\n\nit('should raise selected event when clicked', () => {\n  click(heroEl);\n  // 선택된 히어로는 데이터 바인딩한 히어로와 같아야 합니다.\n  expect(testHost.selectedHero).toBe(testHost.hero);\n});\n\n</code-example>\n<p>히어로가 선택되었을 때를 테스트하는 로직은 조금 다릅니다.\n이 테스트 코드에서는 호스트 컴포넌트에 이벤트 바인딩으로 전달된 객체를 검사하는 방식을 사용했습니다.</p>\n<hr>\n<a id=\"routing-component\"></a>\n<!--\n## Routing component\n-->\n<h2 id=\"라우터를-활용하는-컴포넌트\">라우터를 활용하는 컴포넌트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#라우터를-활용하는-컴포넌트\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nA _routing component_ is a component that tells the `Router` to navigate to another component.\nThe `DashboardComponent` is a _routing component_ because the user can\nnavigate to the `HeroDetailComponent` by clicking on one of the _hero buttons_ on the dashboard.\n\nRouting is pretty complicated.\nTesting the `DashboardComponent` seemed daunting in part because it involves the `Router`,\nwhich it injects together with the `HeroService`.\n\n<code-example path=\"testing/src/app/dashboard/dashboard.component.ts\" region=\"ctor\" header=\"app/dashboard/dashboard.component.ts (constructor)\">\nconstructor(\n  private router: Router,\n  private heroService: HeroService) {\n}\n\n</code-example>\n\nMocking the `HeroService` with a spy is a [familiar story](#component-with-async-service).\nBut the `Router` has a complicated API and is entwined with other services and application preconditions. Might it be difficult to mock?\n\nFortunately, not in this case because the `DashboardComponent` isn't doing much with the `Router`\n\n<code-example path=\"testing/src/app/dashboard/dashboard.component.ts\" region=\"goto-detail\" header=\"app/dashboard/dashboard.component.ts (goToDetail)\">\ngotoDetail(hero: Hero) {\n  const url = `/heroes/${hero.id}`;\n  this.router.navigateByUrl(url);\n}\n\n</code-example>\n\nThis is often the case with _routing components_.\nAs a rule you test the component, not the router,\nand care only if the component navigates with the right address under the given conditions.\n\nProviding a router spy for _this component_ test suite happens to be as easy\nas providing a `HeroService` spy.\n\n<code-example path=\"testing/src/app/dashboard/dashboard.component.spec.ts\" region=\"router-spy\" header=\"app/dashboard/dashboard.component.spec.ts (spies)\">\nconst routerSpy = jasmine.createSpyObj(&#39;Router&#39;, [&#39;navigateByUrl&#39;]);\nconst heroServiceSpy = jasmine.createSpyObj(&#39;HeroService&#39;, [&#39;getHeroes&#39;]);\n\nTestBed\n    .configureTestingModule({\n      providers: [\n        {provide: HeroService, useValue: heroServiceSpy}, {provide: Router, useValue: routerSpy}\n      ]\n    })\n\n</code-example>\n\nThe following test clicks the displayed hero and confirms that\n`Router.navigateByUrl` is called with the expected url.\n\n<code-example path=\"testing/src/app/dashboard/dashboard.component.spec.ts\" region=\"navigate-test\" header=\"app/dashboard/dashboard.component.spec.ts (navigate test)\">\nit(&#39;should tell ROUTER to navigate when hero clicked&#39;, () =&gt; {\n  heroClick();  // &lt;div class=&quot;hero&quot;&gt; 엘리먼트 중 첫번째 엘리먼트를 클릭합니다.\n\n  // 컴포넌트가 이동하는 주소는 router.navigateByUrl() 스파이의 인자로 전달됩니다.\n  const spy = router.navigateByUrl as jasmine.Spy;\n  const navArgs = spy.calls.first().args[0];\n\n  // 이동하려는 주소가 컴포넌트의 히어로 목록 중 첫번째의 id와 같은지 검사합니다.\n  const id = comp.heroes[0].id;\n  expect(navArgs).toBe(&#39;/heroes/&#39; + id, &#39;should nav to HeroDetail for first hero&#39;);\n});\n\n</code-example>\n-->\n<p><code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>를 사용해서 다른 컴포넌트로 전환하는 컴포넌트가 있습니다.\n<code>DashboardComponent</code>도 대시보드에서 <em>히어로 버튼</em> 중 하나를 클릭하면 <code>HeroDetailComponent</code> 화면으로 이동하기 때문에 라우터를 활용하는 컴포넌트입니다.</p>\n<p>라우터 객체는 아주 복잡합니다.\n그리고 <code>DashboardComponent</code>는 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 뿐 아니라 <code>HeroService</code>도 함께 의존성 객체로 주입되고 있으니 테스트하기에는 너무 어려워 보입니다.</p>\n<code-example path=\"testing/src/app/dashboard/dashboard.component.ts\" region=\"ctor\" header=\"app/dashboard/dashboard.component.ts (생성자)\">\nconstructor(\n  private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,\n  private heroService: HeroService) {\n}\n\n</code-example>\n<p><code>HeroService</code>를 스파이 객체로 대체하는 방법은 <a href=\"guide/testing-components-scenarios#component-with-async-service\">이미 살펴본 내용</a>이라 익숙할 것입니다.\n하지만 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>는 API를 방대하게 제공하고 있으며 애플리케이션 상태에 따라 다른 서비스와 함께 복잡하게 얽혀있을 수 있습니다.\n이 객체를 목 객체로 만드는 것은 어렵지 않을까요?</p>\n<p>다행히, 아직 <code>DashboardComponent</code>는 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>를 활용하는 로직이 많지 않습니다.</p>\n<code-example path=\"testing/src/app/dashboard/dashboard.component.ts\" region=\"goto-detail\" header=\"app/dashboard/dashboard.component.ts (goToDetail())\">\ngotoDetail(hero: Hero) {\n  const url = `/heroes/${hero.id}`;\n  this.router.navigateByUrl(url);\n}\n\n</code-example>\n<p>이런 코드는 라우터를 활용하는 컴포넌트에 많이 사용됩니다.\n하지만 지금은 컴포넌트의 기능을 테스트하는 것이지 라우터를 테스트하는 것이 아니기 때문에, 주소를 이동한 후에 이 주소가 정해진 주소가 맞는지만 확인하면 됩니다.</p>\n<p>그래서 이 컴포넌트를 테스트할 때는 <code>HeroService</code> 목 객체를 만든 것과 비슷하게 라우터 목 객체를 만드는 것이 더 쉽습니다.</p>\n<code-example path=\"testing/src/app/dashboard/dashboard.component.spec.ts\" region=\"router-spy\" header=\"app/dashboard/dashboard.component.spec.ts (목 객체)\">\nconst routerSpy = jasmine.createSpyObj('<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>', ['navigateByUrl']);\nconst heroServiceSpy = jasmine.createSpyObj('HeroService', ['getHeroes']);\n\n<a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n    .configureTestingModule({\n      providers: [\n        {provide: HeroService, useValue: heroServiceSpy}, {provide: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>, useValue: routerSpy}\n      ]\n    })\n\n</code-example>\n<p>아래 코드는 화면에 있는 히어로 엘리먼트를 클릭했을 때 지정된 주소로 잘 이동했는지 확인하는 테스트 코드입니다.</p>\n<code-example path=\"testing/src/app/dashboard/dashboard.component.spec.ts\" region=\"navigate-test\" header=\"app/dashboard/dashboard.component.spec.ts (네비게이션 테스트)\">\nit('should tell ROUTER to navigate when hero clicked', () => {\n  heroClick();  // &#x3C;div class=\"hero\"> 엘리먼트 중 첫번째 엘리먼트를 클릭합니다.\n\n  // 컴포넌트가 이동하는 주소는 router.navigateByUrl() 스파이의 인자로 전달됩니다.\n  const spy = router.navigateByUrl as jasmine.Spy;\n  const navArgs = spy.calls.first().args[0];\n\n  // 이동하려는 주소가 컴포넌트의 히어로 목록 중 첫번째의 id와 같은지 검사합니다.\n  const id = comp.heroes[0].id;\n  expect(navArgs).toBe('/heroes/' + id, 'should nav to HeroDetail for first hero');\n});\n\n</code-example>\n<a id=\"routed-component-w-param\"></a>\n<!--\n## Routed components\n-->\n<h2 id=\"라우팅-대상이-되는-컴포넌트\">라우팅 대상이 되는 컴포넌트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#라우팅-대상이-되는-컴포넌트\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nA _routed component_ is the destination of a `Router` navigation.\nIt can be trickier to test, especially when the route to the component _includes parameters_.\nThe `HeroDetailComponent` is a _routed component_ that is the destination of such a route.\n\nWhen a user clicks a _Dashboard_ hero, the `DashboardComponent` tells the `Router`\nto navigate to `heroes/:id`.\nThe `:id` is a route parameter whose value is the `id` of the hero to edit.\n\nThe `Router` matches that URL to a route to the `HeroDetailComponent`.\nIt creates an `ActivatedRoute` object with the routing information and\ninjects it into a new instance of the `HeroDetailComponent`.\n\nHere's the `HeroDetailComponent` constructor:\n\n<code-example path=\"testing/src/app/hero/hero-detail.component.ts\" region=\"ctor\" header=\"app/hero/hero-detail.component.ts (constructor)\">\nconstructor(\n  private heroDetailService: HeroDetailService,\n  private route: ActivatedRoute,\n  private router: Router) {\n}\n\n</code-example>\n\nThe `HeroDetail` component needs the `id` parameter so it can fetch\nthe corresponding hero via the `HeroDetailService`.\nThe component has to get the `id` from the `ActivatedRoute.paramMap` property\nwhich is an `Observable`.\n\nIt can't just reference the `id` property of the `ActivatedRoute.paramMap`.\nThe component has to _subscribe_ to the `ActivatedRoute.paramMap` observable and be prepared\nfor the `id` to change during its lifetime.\n\n<code-example path=\"testing/src/app/hero/hero-detail.component.ts\" region=\"ng-on-init\" header=\"app/hero/hero-detail.component.ts (ngOnInit)\">\nngOnInit(): void {\n  // `id` 인자가 바뀔때마다 히어로 객체를 가져옵니다.\n  this.route.paramMap.subscribe(pmap =&gt; this.getHero(pmap.get(&#39;id&#39;)));\n}\n\n</code-example>\n\n<div class=\"alert is-helpful\">\n\nThe [ActivatedRoute in action](guide/router-tutorial-toh#activated-route-in-action) section of the [Router tutorial: tour of heroes](guide/router-tutorial-toh) guide covers `ActivatedRoute.paramMap` in more detail.\n\n</div>\n\nTests can explore how the `HeroDetailComponent` responds to different `id` parameter values\nby manipulating the `ActivatedRoute` injected into the component's constructor.\n\nYou know how to spy on the `Router` and a data service.\n\nYou'll take a different approach with `ActivatedRoute` because\n\n- `paramMap` returns an `Observable` that can emit more than one value\n  during a test.\n- You need the router helper function, `convertToParamMap()`, to create a `ParamMap`.\n- Other _routed component_ tests need a test double for `ActivatedRoute`.\n\nThese differences argue for a re-usable stub class.\n-->\n<p>라우팅 대상이 되는 컴포넌트는 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>가 화면을 전환할 때 목적지가 되는 컴포넌트를 의미합니다.\n이런 컴포넌트를 테스트하려면 약간의 트릭을 사용해야 하며, 특히 라우팅 규칙에 라우팅 인자가 들어있다면 더 그렇습니다.\n<code>HeroDetailComponent</code>는 라우팅 규칙의 대상이 되는 컴포넌트입니다.</p>\n<p>사용자가 <em>대시보드</em> 에서 히어로를 클릭하면 <code>DashboardComponent</code>는 <code>heroes/:id</code>라는 주소로 이동하도록 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>에게 요청합니다.\n이 주소에서 <code>:id</code> 부분이 정보를 수정할 히어로의 <code>id</code>에 해당하는 라우팅 인자입니다.</p>\n<p><code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>는 이 주소를 만나면 <code>HeroDetailComponent</code>로 전환합니다.\n그리고 이 때 라우팅 정보에 대한 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 객체가 <code>HeroDetailComponent</code> 인스턴스에 의존성으로 주입됩니다.</p>\n<p><code>HeroDetailComponent</code>의 생성자는 이렇습니다:</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.ts\" region=\"ctor\" header=\"app/hero/hero-detail.component.ts (constructor)\">\nconstructor(\n  private heroDetailService: HeroDetailService,\n  private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>,\n  private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {\n}\n\n</code-example>\n<p><code>HeroDetail</code> 컴포넌트는 <code>HeroDetailService</code>에서 원하는 히어로 데이터를 가져오기 위해 <code>id</code> 인자가 필요합니다.\n그래서 <code>Observable</code>로 제공되는 <code><a href=\"api/router/ActivatedRoute#paramMap\" class=\"code-anchor\">ActivatedRoute.paramMap</a></code> 프로퍼티를 참조하면 원하는 <code>id</code> 값을 참조할 수 있습니다.</p>\n<p><code><a href=\"api/router/ActivatedRoute#paramMap\" class=\"code-anchor\">ActivatedRoute.paramMap</a></code>에서 <code>id</code> 프로퍼티를 직접 참조할 수는 없습니다.\n이 프로퍼티는 옵저버블로 제공되기 때문에 반드시 <em>구독</em> 해야 하며, 이렇게 해야 라우팅 인자가 변경될때마다 전달되는 <code>id</code> 값에 대응할 수 있습니다.</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.ts\" region=\"ng-on-init\" header=\"app/hero/hero-detail.component.ts (ngOnInit())\">\nngOnInit(): void {\n  // `id` 인자가 바뀔때마다 히어로 객체를 가져옵니다.\n  this.route.paramMap.subscribe(pmap => this.getHero(pmap.get('id')));\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p><code><a href=\"api/router/ActivatedRoute#paramMap\" class=\"code-anchor\">ActivatedRoute.paramMap</a></code>에 대해 자세하게 알아보려면 <a href=\"guide/router-tutorial-toh\">라우터 튜토리얼: 히어로들의 여행</a> 문서의 <a href=\"guide/router-tutorial-toh#activated-route-in-action\">ActivatedRoute 활용하기</a> 섹션을 참고하세요.</p>\n</div>\n<p>이제 테스트 코드에서는 <code>HeroDetailComponent</code> 생성자로 주입되는 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 객체의 <code>id</code> 값을 바꿔보면서 이 컴포넌트가 어떻게 반응하는지 테스트하면 됩니다.</p>\n<p><code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>와 데이터 서비스의 목 객체를 만드는 방법에 대해서는 이미 다뤘습니다.</p>\n<p><code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>는 이들과는 조금 다릅니다.</p>\n<ul>\n<li><code>paramMap</code>은 <code>Observable</code>을 반환하며 테스트 코드가 실행되는 동안 데이터를 한 번 이상 보낼 수 있습니다.</li>\n<li><code><a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a></code>을 만들기 위해 <code><a href=\"api/router/convertToParamMap\" class=\"code-anchor\">convertToParamMap</a>()</code> 라우터 헬퍼 함수를 사용합니다.</li>\n<li>라우팅 대상 컴포넌트를 테스트하려면 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 목 객체가 필요합니다.</li>\n</ul>\n<p>이런 내용들은 나중에 재사용하기 위해 목 클래스로 만들어 둡시다.</p>\n<h4 id=\"activatedroutestub\"><em>ActivatedRouteStub</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#activatedroutestub\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe following `ActivatedRouteStub` class serves as a test double for `ActivatedRoute`.\n\n<code-example path=\"testing/src/testing/activated-route-stub.ts\" region=\"activated-route-stub\" header=\"testing/activated-route-stub.ts (ActivatedRouteStub)\">\nimport { convertToParamMap, ParamMap, Params } from &#39;@angular/router&#39;;\nimport { ReplaySubject } from &#39;rxjs&#39;;\n\n/**\n * `paramMap` 옵저버블을 제공하는 ActivatedRoute 클래스의 목 클래스를 정의합니다.\n * `paramMap`으로 데이터를 보낼 때는 `setParamMap()` 메소드를 활용합니다.\n */\nexport class ActivatedRouteStub {\n  // 구독자가 이전 값을 참조할 수 있도록 ReplaySubject를 사용합니다.\n  // `paramMap` 옵저버블로 제공되는 데이터도 이 객체로 전달됩니다.\n  private subject = new ReplaySubject&lt;ParamMap&gt;();\n\n  constructor(initialParams?: Params) {\n    this.setParamMap(initialParams);\n  }\n\n  /** 목 paramMap 옵저버블 */\n  readonly paramMap = this.subject.asObservable();\n\n  /** paramMap 옵저버블로 데이터를 전달합니다. */\n  setParamMap(params?: Params) {\n    this.subject.next(convertToParamMap(params));\n  }\n}\n\n</code-example>\n\nConsider placing such helpers in a `testing` folder sibling to the `app` folder.\nThis sample puts `ActivatedRouteStub` in `testing/activated-route-stub.ts`.\n\n<div class=\"alert is-helpful\">\n\nConsider writing a more capable version of this stub class with\nthe [_marble testing library_](#marble-testing).\n\n</div>\n-->\n<p>아래 <code>ActivatedRouteStub</code> 클래스는 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>를 대신하기 위해 정의한 목 클래스입니다.</p>\n<code-example path=\"testing/src/testing/activated-route-stub.ts\" region=\"activated-route-stub\" header=\"testing/activated-route-stub.ts (ActivatedRouteStub)\">\nimport { <a href=\"api/router/convertToParamMap\" class=\"code-anchor\">convertToParamMap</a>, <a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a>, <a href=\"api/router/Params\" class=\"code-anchor\">Params</a> } from '@angular/router';\nimport { ReplaySubject } from 'rxjs';\n\n/**\n * `paramMap` 옵저버블을 제공하는 <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> 클래스의 목 클래스를 정의합니다.\n * `paramMap`으로 데이터를 보낼 때는 `setParamMap()` 메소드를 활용합니다.\n */\nexport class ActivatedRouteStub {\n  // 구독자가 이전 값을 참조할 수 있도록 ReplaySubject를 사용합니다.\n  // `paramMap` 옵저버블로 제공되는 데이터도 이 객체로 전달됩니다.\n  private subject = new ReplaySubject&#x3C;<a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a>>();\n\n  constructor(initialParams?: <a href=\"api/router/Params\" class=\"code-anchor\">Params</a>) {\n    this.setParamMap(initialParams);\n  }\n\n  /** 목 paramMap 옵저버블 */\n  readonly paramMap = this.subject.asObservable();\n\n  /** paramMap 옵저버블로 데이터를 전달합니다. */\n  setParamMap(params?: <a href=\"api/router/Params\" class=\"code-anchor\">Params</a>) {\n    this.subject.next(<a href=\"api/router/convertToParamMap\" class=\"code-anchor\">convertToParamMap</a>(params));\n  }\n}\n\n</code-example>\n<p>이런 헬퍼들은 <code>app</code> 폴더 옆에 <code>testing</code> 폴더를 만들어서 모아 두는 것이 좋습니다.\n이 문서에서는 <code>testing/activated-route-stub.ts</code>라는 파일에 <code>ActivatedRouteStub</code>을 정의했습니다.</p>\n<div class=\"alert is-helpful\">\n<p><code>ActivatedRouteStub</code>를 더 다양하게 활용하도록 확장하려면 <a href=\"guide/testing-components-scenarios#marble-testing\">마블 테스트 라이브러리</a> 섹션을 참고하세요.</p>\n</div>\n<a id=\"tests-w-test-double\"></a>\n<!--\n#### Testing with _ActivatedRouteStub_\n-->\n<h4 id=\"activatedroutestub-로-테스트하기\"><em>ActivatedRouteStub</em> 로 테스트하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#activatedroutestub-로-테스트하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nHere's a test demonstrating the component's behavior when the observed `id` refers to an existing hero:\n\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"route-good-id\" header=\"app/hero/hero-detail.component.spec.ts (existing id)\">\ndescribe(&#39;when navigate to existing hero&#39;, () =&gt; {\n  let expectedHero: Hero;\n\n  beforeEach(waitForAsync(() =&gt; {\n    expectedHero = firstHero;\n    activatedRoute.setParamMap({id: expectedHero.id});\n    createComponent();\n  }));\n\n  it(&#39;should display that hero\\&#39;s name&#39;, () =&gt; {\n    expect(page.nameDisplay.textContent).toBe(expectedHero.name);\n  });\n});\n\n</code-example>\n\n<div class=\"alert is-helpful\">\n\nThe `createComponent()` method and `page` object are discussed [below](#page-object).\nRely on your intuition for now.\n\n</div>\n\nWhen the `id` cannot be found, the component should re-route to the `HeroListComponent`.\n\nThe test suite setup provided the same router spy [described above](#routing-component) which spies on the router without actually navigating.\n\nThis test expects the component to try to navigate to the `HeroListComponent`.\n\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"route-bad-id\" header=\"app/hero/hero-detail.component.spec.ts (bad id)\">\ndescribe(&#39;when navigate to non-existent hero id&#39;, () =&gt; {\n  beforeEach(waitForAsync(() =&gt; {\n    activatedRoute.setParamMap({id: 99999});\n    createComponent();\n  }));\n\n  it(&#39;should try to navigate back to hero list&#39;, () =&gt; {\n    expect(page.gotoListSpy.calls.any()).toBe(true, &#39;comp.gotoList called&#39;);\n    expect(page.navigateSpy.calls.any()).toBe(true, &#39;router.navigate called&#39;);\n  });\n});\n\n</code-example>\n\nWhile this app doesn't have a route to the `HeroDetailComponent` that omits the `id` parameter, it might add such a route someday.\nThe component should do something reasonable when there is no `id`.\n\nIn this implementation, the component should create and display a new hero.\nNew heroes have `id=0` and a blank `name`. This test confirms that the component behaves as expected:\n\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"route-no-id\" header=\"app/hero/hero-detail.component.spec.ts (no id)\">\ndescribe(&#39;when navigate with no hero id&#39;, () =&gt; {\n  beforeEach(waitForAsync(createComponent));\n\n  it(&#39;should have hero.id === 0&#39;, () =&gt; {\n    expect(component.hero.id).toBe(0);\n  });\n\n  it(&#39;should display empty hero name&#39;, () =&gt; {\n    expect(page.nameDisplay.textContent).toBe(&#39;&#39;);\n  });\n});\n\n</code-example>\n-->\n<p>아래 코드는 존재하는 히어로의 <code>id</code>를 받았을 때 컴포넌트의 동작을 테스트하는 코드입니다:</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"route-good-id\" header=\"app/hero/hero-detail.component.spec.ts (id가 존재하는 경우)\">\ndescribe('when navigate to existing hero', () => {\n  let expectedHero: Hero;\n\n  beforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() => {\n    expectedHero = firstHero;\n    activatedRoute.setParamMap({id: expectedHero.id});\n    createComponent();\n  }));\n\n  it('should display that hero\\'s name', () => {\n    expect(page.nameDisplay.textContent).toBe(expectedHero.name);\n  });\n});\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p><code>createComponent()</code> 메서드와 <code>page</code> 객체는 <a href=\"guide/testing-components-scenarios#page-object\">아래 섹션</a>에서 다룹니다.\n지금 꼭 알아야 하는 내용은 아닙니다.</p>\n</div>\n<p>전달된 <code>id</code>와 맞는 히어로를 찾을 수 없으면 다시 <code>HeroListComponent</code>로 이동해야 합니다.</p>\n<p>이 때 실제 화면이동은 스파이로 대체하기 위해 <a href=\"guide/testing-components-scenarios#routing-component\">위에서 설명한</a> 라우터 목 객체를 사용해서 테스트 코드의 환경설정을 했습니다.</p>\n<p>아래 코드는 다시 <code>HeroListComponent</code>로 이동하는지 검사하는 테스트 코드입니다.</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"route-bad-id\" header=\"app/hero/hero-detail.component.spec.ts (유효하지 않은 id)\">\ndescribe('when navigate to non-existent hero id', () => {\n  beforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() => {\n    activatedRoute.setParamMap({id: 99999});\n    createComponent();\n  }));\n\n  it('should try to navigate back to hero list', () => {\n    expect(page.gotoListSpy.calls.any()).toBe(true, 'comp.gotoList called');\n    expect(page.navigateSpy.calls.any()).toBe(true, 'router.navigate called');\n  });\n});\n\n</code-example>\n<p>아직까지 이 문서에서 다루는 예제에 <code>id</code>인자를 빠뜨린 채로 <code>HeroDetailComponent</code>로 이동하는 라우팅 규칙은 등록되지 않았지만, 이 라우팅 규칙은 조만간 추가하는 것이 좋습니다.\n유효하지 않은 <code>id</code> 뿐 아니라 <code>id</code> 자체가 존재하지 않는 경우에도 컴포넌트가 적절하게 대응해야 합니다.</p>\n<p>아니면 이런 경우에 컴포넌트가 새로운 히어로를 생성하게 할 수도 있습니다.\n새로운 히어로의 <code>id</code>는 <code>0</code>으로 지정하며 <code>name</code>은 빈 문자열로 시작한다면 테스트 코드를 이렇게 작성할 수 있습니다:</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"route-no-id\" header=\"app/hero/hero-detail.component.spec.ts (id가 없는 경우)\">\ndescribe('when navigate with no hero id', () => {\n  beforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(createComponent));\n\n  it('should have hero.id === 0', () => {\n    expect(component.hero.id).toBe(0);\n  });\n\n  it('should display empty hero name', () => {\n    expect(page.nameDisplay.textContent).toBe('');\n  });\n});\n\n</code-example>\n<hr>\n<a id=\"nested-component-tests\"></a>\n<!--\n## Nested component tests\n-->\n<h2 id=\"중첩된-컴포넌트-테스트하기\">중첩된 컴포넌트 테스트하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#중첩된-컴포넌트-테스트하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nComponent templates often have nested components, whose templates\nmay contain more components.\n\nThe component tree can be very deep and, most of the time, the nested components\nplay no role in testing the component at the top of the tree.\n\nThe `AppComponent`, for example, displays a navigation bar with anchors and their `RouterLink` directives.\n\n<code-example path=\"testing/src/app/app.component.html\" header=\"app/app.component.html\">\n&lt;app-banner&gt;&lt;/app-banner&gt;\n&lt;app-welcome&gt;&lt;/app-welcome&gt;\n&lt;nav&gt;\n  &lt;a routerLink=&quot;/dashboard&quot;&gt;Dashboard&lt;/a&gt;\n  &lt;a routerLink=&quot;/heroes&quot;&gt;Heroes&lt;/a&gt;\n  &lt;a routerLink=&quot;/about&quot;&gt;About&lt;/a&gt;\n&lt;/nav&gt;\n&lt;router-outlet&gt;&lt;/router-outlet&gt;\n\n\n</code-example>\n\nWhile the `AppComponent` _class_ is empty,\nyou may want to write unit tests to confirm that the links are wired properly\nto the `RouterLink` directives, perhaps for the reasons [explained below](#why-stubbed-routerlink-tests).\n\nTo validate the links, you don't need the `Router` to navigate and you don't\nneed the `<router-outlet>` to mark where the `Router` inserts _routed components_.\n\nThe `BannerComponent` and `WelcomeComponent`\n(indicated by `<app-banner>` and `<app-welcome>`) are also irrelevant.\n\nYet any test that creates the `AppComponent` in the DOM will also create instances of\nthese three components and, if you let that happen,\nyou'll have to configure the `TestBed` to create them.\n\nIf you neglect to declare them, the Angular compiler won't recognize the\n`<app-banner>`, `<app-welcome>`, and `<router-outlet>` tags in the `AppComponent` template\nand will throw an error.\n\nIf you declare the real components, you'll also have to declare _their_ nested components\nand provide for _all_ services injected in _any_ component in the tree.\n\nThat's too much effort just to answer a few simple questions about links.\n\nThis section describes two techniques for minimizing the setup.\nUse them, alone or in combination, to stay focused on testing the primary component.\n-->\n<p>컴포넌트 템플릿에는 컴포넌트가 여러개 존재하면서 중첩된 컴포넌트가 있을 수도 있습니다.</p>\n<p>컴포넌트 트리는 얼마든지 복잡하게 구성될 수 있지만, 사실 테스트하는 컴포넌트 외에는 별 역할을 하지 않는 경우가 많습니다.</p>\n<p><code>AppComponent</code>를 예로 들면, <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 디렉티브가 사용된 네비게이션 바와 앵커 엘리먼트가 있다고 합시다.</p>\n<code-example path=\"testing/src/app/app.component.html\" header=\"app/app.component.html\">\n&#x3C;app-banner>&#x3C;/app-banner>\n&#x3C;app-welcome>&#x3C;/app-welcome>\n&#x3C;nav>\n  &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/dashboard\">Dashboard&#x3C;/a>\n  &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/heroes\">Heroes&#x3C;/a>\n  &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/about\">About&#x3C;/a>\n&#x3C;/nav>\n&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n\n\n</code-example>\n<p>템플릿이 이렇게 구성되어 있으면 <code>AppComponent</code> <em>클래스</em> 코드에 아무것도 없다고 해도 이 링크들이 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 디렉티브와 제대로 연결되었는지 확인하는 유닛 테스트 코드를 작성할 수 있습니다.\n이 내용은 <a href=\"guide/testing-components-scenarios#why-stubbed-routerlink-tests\">아래</a>에서 자세하게 다룹니다.</p>\n<p>링크가 제대로 동작하는지 확인하려고 해도 실제로 화면을 전환하는 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>는 필요 없으며, 라우팅 대상이 되는 컴포넌트가 들어갈 <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code>도 필요하지 않습니다.</p>\n<p><code>BannerComponent</code>(<code>&#x3C;app-banner></code>)와 <code>WelcomeComponent</code>(<code>&#x3C;app-welcome></code>)도 지금 테스트하는 기능과는 관계가 없습니다.</p>\n<p>하지만 <code>AppComponent</code> 인스턴스를 그대로 생성하면 관련 컴포넌트들도 함께 생성되기 때문에 이 컴포넌트들에 대한 설정도 추가로 해줘야 합니다.</p>\n<p>만약 이 컴포넌트들을 등록하지 않은 채로 컴파일하면 Angular 컴파일러가 <code>AppComponent</code> 템플릿에 사용된 <code>&#x3C;app-banner></code>, <code>&#x3C;app-welcome></code>, <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code>를 확인할 수 없기 때문에 에러가 발생합니다.</p>\n<p>하지만 실제 컴포넌트를 등록하면 이 컴포넌트 내부에 있는 다른 컴포넌트도 또 등록해야 하며, 이와 관련된 서비스 객체도 모두 의존성으로 주입할 수 있도록 준비해야 합니다.</p>\n<p>링크가 제대로 동작하는지 확인하려고 하는데 이런 노력은 필요 없습니다.</p>\n<p>이번 섹션에서는 환경설정을 최소화하는 테크닉에 대해 알아봅시다.\n이제부터 설명하는 두가지 방법을 활용하면 테스트하려는 대상 컴포넌트에만 집중하는 데에 도움이 될 것입니다.</p>\n<a id=\"stub-component\"></a>\n<!--\n##### Stubbing unneeded components\n-->\n<h5 id=\"필요없는-컴포넌트-목으로-대체하기\">필요없는 컴포넌트 목으로 대체하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#필요없는-컴포넌트-목으로-대체하기\"><i class=\"material-icons\">link</i></a></h5>\n<!--\nIn the first technique, you create and declare stub versions of the components\nand directive that play little or no role in the tests.\n\n<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"component-stubs\" header=\"app/app.component.spec.ts (stub declaration)\">\n@Component({selector: &#39;app-banner&#39;, template: &#39;&#39;})\nclass BannerStubComponent {\n}\n\n@Component({selector: &#39;router-outlet&#39;, template: &#39;&#39;})\nclass RouterOutletStubComponent {\n}\n\n@Component({selector: &#39;app-welcome&#39;, template: &#39;&#39;})\nclass WelcomeStubComponent {\n}\n\n</code-example>\n\nThe stub selectors match the selectors for the corresponding real components.\nBut their templates and classes are empty.\n\nThen declare them in the `TestBed` configuration next to the\ncomponents, directives, and pipes that need to be real.\n\n<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"testbed-stubs\" header=\"app/app.component.spec.ts (TestBed stubs)\">\nTestBed\n    .configureTestingModule({\n      declarations: [\n        AppComponent, RouterLinkDirectiveStub, BannerStubComponent, RouterOutletStubComponent,\n        WelcomeStubComponent\n      ]\n    })\n\n</code-example>\n\nThe `AppComponent` is the test subject, so of course you declare the real version.\n\nThe `RouterLinkDirectiveStub`, [described later](#routerlink), is a test version\nof the real `RouterLink` that helps with the link tests.\n\nThe rest are stubs.\n-->\n<p>첫 번째 테크닉은 테스트와 관련이 없는 컴포넌트와 디렉티브를 목으로 만들어서 등록하는 것입니다.</p>\n<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"component-stubs\" header=\"app/app.component.spec.ts (목 객체 정의하기)\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({selector: 'app-banner', template: ''})\nclass BannerStubComponent {\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({selector: '<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>', template: ''})\nclass RouterOutletStubComponent {\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({selector: 'app-welcome', template: ''})\nclass WelcomeStubComponent {\n}\n\n</code-example>\n<p>목 컴포넌트의 셀렉터는 대체하려는 컴포넌트와 같은 셀렉터를 사용하면 됩니다.\n셀렉터는 같지만 템플릿과 클래스가 비어있는 컴포넌트를 등록하는 셈입니다.</p>\n<p>그리고 이렇게 정의한 목 컴포넌트를 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 환경설정에 등록합니다.</p>\n<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"testbed-stubs\" header=\"app/app.component.spec.ts (TestBed에 목 객체 등록하기)\">\n<a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n    .configureTestingModule({\n      declarations: [\n        AppComponent, RouterLinkDirectiveStub, BannerStubComponent, RouterOutletStubComponent,\n        WelcomeStubComponent\n      ]\n    })\n\n</code-example>\n<p>이 테스트 코드가 테스트하는 대상은 <code>AppComponent</code>이기 때문에 <code>AppComponent</code>는 실제 컴포넌트를 등록해야 합니다.</p>\n<p><a href=\"guide/testing-components-scenarios#routerlink\">이후</a>에 다루겠지만, <code>RouterLinkDirectiveStub</code>는 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>를 대신하는 목 객체입니다.</p>\n<a id=\"no-errors-schema\"></a>\n<h4 id=\"no_errors_schema\"><em>NO_ERRORS_SCHEMA</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#no_errors_schema\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nIn the second approach, add `NO_ERRORS_SCHEMA` to the `TestBed.schemas` metadata.\n\n<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"no-errors-schema\" header=\"app/app.component.spec.ts (NO_ERRORS_SCHEMA)\">\nTestBed\n    .configureTestingModule({\n      declarations: [\n        AppComponent,\n        RouterLinkDirectiveStub\n      ],\n      schemas: [NO_ERRORS_SCHEMA]\n    })\n\n</code-example>\n\nThe `NO_ERRORS_SCHEMA` tells the Angular compiler to ignore unrecognized elements and attributes.\n\nThe compiler will recognize the `<app-root>` element and the `routerLink` attribute\nbecause you declared a corresponding `AppComponent` and `RouterLinkDirectiveStub`\nin the `TestBed` configuration.\n\nBut the compiler won't throw an error when it encounters `<app-banner>`, `<app-welcome>`, or `<router-outlet>`.\nIt simply renders them as empty tags and the browser ignores them.\n\nYou no longer need the stub components.\n-->\n<p>두 번째 테크닉은 <code>TestBed.schemas</code> 메타데이터에 <code><a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a></code>를 지정하는 것입니다.</p>\n<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"no-errors-schema\" header=\"app/app.component.spec.ts (NO_ERRORS_SCHEMA)\">\n<a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n    .configureTestingModule({\n      declarations: [\n        AppComponent,\n        RouterLinkDirectiveStub\n      ],\n      schemas: [<a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a>]\n    })\n\n</code-example>\n<p><code><a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a></code>를 사용하면 Angular 컴파일러가 확인할 수 없는 엘리먼트와 어트리뷰트는 모두 무시합니다.</p>\n<p>이 경우에는 Angular 컴파일러가 <code>&#x3C;app-root></code> 엘리먼트와 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> 어트리뷰트만 인식할 수 있습니다.\n왜냐하면 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 환경설정에 <code>AppComponent</code>와 <code>RouterLinkDirectiveStub</code>만 등록되어 있기 때문입니다.</p>\n<p>Angualr 컴파일러는 <code>&#x3C;app-banner></code>, <code>&#x3C;app-welcome></code>, <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code>에 해당하는 객체를 찾을 수 없지만 에러가 발생하지는 않습니다.\n이 태그들은 비어있는 태그로 렌더링되며 브라우저도 이 태그들을 무시합니다.</p>\n<p>컴포넌트를 목 객체로 대체할 필요도 없습니다.</p>\n<!--\n#### Use both techniques together\n-->\n<h4 id=\"두가지-방법-동시에-사용하기\">두가지 방법 동시에 사용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#두가지-방법-동시에-사용하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThese are techniques for _Shallow Component Testing_ ,\nso-named because they reduce the visual surface of the component to just those elements\nin the component's template that matter for tests.\n\nThe `NO_ERRORS_SCHEMA` approach is the easier of the two but don't overuse it.\n\nThe `NO_ERRORS_SCHEMA` also prevents the compiler from telling you about the missing\ncomponents and attributes that you omitted inadvertently or misspelled.\nYou could waste hours chasing phantom bugs that the compiler would have caught in an instant.\n\nThe _stub component_ approach has another advantage.\nWhile the stubs in _this_ example were empty,\nyou could give them stripped-down templates and classes if your tests\nneed to interact with them in some way.\n\nIn practice you will combine the two techniques in the same setup,\nas seen in this example.\n\n<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"mixed-setup\" header=\"app/app.component.spec.ts (mixed setup)\">\nTestBed\n    .configureTestingModule({\n      declarations: [\n        AppComponent,\n        BannerStubComponent,\n        RouterLinkDirectiveStub\n      ],\n      schemas: [NO_ERRORS_SCHEMA]\n    })\n\n</code-example>\n\nThe Angular compiler creates the `BannerComponentStub` for the `<app-banner>` element\nand applies the `RouterLinkStubDirective` to the anchors with the `routerLink` attribute,\nbut it ignores the `<app-welcome>` and `<router-outlet>` tags.\n-->\n<p>두가지 테크닉은 <em>얕은 컴포넌트 테스트(shallow component testing)</em> 를 하기 위한 방법입니다.\n컴포넌트 템플릿에서 테스트와 관련없는 부분을 생략하기 때문에 이런 이름이 붙었습니다.</p>\n<p>그리고 두 가지 테크닉 중에는 <code><a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a></code>를 활용하는 방법이 더 쉽지만 이 방법을 너무 많이 사용하면 안됩니다.</p>\n<p><code><a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a></code>는 컴포넌트나 어트리뷰트 이름을 잘못 사용했을 때도 해당 객체를 무시합니다.\n이런 경우에는 에러도 표시되지 않기 때문에 문제를 해결하기 위해 많은 시간을 허비할 수도 있습니다.</p>\n<p>컴포넌트를 목 객체로 대신하는 방법의 장점이 또 있습니다.\n테스트하려는 컴포넌트가 이런 컴포넌트와 상호작용하는 로직이 있다면, 꼭 필요한 부분만 작성해서 이 동작을 실제로 확인할 수 있습니다.</p>\n<p>두 가지 테크닉을 동시에 활용하려면 환경설정 코드를 이렇게 구성하면 됩니다.</p>\n<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"mixed-setup\" header=\"app/app.component.spec.ts (환경설정)\">\n<a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n    .configureTestingModule({\n      declarations: [\n        AppComponent,\n        BannerStubComponent,\n        RouterLinkDirectiveStub\n      ],\n      schemas: [<a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a>]\n    })\n\n</code-example>\n<p>이렇게 작성하면 Angular 컴파일러는 <code>&#x3C;app-banner></code> 엘리먼트를 <code>BannerComponentStub</code>으로 대체하며, <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> 어트리뷰트를 <code>RouterLinkStubDirective</code>로 대체합니다.\n<code>&#x3C;app-welcome></code>과 <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code> 태그는 무시합니다.</p>\n<hr>\n<a id=\"routerlink\"></a>\n<!--\n## Components with _RouterLink_\n-->\n<h2 id=\"routerlink-를-사용하는-컴포넌트\"><em>RouterLink</em> 를 사용하는 컴포넌트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#routerlink-를-사용하는-컴포넌트\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe real `RouterLinkDirective` is quite complicated and entangled with other components\nand directives of the `RouterModule`.\nIt requires challenging setup to mock and use in tests.\n\nThe `RouterLinkDirectiveStub` in this sample code replaces the real directive\nwith an alternative version designed to validate the kind of anchor tag wiring\nseen in the `AppComponent` template.\n\n<code-example path=\"testing/src/testing/router-link-directive-stub.ts\" region=\"router-link\" header=\"testing/router-link-directive-stub.ts (RouterLinkDirectiveStub)\">\n@Directive({\n  selector: &#39;[routerLink]&#39;\n})\nexport class RouterLinkDirectiveStub {\n  @Input(&#39;routerLink&#39;) linkParams: any;\n  navigatedTo: any = null;\n\n  @HostListener(&#39;click&#39;)\n  onClick() {\n    this.navigatedTo = this.linkParams;\n  }\n}\n\n</code-example>\n\nThe URL bound to the `[routerLink]` attribute flows in to the directive's `linkParams` property.\n\nThe `HostListener` wires the click event of the host element\n(the `<a>` anchor elements in `AppComponent`) to the stub directive's `onClick` method.\n\nClicking the anchor should trigger the `onClick()` method,\nwhich sets the stub's telltale `navigatedTo` property.\nTests inspect `navigatedTo` to confirm that clicking the anchor\nsets the expected route definition.\n\n<div class=\"alert is-helpful\">\n\nWhether the router is configured properly to navigate with that route definition is a\nquestion for a separate set of tests.\n\n</div>\n-->\n<p>실제 <code>RouterLinkDirective</code>는 아주 복잡하며 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>에 있는 다른 컴포넌트, 디렉티브와 복잡하게 얽혀있습니다.\n그래서 이 객체를 테스트 코드에 사용하려면 환경설정 과정이 아주 복잡해 집니다.</p>\n<p>테스트 코드에서는 실제 디렉티브 대신 테스트에 꼭 필요한 내용만 구현해서 <code>RouterLinkDirectiveStub</code>로  대체하는 것이 좋습니다.</p>\n<code-example path=\"testing/src/testing/router-link-directive-stub.ts\" region=\"router-link\" header=\"testing/router-link-directive-stub.ts (RouterLinkDirectiveStub)\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: '[<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]'\n})\nexport class RouterLinkDirectiveStub {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>') linkParams: any;\n  navigatedTo: any = null;\n\n  @<a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>('click')\n  onClick() {\n    this.navigatedTo = this.linkParams;\n  }\n}\n\n</code-example>\n<p><code>[<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]</code> 어트리뷰트로 바인딩된 URL은 디렉티브 <code>linkParams</code> 프로퍼티로 전달됩니다.</p>\n<p>그리고 <code><a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a></code>는 호스트 엘리먼트(<code>AppComponent</code>의 <code>&#x3C;a></code> 엘리먼트)에서 발생하는 클릭 이벤트를 디렉티브 <code>onClick()</code> 메서드와 바인딩합니다.</p>\n<p>이제 앵커 엘리먼트를 클릭하면 <code>onClick()</code> 메서드가 실행되면서 목 디렉티브의 <code>navigatedTo</code> 프로퍼티 값을 할당합니다.\n그러면 앵커 엘리먼트를 클릭했을 때 이동하는 주소는 <code>navigatedTo</code> 프로퍼티 값을 확인하는 방식으로 검사할 수 있습니다.</p>\n<div class=\"alert is-helpful\">\n<p>이동하려는 주소가 라우터에 등록되어 있는지 확인하는 테스트는 이 테스트와 별개입니다.</p>\n</div>\n<a id=\"by-directive\"></a>\n<a id=\"inject-directive\"></a>\n<!--\n#### _By.directive_ and injected directives\n-->\n<h4 id=\"bydirective-와-의존성으로-주입된-디렉티브\"><em>By.directive</em> 와 의존성으로 주입된 디렉티브<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#bydirective-와-의존성으로-주입된-디렉티브\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nA little more setup triggers the initial data binding and gets references to the navigation links:\n\n<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"test-setup\" header=\"app/app.component.spec.ts (test setup)\">\nbeforeEach(() =&gt; {\n  fixture.detectChanges(); // 초기 데이터 바인딩을 실행합니다.\n\n  // RouterLinkStubDirective가 사용된 DebugElement를 쿼리합니다.\n  linkDes = fixture.debugElement.queryAll(By.directive(RouterLinkDirectiveStub));\n\n  // DebugElement의 인젝터를 사용해서 개별 디렉티브 인스턴스를 참조합니다.\n  routerLinks = linkDes.map(de =&gt; de.injector.get(RouterLinkDirectiveStub));\n});\n\n</code-example>\n\nThree points of special interest:\n\n1.  You can locate the anchor elements with an attached directive using `By.directive`.\n\n1.  The query returns `DebugElement` wrappers around the matching elements.\n\n1.  Each `DebugElement` exposes a dependency injector with the\n    specific instance of the directive attached to that element.\n\nThe `AppComponent` links to validate are as follows:\n\n<code-example path=\"testing/src/app/app.component.html\" region=\"links\" header=\"app/app.component.html (navigation links)\">\n&lt;nav&gt;\n  &lt;a routerLink=&quot;/dashboard&quot;&gt;Dashboard&lt;/a&gt;\n  &lt;a routerLink=&quot;/heroes&quot;&gt;Heroes&lt;/a&gt;\n  &lt;a routerLink=&quot;/about&quot;&gt;About&lt;/a&gt;\n&lt;/nav&gt;\n\n</code-example>\n\n<a id=\"app-component-tests\"></a>\n\nHere are some tests that confirm those links are wired to the `routerLink` directives\nas expected:\n\n<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"tests\" header=\"app/app.component.spec.ts (selected tests)\">\nit(&#39;can get RouterLinks from template&#39;, () =&gt; {\n  expect(routerLinks.length).toBe(3, &#39;should have 3 routerLinks&#39;);\n  expect(routerLinks[0].linkParams).toBe(&#39;/dashboard&#39;);\n  expect(routerLinks[1].linkParams).toBe(&#39;/heroes&#39;);\n  expect(routerLinks[2].linkParams).toBe(&#39;/about&#39;);\n});\n\nit(&#39;can click Heroes link in template&#39;, () =&gt; {\n  const heroesLinkDe = linkDes[1];    // 히어로 목록으로 가는 링크를 표현하는 DebugElement\n  const heroesLink = routerLinks[1];  // 히어로 목록으로 가는 링크와 연결된 디렉티브\n\n  expect(heroesLink.navigatedTo).toBeNull(&#39;should not have navigated yet&#39;);\n\n  heroesLinkDe.triggerEventHandler(&#39;click&#39;, null);\n  fixture.detectChanges();\n\n  expect(heroesLink.navigatedTo).toBe(&#39;/heroes&#39;);\n});\n\n</code-example>\n\n<div class=\"alert is-helpful\">\n\nThe \"click\" test _in this example_ is misleading.\nIt tests the `RouterLinkDirectiveStub` rather than the _component_.\nThis is a common failing of directive stubs.\n\nIt has a legitimate purpose in this guide.\nIt demonstrates how to find a `RouterLink` element, click it, and inspect a result,\nwithout engaging the full router machinery.\nThis is a skill you may need to test a more sophisticated component, one that changes the display,\nre-calculates parameters, or re-arranges navigation options when the user clicks the link.\n\n</div>\n-->\n<p>데이터 초기값을 바인딩하려면 네비게이션 링크 인스턴스를 가져와야 합니다:</p>\n<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"test-setup\" header=\"app/app.component.spec.ts (테스트 환경설정)\">\nbeforeEach(() => {\n  fixture.detectChanges(); // 초기 데이터 바인딩을 실행합니다.\n\n  // RouterLinkStubDirective가 사용된 <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>를 쿼리합니다.\n  linkDes = fixture.debugElement.queryAll(By.directive(RouterLinkDirectiveStub));\n\n  // <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>의 인젝터를 사용해서 개별 디렉티브 인스턴스를 참조합니다.\n  routerLinks = linkDes.map(de => de.injector.get(RouterLinkDirectiveStub));\n});\n\n</code-example>\n<p>이 코드에서 이런 내용이 중요합니다:</p>\n<ol>\n<li>\n<p>앵커 엘리먼트에 적용된 디렉티브는 <code>By.directive</code>로 참조할 수 있습니다.</p>\n</li>\n<li>\n<p><code>queryAll()</code> 함수는 해당 엘리먼트를 래핑한 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>를 반환합니다.</p>\n</li>\n<li>\n<p>개별 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>에 있는 의존성 주입기(인젝터)를 활용하면 해당 엘리먼트 인스턴스에 있는 디렉티브 인스턴스를 참조할 수 있습니다.</p>\n</li>\n</ol>\n<p>검사해야 할 <code>AppComponent</code> 링크들은 이렇습니다:</p>\n<code-example path=\"testing/src/app/app.component.html\" region=\"links\" header=\"app/app.component.html (네비게이션 링크)\">\n&#x3C;nav>\n  &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/dashboard\">Dashboard&#x3C;/a>\n  &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/heroes\">Heroes&#x3C;/a>\n  &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/about\">About&#x3C;/a>\n&#x3C;/nav>\n\n</code-example>\n<a id=\"app-component-tests\"></a>\n<p>이제 개별 링크가 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> 디렉티브와 잘 연결되었는지 테스트하려면 테스트 코드를 이렇게 작성하면 됩니다:</p>\n<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"tests\" header=\"app/app.component.spec.ts (링크 테스트)\">\nit('can get RouterLinks from template', () => {\n  expect(routerLinks.length).toBe(3, 'should have 3 routerLinks');\n  expect(routerLinks[0].linkParams).toBe('/dashboard');\n  expect(routerLinks[1].linkParams).toBe('/heroes');\n  expect(routerLinks[2].linkParams).toBe('/about');\n});\n\nit('can click Heroes link in template', () => {\n  const heroesLinkDe = linkDes[1];    // 히어로 목록으로 가는 링크를 표현하는 <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>\n  const heroesLink = routerLinks[1];  // 히어로 목록으로 가는 링크와 연결된 디렉티브\n\n  expect(heroesLink.navigatedTo).toBeNull('should not have navigated yet');\n\n  heroesLinkDe.triggerEventHandler('click', null);\n  fixture.detectChanges();\n\n  expect(heroesLink.navigatedTo).toBe('/heroes');\n});\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p><em>이 테스트처럼</em> \"click\" 이벤트를 테스트하는 것은 논란의 여지가 있습니다.\n이 코드는 <em>컴포넌트</em> 를 테스트하는 것이 아니라 <code>RouterLinkDirectiveStub</code>를 테스트하는 것이기 때문입니다.\n목 디렉티브 객체로 이런 테스트 코드를 작성하면 원하는 결과를 얻지 못할 수도 있습니다.</p>\n<p>하지만 이 문서에서 다루는 내용을 확인하는 정도라면 문제되지 않습니다.\n이 문서는 라우터의 기능을 완벽하게 실행하는 것이 아니라 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>가 적용된 엘리먼트를 찾고, 클릭한 후에, 결과가 예상한 대로인지 검사하는 것으로 충분합니다.\n사용자가 링크를 클릭했을 때 화면을 실제로 갱신하고 라우팅 인자를 다시 참조하며 네비게이션 옵션을 다시 확인하는 것보다는 이 방식이 더 사용하기 편합니다.</p>\n</div>\n<a id=\"why-stubbed-routerlink-tests\"></a>\n<!--\n#### What good are these tests?\n-->\n<h4 id=\"이런-테스트는-어떤-점이-좋나요\">이런 테스트는 어떤 점이 좋나요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#이런-테스트는-어떤-점이-좋나요\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nStubbed `RouterLink` tests can confirm that a component with links and an outlet is setup properly,\nthat the component has the links it should have, and that they are all pointing in the expected direction.\nThese tests do not concern whether the app will succeed in navigating to the target component when the user clicks a link.\n\nStubbing the RouterLink and RouterOutlet is the best option for such limited testing goals.\nRelying on the real router would make them brittle.\nThey could fail for reasons unrelated to the component.\nFor example, a navigation guard could prevent an unauthorized user from visiting the `HeroListComponent`.\nThat's not the fault of the `AppComponent` and no change to that component could cure the failed test.\n\nA _different_ battery of tests can explore whether the application navigates as expected\nin the presence of conditions that influence guards such as whether the user is authenticated and authorized.\n\n<div class=\"alert is-helpful\">\n\nA future guide update will explain how to write such\ntests with the `RouterTestingModule`.\n\n</div>\n-->\n<p><code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>를 목 객체로 대체해서 테스트하면 컴포넌트에 링크가 존재하는지, 이 링크들은 정해진 주소와 제대로 연결되어있는지 간단하게 확인할 수 있습니다.\n사용자가 링크를 클릭한 이후에 해당 컴포넌트가 제대로 표시되는 지는 신경쓰지 않아도 됩니다.</p>\n<p>꼭 필요한 내용만 테스트하려면 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>와 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>을 목 객체로 대신하는 것이 최선의 방법입니다.\n실제 라우터 객체를 사용하면 테스트하는 컴포넌트와 상관없는 이유로 얼마든지 문제가 발생할 수 있기 때문에 일을 복잡하게 만들기만 할 뿐입니다.\n<code>HeroListComponent</code>로 이동할 때 네비게이션 가드가 로그인하지 않은 사용자를 걸러낼 수도 있습니다.\n하지만 이런 상황은 <code>AppComponent</code>가 잘못한 것이 아니며 <code>AppComponent</code>를 수정한다고 이 문제가 해결되는 것도 아닙니다.</p>\n<p>권한이 없거나 로그인하지 않은 사용자가 화면을 전환하는 것을 막는 가드는 해당 가드를 테스트 코드로 확인하는 것이 좋습니다.</p>\n<div class=\"alert is-helpful\">\n<p><code><a href=\"api/router/testing/RouterTestingModule\" class=\"code-anchor\">RouterTestingModule</a></code>을 활용해서 테스트 코드를 작성하는 방법은 다른 가이드 문서에서 다룰 예정입니다.</p>\n</div>\n<hr>\n<a id=\"page-object\"></a>\n<!--\n## Use a _page_ object\n-->\n<h2 id=\"page-객체-활용하기\"><em>page</em> 객체 활용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#page-객체-활용하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe `HeroDetailComponent` is a simple view with a title, two hero fields, and two buttons.\n\n<div class=\"lightbox\">\n  <img src='generated/images/guide/testing/hero-detail.component.png' alt=\"HeroDetailComponent in action\">\n</div>\n\nBut there's plenty of template complexity even in this simple form.\n\n<code-example path=\"testing/src/app/hero/hero-detail.component.html\" header=\"app/hero/hero-detail.component.html\">\n&lt;div *ngIf=&quot;hero&quot;&gt;\n  &lt;h2&gt;&lt;span&gt;{{hero.name | titlecase}}&lt;/span&gt; Details&lt;/h2&gt;\n  &lt;div&gt;\n    &lt;label&gt;id: &lt;/label&gt;{{hero.id}}&lt;/div&gt;\n  &lt;div&gt;\n    &lt;label for=&quot;name&quot;&gt;name: &lt;/label&gt;\n    &lt;input id=&quot;name&quot; [(ngModel)]=&quot;hero.name&quot; placeholder=&quot;name&quot; /&gt;\n  &lt;/div&gt;\n  &lt;button (click)=&quot;save()&quot;&gt;Save&lt;/button&gt;\n  &lt;button (click)=&quot;cancel()&quot;&gt;Cancel&lt;/button&gt;\n&lt;/div&gt;\n\n\n</code-example>\n\nTests that exercise the component need ...\n\n- to wait until a hero arrives before elements appear in the DOM.\n- a reference to the title text.\n- a reference to the name input box to inspect and set it.\n- references to the two buttons so they can click them.\n- spies for some of the component and router methods.\n\nEven a small form such as this one can produce a mess of tortured conditional setup and CSS element selection.\n\nTame the complexity with a `Page` class that handles access to component properties\nand encapsulates the logic that sets them.\n\nHere is such a `Page` class for the `hero-detail.component.spec.ts`\n\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"page\" header=\"app/hero/hero-detail.component.spec.ts (Page)\">\nclass Page {\n  // DOM에서 원하는 엘리먼트를 참조하는 게터 함수를 정의합니다.\n  get buttons() {\n    return this.queryAll&lt;HTMLButtonElement&gt;(&#39;button&#39;);\n  }\n  get saveBtn() {\n    return this.buttons[0];\n  }\n  get cancelBtn() {\n    return this.buttons[1];\n  }\n  get nameDisplay() {\n    return this.query&lt;HTMLElement&gt;(&#39;span&#39;);\n  }\n  get nameInput() {\n    return this.query&lt;HTMLInputElement&gt;(&#39;input&#39;);\n  }\n\n  gotoListSpy: jasmine.Spy;\n  navigateSpy: jasmine.Spy;\n\n  constructor(someFixture: ComponentFixture&lt;HeroDetailComponent&gt;) {\n    // 의존성 객체로 주입된 라우터 스파이 객체를 참조합니다.\n    const routerSpy = someFixture.debugElement.injector.get(Router) as any;\n    this.navigateSpy = routerSpy.navigate;\n\n    // 컴포넌트의 `gotoList()` 메소드에 스파이를 적용합니다.\n    const someComponent = someFixture.componentInstance;\n    this.gotoListSpy = spyOn(someComponent, &#39;gotoList&#39;).and.callThrough();\n  }\n\n  //// 쿼리 헬퍼 ////\n  private query&lt;T&gt;(selector: string): T {\n    return fixture.nativeElement.querySelector(selector);\n  }\n\n  private queryAll&lt;T&gt;(selector: string): T[] {\n    return fixture.nativeElement.querySelectorAll(selector);\n  }\n}\n\n</code-example>\n\nNow the important hooks for component manipulation and inspection are neatly organized and accessible from an instance of `Page`.\n\nA `createComponent` method creates a `page` object and fills in the blanks once the `hero` arrives.\n\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"create-component\" header=\"app/hero/hero-detail.component.spec.ts (createComponent)\">\n/** HeroDetailComponent의 인스턴스를 생성하고, 초기화하며, 테스트 변수를 할당합니다. */\nfunction createComponent() {\n  fixture = TestBed.createComponent(HeroDetailComponent);\n  component = fixture.componentInstance;\n  page = new Page(fixture);\n\n  // 첫번째 변화 감지 로직이 동작하면 히어로 데이터를 가져오는 ngOnInit이 실행됩니다.\n  fixture.detectChanges();\n  return fixture.whenStable().then(() =&gt; {\n    // 두번째 변화 감지 로직이 동작하면 비동기로 가져온 히어로 데이터가 화면에 표시됩니다.\n    fixture.detectChanges();\n  });\n}\n\n</code-example>\n\nThe [_HeroDetailComponent_ tests](#tests-w-test-double) in an earlier section demonstrate how `createComponent` and `page`\nkeep the tests short and _on message_.\nThere are no distractions: no waiting for promises to resolve and no searching the DOM for element values to compare.\n\nHere are a few more `HeroDetailComponent` tests to reinforce the point.\n\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"selected-tests\" header=\"app/hero/hero-detail.component.spec.ts (selected tests)\">\nit(&#39;should display that hero\\&#39;s name&#39;, () =&gt; {\n  expect(page.nameDisplay.textContent).toBe(expectedHero.name);\n});\n\nit(&#39;should navigate when click cancel&#39;, () =&gt; {\n  click(page.cancelBtn);\n  expect(page.navigateSpy.calls.any()).toBe(true, &#39;router.navigate called&#39;);\n});\n\nit(&#39;should save when click save but not navigate immediately&#39;, () =&gt; {\n  // 컴포넌트로 의존성 주입된 서비스를 참조하고, `saveHero` 메소드에 스파이를 연결합니다.\n  // 테스트 코드를 안전하게 실행하기 위해, `HeroDetailService.saveHero` 메소드는 목 클래스에 만든 `HeroService.updateHero`를 사용합니다.\n  const hds = fixture.debugElement.injector.get(HeroDetailService);\n  const saveSpy = spyOn(hds, &#39;saveHero&#39;).and.callThrough();\n\n  click(page.saveBtn);\n  expect(saveSpy.calls.any()).toBe(true, &#39;HeroDetailService.save called&#39;);\n  expect(page.navigateSpy.calls.any()).toBe(false, &#39;router.navigate not called&#39;);\n});\n\nit(&#39;should navigate when click save and save resolves&#39;, fakeAsync(() =&gt; {\n     click(page.saveBtn);\n     tick();  // 비동기 저장 작업이 종료될 때까지 기다립니다.\n     expect(page.navigateSpy.calls.any()).toBe(true, &#39;router.navigate called&#39;);\n   }));\n\nit(&#39;should convert hero name to Title Case&#39;, () =&gt; {\n  // 이름에 해당하는 input 엘리먼트와 이 이름을 화면에 표시하는 span 엘리먼트를 DOM에서 참조합니다.\n  const hostElement = fixture.nativeElement;\n  const nameInput: HTMLInputElement = hostElement.querySelector(&#39;input&#39;);\n  const nameDisplay: HTMLElement = hostElement.querySelector(&#39;span&#39;);\n\n  // 사용자가 입력한 것처럼 입력 필드의 내용을 변경합니다.\n  nameInput.value = &#39;quick BROWN  fOx&#39;;\n\n  // 엘리먼트의 값이 변경되었다는 것을 Angular에게 알리기 위해 DOM 이벤트를 생성합니다.\n  // IE와 같이 오래된 브라우저에서는 CustomEvent 를 사용해야 합니다. 아래 문서를 참고하세요.\n  // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill\n  nameInput.dispatchEvent(new Event(&#39;input&#39;));\n\n  // Angular가 화면을 갱신하도록 detectChanges() 함수를 실행합니다.\n  fixture.detectChanges();\n\n  expect(nameDisplay.textContent).toBe(&#39;Quick Brown  Fox&#39;);\n});\n\n</code-example>\n-->\n<p><code>HeroDetailComponent</code>는 제목과 히어로 필드 2개, 버튼 2개로 구성된 컴포넌트입니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/testing/hero-detail.component.png\" alt=\"HeroDetailComponent in action\" width=\"269\" height=\"170\">\n</div>\n<p>하지만 이렇게 간단한 폼도 템플릿은 얼마든지 복잡하게 구성될 수 있습니다.</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.html\" header=\"app/hero/hero-detail.component.html\">\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero\">\n  &#x3C;h2>&#x3C;span>{{hero.name | <a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">titlecase</a>}}&#x3C;/span> Details&#x3C;/h2>\n  &#x3C;div>\n    &#x3C;label>id: &#x3C;/label>{{hero.id}}&#x3C;/div>\n  &#x3C;div>\n    &#x3C;label for=\"name\">name: &#x3C;/label>\n    &#x3C;input id=\"name\" [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.name\" placeholder=\"name\" />\n  &#x3C;/div>\n  &#x3C;button (click)=\"save()\">Save&#x3C;/button>\n  &#x3C;button (click)=\"cancel()\">Cancel&#x3C;/button>\n&#x3C;/div>\n\n\n</code-example>\n<p>이 컴포넌트를 테스트하려면...</p>\n<ul>\n<li>컴포넌트가 히어로 데이터를 받아 DOM에 표시될 때까지 기다려야 합니다.</li>\n<li>제목을 참조해와야 합니다.</li>\n<li>이름을 입력하는 입력 필드를 참조해와야 합니다.</li>\n<li>클릭할 수 있는 버튼을 참조해와야 합니다.</li>\n<li>일부 컴포넌트와 라우터는 목 객체로 대신해야 합니다.</li>\n</ul>\n<p>이렇게 간단한 폼을 테스트할 때도 미리 준비해야 하는 환경설정과 CSS 엘리먼트 쿼리 로직이 많아질 수 있습니다.</p>\n<p>이 문제를 간단하게 하려면 <code>Page</code> 클래스를 별도로 만들어서 컴포넌트 프로퍼티를 직접 다루고 환경설정 코드도 캡슐화하는 것이 좋습니다.</p>\n<p><code>hero-detail.component.spec.ts</code> 파일에서 사용하는 <code>Page</code> 클래스 코드는 이렇습니다.</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"page\" header=\"app/hero/hero-detail.component.spec.ts (Page)\">\nclass Page {\n  // DOM에서 원하는 엘리먼트를 참조하는 게터 함수를 정의합니다.\n  get buttons() {\n    return this.queryAll&#x3C;HTMLButtonElement>('button');\n  }\n  get saveBtn() {\n    return this.buttons[0];\n  }\n  get cancelBtn() {\n    return this.buttons[1];\n  }\n  get nameDisplay() {\n    return this.query&#x3C;HTMLElement>('span');\n  }\n  get nameInput() {\n    return this.query&#x3C;HTMLInputElement>('input');\n  }\n\n  gotoListSpy: jasmine.Spy;\n  navigateSpy: jasmine.Spy;\n\n  constructor(someFixture: <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>&#x3C;HeroDetailComponent>) {\n    // 의존성 객체로 주입된 라우터 스파이 객체를 참조합니다.\n    const routerSpy = someFixture.debugElement.injector.get(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) as any;\n    this.navigateSpy = routerSpy.navigate;\n\n    // 컴포넌트의 `gotoList()` 메소드에 스파이를 적용합니다.\n    const someComponent = someFixture.componentInstance;\n    this.gotoListSpy = spyOn(someComponent, 'gotoList').and.callThrough();\n  }\n\n  //// 쿼리 헬퍼 ////\n  private <a href=\"api/animations/query\" class=\"code-anchor\">query</a>&#x3C;T>(selector: string): T {\n    return fixture.nativeElement.querySelector(selector);\n  }\n\n  private queryAll&#x3C;T>(selector: string): T[] {\n    return fixture.nativeElement.querySelectorAll(selector);\n  }\n}\n\n</code-example>\n<p>이제 컴포넌트를 조작하고 검사하는 동작은 <code>Page</code> 객체의 인스턴스를 활용하는 것이 더 간단합니다.</p>\n<p><code>createComponent</code> 메서드는 <code>page</code> 객체를 생성하고 <code>hero</code> 데이터가 전달되기 전까지 사용할 기본값을 채우는 동작을 합니다.</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"create-component\" header=\"app/hero/hero-detail.component.spec.ts (createComponent())\">\n/** HeroDetailComponent의 인스턴스를 생성하고, 초기화하며, 테스트 변수를 할당합니다. */\nfunction createComponent() {\n  fixture = TestBed.createComponent(HeroDetailComponent);\n  component = fixture.componentInstance;\n  page = new Page(fixture);\n\n  // 첫번째 변화 감지 로직이 동작하면 히어로 데이터를 가져오는 ngOnInit이 실행됩니다.\n  fixture.detectChanges();\n  return fixture.whenStable().then(() => {\n    // 두번째 변화 감지 로직이 동작하면 비동기로 가져온 히어로 데이터가 화면에 표시됩니다.\n    fixture.detectChanges();\n  });\n}\n\n</code-example>\n<p>이전 섹션에서 다룬 <a href=\"guide/testing-components-scenarios#tests-w-test-double\"><em>HeroDetailComponent</em> 테스트 코드</a>는 <code>createComponent()</code> 메서드와 <code>page</code>를 활용해서 테스트 코드를 줄이는 방법에 대해 설명했습니다.\n군더더기는 없습니다.\n프라미스가 완료되기를 기다릴 필요가 없으며 DOM 에서 원하는 엘리먼트를 찾는 코드도 필요없습니다.</p>\n<p>몇가지 테스트를 더 추가해보면 이렇게 활용할 수 있습니다.</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"selected-tests\" header=\"app/hero/hero-detail.component.spec.ts (히어로 선택 테스트)\">\nit('should display that hero\\'s name', () => {\n  expect(page.nameDisplay.textContent).toBe(expectedHero.name);\n});\n\nit('should navigate when click cancel', () => {\n  click(page.cancelBtn);\n  expect(page.navigateSpy.calls.any()).toBe(true, 'router.navigate called');\n});\n\nit('should save when click save but not navigate immediately', () => {\n  // 컴포넌트로 의존성 주입된 서비스를 참조하고, `saveHero` 메소드에 스파이를 연결합니다.\n  // 테스트 코드를 안전하게 실행하기 위해, `HeroDetailService.saveHero` 메소드는 목 클래스에 만든 `HeroService.updateHero`를 사용합니다.\n  const hds = fixture.debugElement.injector.get(HeroDetailService);\n  const saveSpy = spyOn(hds, 'saveHero').and.callThrough();\n\n  click(page.saveBtn);\n  expect(saveSpy.calls.any()).toBe(true, 'HeroDetailService.save called');\n  expect(page.navigateSpy.calls.any()).toBe(false, 'router.navigate not called');\n});\n\nit('should navigate when click save and save resolves', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() => {\n     click(page.saveBtn);\n     <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>();  // 비동기 저장 작업이 종료될 때까지 기다립니다.\n     expect(page.navigateSpy.calls.any()).toBe(true, 'router.navigate called');\n   }));\n\nit('should convert hero name to <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a> Case', () => {\n  // 이름에 해당하는 input 엘리먼트와 이 이름을 화면에 표시하는 span 엘리먼트를 DOM에서 참조합니다.\n  const hostElement = fixture.nativeElement;\n  const nameInput: HTMLInputElement = hostElement.querySelector('input');\n  const nameDisplay: HTMLElement = hostElement.querySelector('span');\n\n  // 사용자가 입력한 것처럼 입력 필드의 내용을 변경합니다.\n  nameInput.value = 'quick BROWN  fOx';\n\n  // 엘리먼트의 값이 변경되었다는 것을 Angular에게 알리기 위해 DOM 이벤트를 생성합니다.\n  // IE와 같이 오래된 브라우저에서는 CustomEvent 를 사용해야 합니다. 아래 문서를 참고하세요.\n  // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill\n  nameInput.dispatchEvent(new <a href=\"api/router/Event\" class=\"code-anchor\">Event</a>('input'));\n\n  // Angular가 화면을 갱신하도록 detectChanges() 함수를 실행합니다.\n  fixture.detectChanges();\n\n  expect(nameDisplay.textContent).toBe('Quick Brown  Fox');\n});\n\n</code-example>\n<hr>\n<a id=\"compile-components\"></a>\n<!--\n## Calling _compileComponents()_\n-->\n<h2 id=\"compilecomponents-실행하기\"><em>compileComponents()</em> 실행하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#compilecomponents-실행하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\n<div class=\"alert is-helpful\">\n\nYou can ignore this section if you _only_ run tests with the CLI `ng test` command\nbecause the CLI compiles the application before running the tests.\n\n</div>\n\nIf you run tests in a **non-CLI environment**, the tests may fail with a message like this one:\n\n<code-example language=\"sh\" class=\"code-shell\" hideCopy>\nError: This test module uses the component BannerComponent\nwhich is using a \"templateUrl\" or \"styleUrls\", but they were never compiled.\nPlease call \"TestBed.compileComponents\" before your test.\n</code-example>\n\nThe root of the problem is at least one of the components involved in the test\nspecifies an external template or CSS file as\nthe following version of the `BannerComponent` does.\n\n<code-example path=\"testing/src/app/banner/banner-external.component.ts\" header=\"app/banner/banner-external.component.ts (external template & css)\">\nimport { Component } from &#39;@angular/core&#39;;\n\n@Component({\n  selector: &#39;app-banner&#39;,\n  templateUrl: &#39;./banner-external.component.html&#39;,\n  styleUrls:  [&#39;./banner-external.component.css&#39;]\n})\nexport class BannerComponent {\n  title = &#39;Test Tour of Heroes&#39;;\n}\n\n\n</code-example>\n\nThe test fails when the `TestBed` tries to create the component.\n\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"configure-and-create\" header=\"app/banner/banner.component.spec.ts (setup that fails)\" avoid>\nbeforeEach(() =&gt; {\n  TestBed.configureTestingModule({\n    declarations: [ BannerComponent ],\n  });\n  fixture = TestBed.createComponent(BannerComponent);\n});\n\n</code-example>\n\nRecall that the app hasn't been compiled.\nSo when you call `createComponent()`, the `TestBed` compiles implicitly.\n\nThat's not a problem when the source code is in memory.\nBut the `BannerComponent` requires external files\nthat the compiler must read from the file system,\nan inherently _asynchronous_ operation.\n\nIf the `TestBed` were allowed to continue, the tests would run and fail mysteriously\nbefore the compiler could finished.\n\nThe preemptive error message tells you to compile explicitly with `compileComponents()`.\n-->\n<div class=\"alert is-helpful\">\n<p>테스트를 실행할 때 Angular CLI <code>ng test</code> 명령만 사용한다면 이 섹션은 건너뛰어도 됩니다.\nAngular CLI는 테스트를 실행하기 전에 애플리케이션을 자동으로 빌드합니다.</p>\n</div>\n<p>Angular CLI를 사용하지 않고 테스트를 실행한다면 이런 에러가 발생하면서 테스트 실행이 실패합니다:</p>\n<code-example language=\"sh\" class=\"code-shell\" hidecopy=\"\">\nError: This test module uses the component BannerComponent\nwhich is using a \"templateUrl\" or \"styleUrls\", but they were never compiled.\nPlease call \"TestBed.compileComponents\" before your test.\n</code-example>\n<p>이 문제의 원인은 테스트 코드에서 사용하는 컴포넌트 중에 외부 템플릿 파일이나 외부 CSS 파일을 사용하는 컴포넌트가 있기 때문입니다.\n지금 다루는 예제에서는 <code>BannerComponent</code>가 원인입니다.</p>\n<code-example path=\"testing/src/app/banner/banner-external.component.ts\" header=\"app/banner/banner-external.component.ts (외부 템플릿 &#x26; CSS)\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-banner',\n  templateUrl: './banner-external.component.html',\n  styleUrls:  ['./banner-external.component.css']\n})\nexport class BannerComponent {\n  title = 'Test Tour of Heroes';\n}\n\n\n</code-example>\n<p>그래서 이 테스트는 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>가 컴포넌트를 생성하는 부분에서 실패합니다.</p>\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"configure-and-create\" header=\"app/banner/banner.component.spec.ts (실행에 실패한 테스트 코드 환경설정)\" avoid=\"\">\nbeforeEach(() => {\n  TestBed.configureTestingModule({\n    declarations: [ BannerComponent ],\n  });\n  fixture = TestBed.createComponent(BannerComponent);\n});\n\n</code-example>\n<p>문제는 컴포넌트가 컴파일되지 않았다는 것입니다.\n그래서 <code>createComponent()</code>를 실행해야 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>가 컴포넌트를 컴파일합니다.</p>\n<p>소스 코드가 메모리에 있는 경우는 문제가 되지 않습니다.\n하지만 <code>BannerComponent</code>를 컴파일하려면 외부 파일을 참조하기 위해 파일 시스템을 사용해야 하고, 이 파일 시스템은 <em>비동기로</em> 동작하기 때문에 문제가 생깁니다.</p>\n<p>그래서 테스트를 더 진행하려면 컴포넌트가 컴파일되는 과정이 끝날때까지 기다려야 합니다.</p>\n<p>앞서 다룬 에러 메시지를 다시 확인해보면, <code>compileComponents()</code>를 실행하지 않았기 때문에 발생한 에러라는 것을 확인할 수 있습니다.</p>\n<!--\n#### _compileComponents()_ is async\n-->\n<h4 id=\"compiolecomponents-는-비동기로-동작합니다\"><em>compioleComponents()</em> 는 비동기로 동작합니다.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#compiolecomponents-는-비동기로-동작합니다\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nYou must call `compileComponents()` within an asynchronous test function.\n\n<div class=\"alert is-critical\">\n\nIf you neglect to make the test function async\n(e.g., forget to use `waitForAsync()` as described below),\nyou'll see this error message\n\n<code-example language=\"sh\" class=\"code-shell\" hideCopy>\nError: ViewDestroyedError: Attempt to use a destroyed view\n</code-example>\n\n</div>\n\nA typical approach is to divide the setup logic into two separate `beforeEach()` functions:\n\n1.  An async `beforeEach()` that compiles the components\n1.  A synchronous `beforeEach()` that performs the remaining setup.\n\nTo follow this pattern, import the `waitForAsync()` helper with the other testing symbols.\n\n<code-example path=\"testing/src/app/banner/banner-external.component.spec.ts\" region=\"import-async\">\nimport { ComponentFixture, TestBed, waitForAsync } from &#39;@angular/core/testing&#39;;\n\n</code-example>\n-->\n<p><code>compileComponents()</code>는 비동기 테스트 함수 안에서 실행해야 합니다.</p>\n<div class=\"alert is-critical\">\n<p><code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code>와 같은 비동기 테스트 함수를 사용하지 않으면 이런 에러가 발생합니다.</p>\n<code-example language=\"sh\" class=\"code-shell\" hidecopy=\"\">\nError: ViewDestroyedError: Attempt to use a destroyed view\n</code-example>\n</div>\n<p>일반적인 방법은 환경설정 로직을 <code>beforeEach()</code> 2개로 나누는 것입니다:</p>\n<ol>\n<li>비동기 <code>beforeEach()</code>에서는 컴포넌트를 컴파일합니다.</li>\n<li>동기 <code>beforeEach()</code>에서는 나머지 환경설정을 합니다.</li>\n</ol>\n<p>이 패턴을 활용하려면 테스트 라이브러리에서 <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a></code> 심볼을 로드해야 합니다.</p>\n<code-example path=\"testing/src/app/banner/banner-external.component.spec.ts\" region=\"import-async\">\nimport { <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>, <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>, <a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a> } from '@angular/core/testing';\n\n</code-example>\n<!--\n#### The async _beforeEach_\n-->\n<h4 id=\"비동기-beforeeach\">비동기 <em>beforeEach</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#비동기-beforeeach\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nWrite the first async `beforeEach` like this.\n\n<code-example path=\"testing/src/app/banner/banner-external.component.spec.ts\" region=\"async-before-each\" header=\"app/banner/banner-external.component.spec.ts (async beforeEach)\">\nbeforeEach(waitForAsync(() =&gt; {\n  TestBed\n      .configureTestingModule({\n        declarations: [BannerComponent],\n      })\n      .compileComponents();  // 템플릿과 CSS를 컴파일합니다.\n}));\n\n</code-example>\n\nThe `waitForAsync()` helper function takes a parameterless function with the body of the setup.\n\nThe `TestBed.configureTestingModule()` method returns the `TestBed` class so you can chain\ncalls to other `TestBed` static methods such as `compileComponents()`.\n\nIn this example, the `BannerComponent` is the only component to compile.\nOther examples configure the testing module with multiple components\nand may import application modules that hold yet more components.\nAny of them could require external files.\n\nThe `TestBed.compileComponents` method asynchronously compiles all components configured in the testing module.\n\n<div class=\"alert is-important\">\n\nDo not re-configure the `TestBed` after calling `compileComponents()`.\n\n</div>\n\nCalling `compileComponents()` closes the current `TestBed` instance to further configuration.\nYou cannot call any more `TestBed` configuration methods, not `configureTestingModule()`\nnor any of the `override...` methods. The `TestBed` throws an error if you try.\n\nMake `compileComponents()` the last step\nbefore calling `TestBed.createComponent()`.\n-->\n<p>첫 번째 비동기 <code>beforeEach()</code>는 이렇게 작성합니다.</p>\n<code-example path=\"testing/src/app/banner/banner-external.component.spec.ts\" region=\"async-before-each\" header=\"app/banner/banner-external.component.spec.ts (비동기 beforeEach())\">\nbeforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() => {\n  <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n      .configureTestingModule({\n        declarations: [BannerComponent],\n      })\n      .compileComponents();  // 템플릿과 CSS를 컴파일합니다.\n}));\n\n</code-example>\n<p><code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 헬퍼 함수는 인자가 없는 함수를 인자로 받으며, 환경설정 로직은 이 함수에 작성합니다.</p>\n<p>그리고 <code>TestBed.configureTestinModule()</code> 메서드는 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 클래스를 반환하기 때문에 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 클래스가 제공하는 정적 메소드를 바로 체이닝해서 실행할 수 있습니다.</p>\n<p>지금 다루는 예제에서는 컴파일되는 컴포넌트가 <code>BannerComponent</code> 뿐입니다.\n하지만 컴포넌트가 여러개 사용되는 테스트 모듈의 환경을 설정할 때는 컴포넌트와 모듈을 더 로드해야 할 수도 있습니다.\n외부 파일을 로드해야 할 수도 있습니다.</p>\n<p><code>TestBed.compileComponents()</code> 메서드는 테스트 모듈에 등록된 컴포넌트를 모두 비동기로 컴파일하는 메서드입니다.</p>\n<div class=\"alert is-important\">\n<p><code>compileComponents()</code>를 실행한 후에는 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 설정을 변경하지 마세요.</p>\n</div>\n<p><code>compileComponents()</code>를 실행하면 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 인스턴스의 현재 설정이 확정되며 더이상 변경되지 않습니다.\n그래서 이후에는 <code>configureTestingModule</code>, <code>override...</code>와 같은 테스트 모듈 환경설정 메서드를 실행할 수 없습니다.\n실행하면 에러가 발생합니다.</p>\n<p>그래서 <code>compileComponents()</code>는 <code>TestBed.createComponent()</code>를 실행하기 직전에 실행해야 합니다.</p>\n<!--\n#### The synchronous _beforeEach_\n-->\n<h4 id=\"동기-beforeeach\">동기 <em>beforeEach</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#동기-beforeeach\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe second, synchronous `beforeEach()` contains the remaining setup steps,\nwhich include creating the component and querying for elements to inspect.\n\n<code-example path=\"testing/src/app/banner/banner-external.component.spec.ts\" region=\"sync-before-each\" header=\"app/banner/banner-external.component.spec.ts (synchronous beforeEach)\">\nbeforeEach(() =&gt; {\n  fixture = TestBed.createComponent(BannerComponent);\n  component = fixture.componentInstance;  // BannerComponent 인스턴스를 참조합니다.\n  h1 = fixture.nativeElement.querySelector(&#39;h1&#39;);\n});\n\n</code-example>\n\nYou can count on the test runner to wait for the first asynchronous `beforeEach` to finish before calling the second.\n-->\n<p>두 번째로 구현하는 동기 <code>beforeEach()</code>에는 나머지 환경설정 로직을 작성합니다.\n컴포넌트를 생성하고 엘리먼트를 쿼리하는 로직을 작성하면 됩니다.</p>\n<code-example path=\"testing/src/app/banner/banner-external.component.spec.ts\" region=\"sync-before-each\" header=\"app/banner/banner-external.component.spec.ts (동기 beforeEach())\">\nbeforeEach(() => {\n  fixture = TestBed.createComponent(BannerComponent);\n  component = fixture.componentInstance;  // BannerComponent 인스턴스를 참조합니다.\n  h1 = fixture.nativeElement.querySelector('h1');\n});\n\n</code-example>\n<p>테스트 러너는 이 함수 이전에 작성한 비동기 <code>beforeEach()</code> 실행이 완전히 끝난 후에 두 번째 <code>beforeEach()</code> 함수를 실행합니다.</p>\n<!--\n#### Consolidated setup\n-->\n<h4 id=\"환경설정-통합하기\">환경설정 통합하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#환경설정-통합하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nYou can consolidate the two `beforeEach()` functions into a single, async `beforeEach()`.\n\nThe `compileComponents()` method returns a promise so you can perform the\nsynchronous setup tasks _after_ compilation by moving the synchronous code\ninto a `then(...)` callback.\n\n<code-example path=\"testing/src/app/banner/banner-external.component.spec.ts\" region=\"one-before-each\" header=\"app/banner/banner-external.component.spec.ts (one beforeEach)\">\nbeforeEach(waitForAsync(() =&gt; {\n  TestBed\n      .configureTestingModule({\n        declarations: [BannerComponent],\n      })\n      .compileComponents()\n      .then(() =&gt; {\n        fixture = TestBed.createComponent(BannerComponent);\n        component = fixture.componentInstance;\n        h1 = fixture.nativeElement.querySelector(&#39;h1&#39;);\n      });\n}));\n\n</code-example>\n-->\n<p><code>beforeEach()</code> 함수를 둘로 나누는 대신 비동기 <code>beforeEach()</code> 하나로 통합하는 방법도 있습니다.</p>\n<p><code>compileComponents()</code> 메서드는 프라미스를 반환하기 때문에, 컴포넌트를 컴파일한 이후에 필요한 동기 환경설정 작업은 프라미스의 <code>then()</code> 콜백으로 이어서 작성할 수 있습니다.</p>\n<code-example path=\"testing/src/app/banner/banner-external.component.spec.ts\" region=\"one-before-each\" header=\"app/banner/banner-external.component.spec.ts (beforeEach() 하나로 구성하기)\">\nbeforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() => {\n  <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n      .configureTestingModule({\n        declarations: [BannerComponent],\n      })\n      .compileComponents()\n      .then(() => {\n        fixture = TestBed.createComponent(BannerComponent);\n        component = fixture.componentInstance;\n        h1 = fixture.nativeElement.querySelector('h1');\n      });\n}));\n\n</code-example>\n<!--\n#### _compileComponents()_ is harmless\n-->\n<h4 id=\"compilecomponents-는-안전하게-실행됩니다\"><em>compileComponents()</em> 는 안전하게 실행됩니다.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#compilecomponents-는-안전하게-실행됩니다\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThere's no harm in calling `compileComponents()` when it's not required.\n\nThe component test file generated by the CLI calls `compileComponents()`\neven though it is never required when running `ng test`.\n\nThe tests in this guide only call `compileComponents` when necessary.\n-->\n<p><code>compileComponents()</code>는 필요하지 않은 시점에 실행하더라도 아무 문제가 발생하지 않습니다.</p>\n<p>Angular CLI가 자동으로 생성한 컴포넌트 테스트 파일도 이 메서드가 필요한 지는 알 수 없지만 기본적으로 <code>compileComponents()</code>를 실행합니다.</p>\n<p>다만 이 문서에서는 꼭 필요할 때만 <code>compileComponents()</code>를 실행했습니다.</p>\n<hr>\n<a id=\"import-module\"></a>\n<!--\n## Setup with module imports\n-->\n<h2 id=\"모듈을-로드하는-방식으로-환경설정-하기\">모듈을 로드하는 방식으로 환경설정 하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#모듈을-로드하는-방식으로-환경설정-하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nEarlier component tests configured the testing module with a few `declarations` like this:\n\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"config-testbed\" header=\"app/dashboard/dashboard-hero.component.spec.ts (configure TestBed)\">\nTestBed\n    .configureTestingModule({declarations: [DashboardHeroComponent]})\n\n</code-example>\n\nThe `DashboardComponent` is simple. It needs no help.\nBut more complex components often depend on other components, directives, pipes, and providers\nand these must be added to the testing module too.\n\nFortunately, the `TestBed.configureTestingModule` parameter parallels\nthe metadata passed to the `@NgModule` decorator\nwhich means you can also specify `providers` and `imports`.\n\nThe `HeroDetailComponent` requires a lot of help despite its small size and simple construction.\nIn addition to the support it receives from the default testing module `CommonModule`, it needs:\n\n- `NgModel` and friends in the `FormsModule` to enable two-way data binding.\n- The `TitleCasePipe` from the `shared` folder.\n- Router services (which these tests are stubbing).\n- Hero data access services (also stubbed).\n\nOne approach is to configure the testing module from the individual pieces as in this example:\n\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-forms-module\" header=\"app/hero/hero-detail.component.spec.ts (FormsModule setup)\">\nbeforeEach(waitForAsync(() =&gt; {\n  const routerSpy = createRouterSpy();\n\n  TestBed\n      .configureTestingModule({\n        imports: [FormsModule],\n        declarations: [HeroDetailComponent, TitleCasePipe],\n        providers: [\n          {provide: ActivatedRoute, useValue: activatedRoute},\n          {provide: HeroService, useClass: TestHeroService},\n          {provide: Router, useValue: routerSpy},\n        ]\n      })\n      .compileComponents();\n}));\n\n</code-example>\n\n<div class=\"alert is-helpful\">\n\nNotice that the `beforeEach()` is asynchronous and calls `TestBed.compileComponents`\nbecause the `HeroDetailComponent` has an external template and css file.\n\nAs explained in [_Calling compileComponents()_](#compile-components) above,\nthese tests could be run in a non-CLI environment\nwhere Angular would have to compile them in the browser.\n\n</div>\n-->\n<p>위에서 살펴본 테스트 코드에서 테스트 모듈의 환경설정은 <code>declarations</code>를 사용해서 이렇게 설정했습니다:</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"config-testbed\" header=\"app/dashboard/dashboard-hero.component.spec.ts (TestBed 환경설정)\">\n<a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n    .configureTestingModule({declarations: [DashboardHeroComponent]})\n\n</code-example>\n<p><code>DashboardComponent</code>는 아직 간단합니다.\n이정도는 별다른 헬퍼가 필요하지 않습니다.\n하지만 테스트하려는 컴포넌트가 더 복잡해져서 다른 컴포넌트, 디렉티브, 파이프, 서비스 프로바이더를 활용해야 한다면 테스트 모듈에도 이 항목들을 모두 등록해야 합니다.</p>\n<p>다행히, <code>TestBed.configureTestingModule</code> 인자는 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 데코레이터에 사용하는 메타데이터 형식과 같기 때문에 <code>providers</code>와 <code>imports</code> 배열도 사용할 수 있습니다.</p>\n<p><code>HeroDetailComponent</code> 자체는 간단하지만 이 컴포넌트를 생성하기 위해 필요한 항목들이 많습니다.\n그렇다면 테스트 모듈의 기본 설정으로 활용할 수 있는 <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code> 모듈을 만들어 봅시다.\n이 모듈에는:</p>\n<ul>\n<li>양방향 데이터 바인딩을 사용하기 위해 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>이 제공하는 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 관련 심볼을 등록합니다.</li>\n<li><code>shared</code> 폴더에 있는 <code><a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a></code>를 등록합니다.</li>\n<li>라우터 서비스의 목 객체를 등록합니다.</li>\n<li>서비스로 가져올 히어로 데이터를 목 객체로 등록합니다.</li>\n</ul>\n<p>이런 설정들을 한 번에 모으면 이렇게 구현할 수 있습니다:</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-forms-module\" header=\"app/hero/hero-detail.component.spec.ts (FormsModule 환경설정)\">\nbeforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() => {\n  const routerSpy = createRouterSpy();\n\n  <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n      .configureTestingModule({\n        imports: [<a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>],\n        declarations: [HeroDetailComponent, <a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a>],\n        providers: [\n          {provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: activatedRoute},\n          {provide: HeroService, useClass: TestHeroService},\n          {provide: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>, useValue: routerSpy},\n        ]\n      })\n      .compileComponents();\n}));\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>이 환경설정 코드에서 <code>beforeEach()</code>는 비동기이며 <code>TestBed.compileComponents()</code>도 실행합니다.\n<code>HeroDetailComponent</code>의 템플릿 파일과 스타일 파일이 별도 파일이기 때문에 이렇게 사용했습니다.</p>\n<p>그리고 이전에 살펴본 <a href=\"guide/testing-components-scenarios#compile-components\"><em>compileComponents() 실행하기</em></a> 섹션에서 살펴봤듯이, 이 환경설정 코드는 명시적으로 컴포넌트를 컴파일하기 때문에 Angular CLI로 실행하지 않아도 테스트 코드를 실행할 수 있습니다.</p>\n</div>\n<!--\n#### Import a shared module\n-->\n<h4 id=\"공유-모듈-로드하기\">공유 모듈 로드하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#공유-모듈-로드하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nBecause many app components need the `FormsModule` and the `TitleCasePipe`, the developer created\na `SharedModule` to combine these and other frequently requested parts.\n\nThe test configuration can use the `SharedModule` too as seen in this alternative setup:\n\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-shared-module\" header=\"app/hero/hero-detail.component.spec.ts (SharedModule setup)\">\nbeforeEach(waitForAsync(() =&gt; {\n  const routerSpy = createRouterSpy();\n\n  TestBed\n      .configureTestingModule({\n        imports: [SharedModule],\n        declarations: [HeroDetailComponent],\n        providers: [\n          {provide: ActivatedRoute, useValue: activatedRoute},\n          {provide: HeroService, useClass: TestHeroService},\n          {provide: Router, useValue: routerSpy},\n        ]\n      })\n      .compileComponents();\n}));\n\n</code-example>\n\nIt's a bit tighter and smaller, with fewer import statements (not shown).\n-->\n<p><code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>과 <code><a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a></code>가 애플리케이션 곳곳에 사용된다면 이 부분을 <code>SharedModule</code>로 만들어두고 재사용하는 것이 편합니다.</p>\n<p>환경설정을 이렇게 구성하면 됩니다:</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-shared-module\" header=\"app/hero/hero-detail.component.spec.ts (SharedModule 환경설정)\">\nbeforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() => {\n  const routerSpy = createRouterSpy();\n\n  <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n      .configureTestingModule({\n        imports: [SharedModule],\n        declarations: [HeroDetailComponent],\n        providers: [\n          {provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: activatedRoute},\n          {provide: HeroService, useClass: TestHeroService},\n          {provide: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>, useValue: routerSpy},\n        ]\n      })\n      .compileComponents();\n}));\n\n</code-example>\n<p>이제 이 모듈을 활용하면 환경설정 코드가 더 간단해질 것입니다.</p>\n<a id=\"feature-module-import\"></a>\n<!--\n#### Import a feature module\n-->\n<h4 id=\"기능-모듈-로드하기\">기능 모듈 로드하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#기능-모듈-로드하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe `HeroDetailComponent` is part of the `HeroModule` [Feature Module](guide/feature-modules) that aggregates more of the interdependent pieces\nincluding the `SharedModule`.\nTry a test configuration that imports the `HeroModule` like this one:\n\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-hero-module\" header=\"app/hero/hero-detail.component.spec.ts (HeroModule setup)\">\nbeforeEach(waitForAsync(() =&gt; {\n  const routerSpy = createRouterSpy();\n\n  TestBed\n      .configureTestingModule({\n        imports: [HeroModule],\n        providers: [\n          {provide: ActivatedRoute, useValue: activatedRoute},\n          {provide: HeroService, useClass: TestHeroService},\n          {provide: Router, useValue: routerSpy},\n        ]\n      })\n      .compileComponents();\n}));\n\n</code-example>\n\nThat's _really_ crisp. Only the _test doubles_ in the `providers` remain. Even the `HeroDetailComponent` declaration is gone.\n\nIn fact, if you try to declare it, Angular will throw an error because\n`HeroDetailComponent` is declared in both the `HeroModule` and the `DynamicTestModule`\ncreated by the `TestBed`.\n\n<div class=\"alert is-helpful\">\n\nImporting the component's feature module can be the easiest way to configure tests\nwhen there are many mutual dependencies within the module and\nthe module is small, as feature modules tend to be.\n\n</div>\n-->\n<p><code>HeroDetailComponent</code>는 <code>HeroModule</code>이라는 <a href=\"guide/feature-modules\">기능 모듈</a>에 포함되어 있으며 <code>HeroModule</code>은 <code>SharedModule</code>을 포함해서 다른 구성요소들과도 연관되어 있습니다.\n그렇다면 <code>HeroModule</code>을 로드해서 활용하는 테스트 환경설정 코드는 이렇게 구성할 수 있습니다:</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-hero-module\" header=\"app/hero/hero-detail.component.spec.ts (HeroModule 환경설정)\">\nbeforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() => {\n  const routerSpy = createRouterSpy();\n\n  <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n      .configureTestingModule({\n        imports: [HeroModule],\n        providers: [\n          {provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: activatedRoute},\n          {provide: HeroService, useClass: TestHeroService},\n          {provide: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>, useValue: routerSpy},\n        ]\n      })\n      .compileComponents();\n}));\n\n</code-example>\n<p>이 코드는 <em>정말</em> 단순합니다.\n<code>HeroModule</code>을 제외하면 모두 <em>목 객체</em> 를 등록하는 것 뿐입니다.\n<code>HeroDetailComponent</code>를 등록하는 코드도 없습니다.</p>\n<p>사실 이렇게 선언하면 <code>HeroDetailComponent</code>가 <code>HeroModule</code>과 <code>DynamicTestModule</code>에 중복 등록되기 때문에 에러가 발생합니다.</p>\n<div class=\"alert is-helpful\">\n<p>테스트 환경을 구성할 때는 컴포넌트를 포함하는 기능 모듈을 통째로 로드하는 방식이 가장 간단합니다.\n모듈을 통째로 로드하면 모듈 안에서 필요한 의존성 관계도 모듈 안에서 자동으로 구성됩니다.</p>\n</div>\n<hr>\n<a id=\"component-override\"></a>\n<!--\n## Override component providers\n-->\n<h2 id=\"컴포넌트-프로바이더-오버라이드하기\">컴포넌트 프로바이더 오버라이드하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#컴포넌트-프로바이더-오버라이드하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe `HeroDetailComponent` provides its own `HeroDetailService`.\n\n<code-example path=\"testing/src/app/hero/hero-detail.component.ts\" region=\"prototype\" header=\"app/hero/hero-detail.component.ts (prototype)\">\n@Component({\n  selector:    &#39;app-hero-detail&#39;,\n  templateUrl: &#39;./hero-detail.component.html&#39;,\n  styleUrls:  [&#39;./hero-detail.component.css&#39; ],\n  providers:  [ HeroDetailService ]\n})\nexport class HeroDetailComponent implements OnInit {\n  constructor(\n    private heroDetailService: HeroDetailService,\n    private route: ActivatedRoute,\n    private router: Router) {\n  }\n}\n\n</code-example>\n\nIt's not possible to stub the component's `HeroDetailService` in the `providers` of the `TestBed.configureTestingModule`.\nThose are providers for the _testing module_, not the component. They prepare the dependency injector at the _fixture level_.\n\nAngular creates the component with its _own_ injector, which is a _child_ of the fixture injector.\nIt registers the component's providers (the `HeroDetailService` in this case) with the child injector.\n\nA test cannot get to child injector services from the fixture injector.\nAnd `TestBed.configureTestingModule` can't configure them either.\n\nAngular has been creating new instances of the real `HeroDetailService` all along!\n\n<div class=\"alert is-helpful\">\n\nThese tests could fail or timeout if the `HeroDetailService` made its own XHR calls to a remote server.\nThere might not be a remote server to call.\n\nFortunately, the `HeroDetailService` delegates responsibility for remote data access to an injected `HeroService`.\n\n<code-example path=\"testing/src/app/hero/hero-detail.service.ts\" region=\"prototype\" header=\"app/hero/hero-detail.service.ts (prototype)\">\n@Injectable()\nexport class HeroDetailService {\n  constructor(private heroService: HeroService) {  }\n/* . . . */\n}\n\n</code-example>\n\nThe [previous test configuration](#feature-module-import) replaces the real `HeroService` with a `TestHeroService`\nthat intercepts server requests and fakes their responses.\n\n</div>\n\nWhat if you aren't so lucky. What if faking the `HeroService` is hard?\nWhat if `HeroDetailService` makes its own server requests?\n\nThe `TestBed.overrideComponent` method can replace the component's `providers` with easy-to-manage _test doubles_\nas seen in the following setup variation:\n\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-override\" header=\"app/hero/hero-detail.component.spec.ts (Override setup)\">\nbeforeEach(waitForAsync(() =&gt; {\n  const routerSpy = createRouterSpy();\n\n  TestBed\n      .configureTestingModule({\n        imports: [HeroModule],\n        providers: [\n          {provide: ActivatedRoute, useValue: activatedRoute},\n          {provide: Router, useValue: routerSpy},\n        ]\n      })\n\n      // 컴포넌트에 등록된 프로바이더를 오버라이드합니다.\n      .overrideComponent(\n          HeroDetailComponent,\n          {set: {providers: [{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]}})\n\n      .compileComponents();\n}));\n\n</code-example>\n\nNotice that `TestBed.configureTestingModule` no longer provides a (fake) `HeroService` because it's [not needed](#spy-stub).\n-->\n<p><code>HeroDetailComponent</code>는 컴포넌트 자체에서 <code>HeroDetailService</code>를 등록하고 있습니다.</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.ts\" region=\"prototype\" header=\"app/hero/hero-detail.component.ts (프로토타입)\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector:    'app-hero-detail',\n  templateUrl: './hero-detail.component.html',\n  styleUrls:  ['./hero-detail.component.css' ],\n  providers:  [ HeroDetailService ]\n})\nexport class HeroDetailComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  constructor(\n    private heroDetailService: HeroDetailService,\n    private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>,\n    private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {\n  }\n}\n\n</code-example>\n<p>이 서비스 프로바이더는 컴포넌트에 등록되어 있기 때문에 <code>TestBed.configureTestingModule()</code>에 서비스 프로바이더의 목 객체를 등록하는 방법으로는 대체할 수 없습니다.\n<code>TestBed.configureTestingModule()</code>에 등록하는 서비스 프로바이더는 <em>테스트 모듈</em> 에 등록하는 것이지 컴포넌트에 등록하는 것이 아닙니다.\n그래서 이 서비스 프로바이더를 목 객체로 등록하려면 <em>픽스쳐 계층</em> 에 있는 인젝터를 사용해야 합니다.</p>\n<p>Angular는 컴포넌트를 생성할 때 픽스쳐 인젝터의 자식 인젝터로 컴포넌트 인젝터를 함께 생성하며, 컴포넌트에 등록된 <code>HeroDetailService</code>는 이 컴포넌트 인젝터에 등록됩니다.</p>\n<p>하지만 픽스쳐 인젝터로는 자식 인젝터에 등록된 서비스를 참조할 수 없습니다.\n<code>TestBed.configureTestingModule()</code>도 마찬가지입니다.</p>\n<p>그래서 Angular는 실제 <code>HeroDetailService</code> 클래스의 인스턴스를 생성합니다!</p>\n<div class=\"alert is-helpful\">\n<p><code>HeroDetailService</code> 메서드가 리모트 서버로 XHR 요청을 보낸다면 이 테스트 코드가 실패하거나 타임아웃이 발생할 수 있습니다.\n리모트 서버가 준비되지 않았을 수도 있습니다.</p>\n<p>다행히, <code>HeroDetailService</code>는 의존성으로 주입되는 <code>HeroService</code>를 활용해서 데이터를 요청합니다.</p>\n<code-example path=\"testing/src/app/hero/hero-detail.service.ts\" region=\"prototype\" header=\"app/hero/hero-detail.service.ts (프로토타입)\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class HeroDetailService {\n  constructor(private heroService: HeroService) {  }\n/* . . . */\n}\n\n</code-example>\n<p>그래서 <a href=\"guide/testing-components-scenarios#feature-module-import\">이전 섹션에서 설명한</a>대로 실제 <code>HeroService</code>를 <code>TestHeroService</code>로 대체하면 서버로 보내는 요청을 가로채서 원하는 응답으로 대체할 수 있습니다.</p>\n</div>\n<p>좋지 않은 경우를 생각해 봅시다.\n<code>HeroService</code>를 대체하기 어렵다면 어떨까요?\n<code>HeroDetailService</code>가 직접 서버로 요청을 보낸다면 어떨까요?</p>\n<p><code>TestBed.overrideComponent()</code> 메서드는 컴포넌트의 <code>providers</code>에 등록된 의존성 객체를 다른 객체로 대체하는 메서드입니다.\n이렇게 사용합니다:</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-override\" header=\"app/hero/hero-detail.component.spec.ts (환경설정 오버라이드하기)\">\nbeforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() => {\n  const routerSpy = createRouterSpy();\n\n  <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n      .configureTestingModule({\n        imports: [HeroModule],\n        providers: [\n          {provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: activatedRoute},\n          {provide: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>, useValue: routerSpy},\n        ]\n      })\n\n      // 컴포넌트에 등록된 프로바이더를 오버라이드합니다.\n      .overrideComponent(\n          HeroDetailComponent,\n          {set: {providers: [{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]}})\n\n      .compileComponents();\n}));\n\n</code-example>\n<p><code>TestBed.configureTestingModule()</code>에는 이제 <code>HeroService</code>를 대체하는 코드가 없습니다.\n이 코드는 이제 <a href=\"guide/testing-components-scenarios#spy-stub\">필요하지 않습니다</a>.</p>\n<a id=\"override-component-method\"></a>\n<!--\n#### The _overrideComponent_ method\n-->\n<h4 id=\"overridecomponent-메서드\"><em>overrideComponent</em> 메서드<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#overridecomponent-메서드\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nFocus on the `overrideComponent` method.\n\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"override-component-method\" header=\"app/hero/hero-detail.component.spec.ts (overrideComponent)\">\n.overrideComponent(\n    HeroDetailComponent,\n    {set: {providers: [{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]}})\n\n</code-example>\n\nIt takes two arguments: the component type to override (`HeroDetailComponent`) and an override metadata object.\nThe [override metadata object](guide/testing-utility-apis#metadata-override-object) is a generic defined as follows:\n\n<code-example language=\"javascript\">\n  type MetadataOverride&lt;T&gt; = {\n    add?: Partial&lt;T&gt;;\n    remove?: Partial&lt;T&gt;;\n    set?: Partial&lt;T&gt;;\n  };\n</code-example>\n\nA metadata override object can either add-and-remove elements in metadata properties or completely reset those properties.\nThis example resets the component's `providers` metadata.\n\nThe type parameter, `T`, is the kind of metadata you'd pass to the `@Component` decorator:\n\n<code-example language=\"javascript\">\n  selector?: string;\n  template?: string;\n  templateUrl?: string;\n  providers?: any[];\n  ...\n</code-example>\n-->\n<p><code>overrideComponent</code> 메서드를 봅시다.</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"override-component-method\" header=\"app/hero/hero-detail.component.spec.ts (overrideComponent())\">\n.overrideComponent(\n    HeroDetailComponent,\n    {set: {providers: [{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]}})\n\n</code-example>\n<p>이 메서드는 인자를 2개 받는데, 첫 번째는 오버라이드 하려는 컴포넌트(<code>HeroDetailComponent</code>)이고, 두 번째는 오버라이드 메타데이터 객체입니다.\n<a href=\"guide/testing-utility-apis#metadata-override-object\">오버라이드 메타데이터 객체</a> 제네릭은 이렇게 선언되어 있습니다:</p>\n<code-example language=\"javascript\">\n  type <a href=\"api/core/testing/MetadataOverride\" class=\"code-anchor\">MetadataOverride</a>&#x3C;T> = {\n    add?: Partial&#x3C;T>;\n    remove?: Partial&#x3C;T>;\n    set?: Partial&#x3C;T>;\n  };\n</code-example>\n<p>메타데이터 오버라이드 객체는 기존 메타데이터를 수정하거나 온전히 대체하는 방식으로 지정할 수 있습니다.\n위 예제 코드는 컴포넌트의 <code>providers</code> 메타데이터를 완전히 대체하는 방식으로 사용되었습니다.</p>\n<p>타입 <code>T</code>는 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 데코레이터에 전달하는 메타데이터의 타입을 가리킵니다:</p>\n<code-example language=\"javascript\">\n  selector?: string;\n  template?: string;\n  templateUrl?: string;\n  providers?: any[];\n  ...\n</code-example>\n<a id=\"spy-stub\"></a>\n<!--\n#### Provide a _spy stub_ (_HeroDetailServiceSpy_)\n-->\n<h4 id=\"herodetailservicespy-목-객체-등록하기\"><em>HeroDetailServiceSpy</em> 목 객체 등록하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#herodetailservicespy-목-객체-등록하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThis example completely replaces the component's `providers` array with a new array containing a `HeroDetailServiceSpy`.\n\nThe `HeroDetailServiceSpy` is a stubbed version of the real `HeroDetailService`\nthat fakes all necessary features of that service.\nIt neither injects nor delegates to the lower level `HeroService`\nso there's no need to provide a test double for that.\n\nThe related `HeroDetailComponent` tests will assert that methods of the `HeroDetailService`\nwere called by spying on the service methods.\nAccordingly, the stub implements its methods as spies:\n\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"hds-spy\" header=\"app/hero/hero-detail.component.spec.ts (HeroDetailServiceSpy)\">\nclass HeroDetailServiceSpy {\n  testHero: Hero = {id: 42, name: &#39;Test Hero&#39;};\n\n  /* 히어로 객체를 복사해서 보냅니다. */\n  getHero = jasmine.createSpy(&#39;getHero&#39;).and.callFake(\n      () =&gt; asyncData(Object.assign({}, this.testHero)));\n\n  /* 복사한 히어로 객체에 변경사항을 반영해서 보냅니다. */\n  saveHero = jasmine.createSpy(&#39;saveHero&#39;)\n                 .and.callFake((hero: Hero) =&gt; asyncData(Object.assign(this.testHero, hero)));\n}\n\n\n</code-example>\n-->\n<p>위에서 다룬 테스트 코드처럼 사용하면 컴포넌트의 <code>providers</code> 배열이 <code>HeroDetailServiceSpy</code>가 들어있는 새로운 배열로 완전히 대체됩니다.</p>\n<p><code>HeroDetailServiceSpy</code>는 <code>HeroDetailService</code>를 대체하는 클래스이며, 서비스가 제공하는 기능은 모두 기존 기능을 대체하는 방식으로 정의되어 있습니다.\n원래 서비스 클래스에 필요한 <code>HeroService</code>는 의존성으로 주입되지 않으니 목 객체를 준비할 필요도 없습니다.</p>\n<p><code>HeroDetailService</code> 메서드를 활용하는 <code>HeroDetailComponent</code> 테스트 코드는 목 서비스로 대체된 코드로 처리되기 때문에 아무런 문제가 발생하지 않습니다.\n목 객체는 이렇게 정의되어 있습니다:</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"hds-spy\" header=\"app/hero/hero-detail.component.spec.ts (HeroDetailServiceSpy)\">\nclass HeroDetailServiceSpy {\n  testHero: Hero = {id: 42, name: 'Test Hero'};\n\n  /* 히어로 객체를 복사해서 보냅니다. */\n  getHero = jasmine.createSpy('getHero').and.callFake(\n      () => asyncData(Object.assign({}, this.testHero)));\n\n  /* 복사한 히어로 객체에 변경사항을 반영해서 보냅니다. */\n  saveHero = jasmine.createSpy('saveHero')\n                 .and.callFake((hero: Hero) => asyncData(Object.assign(this.testHero, hero)));\n}\n\n\n</code-example>\n<a id=\"override-tests\"></a>\n<!--\n#### The override tests\n-->\n<h4 id=\"오버라이드를-활용한-테스트-코드\">오버라이드를 활용한 테스트 코드<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#오버라이드를-활용한-테스트-코드\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nNow the tests can control the component's hero directly by manipulating the spy-stub's `testHero`\nand confirm that service methods were called.\n\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"override-tests\" header=\"app/hero/hero-detail.component.spec.ts (override tests)\">\nlet hdsSpy: HeroDetailServiceSpy;\n\nbeforeEach(waitForAsync(() =&gt; {\n  createComponent();\n  // 컴포넌트에 주입된 HeroDetailServiceSpy를 참조합니다.\n  hdsSpy = fixture.debugElement.injector.get(HeroDetailService) as any;\n}));\n\nit(&#39;should have called `getHero`&#39;, () =&gt; {\n  expect(hdsSpy.getHero.calls.count()).toBe(1, &#39;getHero called once&#39;);\n});\n\nit(&#39;should display stub hero\\&#39;s name&#39;, () =&gt; {\n  expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name);\n});\n\nit(&#39;should save stub hero change&#39;, fakeAsync(() =&gt; {\n     const origName = hdsSpy.testHero.name;\n     const newName = &#39;New Name&#39;;\n\n     page.nameInput.value = newName;\n\n     // IE와 같이 오래된 브라우저에서는 CustomEvent 를 사용해야 합니다. 아래 문서를 참고하세요.\n     // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill\n     page.nameInput.dispatchEvent(new Event(&#39;input&#39;)); // tell Angular\n\n     expect(component.hero.name).toBe(newName, &#39;component hero has new name&#39;);\n     expect(hdsSpy.testHero.name).toBe(origName, &#39;service hero unchanged before save&#39;);\n\n     click(page.saveBtn);\n     expect(hdsSpy.saveHero.calls.count()).toBe(1, &#39;saveHero called once&#39;);\n\n     tick();  // 비동기 저장 로직이 끝나는 것을 기다립니다.\n     expect(hdsSpy.testHero.name).toBe(newName, &#39;service hero has new name after save&#39;);\n     expect(page.navigateSpy.calls.any()).toBe(true, &#39;router.navigate called&#39;);\n   }));\n\n</code-example>\n-->\n<p>이제 컴포넌트 로직은 스파이에 있는 <code>testHero</code> 객체를 직접 조작하는 방식으로 테스트할 수 있습니다.</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"override-tests\" header=\"app/hero/hero-detail.component.spec.ts (오버라이드를 활용한 테스트 코드)\">\nlet hdsSpy: HeroDetailServiceSpy;\n\nbeforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() => {\n  createComponent();\n  // 컴포넌트에 주입된 HeroDetailServiceSpy를 참조합니다.\n  hdsSpy = fixture.debugElement.injector.get(HeroDetailService) as any;\n}));\n\nit('should have called `getHero`', () => {\n  expect(hdsSpy.getHero.calls.count()).toBe(1, 'getHero called once');\n});\n\nit('should display stub hero\\'s name', () => {\n  expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name);\n});\n\nit('should save stub hero change', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() => {\n     const origName = hdsSpy.testHero.name;\n     const newName = 'New Name';\n\n     page.nameInput.value = newName;\n\n     // IE와 같이 오래된 브라우저에서는 CustomEvent 를 사용해야 합니다. 아래 문서를 참고하세요.\n     // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill\n     page.nameInput.dispatchEvent(new <a href=\"api/router/Event\" class=\"code-anchor\">Event</a>('input')); // tell Angular\n\n     expect(component.hero.name).toBe(newName, 'component hero has new name');\n     expect(hdsSpy.testHero.name).toBe(origName, 'service hero unchanged before save');\n\n     click(page.saveBtn);\n     expect(hdsSpy.saveHero.calls.count()).toBe(1, 'saveHero called once');\n\n     <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>();  // 비동기 저장 로직이 끝나는 것을 기다립니다.\n     expect(hdsSpy.testHero.name).toBe(newName, 'service hero has new name after save');\n     expect(page.navigateSpy.calls.any()).toBe(true, 'router.navigate called');\n   }));\n\n</code-example>\n<a id=\"more-overrides\"></a>\n<!--\n#### More overrides\n-->\n<h4 id=\"오버라이드-더-활용하기\">오버라이드 더 활용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#오버라이드-더-활용하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe `TestBed.overrideComponent` method can be called multiple times for the same or different components.\nThe `TestBed` offers similar `overrideDirective`, `overrideModule`, and `overridePipe` methods\nfor digging into and replacing parts of these other classes.\n\nExplore the options and combinations on your own.\n-->\n<p><code>TestBed.overrideComponent()</code> 메서드는 컴포넌트를 대상으로 여러번 실행할 수도 있습니다.\n그리고 이 메서드와 비슷하게 활용할 수 있는 <code>overrideDirective()</code>, <code>overrideModule()</code>, <code>overridePipe()</code> 메서드를 제공하기 때문에, 클래스의 원하는 부분만 대체할 수도 있습니다.</p>\n<p>어떻게 활용할지는 여러분에게 달려있습니다.</p>\n<hr>\n\n</div>\n\n<!-- links to this doc:\n - guide/testing\n - guide/testing-attribute-directives\n - guide/testing-components-basics\n - guide/testing-utility-apis\n - guide/upgrade-setup\n-->\n<!-- links from this doc:\n - api/animations/query\n - api/common/AsyncPipe\n - api/common/CommonModule\n - api/common/NgForOf\n - api/common/NgIf\n - api/common/TitleCasePipe\n - api/common/UpperCasePipe\n - api/common/http/HttpClient\n - api/core/AfterViewInit\n - api/core/Component\n - api/core/Component#styleUrls\n - api/core/Component#styles\n - api/core/Component#template\n - api/core/Component#templateUrl\n - api/core/DebugElement\n - api/core/Directive\n - api/core/ElementRef\n - api/core/EventEmitter\n - api/core/HostListener\n - api/core/Injectable\n - api/core/Input\n - api/core/NO_ERRORS_SCHEMA\n - api/core/NgModule\n - api/core/OnInit\n - api/core/Output\n - api/core/ViewChild\n - api/core/testing/ComponentFixture\n - api/core/testing/ComponentFixtureAutoDetect\n - api/core/testing/MetadataOverride\n - api/core/testing/TestBed\n - api/core/testing/fakeAsync\n - api/core/testing/tick\n - api/core/testing/waitForAsync\n - api/forms/FormsModule\n - api/forms/NgModel\n - api/platform-browser/Title\n - api/router/ActivatedRoute\n - api/router/ActivatedRoute#paramMap\n - api/router/Event\n - api/router/ParamMap\n - api/router/Params\n - api/router/Router\n - api/router/Router#events\n - api/router/RouterLink\n - api/router/RouterModule\n - api/router/RouterOutlet\n - api/router/convertToParamMap\n - api/router/testing/RouterTestingModule\n - guide/feature-modules\n - guide/http\n - guide/lifecycle-hooks\n - guide/router-tutorial-toh\n - guide/router-tutorial-toh#activated-route-in-action\n - guide/testing-components-basics#component-class-testing\n - guide/testing-components-scenarios#activatedroutestub\n - guide/testing-components-scenarios#activatedroutestub-로-테스트하기\n - guide/testing-components-scenarios#bydirective-와-의존성으로-주입된-디렉티브\n - guide/testing-components-scenarios#click-헬퍼\n - guide/testing-components-scenarios#cold-observable\n - guide/testing-components-scenarios#compile-components\n - guide/testing-components-scenarios#compilecomponents-는-안전하게-실행됩니다\n - guide/testing-components-scenarios#compilecomponents-실행하기\n - guide/testing-components-scenarios#compiolecomponents-는-비동기로-동작합니다\n - guide/testing-components-scenarios#component-override\n - guide/testing-components-scenarios#component-with-async-service\n - guide/testing-components-scenarios#createcomponent-는-데이터를-바인딩하지-않습니다\n - guide/testing-components-scenarios#dashboard-hero-component\n - guide/testing-components-scenarios#dashboardherocomponent-단독으로-테스트하기\n - guide/testing-components-scenarios#detectchanges\n - guide/testing-components-scenarios#dispatchevent-로-입력값-변경하기\n - guide/testing-components-scenarios#fakeasync-로-비동기-테스트하기\n - guide/testing-components-scenarios#fakeasync-안에서-rxjs-스케쥴러-사용하기\n - guide/testing-components-scenarios#fakeasync-안에서-시간-확인하기\n - guide/testing-components-scenarios#feature-module-import\n - guide/testing-components-scenarios#h1-쿼리하기\n - guide/testing-components-scenarios#herodetailservicespy-목-객체-등록하기\n - guide/testing-components-scenarios#jasmine-done\n - guide/testing-components-scenarios#jasmineclock과-함께-사용하기\n - guide/testing-components-scenarios#marble-frame\n - guide/testing-components-scenarios#marble-testing\n - guide/testing-components-scenarios#no_errors_schema\n - guide/testing-components-scenarios#overridecomponent-메서드\n - guide/testing-components-scenarios#page-object\n - guide/testing-components-scenarios#page-객체-활용하기\n - guide/testing-components-scenarios#routerlink\n - guide/testing-components-scenarios#routerlink-를-사용하는-컴포넌트\n - guide/testing-components-scenarios#routing-component\n - guide/testing-components-scenarios#spy-stub\n - guide/testing-components-scenarios#testbedinject\n - guide/testing-components-scenarios#tests-w-test-double\n - guide/testing-components-scenarios#tick-함수\n - guide/testing-components-scenarios#tickoptions\n - guide/testing-components-scenarios#triggereventhandler\n - guide/testing-components-scenarios#waitForAsync\n - guide/testing-components-scenarios#waitforasync-로-비동기-테스트하기\n - guide/testing-components-scenarios#whenstable\n - guide/testing-components-scenarios#why-stubbed-routerlink-tests\n - guide/testing-components-scenarios#공유-모듈-로드하기\n - guide/testing-components-scenarios#기능-모듈-로드하기\n - guide/testing-components-scenarios#동기-beforeeach\n - guide/testing-components-scenarios#동기-테스트\n - guide/testing-components-scenarios#두가지-방법-동시에-사용하기\n - guide/testing-components-scenarios#라우터를-활용하는-컴포넌트\n - guide/testing-components-scenarios#라우팅-대상이-되는-컴포넌트\n - guide/testing-components-scenarios#마블-테스트--에러-처리\n - guide/testing-components-scenarios#마블-테스트-활용하기\n - guide/testing-components-scenarios#매크로-태스크-지원하기\n - guide/testing-components-scenarios#모듈을-로드하는-방식으로-환경설정-하기\n - guide/testing-components-scenarios#목-서비스-프로바이더-등록하기\n - guide/testing-components-scenarios#변화-감지-로직을-자동으로-실행하기\n - guide/testing-components-scenarios#비동기-beforeeach\n - guide/testing-components-scenarios#비동기-더-활용하기\n - guide/testing-components-scenarios#비동기-서비스를-주입받는-컴포넌트\n - guide/testing-components-scenarios#비동기-옵저버블\n - guide/testing-components-scenarios#비동기-옵저버블-헬퍼\n - guide/testing-components-scenarios#스파이-활용하기\n - guide/testing-components-scenarios#엘리먼트-클릭하기\n - guide/testing-components-scenarios#오버라이드-더-활용하기\n - guide/testing-components-scenarios#오버라이드를-활용한-테스트-코드\n - guide/testing-components-scenarios#외부-파일을-사용하는-컴포넌트\n - guide/testing-components-scenarios#의존성-객체가-주입되는-컴포넌트\n - guide/testing-components-scenarios#의존성으로-주입한-서비스-참조하기\n - guide/testing-components-scenarios#이런-테스트는-어떤-점이-좋나요\n - guide/testing-components-scenarios#입출력-프로퍼티가-있는-컴포넌트\n - guide/testing-components-scenarios#중첩된-컴포넌트-테스트하기\n - guide/testing-components-scenarios#컴포넌트-마블-테스트\n - guide/testing-components-scenarios#컴포넌트-바인딩\n - guide/testing-components-scenarios#컴포넌트-테스트-시나리오\n - guide/testing-components-scenarios#컴포넌트-프로바이더-오버라이드하기\n - guide/testing-components-scenarios#클릭-확인\n - guide/testing-components-scenarios#테스트-호스트-안에서-테스트하기\n - guide/testing-components-scenarios#필요없는-컴포넌트-목으로-대체하기\n - guide/testing-components-scenarios#환경설정-마무리-테스트\n - guide/testing-components-scenarios#환경설정-통합하기\n - guide/testing-utility-apis#metadata-override-object\n - http://reactivex.io/documentation/operators/defer.html\n - http://rxmarbles.com/\n - https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n - https://github.com/angular/angular/edit/master/aio/content/guide/testing-components-scenarios.md?message=docs%3A%20describe%20your%20change...\n - https://jasmine.github.io/2.0/introduction.html#section-Asynchronous_Support\n - https://plnkr.co/\n - https://rxjs.dev/guide/testing/marble-testing\n-->"
}