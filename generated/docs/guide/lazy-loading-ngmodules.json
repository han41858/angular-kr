{
  "id": "guide/lazy-loading-ngmodules",
  "title": "기능모듈 지연로딩 하기",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/lazy-loading-ngmodules.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Lazy Loading Feature Modules\n-->\n<h1 id=\"기능모듈-지연로딩-하기\">기능모듈 지연로딩 하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#기능모듈-지연로딩-하기\"><i class=\"material-icons\">link</i></a></h1>\n<!--\n#### Prerequisites\n-->\n<h4 id=\"사전-지식\">사전 지식<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#사전-지식\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nA basic understanding of the following:\n* [Feature Modules](guide/feature-modules).\n* [JavaScript Modules vs. NgModules](guide/ngmodule-vs-jsmodule).\n* [Frequently Used Modules](guide/frequent-ngmodules).\n* [Types of Feature Modules](guide/module-types).\n* [Routing and Navigation](guide/router).\n-->\n<p>다음 내용을 먼저 이해하고 이 문서를 보는 것이 좋습니다.:</p>\n<ul>\n<li><a href=\"guide/feature-modules\">기능 모듈</a></li>\n<li><a href=\"guide/ngmodule-vs-jsmodule\">JavaScript 모듈 vs. NgModules</a></li>\n<li><a href=\"guide/frequent-ngmodules\">자주 사용하는 NgModule</a></li>\n<li><a href=\"guide/module-types\">기능 모듈의 종류</a></li>\n<li><a href=\"guide/router\">라우팅, 네비게이션</a></li>\n</ul>\n<!--\nFor the final sample app with two lazy loaded modules that this page describes, see the\n<live-example></live-example>.\n-->\n<p>이 문서에서는 지연 로딩되는 모듈 2개를 만들어 봅니다. 이 문서에서 설명하는 예제 코드는 <live-example></live-example>에서 직접 확인하거나 다운받아 확인할 수 있습니다.</p>\n<hr>\n<!--\n## High level view\n-->\n<h2 id=\"개요\">개요<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#개요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThere are three main steps to setting up a lazy loaded feature module:\n\n1. Create the feature module.\n1. Create the feature module’s routing module.\n1. Configure the routes.\n-->\n<p>기능 모듈을 지연 로딩 하도록 지정하는 것은 세 단계로 구성됩니다.</p>\n<ol>\n<li>기능 모듈을 생성합니다.</li>\n<li>이 모듈을 연결하는 라우팅 모듈을 생성합니다.</li>\n<li>라우터를 설정합니다.</li>\n</ol>\n<!--\n## Set up an app\n-->\n<h2 id=\"앱-생성하기\">앱 생성하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#앱-생성하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nIf you don’t already have an app, you can follow the steps below to\ncreate one with the CLI. If you do already have an app, skip to\n[Configure the routes](#config-routes). Enter the following command\nwhere `customer-app` is the name of your app:\n-->\n<p>아직 프로젝트를 만들지 않았다면 Angular CLI를 사용해서 새로운 애플리케이션을 생성합니다. 이미 있는 앱을 활용하려면 <a href=\"guide/lazy-loading-ngmodules#config-routes\">라우터 설정하기</a> 부분으로 넘어가세요.\n애플리케이션은 다음 명령을 실행해서 생성합니다:</p>\n<code-example language=\"sh\">\nng new customer-app --routing\n</code-example>\n<!--\nThis creates an app called `customer-app` and the `--routing` flag\ngenerates a file called `app-routing.module.ts`, which is one of\nthe files you need for setting up lazy loading for your feature module.\nNavigate into the project by issuing the command `cd customer-app`.\n-->\n<p>이 명령을 실행하면 <code>customer-app</code> 이라는 이름으로 애플리케이션이 생성되는데, 이 때 옵션으로 <code>--routing</code> 플래그를 설정했기 때문에 <code>app-routing.module.ts</code> 파일이 함께 생성됩니다. 이 파일은 기능 모듈을 지연 로딩하도록 설정할 때 사용합니다.\n애플리케이션이 생성되고 나면 <code>cd customer-app</code> 명령을 실행해서 프로젝트 폴더로 이동합니다.</p>\n<!--\n## Create a feature module with routing\n-->\n<h2 id=\"기능-모듈-라우팅-모듈-생성하기\">기능 모듈, 라우팅 모듈 생성하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#기능-모듈-라우팅-모듈-생성하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nNext, you’ll need a feature module to route to. To make one, enter\nthe following command at the terminal window prompt where `customers` is the name of the module:\n-->\n<p>이제 라우터로 연결할 기능 모듈이 필요합니다. 터미널 창에서 다음 명령을 실행해서 <code>customers</code> 모듈을 생성합니다:</p>\n<code-example language=\"sh\">\nng generate module customers --routing\n</code-example>\n<!--\nThis creates a customers folder with two files inside; `CustomersModule`\nand `CustomersRoutingModule`. `CustomersModule` will act as the gatekeeper\nfor anything that concerns customers. `CustomersRoutingModule` will handle\nany customer-related routing. This keeps the app’s structure organized as\nthe app grows and allows you to reuse this module while easily keeping its routing intact.\n-->\n<p>이 명령을 실행하면 <code>customers</code> 폴더에 <code>CustomersModule</code>과 <code>CustomersRoutingModule</code>에 해당하는 파일이 생성됩니다. <code>CustomersModule</code>은 고객에 관련된 기능을 전담하는 용도로 사용할 것입니다.\n그리고 <code>CustomersRoutingModule</code>은 <code>CustomersModule</code> 안에서 라우팅 하는 용도로 사용합니다.\n이렇게 구성하면 이 모듈의 라우팅 설정은 애플리케이션의 라우팅 설정과 분리되기 때문에 모듈 외부의 영향을 받지 않으며, 이 모듈만 떼서 다른 애플리케이션에 재사용하기도 좋습니다.</p>\n<!--\nThe CLI imports the `CustomersRoutingModule` into the `CustomersModule` by\nadding a JavaScript import statement at the top of the file and adding\n`CustomersRoutingModule` to the `@NgModule` `imports` array.\n-->\n<p>Angular CLI로 모듈을 생성하면 <code>CustomersModule</code>의 <code>import</code> 구문에 자동으로 <code>CustomersRoutingModule</code>가 추가되고, <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 데코레이터의 <code><a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a></code> 배열에도 자동으로 추가됩니다.</p>\n<!--\n## Add a component to the feature module\n-->\n<h2 id=\"기능-모듈에-컴포넌트-추가하기\">기능 모듈에 컴포넌트 추가하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#기능-모듈에-컴포넌트-추가하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nIn order to see the module being lazy loaded in the browser, create a component to render some HTML when the app loads `CustomersModule`. At the command line, enter the following:\n-->\n<p>브라우저에서 모듈이 지연 로딩 되는 것을 확인하려면 <code>CustomersModule</code>이 로드되었을 때 화면에 표시할 컴포넌트가 필요합니다. 다음 명령을 실행해서 컴포넌트를 생성합니다:</p>\n<code-example language=\"sh\">\nng generate component customers/customer-list\n</code-example>\n<!--\nThis creates a folder inside of `customers` called `customer-list`\nwith the four files that make up the component.\n-->\n<p>이 명령을 실행하면 <code>customers</code> 폴더 안에 <code>customer-list</code> 폴더가 생성되며, 컴포넌트를 구성하는 4개 파일이 생성됩니다.</p>\n<!-- For more information\nabout components, see [Components](). -->\n<!--\nJust like with the routing module, the CLI imports the\n`CustomerListComponent` into the `CustomersModule`.\n-->\n<p>모듈을 생성할 때와 마찬가지로, Angular CLI로 컴포넌트를 생성하면 이 컴포넌트는 해당 모듈에 자동으로 추가됩니다.</p>\n<!--\n## Add another feature module\n-->\n<h2 id=\"기능-모듈-하나-더-생성하기\">기능 모듈 하나 더 생성하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#기능-모듈-하나-더-생성하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nFor another place to route to, create a second feature module with routing:\n-->\n<p>라우팅 동작을 위해 모듈을 하나 더 만듭니다:</p>\n<code-example language=\"sh\">\nng generate module orders --routing\n</code-example>\n<!--\nThis makes a new folder called `orders` containing an `OrdersModule` and an `OrdersRoutingModule`.\n-->\n<p>이 명령을 실행하면 <code>orders</code> 폴더가 생성되고, 이 폴더 안에 <code>OrdersModule</code>과 <code>OrdersRoutingModule</code>에 해당하는 모듈이 생성됩니다.</p>\n<!--\nNow, just like with the `CustomersModule`, give it some content:\n-->\n<p>그리고 <code>CustomersModule</code>과 마찬가지로, 이 모듈에도 화면에 표시할 컴포넌트를 생성합니다:</p>\n<code-example language=\"sh\">\nng generate component orders/order-list\n</code-example>\n<!--\n## Set up the UI\n-->\n<h2 id=\"화면-구성하기\">화면 구성하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#화면-구성하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThough you can type the URL into the address bar, a nav\nis easier for the user and more common. Replace the default\nplaceholder markup in `app.component.html` with a custom nav\nso you can easily navigate to your modules in the browser:\n-->\n<p>주소표시줄에 URL을 입력해도 원하는 모듈로 이동할 수 있지만, 좀 더 편하게 사용하기 위해 <code>app.component.html</code> 파일에 버튼을 추가해 봅시다. 이 파일의 내용을 다음과 같이 작성합니다:</p>\n<code-example path=\"lazy-loading-ngmodules/src/app/app.component.html\" region=\"app-component-template\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;h1>\n  {{title}}\n&#x3C;/h1>\n\n&#x3C;button <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/customers\">Customers&#x3C;/button>\n&#x3C;button <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/orders\">Orders&#x3C;/button>\n&#x3C;button <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"\">Home&#x3C;/button>\n\n&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n\n\n</code-example>\n<!--\nTo see your app in the browser so far, enter the following command in the terminal window:\n-->\n<p>그리고 애플리케이션을 브라우저에 실행하기 위해 다음 명령을 실행합니다:</p>\n<code-example language=\"sh\">\nng serve\n</code-example>\n<!--\nThen go to `localhost:4200` where you should see “app works!” and three buttons.\n-->\n<p>이제 브라우저를 실행하고 <code>localhost:4200</code>으로 이동하면 \"app works!\" 메시지와 함께 버튼이 3개 표시되는 것을 확인할 수 있습니다.</p>\n<figure>\n <img src=\"generated/images/guide/lazy-loading-ngmodules/three-buttons.png\" width=\"300\" alt=\"three buttons in the browser\">\n</figure>\n<!--\nTo make the buttons work, you need to configure the routing modules.\n-->\n<p>이제 버튼을 동작시키기 위해 라우터 모듈을 설정해 봅시다.</p>\n<a id=\"config-routes\"></a>\n<!--\n## Configure the routes\n-->\n<h2 id=\"라우터-설정하기\">라우터 설정하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#라우터-설정하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe two feature modules, `OrdersModule` and `CustomersModule`, have to be\nwired up to the `AppRoutingModule` so the router knows about them. The structure is as follows:\n-->\n<p><code>OrdersModule</code>과 <code>CustomersModule</code>을 <code>AppRoutingModule</code>를 통해 연결하려고 합니다. 이 구조를 그림으로 표현하면 다음과 같습니다:</p>\n<figure>\n <img src=\"generated/images/guide/lazy-loading-ngmodules/lazy-load-relationship.jpg\" width=\"400\" alt=\"lazy loaded modules diagram\">\n</figure>\n<!--\nEach feature module acts as a doorway via the router. In the `AppRoutingModule`, you configure the routes to the feature modules, in this case `OrdersModule` and `CustomersModule`. This way, the router knows to go to the feature module. The feature module then connects the `AppRoutingModule` to the `CustomersRoutingModule` or the `OrdersRoutingModule`. Those routing modules tell the router where to go to load relevant components.\n-->\n<p>라우터가 각 기능 모듈의 진입점까지만 연결하면 모듈 안쪽은 모듈에 있는 라우터가 처리할 것입니다. 이 문서에서 작성하는 예제로 보면, <code>AppRoutingModule</code>이 <code>OrdersModule</code>과 <code>CustomersModule</code>을 연결하면, 이 라우팅 동작은 각각 <code>CustomersRoutingModule</code>과 <code>OrdersRoutingModule</code>로 연결됩니다. 그러면 기능 모듈 안에 있는 라우터가 주소에 지정된 컴포넌트를 화면에 표시합니다.</p>\n<!--\n### Routes at the app level\n-->\n<h3 id=\"애플리케이션-계층의-라우팅\">애플리케이션 계층의 라우팅<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#애플리케이션-계층의-라우팅\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn `AppRoutingModule`, update the `routes` array with the following:\n-->\n<p><code>AppRoutingModule</code>의 <code>routes</code> 배열을 다음과 같이 수정합니다:</p>\n<code-example path=\"lazy-loading-ngmodules/src/app/app-routing.module.ts\" region=\"const-routes\" header=\"src/app/app-routing.module.ts\" linenums=\"false\">\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'customers',\n    <a href=\"api/router/Route#loadChildren\" class=\"code-anchor\">loadChildren</a>: './customers/customers.module#CustomersModule'\n  },\n  {\n    path: 'orders',\n    <a href=\"api/router/Route#loadChildren\" class=\"code-anchor\">loadChildren</a>: './orders/orders.module#OrdersModule'\n  },\n  {\n    path: '',\n    <a href=\"api/router/Route#redirectTo\" class=\"code-anchor\">redirectTo</a>: '',\n    <a href=\"api/router/Route#pathMatch\" class=\"code-anchor\">pathMatch</a>: '<a href=\"api/core/Version#full\" class=\"code-anchor\">full</a>'\n  }\n];\n\n</code-example>\n<!--\nThe import statements stay the same. The first two paths are the routes to the `CustomersModule` and the `OrdersModule` respectively. Notice that the lazy loading syntax uses `loadChildren` followed by a string that is the relative path to the module, a hash mark or `#`, and the module’s class name.\n-->\n<p>이 파일의 다른 부분은 그대로 둡니다. 라우터 설정을 지정한 것을 보면, 배열의 첫번째 항목은 <code>CustomersModule</code>로 라우팅하도록 지정했고, 두번째 항목은 <code>OrdersModule</code>로 라우팅하도록 지정했습니다. 이 떄 지연 로딩하는 모듈은 <code><a href=\"api/router/Route#loadChildren\" class=\"code-anchor\">loadChildren</a></code> 프로퍼티로 지정하며, 라우팅하려는 상대 주소에 <code>#</code> 기호와 모듈의 이름을 붙여서 지정합니다.</p>\n<!--\n### Inside the feature module\n-->\n<h2 id=\"기능-모듈의-라우팅\">기능 모듈의 라우팅<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#기능-모듈의-라우팅\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nNext, take a look at `customers.module.ts`. If you’re using the CLI and following the steps outlined in this page, you don’t have to do anything here. The feature module is like a connector between the `AppRoutingModule` and the feature routing module. The `AppRoutingModule` imports the feature module, `CustomersModule`, and `CustomersModule` in turn imports the `CustomersRoutingModule`.\n-->\n<p>다음으로 <code>customers.module.ts</code> 파일을 확인하는데, 지금까지 단계를 Angular CLI를 활용하면서 그대로 따라왔다면 추가로 수정할 내용은 없습니다. 기능 모듈 자체는 <code>AppRoutingModule</code>과 기능 모듈 안에 있는 라우팅 모듈을 연결하는 역할만 합니다. 그래서 <code>AppRoutingModule</code>이 기능 모듈인 <code>CustomersModule</code>을 로드하면, <code>CustomersModule</code>이 다시 <code>CustomerRoutingModule</code>을 로드합니다.</p>\n<code-example path=\"lazy-loading-ngmodules/src/app/customers/customers.module.ts\" region=\"customers-module\" header=\"src/app/customers/customers.module.ts\" linenums=\"false\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> } from '@angular/common';\nimport { CustomersRoutingModule } from './customers-routing.module';\nimport { CustomerListComponent } from './customer-list/customer-list.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>,\n    CustomersRoutingModule\n  ],\n  <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [CustomerListComponent]\n})\nexport class CustomersModule { }\n\n</code-example>\n<!--\nThe `customers.module.ts` file imports the `CustomersRoutingModule` and `CustomerListComponent` so the `CustomersModule` class can have access to them. `CustomersRoutingModule` is then listed in the `@NgModule` `imports` array giving `CustomersModule` access to its own routing module, and `CustomerListComponent` is in the `declarations` array, which means `CustomerListComponent` belongs to the `CustomersModule`.\n-->\n<p><code>customers.module.ts</code> 파일에 정의된 <code>CustomersModule</code>은 <code>CustomersRoutingModule</code>을 로드하기 때문에 이 라우팅 모듈에 접근할 수 있습니다. 이 라우팅 모듈을 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>의 <code><a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a></code> 프로퍼티에 등록하면 <code>CustomersModule</code>의 라우팅을 담당하는 모듈로 동작하며, <code>CustomerListComponent</code>도 <code>CustomersModule</code>에 포함되도록 <code><a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a></code> 프로퍼티에 등록했습니다.</p>\n<!--\n### Configure the feature module’s routes\n-->\n<h3 id=\"기능-모듈의-라우팅-설정하기\">기능 모듈의 라우팅 설정하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#기능-모듈의-라우팅-설정하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe next step is in `customers-routing.module.ts`. First, import the component at the top of the file with the other JavaScript import statements. Then, add the route to `CustomerListComponent`.\n-->\n<p>다음으로 볼 파일은 <code>customers-routing.module.ts</code> 파일입니다. 먼저, 파일 제일 위쪽에 라우팅과 관련된 심볼을 로드하고, 그 다음에는 라우팅에 사용할 <code>CustomerListComponent</code>를 로드합니다.</p>\n<code-example path=\"lazy-loading-ngmodules/src/app/customers/customers-routing.module.ts\" region=\"customers-routing-module\" header=\"src/app/customers/customers-routing.module.ts\" linenums=\"false\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a>, <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a> } from '@angular/router';\n\nimport { CustomerListComponent } from './customer-list/customer-list.component';\n\n\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: '',\n    component: CustomerListComponent\n  }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [RouterModule.forChild(routes)],\n  <a href=\"api/core/NgModule#exports\" class=\"code-anchor\">exports</a>: [<a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>]\n})\nexport class CustomersRoutingModule { }\n\n</code-example>\n<!--\nNotice that the `path` is set to an empty string. This is because the path in `AppRoutingModule` is already set to `customers`, so this route in the `CustomersRoutingModule`, is already within the `customers` context. Every route in this routing module is a child route.\n-->\n<p>이 때 라우팅 설정에서 <code>path</code>에는 빈 주소를 지정했습니다. 이렇게 사용한 이유는 <code>AppRoutingModule</code>에서 주소를 지정할 때 이미 <code>customers</code>로 지정했기 때문이며, 이제 <code>CustomersRoutingModule</code>이 라우팅하는 주소는 <code>customers</code> 주소가 기준점이 됩니다.</p>\n<!--\nRepeat this last step of importing the `OrdersListComponent` and configuring the Routes array for the `orders-routing.module.ts`:\n-->\n<p>이 내용은 <code>orders-routing.module.ts</code> 파일에서 <code>OrdersListComponent</code>에 대한 라우팅 설정을 할 때도 마찬가지입니다:</p>\n<code-example path=\"lazy-loading-ngmodules/src/app/orders/orders-routing.module.ts\" region=\"orders-routing-module-detail\" header=\"src/app/orders/orders-routing.module.ts (excerpt)\" linenums=\"false\">\nimport { OrderListComponent } from './order-list/order-list.component';\n\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: '',\n    component: OrderListComponent\n  }\n];\n\n</code-example>\n<!--\nNow, if you view the app in the browser, the three buttons take you to each module.\n-->\n<p>이제 브라우저에서 앱을 실행해보면 이전에 만들었던 버튼 3개가 모두 동작하는 것을 확인할 수 있습니다.</p>\n<!--\n## Confirm it’s working\n-->\n<h2 id=\"동작-확인하기\">동작 확인하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#동작-확인하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nYou can check to see that a module is indeed being lazy loaded with the Chrome developer tools. In Chrome, open the dev tools by pressing `Cmd+Option+i` on a Mac or `Ctrl+Alt+i` on a PC and go to the Network Tab.\n-->\n<p>Chrome 개발자 도구를 활용하면 모듈이 정말 지연 로딩되었는지 확인할 수 있습니다. Chrome 브라우저에서 개발자 도구를 열고 네트워크 탭으로 이동합니다.</p>\n<figure>\n <img src=\"generated/images/guide/lazy-loading-ngmodules/network-tab.png\" width=\"600\" alt=\"lazy loaded modules diagram\">\n</figure>\n<!--\nClick on the Orders or Customers button. If you see a chunk appear, you’ve wired everything up properly and the feature module is being lazy loaded. A chunk should appear for Orders and for Customers but will only appear once for each.\n-->\n<p>그리고 이제 Orders나 Customers 버튼을 클릭해 봅시다. 그러면 애플리케이션 패키지 파일과 별개의 청크(chunk) 파일로 패키징된 지연 로딩 모듈이 로드되는 것을 확인할 수 있습니다. 이 파일은 <code>OrdersModule</code>이나 <code>CustomersModule</code>에 접근할 때 한 번씩만 로드됩니다.</p>\n<figure>\n <img src=\"generated/images/guide/lazy-loading-ngmodules/chunk-arrow.png\" width=\"600\" alt=\"lazy loaded modules diagram\">\n</figure>\n<!--\nTo see it again, or to test after working in the project, clear everything out by clicking the circle with a line through it in the upper left of the Network Tab:\n-->\n<p>이 과정을 다시 확인하려면 브라우저에 애플리케이션을 다시 실행해야 합니다. 먼저, 네트워크 탭에서 Clear 버튼을 눌러서 네트워크 기록을 초기화합니다:</p>\n<figure>\n <img src=\"generated/images/guide/lazy-loading-ngmodules/clear.gif\" width=\"200\" alt=\"lazy loaded modules diagram\">\n</figure>\n<!--\nThen reload with `Cmd+r` or `Ctrl+r`, depending on your platform.\n-->\n<p>그리고 페이지를 새로고침하면 애플리케이션이 다시 실행될 것입니다.</p>\n<!--\n## `forRoot()` and `forChild()`\n-->\n<h2 id=\"forroot와-forchild\"><code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">forRoot()</a></code>와 <code><a href=\"api/router/RouterModule#forChild\" class=\"code-anchor\">forChild()</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#forroot와-forchild\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nYou might have noticed that the CLI adds `RouterModule.forRoot(routes)` to the `app-routing.module.ts` `imports` array. This lets Angular know that this module,\n`AppRoutingModule`, is a routing module and `forRoot()` specifies that this is the root\nrouting module. It configures all the\nroutes you pass to it, gives you access to the router directives, and registers the `RouterService`.\nUse `forRoot()` in the `AppRoutingModule`&mdash;that is, one time in the app at the root level.\n-->\n<p>Angular CLI로 생성한 <code>app-routing.module.ts</code> 파일을 보면, <code><a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a></code> 배열에 라우팅 모듈을 등록할 때 <code>RouterModule.forRoot(routes)</code>로 지정한 것을 확인할 수 있습니다. <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">forRoot()</a></code> 메소드를 사용하면 이 라우팅 모듈이 최상위 라우팅 모듈이라는 것을 의미합니다. 그러면 이 애플리케이션에서 라우팅할 때는 모두 이 라우팅 모듈을 거치게 될 것이며, 이 라우팅 모듈의 설정이 모든 라우팅에 적용됩니다. 그래서 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">forRoot()</a></code>는 애플리케이션의 최상위 계층에서 한 번만 사용해야 합니다.</p>\n<!--\nThe CLI also adds `RouterModule.forChild(routes)` to feature routing modules. This way, Angular\nknows that the route list is only responsible for providing additional routes and is intended for feature modules. You can use `forChild()` in multiple modules.\n-->\n<p>이와 다르게, 기능 모듈에 만든 라우팅 모듈은 <code>RouterModule.forChild(routes)</code>로 지정되어 있습니다. <code><a href=\"api/router/RouterModule#forChild\" class=\"code-anchor\">forChild()</a></code> 함수를 사용하면 이 라우팅 모듈이 최상위 모듈의 자식 라우터로 동작한다는 것을 의미하며, 동시에 어떤 기능 모듈 안에 포함된다는 것으로 판단합니다. <code><a href=\"api/router/RouterModule#forChild\" class=\"code-anchor\">forChild()</a></code> 함수는 여러번 사용해도 문제 없습니다.</p>\n<!--\n`forRoot()` contains injector configuration which is global; such as configuring the Router. `forChild()` has no injector configuration, only directives such as `RouterOutlet` and `RouterLink`.\n-->\n<p><code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">forRoot()</a></code>를 사용하면 전역에서 사용할 수 있는 인젝터가 생성되는데, 브라우저 전체에서 사용되는 Router 객체가 이 인젝터에 포함됩니다. 반면에 <code><a href=\"api/router/RouterModule#forChild\" class=\"code-anchor\">forChild()</a></code>는 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>과 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 디렉티브만 제공합니다.</p>\n<hr>\n<!--\n## More on NgModules and routing\n-->\n<h2 id=\"ngmodule과-라우팅-더-알아보기\">NgModule과 라우팅 더 알아보기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lazy-loading-ngmodules#ngmodule과-라우팅-더-알아보기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nYou may also be interested in the following:\n* [Routing and Navigation](guide/router).\n* [Providers](guide/providers).\n* [Types of Feature Modules](guide/module-types).\n-->\n<p>다음 내용에 대해서도 더 확인해 보세요:</p>\n<ul>\n<li><a href=\"guide/router\">라우팅, 네비게이션</a></li>\n<li><a href=\"guide/providers\">프로바이더</a></li>\n<li><a href=\"guide/module-types\">기능 모듈의 종류</a></li>\n</ul>\n\n</div>\n\n<!-- links to this doc:\n - guide/entry-components\n - guide/feature-modules\n - guide/hierarchical-dependency-injection\n - guide/module-types\n - guide/providers\n - guide/sharing-ngmodules\n - guide/singleton-services\n-->\n<!-- links from this doc:\n - api/common/CommonModule\n - api/core/NgModule\n - api/core/NgModule#declarations\n - api/core/NgModule#exports\n - api/core/NgModule#imports\n - api/core/Version#full\n - api/router/Route#loadChildren\n - api/router/Route#pathMatch\n - api/router/Route#redirectTo\n - api/router/RouterLink\n - api/router/RouterModule\n - api/router/RouterModule#forChild\n - api/router/RouterModule#forRoot\n - api/router/RouterOutlet\n - api/router/Routes\n - guide/feature-modules\n - guide/frequent-ngmodules\n - guide/lazy-loading-ngmodules#config-routes\n - guide/lazy-loading-ngmodules#forroot와-forchild\n - guide/lazy-loading-ngmodules#ngmodule과-라우팅-더-알아보기\n - guide/lazy-loading-ngmodules#개요\n - guide/lazy-loading-ngmodules#기능-모듈-라우팅-모듈-생성하기\n - guide/lazy-loading-ngmodules#기능-모듈-하나-더-생성하기\n - guide/lazy-loading-ngmodules#기능-모듈에-컴포넌트-추가하기\n - guide/lazy-loading-ngmodules#기능-모듈의-라우팅\n - guide/lazy-loading-ngmodules#기능-모듈의-라우팅-설정하기\n - guide/lazy-loading-ngmodules#기능모듈-지연로딩-하기\n - guide/lazy-loading-ngmodules#동작-확인하기\n - guide/lazy-loading-ngmodules#라우터-설정하기\n - guide/lazy-loading-ngmodules#사전-지식\n - guide/lazy-loading-ngmodules#애플리케이션-계층의-라우팅\n - guide/lazy-loading-ngmodules#앱-생성하기\n - guide/lazy-loading-ngmodules#화면-구성하기\n - guide/module-types\n - guide/ngmodule-vs-jsmodule\n - guide/providers\n - guide/router\n - https://github.com/angular/angular/edit/master/aio/content/guide/lazy-loading-ngmodules.md?message=docs%3A%20describe%20your%20change...\n-->"
}