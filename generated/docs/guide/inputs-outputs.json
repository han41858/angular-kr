{
  "id": "guide/inputs-outputs",
  "title": "입출력 프로퍼티 @Input(), @Output()",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/inputs-outputs.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# `@Input()` and `@Output()` properties\n-->\n<h1 id=\"입출력-프로퍼티-input-output\">입출력 프로퍼티 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>, <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/inputs-outputs#입출력-프로퍼티-input-output\"><i class=\"material-icons\">link</i></a></h1>\n<!--\n`@Input()` and `@Output()` allow Angular to share data between the parent context\nand child directives or components. An `@Input()` property is writable\nwhile an `@Output()` property is observable.\n\n<div class=\"alert is-helpful\">\n\nSee the <live-example></live-example> for a working example containing the code snippets in this guide.\n\n</div>\n\nConsider this example of a child/parent relationship:\n\n```html\n<parent-component>\n  <child-component></child-component>\n</parent-component>\n\n```\n\nHere, the `<child-component>` selector, or child directive, is embedded\nwithin a `<parent-component>`, which serves as the child's context.\n\n`@Input()` and `@Output()` act as\nthe API, or application programming interface, of the child\ncomponent in that they allow the child to\ncommunicate with the parent. Think of `@Input()` and `@Output()` like ports\nor doorways&mdash;`@Input()` is the doorway into the component allowing data\nto flow in while `@Output()` is the doorway out of the component, allowing the\nchild component to send data out.\n-->\n<p><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>과 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code>을 활용하면 디렉티브나 컴포넌트가 부모 컨텍스트와 데이터를 주고받을 수 있습니다.\n이 때 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>는 직접 값을 지정할 수 있는 타입의 프로퍼티에 선언하며, <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 프로퍼티는 옵저버블에 선언합니다.</p>\n<div class=\"alert is-helpful\">\n<p>이 문서에서 다루는 예제는 <live-example></live-example>에서 직접 확인하거나 다운받아 확인할 수 있습니다.</p>\n</div>\n<p>부모/자식 관계가 이렇게 구성되어 있다고 합시다:</p>\n<code-example language=\"html\">\n&#x3C;parent-component>\n  &#x3C;child-component>&#x3C;/child-component>\n&#x3C;/parent-component>\n</code-example>\n<p>이 예제 코드에서 <code>&#x3C;child-component></code>는 <code>&#x3C;parent-component></code> 안에 들어가 있기 때문에 자식 컴포넌트의 컨텍스트를 따로 구성한다고 볼 수 있습니다.</p>\n<p>이 때 자식 컴포넌트 프로퍼티에 선언하는 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>과 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code>은 자식 컴포넌트의 API(application programming interface)처럼 동작한다고 볼 수 있습니다.\n<code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>은 자식 컴포넌트로 데이터가 들어오는 통로이며, <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code>은 자식 컴포넌트 밖으로 데이터가 나가는 통로라고 이해해도 됩니다.</p>\n<!--\n<div class=\"alert is-helpful\">\n\n#### `@Input()` and `@Output()` are independent\n\nThough `@Input()` and `@Output()` often appear together in apps, you can use\nthem separately. If the nested\ncomponent is such that it only needs to send data to its parent, you wouldn't\nneed an `@Input()`, only an `@Output()`. The reverse is also true in that if the\nchild only needs to receive data from the parent, you'd only need `@Input()`.\n\n</div>\n-->\n<div class=\"alert is-helpful\">\n<h4 id=\"input과-output는-독립적으로-동작합니다\"><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>과 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code>는 독립적으로 동작합니다.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/inputs-outputs#input과-output는-독립적으로-동작합니다\"><i class=\"material-icons\">link</i></a></h4>\n<p><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>과 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code>이 컴포넌트 클래스에 함께 사용되는 경우도 종종 있지만, 두 데코레이터는 온전히 별개입니다.\n자식 컴포넌트로 데이터가 이동하지 않는다면 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>이 필요없으며, 자식 컴포넌트가 데이터를 받기만 하고 부모 컴포넌트로 보내지 않는다면 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 없이 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>만 있으면 됩니다.</p>\n</div>\n<a id=\"input\"></a>\n<!--\n## How to use `@Input()`\n-->\n<h2 id=\"input-사용방법\"><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 사용방법<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/inputs-outputs#input-사용방법\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nUse the `@Input()` decorator in a child component or directive to let Angular know\nthat a property in that component can receive its value from its parent component.\nIt helps to remember that the data flow is from the perspective of the\nchild component. So an `@Input()` allows data to be input _into_ the\nchild component from the parent component.\n\n\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/inputs-outputs/input.svg\" alt=\"Input data flow diagram\">\n</div>\n\nTo illustrate the use of `@Input()`, edit these parts of your app:\n\n* The child component class and template\n* The parent component class and template\n-->\n<p>자식 디렉티브/컴포넌트 프로퍼티에 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>을 지정하면 해당 프로퍼티 값을 부모 컴포넌트에서 받을 수 있습니다.\n이 때 데이터가 이동하는 방향은 부모 컴포넌트에서 자식 컴포넌트로 향하는 방향입니다.\n간단하게 이야기하면 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터는 부모 컴포넌트에서 자식 컴포넌트로 이동하는 데이터 통로를 여는 역할을 합니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/inputs-outputs/input.svg\" alt=\"Input data flow diagram\" width=\"671\" height=\"346\">\n</div>\n<p><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>이 동작하는 것을 확인하기 위해 다음 코드를 수정해 봅시다:</p>\n<ul>\n<li>자식 컴포넌트 클래스와 템플릿</li>\n<li>부모 컴포넌트 클래스와 템플릿</li>\n</ul>\n<!--\n### In the child\n-->\n<h3 id=\"자식-컴포넌트에서\">자식 컴포넌트에서<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/inputs-outputs#자식-컴포넌트에서\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nTo use the `@Input()` decorator in a child component class, first import\n`Input` and then decorate the property with `@Input()`:\n\n<code-example path=\"inputs-outputs/src/app/item-detail/item-detail.component.ts\" region=\"use-input\" header=\"src/app/item-detail/item-detail.component.ts\">\nimport { Component, Input } from &#39;@angular/core&#39;; // Input 심볼을 로드합니다.\nexport class ItemDetailComponent {\n  @Input() item: string; // 프로퍼티에 @Input() 데코레이터를 지정합니다.\n}\n\n</code-example>\n\n\nIn this case, `@Input()` decorates the property <code class=\"no-auto-link\">item</code>, which has\na type of `string`, however, `@Input()` properties can have any type, such as\n`number`, `string`, `boolean`, or `object`. The value for `item` will come from the parent component, which the next section covers.\n\nNext, in the child component template, add the following:\n\n<code-example path=\"inputs-outputs/src/app/item-detail/item-detail.component.html\" region=\"property-in-template\" header=\"src/app/item-detail/item-detail.component.html\">\n&lt;p&gt;\n  Today&#39;s item: {{item}}\n&lt;/p&gt;\n\n</code-example>\n-->\n<p>자식 컴포넌트 클래스에 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터를 사용하려면 먼저 <code><a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 심볼을 로드해서 프로퍼티에 지정해야 합니다:</p>\n<code-example path=\"inputs-outputs/src/app/item-detail/item-detail.component.ts\" region=\"use-input\" header=\"src/app/item-detail/item-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a> } from '@angular/core'; // <a href=\"api/core/Input\" class=\"code-anchor\">Input</a> 심볼을 로드합니다.\nexport class ItemDetailComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() item: string; // 프로퍼티에 @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() 데코레이터를 지정합니다.\n}\n\n</code-example>\n<p>이렇게 작성하면 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터는 <code>string</code> 타입으로 선언된 <code class=\"no-auto-link\">item</code> 프로퍼티를 입력 프로퍼티로 지정합니다.\n이 때 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터는 <code><a href=\"api/common/DecimalPipe\" class=\"code-anchor\">number</a></code>, <code>string</code>, <code>boolean</code>, <code>object</code> 등 다양한 타입의 프로퍼티에 지정할 수 있습니다.\n이제 <code>item</code> 프로퍼티의 값은 부모 컴포넌트에서 전달됩니다.\n이 내용은 다음 섹션에서 확인해 봅시다.</p>\n<p>자식 컴포넌트 템플릿에는 이런 코드를 추가합니다:</p>\n<code-example path=\"inputs-outputs/src/app/item-detail/item-detail.component.html\" region=\"property-in-template\" header=\"src/app/item-detail/item-detail.component.html\">\n&#x3C;p>\n  Today's item: {{item}}\n&#x3C;/p>\n\n</code-example>\n<!--\n### In the parent\n-->\n<h3 id=\"부모-컴포넌트에서\">부모 컴포넌트에서<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/inputs-outputs#부모-컴포넌트에서\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe next step is to bind the property in the parent component's template.\nIn this example, the parent component template is `app.component.html`.\n\nFirst, use the child's selector, here `<app-item-detail>`, as a directive within the\nparent component template. Then, use [property binding](guide/property-binding)\nto bind the property in the child to the property of the parent.\n\n<code-example path=\"inputs-outputs/src/app/app.component.html\" region=\"input-parent\" header=\"src/app/app.component.html\">\n&lt;app-item-detail [item]=&quot;currentItem&quot;&gt;&lt;/app-item-detail&gt;\n\n</code-example>\n\nNext, in the parent component class, `app.component.ts`, designate a value for `currentItem`:\n\n<code-example path=\"inputs-outputs/src/app/app.component.ts\" region=\"parent-property\" header=\"src/app/app.component.ts\">\nexport class AppComponent {\n  currentItem = &#39;Television&#39;;\n}\n\n</code-example>\n\nWith `@Input()`, Angular passes the value for `currentItem` to the child so that `item` renders as `Television`.\n\nThe following diagram shows this structure:\n\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/inputs-outputs/input-diagram-target-source.svg\" alt=\"Property binding diagram\">\n</div>\n\nThe target in the square brackets, `[]`, is the property you decorate\nwith `@Input()` in the child component. The binding source, the part\nto the right of the equal sign, is the data that the parent\ncomponent passes to the nested component.\n\nThe key takeaway is that when binding to a child component's property in a parent component&mdash;that is, what's\nin square brackets&mdash;you must\ndecorate the property with `@Input()` in the child component.\n-->\n<p>이제 프로퍼티를 바인딩하기 위해 부모 컴포넌트 템플릿을 수정합시다.\n이 문서에서 다루는 예제에서 부모 컴포넌트 템플릿은 <code>app.component.html</code> 입니다.</p>\n<p>먼저, 자식 컴포넌트 셀렉터 <code>&#x3C;app-item-detail></code>를 부모 컴포넌트 템플릿에 추가하고, 자식 컴포넌트의 프로퍼티를 자식 컴포넌트에 <a href=\"guide/property-binding\">프로퍼티 바인딩</a>으로 연결합니다.</p>\n<code-example path=\"inputs-outputs/src/app/app.component.html\" region=\"input-parent\" header=\"src/app/app.component.html\">\n&#x3C;app-item-detail [item]=\"currentItem\">&#x3C;/app-item-detail>\n\n</code-example>\n<p>그리고 부모 컴포넌트 클래스 <code>app.component.ts</code> 파일에 <code>currentItem</code> 프로퍼티를 선언합니다:</p>\n<code-example path=\"inputs-outputs/src/app/app.component.ts\" region=\"parent-property\" header=\"src/app/app.component.ts\">\nexport class AppComponent {\n  currentItem = 'Television';\n}\n\n</code-example>\n<p><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터를 사용하면 부모 컴포넌트에 있는 <code>currentItem</code> 프로퍼티 값이 자식 컴포넌트 <code>item</code> 프로퍼티로 전달되기 때문에, <code>item</code> 프로퍼티의 값은 <code>Television</code>이 됩니다.</p>\n<p>아래 그림을 보면서 이 데코레이터가 어떻게 연결되는지 확인해 보세요:</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/inputs-outputs/input-diagram-target-source.svg\" alt=\"Property binding diagram\" width=\"502\" height=\"304\">\n</div>\n<p>바인딩 대상은 대괄호(<code>[]</code>) 안에 있는 프로퍼티이며, 이 프로퍼티는 자식 컴포넌트에서 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>이 지정된 프로퍼티입니다.\n그리고 바인딩되어 값이 전달되는 소스는 등호(<code>=</code>) 오른쪽에 지정하며, 이 예제에서는 부모 컴포넌트에 있는 <code>currentItem</code> 프로퍼티입니다.</p>\n<p>이 문법에서 중요한 것은 부모 컴포넌트에 있는 프로퍼티를 자식 컴포넌트 프로퍼티로 바인딩한다는 것입니다.\n그래서 자식 컴포넌트에서 값을 받는 프로퍼티에는 반드시 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터가 지정되어 있어야 합니다.</p>\n<!--\n<div class=\"alert is-helpful\">\n\n### `OnChanges` and `@Input()`\n\nTo watch for changes on an `@Input()` property, use\n`OnChanges`, one of Angular's [lifecycle hooks](guide/lifecycle-hooks#onchanges).\n`OnChanges` is specifically designed to work with properties that have the\n`@Input()` decorator. See the [`OnChanges`](guide/lifecycle-hooks#onchanges) section of the [Lifecycle Hooks](guide/lifecycle-hooks) guide for more details and examples.\n\n</div>\n-->\n<div class=\"alert is-helpful\">\n<h3 id=\"onchanges와-input\"><code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a></code>와 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/inputs-outputs#onchanges와-input\"><i class=\"material-icons\">link</i></a></h3>\n<p><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터가 지정된 프로퍼티 값이 변경되는 것을 감지하려면 Angular <a href=\"guide/lifecycle-hooks#onchanges\">라이프싸이클 후킹 메서드</a> <code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a></code>를 활용하면 됩니다.\n특히 <code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a></code> 라이프싸이클 후킹 메서드는 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터가 지정된 프로퍼티에 적합하게 설계되었습니다.\n자세한 내용은 <a href=\"guide/lifecycle-hooks\">라이프싸이클 후킹 메서드</a> 문서의 <a href=\"guide/lifecycle-hooks#onchanges\"><code>OnChanges</code></a> 섹션을 참고하세요.</p>\n</div>\n<a id=\"output\"></a>\n<a id=\"how-to-use-output\"></a>\n<!--\n## How to use `@Output()`\n-->\n<h2 id=\"output-사용방법\"><code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 사용방법<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/inputs-outputs#output-사용방법\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nUse the `@Output()` decorator in the child component or directive to allow data to flow from\nthe child _out_ to the parent.\n\nAn `@Output()` property should normally be initialized to an Angular [`EventEmitter`](api/core/EventEmitter) with values flowing out of the component as [events](guide/event-binding).\n\n\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/inputs-outputs/output.svg\" alt=\"Output diagram\">\n</div>\n\nJust like with `@Input()`, you can use `@Output()`\non a property of the child component but its type should be\n`EventEmitter`.\n\n`@Output()` marks a property in a child component as a doorway\nthrough which data can travel from the child to the parent.\nThe child component then has to raise an event so the\nparent knows something has changed. To raise an event,\n`@Output()` works hand in hand with `EventEmitter`,\nwhich is a class in `@angular/core` that you\nuse to emit custom events.\n\nWhen you use `@Output()`, edit these parts of your app:\n\n* The child component class and template\n* The parent component class and template\n\n\nThe following example shows how to set up an `@Output()` in a child\ncomponent that pushes data you enter in an HTML `<input>` to an array in the\nparent component.\n\n<div class=\"alert is-helpful\">\n\nThe HTML element `<input>` and the Angular decorator `@Input()`\nare different. This documentation is about component communication in Angular as it pertains to `@Input()` and `@Output()`. For more information on the HTML element `<input>`, see the [W3C Recommendation](https://www.w3.org/TR/html5/sec-forms.html#the-input-element).\n\n</div>\n-->\n<p>자식 컴포넌트 프로퍼티나 자식 디렉티브 프로퍼티에 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터를 지정하면 자식 컴포넌트에서 부모 컴포넌트로 데이터를 전달할 수 있습니다.</p>\n<p><code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 프로퍼티는 Angular <a href=\"api/core/EventEmitter\"><code>EventEmitter</code></a> 클래스 타입에 지정합니다.\n이 클래스는 Angular 애플리케이션에서 <a href=\"guide/event-binding\">이벤트</a>를 표현하는 클래스이며 <code>@angular/core</code> 패키지에 정의되어 있습니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/inputs-outputs/output.svg\" alt=\"Output diagram\" width=\"666\" height=\"340\">\n</div>\n<p><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>과 마찬가지로, <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터도 자식 컴포넌트 프로퍼티에 지정하는데, 이 프로퍼티는 반드시 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 타입이어야 합니다.</p>\n<p><code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터는 자식 컴포넌트에서 부모 컴포넌트로 데이터를 전달하는 프로퍼티를 선언하는 역할을 한다고도 볼 수 있습니다.\n부모 컴포넌트가 자식 컴포넌트에서 일어나는 일을 알려면 자식 컴포넌트에서 이벤트를 발생시켜야 합니다.\n그리고 자식 컴포넌트에서 이벤트를 발생시키려면 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터가 지정된 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 객체를 활용하면 됩니다.</p>\n<p><code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code>이 동작하는 것을 확인하기 위해 다음 코드를 수정해 봅시다:</p>\n<ul>\n<li>자식 컴포넌트 클래스와 템플릿</li>\n<li>부모 컴포넌트 클래스와 템플릿</li>\n</ul>\n<p>이제부터 살펴볼 예제는 자식 컴포넌트에 있는 HTML <code>&#x3C;input></code>에 입력된 문자열을 부모 컴포넌트로 보내 부모 컴포넌트 배열에 추가하는 예제입니다.</p>\n<div class=\"alert is-helpful\">\n<p>HTML 엘리먼트 <code>&#x3C;input></code>과 Angular 데코레이터 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>은 엄연히 다릅니다.\n이 문서는 Angular에서 자식 컴포넌트와 부모 컴포넌트가 데이터를 주고 받을 때 사용하는 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>, <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터에 대해 다룹니다.\nHTML <code>&#x3C;input></code> 엘리먼트에 대해 자세하게 알아보려면 <a href=\"https://www.w3.org/TR/html5/sec-forms.html#the-input-element\">W3C 권장안</a>을 확인하세요.</p>\n</div>\n<!--\n## In the child\n-->\n<h3 id=\"자식-컴포넌트에서-1\">자식 컴포넌트에서<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/inputs-outputs#자식-컴포넌트에서-1\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThis example features an `<input>` where a user can enter a value and click a `<button>` that raises an event. The `EventEmitter` then relays the data to the parent component.\n\nFirst, be sure to import `Output` and `EventEmitter`\nin the child component class:\n\n```js\nimport { Output, EventEmitter } from '@angular/core';\n\n```\n\nNext, still in the child, decorate a property with `@Output()` in the component class.\nThe following example `@Output()` is called `newItemEvent` and its type is\n`EventEmitter`, which means it's an event.\n\n\n<code-example path=\"inputs-outputs/src/app/item-output/item-output.component.ts\" region=\"item-output\" header=\"src/app/item-output/item-output.component.ts\">\n\n@Output() newItemEvent = new EventEmitter&lt;string&gt;();\n\n\n</code-example>\n\nThe different parts of the above declaration are as follows:\n\n* `@Output()`&mdash;a decorator function marking the property as a way for data to go from the child to the parent\n* `newItemEvent`&mdash;the name of the `@Output()`\n* `EventEmitter<string>`&mdash;the `@Output()`'s type\n* `new EventEmitter<string>()`&mdash;tells Angular to create a new event emitter and that the data it emits is of type string. The type could be any type, such as `number`, `boolean`, and so on. For more information on `EventEmitter`, see the [EventEmitter API documentation](api/core/EventEmitter).\n\nNext, create an `addNewItem()` method in the same component class:\n\n<code-example path=\"inputs-outputs/src/app/item-output/item-output.component.ts\" region=\"item-output-class\" header=\"src/app/item-output/item-output.component.ts\">\nexport class ItemOutputComponent {\n\n  @Output() newItemEvent = new EventEmitter&lt;string&gt;();\n\n  addNewItem(value: string) {\n    this.newItemEvent.emit(value);\n  }\n}\n\n</code-example>\n\nThe `addNewItem()` function uses the `@Output()`, `newItemEvent`,\nto raise an event in which it emits the value the user\ntypes into the `<input>`. In other words, when\nthe user clicks the add button in the UI, the child lets the parent know\nabout the event and gives that data to the parent.\n-->\n<p>예제 앱에서 사용자가 <code>&#x3C;input></code>에 값을 입력하고 <code>&#x3C;button></code>을 클릭하면 이벤트가 발생합니다.\n데이터는 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code>에 실어서 부모 컴포넌트로 전달해 봅시다.</p>\n<p>먼저, 자식 컴포넌트 클래스 파일에서 <code><a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code> 심볼과 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 심볼을 로드합니다:</p>\n<code-example language=\"js\">\nimport { <a href=\"api/core/Output\" class=\"code-anchor\">Output</a>, <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a> } from '@angular/core';\n</code-example>\n<p>그리고 자식 컴포넌트 클래스 프로퍼티에 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터를 지정합니다.\n이 예제에서는 <code>newItemEvent</code>에 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터를 붙이는데, 이 프로퍼티는 이벤트를 표현하기 위해 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 타입이어야 합니다.</p>\n<code-example path=\"inputs-outputs/src/app/item-output/item-output.component.ts\" region=\"item-output\" header=\"src/app/item-output/item-output.component.ts\">\n\n@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() newItemEvent = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;string>();\n\n\n</code-example>\n<p>위에서 작성했던 예제와는 이런 부분이 다릅니다:</p>\n<ul>\n<li><code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> — 자식 컴포넌트에서 부모 컴포넌트로 데이터를 전달하는 프로퍼티를 지정하는 데코레이터입니다.</li>\n<li><code>newItemEvent</code> — <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터의 이름입니다.</li>\n<li><code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;string></code> — <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터가 지정된 프로퍼티의 타입입니다.</li>\n<li><code>new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;string>()</code> — <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 인스턴스를 새로 생성하면서 이 인스턴스로 전달되는 데이터 타입이 문자열이라는 것을 의미합니다. 부모 컴포넌트로 전달하는 데이터 타입은 <code>string</code> 뿐 아니라 <code><a href=\"api/common/DecimalPipe\" class=\"code-anchor\">number</a></code>나 <code>boolean</code> 타입도 사용할 수 있습니다. <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code>에 대해 자세하게 알아보려면 <a href=\"api/core/EventEmitter\">EventEmitter API 문서</a>를 참고하세요.</li>\n</ul>\n<p>그리고 자식 컴포넌트 클래스에 <code>addNewItem()</code> 메서드를 추가합니다:</p>\n<code-example path=\"inputs-outputs/src/app/item-output/item-output.component.ts\" region=\"item-output-class\" header=\"src/app/item-output/item-output.component.ts\">\nexport class ItemOutputComponent {\n\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() newItemEvent = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;string>();\n\n  addNewItem(value: string) {\n    this.newItemEvent.emit(value);\n  }\n}\n\n</code-example>\n<p><code>addNewItem()</code> 함수는 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터가 지정된 <code>newItemEvent</code> 프로퍼티를 활용해서 이벤트를 발생시키는데, 이 때 사용자가 <code>&#x3C;input></code> 엘리먼트에 입력한 문자열을 데이터로 함께 전달합니다.\n다르게 설명하면, 사용자가 화면에 있는 추가 버튼을 누르면 부모 컴포넌트가 알 수 있도록 자식 컴포넌트가 이벤트를 발생시키며, 이 때 데이터를 이벤트 객체에 담아 전달합니다.</p>\n<!--\n### In the child's template\n-->\n<h4 id=\"자식-컴포넌트-템플릿에서\">자식 컴포넌트 템플릿에서<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/inputs-outputs#자식-컴포넌트-템플릿에서\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe child's template has two controls. The first is an HTML `<input>` with a\n[template reference variable](guide/template-reference-variables) , `#newItem`,\nwhere the user types in an item name. Whatever the user types\ninto the `<input>` gets stored in the `#newItem` variable.\n\n<code-example path=\"inputs-outputs/src/app/item-output/item-output.component.html\" region=\"child-output\" header=\"src/app/item-output/item-output.component.html\">\n&lt;label&gt;Add an item: &lt;input #newItem&gt;&lt;/label&gt;\n&lt;button (click)=&quot;addNewItem(newItem.value)&quot;&gt;Add to parent&#39;s list&lt;/button&gt;\n\n</code-example>\n\nThe second element is a `<button>`\nwith an [event binding](guide/event-binding). You know it's\nan event binding because the part to the left of the equal\nsign is in parentheses, `(click)`.\n\nThe `(click)` event is bound to the `addNewItem()` method in the child component class which\ntakes as its argument whatever the value of `#newItem` is.\n\nNow the child component has an `@Output()`\nfor sending data to the parent and a method for raising an event.\nThe next step is in the parent.\n-->\n<p>자식 컴포넌트에는 폼 컨트롤이 2개 있습니다.\n첫번째는 <a href=\"guide/template-reference-variables\">템플릿 참조 변수(template reference variable)</a> <code>#newItem</code>이 지정된 HTML <code>&#x3C;input></code> 엘리먼트이며, 사용자는 이 엘리먼트에 새 아이템 이름을 입력합니다.\n사용자가 <code>&#x3C;input></code> 엘리먼트에 입력한 값은 <code>#newItem</code> 변수의 <code>value</code> 프로퍼티로 참조할 수 있습니다.</p>\n<code-example path=\"inputs-outputs/src/app/item-output/item-output.component.html\" region=\"child-output\" header=\"src/app/item-output/item-output.component.html\">\n&#x3C;label>Add an item: &#x3C;input #newItem>&#x3C;/label>\n&#x3C;button (click)=\"addNewItem(newItem.value)\">Add to parent's list&#x3C;/button>\n\n</code-example>\n<p>두번째 엘리먼트는 <a href=\"guide/event-binding\">이벤트 바인딩</a>으로 연결된 <code>&#x3C;button></code> 엘리먼트입니다.\n이 엘리먼트에는 <code>(click)</code> 이라는 문법이 사용되었기 때문에 이벤트 바인딩이 사용되었다는 것을 쉽게 알 수 있습니다.</p>\n<p><code>(click)</code> 이벤트는 자식 컴포넌트 클래스에 있는 <code>addNewItem()</code> 메서드와 바인딩되어 있는데, 이 메서드를 실행할 때 <code>#newItem.value</code> 프로퍼티를 참조해서 <code>&#x3C;input></code> 엘리먼트에 입력된 값을 인자로 전달합니다.</p>\n<p>지금까지 자식 컴포넌트에 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터를 적용해 봤습니다.\n이제 부모 컴포넌트를 수정해 봅시다.</p>\n<!--\n## In the parent\n-->\n<h3 id=\"부모-컴포넌트에서-1\">부모 컴포넌트에서<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/inputs-outputs#부모-컴포넌트에서-1\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn this example, the parent component is `AppComponent`, but you could use\nany component in which you could nest the child.\n\nThe `AppComponent` in this example features a list of `items`\nin an array and a method for adding more items to the array.\n\n<code-example path=\"inputs-outputs/src/app/app.component.ts\" region=\"add-new-item\" header=\"src/app/app.component.ts\">\nexport class AppComponent {\n  items = [&#39;item1&#39;, &#39;item2&#39;, &#39;item3&#39;, &#39;item4&#39;];\n\n  addItem(newItem: string) {\n    this.items.push(newItem);\n  }\n}\n\n</code-example>\n\nThe `addItem()` method takes an argument in the form of a string\nand then pushes, or adds, that string to the `items` array.\n-->\n<p>이 예제에서 부모 컴포넌트는 <code>AppComponent</code>지만, 자식 컴포넌트가 존재한다면 어떤 컴포넌트라도 부모 컴포넌트가 될 수 있습니다.</p>\n<p><code>AppComponent</code>에는 아이템을 배열 형태로 관리하기 위해 <code>items</code> 프로퍼티가 선언되어 있습니다.</p>\n<code-example path=\"inputs-outputs/src/app/app.component.ts\" region=\"add-new-item\" header=\"src/app/app.component.ts\">\nexport class AppComponent {\n  items = ['item1', 'item2', 'item3', 'item4'];\n\n  addItem(newItem: string) {\n    this.items.push(newItem);\n  }\n}\n\n</code-example>\n<p>그리고 <code>addItem()</code> 메서드는 문자열 타입 인자를 받아서 <code>items</code> 배열에 추가합니다.</p>\n<!--\n### In the parent's template\n-->\n<h4 id=\"부모-컴포넌트-템플릿에서\">부모 컴포넌트 템플릿에서<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/inputs-outputs#부모-컴포넌트-템플릿에서\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nNext, in the parent's template, bind the parent's\nmethod to the child's event. Put the child selector, here `<app-item-output>`,\nwithin the parent component's\ntemplate, `app.component.html`.\n\n<code-example path=\"inputs-outputs/src/app/app.component.html\" region=\"output-parent\" header=\"src/app/app.component.html\">\n&lt;app-item-output (newItemEvent)=&quot;addItem($event)&quot;&gt;&lt;/app-item-output&gt;\n\n</code-example>\n\nThe event binding, `(newItemEvent)='addItem($event)'`, tells\nAngular to connect the event in the child, `newItemEvent`, to\nthe method in the parent, `addItem()`, and that the event that the child\nis notifying the parent about is to be the argument of `addItem()`.\nIn other words, this is where the actual hand off of data takes place.\nThe `$event` contains the data that the user types into the `<input>`\nin the child template UI.\n\nNow, in order to see the `@Output()` working, add the following to the parent's template:\n\n```html\n  <ul>\n    <li *ngFor=\"let item of items\">{{item}}</li>\n  </ul>\n  ```\n\nThe `*ngFor` iterates over the items in the `items` array. When you enter a value in the child's `<input>` and click the button, the child emits the event and the parent's `addItem()` method pushes the value to the `items` array and it renders in the list.\n-->\n<p>이제 자식 컴포넌트에서 발생하는 이벤트를 부모 컴포넌트 메서드와 바인딩하기 위해 부모 컴포넌트 템플릿을 수정해 봅시다.\n부모 컴포넌트 템플릿 파일 <code>app.component.html</code>에 자식 컴포넌트 셀렉터 <code>&#x3C;app-item-output></code>을 추가합니다.</p>\n<code-example path=\"inputs-outputs/src/app/app.component.html\" region=\"output-parent\" header=\"src/app/app.component.html\">\n&#x3C;app-item-output (newItemEvent)=\"addItem($event)\">&#x3C;/app-item-output>\n\n</code-example>\n<p>이벤트 바인딩 문법을 <code>(newItemEvent)='addItem($event)'</code>라고 작성하면 자식 컴포넌트에서 <code>newItemEvent</code> 이벤트가 발생했을 때 부모 컴포넌트 메서드 <code>addItem()</code>가 실행되면서 문자열 타입의 데이터가 함께 전달됩니다.\n딱 이 시점이 데이터가 실제로 전달되는 순간입니다.\n<code>$event</code> 객체에는 사용자가 자식 컴포넌트 템플릿에 있는 <code>&#x3C;input></code> 엘리먼트에 입력한 값이 전달됩니다.</p>\n<p>이제 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code>이 동작하는 것을 확인하기 위해 부모 컴포넌트 템플릿에 다음 코드를 추가합니다:</p>\n<code-example language=\"html\">\n  &#x3C;ul>\n    &#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let item of items\">{{item}}&#x3C;/li>\n  &#x3C;/ul>\n</code-example>\n<p><code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>는 <code>items</code> 배열을 순회하는 이터레이터입니다.\n이제 자식 컴포넌트에 있는 <code>&#x3C;input></code> 엘리먼트에 값을 입력하고 버튼을 클릭하면, 자식 컴포넌트에서 이벤트가 발생하면서 부모 컴포넌트에 있는 <code>addItem()</code> 메서드를 실행하고, 이 메서드에 작성된 로직에 따라 인자로 받은 문자열을 <code>items</code> 배열에 추가하면서 화면에 표시됩니다.</p>\n<!--\n## `@Input()` and `@Output()` together\n-->\n<h2 id=\"input-output-함께-사용하기\"><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>, <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 함께 사용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/inputs-outputs#input-output-함께-사용하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nYou can use `@Input()` and `@Output()` on the same child component as in the following:\n\n<code-example path=\"inputs-outputs/src/app/app.component.html\" region=\"together\" header=\"src/app/app.component.html\">\n&lt;app-input-output [item]=&quot;currentItem&quot; (deleteRequest)=&quot;crossOffItem($event)&quot;&gt;&lt;/app-input-output&gt;\n\n</code-example>\n\nThe target, `item`, which is an `@Input()` property in the child component class, receives its value from the parent's property, `currentItem`. When you click delete, the child component raises an event, `deleteRequest`, which is the argument for the parent's `crossOffItem()` method.\n\nThe following diagram is of an `@Input()` and an `@Output()` on the same\nchild component and shows the different parts of each:\n\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/inputs-outputs/input-output-diagram.svg\" alt=\"Input/Output diagram\">\n</div>\n\nAs the diagram shows, use inputs and outputs together in the same manner as using them separately. Here, the child selector is `<app-input-output>` with `item` and `deleteRequest` being `@Input()` and `@Output()`\nproperties in the child component class. The property `currentItem` and the method `crossOffItem()` are both in the parent component class.\n\nTo combine property and event bindings using the banana-in-a-box\nsyntax, `[()]`, see [Two-way Binding](guide/two-way-binding).\n-->\n<p><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터와 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터는 다음과 같이 함께 사용할 수도 있습니다:</p>\n<code-example path=\"inputs-outputs/src/app/app.component.html\" region=\"together\" header=\"src/app/app.component.html\">\n&#x3C;app-input-output [item]=\"currentItem\" (deleteRequest)=\"crossOffItem($event)\">&#x3C;/app-input-output>\n\n</code-example>\n<p><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터가 지정되는 대상은 자식 컴포넌트 클래스에 있는 <code>item</code> 프로퍼티이며, 이 프로퍼티는 부모 컴포넌트의 <code>currentItem</code> 프로퍼티에서 값을 받아옵니다.\n그리고 사용자가 삭제 버튼을 클릭하면 자식 컴포넌트에서 <code>deleteRequest</code> 이벤트가 발생하는데, 이 프로퍼티에는 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터가 지정되어 있기 때문에 부모 컴포넌트의 <code>crossOffItem()</code> 메서드를 실행합니다.</p>\n<p>아래 그림을 보면서 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>과 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code>이 각각 어떻게 연결되는지 확인해 보세요:</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/inputs-outputs/input-output-diagram.svg\" alt=\"Input/Output diagram\" width=\"800\" height=\"333\">\n</div>\n<p>다이어그램에서 확인할 수 있듯이 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>과 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code>을 함께 사용하더라도 각각 사용했을 때와 똑같이 사용하면 됩니다.\n이 예제에서 자식 컴포넌트 셀렉터는 <code>&#x3C;app-input-output></code> 이며, 이 태그의 <code>item</code>과 <code>deleteRequest</code>는 각각 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>과 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code>이 지정된 프로퍼티입니다.\n이 프로퍼티들은 각각 부모 컴포넌트 클래스의 <code>currentItem</code> 프로퍼티와 <code>crossOffItem()</code> 메서드와 바인딩되었습니다.</p>\n<p>프로퍼티 바인딩과 이벤트 바인딩을 동시에 하려면 상자 안에 있는 바나나 문법, <code>[()]</code>를 사용하면 됩니다.\n자세한 내용은 <a href=\"guide/two-way-binding\">양방향 바인딩(Two-way Binding)</a> 문서를 참고하세요.</p>\n<!--\n## `@Input()` and `@Output()` declarations\n-->\n<h2 id=\"메타데이터에서-input-output-선언하기\">메타데이터에서 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>, <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 선언하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/inputs-outputs#메타데이터에서-input-output-선언하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nInstead of using the `@Input()` and `@Output()` decorators\nto declare inputs and outputs, you can identify\nmembers in the `inputs` and `outputs` arrays\nof the directive metadata, as in this example:\n\n<code-example path=\"inputs-outputs/src/app/in-the-metadata/in-the-metadata.component.ts\" region=\"metadata\" header=\"src/app/in-the-metadata/in-the-metadata.component.ts\">\n// tslint:disable: no-inputs-metadata-property no-outputs-metadata-property\ninputs: [&#39;clearanceItem&#39;],\noutputs: [&#39;buyEvent&#39;]\n// tslint:enable: no-inputs-metadata-property no-outputs-metadata-property\n\n</code-example>\n\nWhile declaring `inputs` and `outputs` in the `@Directive` and `@Component`\nmetadata is possible, it is a better practice to use the `@Input()` and `@Output()`\nclass decorators instead, as follows:\n\n<code-example path=\"inputs-outputs/src/app/input-output/input-output.component.ts\" region=\"input-output\" header=\"src/app/input-output/input-output.component.ts\">\n@Input() item: string;\n@Output() deleteRequest = new EventEmitter&lt;string&gt;();\n\n</code-example>\n\nSee the [Decorate input and output properties](guide/styleguide#decorate-input-and-output-properties) section of the\n[Style Guide](guide/styleguide) for details.\n\n\n\n<div class=\"alert is-helpful\">\n\nIf you get a template parse error when trying to use inputs or outputs, but you know that the\nproperties do indeed exist, double check\nthat your properties are annotated with `@Input()` / `@Output()` or that you've declared\nthem in an `inputs`/`outputs` array:\n\n<code-example language=\"bash\">\nUncaught Error: Template parse errors:\nCan't bind to 'item' since it isn't a known property of 'app-item-detail'\n</code-example>\n\n</div>\n-->\n<p>입출력 프로퍼티를 지정하기 위해 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>, <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터를 사용하는 대신, 디렉티브 메타데이터의 <code>inputs</code>, <code>outputs</code> 배열을 활용해도 같은 효과를 낼 수 있습니다:</p>\n<code-example path=\"inputs-outputs/src/app/in-the-metadata/in-the-metadata.component.ts\" region=\"metadata\" header=\"src/app/in-the-metadata/in-the-metadata.component.ts\">\n// tslint:disable: no-inputs-metadata-property no-outputs-metadata-property\ninputs: ['clearanceItem'],\noutputs: ['buyEvent']\n// tslint:enable: no-inputs-metadata-property no-outputs-metadata-property\n\n</code-example>\n<p>이렇게 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code>, <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 메타데이터를 활용해도 입출력 프로퍼티를 지정할 수 있지만, 다음과 같이 클래스 코드에서 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>, <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code>을 지정하는 방식을 더 권장합니다:</p>\n<code-example path=\"inputs-outputs/src/app/input-output/input-output.component.ts\" region=\"input-output\" header=\"src/app/input-output/input-output.component.ts\">\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() item: string;\n@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() deleteRequest = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;string>();\n\n</code-example>\n<p><a href=\"guide/styleguide\">코딩 스타일 가이드</a> 문서의 <a href=\"guide/styleguide#decorate-input-and-output-properties\">입출력 프로퍼티 지정하기</a> 섹션을 참고해 보세요.</p>\n<div class=\"alert is-helpful\">\n<p>입출력 프로퍼티를 지정했을 때 템플릿에서 파싱 오류가 발생한다면 컴포넌트에 해당 프로퍼티가 존재하는지 확인해 보세요.\n입출력 프로퍼티는 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>/<code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 으로 지정하는 방식과 <code>inputs</code>/<code>outputs</code> 배열로 지정하는 방식 모두 가능하니 양쪽 모두 확인해야 합니다:</p>\n<code-example language=\"bash\">\nUncaught Error: Template parse errors:\nCan't bind to 'item' since it isn't a known property of 'app-item-detail'\n</code-example>\n</div>\n<a id=\"aliasing-io\"></a>\n<!--\n## Aliasing inputs and outputs\n-->\n<h2 id=\"입출력-프로퍼티를-다른-이름으로-사용하기\">입출력 프로퍼티를 다른 이름으로 사용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/inputs-outputs#입출력-프로퍼티를-다른-이름으로-사용하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nSometimes the public name of an input/output property should be different from the internal name. While it is a best practice to avoid this situation, Angular does\noffer a solution.\n-->\n<p>입출력 프로퍼티의 이름을 자식 컴포넌트와 부모 컴포넌트에서 다르게 사용해야 할 때가 있습니다.\n권장하지는 않지만 이렇게 사용하는 방법에 대해 알아봅시다.</p>\n<!--\n### Aliasing in the metadata\n-->\n<h3 id=\"메타데이터에서-지정하기\">메타데이터에서 지정하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/inputs-outputs#메타데이터에서-지정하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAlias inputs and outputs in the metadata using a colon-delimited (`:`) string with\nthe directive property name on the left and the public alias on the right:\n\n<code-example path=\"inputs-outputs/src/app/aliasing/aliasing.component.ts\" region=\"alias\" header=\"src/app/aliasing/aliasing.component.ts\">\n// tslint:disable: no-inputs-metadata-property no-outputs-metadata-property\ninputs: [&#39;input1: saveForLaterItem&#39;], // 프로퍼티_이름:클래스_밖에서_사용할_이름\noutputs: [&#39;outputEvent1: saveForLaterEvent&#39;]\n// tslint:disable: no-inputs-metadata-property no-outputs-metadata-property\n\n</code-example>\n-->\n<p>메타데이터에서 입출력 프로퍼티의 다른 이름을 지정하려면 디렉티브 프로퍼티 이름 오른쪽에 콜론(<code>:</code>)을 붙이고 원하는 이름을 지정하면 됩니다:</p>\n<code-example path=\"inputs-outputs/src/app/aliasing/aliasing.component.ts\" region=\"alias\" header=\"src/app/aliasing/aliasing.component.ts\">\n// tslint:disable: no-inputs-metadata-property no-outputs-metadata-property\ninputs: ['input1: saveForLaterItem'], // 프로퍼티_이름:클래스_밖에서_사용할_이름\noutputs: ['outputEvent1: saveForLaterEvent']\n// tslint:disable: no-inputs-metadata-property no-outputs-metadata-property\n\n</code-example>\n<!--\n### Aliasing with the `@Input()`/`@Output()` decorator\n-->\n<h3 id=\"데코레이터에서-지정하기\">데코레이터에서 지정하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/inputs-outputs#데코레이터에서-지정하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou can specify the alias for the property name by passing the alias name to the `@Input()`/`@Output()` decorator. The internal name remains as usual.\n\n<code-example path=\"inputs-outputs/src/app/aliasing/aliasing.component.ts\" region=\"alias-input-output\" header=\"src/app/aliasing/aliasing.component.ts\">\n@Input(&#39;wishListItem&#39;) input2: string; //  @Input(클래스_밖에서_사용할_이름)\n@Output(&#39;wishEvent&#39;) outputEvent2 = new EventEmitter&lt;string&gt;(); //  @Output(클래스_밖에서_사용할_이름) 프로퍼티_이름 = ...\n\n</code-example>\n-->\n<p>데코레이터에서 입출력 프로퍼티의 다른 이름을 지정하려면 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>/<code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터 안에 원하는 이름을 지정하면 됩니다.</p>\n<code-example path=\"inputs-outputs/src/app/aliasing/aliasing.component.ts\" region=\"alias-input-output\" header=\"src/app/aliasing/aliasing.component.ts\">\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('wishListItem') input2: string; //  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>(클래스_밖에서_사용할_이름)\n@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>('wishEvent') outputEvent2 = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;string>(); //  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>(클래스_밖에서_사용할_이름) 프로퍼티_이름 = ...\n\n</code-example>\n\n</div>\n\n<!-- links to this doc:\n - api/core/Input\n - api/core/Output\n - guide/built-in-directives\n - guide/component-interaction\n - guide/glossary\n - guide/observables-in-angular\n - guide/structural-directives\n - guide/template-syntax\n - tutorial/toh-pt3\n-->\n<!-- links from this doc:\n - api/common/DecimalPipe\n - api/common/NgForOf\n - api/core/Component\n - api/core/Directive\n - api/core/EventEmitter\n - api/core/Input\n - api/core/OnChanges\n - api/core/Output\n - guide/event-binding\n - guide/inputs-outputs#input-output-함께-사용하기\n - guide/inputs-outputs#input-사용방법\n - guide/inputs-outputs#input과-output는-독립적으로-동작합니다\n - guide/inputs-outputs#onchanges와-input\n - guide/inputs-outputs#output-사용방법\n - guide/inputs-outputs#데코레이터에서-지정하기\n - guide/inputs-outputs#메타데이터에서-input-output-선언하기\n - guide/inputs-outputs#메타데이터에서-지정하기\n - guide/inputs-outputs#부모-컴포넌트-템플릿에서\n - guide/inputs-outputs#부모-컴포넌트에서\n - guide/inputs-outputs#부모-컴포넌트에서-1\n - guide/inputs-outputs#입출력-프로퍼티-input-output\n - guide/inputs-outputs#입출력-프로퍼티를-다른-이름으로-사용하기\n - guide/inputs-outputs#자식-컴포넌트-템플릿에서\n - guide/inputs-outputs#자식-컴포넌트에서\n - guide/inputs-outputs#자식-컴포넌트에서-1\n - guide/lifecycle-hooks\n - guide/lifecycle-hooks#onchanges\n - guide/property-binding\n - guide/styleguide\n - guide/styleguide#decorate-input-and-output-properties\n - guide/template-reference-variables\n - guide/two-way-binding\n - https://github.com/angular/angular/edit/master/aio/content/guide/inputs-outputs.md?message=docs%3A%20describe%20your%20change...\n - https://www.w3.org/TR/html5/sec-forms.html#the-input-element\n-->"
}