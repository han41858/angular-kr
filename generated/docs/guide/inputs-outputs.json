{
  "id": "guide/inputs-outputs",
  "title": "부모/자식 디렉티브/컴포넌트끼리 데이터 공유하기",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/inputs-outputs.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Sharing data between child and parent directives and components\n-->\n<h1 id=\"부모자식-디렉티브컴포넌트끼리-데이터-공유하기\">부모/자식 디렉티브/컴포넌트끼리 데이터 공유하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/inputs-outputs#부모자식-디렉티브컴포넌트끼리-데이터-공유하기\"><i class=\"material-icons\">link</i></a></h1>\n<!--\nA common pattern in Angular is sharing data between a parent component and one or more child components.\nYou can implement this pattern by using the `@Input()` and `@Output()` directives.\n\n<div class=\"alert is-helpful\">\n\nSee the <live-example></live-example> for a working example containing the code snippets in this guide.\n\n</div>\n\nConsider the following hierarchy:\n\n```html\n<parent-component>\n  <child-component></child-component>\n</parent-component>\n\n```\n\nThe `<parent-component>` serves as the context for the `<child-component>`.\n\n`@Input()` and `@Output()` give a child component a way to communicate with its parent component.\n`@Input()` allows a parent component to update data in the child component.\nConversely, `@Output() allows the child to send data to a parent component.\n-->\n<p>Angular에서는 부모 컴포넌트와 자식 컴포넌트가 데이터를 주고받는 패턴이 자주 사용됩니다.\n이 패턴은 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>, <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터 구현합니다.</p>\n<div class=\"alert is-helpful\">\n<p>이 문서에서 설명하는 내용은 <live-example></live-example>에서 직접 확인하거나 다운받아 확인할 수 있습니다.</p>\n</div>\n<p>이런 구조가 있다고 합시다:</p>\n<code-example language=\"html\">\n&#x3C;parent-component>\n  &#x3C;child-component>&#x3C;/child-component>\n&#x3C;/parent-component>\n</code-example>\n<p>이 구조에서 <code>&#x3C;parent-component></code>는 <code>&#x3C;child-component></code>의 컨텍스트를 제공하는 역할을 합니다.</p>\n<p><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>, <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터를 활용하면 자식 컴포넌트가 부모 컴포넌트와 통신할 수 있습니다.\n이 때 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>은 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때 사용합니다.\n그리고 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code>은 반대로 자식 컴포넌트에서 부모 컴포넌트로 데이터를 전달할 때 사용합니다.</p>\n<a id=\"input\"></a>\n<!--\n## Sending data to a child component\n-->\n<h2 id=\"자식-컴포넌트로-데이터-전달하기\">자식 컴포넌트로 데이터 전달하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/inputs-outputs#자식-컴포넌트로-데이터-전달하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe `@Input()` decorator in a child component or directive signifies that the property can receive its value from its parent component.\n\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/inputs-outputs/input.svg\" alt=\"Input data flow diagram\">\n</div>\n\nTo use `@Input()`, you must configure the parent and child.\n-->\n<p><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터는 자식 컴포넌트/디렉티브에 있는 특정 프로퍼티가 부모 컴포넌트/디렉티브에서 값을 받는다는 것을 지정하는 데코레이터입니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/inputs-outputs/input.svg\" alt=\"Input data flow diagram\" width=\"671\" height=\"346\">\n</div>\n<p><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터는 부모-자식 관계에서만 사용할 수 있습니다.</p>\n<!--\n### Configuring the child component\n-->\n<h3 id=\"자식-컴포넌트-설정하기\">자식 컴포넌트 설정하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/inputs-outputs#자식-컴포넌트-설정하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nTo use the `@Input()` decorator in a child component class, first import `Input` and then decorate the property with `@Input()`, as in the following example.\n\n<code-example path=\"inputs-outputs/src/app/item-detail/item-detail.component.ts\" region=\"use-input\" header=\"src/app/item-detail/item-detail.component.ts\">\nimport { Component, Input } from &#39;@angular/core&#39;; // Input 심볼을 로드합니다.\nexport class ItemDetailComponent {\n  @Input() item: string; // 프로퍼티에 @Input() 데코레이터를 지정합니다.\n}\n\n</code-example>\n\n\nIn this case, `@Input()` decorates the property <code class=\"no-auto-link\">item</code>, which has a type of `string`, however, `@Input()` properties can have any type, such as `number`, `string`, `boolean`, or `object`.\nThe value for `item` comes from the parent component.\n\nNext, in the child component template, add the following:\n\n<code-example path=\"inputs-outputs/src/app/item-detail/item-detail.component.html\" region=\"property-in-template\" header=\"src/app/item-detail/item-detail.component.html\">\n&lt;p&gt;\n  Today&#39;s item: {{item}}\n&lt;/p&gt;\n\n</code-example>\n-->\n<p>자식 컴포넌트에서 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터를 사용하려면 먼저 <code><a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 심볼을 로드해야합니다.\n이렇게 구성하면 됩니다.</p>\n<code-example path=\"inputs-outputs/src/app/item-detail/item-detail.component.ts\" region=\"use-input\" header=\"src/app/item-detail/item-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a> } from '@angular/core'; // <a href=\"api/core/Input\" class=\"code-anchor\">Input</a> 심볼을 로드합니다.\nexport class ItemDetailComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() item: string; // 프로퍼티에 @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() 데코레이터를 지정합니다.\n}\n\n</code-example>\n<p>이렇게 구현하면 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터는 <code>string</code> 타입으로 선언된 <code class=\"no-auto-link\">item</code> 프로퍼티가 입력 프로퍼티라는 것을 지정하는데, <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 프로퍼티에는 <code><a href=\"api/common/DecimalPipe\" class=\"code-anchor\">number</a></code>, <code>string</code>, <code>boolean</code>, <code>object</code> 등 어떠한 타입이라도 자유롭게 전달될 수 있습니다.\n<code>item</code> 프로퍼티에 맞는 타입으로 데이터를 전달하는 것은 부모 컴포넌트의 몫입니다.</p>\n<p>다음에는 자식 컴포넌트 템플릿에 이런 코드를 추가합니다:</p>\n<code-example path=\"inputs-outputs/src/app/item-detail/item-detail.component.html\" region=\"property-in-template\" header=\"src/app/item-detail/item-detail.component.html\">\n&#x3C;p>\n  Today's item: {{item}}\n&#x3C;/p>\n\n</code-example>\n<!--\n### Configuring the parent component\n-->\n<h3 id=\"부모-컴포넌트-설정하기\">부모 컴포넌트 설정하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/inputs-outputs#부모-컴포넌트-설정하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe next step is to bind the property in the parent component's template.\nIn this example, the parent component template is `app.component.html`.\n\n1. Use the child's selector, here `<app-item-detail>`, as a directive within the\nparent component template.\n\n2. Use [property binding](guide/property-binding) to bind the `item` property in the child to the `currentItem` property of the parent.\n\n<code-example path=\"inputs-outputs/src/app/app.component.html\" region=\"input-parent\" header=\"src/app/app.component.html\">\n&lt;app-item-detail [item]=&quot;currentItem&quot;&gt;&lt;/app-item-detail&gt;\n\n</code-example>\n\n3. In the parent component class, designate a value for `currentItem`:\n\n<code-example path=\"inputs-outputs/src/app/app.component.ts\" region=\"parent-property\" header=\"src/app/app.component.ts\">\nexport class AppComponent {\n  currentItem = &#39;Television&#39;;\n}\n\n</code-example>\n\nWith `@Input()`, Angular passes the value for `currentItem` to the child so that `item` renders as `Television`.\n\nThe following diagram shows this structure:\n\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/inputs-outputs/input-diagram-target-source.svg\" alt=\"Property binding diagram\">\n</div>\n\nThe target in the square brackets, `[]`, is the property you decorate with `@Input()` in the child component.\nThe binding source, the part to the right of the equal sign, is the data that the parent component passes to the nested component.\n-->\n<p>다음에는 부모 컴포넌트 템플릿에서 프로퍼티를 바인딩해야 합니다.\n이 문서에서 다루는 예제에서 부모 컴포넌트의 템플릿 파일은 <code>app.component.html</code> 파일입니다.</p>\n<ol>\n<li>\n<p>부모 컴포넌트 템플릿에 자식 컴포넌트 셀렉터 <code>&#x3C;app-item-detail></code>를 추가합니다.</p>\n</li>\n<li>\n<p><a href=\"guide/property-binding\">프로퍼티 바인딩</a>을 사용해서 부모 컴포넌트의 <code>currentItem</code> 프로퍼티를 자식 컴포넌트의 <code>item</code> 프로퍼티로 바인딩합니다.</p>\n</li>\n</ol>\n<code-example path=\"inputs-outputs/src/app/app.component.html\" region=\"input-parent\" header=\"src/app/app.component.html\">\n&#x3C;app-item-detail [item]=\"currentItem\">&#x3C;/app-item-detail>\n\n</code-example>\n<ol start=\"3\">\n<li>부모 컴포넌트 클래스에서 <code>currentItem</code> 값을 할당합니다:</li>\n</ol>\n<code-example path=\"inputs-outputs/src/app/app.component.ts\" region=\"parent-property\" header=\"src/app/app.component.ts\">\nexport class AppComponent {\n  currentItem = 'Television';\n}\n\n</code-example>\n<p><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터를 사용하면 부모 컴포넌트의 <code>currentItem</code> 프로퍼티 값이 자식 컴포넌트 <code>item</code> 프로퍼티로 전달되기 때문에 자식 컴포넌트 템플릿에 정의된 대로 <code>Television</code> 이라는 값이 화면에 렌더링됩니다.</p>\n<p>아래 그림을 보면서 구조를 확인해 보세요:</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/inputs-outputs/input-diagram-target-source.svg\" alt=\"Property binding diagram\" width=\"502\" height=\"304\">\n</div>\n<p>이 때 프로퍼티 바인딩 대상이 되는 프로퍼티는 부모 컴포넌트 템플릿에서 대괄호(<code>[]</code>)로 감싼 프로퍼티이며, 자식 컴포넌트 클래스에서 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터를 지정한 프로퍼티이기도 합니다.\n바인딩 하는 대상은 등호(<code>=</code>) 오른쪽에 있는 부모 컴포넌트 클래스 프로퍼티입니다.</p>\n<!--\n### Watching for `@Input()` changes\n-->\n<h3 id=\"input-변화-감지하기\"><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 변화 감지하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/inputs-outputs#input-변화-감지하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nTo watch for changes on an `@Input()` property, you can use `OnChanges`, one of Angular's [lifecycle hooks](guide/lifecycle-hooks).\nSee the [`OnChanges`](guide/lifecycle-hooks#onchanges) section of the [Lifecycle Hooks](guide/lifecycle-hooks) guide for more details and examples.\n-->\n<p><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 프로퍼티로 전달되는 값이 변경되는 것을 감지하려면 Angular <a href=\"guide/lifecycle-hooks\">라이프싸이클 후킹 함수</a> 중 <code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a></code>를 활용하면 됩니다.\n자세한 내용은 <a href=\"guide/lifecycle-hooks\">라이프싸이클 후킹 함수</a> 문서의 <a href=\"guide/lifecycle-hooks#onchanges\"><code>OnChanges</code></a> 섹션을 참고하세요.</p>\n<a id=\"output\"></a>\n<!--\n## Sending data to a parent component\n-->\n<h2 id=\"부모-컴포넌트로-데이터-전달하기\">부모 컴포넌트로 데이터 전달하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/inputs-outputs#부모-컴포넌트로-데이터-전달하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe `@Output()` decorator in a child component or directive allows data to flow from the child to the parent.\n\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/inputs-outputs/output.svg\" alt=\"Output diagram\">\n</div>\n\n`@Output()` marks a property in a child component as a doorway through which data can travel from the child to the parent.\n\nThe child component uses the `@Output()` property to raise an event to notify the parent of the change.\nTo raise an event, an `@Output()` must have the type of `EventEmitter`, which is a class in `@angular/core` that you use to emit custom events.\n\nThe following example shows how to set up an `@Output()` in a child component that pushes data from an HTML `<input>` to an array in the parent component.\n\nTo use `@Output()`, you must configure the parent and child.\n-->\n<p>자식 컴포넌트/디렉티브에 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터를 사용하면 부모 컴포넌트/디렉티브로 데이터를 전달할 수 있습니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/inputs-outputs/output.svg\" alt=\"Output diagram\" width=\"666\" height=\"340\">\n</div>\n<p><code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터는 자식 컴포넌트 프로퍼티 중 부모 컴포넌트로 데이터를 보내는 프로퍼티를 지정하는 역할을 합니다.</p>\n<p>그리고 나면 자식 컴포넌트에서 이벤트를 발생시켜서 부모 컴포넌트로 보내면 됩니다.\n이벤트를 발생시키기 위해 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터는 반드시 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 타입의 프로퍼티에 선언해야 합니다.\n이 커스텀 이벤트 클래스는 <code>@angular/core</code> 패키지에서 제공하는 클래스입니다.</p>\n<p>이번에는 자식 컴포넌트 템플릿에 있는 HTML <code>&#x3C;input></code> 엘리먼트에서 데이터를 받아 부모 컴포넌트로 전달하는 예제를 알아봅시다.</p>\n<p><code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터를 사용하려면 부모 컴포넌트와 자식 컴포넌트를 모두 수정해야 합니다.</p>\n<!--\n### Configuring the child component\n-->\n<h3 id=\"자식-컴포넌트-설정하기-1\">자식 컴포넌트 설정하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/inputs-outputs#자식-컴포넌트-설정하기-1\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe following example features an `<input>` where a user can enter a value and click a `<button>` that raises an event. The `EventEmitter` then relays the data to the parent component.\n\n1. Import `Output` and `EventEmitter` in the child component class:\n\n  ```js\n  import { Output, EventEmitter } from '@angular/core';\n\n  ```\n\n1. In the component class, decorate a property with `@Output()`.\n  The following example `newItemEvent` `@Output()` has a type of `EventEmitter`, which means it's an event.\n\n  <code-example path=\"inputs-outputs/src/app/item-output/item-output.component.ts\" region=\"item-output\" header=\"src/app/item-output/item-output.component.ts\">\n\n@Output() newItemEvent = new EventEmitter&lt;string&gt;();\n\n\n</code-example>\n\n  The different parts of the above declaration are as follows:\n\n    * `@Output()`&mdash;a decorator function marking the property as a way for data to go from the child to the parent\n    * `newItemEvent`&mdash;the name of the `@Output()`\n    * `EventEmitter<string>`&mdash;the `@Output()`'s type\n    * `new EventEmitter<string>()`&mdash;tells Angular to create a new event emitter and that the data it emits is of type string.\n\n  For more information on `EventEmitter`, see the [EventEmitter API documentation](api/core/EventEmitter).\n\n1. Create an `addNewItem()` method in the same component class:\n\n  <code-example path=\"inputs-outputs/src/app/item-output/item-output.component.ts\" region=\"item-output-class\" header=\"src/app/item-output/item-output.component.ts\">\nexport class ItemOutputComponent {\n\n  @Output() newItemEvent = new EventEmitter&lt;string&gt;();\n\n  addNewItem(value: string) {\n    this.newItemEvent.emit(value);\n  }\n}\n\n</code-example>\n\n  The `addNewItem()` function uses the `@Output()`, `newItemEvent`, to raise an event with the value the user types into the `<input>`.\n-->\n<p>이제부터 살펴볼 예제에서 사용자가 <code>&#x3C;input></code> 엘리먼트에 문자열을 입력하고 버튼을 클릭하면 이벤트를 발생시킵니다.\n그리고 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code>를 사용해서 부모 컴포넌트로 이 이벤트를 전달할 것입니다.</p>\n<ol>\n<li>\n<p>자식 컴포넌트 클래스 파일에 <code><a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code>, <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 심볼을 로드합니다:</p>\n<code-example language=\"js\">\nimport { <a href=\"api/core/Output\" class=\"code-anchor\">Output</a>, <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a> } from '@angular/core';\n</code-example>\n</li>\n<li>\n<p>컴포넌트 클래스에서 프로퍼티에 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터를 지정합니다.\n아래 예제 코드는 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 타입으로 선언된 <code>newItemEvent</code> 프로퍼티에 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터를 지정한 코드입니다.</p>\n<code-example path=\"inputs-outputs/src/app/item-output/item-output.component.ts\" region=\"item-output\" header=\"src/app/item-output/item-output.component.ts\">\n\n@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() newItemEvent = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;string>();\n\n\n</code-example>\n<p>이전 예제와는 이런 점이 다릅니다:</p>\n<ul>\n<li><code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code>—자식 컴포넌트에서 부모 컴포넌트로 데이터를 전달하는 프로퍼티를 지정합니다.</li>\n<li><code>newItemEvent</code>—<code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터가 지정된 프로퍼티입니다.</li>\n<li><code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;string></code>—<code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터의 타입입니다.</li>\n<li><code>new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;string>()</code>—문자열 타입으로 이벤트를 전달하는 이벤트 이미터 인스턴스를 생성합니다.</li>\n</ul>\n<p><code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code>에 대해 자세하게 알아보려면 <a href=\"api/core/EventEmitter\">EventEmitter API 문서</a>를 참고하세요.</p>\n</li>\n<li>\n<p>자식 컴포넌트 클래스에 <code>addNewItem()</code> 메서드를 추가합니다:</p>\n<code-example path=\"inputs-outputs/src/app/item-output/item-output.component.ts\" region=\"item-output-class\" header=\"src/app/item-output/item-output.component.ts\">\nexport class ItemOutputComponent {\n\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() newItemEvent = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;string>();\n\n  addNewItem(value: string) {\n    this.newItemEvent.emit(value);\n  }\n}\n\n</code-example>\n<p><code>addNewItem()</code> 함수는 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터가 지정된 <code>newItemEvent</code>를 활용해서 이벤트를 발생시키며, 이 때 <code>&#x3C;input></code> 엘리먼트에 사용자가 입력한 값을 함께 전달합니다.</p>\n</li>\n</ol>\n<!--\n### Configuring the child's template\n-->\n<h3 id=\"자식-컴포넌트-템플릿-설정하기\">자식 컴포넌트 템플릿 설정하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/inputs-outputs#자식-컴포넌트-템플릿-설정하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe child's template has two controls.\nThe first is an HTML `<input>` with a [template reference variable](guide/template-reference-variables) , `#newItem`, where the user types in an item name.\nThe `value` property of the `#newItem` variable stores what the user types into the `<input>`.\n\n<code-example path=\"inputs-outputs/src/app/item-output/item-output.component.html\" region=\"child-output\" header=\"src/app/item-output/item-output.component.html\">\n&lt;label&gt;Add an item: &lt;input #newItem&gt;&lt;/label&gt;\n&lt;button (click)=&quot;addNewItem(newItem.value)&quot;&gt;Add to parent&#39;s list&lt;/button&gt;\n\n</code-example>\n\nThe second element is a `<button>` with a `click` [event binding](guide/event-binding).\n\nThe `(click)` event is bound to the `addNewItem()` method in the child component class.\nThe `addNewItem()` method takes as its argument the value of the `#newItem.value` property.\n-->\n<p>자식 컴포넌트 템플릿에는 폼 컨트롤이 2개 있습니다.\n하나는 사용자가 값을 입력할 수 있는 HTML <code>&#x3C;input></code> 엘리먼트이며, 이 엘리먼트에는 <a href=\"guide/template-reference-variables\">템플릿 참조 변수</a> <code>newItem</code>이 지정되어 있습니다.\n사용자가 <code>&#x3C;input></code> 엘리먼트에 입력한 값을 참조하려면 <code>#newItem</code> 변수의 <code>value</code> 프로퍼티를 참조하면 됩니다.</p>\n<code-example path=\"inputs-outputs/src/app/item-output/item-output.component.html\" region=\"child-output\" header=\"src/app/item-output/item-output.component.html\">\n&#x3C;label>Add an item: &#x3C;input #newItem>&#x3C;/label>\n&#x3C;button (click)=\"addNewItem(newItem.value)\">Add to parent's list&#x3C;/button>\n\n</code-example>\n<p>그리고 다른 엘리먼트는 <code>click</code> <a href=\"guide/event-binding\">이벤트가 바인딩 된</a> <code>&#x3C;button></code> 엘리먼트입니다.</p>\n<p>이 엘리먼트의 <code>(click)</code> 이벤트는 자식 컴포넌트 클래스의 <code>addNewItem()</code> 메서드와 바인딩 되어 있습니다.\n<code>addNewItem()</code> 메서드는 <code>#newItem.value</code> 값을 인자로 받습니다.</p>\n<!--\n### Configuring the parent component\n-->\n<h3 id=\"부모-컴포넌트-설정하기-1\">부모 컴포넌트 설정하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/inputs-outputs#부모-컴포넌트-설정하기-1\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe `AppComponent` in this example features a list of `items` in an array and a method for adding more items to the array.\n\n<code-example path=\"inputs-outputs/src/app/app.component.ts\" region=\"add-new-item\" header=\"src/app/app.component.ts\">\nexport class AppComponent {\n  items = [&#39;item1&#39;, &#39;item2&#39;, &#39;item3&#39;, &#39;item4&#39;];\n\n  addItem(newItem: string) {\n    this.items.push(newItem);\n  }\n}\n\n</code-example>\n\nThe `addItem()` method takes an argument in the form of a string and then adds that string to the `items` array.\n-->\n<p>이 문서에서 다루는 예제에서 <code>AppComponent</code>에는 항목들을 배열 형태로 저장하는 <code>items</code> 배열이 있습니다.</p>\n<code-example path=\"inputs-outputs/src/app/app.component.ts\" region=\"add-new-item\" header=\"src/app/app.component.ts\">\nexport class AppComponent {\n  items = ['item1', 'item2', 'item3', 'item4'];\n\n  addItem(newItem: string) {\n    this.items.push(newItem);\n  }\n}\n\n</code-example>\n<p>그리고 부모 컴포넌트의 <code>addItem()</code> 메서드는 인자로 받은 문자열을 <code>items</code> 배열에 저장합니다.</p>\n<!--\n### Configuring the parent's template\n-->\n<h3 id=\"부모-컴포넌트-템플릿-설정하기\">부모 컴포넌트 템플릿 설정하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/inputs-outputs#부모-컴포넌트-템플릿-설정하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\n1. In the parent's template, bind the parent's method to the child's event.\n\n1. Put the child selector, here `<app-item-output>`, within the parent component's template, `app.component.html`.\n\n  <code-example path=\"inputs-outputs/src/app/app.component.html\" region=\"output-parent\" header=\"src/app/app.component.html\">\n&lt;app-item-output (newItemEvent)=&quot;addItem($event)&quot;&gt;&lt;/app-item-output&gt;\n\n</code-example>\n\n  The event binding, `(newItemEvent)='addItem($event)'`, connects the event in the child, `newItemEvent`, to the method in the parent, `addItem()`.\n\n  The `$event` contains the data that the user types into the `<input>` in the child template UI.\n\n  To see the `@Output()` working, you can add the following to the parent's template:\n\n  ```html\n    <ul>\n      <li *ngFor=\"let item of items\">{{item}}</li>\n    </ul>\n  ```\n\n  The `*ngFor` iterates over the items in the `items` array.\n  When you enter a value in the child's `<input>` and click the button, the child emits the event and the parent's `addItem()` method pushes the value to the `items` array and new item renders in the list.\n-->\n<ol>\n<li>\n<p>부모 컴포넌트 메서드와 자식 컴포넌트의 이벤트는 부모 컴포넌트 템플릿에서 바인딩 합니다.</p>\n</li>\n<li>\n<p>부모 컴포넌트 템플릿 파일 <code>app.component.html</code>에 자식 컴포넌트 셀렉터 <code>&#x3C;app-item-output></code>를 추가합니다.</p>\n<code-example path=\"inputs-outputs/src/app/app.component.html\" region=\"output-parent\" header=\"src/app/app.component.html\">\n&#x3C;app-item-output (newItemEvent)=\"addItem($event)\">&#x3C;/app-item-output>\n\n</code-example>\n<p>이벤트 바인딩 <code>(newItemEvent)='addItem($event)'</code>에 사용된 문법을 보면, 자식 컴포넌트에서 <code>newItemEvent</code> 이벤트가 발생하면 부모 컴포넌트 메서드 <code>addItem()</code>을 실행합니다.</p>\n<p><code>$event</code> 객체는 자식 컴포넌트에서 보낸 데이터가 담겨 있습니다.\n이 예제에서는 자식 컴포넌트 템플릿의 <code>&#x3C;input></code>에 사용자가 입력한 값이 전달됩니다.</p>\n<p><code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터가 동작하는 것을 확인하기 위해 부모 컴포넌트에 이런 코드를 추가합니다:</p>\n<code-example language=\"html\">\n  &#x3C;ul>\n    &#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let item of items\">{{item}}&#x3C;/li>\n  &#x3C;/ul>\n</code-example>\n<p><code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>는 <code>items</code> 배열을 순회하며 템플릿을 반복해서 렌더링합니다.\n이제 사용자가 자식 컴포넌트 템플릿에서 <code>&#x3C;input></code>에 값을 입력하고 버튼을 누르면 자식 컴포넌트에서 이벤트가 발생하며, 이벤트가 발생하면 이 이벤트와 바인딩된 부모 컴포넌트 <code>addItem()</code> 메서드가 실행되면서 <code>items</code> 배열에 새로운 항목이 추가되고 화면에 렌더링됩니다.</p>\n</li>\n</ol>\n<!--\n## Using `@Input()` and `@Output()` together\n-->\n<h2 id=\"input-output-함께-사용하기\"><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>, <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 함께 사용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/inputs-outputs#input-output-함께-사용하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nYou can use `@Input()` and `@Output()` on the same child component as follows:\n\n<code-example path=\"inputs-outputs/src/app/app.component.html\" region=\"together\" header=\"src/app/app.component.html\">\n&lt;app-input-output [item]=&quot;currentItem&quot; (deleteRequest)=&quot;crossOffItem($event)&quot;&gt;&lt;/app-input-output&gt;\n\n</code-example>\n\nThe target, `item`, which is an `@Input()` property in the child component class, receives its value from the parent's property, `currentItem`.\nWhen you click delete, the child component raises an event, `deleteRequest`, which is the argument for the parent's `crossOffItem()` method.\n\nThe following diagram shows the different parts of the `@Input()` and `@Output()` on the `<app-input-output>` child component.\n\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/inputs-outputs/input-output-diagram.svg\" alt=\"Input/Output diagram\">\n</div>\n\nThe child selector is `<app-input-output>` with `item` and `deleteRequest` being `@Input()` and `@Output()`\nproperties in the child component class.\nThe property `currentItem` and the method `crossOffItem()` are both in the parent component class.\n\nTo combine property and event bindings using the banana-in-a-box\nsyntax, `[()]`, see [Two-way Binding](guide/two-way-binding).\n-->\n<p><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터와 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터는 자식 컴포넌트에서 함께 사용할 수도 있습니다:</p>\n<code-example path=\"inputs-outputs/src/app/app.component.html\" region=\"together\" header=\"src/app/app.component.html\">\n&#x3C;app-input-output [item]=\"currentItem\" (deleteRequest)=\"crossOffItem($event)\">&#x3C;/app-input-output>\n\n</code-example>\n<p><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터가 지정된 <code>item</code> 프로퍼티는 부모 컴포넌트의 <code>currentItem</code> 프로퍼티에서 값을 받아옵니다.\n그리고 사용자가 삭제 버튼을 클릭하면 자식 컴포넌트에서 <code>deleteRequest</code> 이벤트가 발생하는데, 이 이벤트는 부모 컴포넌트가 감지하고 있다가 <code>crossOffItem()</code> 메서드를 실행합니다.</p>\n<p>아래 그림을 보면서 자식 컴포넌트 <code>&#x3C;app-input-output></code>에 사용된 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터와 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터가 어떻게 연결되는지 확인해 보세요.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/inputs-outputs/input-output-diagram.svg\" alt=\"Input/Output diagram\" width=\"800\" height=\"333\">\n</div>\n<p>이 코드에서 자식 컴포넌트 셀렉터는 <code>&#x3C;app-input-output></code>이며, 자식 컴포넌트에 있는 <code>item</code> 프로퍼티와 <code>deleteRequest</code> 프로퍼티는 각각 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터와 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터가 지정되었습니다.\n그리고 <code>currentItem</code> 프로퍼티와 <code>crossOffItem()</code> 메서드는 부모 컴포넌트 클래스에 정의되어 있습니다.</p>\n<p>프로퍼티 바인딩과 이벤트 바인딩을 결합한 <em>상자 안에 있는 바나나 (<code>[()]</code>)</em> 문법에 대해 자세하게 알아보려면 <a href=\"guide/two-way-binding\">양방향 바인딩</a> 문서를 참고하세요.</p>\n\n</div>\n\n<!-- links to this doc:\n - api/core/Input\n - api/core/Output\n - guide/built-in-directives\n - guide/component-interaction\n - guide/example-apps-list\n - guide/glossary\n - guide/observables-in-angular\n - guide/structural-directives\n - guide/template-syntax\n - guide/two-way-binding\n - tutorial/toh-pt3\n-->\n<!-- links from this doc:\n - api/common/DecimalPipe\n - api/common/NgForOf\n - api/core/Component\n - api/core/EventEmitter\n - api/core/Input\n - api/core/OnChanges\n - api/core/Output\n - guide/event-binding\n - guide/inputs-outputs#input-output-함께-사용하기\n - guide/inputs-outputs#input-변화-감지하기\n - guide/inputs-outputs#부모-컴포넌트-설정하기\n - guide/inputs-outputs#부모-컴포넌트-설정하기-1\n - guide/inputs-outputs#부모-컴포넌트-템플릿-설정하기\n - guide/inputs-outputs#부모-컴포넌트로-데이터-전달하기\n - guide/inputs-outputs#부모자식-디렉티브컴포넌트끼리-데이터-공유하기\n - guide/inputs-outputs#자식-컴포넌트-설정하기\n - guide/inputs-outputs#자식-컴포넌트-설정하기-1\n - guide/inputs-outputs#자식-컴포넌트-템플릿-설정하기\n - guide/inputs-outputs#자식-컴포넌트로-데이터-전달하기\n - guide/lifecycle-hooks\n - guide/lifecycle-hooks#onchanges\n - guide/property-binding\n - guide/template-reference-variables\n - guide/two-way-binding\n - https://github.com/angular/angular/edit/master/aio/content/guide/inputs-outputs.md?message=docs%3A%20describe%20your%20change...\n-->"
}