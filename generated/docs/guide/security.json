{
  "id": "guide/security",
  "title": "보안",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/security.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Security\n-->\n<h1 id=\"보안\">보안<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#보안\"><i class=\"material-icons\">link</i></a></h1>\n<!--\nThis page describes Angular's built-in\nprotections against common web-application vulnerabilities and attacks such as cross-site\nscripting attacks. It doesn't cover application-level security, such as authentication (_Who is\nthis user?_) and authorization (_What can this user do?_).\n\nFor more information about the attacks and mitigations described below, see [OWASP Guide Project](https://www.owasp.org/index.php/Category:OWASP_Guide_Project).\n\nYou can run the <live-example></live-example> in Stackblitz and download the code from there.\n-->\n<p>이 문서는 일반적인 웹 애플리케이션에 존재하는 취약점이나 크로스-사이트 스크립트 공격과 같은 악성 공격을 Angular가 어떻게 방어하는지 소개합니다.\n인증(<em>이 사용자는 누구인가?</em>)이나 권한(<em>이 사용자는 무엇을 할 수 있나?</em>)과 같은 애플리케이션 레벨의 보안에 대해서는 다루지 않습니다.</p>\n<p>이 문서에서 다루는 공격 방법에 대해 자세하게 알아보려면 <a href=\"https://www.owasp.org/index.php/Category:OWASP_Guide_Project\">OWASP Guide Project</a>를 참고하세요.</p>\n<p>이 문서에서 다루는 예제 코드는 <live-example></live-example>에서 직접 실행하거나 다운받아 확인할 수 있습니다.</p>\n<h2 id=\"report-issues\">\n  <!--\n  Reporting vulnerabilities\n  -->\n  취약점 제보하기\n<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#report-issues\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nTo report vulnerabilities in Angular itself, email us at [security@angular.io](mailto:security@angular.io).\n\nFor more information about how Google handles security issues, see [Google's security\nphilosophy](https://www.google.com/about/appsecurity/).\n-->\n<p>Angular에 존재하는 취약점을 제보하려면 <a href=\"mailto:security@angular.io\">security@angular.io</a>로 메일을 보내주세요.</p>\n<p>Google이 처리하는 보안 이슈에 대해 더 알아보려면 <a href=\"https://www.google.com/about/appsecurity/\">Google의 보안 철학</a> 문서를 참고하세요.</p>\n<h2 id=\"best-practices\">\n  <!--\n  Best practices\n  -->\n  권장사항\n<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#best-practices\"><i class=\"material-icons\">link</i></a></h2>\n<!--\n* **Keep current with the latest Angular library releases.**\nWe regularly update the Angular libraries, and these updates may fix security defects discovered in\nprevious versions. Check the Angular [change\nlog](https://github.com/angular/angular/blob/master/CHANGELOG.md) for security-related updates.\n\n* **Don't modify your copy of Angular.**\nPrivate, customized versions of Angular tend to fall behind the current version and may not include\nimportant security fixes and enhancements. Instead, share your Angular improvements with the\ncommunity and make a pull request.\n\n* **Avoid Angular APIs marked in the documentation as “_Security Risk_.”**\nFor more information, see the [Trusting safe values](guide/security#bypass-security-apis) section of this page.\n-->\n<ul>\n<li>\n<p><strong>Angular 라이브러리는 최신 버전으로 유지하세요.</strong>\nAngular 팀은 주기적으로 Angular 라이브러리를 업데이트하면서 이전 버전에 발견된 보안 문제를 함께 수정하고 있습니다.\n<a href=\"https://github.com/angular/angular/blob/master/CHANGELOG.md\">체인지 로그</a>에서 보안과 관련된 업데이트 내용을 확인해 보세요.</p>\n</li>\n<li>\n<p><strong>Angular 코드를 직접 수정하지 마세요.</strong>\nAngular 코드를 직접 수정해서 사용하면 해당 버전의 기능이 일부 동작하지 않을 수 있는데, 이 때 중요한 보안 패치나 방어 로직이 동작하지 않을 수 있습니다.\nAngular를 직접 수정하기 보다는 커뮤니티에 수정을 요청하거나 풀 리퀘스트를 활용하세요.</p>\n</li>\n<li>\n<p><strong>문서에 \"<em>Security Risk</em>\" 라고 표시된 API는 되도록 사용하지 마세요.</strong>\n더 자세한 내용은 이 문서의 <a href=\"guide/security#bypass-security-apis\">안전한 값으로 간주하기</a> 섹션에서 설명합니다.</p>\n</li>\n</ul>\n<h2 id=\"xss\">\n  <!--\n  Preventing cross-site scripting (XSS)\n  -->\n  크로스 사이트 스크립트 공격(cross-site scripting, XSS) 방어하기\n<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#xss\"><i class=\"material-icons\">link</i></a></h2>\n<!--\n[Cross-site scripting (XSS)](https://en.wikipedia.org/wiki/Cross-site_scripting) enables attackers\nto inject malicious code into web pages. Such code can then, for example, steal user data (in\nparticular, login data) or perform actions to impersonate the user. This is one of the most\ncommon attacks on the web.\n\nTo block XSS attacks, you must prevent malicious code from entering the DOM (Document Object Model). For example, if\nattackers can trick you into inserting a `<script>` tag in the DOM, they can run arbitrary code on\nyour website. The attack isn't limited to `<script>` tags&mdash;many elements and properties in the\nDOM allow code execution, for example, `<img onerror=\"...\">` and `<a href=\"javascript:...\">`. If\nattacker-controlled data enters the DOM, expect security vulnerabilities.\n-->\n<p><a href=\"https://en.wikipedia.org/wiki/Cross-site_scripting\">크로스-사이트 스크립트 공격(cross-site scripting, XSS)</a>은 공격자가 웹 페이지 안에 악성 코드를 주입해서 실행하는 것을 의미합니다.\n이런 공격은 웹에서 가장 흔한 공격 방식 중 하나인데, 보통 로그인 데이터와 같은 사용자의 정보를 탈취하거나 비정상적인 동작을 실행하는 방식으로 동작합니다.</p>\n<p>XSS 공격을 방어하려면 DOM(Document Object Model)에 악성 코드가 추가되는 것을 막아야 합니다.\n공격자가 DOM 안에 <code>&#x3C;script></code> 태그를 심을 수 있다면, 이 태그를 통해 악성 코드를 실행할 수 있습니다.\n하지만 XSS 공격이 꼭 <code>&#x3C;script></code> 태그에만 한정된 것은 아닙니다.\n<code>&#x3C;img onerror=\"...\"></code>나 <code>&#x3C;a href=\"javascript:...\"></code>와 같은 코드도 XSS 공격에 활용될 수 있습니다.\n그래서 공격자가 DOM에 데이터를 추가할 수 있다면 보안 취약점이 존재한다고 볼 수 있습니다.</p>\n<!--\n### Angular’s cross-site scripting security model\n-->\n<h3 id=\"angular의-xss-방어-모델\">Angular의 XSS 방어 모델<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#angular의-xss-방어-모델\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nTo systematically block XSS bugs, Angular treats all values as untrusted by default. When a value\nis inserted into the DOM from a template, via property, attribute, style, class binding, or interpolation,\nAngular sanitizes and escapes untrusted values.\n\n_Angular templates are the same as executable code_: HTML, attributes, and binding expressions\n(but not the values bound) in templates are trusted to be safe. This means that applications must\nprevent values that an attacker can control from ever making it into the source code of a\ntemplate. Never generate template source code by concatenating user input and templates.\nTo prevent these vulnerabilities, use\nthe [offline template compiler](guide/security#offline-template-compiler), also known as _template injection_.\n-->\n<p>프레임워크 계층에서 XSS 공격을 방어하기 위해 기본적으로 Angular는 모든 값을 신뢰할 수 없는 것으로 간주합니다.\n그래서 템플릿 DOM에 추가되는 값이나 프로퍼티, 어트리뷰트, 스타일, 클래스 바인딩, 문자열 바인딩은 모두 Angular가 안전성을 검사하고 보안에 위배되는 값을 제거합니다.</p>\n<p><em>Angular 템플릿은 실행되는 코드라고 볼 수 있습니다</em>: 그래서 템플릿에 존재하는 HTML이나 어트리뷰트, 바인딩 표현식은 모두 안전한 코드가 되어야 하며, 애플리케이션은 XSS 공격자가 템플릿에 소스 코드를 추가할 수 없도록 해야 합니다.\n사용자가 입력한 내용으로 템플릿을 구성하는 방식은 절대로 사용하면 안됩니다.\n이 기능이 꼭 필요하다면 <a href=\"guide/security#offline-template-compiler\">오프라인 템플릿 컴파일러</a>를 사용해야 합니다. 이 방식은 <em>템플릿 주입(template injection)</em> 이라고도 합니다.</p>\n<a id=\"sanitization-and-security-contexts\"></a>\n<!--\n### Sanitization and security contexts\n-->\n<h3 id=\"코드-안전성-검사와-보안-영역\">코드 안전성 검사와 보안 영역<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#코드-안전성-검사와-보안-영역\"><i class=\"material-icons\">link</i></a></h3>\n<!--\n_Sanitization_ is the inspection of an untrusted value, turning it into a value that's safe to insert into\nthe DOM. In many cases, sanitization doesn't change a value at all. Sanitization depends on context:\na value that's harmless in CSS is potentially dangerous in a URL.\n\nAngular defines the following security contexts:\n\n* **HTML** is used when interpreting a value as HTML, for example, when binding to `innerHtml`.\n* **Style** is used when binding CSS into the `style` property.\n* **URL** is used for URL properties, such as `<a href>`.\n* **Resource URL** is a URL that will be loaded and executed as code, for example, in `<script src>`.\n\nAngular sanitizes untrusted values for HTML, styles, and URLs; sanitizing resource URLs isn't\npossible because they contain arbitrary code. In development mode, Angular prints a console warning\nwhen it has to change a value during sanitization.\n-->\n<p><em>코드 안전성 검사(Sanitization)</em> 란 안전성이 확인되지 않은 값을 검사해서 DOM에 적용할 수 있는 안전한 값으로 변환하는 것을 의미합니다.\n일반적으로 코드 안전성 검사를 실행했을 때 값 전체를 한번에 처리하지는 않습니다.\n코드 안전성 검사는 해당 컨텍스트에 필요한 부분만 처리됩니다.\n그래서 CSS에는 위험하지 않은 코드라도 URL에 사용되면 위험할 수 있는 경우도 있습니다.</p>\n<p>Angular는 다음과 같은 보안 영역(security context)을 구성합니다:</p>\n<ul>\n<li>어떤 값이 HTML로 변환되는 경우에는 <strong>HTML</strong> 보안 영역이 구성됩니다. <code>innerHtml</code>로 바인딩되는 경우가 해당됩니다.</li>\n<li><code><a href=\"api/animations/style\" class=\"code-anchor\">style</a></code> 프로퍼티로 CSS 코드가 바인딩되는 경우에는 <strong>스타일</strong> 보안 영역이 구성됩니다.</li>\n<li><code>&#x3C;a href></code>와 같은 엘리먼트에 URL 프로퍼티가 사용되면 <strong>URL</strong> 보안 영역이 구성됩니다.</li>\n<li><code>&#x3C;script src></code>와 같이 외부 코드를 로드해서 실행하는 경우에는 <strong>리소스 URL</strong> 보안 영역이 구성됩니다.</li>\n</ul>\n<p>Angular는 HTML이나 스타일, URL로 사용되는 값에 모두 안전성 검사를 실행하지만, 리소스 URL에는 미처 처리되지 않은 악성 코드가 포함되어 있을 수도 있습니다.\n그래서 개발 모드에서는 추가 안전성 검사가 필요하다고 판단하는 경우에 콘솔로 경고 메시지를 출력합니다.</p>\n<!--\n### Sanitization example\n-->\n<h3 id=\"안전성-검사-예제\">안전성 검사 예제<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#안전성-검사-예제\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe following template binds the value of `htmlSnippet`, once by interpolating it into an element's\ncontent, and once by binding it to the `innerHTML` property of an element:\n-->\n<p>아래 템플릿 코드에서 <code>htmlSnippet</code>는 엘리먼트의 내용에 문자열 바인딩되면서 한 번, 엘리먼트의 <code>innerHTML</code> 프로퍼티에 바인딩되면서 한 번 실행됩니다:</p>\n<code-example path=\"security/src/app/inner-html-binding.component.html\" header=\"src/app/inner-html-binding.component.html\">\n&#x3C;h3>Binding innerHTML&#x3C;/h3>\n&#x3C;p>Bound value:&#x3C;/p>\n&#x3C;p class=\"e2e-inner-html-interpolated\">{{htmlSnippet}}&#x3C;/p>\n&#x3C;p>Result of binding to innerHTML:&#x3C;/p>\n&#x3C;p class=\"e2e-inner-html-bound\" [innerHTML]=\"htmlSnippet\">&#x3C;/p>\n\n\n</code-example>\n<!--\nInterpolated content is always escaped&mdash;the HTML isn't interpreted and the browser displays\nangle brackets in the element's text content.\n\nFor the HTML to be interpreted, bind it to an HTML property such as `innerHTML`. But binding\na value that an attacker might control into `innerHTML` normally causes an XSS\nvulnerability. For example, code contained in a `<script>` tag is executed:\n-->\n<p>문자열 바인딩되는 내용은 언제나 안전하게 처리됩니다. 이 내용이 HTML 코드라면 이 코드는 HTML로 처리되지 않고 일반 문자열로 표시될 것입니다.</p>\n<p>HTML 코드를 그대로 사용하려면 이 코드는 <code>innerHTML</code>과 같은 HTML 프로퍼티에 바인딩되어야 합니다.\n하지만 이 코드를 아무 처리없이 바인딩하는 것은 공격자가 XSS 취약점을 사용하도록 하는 것과 같습니다.\n예를 들어 <code>htmlSnippet</code>의 내용 안에 <code>&#x3C;script></code> 태그가 포함되어 있다고 합시다:</p>\n<!--\n<code-example path=\"security/src/app/inner-html-binding.component.ts\" header=\"src/app/inner-html-binding.component.ts (class)\" region=\"class\">\nexport class InnerHtmlBindingComponent {\n  // HTML 코드에 악성 코드가 포함되어 있을 수 있습니다.\n  htmlSnippet = &#39;Template &lt;script&gt;alert(&quot;0wned&quot;)&lt;/script&gt; &lt;b&gt;Syntax&lt;/b&gt;&#39;;\n}\n\n\n</code-example>\n-->\n<code-example path=\"security/src/app/inner-html-binding.component.ts\" header=\"src/app/inner-html-binding.component.ts (클래스)\" region=\"class\">\nexport class InnerHtmlBindingComponent {\n  // HTML 코드에 악성 코드가 포함되어 있을 수 있습니다.\n  htmlSnippet = 'Template &#x3C;script>alert(\"0wned\")&#x3C;/script> &#x3C;b>Syntax&#x3C;/b>';\n}\n\n\n</code-example>\n<!--\nAngular recognizes the value as unsafe and automatically sanitizes it, which removes the `<script>`\ntag but keeps safe content such as the `<b>` element.\n-->\n<p>Angular는 이 코드에서 <code>&#x3C;script></code>와 같이 위험한 부분을 자동으로 제거하지만 <code>&#x3C;b></code> 엘리먼트와 같이 안전한 코드는 그대로 둡니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/security/binding-inner-html.png\" alt=\"A screenshot showing interpolated and bound HTML values\" width=\"400\" height=\"114\">\n</div>\n<!--\n### Direct use of the DOM APIs and explicit sanitization calls\n-->\n<h3 id=\"dom-api를-직접-사용하는-경우와-명시적으로-안전성-검사를-실행하는-경우\">DOM API를 직접 사용하는 경우와 명시적으로 안전성 검사를 실행하는 경우<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#dom-api를-직접-사용하는-경우와-명시적으로-안전성-검사를-실행하는-경우\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe built-in browser DOM APIs don't automatically protect you from security vulnerabilities.\nFor example, `document`, the node available through `ElementRef`, and many third-party APIs\ncontain unsafe methods. In the same way, if you interact with other libraries that manipulate\nthe DOM, you likely won't have the same automatic sanitization as with Angular interpolations.\nAvoid directly interacting with the DOM and instead use Angular templates where possible.\n\nFor cases where this is unavoidable, use the built-in Angular sanitization functions.\nSanitize untrusted values with the [DomSanitizer.sanitize](api/platform-browser/DomSanitizer#sanitize)\nmethod and the appropriate `SecurityContext`. That function also accepts values that were\nmarked as trusted using the `bypassSecurityTrust`... functions, and will not sanitize them,\nas [described below](#bypass-security-apis).\n-->\n<p>브라우저가 제공하는 DOM API는 기본적으로 보안 취약점을 검사하지 않습니다.\n그래서 <code><a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a></code>로 참조할 수 있는 <code>document</code> 노드나 서드 파티 API에는 보안에 취약한 메소드가 존재할 수 있습니다.\n그런데 노드와 라이브러리가 제공하는 API를 사용해서 DOM을 조작하면 Angular가 자동으로 처리했던 것과 같은 안전성 검사도 자동으로 실행되지 않습니다.\n따라서 DOM을 직접 조작하지 말고 Angular의 템플릿을 최대한 활용하는 것이 좋습니다.</p>\n<p>하지만 DOM을 직접 조작해야만 할 때는 Angular가 제공하는 안전성 검사 함수를 활용할 수도 있습니다.\n안전이 확인되지 않은 코드에 <a href=\"api/platform-browser/DomSanitizer#sanitize\">DomSanitizer.sanitize</a> 메소드를 사용하면 Angular가 자동으로 구성하는 것과 같은 <code><a href=\"api/core/SecurityContext\" class=\"code-anchor\">SecurityContext</a></code>를 구성할 수 있습니다.\n그리고 <a href=\"guide/security#bypass-security-apis\">아래에서 자세하게 설명하겠지만</a>, 이미 <code>bypassSecurityTrust...</code>와 같은 함수가 실행된 코드는 안전성 검사의 대상이 되지 않습니다.</p>\n<!--\n### Content security policy\n-->\n<h3 id=\"컨텐츠-보안-정책\">컨텐츠 보안 정책<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#컨텐츠-보안-정책\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nContent Security Policy (CSP) is a defense-in-depth\ntechnique to prevent XSS. To enable CSP, configure your web server to return an appropriate\n`Content-Security-Policy` HTTP header. Read more about content security policy at\n[An Introduction to Content Security Policy](http://www.html5rocks.com/en/tutorials/security/content-security-policy/)\non the HTML5Rocks website.\n-->\n<p>컨텐츠 보안 정책(Content Security Policy, CSP)은 XSS 공격을 근본적으로 방지하는 테크닉 중 하나입니다.\nCSP를 활성화하려면 웹서버가 응답을 반환할 때 HTTP 헤더에 <code>Content-Security-Policy</code>를 붙이도록 서버 설정을 변경해야 합니다.\n더 자세한 내용은 HTML5Rocks 웹사이트에서 제공하는 <a href=\"http://www.html5rocks.com/en/tutorials/security/content-security-policy/\">An Introduction to Content Security Policy</a> 문서를 참고하세요.</p>\n<a id=\"offline-template-compiler\"></a>\n<!--\n### Use the offline template compiler\n-->\n<h3 id=\"오프라인-템플릿-컴파일러를-사용하세요\">오프라인 템플릿 컴파일러를 사용하세요.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#오프라인-템플릿-컴파일러를-사용하세요\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe offline template compiler prevents a whole class of vulnerabilities called template injection,\nand greatly improves application performance. Use the offline template compiler in production\ndeployments; don't dynamically generate templates. Angular trusts template code, so generating\ntemplates, in particular templates containing user data, circumvents Angular's built-in protections.\nFor information about dynamically constructing forms in a safe way, see the\n[Dynamic Forms](guide/dynamic-form) guide page.\n-->\n<p>오프라인 템플릿 컴파일러를 사용하면 템플릿 인젝션이라고 부르는 취약점 공격을 근본적으로 방어할 수 있으며, 애플리케이션 실행 성능도 크게 개선할 수 있습니다.\n오프라인 템플릿 컴파일러는 템플릿을 동적으로 구성하지 않기 때문에 운영 모드에 사용하기도 좋습니다.\n오프라인 템플릿 컴파일러를 사용하면 템플릿 코드를 모두 안전한 코드인 것으로 간주하기 때문에 Angular가 자동으로 실행하는 보안 기능도 실행되지 않습니다.\n안전하게 동적 폼을 구성하는 방법에 대해 더 자세하게 알아보려면 <a href=\"guide/dynamic-form\">동적 폼</a> 가이드 문서를 참고하세요.</p>\n<!--\n### Server-side XSS protection\n-->\n<h3 id=\"서버에서-xss-공격-방어하기\">서버에서 XSS 공격 방어하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#서버에서-xss-공격-방어하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nHTML constructed on the server is vulnerable to injection attacks. Injecting template code into an\nAngular application is the same as injecting executable code into the\napplication: it gives the attacker full control over the application. To prevent this,\nuse a templating language that automatically escapes values to prevent XSS vulnerabilities on\nthe server. Don't generate Angular templates on the server side using a templating language; doing this\ncarries a high risk of introducing template-injection vulnerabilities.\n-->\n<p>서버에서 HTML을 구성하는 경우에도 템플릿 인젝션 공격에 대한 취약점이 존재합니다.\n템플릿 코드를 Angular 애플리케이션에 주입할 수 있다는 것은 이 애플리케이션에서 실행되는 코드를 애플리케이션 외부에서 주입할 수 있다는 것과 같습니다.\n이런 공격이 성공하면 공격자가 애플리케이션을 자유롭게 조작할 수 있습니다.\n그래서 이 공격을 막기 위해 서버에서도 XSS 취약점을 노리는 위험한 코드들을 제거해야 합니다.\n템플릿 인젝션 취약점을 근본적으로 방어하려면 서버에서 Angular 템플릿을 생성하지 않는 것이 좋습니다.</p>\n<h2 id=\"bypass-security-apis\">\n  <!--\n  Trusting safe values\n  -->\n  안전한 값으로 간주하기\n<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#bypass-security-apis\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nSometimes applications genuinely need to include executable code, display an `<iframe>` from some\nURL, or construct potentially dangerous URLs. To prevent automatic sanitization in any of these\nsituations, you can tell Angular that you inspected a value, checked how it was generated, and made\nsure it will always be secure. But *be careful*. If you trust a value that might be malicious, you\nare introducing a security vulnerability into your application. If in doubt, find a professional\nsecurity reviewer.\n\nTo mark a value as trusted, inject `DomSanitizer` and call one of the\nfollowing methods:\n-->\n<p>때로는 외부에서 실행할 수 있는 코드를 가져와서 애플리케이션에 사용해야 하는 경우가 있습니다.\nURL을 사용해서 <code>&#x3C;iframe></code>을 표시하거나 URL을 조합해서 활용하는 경우가 그렇습니다.\n이런 경우에는 이 코드가 정상적으로 생성되었고, 안전한 것으로 확인되었다고 처리해서 Angular가 자동으로 실행하는 안전성 검사를 우회해야 합니다.\n하지만 <em>조심하세요</em>.\n악성 코드를 안전한 것으로 간주하면 애플리케이션에 보안 취약점을 열어놓는 것이 됩니다.\n코드가 안전한 것인지 확실하지 않으면 보안 전문가에게 꼭 확인을 받으세요.</p>\n<p>코드를 안전한 것으로 간주하려면 <code><a href=\"api/platform-browser/DomSanitizer\" class=\"code-anchor\">DomSanitizer</a></code>를 의존성으로 주입해서 다음 메소드 중 하나를 실행하면 됩니다.</p>\n<ul>\n<li><code>bypassSecurityTrustHtml</code></li>\n<li><code>bypassSecurityTrustScript</code></li>\n<li><code>bypassSecurityTrustStyle</code></li>\n<li><code>bypassSecurityTrustUrl</code></li>\n<li><code>bypassSecurityTrustResourceUrl</code></li>\n</ul>\n<!--\nRemember, whether a value is safe depends on context, so choose the right context for\nyour intended use of the value. Imagine that the following template needs to bind a URL to a\n`javascript:alert(...)` call:\n-->\n<p>코드를 안전한 것으로 간주하려면 해당 컨텍스트에 어울리는 메소드를 실행해야 합니다.\n아래 템플릿 코드에서는 URL을 바인딩하는 부분이 있는데 이 URL에 <code>javaScript:alert(...)</code>과 같은 코드가 사용된다고 합시다.</p>\n<code-example path=\"security/src/app/bypass-security.component.html\" header=\"src/app/bypass-security.component.html (URL)\" region=\"URL\">\n&#x3C;h4>An untrusted URL:&#x3C;/h4>\n&#x3C;p>&#x3C;a class=\"e2e-dangerous-url\" [href]=\"dangerousUrl\">Click me&#x3C;/a>&#x3C;/p>\n&#x3C;h4>A trusted URL:&#x3C;/h4>\n&#x3C;p>&#x3C;a class=\"e2e-trusted-url\" [href]=\"trustedUrl\">Click me&#x3C;/a>&#x3C;/p>\n\n</code-example>\n<!--\nNormally, Angular automatically sanitizes the URL, disables the dangerous code, and\nin development mode, logs this action to the console. To prevent\nthis, mark the URL value as a trusted URL using the `bypassSecurityTrustUrl` call:\n-->\n<p>일반적으로 Angular는 URL을 대상으로 안전성 검사를 실행하기 때문에 <code>javascript:alert(...)</code>과 같이 위험한 코드는 자동으로 제거되며, 개발모드라면 콘솔에 경고 메시지가 출력됩니다.\n하지만 이 동작을 우회하려면 <code>bypassSecurityTrustUrl</code>을 실행해서 URL로 사용되는 코드가 안전하다는 것으로 체크하면 됩니다.</p>\n<code-example path=\"security/src/app/bypass-security.component.ts\" header=\"src/app/bypass-security.component.ts (trust-url)\" region=\"trust-url\">\nconstructor(private sanitizer: <a href=\"api/platform-browser/DomSanitizer\" class=\"code-anchor\">DomSanitizer</a>) {\n  // javscript: 와 같은 코드가 직접 실행되는 것은 위험합니다.\n  // 그래서 Angular는 이 코드를 데이터 바인딩할 때 자동으로 안전성 검사를 실행하지만,\n  // 이 코드를 안전한 것으로 간주하고 안전성 검사를 실행하지 않을 수도 있습니다.\n  this.dangerousUrl = 'javascript:alert(\"Hi there\")';\n  this.trustedUrl = sanitizer.bypassSecurityTrustUrl(this.dangerousUrl);\n\n</code-example>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/security/bypass-security-component.png\" alt=\"A screenshot showing an alert box created from a trusted URL\" width=\"454\" height=\"175\">\n</div>\n<!--\nIf you need to convert user input into a trusted value, use a\ncontroller method. The following template allows users to enter a YouTube video ID and load the\ncorresponding video in an `<iframe>`. The `<iframe src>` attribute is a resource URL security\ncontext, because an untrusted source can, for example, smuggle in file downloads that unsuspecting users\ncould execute. So call a method on the controller to construct a trusted video URL, which causes\nAngular to allow binding into `<iframe src>`:\n-->\n<p>사용자가 입력한 내용을 안전한 코드로 처리하려면 클래스 코드에 메소드를 정의해서 우회하면 됩니다.\n아래 코드에서는 사용자에게 YouTube 영상 ID를 입력받고 이 ID에 해당하는 영상을 <code>&#x3C;iframe></code>에 로드합니다.\n이 때 사용자가 입력하는 URL은 <code>&#x3C;iframe src></code> 어트리뷰트에 바인딩되어 실행되기 때문에, Angular는 이 URL이 위험할 수 있다고 판단하고 URL 컨텍스트로 안전성 검사를 실행합니다.\n안전성 검사를 실행하지 않으면 영상을 표시하지 않고 파일을 다운로드하게 할 수도 있기 때문에 위험합니다.\n이 때 사용자가 입력하는 영상의 URL이 언제나 안전하다고 생각하면 이 코드를 안전한 값으로 처리하는 메소드를 정의하고, 이 메소드가 처리한 URL을 <code>&#x3C;iframe src></code>에 활용할 수 있습니다.</p>\n<code-example path=\"security/src/app/bypass-security.component.html\" header=\"src/app/bypass-security.component.html (iframe)\" region=\"iframe\">\n&#x3C;h4>Resource URL:&#x3C;/h4>\n&#x3C;p>Showing: {{dangerousVideoUrl}}&#x3C;/p>\n&#x3C;p>Trusted:&#x3C;/p>\n&#x3C;iframe class=\"e2e-iframe-trusted-src\" width=\"640\" height=\"390\" [src]=\"videoUrl\">&#x3C;/iframe>\n&#x3C;p>Untrusted:&#x3C;/p>\n&#x3C;iframe class=\"e2e-iframe-untrusted-src\" width=\"640\" height=\"390\" [src]=\"dangerousVideoUrl\">&#x3C;/iframe>\n\n\n</code-example>\n<code-example path=\"security/src/app/bypass-security.component.ts\" header=\"src/app/bypass-security.component.ts (trust-video-url)\" region=\"trust-video-url\">\nupdateVideoUrl(id: string) {\n  // YouTube URL에 ID를 조합한 문자열은 안전한 URL입니다.\n  // 그렇다면 이렇게 조합된 URL은 언제나 안전하다고 간주하고 자동으로 실행되는 안전성 검사를 생략할 수 있습니다.\n  this.dangerousVideoUrl = 'https://www.youtube.com/embed/' + id;\n  this.videoUrl =\n      this.sanitizer.bypassSecurityTrustResourceUrl(this.dangerousVideoUrl);\n}\n\n</code-example>\n<h2 id=\"http\">\n  <!--\n  HTTP-level vulnerabilities\n  -->\n  HTTP 계층의 취약점\n<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#http\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAngular has built-in support to help prevent two common HTTP vulnerabilities, cross-site request\nforgery (CSRF or XSRF) and cross-site script inclusion (XSSI). Both of these must be mitigated primarily\non the server side, but Angular provides helpers to make integration on the client side easier.\n-->\n<p>Angular는 크로스 사이트 요청 위조(cross-site request forgery, CSRF, XSRF)나 크로스 사이트 스크립트 주입(cross-site script inclusion, XSSI)과 같은 HTTP 취약점을 자동으로 방어합니다.\n하지만 Angular가 제공하는 헬퍼는 클라이언트만을 위한 것이기 때문에 서버쪽에서도 반드시 취약점을 방어하는 설정을 추가해야 합니다.</p>\n<h3 id=\"xsrf\">\n  <!--\n  Cross-site request forgery\n  -->\n  크로스 사이트 요청 위조\n<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#xsrf\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn a cross-site request forgery (CSRF or XSRF), an attacker tricks the user into visiting\na different web page (such as `evil.com`) with malignant code that secretly sends a malicious request\nto the application's web server (such as `example-bank.com`).\n\nAssume the user is logged into the application at `example-bank.com`.\nThe user opens an email and clicks a link to `evil.com`, which opens in a new tab.\n\nThe `evil.com` page immediately sends a malicious request to `example-bank.com`.\nPerhaps it's a request to transfer money from the user's account to the attacker's account.\nThe browser automatically sends the `example-bank.com` cookies (including the authentication cookie) with this request.\n\nIf the `example-bank.com` server lacks XSRF protection, it can't tell the difference between a legitimate\nrequest from the application and the forged request from `evil.com`.\n\nTo prevent this, the application must ensure that a user request originates from the real\napplication, not from a different site.\nThe server and client must cooperate to thwart this attack.\n-->\n<p>크로스 사이트 요청 위조(cross-site request forgery, CSRF, XSRF)는 애플리케이션이 웹 서버(ex. <code>example-bank.com</code>)로 보내는 요청을 가로채서 다른 웹 페이지(ex. <code>evil.com</code>)로 보내거나 이 과정에 악성 코드를 실행하게 하는 공격 방식입니다.</p>\n<p>사용자가 <code>example-bank.com</code>에서 제공하는 애플리케이션에 로그인한 상태라고 합시다.\n이 때 사용자가 이메일을 열어서 <code>evil.com</code>로 향하는 링크를 클릭하면 새 탭에서 <code>evil.com</code> 페이지가 열릴 수 있습니다.</p>\n<p>이 때 <code>evil.com</code> 페이지는 즉시 <code>example-bank.com</code>으로 악성 요청을 보낸다고 합시다.\n이 요청은 사용자의 계좌에서 공격자의 계좌로 돈을 보내라는 요청이 될 수도 있습니다.\n브라우저 쿠키에 저장된 인증정보는 악의적으로 활용될 수 있습니다.</p>\n<p>만약 <code>example-bank.com</code> 서버가 XSRF 공격을 방어하지 않는다면 정상적인 애플리케이션에서 보낸 정상 요청인지, <code>evil.com</code>에서 요청한 악성 요청인지 구분할 수 없습니다.</p>\n<p>그래서 애플리케이션은 사용자가 보낸 요청이 정상 애플리케이션에서 보낸 것인지 꼭 확인해야 합니다.\n이런 공격은 서버와 클라이언트가 모두 대응해야 방어할 수 있습니다.</p>\n<!--\nIn a common anti-XSRF technique, the application server sends a randomly\ngenerated authentication token in a cookie.\nThe client code reads the cookie and adds a custom request header with the token in all subsequent requests.\nThe server compares the received cookie value to the request header value and rejects the request if the values are missing or don't match.\n\nThis technique is effective because all browsers implement the _same origin policy_. Only code from the website\non which cookies are set can read the cookies from that site and set custom headers on requests to that site.\nThat means only your application can read this cookie token and set the custom header. The malicious code on `evil.com` can't.\n\nAngular's `HttpClient` has built-in support for the client-side half of this technique. Read about it more in the [HttpClient guide](/guide/http#security-xsrf-protection).\n\nFor information about CSRF at the Open Web Application Security Project (OWASP), see\n<a href=\"https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29\">Cross-Site Request Forgery (CSRF)</a> and\n<a href=\"https://www.owasp.org/index.php/CSRF_Prevention_Cheat_Sheet\">Cross-Site Request Forgery (CSRF) Prevention Cheat Sheet</a>.\nThe Stanford University paper\n<a href=\"https://seclab.stanford.edu/websec/csrf/csrf.pdf\">Robust Defenses for Cross-Site Request Forgery</a> is a rich source of detail.\n\nSee also Dave Smith's easy-to-understand\n<a href=\"https://www.youtube.com/watch?v=9inczw6qtpY\" title=\"Cross Site Request Funkery Securing Your Angular Apps From Evil Doers\">talk on XSRF at AngularConnect 2016</a>.\n-->\n<p>일반적으로 XSRF 공격을 방어하려면 애플리케이션 서버가 무작위로 생성한 인증 토큰을 쿠키에 저장해두고, 이후에 요청을 보낼 때 이 토큰을 헤더에 포함하도록 하면 됩니다.\n그리고 서버는 클라이언트가 보낸 요청을 받았을 때 이 토큰이 존재하는지, 정상적으로 생성된 토큰인지 확인해야 합니다.</p>\n<p>브라우저는 모두 <em>동일 근원 정책(same origin policy)</em> 을 준수하기 때문에 이 방법을 사용할 수 있습니다.\n왜냐하면 쿠키를 저장한 웹사이트에서만 이 쿠키를 읽을 수 있고, 요청 헤더에 커스텀 헤더로 추가할 수 있기 때문입니다.\n따라서 쿠키를 저장한 애플리케이션만 이 쿠키를 읽을 수 있고 커스텀 헤더를 추가할 수 있습니다.\n<code>evil.com</code>가 실행하는 악성 코드는 이 쿠키에 접근할 수 없습니다.</p>\n<p>Angular가 제공하는 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>도 이 방식을 활용합니다.\n자세한 내용은 <a href=\"/guide/http\">HttpClient 가이드 문서</a>를 참고하세요.</p>\n<p>Open Web Application Security Project (OWASP)에서 제공하는 CSRF 방어 방법에 대해 알아보려면 <a href=\"https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29\">Cross-Site Request Forgery (CSRF)</a>나 <a href=\"https://www.owasp.org/index.php/CSRF_Prevention_Cheat_Sheet\">Cross-Site Request Forgery (CSRF) Prevention Cheat Sheet</a> 문서를 참고하세요.\n<a href=\"https://seclab.stanford.edu/websec/csrf/csrf.pdf\">Robust Defenses for Cross-Site Request Forgery</a>에도 자세하게 설명되어 있습니다.</p>\n<p><a href=\"https://www.youtube.com/watch?v=9inczw6qtpY\" title=\"Cross Site Request Funkery Securing Your Angular Apps From Evil Doers\">Dave Smith가 AngularConnect 2016에서 발표한 XSRF에 대한 이야기</a>도 도움이 될 것입니다.</p>\n<h3 id=\"xssi\">\n  <!--\n  Cross-site script inclusion (XSSI)\n  -->\n  크로스 사이트 스크립트 주입\n<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#xssi\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nCross-site script inclusion, also known as JSON vulnerability, can allow an attacker's website to\nread data from a JSON API. The attack works on older browsers by overriding native JavaScript\nobject constructors, and then including an API URL using a `<script>` tag.\n\nThis attack is only successful if the returned JSON is executable as JavaScript. Servers can\nprevent an attack by prefixing all JSON responses to make them non-executable, by convention, using the\nwell-known string `\")]}',\\n\"`.\n\nAngular's `HttpClient` library recognizes this convention and automatically strips the string\n`\")]}',\\n\"` from all responses before further parsing.\n\nFor more information, see the XSSI section of this [Google web security blog\npost](https://security.googleblog.com/2011/05/website-security-for-webmasters.html).\n-->\n<p>크로스 사이트 스크립트 주입, JSON 취약점이라고도 알려져 있는 이 취약점을 활용하면 공격자가 JSON API를 활용해서 데이터를 탈취할 수 있습니다.\n이 공격은 오래된 브라우저에서 JavaScript 객체 생성자를 오버라이드한 다음 <code>&#x3C;script></code> 태그를 활용하는 방식으로 동작합니다.</p>\n<p>이 공격은 응답으로 받은 JSON 객체가 JavaScript로 실행될 때만 가능합니다.\n그래서 서버는 JSON 응답을 보낼 때 반드시 실행되지 않도록 처리해야 하는데, 이 때 보통 <code>\")]}',\\n\"</code>라는 문자열을 활용합니다.</p>\n<p>Angular가 제공하는 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 라이브러리도 이 방식을 사용하며, 응답을 파싱한 뒤에는 <code>\")]}',\\n\"</code> 문자열을 자동으로 제거합니다.</p>\n<p>더 자세한 내용은 <a href=\"https://security.googleblog.com/2011/05/website-security-for-webmasters.html\">Google web security blog\npost</a>의 XSSI 섹션을 참고하세요.</p>\n<h2 id=\"code-review\">\n  <!--\n  Auditing Angular applications\n  -->\n  Angular 애플리케이션 검증하기\n<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#code-review\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAngular applications must follow the same security principles as regular web applications, and\nmust be audited as such. Angular-specific APIs that should be audited in a security review,\nsuch as the [_bypassSecurityTrust_](guide/security#bypass-security-apis) methods, are marked in the documentation\nas security sensitive.\n-->\n<p>Angular 애플리케이션은 반드시 일반적인 웹 애플리케이션이 준수하는 보안 정책을 준수해야 하며, 애플리케이션을 검증할 때도 이 정책을 기준으로 해야 합니다.\n그래서 <a href=\"guide/security#bypass-security-apis\"><em>bypassSecurityTrust</em></a> 메소드와 같이 Angular에서만 제공하는 API라면 반드시 보안 취약점을 확인해야 하며, API 문서에도 보안 취약점이 존재할 수 있다고 경고하고 있습니다.</p>\n\n</div>\n\n<!-- links to this doc:\n - guide/architecture-next-steps\n - guide/example-apps-list\n - guide/property-binding\n - guide/template-syntax\n-->\n<!-- links from this doc:\n - /guide/http\n - api/animations/style\n - api/common/http/HttpClient\n - api/core/ElementRef\n - api/core/SecurityContext\n - api/platform-browser/DomSanitizer\n - api/platform-browser/DomSanitizer#sanitize\n - guide/dynamic-form\n - guide/security#angular의-xss-방어-모델\n - guide/security#best-practices\n - guide/security#bypass-security-apis\n - guide/security#code-review\n - guide/security#dom-api를-직접-사용하는-경우와-명시적으로-안전성-검사를-실행하는-경우\n - guide/security#http\n - guide/security#offline-template-compiler\n - guide/security#report-issues\n - guide/security#xsrf\n - guide/security#xss\n - guide/security#xssi\n - guide/security#보안\n - guide/security#서버에서-xss-공격-방어하기\n - guide/security#안전성-검사-예제\n - guide/security#오프라인-템플릿-컴파일러를-사용하세요\n - guide/security#컨텐츠-보안-정책\n - guide/security#코드-안전성-검사와-보안-영역\n - http://www.html5rocks.com/en/tutorials/security/content-security-policy/\n - https://en.wikipedia.org/wiki/Cross-site_scripting\n - https://github.com/angular/angular/blob/master/CHANGELOG.md\n - https://github.com/angular/angular/edit/master/aio/content/guide/security.md?message=docs%3A%20describe%20your%20change...\n - https://seclab.stanford.edu/websec/csrf/csrf.pdf\n - https://security.googleblog.com/2011/05/website-security-for-webmasters.html\n - https://www.google.com/about/appsecurity/\n - https://www.owasp.org/index.php/CSRF_Prevention_Cheat_Sheet\n - https://www.owasp.org/index.php/Category:OWASP_Guide_Project\n - https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29\n - https://www.youtube.com/watch?v=9inczw6qtpY\n - mailto:security@angular.io\n-->"
}