{
  "id": "guide/schematics-for-libraries",
  "title": "라이브러리용 스키매틱",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/schematics-for-libraries.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Schematics for libraries\n-->\n<h1 id=\"라이브러리용-스키매틱\">라이브러리용 스키매틱<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-for-libraries#라이브러리용-스키매틱\"><i class=\"material-icons\">link</i></a></h1>\n<!--\nWhen you create an Angular library, you can provide and package it with schematics that integrate it with the Angular CLI.\nWith your schematics, your users can use `ng add` to install an initial version of your library,\n`ng generate` to create artifacts defined in your library, and `ng update` to adjust their project for a new version of your library that introduces breaking changes.\n\nAll three types of schematics can be part of a collection that you package with your library.\n\nDownload the <live-example downloadOnly>library schematics project</live-example> for a completed example of the steps below.\n-->\n<p>Angular 라이브러리는 Angular CLI와 통합하는 스키매틱을 함께 제공할 수 있습니다.\n이 방법을 활용하면 사용자가 <code>ng add</code> 명령을 사용해서 라이브러리를 설치할 수 있고, <code>ng generate</code> 명령을 사용해서 라이브러리가 제공하는 Angular 구성요소를 생성할 수 있으며, <code>ng update</code>를 사용해서 라이브러리 버전을 업데이트하면서 필요한 수정사항을 자동으로 처리할 수 있습니다.</p>\n<p>그리고 세 종류의 스키매틱은 컬렉션 하나로 묶어서 라이브러리와 함께 배포할 수 있습니다.</p>\n<p>이 문서에서 설명하는 내용은 <live-example downloadonly=\"\">library schematics project</live-example>를 직접 내려받아서 확인해보세요.</p>\n<!--\n## Creating a schematics collection\n-->\n<h2 id=\"스키매틱-컬렉션-만들기\">스키매틱 컬렉션 만들기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-for-libraries#스키매틱-컬렉션-만들기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nTo start a collection, you need to create the schematic files.\nThe following steps show you how to add initial support without modifying any project files.\n\n1. In your library's root folder, create a `schematics/`  folder.\n\n1. In the `schematics/` folder, create an `ng-add/` folder for your first schematic.\n\n1. At the root level of the `schematics/` folder, create a `collection.json` file.\n\n1. Edit the `collection.json` file to define the initial schema for your collection.\n\n<code-example header=\"projects/my-lib/schematics/collection.json (Schematics Collection)\" path=\"schematics-for-libraries/projects/my-lib/schematics/collection.1.json\">\n{\n  &quot;$schema&quot;: &quot;../../../node_modules/@angular-devkit/schematics/collection-schema.json&quot;,\n  &quot;schematics&quot;: {\n    &quot;ng-add&quot;: {\n      &quot;description&quot;: &quot;Add my library to the project.&quot;,\n      &quot;factory&quot;: &quot;./ng-add/index#ngAdd&quot;\n    }\n  }\n}\n\n</code-example>\n\n  * The `$schema` path is relative to the Angular Devkit collection schema.\n  * The `schematics` object describes the named schematics that are part of this collection.\n  * The first entry is for a schematic named `ng-add`. It contains the description, and points to the factory function that is called when your schematic is executed.\n\n1. In your library project's `package.json` file, add a \"schematics\" entry with the path to your schema file.\n   The Angular CLI uses this entry to find named schematics in your collection when it runs commands.\n\n<code-example header=\"projects/my-lib/package.json (Schematics Collection Reference)\" path=\"schematics-for-libraries/projects/my-lib/package.json\" region=\"collection\">\n{\n  &quot;name&quot;: &quot;my-lib&quot;,\n  &quot;version&quot;: &quot;0.0.1&quot;,\n  &quot;schematics&quot;: &quot;./schematics/collection.json&quot;\n}\n\n</code-example>\n\nThe initial schema that you have created tells the CLI where to find the schematic that supports the `ng add` command.\nNow you are ready to create that schematic.\n-->\n<p>컬렉션을 만들기 전에 먼저 스키매틱 파일을 만들어야 합니다.\n다음 순서대로 진행하면 프로젝트 파일은 건드리지 않으면서 스키매틱을 만들 수 있습니다.</p>\n<ol>\n<li>\n<p>라이브러리 최상위 폴더 아래에 <code>schematics</code> 폴더를 생성합니다.</p>\n</li>\n<li>\n<p><code>schematics</code> 폴더에 첫번째 스키매틱으로 사용할 <code>ng-add</code> 폴더를 생성합니다.</p>\n</li>\n<li>\n<p><code>schematics</code> 폴더에 <code>collection.json</code> 파일을 생성합니다.</p>\n</li>\n<li>\n<p><code>collection.json</code> 파일의 내용을 다음과 같이 작성합니다.</p>\n</li>\n</ol>\n<code-example header=\"projects/my-lib/schematics/collection.json (스키매틱 컬렉션)\" path=\"schematics-for-libraries/projects/my-lib/schematics/collection.1.json\">\n{\n  \"$schema\": \"../../../node_modules/@angular-devkit/schematics/collection-schema.json\",\n  \"schematics\": {\n    \"ng-add\": {\n      \"description\": \"Add my library to the project.\",\n      \"factory\": \"./ng-add/index#ngAdd\"\n    }\n  }\n}\n\n</code-example>\n<ul>\n<li><code>$schema</code>는 Angular Devkit 컬렉션 스키마를 가리키는 상대주소입니다.</li>\n<li><code>schematics</code> 객체에는 컬렉션에 추가할 스키매틱을 지정합니다.</li>\n<li>첫번째로 추가된 스키매틱은 <code>ng-add</code> 스키매틱입니다. 이 스키매틱 객체에는 스키매틱에 대한 설명과 스키매틱이 실행될 때 진입점이 될 팩토리 함수를 지정합니다.</li>\n</ul>\n<ol start=\"5\">\n<li>라이브러리 프로젝트의 <code>package.json</code> 파일에 \"schematics\"를 추가하고 위에서 작성한 스키마 파일의 경로를 지정합니다.\n그러면 Angular CLI가 이 스키마 파일의 내용을 추가하며 확장됩니다.</li>\n</ol>\n<code-example header=\"projects/my-lib/package.json (스키매틱 컬렉션 참조)\" path=\"schematics-for-libraries/projects/my-lib/package.json\" region=\"collection\">\n{\n  \"name\": \"my-lib\",\n  \"version\": \"0.0.1\",\n  \"schematics\": \"./schematics/collection.json\"\n}\n\n</code-example>\n<p>지금까지 작성한 내용은 이 라이브러리가 <code>ng add</code> 스키매틱을 제공한다는 것을 Angular CLI에게 알려주기 위한 것입니다.\n이제 스키매틱 로직을 작성해 봅시다.</p>\n<!--\n## Providing installation support\n-->\n<h2 id=\"라이브러리-설치-로직-작성하기\">라이브러리 설치 로직 작성하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-for-libraries#라이브러리-설치-로직-작성하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nA schematic for the `ng add` command can enhance the initial installation process for your users.\nThe following steps will define this type of schematic.\n\n1. Go to the <lib-root>/schematics/ng-add/ folder.\n\n1. Create the main file, `index.ts`.\n\n1. Open `index.ts` and add the source code for your schematic factory function.\n\n<code-example header=\"projects/my-lib/schematics/ng-add/index.ts (ng-add Rule Factory)\" path=\"schematics-for-libraries/projects/my-lib/schematics/ng-add/index.ts\">\nimport { Rule, SchematicContext, Tree } from &#39;@angular-devkit/schematics&#39;;\nimport { NodePackageInstallTask } from &#39;@angular-devkit/schematics/tasks&#39;;\n\n// 트리를 그대로 반환합니다.\nexport function ngAdd(_options: any): Rule {\n  return (tree: Tree, _context: SchematicContext) =&gt; {\n    _context.addTask(new NodePackageInstallTask());\n    return tree;\n  };\n}\n\n\n</code-example>\n\nThe only step needed to provide initial `ng add` support is to trigger an installation task using the `SchematicContext`.\nThe task uses the user's preferred package manager to add the library to the project's `package.json` configuration file, and install it in the project’s `node_modules` directory.\n\nIn this example, the function receives the current `Tree` and returns it without any modifications.\nIf you need to, you can do additional setup when your package is installed, such as generating files, updating configuration, or any other initial setup your library requires.\n-->\n<p><code>ng add</code> 스키매틱을 정의하면 라이브러리 설치 과정을 확장할 수 있습니다.\n다음 순서로 진행해 봅시다.</p>\n<ol>\n<li>\n<p>&#x3C;라이브러리-최상위-폴더>/schematics/ng-add/ 폴더로 이동합니다.</p>\n</li>\n<li>\n<p>메인 파일 <code>index.ts</code>를 만듭니다.</p>\n</li>\n<li>\n<p><code>index.ts</code> 파일을 열고 다음 내용으로 스키매틱 팩토리 함수를 정의합니다.</p>\n</li>\n</ol>\n<code-example header=\"projects/my-lib/schematics/ng-add/index.ts (ng-add 룰 팩토리)\" path=\"schematics-for-libraries/projects/my-lib/schematics/ng-add/index.ts\">\nimport { Rule, SchematicContext, Tree } from '@angular-devkit/schematics';\nimport { NodePackageInstallTask } from '@angular-devkit/schematics/tasks';\n\n// 트리를 그대로 반환합니다.\nexport function ngAdd(_options: any): Rule {\n  return (tree: Tree, _context: SchematicContext) => {\n    _context.addTask(new NodePackageInstallTask());\n    return tree;\n  };\n}\n\n\n</code-example>\n<p><code>ng add</code> 스키매틱에 필요한 것은 <code>SchematicContext</code>를 활용해서 설치 작업을 시작하는 것 뿐입니다.\n그러면 사용자가 설정한 기본 패키지 매니저로 <code>node_modules</code> 폴더에 라이브러리를 설치하며, 프로젝트에 있는 <code>package.json</code> 설정 파일을 수정합니다.</p>\n<p>위에서 작성한 예제 코드는 <code>Tree</code> 객체를 받지만 이 객체를 수정하지 않고 그대로 반환합니다.\n필요하다면 라이브러리 패키지를 설치한 이후에 어떤 파일을 생성한다던지, 환경설정 파일을 수정한다던지, 라이브러리 초기화 작업을 실행할 수 있습니다.</p>\n<!--\n## Building your schematics\n-->\n<h2 id=\"스키매틱-빌드하기\">스키매틱 빌드하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-for-libraries#스키매틱-빌드하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nTo bundle your schematics together with your library, you must configure the library to build the schematics separately, then add them to the bundle.\nYou must build your schematics *after* you build your library, so they are placed in the correct directory.\n\n* Your library needs a custom Typescript configuration file with instructions on how to compile your schematics into your distributed library.\n\n* To add the schematics to the library bundle, add scripts to the library's `package.json` file.\n\nAssume you have a library project `my-lib` in your Angular workspace.\nTo tell the library how to build the schematics, add a `tsconfig.schematics.json` file next to the generated `tsconfig.lib.json` file that configures the library build.\n\n1. Edit the `tsconfig.schematics.json` file to add the following content.\n\n<code-example header=\"projects/my-lib/tsconfig.schematics.json (TypeScript Config)\" path=\"schematics-for-libraries/projects/my-lib/tsconfig.schematics.json\">\n{\n  &quot;compilerOptions&quot;: {\n    &quot;baseUrl&quot;: &quot;.&quot;,\n    &quot;lib&quot;: [\n      &quot;es2018&quot;,\n      &quot;dom&quot;\n    ],\n    &quot;declaration&quot;: true,\n    &quot;module&quot;: &quot;commonjs&quot;,\n    &quot;moduleResolution&quot;: &quot;node&quot;,\n    &quot;noEmitOnError&quot;: true,\n    &quot;noFallthroughCasesInSwitch&quot;: true,\n    &quot;noImplicitAny&quot;: true,\n    &quot;noImplicitThis&quot;: true,\n    &quot;noUnusedParameters&quot;: true,\n    &quot;noUnusedLocals&quot;: true,\n    &quot;rootDir&quot;: &quot;schematics&quot;,\n    &quot;outDir&quot;: &quot;../../dist/my-lib/schematics&quot;,\n    &quot;skipDefaultLibCheck&quot;: true,\n    &quot;skipLibCheck&quot;: true,\n    &quot;sourceMap&quot;: true,\n    &quot;strictNullChecks&quot;: true,\n    &quot;target&quot;: &quot;es6&quot;,\n    &quot;types&quot;: [\n      &quot;jasmine&quot;,\n      &quot;node&quot;\n    ]\n  },\n  &quot;include&quot;: [\n    &quot;schematics/**/*&quot;\n  ],\n  &quot;exclude&quot;: [\n    &quot;schematics/*/files/**/*&quot;\n  ]\n}\n\n</code-example>\n\n  * The `rootDir` specifies that your `schematics/` folder contains the input files to be compiled.\n\n  * The `outDir` maps to the library's output folder. By default, this is the `dist/my-lib` folder at the root of your workspace.\n\n1. To make sure your schematics source files get compiled into the library bundle, add the following scripts to the `package.json` file in your library project's root folder (`projects/my-lib`).\n\n<code-example header=\"projects/my-lib/package.json (Build Scripts)\" path=\"schematics-for-libraries/projects/my-lib/package.json\">\n{\n  &quot;name&quot;: &quot;my-lib&quot;,\n  &quot;version&quot;: &quot;0.0.1&quot;,\n  &quot;scripts&quot;: {\n    &quot;build&quot;: &quot;../../node_modules/.bin/tsc -p tsconfig.schematics.json&quot;,\n    &quot;copy:schemas&quot;: &quot;cp --parents schematics/*/schema.json ../../dist/my-lib/&quot;,\n    &quot;copy:files&quot;: &quot;cp --parents -p schematics/*/files/** ../../dist/my-lib/&quot;,\n    &quot;copy:collection&quot;: &quot;cp schematics/collection.json ../../dist/my-lib/schematics/collection.json&quot;,\n    &quot;postbuild&quot;: &quot;npm run copy:schemas &amp;&amp; npm run copy:files &amp;&amp; npm run copy:collection&quot;\n  },\n  &quot;peerDependencies&quot;: {\n    &quot;@angular/common&quot;: &quot;^7.2.0&quot;,\n    &quot;@angular/core&quot;: &quot;^7.2.0&quot;\n  },\n  &quot;schematics&quot;: &quot;./schematics/collection.json&quot;\n}\n\n</code-example>\n\n  * The `build` script compiles your schematic using the custom `tsconfig.schematics.json` file.\n  * The `copy:*` statements copy compiled schematic files into the proper locations in the library output folder in order to preserve the file structure.\n  * The `postbuild` script copies the schematic files after the `build` script completes.\n-->\n<p>스키매틱을 라이브러리와 함께 빌드하려면 기존 빌드 설정에 스키매틱 빌드 과정을 추가해야 합니다.\n이 때 스키매틱은 라이브러리를 빌드한 <em>후에</em> 빌드해야 원하는 위치에 제대로 생성할 수 있습니다.</p>\n<ul>\n<li>\n<p>스키매틱을 라이브러리 안으로 통합하려면 스키매틱을 어떻게 컴파일해야 하는지 지정하는 TypeScript 설정이 필요합니다.</p>\n</li>\n<li>\n<p>라이브러리 <code>package.json</code> 파일에 스키매틱을 추가하는 스크립트를 작성해야 합니다.</p>\n</li>\n</ul>\n<p>Angular 워크스페이스에 <code>my-lib</code> 라이브러리 프로젝트가 있다고 합시다.\n그러면 스키매틱을 빌드하기 위해 라이브러리 빌드 설정 파일인 <code>tsconfig.lib.json</code> 파일과 같은 위치에 <code>tsconfig.schematics.json</code> 파일을 추가해야 합니다.</p>\n<ol>\n<li><code>tsconfig.schematics.json</code> 파일의 내용을 다음과 같이 작성합니다.</li>\n</ol>\n<code-example header=\"projects/my-lib/tsconfig.schematics.json (TypeScript 환경 설정)\" path=\"schematics-for-libraries/projects/my-lib/tsconfig.schematics.json\">\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"lib\": [\n      \"es2018\",\n      \"dom\"\n    ],\n    \"declaration\": true,\n    \"module\": \"commonjs\",\n    \"moduleResolution\": \"node\",\n    \"noEmitOnError\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"noImplicitAny\": true,\n    \"noImplicitThis\": true,\n    \"noUnusedParameters\": true,\n    \"noUnusedLocals\": true,\n    \"rootDir\": \"schematics\",\n    \"outDir\": \"../../dist/my-lib/schematics\",\n    \"skipDefaultLibCheck\": true,\n    \"skipLibCheck\": true,\n    \"sourceMap\": true,\n    \"strictNullChecks\": true,\n    \"target\": \"es6\",\n    \"types\": [\n      \"jasmine\",\n      \"node\"\n    ]\n  },\n  \"include\": [\n    \"schematics/**/*\"\n  ],\n  \"exclude\": [\n    \"schematics/*/files/**/*\"\n  ]\n}\n\n</code-example>\n<ul>\n<li>\n<p>스키매틱에 있는 파일을 모두 컴파일해야 하기 때문에 <code>rootDir</code>은 <code>schematics</code> 폴더로 지정합니다.</p>\n</li>\n<li>\n<p><code>outDir</code>은 라이브러리가 빌드되는 폴더로 지정합니다. 기본값은 워크스페이스 최상위 폴더를 기준으로 <code>dist/my-lib</code>입니다.</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>그리고 스키매틱 소스 파일을 라이브러리 번들 결과물에 포함하기 위해 라이브러리 프로젝트의 최상위 폴더 <code>projects/my-lib</code>에 있는 <code>package.json</code> 파일에 다음 스크립트를 추가합니다.</li>\n</ol>\n<code-example header=\"projects/my-lib/package.json (빌드 스크립트)\" path=\"schematics-for-libraries/projects/my-lib/package.json\">\n{\n  \"name\": \"my-lib\",\n  \"version\": \"0.0.1\",\n  \"scripts\": {\n    \"build\": \"../../node_modules/.bin/tsc -p tsconfig.schematics.json\",\n    \"copy:schemas\": \"cp --parents schematics/*/schema.json ../../dist/my-lib/\",\n    \"copy:files\": \"cp --parents -p schematics/*/files/** ../../dist/my-lib/\",\n    \"copy:collection\": \"cp schematics/collection.json ../../dist/my-lib/schematics/collection.json\",\n    \"postbuild\": \"npm run copy:schemas &#x26;&#x26; npm run copy:files &#x26;&#x26; npm run copy:collection\"\n  },\n  \"peerDependencies\": {\n    \"@angular/common\": \"^7.2.0\",\n    \"@angular/core\": \"^7.2.0\"\n  },\n  \"schematics\": \"./schematics/collection.json\"\n}\n\n</code-example>\n<ul>\n<li><code>build</code> 스크립트는 <code>tsconfig.schematics.json</code> 파일을 사용해서 스키매틱을 빌드하는 스크립트입니다.</li>\n<li><code>copy:*</code> 스크립트는 컴파일된 스키매틱 파일을 라이브러리가 빌드된 폴더로 복사하는 스크립트입니다.</li>\n<li><code>postbuild</code> 스크립트는 <code>build</code> 스크립트를 실행한 후에 빌드된 스키매틱 파일을 복사하는 스크립트입니다.</li>\n</ul>\n<!--\n## Providing generation support\n-->\n<h2 id=\"생성generation-기능-제공하기\">생성(generation) 기능 제공하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-for-libraries#생성generation-기능-제공하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nYou can add a named schematic to your collection that lets your users use the `ng generate` command to create an artifact that is defined in your library.\n\nWe'll assume that your library defines a service, `my-service`, that requires some setup. You want your users to be able to generate it using the following CLI command.\n\n<code-example language=\"bash\">\nng generate my-lib:my-service\n</code-example>\n\nTo begin, create a new subfolder, `my-service`, in the `schematics` folder.\n-->\n<p><code>ng generate</code> 스키매틱을 정의하면 라이브러리가 제공하는 컴포넌트나 서비스를 간단하게 생성할 수 있습니다.</p>\n<p>라이브러리가 <code>my-service</code>라는 서비스를 제공하는데 이 서비스를 생성하려면 몇가지를 설정해야 한다고 합시다.\n이런 생성 과정을 간단하게 처리하기 위해 Angular CLI 명령으로 다음과 같이 사용하려고 합니다.</p>\n<code-example language=\"bash\">\nng generate my-lib:my-service\n</code-example>\n<p><code>schematics</code> 폴더에 <code>my-service</code> 폴더를 만드는 것부터 시작해 봅시다.</p>\n<!--\n### Configure the new schematic\n-->\n<h3 id=\"스키매틱-추가하기\">스키매틱 추가하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-for-libraries#스키매틱-추가하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nWhen you add a schematic to the collection, you have to point to it in the collection's schema, and provide configuration files to define options that a user can pass to the command.\n\n1. Edit the `schematics/collection.json` file to point to the new schematic subfolder, and include a pointer to a schema file that will specify inputs for the new schematic.\n\n<code-example header=\"projects/my-lib/schematics/collection.json (Schematics Collection)\" path=\"schematics-for-libraries/projects/my-lib/schematics/collection.json\">\n{\n  &quot;$schema&quot;: &quot;../../../node_modules/@angular-devkit/schematics/collection-schema.json&quot;,\n  &quot;schematics&quot;: {\n    &quot;ng-add&quot;: {\n      &quot;description&quot;: &quot;Add my library to the project.&quot;,\n      &quot;factory&quot;: &quot;./ng-add/index#ngAdd&quot;\n    },\n    &quot;my-service&quot;: {\n      &quot;description&quot;: &quot;Generate a service in the project.&quot;,\n      &quot;factory&quot;: &quot;./my-service/index#myService&quot;,\n      &quot;schema&quot;: &quot;./my-service/schema.json&quot;\n    }\n  }\n}\n\n</code-example>\n\n1. Go to the `<lib-root>/schematics/my-service/` folder.\n\n1. Create a `schema.json` file and define the available options for the schematic.\n\n<code-example header=\"projects/my-lib/schematics/my-service/schema.json (Schematic JSON Schema)\" path=\"schematics-for-libraries/projects/my-lib/schematics/my-service/schema.json\">\n{\n  &quot;$schema&quot;: &quot;http://json-schema.org/schema&quot;,\n  &quot;id&quot;: &quot;SchematicsMyService&quot;,\n  &quot;title&quot;: &quot;My Service Schema&quot;,\n  &quot;type&quot;: &quot;object&quot;,\n  &quot;properties&quot;: {\n    &quot;name&quot;: {\n      &quot;description&quot;: &quot;The name of the service.&quot;,\n      &quot;type&quot;: &quot;string&quot;\n    },\n    &quot;path&quot;: {\n      &quot;type&quot;: &quot;string&quot;,\n      &quot;format&quot;: &quot;path&quot;,\n      &quot;description&quot;: &quot;The path to create the service.&quot;,\n      &quot;visible&quot;: false\n    },\n    &quot;project&quot;: {\n      &quot;type&quot;: &quot;string&quot;,\n      &quot;description&quot;: &quot;The name of the project.&quot;,\n      &quot;$default&quot;: {\n        &quot;$source&quot;: &quot;projectName&quot;\n      }\n    }\n   },\n  &quot;required&quot;: [\n    &quot;name&quot;\n  ]\n}\n\n</code-example>\n\n  * *id*: A unique id for the schema in the collection.\n  * *title*: A human-readable description of the schema.\n  * *type*: A descriptor for the type provided by the properties.\n  * *properties*: An object that defines the available options for the schematic.\n\n  Each option associates key with a type, description, and optional alias.\n  The type defines the shape of the value you expect, and the description is displayed when the user requests usage help for your schematic.\n\n  See the workspace schema for additional customizations for schematic options.\n\n1. Create a `schema.ts` file and define an interface that stores the values of the options defined in the `schema.json` file.\n\n<code-example header=\"projects/my-lib/schematics/my-service/schema.ts (Schematic Interface)\" path=\"schematics-for-libraries/projects/my-lib/schematics/my-service/schema.ts\">\nexport interface Schema {\n  // 서비스 이름\n  name: string;\n\n  // 서비스 생성 위치\n  path?: string;\n\n  // 프로젝트 이름\n  project?: string;\n}\n\n\n</code-example>\n\n  * *name*: The name you want to provide for the created service.\n  * *path*: Overrides the path provided to the schematic. The default path value is based on the current working directory.\n  * *project*: Provides a specific project to run the schematic on. In the schematic, you can provide a default if the option is not provided by the user.\n-->\n<p>컬렉션에 스키매틱을 추가하고 나면 컬렉션 스키마에 이 스키매틱을 추가해야 합니다.\n그리고나서 사용자로 부터 받을 입력값을 스키마 파일로 정의해야 합니다.</p>\n<ol>\n<li><code>schematics/collection.json</code> 파일을 열고 새로 만든 스키매틱 폴더를 지정합니다. 이 때 스키매틱 입력값을 정의하는 스키마 파일도 함께 지정합니다.</li>\n</ol>\n<code-example header=\"projects/my-lib/schematics/collection.json (스키매틱 컬렉션)\" path=\"schematics-for-libraries/projects/my-lib/schematics/collection.json\">\n{\n  \"$schema\": \"../../../node_modules/@angular-devkit/schematics/collection-schema.json\",\n  \"schematics\": {\n    \"ng-add\": {\n      \"description\": \"Add my library to the project.\",\n      \"factory\": \"./ng-add/index#ngAdd\"\n    },\n    \"my-service\": {\n      \"description\": \"Generate a service in the project.\",\n      \"factory\": \"./my-service/index#myService\",\n      \"schema\": \"./my-service/schema.json\"\n    }\n  }\n}\n\n</code-example>\n<ol>\n<li>\n<p><code>&#x3C;lib-root>/schematics/my-service</code> 폴더로 이동합니다.</p>\n</li>\n<li>\n<p><code>shcema.json</code> 파일을 열고 스키매틱 입력값을 정의합니다.</p>\n</li>\n</ol>\n<code-example header=\"projects/my-lib/schematics/my-service/schema.json (스키매틱 JSON 스키마)\" path=\"schematics-for-libraries/projects/my-lib/schematics/my-service/schema.json\">\n{\n  \"$schema\": \"http://json-schema.org/schema\",\n  \"id\": \"SchematicsMyService\",\n  \"title\": \"My Service Schema\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"name\": {\n      \"description\": \"The name of the service.\",\n      \"type\": \"string\"\n    },\n    \"path\": {\n      \"type\": \"string\",\n      \"format\": \"path\",\n      \"description\": \"The path to create the service.\",\n      \"visible\": false\n    },\n    \"project\": {\n      \"type\": \"string\",\n      \"description\": \"The name of the project.\",\n      \"$default\": {\n        \"$source\": \"projectName\"\n      }\n    }\n   },\n  \"required\": [\n    \"name\"\n  ]\n}\n\n</code-example>\n<ul>\n<li>\n<p><em>id</em>: 콜렉션 안에서 스키마를 구분하는 ID입니다.</p>\n</li>\n<li>\n<p><em>title</em>: 스키마를 설명하는 문구를 작성합니다.</p>\n</li>\n<li>\n<p><em>type</em>: 프로퍼티 타입을 지정합니다.</p>\n</li>\n<li>\n<p><em>properties</em>: 스키매틱 입력값의 형식을 객체 형태로 정의합니다.</p>\n<p>개별 입력값은 각각 <code>type</code>, <code>description</code>, <code>alias</code>(생략 가능)로 구성합니다.\n이 때 <code>type</code>은 입력값의 형식을 의미하며, <code>description</code>은 사용자가 스키매틱을 실행할 때 확인하는 문구입니다.</p>\n<p>더 자세한 내용은 워크스페이스 스키마를 참고하세요.</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li><code>schema.ts</code> 파일을 만들고 이 파일에 <code>schema.json</code>에서 정의한 내용을 인터페이스 형태로 정의합니다.</li>\n</ol>\n<code-example header=\"projects/my-lib/schematics/my-service/schema.ts (스키매틱 인터페이스)\" path=\"schematics-for-libraries/projects/my-lib/schematics/my-service/schema.ts\">\nexport interface Schema {\n  // 서비스 이름\n  name: string;\n\n  // 서비스 생성 위치\n  path?: string;\n\n  // 프로젝트 이름\n  project?: string;\n}\n\n\n</code-example>\n<ul>\n<li><em>name</em> : 서비스 이름으로 사용할 문자열</li>\n<li><em>path</em> : 서비스를 생성할 위치를 지정할 때 사용합니다. 기본값은 현재 위치한 폴더입니다.</li>\n<li><em>project</em> : 스키매틱 실행에 기준이 될 프로젝트를 지정합니다. 사용자가 입력값을 입력하지 않았을 때 기본값을 지정하기 위해 사용합니다.</li>\n</ul>\n<!--\n### Add template files\n-->\n<h3 id=\"템플릿-파일-추가하기\">템플릿 파일 추가하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-for-libraries#템플릿-파일-추가하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nTo add artifacts to a project, your schematic needs its own template files.\nSchematic templates support special syntax to execute code and variable substitution.\n\n1. Create a `files/` folder inside the `schematics/my-service/` folder.\n\n1. Create a file named `__name@dasherize__.service.ts.template` that defines a template you can use for generating files. This template will generate a service that already has Angular's `HttpClient` injected into its constructor.\n\n<code-example lang=\"ts\" header=\"projects/my-lib/schematics/my-service/files/__name@dasherize__.service.ts.template (Schematic Template)\">\n\nimport { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class <%= classify(name) %>Service {\n  constructor(private http: HttpClient) { }\n}\n\n</code-example>\n\n* The `classify` and `dasherize` methods are utility functions that your schematic will use to transform your source template and filename.\n\n* The `name` is provided as a property from your factory function. It is the same `name` you defined in the schema.\n-->\n<p>스키매틱의 관점에서 템플릿(template)은 라이브러리가 제공하는 Angular 구성요소를 프로젝트에 추가할 때스키매틱이 활용하는 기본틀을 의미합니다.\n스키매틱 템플릿은 상황에 어울리는 코드를 생성하기 위해 독자적인 문법 체계를 갖추고 있습니다.</p>\n<ol>\n<li>\n<p><code>schematics/my-service</code> 폴더 아래 <code>files</code> 폴더를 만듭니다.</p>\n</li>\n<li>\n<p><code>__name@dasherize__.service.ts.template</code>라는 이름으로 파일을 생성합니다. 이 파일은 스키매틱을 <code>ng generate</code> 명령으로 실행할 때 사용하는데, 명령을 실행하고 나면 생성자로 Angular <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 객체가 의존성으로 주입되는 서비스를 생성합니다.</p>\n</li>\n</ol>\n<code-example lang=\"ts\" header=\"projects/my-lib/schematics/my-service/files/__name@dasherize__.service.ts.template (스키매틱 템플릿)\">\n\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root'\n})\nexport class &#x3C;%= classify(name) %>Service {\n  constructor(private <a href=\"api/common/http\" class=\"code-anchor\">http</a>: <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>) { }\n}\n\n</code-example>\n<ul>\n<li>\n<p><code>classify</code>와 <code>dasherize</code> 메소드는 소스 템플릿과 파일 이름을 적절히 변환할 때 사용하는 유틸리티 함수입니다.</p>\n</li>\n<li>\n<p><code>name</code>은 팩토리 함수에서 전달되는데, 스키마에 정의한 <code>name</code> 프로퍼티와 동일한 객체를 가리킵니다.</p>\n</li>\n</ul>\n<!--\n### Add the factory function\n-->\n<h3 id=\"팩토리-함수-추가하기\">팩토리 함수 추가하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-for-libraries#팩토리-함수-추가하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nNow that you have the infrastructure in place, you can define the main function that performs the modifications you need in the user's project.\n\nThe Schematics framework provides a file templating system, which supports both path and content templates.\nThe system operates on placeholders defined inside files or paths that loaded in the input `Tree`.\nIt fills these in using values passed into the `Rule`.\n\nFor details of these data structures and syntax, see the [Schematics README](https://github.com/angular/angular-cli/blob/master/packages/angular_devkit/schematics/README.md).\n\n1. Create the main file `index.ts` and add the source code for your schematic factory function.\n\n1. First, import the schematics definitions you will need. The Schematics framework offers many utility functions to create and use rules when running a schematic.\n\n<code-example header=\"projects/my-lib/schematics/my-service/index.ts (Imports)\" path=\"schematics-for-libraries/projects/my-lib/schematics/my-service/index.ts\" region=\"schematics-imports\">\nimport {\n  Rule, Tree, SchematicsException,\n  apply, url, applyTemplates, move,\n  chain, mergeWith\n} from &#39;@angular-devkit/schematics&#39;;\n\nimport { strings, normalize, experimental } from &#39;@angular-devkit/core&#39;;\n\n</code-example>\n\n1. Import the defined schema interface that provides the type information for your schematic's options.\n\n<code-example header=\"projects/my-lib/schematics/my-service/index.ts (Schema Import)\" path=\"schematics-for-libraries/projects/my-lib/schematics/my-service/index.ts\" region=\"schema-imports\">\nimport {\n  Rule, Tree, SchematicsException,\n  apply, url, applyTemplates, move,\n  chain, mergeWith\n} from &#39;@angular-devkit/schematics&#39;;\n\nimport { strings, normalize, experimental } from &#39;@angular-devkit/core&#39;;\n\nimport { Schema as MyServiceSchema } from &#39;./schema&#39;;\n\n</code-example>\n\n1. To build up the generation schematic, start with an empty rule factory.\n\n<code-example header=\"projects/my-lib/schematics/my-service/index.ts (Initial Rule)\" path=\"schematics-for-libraries/projects/my-lib/schematics/my-service/index.1.ts\" region=\"factory\">\nexport function myService(options: MyServiceSchema): Rule {\n  return (tree: Tree) =&gt; {\n    return tree;\n  };\n}\n\n</code-example>\n\nThis simple rule factory returns the tree without modification.\nThe options are the option values passed through from the `ng generate` command.\n-->\n<p>필요한 준비는 모두 끝났습니다.\n이제부터는 프로젝트 파일을 수정하는 메인 함수를 정의해 봅시다.</p>\n<p>스키매틱 프레임워크는 템플릿 시스템을 제공합니다.\n그리고 이 템플릿 시스템을 활용하는 방식은 두 가지입니다.\n입력 인자로 전달되는 <code>Tree</code>를 활용할 수도 있고, <code>Rule</code>에 내용물을 채워 넣는 방식을 사용할 수도 있습니다.</p>\n<p>스키매틱 프레임워크의 데이터 구조와 문법에 대해 더 자세하게 알아보려면 <a href=\"https://github.com/angular/angular-cli/blob/master/packages/angular_devkit/schematics/README.md\">스키매틱 README</a> 문서를 참고하세요.</p>\n<ol>\n<li>\n<p>메인 파일 <code>index.ts</code> 파일을 만듭니다. 스키매틱의 팩토리 함수는 이 파일에 작성합니다.</p>\n</li>\n<li>\n<p>제일 먼저 스키매틱과 관련된 심볼을 로드합니다. 스키매틱 프레임워크는 룰을 생성하고 활용하는 유틸리티 함수를 다양하게 제공합니다.</p>\n</li>\n</ol>\n<code-example header=\"projects/my-lib/schematics/my-service/index.ts (심볼 로드)\" path=\"schematics-for-libraries/projects/my-lib/schematics/my-service/index.ts\" region=\"schematics-imports\">\nimport {\n  Rule, Tree, SchematicsException,\n  apply, url, applyTemplates, move,\n  chain, mergeWith\n} from '@angular-devkit/schematics';\n\nimport { strings, normalize, experimental } from '@angular-devkit/core';\n\n</code-example>\n<ol start=\"3\">\n<li>스키매틱 타입 정보를 참조하기 위해 스키마 인터페이스를 로드합니다.</li>\n</ol>\n<code-example header=\"projects/my-lib/schematics/my-service/index.ts (스키마 로드)\" path=\"schematics-for-libraries/projects/my-lib/schematics/my-service/index.ts\" region=\"schema-imports\">\nimport {\n  Rule, Tree, SchematicsException,\n  apply, url, applyTemplates, move,\n  chain, mergeWith\n} from '@angular-devkit/schematics';\n\nimport { strings, normalize, experimental } from '@angular-devkit/core';\n\nimport { Schema as MyServiceSchema } from './schema';\n\n</code-example>\n<ol start=\"4\">\n<li>생성 스키매틱을 구현하기 위해 빈 룰 팩토리를 정의합니다.</li>\n</ol>\n<code-example header=\"projects/my-lib/schematics/my-service/index.ts (룰 프로토타입)\" path=\"schematics-for-libraries/projects/my-lib/schematics/my-service/index.1.ts\" region=\"factory\">\nexport function myService(options: MyServiceSchema): Rule {\n  return (tree: Tree) => {\n    return tree;\n  };\n}\n\n</code-example>\n<p>인자로 전달되는 옵션값은 <code>ng generate</code> 명령을 실행했을때 전달되는 값입니다.\n아직까지는 룰 팩토리 함수가 아무 변환작업도 하지 않습니다.</p>\n<!--\n## Define a generation rule\n-->\n<h2 id=\"생성generation-룰-정의하기\">생성(generation) 룰 정의하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-for-libraries#생성generation-룰-정의하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nWe now have the framework in place for creating the code that actually modifies the user's application to set it up for the service defined in your library.\n\nThe Angular workspace where the user has installed your library contains multiple projects (applications and libraries).\nThe user can specify the project on the command line, or allow it to default.\nIn either case, your code needs to identify the specific project to which this schematic is being applied, so that you can retrieve information from the project configuration.\n\nYou can do this using the `Tree` object that is passed in to the factory function.\nThe `Tree` methods give you access to the complete file tree in your workspace, allowing you to read and write files during the execution of the schematic.\n-->\n<p>이제 프로젝트에 있는 애플리케이션 코드를 수정할 준비가 끝났습니다.</p>\n<p>사용자가 라이브러리를 설치한 Angular 워크스페이스에는 애플리케이션과 라이브러리 프로젝트가 여러개 존재할 수도 있습니다.\n그래서 <code>ng generate</code> 명령을 실행할 때 특정 프로젝트를 지정하거나 기본 프로젝트를 미리 지정해둘 수 있습니다.\n어떤 방법을 사용하던지 스키매틱이 동작할 프로젝트가 정확하게 지정되어야 프로젝트에 대한 정보를 참조할 수 있습니다.</p>\n<p>프로젝트 코드를 수정할 때는 팩토리 함수로 전달된 <code>Tree</code> 객체를 사용합니다.\n<code>Tree</code> 객체를 참조하면 워크스페이스에 존재하는 전체 파일 트리에 접근할 수 있습니다.\n그래서 스키매틱이 실행되는 동안 파일을 읽거나 쓰는 것도 물론 가능합니다.</p>\n<!--\n### Get the project configuration\n-->\n<h3 id=\"프로젝트-설정-참조하기\">프로젝트 설정 참조하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-for-libraries#프로젝트-설정-참조하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\n1. To determine the destination project, use the `Tree.read()` method to read the contents of the workspace configuration file, `angular.json`, at the root of the workspace.\n   Add the following code to your factory function.\n\n<code-example header=\"projects/my-lib/schematics/my-service/index.ts (Schema Import)\" path=\"schematics-for-libraries/projects/my-lib/schematics/my-service/index.ts\" region=\"workspace\">\nimport {\n  Rule, Tree, SchematicsException,\n  apply, url, applyTemplates, move,\n  chain, mergeWith\n} from &#39;@angular-devkit/schematics&#39;;\n\nimport { strings, normalize, experimental } from &#39;@angular-devkit/core&#39;;\n\nimport { Schema as MyServiceSchema } from &#39;./schema&#39;;\n\nexport function myService(options: MyServiceSchema): Rule {\n  return (tree: Tree) =&gt; {\n    const workspaceConfig = tree.read(&#39;/angular.json&#39;);\n    if (!workspaceConfig) {\n      throw new SchematicsException(&#39;Could not find Angular workspace configuration&#39;);\n    }\n\n    // 워크스페이스 설정 파일을 문자열로 변환합니다.\n    const workspaceContent = workspaceConfig.toString();\n\n    // 문자열을 JSON 객체로 파싱합니다.\n    const workspace: experimental.workspace.WorkspaceSchema = JSON.parse(workspaceContent);\n  };\n}\n\n\n</code-example>\n\n  * Be sure to check that the context exists and throw the appropriate error.\n\n  * After reading the contents into a string, parse the configuration into a JSON object, typed to the `WorkspaceSchema`.\n\n1. The `WorkspaceSchema` contains all the properties of the workspace configuration, including a `defaultProject` value for determining which project to use if not provided.\n   We will use that value as a fallback, if no project is explicitly specified in the `ng generate` command.\n\n<code-example header=\"projects/my-lib/schematics/my-service/index.ts (Default Project)\" path=\"schematics-for-libraries/projects/my-lib/schematics/my-service/index.ts\" region=\"project-fallback\">\nif (!options.project) {\n  options.project = workspace.defaultProject;\n}\n\n</code-example>\n\n1. Now that you have the project name, use it to retrieve the project-specific configuration information.\n\n<code-example header=\"projects/my-lib/schematics/my-service/index.ts (Project)\" path=\"schematics-for-libraries/projects/my-lib/schematics/my-service/index.ts\" region=\"project-info\">\nconst projectName = options.project as string;\n\nconst project = workspace.projects[projectName];\n\nconst projectType = project.projectType === &#39;application&#39; ? &#39;app&#39; : &#39;lib&#39;;\n\n</code-example>\n\n   The `workspace projects` object contains all the project-specific configuration information.\n\n1. The `options.path` determines where the schematic template files are moved to once the schematic is applied.\n\n   The `path` option in the schematic's schema is substituted by default with the current working directory.\n   If the `path` is not defined, use the `sourceRoot` from the project configuration along with the `projectType`.\n\n<code-example header=\"projects/my-lib/schematics/my-service/index.ts (Project Info)\" path=\"schematics-for-libraries/projects/my-lib/schematics/my-service/index.ts\" region=\"path\">\nif (options.path === undefined) {\n  options.path = `${project.sourceRoot}/${projectType}`;\n}\n\n</code-example>\n-->\n<ol>\n<li>작업할 프로젝트를 정하고 나면 <code>Tree.read()</code> 메소드를 사용해서 워크스페이스 최상위 폴더에 있는 환경설정 파일 <code>angular.json</code>을 읽어옵니다.\n팩토리 함수를 다음과 같이 작성하면 됩니다.</li>\n</ol>\n<code-example header=\"projects/my-lib/schematics/my-service/index.ts (스키마 로드)\" path=\"schematics-for-libraries/projects/my-lib/schematics/my-service/index.ts\" region=\"workspace\">\nimport {\n  Rule, Tree, SchematicsException,\n  apply, url, applyTemplates, move,\n  chain, mergeWith\n} from '@angular-devkit/schematics';\n\nimport { strings, normalize, experimental } from '@angular-devkit/core';\n\nimport { Schema as MyServiceSchema } from './schema';\n\nexport function myService(options: MyServiceSchema): Rule {\n  return (tree: Tree) => {\n    const workspaceConfig = tree.read('/angular.json');\n    if (!workspaceConfig) {\n      throw new SchematicsException('Could not find Angular workspace configuration');\n    }\n\n    // 워크스페이스 설정 파일을 문자열로 변환합니다.\n    const workspaceContent = workspaceConfig.toString();\n\n    // 문자열을 JSON 객체로 파싱합니다.\n    const workspace: experimental.workspace.WorkspaceSchema = JSON.parse(workspaceContent);\n  };\n}\n\n\n</code-example>\n<ul>\n<li>\n<p>작업하는 컨텍스트가 유효한지 반드시 확인해야 합니다. 유효하지 않으면 에러를 발생시켜 로직을 끊는 것이 좋습니다.</p>\n</li>\n<li>\n<p>파일의 내용을 문자열로 읽어온 후에 JSON 객체로 변환하고 이 객체를 <code>WorkspaceSchema</code> 타입으로 선언합니다.</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li><code>WorkspaceSchema</code>는 워크스페이스 환경과 관련된 모든 프로퍼티 정보를 담고 있는 객체입니다. 이 객체에는 프로젝트를 지정하지 않았을 때 기본값으로 사용될 <code>defaultProject</code> 값도 존재합니다.\n이 문서에서는 프로젝트를 지정하지 않고 <code>ng generate</code> 명령을 실행하는 방식으로 구현해 봅시다.</li>\n</ol>\n<code-example header=\"projects/my-lib/schematics/my-service/index.ts (기본 프로젝트)\" path=\"schematics-for-libraries/projects/my-lib/schematics/my-service/index.ts\" region=\"project-fallback\">\nif (!options.project) {\n  options.project = workspace.defaultProject;\n}\n\n</code-example>\n<ol start=\"3\">\n<li>프로젝트 이름으로 참조해서 프로젝트가 어떤 타입인지 구분할 수 있습니다.</li>\n</ol>\n<code-example header=\"projects/my-lib/schematics/my-service/index.ts (프로젝트 참조)\" path=\"schematics-for-libraries/projects/my-lib/schematics/my-service/index.ts\" region=\"project-info\">\nconst projectName = options.project as string;\n\nconst project = workspace.projects[projectName];\n\nconst projectType = project.projectType === 'application' ? 'app' : 'lib';\n\n</code-example>\n<p>   <code>workspace.projects</code> 객체는 워크스페이스에 존재하는 모든 프로젝트 정보를 담고 있는 객체입니다.</p>\n<ol start=\"4\">\n<li>\n<p><code>options.path</code>는 스키매틱이 실행됐을 때 스키매틱 템플릿 파일이 위치할 폴더를 의미합니다.</p>\n<p><code>path</code> 옵션의 값은은 현재 작업하고 있는 폴더 경로로 대체됩니다.\n그리고 <code>path</code>가 존재하지 않으면 프로젝트 정보로 참조해온 <code>sourceRoot</code>와 <code>projectType</code>으로 경로를 구성했습니다.</p>\n</li>\n</ol>\n<code-example header=\"projects/my-lib/schematics/my-service/index.ts (프로젝트 정보)\" path=\"schematics-for-libraries/projects/my-lib/schematics/my-service/index.ts\" region=\"path\">\nif (options.path === undefined) {\n  options.path = `${project.sourceRoot}/${projectType}`;\n}\n\n</code-example>\n<!--\n### Define the rule\n-->\n<h3 id=\"룰-정의하기\">룰 정의하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-for-libraries#룰-정의하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nA `Rule` can use external template files, transform them, and return another `Rule` object with the transformed template. You can use the templating to generate any custom files required for your schematic.\n\n1. Add the following code to your factory function.\n\n<code-example header=\"projects/my-lib/schematics/my-service/index.ts (Template transform)\" path=\"schematics-for-libraries/projects/my-lib/schematics/my-service/index.ts\" region=\"template\">\nconst templateSource = apply(url(&#39;./files&#39;), [\n  applyTemplates({\n    classify: strings.classify,\n    dasherize: strings.dasherize,\n    name: options.name\n  }),\n  move(normalize(options.path as string))\n]);\n\n</code-example>\n\n  * The `apply()` method applies multiple rules to a source and returns the transformed source. It takes 2 arguments, a source and an array of rules.\n  * The `url()` method reads source files from your filesystem, relative to the schematic.\n  * The `applyTemplates()` method receives an argument of methods and properties you want make available to the schematic template and the schematic filenames. It returns a `Rule`. This is where you define the `classify()` and `dasherize()` methods, and the `name` property.\n  * The `classify()` method takes a value and returns the value in title case. For example, if the provided name is `my service`, it is returned as `MyService`\n  * The `dasherize()` method takes a value and returns the value in dashed and lowercase. For example, if the provided name is MyService, it is returned as `my-service`.\n  * The `move` method moves the provided source files to their destination when the schematic is applied.\n\n1. Finally, the rule factory must return a rule.\n\n<code-example header=\"projects/my-lib/schematics/my-service/index.ts (Chain Rule)\" path=\"schematics-for-libraries/projects/my-lib/schematics/my-service/index.ts\" region=\"chain\">\nreturn chain([\n  mergeWith(templateSource)\n]);\n\n</code-example>\n\n  The `chain()` method allows you to combine multiple rules into a single rule, so that you can perform multiple operations in a single schematic.\n  Here you are only merging the template rules with any code executed by the schematic.\n\nSee a complete exampled of the schematic rule function.\n\n<code-example header=\"projects/my-lib/schematics/my-service/index.ts\" path=\"schematics-for-libraries/projects/my-lib/schematics/my-service/index.ts\">\nimport {\n  Rule, Tree, SchematicsException,\n  apply, url, applyTemplates, move,\n  chain, mergeWith\n} from &#39;@angular-devkit/schematics&#39;;\n\nimport { strings, normalize, experimental } from &#39;@angular-devkit/core&#39;;\n\nimport { Schema as MyServiceSchema } from &#39;./schema&#39;;\n\nexport function myService(options: MyServiceSchema): Rule {\n  return (tree: Tree) =&gt; {\n    const workspaceConfig = tree.read(&#39;/angular.json&#39;);\n    if (!workspaceConfig) {\n      throw new SchematicsException(&#39;Could not find Angular workspace configuration&#39;);\n    }\n\n    // 워크스페이스 설정 파일을 문자열로 변환합니다.\n    const workspaceContent = workspaceConfig.toString();\n\n    // 문자열을 JSON 객체로 파싱합니다.\n    const workspace: experimental.workspace.WorkspaceSchema = JSON.parse(workspaceContent);\n    if (!options.project) {\n      options.project = workspace.defaultProject;\n    }\n\n    const projectName = options.project as string;\n\n    const project = workspace.projects[projectName];\n\n    const projectType = project.projectType === &#39;application&#39; ? &#39;app&#39; : &#39;lib&#39;;\n\n    if (options.path === undefined) {\n      options.path = `${project.sourceRoot}/${projectType}`;\n    }\n\n    const templateSource = apply(url(&#39;./files&#39;), [\n      applyTemplates({\n        classify: strings.classify,\n        dasherize: strings.dasherize,\n        name: options.name\n      }),\n      move(normalize(options.path as string))\n    ]);\n\n    return chain([\n      mergeWith(templateSource)\n    ]);\n  };\n}\n\n\n</code-example>\n\nFor more information about rules and utility methods, see [Provided Rules](https://github.com/angular/angular-cli/tree/master/packages/angular_devkit/schematics#provided-rules).\n-->\n<p><code>Rule</code>은 외부 템플릿 파일을 참조할 수 있으며, 이 템플릿을 수정해서 새로운 <code>Rule</code> 객체를 반환합니다.\n이렇게 템플릿을 활용하는 방식은 팩토리 함수에 작성해야 하는 코드의 양을 줄여주기 때문에 효율적입니다.</p>\n<ol>\n<li>룰 팩토리 함수를 다음과 같이 구현합니다.</li>\n</ol>\n<code-example header=\"projects/my-lib/schematics/my-service/index.ts (템플릿 변환작업)\" path=\"schematics-for-libraries/projects/my-lib/schematics/my-service/index.ts\" region=\"template\">\nconst templateSource = apply(url('./files'), [\n  applyTemplates({\n    classify: strings.classify,\n    dasherize: strings.dasherize,\n    name: options.name\n  }),\n  move(normalize(options.path as string))\n]);\n\n</code-example>\n<ul>\n<li><code>apply()</code> 메소드를 사용하면 소스 파일 하나에 여러 룰 작업을 실행할 수 있습니다. 이 메소드는 인자를 2개 받는데, 첫번째 인자는 소스 파일이며, 두 번째 인자는 룰 배열입니다.</li>\n<li><code>url()</code> 메소드는 파일 시스템에서 소스파일을 읽는 메소드입니다. 경로는 스키매틱의 상대주소로 지정합니다.</li>\n<li><code>applyTemplates()</code> 메소드는 스키매틱에 사용하려는 메소드와 프로퍼티를 객체 형태로 받습니다. 위 예제처럼 작성하면 <code>classify()</code>와 <code>dashrize()</code> 메소드를 가져오고 <code>name</code> 프로퍼티를 가져온 후에 <code>Rule</code> 형태로 반환합니다.</li>\n<li><code>classify()</code> 메소드는 인자로 받은 문자열을 제목 형태(title case)로 변환하는 메소드입니다. 입력값으로 <code>my service</code>를 사용하면 <code>MyService</code>를 반환합니다.</li>\n<li><code>dasherize()</code> 메소드는 인자로 받은 문자열을 대시(<code>-</code>)와 소문자로 조합하는 메소드입니다. 입력값으로 <code>MyService</code>를 사용하면 <code>my-service</code>를 반환합니다.</li>\n<li><code>move()</code> 메소드는 스키매틱이 실행될 때 해당 파일을 원하는 위치로 옮기는 메소드입니다.</li>\n</ul>\n<ol start=\"2\">\n<li>마지막으로 룰 팩토리는 반드시 룰 객체를 반환해야 합니다.</li>\n</ol>\n<code-example header=\"projects/my-lib/schematics/my-service/index.ts (룰 체인)\" path=\"schematics-for-libraries/projects/my-lib/schematics/my-service/index.ts\" region=\"chain\">\nreturn chain([\n  mergeWith(templateSource)\n]);\n\n</code-example>\n<p>  <code>chain()</code> 메소드는 룰 여러 개를 하나로 조합하기 때문에 스키매틱을 한 번 실행하면서 여러 작업을 한번에 처리할 수 있습니다.\n위에서 작성한 예제는 별다른 로직 실행 없이 템플릿을 결합하기만 합니다.</p>\n<p>여기까지 작성하고 나면 다음과 같은 스키매틱 룰 함수가 완성됩니다.</p>\n<code-example header=\"projects/my-lib/schematics/my-service/index.ts\" path=\"schematics-for-libraries/projects/my-lib/schematics/my-service/index.ts\">\nimport {\n  Rule, Tree, SchematicsException,\n  apply, url, applyTemplates, move,\n  chain, mergeWith\n} from '@angular-devkit/schematics';\n\nimport { strings, normalize, experimental } from '@angular-devkit/core';\n\nimport { Schema as MyServiceSchema } from './schema';\n\nexport function myService(options: MyServiceSchema): Rule {\n  return (tree: Tree) => {\n    const workspaceConfig = tree.read('/angular.json');\n    if (!workspaceConfig) {\n      throw new SchematicsException('Could not find Angular workspace configuration');\n    }\n\n    // 워크스페이스 설정 파일을 문자열로 변환합니다.\n    const workspaceContent = workspaceConfig.toString();\n\n    // 문자열을 JSON 객체로 파싱합니다.\n    const workspace: experimental.workspace.WorkspaceSchema = JSON.parse(workspaceContent);\n    if (!options.project) {\n      options.project = workspace.defaultProject;\n    }\n\n    const projectName = options.project as string;\n\n    const project = workspace.projects[projectName];\n\n    const projectType = project.projectType === 'application' ? 'app' : 'lib';\n\n    if (options.path === undefined) {\n      options.path = `${project.sourceRoot}/${projectType}`;\n    }\n\n    const templateSource = apply(url('./files'), [\n      applyTemplates({\n        classify: strings.classify,\n        dasherize: strings.dasherize,\n        name: options.name\n      }),\n      move(normalize(options.path as string))\n    ]);\n\n    return chain([\n      mergeWith(templateSource)\n    ]);\n  };\n}\n\n\n</code-example>\n<p>룰과 유틸리티 메소드에 대해 더 자세하게 알아보려면 <a href=\"https://github.com/angular/angular-cli/tree/master/packages/angular_devkit/schematics#provided-rules\">기본 룰</a> 문서를 참고하세요.</p>\n<!--\n## Running your library schematic\n-->\n<h2 id=\"라이브러리-스키매틱-실행하기\">라이브러리 스키매틱 실행하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-for-libraries#라이브러리-스키매틱-실행하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAfter you build your library and schematics, you can install the schematics collection to run against your project. The steps below show you how to generate a service using the schematic you created above.\n-->\n<p>라이브러리와 스키매틱을 빌드하고 나면 이제 Angular 프로젝트에 스키매틱 컬렉션을 설치할 수 있습니다.\n이제부터는 지금까지 구현한 스키매틱을 사용해서 서비스를 생성하는 방법에 대해 알아봅시다.</p>\n<!--\n### Build your library and schematics\n-->\n<h3 id=\"라이브러리-스키매틱-빌드하기\">라이브러리, 스키매틱 빌드하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-for-libraries#라이브러리-스키매틱-빌드하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nFrom the root of your workspace, run the `ng build` command for your library.\n\n<code-example language=\"bash\">\n\n  ng build my-lib\n\n</code-example>\n\nThen, you change into your library directory to build the schematic\n\n<code-example language=\"bash\">\n\n  cd projects/my-lib\n  npm run build\n\n</code-example>\n-->\n<p>워크스페이스 최상위 폴더에서 <code>ng build</code> 명령을 실행해서 라이브러리를 빌드합니다.</p>\n<code-example language=\"bash\">\n\n  ng build my-lib\n\n</code-example>\n<p>그리고 라이브러리 폴더로 들어가서 스키매틱을 빌드합니다.</p>\n<code-example language=\"bash\">\n\n  cd projects/my-lib\n  npm run build\n\n</code-example>\n<!--\n### Link the library\n-->\n<h3 id=\"라이브러리-링크하기\">라이브러리 링크하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-for-libraries#라이브러리-링크하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYour library and schematics are packaged and placed in the `dist/my-lib` folder at the root of your workspace. For running the schematic, you need to link the library into your `node_modules` folder. From the root of your workspace, run the `npm link` command with the path to your distributable library.\n\n<code-example language=\"bash\">\n\nnpm link dist/my-lib\n\n</code-example>\n-->\n<p>이제 라이브러리와 스키매틱이 빌드된 결과물은 워크스페이스 최상위 폴더를 기준으로 <code>dist/my-lib</code> 폴더에 존재합니다.\n그리고 이 스키매틱을 실행하려면 먼저 라이브러리와 <code>node_modules</code> 폴더를 링크해야 합니다.\n워크스페이스 최상위 폴더에서 <code>npm link</code> 명령을 실행해서 라이브러리를 연결해 봅시다.</p>\n<code-example language=\"bash\">\n\nnpm link dist/my-lib\n\n</code-example>\n<!--\n### Run the schematic\n-->\n<h3 id=\"스키매틱-실행하기\">스키매틱 실행하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-for-libraries#스키매틱-실행하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nNow that your library is installed, you can run the schematic using the `ng generate` command.\n\n<code-example language=\"bash\">\n\nng generate my-lib:my-service --name my-data\n\n</code-example>\n\nIn the console, you will see that the schematic was run and the `my-data.service.ts` file was created in your app folder.\n\n<code-example language=\"bash\" hideCopy=\"true\">\n\nCREATE src/app/my-data.service.ts (208 bytes)\n\n</code-example>\n-->\n<p>라이브러리가 설치되고 나면 <code>ng generate</code> 명령으로 스키매틱을 실행할 수 있습니다.</p>\n<code-example language=\"bash\">\n\nng generate my-lib:my-service --name my-data\n\n</code-example>\n<p>콘솔을 보면 스키매틱이 실행되면서 <code>my-data.service.ts</code> 파일이 생성되는 것을 확인할 수 있습니다.</p>\n<code-example language=\"bash\" hidecopy=\"true\">\n\nCREATE src/app/my-data.service.ts (208 bytes)\n\n</code-example>\n\n</div>\n\n<!-- links to this doc:\n - guide/creating-libraries\n - guide/schematics\n - guide/schematics-authoring\n-->\n<!-- links from this doc:\n - api/common/http\n - api/common/http/HttpClient\n - api/core/Injectable\n - guide/schematics-for-libraries#라이브러리-링크하기\n - guide/schematics-for-libraries#라이브러리-설치-로직-작성하기\n - guide/schematics-for-libraries#라이브러리-스키매틱-빌드하기\n - guide/schematics-for-libraries#라이브러리-스키매틱-실행하기\n - guide/schematics-for-libraries#라이브러리용-스키매틱\n - guide/schematics-for-libraries#룰-정의하기\n - guide/schematics-for-libraries#생성generation-기능-제공하기\n - guide/schematics-for-libraries#생성generation-룰-정의하기\n - guide/schematics-for-libraries#스키매틱-빌드하기\n - guide/schematics-for-libraries#스키매틱-실행하기\n - guide/schematics-for-libraries#스키매틱-추가하기\n - guide/schematics-for-libraries#스키매틱-컬렉션-만들기\n - guide/schematics-for-libraries#템플릿-파일-추가하기\n - guide/schematics-for-libraries#팩토리-함수-추가하기\n - guide/schematics-for-libraries#프로젝트-설정-참조하기\n - https://github.com/angular/angular-cli/blob/master/packages/angular_devkit/schematics/README.md\n - https://github.com/angular/angular-cli/tree/master/packages/angular_devkit/schematics#provided-rules\n - https://github.com/angular/angular/edit/master/aio/content/guide/schematics-for-libraries.md?message=docs%3A%20describe%20your%20change...\n-->"
}