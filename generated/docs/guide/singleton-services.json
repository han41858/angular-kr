{
  "id": "guide/singleton-services",
  "title": "싱글턴 서비스 (Singleton services)",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/singleton-services.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Singleton services\n-->\n<h1 id=\"싱글턴-서비스-singleton-services\">싱글턴 서비스 (Singleton services)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#싱글턴-서비스-singleton-services\"><i class=\"material-icons\">link</i></a></h1>\n<!--\nA singleton service is a service for which only one instance exists in an app.\n\nFor a sample app using the app-wide singleton service that this page describes, see the\n<live-example name=\"ngmodules\"></live-example> showcasing all the documented features of NgModules.\n-->\n<p>싱글턴 서비스는 앱 전체에서 단 하나의 인스턴스만 존재하는 서비스를 말합니다.</p>\n<p>이 문서에서는 싱글턴으로 동작하는 서비스를 만들어봅시다.\n이 문서에서 다루는 모든 예제 코드는 <live-example name=\"ngmodules\"></live-example>에서 직접 확인하거나 다운받아 확인할 수 있습니다.</p>\n<!--\n## Providing a singleton service\n-->\n<h2 id=\"싱글턴-서비스-생성하기\">싱글턴 서비스 생성하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#싱글턴-서비스-생성하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThere are two ways to make a service a singleton in Angular:\n\n* Set the `providedIn` property of the `@Injectable()` to `\"root\"`.\n* Include the service in the `AppModule` or in a module that is only imported by the `AppModule`\n-->\n<p>Angular에서 서비스를 싱글턴으로 사용하는 방법은 두 가지가 있습니다:</p>\n<ul>\n<li><code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> <code>providedIn</code> 프로퍼티에 <code>root</code>를 지정해서 서비스 프로바이더를 애플리케이션 루트에 등록하는 방법</li>\n<li>서비스를 <code>AppModule</code>에 선언하고 다른 모듈에서 <code>AppModule</code>만 로드하는 방법</li>\n</ul>\n<a id=\"providedIn\"></a>\n<!--\n### Using `providedIn`\n-->\n<h3 id=\"providedin-사용하기\"><code>providedIn</code> 사용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#providedin-사용하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nBeginning with Angular 6.0, the preferred way to create a singleton service is to set `providedIn` to `root` on the service's `@Injectable()` decorator. This tells Angular\nto provide the service in the application root.\n\n<code-example path=\"providers/src/app/user.service.0.ts\" header=\"src/app/user.service.ts\">\nimport { Injectable } from &#39;@angular/core&#39;;\n\n@Injectable({\n  providedIn: &#39;root&#39;,\n})\nexport class UserService {\n}\n\n\n</code-example>\n\nFor more detailed information on services, see the [Services](tutorial/toh-pt4) chapter of the\n[Tour of Heroes tutorial](tutorial).\n-->\n<p>Angular 6.0 버전부터 Angular CLI로 서비스를 생성하면 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code>데코레이터의 <code>providedIn</code> 메타데이터 값이 <code>root</code>로 설정됩니다.\n그래서 이 서비스는 앱 전역에서 사용할 수 있습니다.</p>\n<code-example path=\"providers/src/app/user.service.0.ts\" header=\"src/app/user.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class UserService {\n}\n\n\n</code-example>\n<p>더 자세한 내용은 <a href=\"tutorial\">히어로들의 여행</a> 튜토리얼의 <a href=\"tutorial/toh-pt4\">서비스</a> 챕터를 참고하세요.</p>\n<!--\n### NgModule `providers` array\n-->\n<h3 id=\"ngmodule의-providers-배열\">NgModule의 <code>providers</code> 배열<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#ngmodule의-providers-배열\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn apps built with Angular versions prior to 6.0, services are registered NgModule `providers` arrays as follows:\n-->\n<p>Angular 6.0 버전 이전에는 Angular CLI로 서비스를 생성했을 때 이 서비스가 NgModule의 <code>providers</code> 배열에 추가됐습니다:</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  ...\n  providers: [UserService],\n  ...\n})\n</code-example>\n<!--\nIf this NgModule were the root `AppModule`, the `UserService` would be a singleton and available\nthroughout the app. Though you may see it coded this way, using the `providedIn` property of the `@Injectable()` decorator on the service itself is preferable as of Angular 6.0 as it makes your services tree-shakable.\n-->\n<p>이 경우에도 서비스가 추가되는 모듈은 <code>AppModule</code>이기 때문에 <code>UserService</code>는 앱 전역에서 인스턴스 하나만 존재합니다.\n동작은 동일하지만, Angular 6.0부터는 트리 셰이킹이 가능한 서비스를 명확하게 지정하기 위해 서비스 클래스의 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 데코레이터에 <code>providedIn</code> 메타데이터를 지정하는 방법을 더 권장합니다.</p>\n<a id=\"forRoot\"></a>\n<a id=\"the-forroot-pattern\"></a>\n<!--\n## The `forRoot()` pattern\n-->\n<h2 id=\"forroot-패턴\"><code>forRoot()</code> 패턴<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#forroot-패턴\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nGenerally, you'll only need `providedIn` for providing services and `forRoot()`/`forChild()` for routing. However, understanding how `forRoot()` works to make sure a service is a singleton will inform your development at a deeper level.\n\nIf a module defines both providers and declarations (components, directives, pipes),\nthen loading the module in multiple feature modules would duplicate the registration of the service. This could result in multiple service instances and the service would no longer behave as a singleton.\n\nThere are multiple ways to prevent this:\n\n* Use the [`providedIn` syntax](guide/singleton-services#providedIn) instead of registering the service in the module.\n* Separate your services into their own module.\n* Define `forRoot()` and `forChild()` methods in the module.\n\n<div class=\"alert is-helpful\">\n\n**Note:** There are two example apps where you can see this scenario; the more advanced <live-example noDownload name=\"ngmodules\">NgModules live example</live-example>, which contains `forRoot()` and `forChild()` in the routing modules and the `GreetingModule`, and the simpler <live-example name=\"lazy-loading-ngmodules\" noDownload>Lazy Loading live example</live-example>. For an introductory explanation see the [Lazy Loading Feature Modules](guide/lazy-loading-ngmodules) guide.\n\n</div>\n\n\nUse `forRoot()` to\nseparate providers from a module so you can import that module into the root module\nwith `providers` and child modules without `providers`.\n\n1. Create a static method `forRoot()` on the module.\n2. Place the providers into the `forRoot()` method.\n\n<code-example path=\"ngmodules/src/app/greeting/greeting.module.ts\" region=\"for-root\" header=\"src/app/greeting/greeting.module.ts\">\nstatic forRoot(config: UserServiceConfig): ModuleWithProviders&lt;GreetingModule&gt; {\n  return {\n    ngModule: GreetingModule,\n    providers: [\n      {provide: UserServiceConfig, useValue: config }\n    ]\n  };\n}\n\n</code-example>\n-->\n<p>일반적으로 서비스 프로바이더를 등록할 때는 <code>providedIn</code>만 알면 되고 라우팅할 때는 <code>forRoot()</code>와 <code>forChild()</code>만 알면 됩니다.\n그런데 <code>forRoot()</code>가 어떻게 동작해서 싱글턴이 되는지 제대로 알면 서비스가 동작하는 과정을 좀 더 자세하게 이해할 수 있습니다.</p>\n<p>서비스 프로바이더와 Angular 구성요소(컴포넌트, 디렉티브, 파이프)를 등록하는 모듈이 많다면 이 모듈들의 관계에 따라 서비스 프로바이더가 중복 등록되는 경우가 생길 수 있습니다.\n그러면 각 모듈마다 서비스의 인스턴스를 생성하기 때문에 더이상 이 서비스는 싱글턴이 아니게 됩니다.</p>\n<p>서비스를 싱글턴으로 유지하는 방법이 몇가지 있습니다:</p>\n<ul>\n<li>모듈에 서비스를 직접 등록하는 대신 <a href=\"guide/singleton-services#providedIn\"><code>providedIn</code> 문법</a>을 사용합니다.</li>\n<li>모듈마다 서비스를 분리합니다.</li>\n<li>모듈에 <code>forRoot()</code>와 <code>forChild()</code> 메소드를 정의합니다.</li>\n</ul>\n<div class=\"alert is-helpful\">\n<p><strong>참고:</strong> 미리 준비해둔 예제가 있습니다. <live-example nodownload=\"\" name=\"ngmodules\">NgModules 예제</live-example>에서는 <code>GreetingModule</code>을 라우팅 모듈에 등록할 때 <code>forRoot()</code>와 <code>forChild()</code>를 사용합니다. 그리고 <live-example name=\"lazy-loading-ngmodules\" nodownload=\"\">지연 로딩 예제</live-example>에서는 좀 더 단순한 방법을 사용합니다. 자세한 내용은 <a href=\"guide/lazy-loading-ngmodules\">기능모듈 지연 로딩</a> 문서를 참고하세요.</p>\n</div>\n<p>서비스 프로바이더를 모듈과 분리하기 위해 <code>forRoot()</code> 패턴을 사용하면 이제 최상위 모듈의 <code>providers</code>에는 모듈의 서비스를 등록하고 자식 모듈의 <code>providers</code>에는 모듈의 서비스를 등록하지 않습니다.</p>\n<ol>\n<li>모듈에 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code>으로 <code>forRoot</code> 메소드를 정의합니다.</li>\n<li>모듈의 서비스 프로바이더는 <code>forRoot()</code> 메소드에 둡니다.</li>\n</ol>\n<code-example path=\"ngmodules/src/app/greeting/greeting.module.ts\" region=\"for-root\" header=\"src/app/greeting/greeting.module.ts\">\n<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> forRoot(config: UserServiceConfig): <a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a>&#x3C;GreetingModule> {\n  return {\n    ngModule: GreetingModule,\n    providers: [\n      {provide: UserServiceConfig, useValue: config }\n    ]\n  };\n}\n\n</code-example>\n<a id=\"forRoot-router\"></a>\n<a id=\"forroot-and-the-router\"></a>\n<!--\n### `forRoot()` and the `Router`\n-->\n<h3 id=\"forroot와-router\"><code>forRoot()</code>와 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#forroot와-router\"><i class=\"material-icons\">link</i></a></h3>\n<!--\n`RouterModule` provides the `Router` service, as well as router directives, such as `RouterOutlet` and `routerLink`. The root application module imports `RouterModule` so that the application has a `Router` and the root application components can access the router directives. Any feature modules must also import `RouterModule` so that their components can place router directives into their templates.\n\nIf the `RouterModule` didn’t have `forRoot()` then each feature module would instantiate a new `Router` instance, which would break the application as there can only be one `Router`. By using the `forRoot()` method, the root application module imports `RouterModule.forRoot(...)` and gets a `Router`, and all feature modules import `RouterModule.forChild(...)` which does not instantiate another `Router`.\n\n<div class=\"alert is-helpful\">\n\n**Note:** If you have a module which has both providers and declarations,\nyou _can_ use this\ntechnique to separate them out and you may see this pattern in legacy apps.\nHowever, since Angular 6.0, the best practice for providing services is with the\n`@Injectable()` `providedIn` property.\n\n</div>\n-->\n<p><code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>을 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 서비스도 제공하고 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>이나 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code>같은 라우터 관련 디렉티브도 프로바이더로 등록합니다.\n그래서 애플리케이션 최상위 모듈에서 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>을 로드하면 앱에 있는 모듈 전체에서 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 서비스를 사용할 수 있습니다.\n그런데 모듈에 있는 컴포넌트가 템플릿에서 라우터 관련 디렉티브를 사용한다면 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>을 다시 로드해야 하는 경우가 있습니다.</p>\n<p>이 때 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>이 <code>forRoot()</code> 패턴을 제공하지 않는다면 기능모듈에서 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>을 로드할 때마다 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 인스턴스가 새로 생성되기 때문에 애플리케이션 전역에서 동작해야 하는 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>는 제대로 동작하지 않습니다.\n그래서 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>은 <code>forRoot()</code> 메소드를 사용했을 때만 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 서비스 프로바이더를 등록해서 인스턴스를 생성하며 다른 기능모듈에서 <code>forChild()</code>를 사용할 때는 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 서비스의 인스턴스를 다시 생성하지 않습니다.</p>\n<div class=\"alert is-helpful\">\n<p><strong>참고:</strong> <code>providers</code>와 <code>declarations</code> 배열을 동시에 사용하는 모듈은 <code>forRoot()</code> 패턴을 적용하는 것이 좋습니다.\n하지만, Angular 6.0부터는 서비스 클래스의 데코레이터 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code>에 <code>providedIn</code> 프로퍼티 값을 <code>root</code>로 지정하는 방식을 더 권장합니다.</p>\n</div>\n<h3 id=\"how-forroot-works\">How <code>forRoot()</code> works<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#how-forroot-works\"><i class=\"material-icons\">link</i></a></h3>\n<!--\n`forRoot()` takes a service configuration object and returns a\n[ModuleWithProviders](api/core/ModuleWithProviders), which is\na simple object with the following properties:\n-->\n<p><code>forRoot()</code> 함수는 서비스 설정 객체를 인자로 받아서 <a href=\"api/core/ModuleWithProviders\">ModuleWithProviders</a>를 반환하는데, 이 모듈에는 다음과 같은 프로퍼티가 있습니다:</p>\n<!--\n* `ngModule`: in this example, the `GreetingModule` class\n* `providers`: the configured providers\n-->\n<ul>\n<li><code>ngModule</code> : 이 예제에서는 <code>GreetingModule</code> 클래스를 의미합니다.</li>\n<li><code>providers</code> : 인자로 받은 객체로 설정된 프로바이더를 의미합니다.</li>\n</ul>\n<!--\nIn the <live-example name=\"ngmodules\">live example</live-example>\nthe root `AppModule` imports the `GreetingModule` and adds the\n`providers` to the `AppModule` providers. Specifically,\nAngular accumulates all imported providers\nbefore appending the items listed in `@NgModule.providers`.\nThis sequence ensures that whatever you add explicitly to\nthe `AppModule` providers takes precedence over the providers\nof imported modules.\n-->\n<p>이 문서와 관련된 예제를 <live-example name=\"ngmodules\">예제 앱</live-example>에서 열어보면, <code>AppModule</code>이 <code>GreetingModule</code>을 로드하고, <code>GreetingModule</code>에서 제공하는 서비스 프로바이더도 <code>Appmodule</code>에 로드합니다. 좀 더 정확하게 설명하면, <code>AppModule</code>의 <code>providers</code> 목록은 아무것도 없지만, 모듈의 <code>imports</code>로 불러오는 다른 모듈에 서비스 프로바이더가 존재하면 이 서비스 프로바이더를 현재 모듈의 <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code>보다 먼저 등록합니다. 그래서 현재 모듈이 다른 모듈의 서비스를 의존성으로 주입받을 때, 이 의존성은 현재 모듈의 프로바이더보다 먼저 등록되었기 때문에 문제없이 사용할 수 있습니다.</p>\n<!--\nThe sample app imports `GreetingModule` and uses its `forRoot()` method one time, in `AppModule`. Registering it once like this prevents multiple instances.\n\nYou can also add a `forRoot()` method in the `GreetingModule` that configures\nthe greeting `UserService`.\n-->\n<p><code>GreetingModule</code>은 <code>forRoot()</code> 메소드를 사용해서 <code>AppModule</code>에 딱 한 번만 로드되며, 이렇게 로드하면 인스턴스가 중복 생성되는 것을 방지할 수 있습니다.</p>\n<p><code>GreetingModule</code>의 <code>forRoot()</code> 메소드는 <code>UserService</code> 서비스를 설정하는 용도로도 사용할 수 있습니다.</p>\n<!--\nIn the following example, the optional, injected `UserServiceConfig`\nextends the greeting `UserService`. If a `UserServiceConfig` exists, the `UserService` sets the user name from that config.\n-->\n<p>아래 예제에서 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code>로 주입되는 <code>UserServiceConfig</code> 객체는 <code>UserService</code>의 환경을 설정하는 용도로 사용됩니다. 그래서 <code>UserServiceConfig</code> 객체가 존재하면 이 객체로 전달받은 사용자의 이름으로 <code>UserService</code>를 설정할 수 있습니다.</p>\n<!--\n<code-example path=\"ngmodules/src/app/greeting/user.service.ts\" region=\"ctor\" header=\"src/app/greeting/user.service.ts (constructor)\">\nconstructor(@Optional() config?: UserServiceConfig) {\n  if (config) { this._userName = config.userName; }\n}\n\n</code-example>\n-->\n<code-example path=\"ngmodules/src/app/greeting/user.service.ts\" region=\"ctor\" header=\"src/app/greeting/user.service.ts (생성자)\">\nconstructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() config?: UserServiceConfig) {\n  if (config) { this._userName = config.userName; }\n}\n\n</code-example>\n<!--\nHere's `forRoot()` that takes a `UserServiceConfig` object:\n-->\n<p>그리고 <code>UserServiceConfig</code> 객체를 활용하는 <code>forRoot()</code> 함수는 다음과 같이 정의합니다.</p>\n<code-example path=\"ngmodules/src/app/greeting/greeting.module.ts\" region=\"for-root\" header=\"src/app/greeting/greeting.module.ts (forRoot)\">\n<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> forRoot(config: UserServiceConfig): <a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a>&#x3C;GreetingModule> {\n  return {\n    ngModule: GreetingModule,\n    providers: [\n      {provide: UserServiceConfig, useValue: config }\n    ]\n  };\n}\n\n</code-example>\n<!--\nLastly, call it within the `imports` list of the `AppModule`. In the following\nsnippet, other parts of the file are left out. For the complete file, see the <live-example name=\"ngmodules\"></live-example>, or continue to the next section of this document.\n-->\n<p>마지막으로 아래 코드 처럼 <code>AppModule</code>의 <code>imports</code> 배열에서 이 메소드를 실행합니다.\n이 코드는 일부만 표시되었으며 완전한 파일 내용을 보려면 <live-example name=\"ngmodules\"></live-example>를 참고하거나 다음 섹션을 참고하세요.</p>\n<!--\n<code-example path=\"ngmodules/src/app/app.module.ts\" region=\"import-for-root\" header=\"src/app/app.module.ts (imports)\">\nimport { GreetingModule } from &#39;./greeting/greeting.module&#39;;\n@NgModule({\n  imports: [\n    GreetingModule.forRoot({userName: &#39;Miss Marple&#39;}),\n  ],\n})\n\n</code-example>\n-->\n<code-example path=\"ngmodules/src/app/app.module.ts\" region=\"import-for-root\" header=\"src/app/app.module.ts (imports 배열)\">\nimport { GreetingModule } from './greeting/greeting.module';\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    GreetingModule.forRoot({userName: 'Miss Marple'}),\n  ],\n})\n\n</code-example>\n<!--\nThe app displays \"Miss Marple\" as the user instead of the default \"Sherlock Holmes\".\n-->\n<p>이제 이 애플리케이션은 기본값인 \"Sherlock Holmes\" 대신 \"Miss Marple\"을 화면에 표시합니다.</p>\n<!--\nRemember to import `GreetingModule` as a Javascript import at the top of the file and don't add it to more than one `@NgModule` `imports` list.\n-->\n<p><code>GreetingModule</code>은 파일의 가장 위쪽에 JavaScript <code>import</code> 키워드로 로드하며, <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>의 <code>imports</code>에 딱 한 번만 등록한다는 것을 잊지 마세요.</p>\n<!-- KW--Does this mean that if we need it elsewhere we only import it at the top? I thought the services would all be available since we were importing it into `AppModule` in `providers`. -->\n<!--\n## Prevent reimport of the `GreetingModule`\n-->\n<h2 id=\"greetingmodule-중복로드-방지하기\"><code>GreetingModule</code> 중복로드 방지하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#greetingmodule-중복로드-방지하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nOnly the root `AppModule` should import the `GreetingModule`. If a\nlazy-loaded module imports it too, the app can generate\n[multiple instances](guide/ngmodule-faq#q-why-bad) of a service.\n-->\n<p><code>GreetingModule</code>은 최상위 <code>AppModule</code>에서만 로드해야 합니다. 만약 지연로딩하는 모듈에서도 <code>GreetingModule</code>을 로드하게 되면 <a href=\"guide/ngmodule-faq#q-why-bad\">싱글턴 서비스의 인스턴스가 여러개 생성</a>됩니다.</p>\n<!--\nTo guard against a lazy loaded module re-importing `GreetingModule`, add the following `GreetingModule` constructor.\n-->\n<p>그래서 지연로딩하는 모듈이 <code>GreetingModule</code>을 중복로드하는 것을 방지하려면 <code>GreetingModule</code> 생성자를 다음과 같이 작성하면 됩니다.</p>\n<code-example path=\"ngmodules/src/app/greeting/greeting.module.ts\" region=\"ctor\" header=\"src/app/greeting/greeting.module.ts\">\nconstructor (@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() parentModule?: GreetingModule) {\n  if (parentModule) {\n    throw new Error(\n      'GreetingModule is already loaded. Import it in the AppModule only');\n  }\n}\n\n</code-example>\n<!--\nThe constructor tells Angular to inject the `GreetingModule` into itself.\nThe injection would be circular if Angular looked for\n`GreetingModule` in the _current_ injector, but the `@SkipSelf()`\ndecorator means \"look for `GreetingModule` in an ancestor\ninjector, above me in the injector hierarchy.\"\n-->\n<p>이 생성자는 <code>GreetingModule</code> 자신을 의존성으로 주입하라고 요청합니다. 이 의존성 주입이 <em>현재</em> 인젝터 계층에서 이루어지면 순환 참조를 발생시킬 수 있습니다. 그래서 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 데코레이터를 사용해서 현재 인젝터 계층보다 상위 계층에서 의존성 객체를 찾도록 지정합니다.</p>\n<!--\nBy default, the injector throws an error when it can't\nfind a requested provider.\nThe `@Optional()` decorator means not finding the service is OK.\nThe injector returns `null`, the `parentModule` parameter is null,\nand the constructor concludes uneventfully.\n-->\n<p>기본적으로 인젝터가 의존성 객체를 찾지 못하면 에러가 발생합니다. 하지만 이 경우는 의존성으로 주입하지 않는 것이 정상 시나리오이기 때문에 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code> 데코레이터를 붙여서 의존성 주입에 실패해도 에러가 아니라는 것을 지정했습니다. 그래서 인젝터가 주입하는 객체는 <code>null</code>이 되고, <code>parentModule</code> 프로퍼티에 할당되는 값도 <code>null</code>이 되며, 에러는 발생하지 않고 생성자는 종료됩니다.</p>\n<!--\nIt's a different story if you improperly import `GreetingModule` into a lazy loaded module such as `CustomersModule`.\n\nAngular creates a lazy loaded module with its own injector,\na child of the root injector.\n`@SkipSelf()` causes Angular to look for a `GreetingModule` in the parent injector, which this time is the root injector.\nOf course it finds the instance imported by the root `AppModule`.\nNow `parentModule` exists and the constructor throws the error.\n-->\n<p>하지만 <code>CustomersModule</code>과 같이 지연로딩되는 모듈에서 <code>GreetingModule</code>을 로드하는 경우에는 상황이 조금 다릅니다.</p>\n<p>지연로딩되는 모듈에는 인젝터가 따로 생성되는데, 이 인젝터는 최상위 인젝터의 자식 인젝터입니다. 그리고 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 데코레이터가 사용되었기 때문에 부모 인젝터 계층에서 <code>GreetingModule</code>을 찾기 시작하는데, 이 경우에는 최상위 인젝터에서 의존성 객체를 찾습니다.\n이번에는 당연하게도 <code>AppModule</code>에 있는 <code>GreetingModule</code> 인스턴스를 찾게 됩니다.\n그래서 <code>parentModule</code> 프로퍼티에 객체가 할당되기 때문에 생성자는 에러를 발생시킵니다.</p>\n<!--\nHere are the two files in their entirety for reference:\n-->\n<p>설명한 내용을 코드로 확인해 보세요.</p>\n<code-tabs>\n <code-pane header=\"app.module.ts\" path=\"ngmodules/src/app/app.module.ts\">\n\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\n\n/* 애플리케이션 최상위 컴포넌트 */\nimport { AppComponent } from './app.component';\n\n/* 기능 모듈 */\nimport { ContactModule } from './contact/contact.module';\nimport { GreetingModule } from './greeting/greeting.module';\n\n/* 라우팅 모듈 */\nimport { AppRoutingModule } from './app-routing.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    ContactModule,\n    GreetingModule.forRoot({userName: 'Miss Marple'}),\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n\n</code-pane>\n <code-pane header=\"greeting.module.ts\" region=\"whole-greeting-module\" path=\"ngmodules/src/app/greeting/greeting.module.ts\">\nimport { <a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a>, <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>, <a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>, <a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a> } from '@angular/core';\n\nimport { <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> } from '@angular/common';\n\nimport { GreetingComponent } from './greeting.component';\nimport { UserServiceConfig } from './user.service';\n\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports:      [ <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> ],\n  declarations: [ GreetingComponent ],\n  exports:      [ GreetingComponent ]\n})\nexport class GreetingModule {\n  constructor (@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() parentModule?: GreetingModule) {\n    if (parentModule) {\n      throw new Error(\n        'GreetingModule is already loaded. Import it in the AppModule only');\n    }\n  }\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> forRoot(config: UserServiceConfig): <a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a>&#x3C;GreetingModule> {\n    return {\n      ngModule: GreetingModule,\n      providers: [\n        {provide: UserServiceConfig, useValue: config }\n      ]\n    };\n  }\n}\n\n</code-pane>\n</code-tabs>\n<hr>\n<!--\n## More on NgModules\n-->\n<h2 id=\"ngmodule-더-알아보기\">NgModule 더 알아보기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#ngmodule-더-알아보기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nYou may also be interested in:\n* [Sharing Modules](guide/sharing-ngmodules), which elaborates on the concepts covered on this page.\n* [Lazy Loading Modules](guide/lazy-loading-ngmodules).\n* [NgModule FAQ](guide/ngmodule-faq).\n-->\n<p>다음 내용에 대해서도 확인해 보세요.</p>\n<ul>\n<li><a href=\"guide/sharing-ngmodules\">모듈 공유하기</a></li>\n<li><a href=\"guide/lazy-loading-ngmodules\">기능모듈 지연로딩</a></li>\n<li><a href=\"guide/ngmodule-faq\">NgModule FAQ</a></li>\n</ul>\n\n</div>\n\n<!-- links to this doc:\n - guide/creating-libraries\n - guide/lazy-loading-ngmodules\n - guide/ngmodule-faq\n - guide/providers\n - guide/router\n - guide/router-tutorial\n-->\n<!-- links from this doc:\n - api/common/CommonModule\n - api/core/Injectable\n - api/core/ModuleWithProviders\n - api/core/NgModule\n - api/core/NgModule#providers\n - api/core/Optional\n - api/core/SkipSelf\n - api/platform-browser/BrowserModule\n - api/router/Router\n - api/router/RouterLink\n - api/router/RouterModule\n - api/router/RouterOutlet\n - api/upgrade/static\n - guide/lazy-loading-ngmodules\n - guide/ngmodule-faq\n - guide/ngmodule-faq#q-why-bad\n - guide/sharing-ngmodules\n - guide/singleton-services#forroot-패턴\n - guide/singleton-services#forroot와-router\n - guide/singleton-services#greetingmodule-중복로드-방지하기\n - guide/singleton-services#how-forroot-works\n - guide/singleton-services#ngmodule-더-알아보기\n - guide/singleton-services#ngmodule의-providers-배열\n - guide/singleton-services#providedIn\n - guide/singleton-services#providedin-사용하기\n - guide/singleton-services#싱글턴-서비스-singleton-services\n - guide/singleton-services#싱글턴-서비스-생성하기\n - tutorial\n - tutorial/toh-pt4\n - https://github.com/angular/angular/edit/master/aio/content/guide/singleton-services.md?message=docs%3A%20describe%20your%20change...\n-->"
}