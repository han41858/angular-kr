{
  "id": "guide/singleton-services",
  "title": "싱글턴 서비스 (Singleton services)",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/singleton-services.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Singleton services\n-->\n<h1 id=\"싱글턴-서비스-singleton-services\">싱글턴 서비스 (Singleton services)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#싱글턴-서비스-singleton-services\"><i class=\"material-icons\">link</i></a></h1>\n<!--\n#### Prerequisites:\n-->\n<h4 id=\"사전지식\">사전지식<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#사전지식\"><i class=\"material-icons\">link</i></a></h4>\n<!--\n* A basic understanding of [Bootstrapping](guide/bootstrapping).\n* Familiarity with [Providers](guide/providers).\n-->\n<p>다음 내용을 먼저 이해하고 이 문서를 보는 것이 좋습니다.</p>\n<ul>\n<li><a href=\"guide/bootstrapping\">부트스트랩</a></li>\n<li><a href=\"guide/providers\">프로바이더</a></li>\n</ul>\n<!--\nFor a sample app using the app-wide singleton service that this page describes, see the\n<live-example name=\"ngmodules\"></live-example> showcasing all the documented features of NgModules.\n-->\n<p>이 문서에서는 앱 전역에서 싱글턴으로 동작하는 서비스를 만들어봅니다. 이 문서에서 다루는 모든 예제 코드는 <live-example name=\"ngmodules\"></live-example>에서 직접 확인하거나 다운받아 확인할 수 있습니다.</p>\n<hr>\n<!--\n## Providing a singleton service\n-->\n<h2 id=\"싱글턴-서비스-생성하기\">싱글턴 서비스 생성하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#싱글턴-서비스-생성하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThere are two ways to make a service a singleton in Angular:\n-->\n<p>Angular에서 서비스를 싱글턴으로 사용하는 방법은 두 가지가 있습니다:</p>\n<!--\n* Declare that the service should be provided in the application root.\n* Include the service in the `AppModule` or in a module that is only imported by the `AppModule`.\n-->\n<ul>\n<li>서비스 프로바이더를 애플리케이션 루트에 선언하는 방법</li>\n<li>서비스를 <code>AppModule</code>에 선언하고 다른 모듈에서 <code>AppModule</code>만 로드하는 방법</li>\n</ul>\n<!--\nBeginning with Angular 6.0, the preferred way to create a singleton services is to specify on the service that it should be provided in the application root. This is done by setting `providedIn` to `root` on the service's `@Injectable` decorator:\n-->\n<p>Angular 6.0부터는 싱글턴 서비스를 만들 때 서비스 프로바이더를 애플리케이션 루트에 등록하도록 명시적으로 정의하는 방법을 권장합니다. 이 방법은 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> 데코레이터 중 <code><a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a></code> 프로퍼티를 <code>root</code>로 지정하면 됩니다:</p>\n<code-example path=\"providers/src/app/user.service.0.ts\" header=\"src/app/user.service.0.ts\" linenums=\"false\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class UserService {\n}\n\n\n</code-example>\n<!--\nFor more detailed information on services, see the [Services](tutorial/toh-pt4) chapter of the\n[Tour of Heroes tutorial](tutorial).\n-->\n<p>서비스에 대한 더 자세한 정보는 <a href=\"tutorial\">히어로들의 여행 튜토리얼</a>의 <a href=\"tutorial/toh-pt4\">서비스</a> 문서를 확인하세요.</p>\n<h2 id=\"forroot\"><code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">forRoot()</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#forroot\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nIf a module provides both providers and declarations (components, directives, pipes) then loading it in a child injector such as a route, would duplicate the provider instances. The duplication of providers would cause issues as they would shadow the root instances, which are probably meant to be singletons. For this reason Angular provides a way to separate providers out of the module so that same module can be imported into the root module with `providers` and child modules without `providers`.\n-->\n<p>모듈의 인젝터와 모듈 내부의 구성요소(컴포넌트, 디렉티브, 파이프)에 같은 프로바이더가 정의되어 있는 경우가 생길 수 있습니다. 이 경우에는 자식 트리에서 생성한 인스턴스가 최상위 인스턴스를 가리기 때문에 문제가 될 수 있으며, 싱글턴 서비스를 사용해서 이 문제를 방지해야 합니다. 이 때 Angular가 제공하는 방법을 사용하면 자식 모듈에 지정했던 <code>providers</code>를 모듈 외부로 옮기고, 최상위 앱 모듈에서만 이 프로바이더를 사용하도록 지정할 수 있습니다.</p>\n<!--\n1. Create a static method `forRoot()` (by convention) on the module.\n2. Place the providers into the `forRoot` method as follows.\n-->\n<ol>\n<li>(사용하기 편하도록) 모듈에 정적 메소드 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">forRoot()</a></code>를 정의합니다.</li>\n<li>프로바이더를 이 함수 안에 등록합니다.</li>\n</ol>\n<!-- MH: show a simple example how to do that without going to deep into it. -->\n<!--\nTo make this more concrete, consider the `RouterModule` as an example. `RouterModule` needs to provide the `Router` service, as well as the `RouterOutlet` directive. `RouterModule` has to be imported by the root application module so that the application has a `Router` and the application has at least one `RouterOutlet`. It also must be imported by the individual route components so that they can place `RouterOutlet` directives into their template for sub-routes.\n-->\n<p>이 내용을 자세하게 살펴보기 위해, <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>을 예로 들어봅시다. <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>에는 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 서비스 프로바이더를 등록하며, 이 모듈에는 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code> 디렉티브도 정의되어 있습니다. 이 모듈은 최상위 앱 모듈에 로드되고, 애플리케이션은 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>와 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>을 사용합니다. 그리고 이 모듈은 다른 모듈에도 로드되며, 서브 라우팅 템플릿을 표시하는 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code> 디렉티브도 제공합니다.</p>\n<!--\nIf the `RouterModule` didn’t have `forRoot()` then each route component would instantiate a new `Router` instance, which would break the application as there can only be one `Router`. For this reason, the `RouterModule` has the `RouterOutlet` declaration so that it is available everywhere, but the `Router` provider is only in the `forRoot()`. The result is that the root application module imports `RouterModule.forRoot(...)` and gets a `Router`, whereas all route components import `RouterModule` which does not include the `Router`.\n-->\n<p>만약 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>에 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">forRoot()</a></code> 메소드가 없다면, 네비게이션을 할 때마다 새로운 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 인스턴스가 만들어지고, 라우팅 컴포넌트도 계속 생성될 것입니다. 그러면 애플리케이션이 제대로 동작할 수 없기 때문에 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 인스턴스는 하나만 존재해야 합니다. 그래서 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>은 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>과 같은 디렉티브는 모듈 안쪽 어디에서라도 자유롭게 사용할 수 있도록 허용하지만, <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>의 프로바이더는 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">forRoot()</a></code> 안에서만 허용합니다. 그래서 애플리케이션 최상위 모듈에서는 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code>를 로드해서 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>가 포함된 모듈을 가져오고, 하위 모듈에서는 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>을 로드해서 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>가 없는 모듈을 가져옵니다.</p>\n<!--\nIf you have a module which provides both providers and declarations, use this pattern to separate them out.\n-->\n<p>만약 프로바이더와 컴포넌트 등록을 함께 하고 있는 모듈이 있다면, 이 패턴을 사용해서 용도에 맞게 분리할 수 있는지 검토해 보세요.</p>\n<!--\nA module that adds providers to the application can offer a\nfacility for configuring those providers as well through the\n`forRoot()` method.\n-->\n<p>애플리케이션에 등록할 프로바이더를 제공하는 모듈이라면, 이 프로바이더를 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">forRoot()</a></code> 메소드를 통해 제공하는 것이 좋습니다.</p>\n<!--\n`forRoot()` takes a service configuration object and returns a\n[ModuleWithProviders](api/core/ModuleWithProviders), which is\na simple object with the following properties:\n-->\n<p><code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">forRoot()</a></code> 함수는 서비스 설정 객체를 인자로 받아서 <a href=\"api/core/ModuleWithProviders\">ModuleWithProviders</a>를 반환하는데, 이 모듈에는 다음과 같은 프로퍼티가 있습니다:</p>\n<!--\n* `ngModule`: in this example, the `CoreModule` class.\n* `providers`: the configured providers.\n-->\n<ul>\n<li><code>ngModule</code> : 이 예제에서는 <code>CoreModule</code> 클래스를 의미합니다.</li>\n<li><code>providers</code> : 인자로 받은 객체로 설정된 프로바이더를 의미합니다.</li>\n</ul>\n<!--\nIn the <live-example name=\"ngmodules\">live example</live-example>\nthe root `AppModule` imports the `CoreModule` and adds the\n`providers` to the `AppModule` providers. Specifically,\nAngular accumulates all imported providers\nbefore appending the items listed in `@NgModule.providers`.\nThis sequence ensures that whatever you add explicitly to\nthe `AppModule` providers takes precedence over the providers\nof imported modules.\n-->\n<p>이 문서와 관련된 예제를 <live-example name=\"ngmodules\">live example</live-example>에서 열어보면, <code>AppModule</code>이 <code>CoreModule</code>을 로드하고, <code>CoreModule</code>에서 제공하는 서비스 프로바이더도 <code>Appmodule</code>에 로드합니다. 좀 더 정확하게 설명하면, <code>AppModule</code>의 <code>providers</code> 목록은 아무것도 없지만, 모듈의 <code><a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a></code>로 불러오는 다른 모듈에 서비스 프로바이더가 존재하면 이 서비스 프로바이더를 현재 모듈의 <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code>보다 먼저 등록합니다. 그래서 현재 모듈이 다른 모듈의 서비스를 의존성으로 주입받을 때, 이 의존성은 현재 모듈의 프로바이더보다 먼저 등록되었기 때문에 문제없이 사용할 수 있습니다.</p>\n<!--\nImport `CoreModule` and use its `forRoot()` method one time, in `AppModule`, because it registers services and you only want to register those services one time in your app. If you were to register them more than once, you could end up with multiple instances of the service and a runtime error.\n-->\n<p><code>CoreModule</code>은 <code>AppModule</code>에 딱 한 번만, <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">forRoot()</a></code> 메소드를 사용해서 로드해야 합니다. 왜냐하면 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">forRoot()</a></code>를 사용해야 싱글턴 서비스 프로바이더를 등록할 수 있는데, 이 서비스 프로바이더들은 앱 전체에서 한 번만 등록되어야 하기 때문입니다. 싱글턴 서비스 프로바이더를 여러번 등록하면 이 서비스가 여러번 생성되면서 런타임 에러가 발생할 수 있습니다.</p>\n<!--\nYou can also add a `forRoot()` method in the `CoreModule` that configures\nthe core `UserService`.\n-->\n<p><code>CoreModule</code>의 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">forRoot()</a></code> 메소드는 코어 서비스인 <code>UserService</code>를 설정하는 용도로도 사용할 수 있습니다.</p>\n<!--\nIn the following example, the optional, injected `UserServiceConfig`\nextends the core `UserService`. If a `UserServiceConfig` exists, the `UserService` sets the user name from that config.\n-->\n<p>아래 예제에서 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code>로 주입되는 <code>UserServiceConfig</code> 객체는 <code>UserService</code>의 환경을 설정하는 용도로 사용됩니다. 그래서 <code>UserServiceConfig</code> 객체가 존재하면 이 객체로 전달받은 사용자의 이름으로 <code>UserService</code>를 설정할 수 있습니다.</p>\n<!--\n<code-example path=\"ngmodules/src/app/core/user.service.ts\" region=\"ctor\" header=\"src/app/core/user.service.ts (constructor)\" linenums=\"false\">\n-->\n<code-example path=\"ngmodules/src/app/core/user.service.ts\" region=\"ctor\" header=\"src/app/core/user.service.ts (생성자)\" linenums=\"false\">\nconstructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() <a href=\"api/router/Router#config\" class=\"code-anchor\">config</a>: UserServiceConfig) {\n  if (<a href=\"api/router/Router#config\" class=\"code-anchor\">config</a>) { this._userName = config.userName; }\n}\n\n</code-example>\n<!--\nHere's `forRoot()` that takes a `UserServiceConfig` object:\n-->\n<p>그리고 <code>UserServiceConfig</code> 객체를 활용하는 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">forRoot()</a></code> 함수는 다음과 같이 정의합니다.</p>\n<code-example path=\"ngmodules/src/app/core/core.module.ts\" region=\"for-root\" header=\"src/app/core/core.module.ts (forRoot)\" linenums=\"false\">\n<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> forRoot(<a href=\"api/router/Router#config\" class=\"code-anchor\">config</a>: UserServiceConfig): <a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a> {\n  return {\n    ngModule: CoreModule,\n    providers: [\n      {provide: UserServiceConfig, useValue: <a href=\"api/router/Router#config\" class=\"code-anchor\">config</a> }\n    ]\n  };\n}\n\n</code-example>\n<!--\nLastly, call it within the `imports` list of the `AppModule`.\n-->\n<p>이제 이 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">forRoot()</a></code> 메소드는 <code>AppModule</code>의 <code><a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a></code>에 다음과 같이 사용합니다.</p>\n<code-example path=\"ngmodules/src/app/app.module.ts\" region=\"import-for-root\" header=\"src/app/app.module.ts (imports)\" linenums=\"false\">\nimport { CoreModule } from './core/core.module';\n/* . . . */\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    ContactModule,\n    CoreModule.forRoot({userName: 'Miss Marple'}),\n    AppRoutingModule\n  ],\n/* . . . */\n})\nexport class AppModule { }\n\n</code-example>\n<!--\nThe app displays \"Miss Marple\" as the user instead of the default \"Sherlock Holmes\".\n-->\n<p>이제 이 애플리케이션은 기본값인 \"Sherlock Holmes\" 대신 \"Miss Marple\"을 화면에 표시합니다.</p>\n<!--\nRemember to _import_ `CoreModule` as a Javascript import at the top of the file; don't add it to more than one `@NgModule` `imports` list.\n-->\n<p><code>CoreModule</code>은 파일의 가장 위쪽에 JavaScript <code>import</code> 키워드로 로드하며, <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>의 <code><a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a></code>에 딱 한 번만 등록한다는 것을 잊지 마세요.</p>\n<!-- KW--Does this mean that if we need it elsewhere we only import it at the top? I thought the services would all be available since we were importing it into `AppModule` in `providers`. -->\n<!--\n## Prevent reimport of the `CoreModule`\n-->\n<h2 id=\"coremodule-중복로드-방지하기\"><code>CoreModule</code> 중복로드 방지하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#coremodule-중복로드-방지하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nOnly the root `AppModule` should import the `CoreModule`. If a\nlazy-loaded module imports it too, the app can generate\n[multiple instances](guide/ngmodule-faq#q-why-bad) of a service.\n-->\n<p><code>CoreModule</code>은 최상위 <code>AppModule</code>에서만 로드해야 합니다. 만약 지연로딩하는 모듈에서도 <code>CoreModule</code>을 로드하게 되면 <a href=\"guide/ngmodule-faq#q-why-bad\">싱글턴 서비스의 인스턴스가 여러개 생성</a>됩니다.</p>\n<!--\nTo guard against a lazy-loaded module re-importing `CoreModule`, add the following `CoreModule` constructor.\n-->\n<p>그래서 지연로딩하는 모듈이 <code>CoreModule</code>을 중복로드하는 것을 방지하려면 <code>CoreModule</code> 생성자를 다음과 같이 작성하면 됩니다.</p>\n<code-example path=\"ngmodules/src/app/core/core.module.ts\" region=\"ctor\" header=\"src/app/core/core.module.ts\" linenums=\"false\">\nconstructor (@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() parentModule: CoreModule) {\n  if (parentModule) {\n    throw new Error(\n      'CoreModule is already loaded. Import it in the AppModule only');\n  }\n}\n\n</code-example>\n<!--\nThe constructor tells Angular to inject the `CoreModule` into itself.\nThe injection would be circular if Angular looked for\n`CoreModule` in the _current_ injector. The `@SkipSelf`\ndecorator means \"look for `CoreModule` in an ancestor\ninjector, above me in the injector hierarchy.\"\n-->\n<p>이 생성자는 <code>CoreModule</code> 자신을 의존성으로 주입하라고 요청합니다. 이 의존성 주입이 <em>현재</em> 인젝터 계층에서 이루어지면 순환 참조를 발생시킬 수 있습니다. 그래서 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 데코레이터를 사용해서 현재 인젝터 계층보다 상위 계층에서 의존성 객체를 찾도록 지정합니다.</p>\n<!--\nIf the constructor executes as intended in the `AppModule`,\nthere would be no ancestor injector that could provide an instance of `CoreModule` and the injector should give up.\n-->\n<p>이 생성자가 <code>AppModule</code>에서 실행되면 <code>AppModule</code>보다 상위 계층의 인젝터는 없기 때문에 <code>CoreModule</code>의 인스턴스는 주입되지 않습니다.</p>\n<!--\nBy default, the injector throws an error when it can't\nfind a requested provider.\nThe `@Optional` decorator means not finding the service is OK.\nThe injector returns `null`, the `parentModule` parameter is null,\nand the constructor concludes uneventfully.\n-->\n<p>기본적으로 인젝터가 의존성 객체를 찾지 못하면 에러가 발생합니다. 하지만 이 경우는 의존성으로 주입하지 않는 것이 정상 시나리오이기 때문에 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code> 데코레이터를 붙여서 의존성 주입에 실패해도 에러가 아니라는 것을 지정했습니다. 그래서 인젝터가 주입하는 객체는 <code>null</code>이 되고, <code>parentModule</code> 프로퍼티에 할당되는 값도 <code>null</code>이 되며, 에러는 발생하지 않고 생성자는 종료됩니다.</p>\n<!--\nIt's a different story if you improperly import `CoreModule` into a lazy-loaded module such as `CustomersModule`.\n-->\n<p>하지만 <code>CustomersModule</code>과 같이 지연로딩되는 모듈에서 <code>CoreModule</code>을 로드하는 경우에는 상황이 조금 다릅니다.</p>\n<!--\nAngular creates a lazy-loaded module with its own injector,\na _child_ of the root injector.\n`@SkipSelf` causes Angular to look for a `CoreModule` in the parent injector, which this time is the root injector.\nOf course it finds the instance imported by the root `AppModule`.\nNow `parentModule` exists and the constructor throws the error.\n-->\n<p>지연로딩되는 모듈에는 인젝터가 따로 생성되는데, 이 인젝터는 최상위 인젝터의 <em>자식</em> 인젝터입니다. 그리고 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 데코레이터가 사용되었기 때문에 부모 인젝터 계층에서 <code>CoreModule</code>을 찾기 시작하는데, 이 경우에는 최상위 인젝터에서 의존성 객체를 찾습니다.\n이번에는 당연하게도 <code>AppModule</code>에 있는 <code>CoreModule</code> 인스턴스를 찾게 됩니다.\n그래서 <code>parentModule</code> 프로퍼티에 객체가 할당되기 때문에 생성자는 에러를 발생시킵니다.</p>\n<!--\nHere are the two files in their entirety for reference:\n-->\n<p>설명한 내용을 코드로 확인해 보세요.</p>\n<code-tabs linenums=\"false\">\n <code-pane header=\"app.module.ts\" path=\"ngmodules/src/app/app.module.ts\">\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\n\n/* 애플리케이션 최상위 컴포넌트 */\nimport { AppComponent } from './app.component';\n\n/* 기능 모듈 */\nimport { ContactModule } from './contact/contact.module';\nimport { CoreModule } from './core/core.module';\n\n/* 라우팅 모듈 */\nimport { AppRoutingModule } from './app-routing.module';\n\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    ContactModule,\n    CoreModule.forRoot({userName: 'Miss Marple'}),\n    AppRoutingModule\n  ],\n  providers: [],\n  <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [\n    AppComponent\n  ],\n  <a href=\"api/core/NgModule#bootstrap\" class=\"code-anchor\">bootstrap</a>: [AppComponent]\n})\nexport class AppModule { }\n\n\n</code-pane>\n <code-pane header=\"core.module.ts\" region=\"whole-core-module\" path=\"ngmodules/src/app/core/core.module.ts\">\nimport { <a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a>, <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>, <a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>, <a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a> } from '@angular/core';\n\nimport { <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> } from '@angular/common';\n\nimport { TitleComponent } from './title.component';\nimport { UserService } from './user.service';\nimport { UserServiceConfig } from './user.service';\n\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>:      [ <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> ],\n  <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [ TitleComponent ],\n  <a href=\"api/core/NgModule#exports\" class=\"code-anchor\">exports</a>:      [ TitleComponent ],\n  providers:    [ UserService ]\n})\nexport class CoreModule {\n  constructor (@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() parentModule: CoreModule) {\n    if (parentModule) {\n      throw new Error(\n        'CoreModule is already loaded. Import it in the AppModule only');\n    }\n  }\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> forRoot(<a href=\"api/router/Router#config\" class=\"code-anchor\">config</a>: UserServiceConfig): <a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a> {\n    return {\n      ngModule: CoreModule,\n      providers: [\n        {provide: UserServiceConfig, useValue: <a href=\"api/router/Router#config\" class=\"code-anchor\">config</a> }\n      ]\n    };\n  }\n}\n\n</code-pane>\n</code-tabs>\n<hr>\n<!--\n## More on NgModules\n-->\n<h2 id=\"ngmodule-더-알아보기\">NgModule 더 알아보기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#ngmodule-더-알아보기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nYou may also be interested in:\n* [Sharing Modules](guide/sharing-ngmodules), which elaborates on the concepts covered on this page.\n* [Lazy Loading Modules](guide/lazy-loading-ngmodules).\n* [NgModule FAQ](guide/ngmodule-faq).\n-->\n<p>다음 내용에 대해서도 확인해 보세요.</p>\n<ul>\n<li><a href=\"guide/sharing-ngmodules\">모듈 공유하기</a></li>\n<li><a href=\"guide/lazy-loading-ngmodules\">기능모듈 지연로딩</a></li>\n<li><a href=\"guide/ngmodule-faq\">NgModule FAQ</a></li>\n</ul>\n\n</div>\n\n<!-- links to this doc:\n - guide/ngmodule-faq\n - guide/providers\n - guide/router\n-->\n<!-- links from this doc:\n - api/common/CommonModule\n - api/core/Injectable\n - api/core/Injectable#providedIn\n - api/core/ModuleWithProviders\n - api/core/NgModule\n - api/core/NgModule#bootstrap\n - api/core/NgModule#declarations\n - api/core/NgModule#exports\n - api/core/NgModule#imports\n - api/core/NgModule#providers\n - api/core/Optional\n - api/core/SkipSelf\n - api/platform-browser/BrowserModule\n - api/router/Router\n - api/router/Router#config\n - api/router/RouterModule\n - api/router/RouterModule#forRoot\n - api/router/RouterOutlet\n - api/upgrade/static\n - guide/bootstrapping\n - guide/lazy-loading-ngmodules\n - guide/ngmodule-faq\n - guide/ngmodule-faq#q-why-bad\n - guide/providers\n - guide/sharing-ngmodules\n - guide/singleton-services#coremodule-중복로드-방지하기\n - guide/singleton-services#forroot\n - guide/singleton-services#ngmodule-더-알아보기\n - guide/singleton-services#사전지식\n - guide/singleton-services#싱글턴-서비스-singleton-services\n - guide/singleton-services#싱글턴-서비스-생성하기\n - tutorial\n - tutorial/toh-pt4\n - https://github.com/angular/angular/edit/master/aio/content/guide/singleton-services.md?message=docs%3A%20describe%20your%20change...\n-->"
}