{
  "id": "guide/aot-metadata-errors",
  "title": "AOT 메타데이터 에러",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/aot-metadata-errors.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# AOT metadata errors\n-->\n<h1 id=\"aot-메타데이터-에러\">AOT 메타데이터 에러<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-metadata-errors#aot-메타데이터-에러\"><i class=\"material-icons\">link</i></a></h1>\n<!--\nThe following are metadata errors you may encounter, with explanations and suggested corrections.\n-->\n<p>AOT 컴파일러를 사용하다보면 다음과 같은 에러가 발생할 수 있습니다.\n이 에러가 왜 발생하는지, 어떻게 해결하면 되는지 알아봅시다.</p>\n<p><a href=\"guide/aot-metadata-errors#expression-form-not-supported\">Expression form not supported</a><br>\n<a href=\"guide/aot-metadata-errors#reference-to-a-local-symbol\">Reference to a local (non-exported) symbol</a><br>\n<a href=\"guide/aot-metadata-errors#only-initialized-variables\">Only initialized variables and constants</a><br>\n<a href=\"guide/aot-metadata-errors#reference-to-a-non-exported-class\">Reference to a non-exported class</a><br>\n<a href=\"guide/aot-metadata-errors#reference-to-a-non-exported-function\">Reference to a non-exported function</a><br>\n<a href=\"guide/aot-metadata-errors#function-calls-not-supported\">Function calls are not supported</a><br>\n<a href=\"guide/aot-metadata-errors#destructured-variable-not-supported\">Destructured variable or constant not supported</a><br>\n<a href=\"guide/aot-metadata-errors#could-not-resolve-type\">Could not resolve type</a><br>\n<a href=\"guide/aot-metadata-errors#name-expected\">Name expected</a><br>\n<a href=\"guide/aot-metadata-errors#unsupported-enum-member-name\">Unsupported enum member name</a><br>\n<a href=\"guide/aot-metadata-errors#tagged-template-expressions-not-supported\">Tagged template expressions are not supported</a><br>\n<a href=\"guide/aot-metadata-errors#symbol-reference-expected\">Symbol reference expected</a><br></p>\n<hr>\n<a id=\"expression-form-not-supported\"></a>\n<h2 id=\"expression-form-not-supported\">Expression form not supported<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-metadata-errors#expression-form-not-supported\"><i class=\"material-icons\">link</i></a></h2>\n<div class=\"alert is-helpful\">\n<!--\n*The compiler encountered an expression it didn't understand while evaluating Angular metadata.*\n-->\n<p><em>메타데이터 표현식에 지원하지 않는 문법이 사용되었습니다.</em></p>\n</div>\n<!--\nLanguage features outside of the compiler's [restricted expression syntax](guide/aot-compiler#expression-syntax)\ncan produce this error, as seen in the following example:\n\n```ts\n// ERROR\nexport class Fooish { ... }\n...\nconst prop = typeof Fooish; // typeof is not valid in metadata\n  ...\n  // bracket notation is not valid in metadata\n  { provide: 'token', useValue: { [prop]: 'value' } };\n  ...\n```\n\nYou can use `typeof` and bracket notation in normal application code.\nYou just can't use those features within expressions that define Angular metadata.\n\nAvoid this error by sticking to the compiler's [restricted expression syntax](guide/aot-compiler#expression-syntax)\nwhen writing Angular metadata\nand be wary of new or unusual TypeScript features.\n-->\n<p>AOT 컴파일러는 <a href=\"guide/aot-compiler#expression-syntax\">제한된 기능으로만 표현식 문법</a>을 지원합니다.\n다음과 같은 코드는 에러가 발생합니다:</p>\n<code-example language=\"ts\">\n// 에러\nexport class Fooish { ... }\n...\nconst prop = typeof Fooish; // typeof는 메타데이터에 사용할 수 없습니다.\n  ...\n  // 메타데이터에서 대괄호 참조를 사용할 수 없습니다.\n  { provide: 'token', useValue: { [prop]: 'value' } };\n  ...\n</code-example>\n<p>애플리케이션 코드에는 <code>typeof</code> 연산자나 대괄호 참조를 사용할 수 있습니다.\n하지만 이런 코드는 Angular 메타데이터 표현식에 사용할 수 없습니다.</p>\n<p>이 에러를 해결하려면 Angular 메타데이터에 사용할 수 있는 <a href=\"guide/aot-compiler#expression-syntax\">제한된 표현식 문법</a>으로만 코드를 작성해야 합니다.\n사용하려는 TypeScript 기능을 지원하는지 확인해 보세요.</p>\n<hr>\n<a id=\"reference-to-a-local-symbol\"></a>\n<h2 id=\"reference-to-a-local-non-exported-symbol\">Reference to a local (non-exported) symbol<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-metadata-errors#reference-to-a-local-non-exported-symbol\"><i class=\"material-icons\">link</i></a></h2>\n<div class=\"alert is-helpful\">\n<!--\n_Reference to a local (non-exported) symbol 'symbol name'. Consider exporting the symbol._\n-->\n<p><em>로컬 심볼을 사용했습니다. 심볼을 파일 외부로 공개(export)하세요.</em></p>\n</div>\n<!--\nThe compiler encountered a referenced to a locally defined symbol that either wasn't exported or wasn't initialized.\n\nHere's a `provider` example of the problem.\n\n```ts\n// ERROR\nlet foo: number; // neither exported nor initialized\n\n@Component({\n  selector: 'my-component',\n  template: ... ,\n  providers: [\n    { provide: Foo, useValue: foo }\n  ]\n})\nexport class MyComponent {}\n```\nThe compiler generates the component factory, which includes the `useValue` provider code, in a separate module. _That_ factory module can't reach back to _this_ source module to access the local (non-exported) `foo` variable.\n\nYou could fix the problem by initializing `foo`.\n\n```ts\nlet foo = 42; // initialized\n```\n\nThe compiler will [fold](guide/aot-compiler#code-folding) the expression into the provider as if you had written this.\n\n```ts\n  providers: [\n    { provide: Foo, useValue: 42 }\n  ]\n```\n\nAlternatively, you can fix it by exporting `foo` with the expectation that `foo` will be assigned at runtime when you actually know its value.\n\n```ts\n// CORRECTED\nexport let foo: number; // exported\n\n@Component({\n  selector: 'my-component',\n  template: ... ,\n  providers: [\n    { provide: Foo, useValue: foo }\n  ]\n})\nexport class MyComponent {}\n```\n\nAdding `export` often works for variables referenced in metadata such as `providers` and `animations` because the compiler can generate _references_ to the exported variables in these expressions. It doesn't need the _values_ of those variables.\n\nAdding `export` doesn't work when the compiler needs the _actual value_\nin order to generate code.\nFor example, it doesn't work for the `template` property.\n\n```ts\n// ERROR\nexport let someTemplate: string; // exported but not initialized\n\n@Component({\n  selector: 'my-component',\n  template: someTemplate\n})\nexport class MyComponent {}\n```\n\nThe compiler needs the value of the `template` property _right now_ to generate the component factory.\nThe variable reference alone is insufficient.\nPrefixing the declaration with `export` merely produces a new error, \"[`Only initialized variables and constants can be referenced`](#only-initialized-variables)\".\n-->\n<p>외부로 공개(export)되지 않은 심볼이 사용되었거나 이 변수가 초기화되지 않았을 때 발생합니다.</p>\n<p>아래 코드에서는 <code>provider</code>를 처리할 때 발생합니다.</p>\n<code-example language=\"ts\">\n// 에러\nlet foo: number; // export로 지정되지 않았으며 초기화되지도 않았습니다.\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: ... ,\n  providers: [\n    { provide: Foo, useValue: foo }\n  ]\n})\nexport class MyComponent {}\n</code-example>\n<p>컴파일러는 다른 모듈에 있는 프로바이더를 참조하는 <code>useValue</code> 코드를 만났을 때 컴포넌트 팩토리를 생성합니다.\n이 때 현재 모듈에서 사용하는 심볼 <code>foo</code>는 모듈 외부로 공개되지 않았기 때문에 외부 모듈이 현재 소스 코드에 접근할 수 없습니다.</p>\n<p>먼저 <code>foo</code>를 초기화하지 않은 문제부터 해결해 봅시다.</p>\n<code-example language=\"ts\">\nlet foo = 42; // 초기화\n</code-example>\n<p>그러면 컴파일러가 표현식을 <a href=\"guide/aot-compiler#code-folding\">폴딩</a>하면서 다음과 같은 형태로 변환합니다.</p>\n<code-example language=\"ts\">\n  providers: [\n    { provide: Foo, useValue: 42 }\n  ]\n</code-example>\n<p><code>foo</code> 변수값이 실행시점에 할당되기 때문에 이 변수를 사용하는 시점에 언제나 값이 존재한다면 <code>foo</code> 변수에 <code>export</code>를 지정하는 방법으로도 해결할 수 있습니다.</p>\n<code-example language=\"ts\">\n// 정상 코드\nexport let foo: number; // export로 지정됨\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: ... ,\n  providers: [\n    { provide: Foo, useValue: foo }\n  ]\n})\nexport class MyComponent {}\n</code-example>\n<p><code>export</code>를 지정하는 방식은 <code>providers</code>나 <code>animations</code>에 사용하는 변수에 활용하면 이 에러를 해결할 수 있습니다.\n컴파일러는 이런 표현식을 처리할 때 변수를 <em>참조</em> 하는 코드만 생성하기 때문입니다.\n이 시점에는 변수에 어떤 값이 있느냐는 중요하지 않습니다.</p>\n<p>하지만 컴파일러 처리 단계에서 <em>실제로 값이 필요한 경우</em> 에는 사용할 수 없습니다.\n아래 코드에서는 <code>template</code> 프로퍼티를 처리할 때 문제가 발생합니다.</p>\n<code-example language=\"ts\">\n// 에러\nexport let someTemplate: string; // export가 지정되었지만 초기화되지 않았습니다.\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: someTemplate\n})\nexport class MyComponent {}\n</code-example>\n<p>컴파일러가 컴포넌트 팩토리를 생성하려면 <code>template</code> 프로퍼티 값이 <em>컴파일러 처리 시점</em> 에 필요합니다.\n변수만 지정하는 것으로는 해결되지 않습니다.</p>\n<p>때로는 <code>export</code>를 지정하더라도 \"<a href=\"guide/aot-metadata-errors#only-initialized-variables\"><code>Only initialized variables and constants can be referenced</code></a>\" 에러가 발생할 수 있으니 주의하세요.</p>\n<hr>\n<a id=\"only-initialized-variables\"></a>\n<h2 id=\"only-initialized-variables-and-constants\">Only initialized variables and constants<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-metadata-errors#only-initialized-variables-and-constants\"><i class=\"material-icons\">link</i></a></h2>\n<div class=\"alert is-helpful\">\n<!--\n_Only initialized variables and constants can be referenced because the value of this variable is needed by the template compiler._\n-->\n<p><em>템플릿 컴파일러가 참조하는 변수의 값이 할당되지 않았습니다.</em></p>\n</div>\n<!--\nThe compiler found a reference to an exported variable or static field that wasn't initialized.\nIt needs the value of that variable to generate code.\n\nThe following example tries to set the component's `template` property to the value of\nthe exported `someTemplate` variable which is declared but _unassigned_.\n\n```ts\n// ERROR\nexport let someTemplate: string;\n\n@Component({\n  selector: 'my-component',\n  template: someTemplate\n})\nexport class MyComponent {}\n```\n\nYou'd also get this error if you imported `someTemplate` from some other module and neglected to initialize it there.\n\n```ts\n// ERROR - not initialized there either\nimport { someTemplate } from './config';\n\n@Component({\n  selector: 'my-component',\n  template: someTemplate\n})\nexport class MyComponent {}\n```\n\nThe compiler cannot wait until runtime to get the template information.\nIt must statically derive the value of the `someTemplate` variable from the source code\nso that it can generate the component factory, which includes\ninstructions for building the element based on the template.\n\nTo correct this error, provide the initial value of the variable in an initializer clause _on the same line_.\n\n```ts\n// CORRECTED\nexport let someTemplate = '<h1>Greetings from Angular</h1>';\n\n@Component({\n  selector: 'my-component',\n  template: someTemplate\n})\nexport class MyComponent {}\n```\n-->\n<p>컴파일러가 참조하는 <code>export</code> 변수나 정적 필드의 값이 할당되지 않았을 때 발생합니다.\n코드를 생성하려면 이 변수의 값이 필요합니다.</p>\n<p>아래 코드에서 컴포넌트 <code>template</code> 프로퍼티에 사용된 변수 <code>someTemplate</code>는 <code>export</code>가 지정되었지만 값이 <em>할당되지 않았습니다</em>.</p>\n<code-example language=\"ts\">\n// 에러\nexport let someTemplate: string;\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: someTemplate\n})\nexport class MyComponent {}\n</code-example>\n<p>이 에러는 <code>someTemplate</code> 변수를 다른 모듈에서 참조해 오는 경우에도 발생할 수 있습니다.</p>\n<code-example language=\"ts\">\n// 에러 - 다른 모듈에서도 초기화하지 않은 경우\nimport { someTemplate } from './config';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: someTemplate\n})\nexport class MyComponent {}\n</code-example>\n<p>템플릿 정보는 컴파일 시점에 처리되어야 합니다.\n컴포넌트 팩토리 코드를 생성하려면 <code>someTemplate</code> 변수의 실제 값이 반드시 할당되어 있어야 하기 때문입니다.\n그래야 템플릿 안에 사용된 다른 엘리먼트를 확인할 수 있습니다.</p>\n<p>이 에러를 해결하려면 변수의 초기값을 할당하면 됩니다.</p>\n<code-example language=\"ts\">\n// 정상 코드\nexport let someTemplate = '&#x3C;h1>Greetings from Angular&#x3C;/h1>';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: someTemplate\n})\nexport class MyComponent {}\n</code-example>\n<hr>\n<a id=\"reference-to-a-non-exported-class\"></a>\n<h2 id=\"reference-to-a-non-exported-class\">Reference to a non-exported class<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-metadata-errors#reference-to-a-non-exported-class\"><i class=\"material-icons\">link</i></a></h2>\n<div class=\"alert is-helpful\">\n<!--\n_Reference to a non-exported class <class name>. Consider exporting the class._\n-->\n<p><em>외부로 공개(export)되지 않은 클래스 이름이 사용되었습니다. 클래스를 파일 외부로 공개하세요.</em></p>\n</div>\n<!--\nMetadata referenced a class that wasn't exported.\n\nFor example, you may have defined a class and used it as an injection token in a providers array\nbut neglected to export that class.\n\n```ts\n// ERROR\nabstract class MyStrategy { }\n\n  ...\n  providers: [\n    { provide: MyStrategy, useValue: ... }\n  ]\n  ...\n```\n\nAngular generates a class factory in a separate module and that\nfactory [can only access exported classes](guide/aot-compiler#exported-symbols).\nTo correct this error, export the referenced class.\n\n```ts\n// CORRECTED\nexport abstract class MyStrategy { }\n\n  ...\n  providers: [\n    { provide: MyStrategy, useValue: ... }\n  ]\n  ...\n```\n-->\n<p>메타데이터에서 외부로 공개되지 않은 클래스를 참조했습니다.</p>\n<p>클래스를 선언해서 프로바이더 배열에 추가했지만 이 클래스가 파일 외부로 공개되지 않았을 때 발생합니다.</p>\n<code-example language=\"ts\">\n// 에러\nabstract class MyStrategy { }\n\n  ...\n  providers: [\n    { provide: MyStrategy, useValue: ... }\n  ]\n  ...\n</code-example>\n<p>Angular는 별도 모듈로 클래스 팩토리를 생성하기 때문에 <a href=\"guide/aot-compiler#exported-symbols\">외부로 공개된 클래스만 참조할 수 있습니다</a>.\n이 에러를 해결하려면 클래스에 <code>export</code>를 붙이면 됩니다.</p>\n<code-example language=\"ts\">\n// 정상 코드\nexport abstract class MyStrategy { }\n\n  ...\n  providers: [\n    { provide: MyStrategy, useValue: ... }\n  ]\n  ...\n</code-example>\n<hr>\n<a id=\"reference-to-a-non-exported-function\"></a>\n<h2 id=\"reference-to-a-non-exported-function\">Reference to a non-exported function<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-metadata-errors#reference-to-a-non-exported-function\"><i class=\"material-icons\">link</i></a></h2>\n<div class=\"alert is-helpful\">\n<!--\n*Metadata referenced a function that wasn't exported.*\n-->\n<p><em>메타데이터에서 외부로 공개되지 않은 함수를 참조했습니다.</em></p>\n</div>\n<!--\nFor example, you may have set a providers `useFactory` property to a locally defined function that you neglected to export.\n\n```ts\n// ERROR\nfunction myStrategy() { ... }\n\n  ...\n  providers: [\n    { provide: MyStrategy, useFactory: myStrategy }\n  ]\n  ...\n```\n\nAngular generates a class factory in a separate module and that\nfactory [can only access exported functions](guide/aot-compiler#exported-symbols).\nTo correct this error, export the function.\n\n```ts\n// CORRECTED\nexport function myStrategy() { ... }\n\n  ...\n  providers: [\n    { provide: MyStrategy, useFactory: myStrategy }\n  ]\n  ...\n```\n-->\n<p>프로바이더에 <code>useFactory</code>를 사용했는데, 이 때 외부로 공개되지 않은 로컬 함수를 사용했을 때 발생합니다.</p>\n<code-example language=\"ts\">\n// 에러\nfunction myStrategy() { ... }\n\n  ...\n  providers: [\n    { provide: MyStrategy, useFactory: myStrategy }\n  ]\n  ...\n</code-example>\n<p>Angular는 별도 모듈로 클래스 팩토리를 생성하기 때문에 <a href=\"guide/aot-compiler#exported-symbols\">외부로 공개된 함수만 참조할 수 있습니다</a>.\n이 에러를 해결하려면 함수에 <code>export</code>를 붙이면 됩니다.</p>\n<code-example language=\"ts\">\n// 정상 코드\nexport function myStrategy() { ... }\n\n  ...\n  providers: [\n    { provide: MyStrategy, useFactory: myStrategy }\n  ]\n  ...\n</code-example>\n<hr>\n<a id=\"function-calls-not-supported\"></a>\n<h2 id=\"function-calls-are-not-supported\">Function calls are not supported<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-metadata-errors#function-calls-are-not-supported\"><i class=\"material-icons\">link</i></a></h2>\n<div class=\"alert is-helpful\">\n<!--\n_Function calls are not supported. Consider replacing the function or lambda with a reference to an exported function._\n-->\n<p><em>메타데이터 안에서는 함수를 실행할 수 없습니다. 익명 함수나 람다 함수 대신 이름이 있는 함수에 <code>export</code>를 지정해서 사용하세요.</em></p>\n</div>\n<!--\nThe compiler does not currently support [function expressions or lambda functions](guide/aot-compiler#function-expression).\nFor example, you cannot set a provider's `useFactory` to an anonymous function or arrow function like this.\n\n```ts\n// ERROR\n  ...\n  providers: [\n    { provide: MyStrategy, useFactory: function() { ... } },\n    { provide: OtherStrategy, useFactory: () => { ... } }\n  ]\n  ...\n```\nYou also get this error if you call a function or method in a provider's `useValue`.\n\n```ts\n// ERROR\nimport { calculateValue } from './utilities';\n\n  ...\n  providers: [\n    { provide: SomeValue, useValue: calculateValue() }\n  ]\n  ...\n```\n\nTo correct this error, export a function from the module and refer to the function in a `useFactory` provider instead.\n\n```ts\n// CORRECTED\nimport { calculateValue } from './utilities';\n\nexport function myStrategy() { ... }\nexport function otherStrategy() { ... }\nexport function someValueFactory() {\n  return calculateValue();\n}\n  ...\n  providers: [\n    { provide: MyStrategy, useFactory: myStrategy },\n    { provide: OtherStrategy, useFactory: otherStrategy },\n    { provide: SomeValue, useFactory: someValueFactory }\n  ]\n  ...\n```\n-->\n<p>AOT 컴파일러는 <a href=\"guide/aot-compiler#function-expression\">함수 표현식이나 람다 함수</a>를 지원하지 않습니다.\n그래서 <code>providers</code> 배열에 <code>useFactory</code>를 사용할 때 다음과 같이 익명 함수를 사용하면 에러가 발생합니다.</p>\n<code-example language=\"ts\">\n// 에러\n  ...\n  providers: [\n    { provide: MyStrategy, useFactory: function() { ... } },\n    { provide: OtherStrategy, useFactory: () => { ... } }\n  ]\n  ...\n</code-example>\n<p>그리고 다음과 같이 <code>providers</code> 배열에 <code>useValue</code>를 사용하면서 함수를 실행해도 이 에러가 발생합니다.</p>\n<code-example language=\"ts\">\n// 에러\nimport { calculateValue } from './utilities';\n\n  ...\n  providers: [\n    { provide: SomeValue, useValue: calculateValue() }\n  ]\n  ...\n</code-example>\n<p>이 에러를 해결하려면 함수에 이름을 지정하고 <code>export</code>로 지정한 후에 <code>providers</code>에 <code>useFactory</code>로 등록하면 됩니다.</p>\n<code-example language=\"ts\">\n// 정상 코드\nimport { calculateValue } from './utilities';\n\nexport function myStrategy() { ... }\nexport function otherStrategy() { ... }\nexport function someValueFactory() {\n  return calculateValue();\n}\n  ...\n  providers: [\n    { provide: MyStrategy, useFactory: myStrategy },\n    { provide: OtherStrategy, useFactory: otherStrategy },\n    { provide: SomeValue, useFactory: someValueFactory }\n  ]\n  ...\n</code-example>\n<hr>\n<a id=\"destructured-variable-not-supported\"></a>\n<h2 id=\"destructured-variable-or-constant-not-supported\">Destructured variable or constant not supported<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-metadata-errors#destructured-variable-or-constant-not-supported\"><i class=\"material-icons\">link</i></a></h2>\n<div class=\"alert is-helpful\">\n<!--\n_Referencing an exported destructured variable or constant is not supported by the template compiler. Consider simplifying this to avoid destructuring._\n-->\n<p><em>비구조화 할당으로 초기화한 변수를 참조했습니다. AOT 컴파일러는 비구조화 할당을 지원하지 않습니다.</em></p>\n</div>\n<!--\nThe compiler does not support references to variables assigned by [destructuring](https://www.typescriptlang.org/docs/handbook/variable-declarations.html#destructuring).\n\nFor example, you cannot write something like this:\n\n```ts\n// ERROR\nimport { configuration } from './configuration';\n\n// destructured assignment to foo and bar\nconst {foo, bar} = configuration;\n  ...\n  providers: [\n    {provide: Foo, useValue: foo},\n    {provide: Bar, useValue: bar},\n  ]\n  ...\n```\n\nTo correct this error, refer to non-destructured values.\n\n```ts\n// CORRECTED\nimport { configuration } from './configuration';\n  ...\n  providers: [\n    {provide: Foo, useValue: configuration.foo},\n    {provide: Bar, useValue: configuration.bar},\n  ]\n  ...\n```\n-->\n<p>AOT 컴파일러는 <a href=\"https://www.typescriptlang.org/docs/handbook/variable-declarations.html#destructuring\">비구조화 할당(destructuring)</a> 으로 초기화한 변수를 지원하지 않습니다.</p>\n<p>그래서 다음과 같이 작성하면 에러가 발생합니다:</p>\n<code-example language=\"ts\">\n// 에러\nimport { configuration } from './configuration';\n\n// foo, bar는 비구조화 할당으로 초기화했습니다.\nconst {foo, bar} = configuration;\n  ...\n  providers: [\n    {provide: Foo, useValue: foo},\n    {provide: Bar, useValue: bar},\n  ]\n  ...\n</code-example>\n<p>이 에러를 수정하려면 비구조화 할당 문법을 사용하지 않으면 됩니다.</p>\n<code-example language=\"ts\">\n// 정상 코드\nimport { configuration } from './configuration';\n  ...\n  providers: [\n    {provide: Foo, useValue: configuration.foo},\n    {provide: Bar, useValue: configuration.bar},\n  ]\n  ...\n</code-example>\n<hr>\n<a id=\"could-not-resolve-type\"></a>\n<h2 id=\"could-not-resolve-type\">Could not resolve type<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-metadata-errors#could-not-resolve-type\"><i class=\"material-icons\">link</i></a></h2>\n<div class=\"alert is-helpful\">\n<!--\n*The compiler encountered a type and can't determine which module exports that type.*\n-->\n<p><em>알 수 없는 타입이 사용되었습니다.</em></p>\n</div>\n<!--\nThis can happen if you refer to an ambient type.\nFor example, the `Window` type is an ambient type declared in the global `.d.ts` file.\n\nYou'll get an error if you reference it in the component constructor,\nwhich the compiler must statically analyze.\n\n```ts\n// ERROR\n@Component({ })\nexport class MyComponent {\n  constructor (private win: Window) { ... }\n}\n```\nTypeScript understands ambient types so you don't import them.\nThe Angular compiler does not understand a type that you neglect to export or import.\n\nIn this case, the compiler doesn't understand how to inject something with the `Window` token.\n\nDo not refer to ambient types in metadata expressions.\n\nIf you must inject an instance of an ambient type,\nyou can finesse the problem in four steps:\n\n1. Create an injection token for an instance of the ambient type.\n1. Create a factory function that returns that instance.\n1. Add a `useFactory` provider with that factory function.\n1. Use `@Inject` to inject the instance.\n\nHere's an illustrative example.\n\n```ts\n// CORRECTED\nimport { Inject } from '@angular/core';\n\nexport const WINDOW = new InjectionToken('Window');\nexport function _window() { return window; }\n\n@Component({\n  ...\n  providers: [\n    { provide: WINDOW, useFactory: _window }\n  ]\n})\nexport class MyComponent {\n  constructor (@Inject(WINDOW) private win: Window) { ... }\n}\n```\n\nThe `Window` type in the constructor is no longer a problem for the compiler because it\nuses the `@Inject(WINDOW)` to generate the injection code.\n\nAngular does something similar with the `DOCUMENT` token so you can inject the browser's `document` object (or an abstraction of it, depending upon the platform in which the application runs).\n\n```ts\nimport { Inject }   from '@angular/core';\nimport { DOCUMENT } from '@angular/platform-browser';\n\n@Component({ ... })\nexport class MyComponent {\n  constructor (@Inject(DOCUMENT) private doc: Document) { ... }\n}\n```\n-->\n<p>이 에러는 묵시적으로 사용하는 타입을 사용한 경우에 발생할 수 있습니다.\n전역 <code>.d.ts</code> 파일에 <code>Window</code> 타입이 정의되어 있다고 합시다.</p>\n<p>이 타입을 컴포넌트 생성자에 사용하면 에러가 발생합니다.\n컴파일러는 모든 타입을 정적으로 확인할 수 있어야 합니다.</p>\n<code-example language=\"ts\">\n// 에러\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({ })\nexport class MyComponent {\n  constructor (private win: Window) { ... }\n}\n</code-example>\n<p>묵시적인 타입은 TypeScript가 자동으로 인식할 수 있기 때문에 이 타입을 로드하지 않아도 코드를 작성할 수 있습니다.\n하지만 Angular 컴파일러는 출처가 정확하게 확인된 타입만 사용합니다.</p>\n<p>그래서 위와 같이 코드를 작성하면 <code>Window</code> 토큰와 연결된 의존성 객체를 어떻게 찾아야 하는지 Angular가 알 수 없습니다.</p>\n<p>메타데이터 표현식에는 암묵적인(ambient) 타입을 사용하면 안됩니다.</p>\n<p>다만, 묵시적인 타입의 인스턴스를 꼭 사용해야 한다면 다음 단계를 거쳐 사용할 수 있습니다:</p>\n<ol>\n<li>묵시적인 타입으로 의존성 주입 토큰을 생성합니다.</li>\n<li>인스턴스를 반환하는 팩토리 함수를 정의합니다.</li>\n<li>프로바이더에 <code>useFactory</code>를 사용해서 팩토리 함수를 등록합니다.</li>\n<li><code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code>를 사용해서 인스턴스를 의존성으로 주입합니다.</li>\n</ol>\n<p>코드로 살펴보면 이렇습니다.</p>\n<code-example language=\"ts\">\n// 정상 코드\nimport { <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a> } from '@angular/core';\n\nexport const WINDOW = new <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a>('Window');\nexport function _window() { return window; }\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  ...\n  providers: [\n    { provide: WINDOW, useFactory: _window }\n  ]\n})\nexport class MyComponent {\n  constructor (@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(WINDOW) private win: Window) { ... }\n}\n</code-example>\n<p>이렇게 작성하면 생성자에 의존성으로 주입하기 위해 사용된 <code>Window</code> 타입은 더이상 문제가 되지 않습니다.\n<code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(WINDOW)</code>를 사용해서 타입을 정확하게 지정했기 때문입니다.</p>\n<p>이 방식은 브라우저의 <code>document</code> 객체를 의존성으로 주입할 때도 사용할 수 있습니다.\n플랫폼마다 사용방법이 조금씩 다를 수 있지만, <code><a href=\"api/common/DOCUMENT\" class=\"code-anchor\">DOCUMENT</a></code> 토큰을 아래 코드처럼 사용하면 됩니다.</p>\n<code-example language=\"ts\">\nimport { <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a> }   from '@angular/core';\nimport { <a href=\"api/common/DOCUMENT\" class=\"code-anchor\">DOCUMENT</a> } from '@angular/platform-browser';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({ ... })\nexport class MyComponent {\n  constructor (@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(<a href=\"api/common/DOCUMENT\" class=\"code-anchor\">DOCUMENT</a>) private doc: Document) { ... }\n}\n</code-example>\n<hr>\n<a id=\"name-expected\"></a>\n<h2 id=\"name-expected\">Name expected<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-metadata-errors#name-expected\"><i class=\"material-icons\">link</i></a></h2>\n<div class=\"alert is-helpful\">\n<!--\n*The compiler expected a name in an expression it was evaluating.*\n-->\n<p><em>표현식을 평가할 때 이름이 필요합니다.</em></p>\n</div>\n<!--\nThis can happen if you use a number as a property name as in the following example.\n\n```ts\n// ERROR\nprovider: [{ provide: Foo, useValue: { 0: 'test' } }]\n```\n\nChange the name of the property to something non-numeric.\n\n```ts\n// CORRECTED\nprovider: [{ provide: Foo, useValue: { '0': 'test' } }]\n```\n-->\n<p>이 에러는 객체의 프로퍼티명으로 숫자를 사용할 때 발생할 수 있습니다.</p>\n<code-example language=\"ts\">\n// 에러\nprovider: [{ provide: Foo, useValue: { 0: 'test' } }]\n</code-example>\n<p>이 에러를 해결하려면 숫자가 아닌 형태로 프로퍼티 이름을 선언하면 됩니다.</p>\n<code-example language=\"ts\">\n// 정상 코드\nprovider: [{ provide: Foo, useValue: { '0': 'test' } }]\n</code-example>\n<hr>\n<a id=\"unsupported-enum-member-name\"></a>\n<h2 id=\"unsupported-enum-member-name\">Unsupported enum member name<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-metadata-errors#unsupported-enum-member-name\"><i class=\"material-icons\">link</i></a></h2>\n<div class=\"alert is-helpful\">\n<!--\n*Angular couldn't determine the value of the [enum member](https://www.typescriptlang.org/docs/handbook/enums.html) that you referenced in metadata.*\n-->\n<p><em>메타데이터에 사용한 <a href=\"https://www.typescriptlang.org/docs/handbook/enums.html\">enum 멤버</a>의 값을 확인할 수 없습니다.</em></p>\n</div>\n<!--\nThe compiler can understand simple enum values but not complex values such as those derived from computed properties.\n\n```ts\n// ERROR\nenum Colors {\n  Red = 1,\n  White,\n  Blue = \"Blue\".length // computed\n}\n\n  ...\n  providers: [\n    { provide: BaseColor,   useValue: Colors.White } // ok\n    { provide: DangerColor, useValue: Colors.Red }   // ok\n    { provide: StrongColor, useValue: Colors.Blue }  // bad\n  ]\n  ...\n```\n\nAvoid referring to enums with complicated initializers or computed properties.\n-->\n<p>AOT 컴파일러는 간단한 enum 값을 참조할 수 있지만 추가 연산이 필요한 값은 참조할 수 없습니다.</p>\n<code-example language=\"ts\">\n// 에러\nenum Colors {\n  Red = 1,\n  White,\n  Blue = \"Blue\".length // computed\n}\n\n  ...\n  providers: [\n    { provide: BaseColor,   useValue: Colors.White } // ok\n    { provide: DangerColor, useValue: Colors.Red }   // ok\n    { provide: StrongColor, useValue: Colors.Blue }  // bad\n  ]\n  ...\n</code-example>\n<p>별도 초기화 로직이 있거나 추가 연산으로 프로퍼티 이름을 지정하는 방식은 사용하지 마세요.</p>\n<hr>\n<a id=\"tagged-template-expressions-not-supported\"></a>\n<h2 id=\"tagged-template-expressions-are-not-supported\">Tagged template expressions are not supported<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-metadata-errors#tagged-template-expressions-are-not-supported\"><i class=\"material-icons\">link</i></a></h2>\n<div class=\"alert is-helpful\">\n<!--\n_Tagged template expressions are not supported in metadata._\n-->\n<p><em>태그 템플릿 표현식은 지원하지 않습니다.</em></p>\n</div>\n<!--\nThe compiler encountered a JavaScript ES2015 [tagged template expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals) such as the following.\n\n```ts\n// ERROR\nconst expression = 'funky';\nconst raw = String.raw`A tagged template ${expression} string`;\n ...\n template: '<div>' + raw + '</div>'\n ...\n```\n[`String.raw()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/raw)\nis a _tag function_ native to JavaScript ES2015.\n\nThe AOT compiler does not support tagged template expressions; avoid them in metadata expressions.\n\n<hr>\n\n<a id=\"symbol-reference-expected\"></a>\n## Symbol reference expected\n\n<div class=\"alert is-helpful\">\n\n*The compiler expected a reference to a symbol at the location specified in the error message.*\n\n</div>\n\nThis error can occur if you use an expression in the `extends` clause of a class.\n-->\n<p>이 에러는 JavaScript ES2015 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals\">태그 템플릿 표현식</a>을 사용했을 때 발생합니다.</p>\n<code-example language=\"ts\">\n// 에러\nconst expression = 'funky';\nconst raw = String.raw`A tagged template ${expression} string`;\n ...\n template: '&#x3C;div>' + raw + '&#x3C;/div>'\n ...\n</code-example>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/raw\"><code>String.raw()</code></a>는 JavaScript ES2015부터 제공하는 <em>태그 함수</em> 입니다.</p>\n<p>하지만 AOT 컴파일러는 이 표현식을 지원하지 않습니다.</p>\n<hr>\n<a id=\"symbol-reference-expected\"></a>\n<h2 id=\"symbol-reference-expected\">Symbol reference expected<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-metadata-errors#symbol-reference-expected\"><i class=\"material-icons\">link</i></a></h2>\n<div class=\"alert is-helpful\">\n<!--\n*The compiler expected a reference to a symbol at the location specified in the error message.*\n-->\n<p><em>에러 메시지에 표시된 심볼을 제대로 참조하고 있는지 확인하세요.</em></p>\n</div>\n<!--\nThis error can occur if you use an expression in the `extends` clause of a class.\n-->\n<p>이 에러는 표현식 안에서 <code>extends</code>를 사용했을 때 발생합니다.</p>\n<!--\n\nChuck: After reviewing your PR comment I'm still at a loss. See [comment there](https://github.com/angular/angular/pull/17712#discussion_r132025495).\n\n-->\n\n</div>\n\n<!-- links to this doc:\n - guide/aot-compiler\n-->\n<!-- links from this doc:\n - api/common/DOCUMENT\n - api/core/Component\n - api/core/Inject\n - api/core/InjectionToken\n - guide/aot-compiler#code-folding\n - guide/aot-compiler#exported-symbols\n - guide/aot-compiler#expression-syntax\n - guide/aot-compiler#function-expression\n - guide/aot-metadata-errors#aot-메타데이터-에러\n - guide/aot-metadata-errors#could-not-resolve-type\n - guide/aot-metadata-errors#destructured-variable-not-supported\n - guide/aot-metadata-errors#destructured-variable-or-constant-not-supported\n - guide/aot-metadata-errors#expression-form-not-supported\n - guide/aot-metadata-errors#function-calls-are-not-supported\n - guide/aot-metadata-errors#function-calls-not-supported\n - guide/aot-metadata-errors#name-expected\n - guide/aot-metadata-errors#only-initialized-variables\n - guide/aot-metadata-errors#only-initialized-variables-and-constants\n - guide/aot-metadata-errors#reference-to-a-local-non-exported-symbol\n - guide/aot-metadata-errors#reference-to-a-local-symbol\n - guide/aot-metadata-errors#reference-to-a-non-exported-class\n - guide/aot-metadata-errors#reference-to-a-non-exported-function\n - guide/aot-metadata-errors#symbol-reference-expected\n - guide/aot-metadata-errors#tagged-template-expressions-are-not-supported\n - guide/aot-metadata-errors#tagged-template-expressions-not-supported\n - guide/aot-metadata-errors#unsupported-enum-member-name\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/raw\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals\n - https://github.com/angular/angular/edit/master/aio/content/guide/aot-metadata-errors.md?message=docs%3A%20describe%20your%20change...\n - https://www.typescriptlang.org/docs/handbook/enums.html\n - https://www.typescriptlang.org/docs/handbook/variable-declarations.html#destructuring\n-->"
}