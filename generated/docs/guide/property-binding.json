{
  "id": "guide/property-binding",
  "title": "프로퍼티 바인딩 [프로퍼티]",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/property-binding.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Property binding `[property]`\n-->\n<h1 id=\"프로퍼티-바인딩-프로퍼티\">프로퍼티 바인딩 <code>[프로퍼티]</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/property-binding#프로퍼티-바인딩-프로퍼티\"><i class=\"material-icons\">link</i></a></h1>\n<!--\nUse property binding to _set_ properties of target elements or\ndirective `@Input()` decorators.\n\n<div class=\"alert is-helpful\">\n\nSee the <live-example></live-example> for a working example containing the code snippets in this guide.\n\n</div>\n-->\n<p>프로퍼티 바인딩을 활용하면 엘리먼트, 디렉티브의 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터가 지정된 프로퍼티에 값을 할당할 수 있습니다.</p>\n<div class=\"alert is-helpful\">\n<p>이 문서에서 설명하는 내용은 <live-example></live-example>에서 직접 확인하거나 다운받아 확인할 수 있습니다.</p>\n</div>\n<!--\n## One-way in\n-->\n<h2 id=\"단방향-연결\">단방향 연결<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/property-binding#단방향-연결\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nProperty binding flows a value in one direction,\nfrom a component's property into a target element property.\n\nYou can't use property\nbinding to read or pull values out of target elements. Similarly, you cannot use\nproperty binding to call a method on the target element.\nIf the element raises events, you can listen to them with an [event binding](guide/event-binding).\n\nIf you must read a target element property or call one of its methods,\nsee the API reference for [ViewChild](api/core/ViewChild) and\n[ContentChild](api/core/ContentChild).\n-->\n<p>프로퍼티 바인딩은 컴포넌트 프로퍼티에서 대상 엘리먼트 프로퍼티로 향하는 단방향입니다.</p>\n<p>프로퍼티 바인딩은 대상 엘리먼트에 있는 특정 항목의 값을 읽는 용도로는 사용할 수 없습니다.\n마찬가지로 대상 엘리먼트에 있는 메서드를 실행할 수도 없습니다.\n엘리먼트에서 발생하는 이벤트를 감지하려면 프로퍼티 바인딩 대신 <a href=\"guide/event-binding\">이벤트 바인딩</a>을 사용해야 합니다.</p>\n<p>바인딩 대상 엘리먼트의 프로퍼티 값을 읽어야 하거나 메서드를 실행해야 한다면 <a href=\"api/core/ViewChild\">ViewChild</a>나 <a href=\"api/core/ContentChild\">ContentChild</a>를 참고하세요.</p>\n<!--\n## Examples\n-->\n<h2 id=\"예제\">예제<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/property-binding#예제\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe most common property binding sets an element property to a component\nproperty value. An example is\nbinding the `src` property of an image element to a component's `itemImageUrl` property:\n\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"property-binding\" header=\"src/app/app.component.html\">\n&lt;img [src]=&quot;itemImageUrl&quot;&gt;\n\n</code-example>\n\nHere's an example of binding to the `colSpan` property. Notice that it's not `colspan`,\nwhich is the attribute, spelled with a lowercase `s`.\n\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"colSpan\" header=\"src/app/app.component.html\">\n&lt;!-- colSpan 프로퍼티는 캐멀 케이스입니다. --&gt;\n&lt;tr&gt;&lt;td [colSpan]=&quot;2&quot;&gt;Span 2 columns&lt;/td&gt;&lt;/tr&gt;\n\n</code-example>\n\nFor more details, see the [MDN HTMLTableCellElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLTableCellElement) documentation.\n\nFor more information about `colSpan` and `colspan`, see the [Attribute binding](guide/attribute-binding#colspan) guide.\n\nAnother example is disabling a button when the component says that it `isUnchanged`:\n\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"disabled-button\" header=\"src/app/app.component.html\">\n&lt;!-- 버튼의 활성화 여부를 `isUnchanged` 프로퍼티와 바인딩합니다. --&gt;\n&lt;button [disabled]=&quot;isUnchanged&quot;&gt;Disabled Button&lt;/button&gt;\n\n</code-example>\n\nAnother is setting a property of a directive:\n\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"class-binding\" header=\"src/app/app.component.html\">\n&lt;p [ngClass]=&quot;classes&quot;&gt;[ngClass] binding to the classes property making this blue&lt;/p&gt;\n\n</code-example>\n\nYet another is setting the model property of a custom component&mdash;a great way\nfor parent and child components to communicate:\n\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"model-property-binding\" header=\"src/app/app.component.html\">\n&lt;app-item-detail [childItem]=&quot;parentItem&quot;&gt;&lt;/app-item-detail&gt;\n\n</code-example>\n-->\n<p>프로퍼티 바인딩은 일반적으로 컴포넌트 프로퍼티의 값을 바인딩하는 대상 엘리먼트의 프로퍼티로 전달하는 용도로 사용합니다.\n그래서 컴포넌트에 있는 <code>itemImageUrl</code> 프로퍼티 값을 이미지 엘리먼트의 <code>src</code> 프로퍼티로 바인딩하려면 다음과 같이 작성하면 됩니다:</p>\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"property-binding\" header=\"src/app/app.component.html\">\n&#x3C;img [src]=\"itemImageUrl\">\n\n</code-example>\n<p><code>colSpan</code> 프로퍼티를 바인딩하는 예제를 살펴봅시다.\n어트리뷰트 <code>colspan</code>이 아니라 대문자 <code>s</code>가 들어간 프로퍼티입니다.</p>\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"colSpan\" header=\"src/app/app.component.html\">\n&#x3C;!-- colSpan 프로퍼티는 캐멀 케이스입니다. -->\n&#x3C;tr>&#x3C;td [colSpan]=\"2\">Span 2 columns&#x3C;/td>&#x3C;/tr>\n\n</code-example>\n<p>이 프로퍼티에 대해 더 자세하게 알아보려면 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/HTMLTableCellElement\">MDN HTMLTableCellElement</a> 문서를 참고하세요.</p>\n<p>그리고 <code>colSpan</code>과 <code>colspan</code>의 차이점에 대해 알아보려면 <a href=\"guide/attribute-binding#colspan\">어트리뷰트 바인딩</a>  문서를 참고하세요.</p>\n<p>컴포넌트 프로퍼티 <code>isUnchanged</code> 값에 따라 버튼을 비활성화하는 예제도 살펴봅시다:</p>\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"disabled-button\" header=\"src/app/app.component.html\">\n&#x3C;!-- 버튼의 활성화 여부를 `isUnchanged` 프로퍼티와 바인딩합니다. -->\n&#x3C;button [disabled]=\"isUnchanged\">Disabled Button&#x3C;/button>\n\n</code-example>\n<p>디렉티브의 프로퍼티 값도 설정할 수 있습니다:</p>\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"class-binding\" header=\"src/app/app.component.html\">\n&#x3C;p [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"classes\">[<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>] binding to the classes property making this blue&#x3C;/p>\n\n</code-example>\n<p>아직 제대로 다루지 않았지만, 프로퍼티 바인딩은 부모 컴포넌트가 자식 컴포넌트로 데이터를 전달하는 용도로도 활용할 수 있습니다.</p>\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"model-property-binding\" header=\"src/app/app.component.html\">\n&#x3C;app-item-detail [childItem]=\"parentItem\">&#x3C;/app-item-detail>\n\n</code-example>\n<!--\n## Binding targets\n-->\n<h2 id=\"바인딩-대상\">바인딩 대상<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/property-binding#바인딩-대상\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAn element property between enclosing square brackets identifies the target property.\nThe target property in the following code is the image element's `src` property.\n\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"property-binding\" header=\"src/app/app.component.html\">\n&lt;img [src]=&quot;itemImageUrl&quot;&gt;\n\n</code-example>\n\nThere's also the `bind-` prefix alternative:\n\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"bind-prefix\" header=\"src/app/app.component.html\">\n&lt;img bind-src=&quot;itemImageUrl&quot;&gt;\n\n</code-example>\n\n\nIn most cases, the target name is the name of a property, even\nwhen it appears to be the name of an attribute.\nSo in this case, `src` is the name of the `<img>` element property.\n\nElement properties may be the more common targets,\nbut Angular looks first to see if the name is a property of a known directive,\nas it is in the following example:\n\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"class-binding\" header=\"src/app/app.component.html\">\n&lt;p [ngClass]=&quot;classes&quot;&gt;[ngClass] binding to the classes property making this blue&lt;/p&gt;\n\n</code-example>\n\nTechnically, Angular is matching the name to a directive `@Input()`,\none of the property names listed in the directive's `inputs` array\nor a property decorated with `@Input()`.\nSuch inputs map to the directive's own properties.\n\nIf the name fails to match a property of a known directive or element, Angular reports an “unknown directive” error.\n\n<div class=\"alert is-helpful\">\n\nThough the target name is usually the name of a property,\nthere is an automatic attribute-to-property mapping in Angular for\nseveral common attributes. These include `class`/`className`, `innerHtml`/`innerHTML`, and\n`tabindex`/`tabIndex`.\n\n</div>\n-->\n<p>프로퍼티 바인딩의 바인딩 대상은 엘리먼트 태그에서 대괄호(<code>[]</code>) 안에 있는 프로퍼티입니다.\n그래서 아래 예제에서는 엘리먼트의 <code>src</code> 프로퍼티가 바인딩 대상입니다.</p>\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"property-binding\" header=\"src/app/app.component.html\">\n&#x3C;img [src]=\"itemImageUrl\">\n\n</code-example>\n<p>대괄호를 사용할 수 없다면 <code>bind-</code> 접두사를 활용해서 프로퍼티를 바인딩할 수 있습니다:</p>\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"bind-prefix\" header=\"src/app/app.component.html\">\n&#x3C;img bind-src=\"itemImageUrl\">\n\n</code-example>\n<p>바인딩 대상이 되는 항목은 프로퍼티의 이름인 경우가 대부분이겠이며 어트리뷰트 이름을 사용하는 경우도 가끔 있습니다.\n위에서 살펴본 예제에서 <code>src</code>는 <code>&#x3C;img></code> 엘리먼트의 프로퍼티 이름입니다.</p>\n<p>Angular는 프로퍼티 바인딩 문법을 만나면 바인딩 대상이 디렉티브에 있는 프로퍼티인지 먼저 검사합니다.\n예제를 봅시다:</p>\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"class-binding\" header=\"src/app/app.component.html\">\n&#x3C;p [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"classes\">[<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>] binding to the classes property making this blue&#x3C;/p>\n\n</code-example>\n<p>Angular는 먼저 디렉티브의 <code>inputs</code> 배열에 해당 프로퍼티가 있는지, 디렉티브 클래스에 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터가 지정된 프로퍼티가 있는지 검사합니다.\n이 때 원하는 프로퍼티를 발견하면 해당 프로퍼티를 바인딩합니다.</p>\n<p>그리고 디렉티브나 엘리먼트에서 프로퍼티를 발견하지 못하면 \"unknown directive\" 에러를 발생시킵니다.</p>\n<div class=\"alert is-helpful\">\n<p>프로퍼티 바인딩 대상은 프로퍼티의 이름인 경우가 대부분이지만, 일부 어트리뷰트에 대해서는 어트리뷰트를 자동으로 프로퍼티와 매칭시키기도 합니다.\n<code>class</code>/<code>className</code>, <code>innerHtml</code>/<code>innerHTML</code>, <code>tabindex</code>/<code>tabIndex</code>의 경우가 그렇습니다.</p>\n</div>\n<a id=\"avoid-side-effects\"></a>\n<!--\n## Avoid side effects\n-->\n<h2 id=\"부수효과-최소화\">부수효과 최소화<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/property-binding#부수효과-최소화\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nEvaluation of a template expression should have no visible side effects.\nThe expression language itself, or the way you write template expressions,\nhelps to a certain extent;\nyou can't assign a value to anything in a property binding expression\nnor use the increment and decrement operators.\n\nFor example, you could have an expression that invoked a property or method that had\nside effects. The expression could call something like `getFoo()` where only you\nknow what `getFoo()` does. If `getFoo()` changes something\nand you happen to be binding to that something,\nAngular may or may not display the changed value. Angular may detect the\nchange and throw a warning error.\nAs a best practice, stick to properties and to methods that return\nvalues and avoid side effects.\n-->\n<p>템플릿 표현식은 실행되면서 부수효과(side effects)를 발생시키지 않는 것이 좋습니다.\n그래서 템플릿 표현식에는 할당연산자나 증감연산자를 사용할 수 없습니다.</p>\n<p>예를 들어, 템플릿 표현식에서 프로퍼티 값을 변경하거나 부수효과를 일으키는 메서드 <code>getFoo()</code>를 실행한다고 합시다.\n<code>getFoo()</code> 메서드가 어떤 동작을 하는지 정확하게 알고 있는 경우라면 괜찮습니다.\n하지만 <code>getFoo()</code> 메서드가 어떤 값을 바꾸고, 이 값이 또 어떤 값을 연쇄적으로 바꾼다면 이렇게 변경되는 값을 Angular가 제대로 감지하지 못할 수 있습니다.\n이 경우에는 콘솔에 경고 메시지가 출력됩니다.\n템플릿 표현식에는 프로퍼티 값을 참조하거나 부수효과가 없는 메서드를 실행하고 메서드가 반환한 값을 사용하는 것 정도가 가장 좋습니다.</p>\n<!--\n## Return the proper type\n-->\n<h2 id=\"적절한-타입-반환하기\">적절한 타입 반환하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/property-binding#적절한-타입-반환하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe template expression should evaluate to the type of value\nthat the target property expects.\nReturn a string if the target property expects a string, a number if it\nexpects a number, an object if it expects an object, and so on.\n\nIn the following example, the `childItem` property of the `ItemDetailComponent` expects a string, which is exactly what you're sending in the property binding:\n\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"model-property-binding\" header=\"src/app/app.component.html\">\n&lt;app-item-detail [childItem]=&quot;parentItem&quot;&gt;&lt;/app-item-detail&gt;\n\n</code-example>\n\nYou can confirm this by looking in the `ItemDetailComponent` where the `@Input` type is set to a string:\n<code-example path=\"property-binding/src/app/item-detail/item-detail.component.ts\" region=\"input-type\" header=\"src/app/item-detail/item-detail.component.ts (setting the @Input() type)\">\n@Input() childItem: string;\n\n</code-example>\n\nAs you can see here, the `parentItem` in `AppComponent` is a string, which the `ItemDetailComponent` expects:\n<code-example path=\"property-binding/src/app/app.component.ts\" region=\"parent-data-type\" header=\"src/app/app.component.ts\">\nparentItem = &#39;lamp&#39;;\n\n</code-example>\n-->\n<p>템플릿 표현식은 대상 프로퍼티의 타입과 맞는 타입을 반환해야 합니다.\n바인딩 된 프로퍼티 타입이 문자열이라면 문자열을 반환해야 하며, 숫자인 경우, 객체인 경우에도 마찬가지입니다.</p>\n<p>아래 예제에서 <code>ItemDetailComponent</code>에 있는 <code>childItem</code> 프로퍼티는 문자열 타입으로 지정되어 있기 때문에 이 프로퍼티를 바인딩 할 때도 문자열을 할당해야 합니다:</p>\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"model-property-binding\" header=\"src/app/app.component.html\">\n&#x3C;app-item-detail [childItem]=\"parentItem\">&#x3C;/app-item-detail>\n\n</code-example>\n<p>프로퍼티 타입은 <code>ItemDetailComponent</code>에서 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>이 지정된 프로퍼티의 타입을 보면 확인할 수 있습니다:</p>\n<code-example path=\"property-binding/src/app/item-detail/item-detail.component.ts\" region=\"input-type\" header=\"src/app/item-detail/item-detail.component.ts (@Input() 프로퍼티의 타입)\">\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() childItem: string;\n\n</code-example>\n<p>그래서 <code>AppComponent</code>에 있는 <code>parentItem</code>도 타입에 맞게 문자열을 지정했습니다:</p>\n<code-example path=\"property-binding/src/app/app.component.ts\" region=\"parent-data-type\" header=\"src/app/app.component.ts\">\nparentItem = 'lamp';\n\n</code-example>\n<!--\n### Passing in an object\n-->\n<h3 id=\"객체-전달하기\">객체 전달하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/property-binding#객체-전달하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe previous simple example showed passing in a string. To pass in an object,\nthe syntax and thinking are the same.\n\nIn this scenario, `ItemListComponent` is nested within `AppComponent` and the `items` property expects an array of objects.\n\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"pass-object\" header=\"src/app/app.component.html\">\n&lt;app-item-list [items]=&quot;currentItems&quot;&gt;&lt;/app-item-list&gt;\n\n</code-example>\n\nThe `items` property is declared in the `ItemListComponent` with a type of `Item` and decorated with `@Input()`:\n\n<code-example path=\"property-binding/src/app/item-list/item-list.component.ts\" region=\"item-input\" header=\"src/app/item-list.component.ts\">\n@Input() items: Item[];\n\n</code-example>\n\nIn this sample app, an `Item` is an object that has two properties; an `id` and a `name`.\n\n<code-example path=\"property-binding/src/app/item.ts\" region=\"item-class\" header=\"src/app/item.ts\">\nexport interface Item {\n  id: number;\n  name: string;\n}\n\n</code-example>\n\nWhile a list of items exists in another file, `mock-items.ts`, you can\nspecify a different item in `app.component.ts` so that the new item will render:\n\n<code-example path=\"property-binding/src/app/app.component.ts\" region=\"pass-object\" header=\"src/app.component.ts\">\ncurrentItems = [{\n  id: 21,\n  name: &#39;phone&#39;\n}];\n\n</code-example>\n\nYou just have to make sure, in this case, that you're supplying an array of objects because that's the type of `Item` and is what the nested component, `ItemListComponent`, expects.\n\nIn this example, `AppComponent` specifies a different `item` object\n(`currentItems`) and passes it to the nested `ItemListComponent`. `ItemListComponent` was able to use `currentItems` because it matches what an `Item` object is according to `item.ts`. The `item.ts` file is where\n`ItemListComponent` gets its definition of an `item`.\n-->\n<p>이전 예제에서는 간단하게 문자열을 전달하는 방법에 대해 알아봤습니다.\n객체를 전달하는 경우에도 문법과 개념은 같습니다.</p>\n<p><code>AppComponent</code> 안에 있는 <code>ItemListComponent</code>의 <code>items</code> 프로퍼티에 객체의 배열을 할당해야 한다고 합시다.</p>\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"pass-object\" header=\"src/app/app.component.html\">\n&#x3C;app-item-list [items]=\"currentItems\">&#x3C;/app-item-list>\n\n</code-example>\n<p><code>ItemListComponent</code>에 선언된 <code>items</code> 프로퍼티의 타입은 <code>Item</code> 배열이며 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터가 지정되어 있습니다:</p>\n<code-example path=\"property-binding/src/app/item-list/item-list.component.ts\" region=\"item-input\" header=\"src/app/item-list.component.ts\">\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() items: Item[];\n\n</code-example>\n<p>그리고 <code>Item</code> 객체에는 <code>id</code>, <code>name</code> 프로퍼티가 존재합니다.</p>\n<code-example path=\"property-binding/src/app/item.ts\" region=\"item-class\" header=\"src/app/item.ts\">\nexport interface Item {\n  id: number;\n  name: string;\n}\n\n</code-example>\n<p>아이템의 목록은 <code>mock-items.ts</code> 파일에 따로 저장되어 있지만, 렌더링이 잘 되는지 확인하기 위해 <code>app.component.ts</code> 파일에 임시 데이터를 할당합시다:</p>\n<code-example path=\"property-binding/src/app/app.component.ts\" region=\"pass-object\" header=\"src/app.component.ts\">\ncurrentItems = [{\n  id: 21,\n  name: 'phone'\n}];\n\n</code-example>\n<p>이 경우에도 <code>ItemListComponent</code>로 프로퍼티 바인딩하는 타입이 <code>Item</code> 배열이기 때문에 정확한 타입이 지정되어야 합니다.</p>\n<p>이렇게 작성하면 <code>AppComponent</code>에 있는 <code>currentItems</code> 프로퍼티의 값이 <code>ItemListComponent</code>로 전달됩니다.\n그리고 <code>ItemListComponent</code>는 <code>items</code>로 받는 데이터의 타입이 <code>Item</code> 객체 배열이기 때문에 이 데이터를 받아서 활용할 수 있습니다.</p>\n<!--\n## Remember the brackets\n-->\n<h2 id=\"대괄호를-빼먹지-마세요\">대괄호를 빼먹지 마세요<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/property-binding#대괄호를-빼먹지-마세요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe brackets, `[]`, tell Angular to evaluate the template expression.\nIf you omit the brackets, Angular treats the string as a constant\nand *initializes the target property* with that string:\n\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"no-evaluation\" header=\"src/app.component.html\">\n&lt;app-item-detail childItem=&quot;parentItem&quot;&gt;&lt;/app-item-detail&gt;\n\n</code-example>\n\n\nOmitting the brackets will render the string\n`parentItem`, not the value of `parentItem`.\n-->\n<p>Angular가 템플릿 표현식을 평가하려면 대괄호(<code>[]</code>)가 꼭 있어야 합니다.\n대괄호를 빼먹으면 Angular는 해당 문자열을 문자열 상수로 평가하며, 바인딩된 프로퍼티에도 문자열 값을 할당합니다:</p>\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"no-evaluation\" header=\"src/app.component.html\">\n&#x3C;app-item-detail childItem=\"parentItem\">&#x3C;/app-item-detail>\n\n</code-example>\n<p>대괄호를 생략하면 <code>parentItem</code>의 값이 아니라 <code>parentItem</code>이라는 문자열이 렌더링됩니다.</p>\n<!--\n## One-time string initialization\n-->\n<h2 id=\"문자열로-한-번만-초기화-할-때\">문자열로 한 번만 초기화 할 때<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/property-binding#문자열로-한-번만-초기화-할-때\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nYou *should* omit the brackets when all of the following are true:\n\n* The target property accepts a string value.\n* The string is a fixed value that you can put directly into the template.\n* This initial value never changes.\n\nYou routinely initialize attributes this way in standard HTML, and it works\njust as well for directive and component property initialization.\nThe following example initializes the `prefix` property of the `StringInitComponent` to a fixed string,\nnot a template expression. Angular sets it and forgets about it.\n\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"string-init\" header=\"src/app/app.component.html\">\n&lt;app-string-init prefix=&quot;This is a one-time initialized string.&quot;&gt;&lt;/app-string-init&gt;\n\n</code-example>\n\nThe `[item]` binding, on the other hand, remains a live binding to the component's `currentItems` property.\n-->\n<p>다음과 같은 경우라면 대괄호를 생략하는 것이 좋습니다:</p>\n<ul>\n<li>프로퍼티가 문자열 값을 받을 때</li>\n<li>문자열은 고정된 값이며 템플릿에서 직접 할당할 때</li>\n<li>이 값이 변경되지 않을 때</li>\n</ul>\n<p>표준 HTML에서도 어트리뷰트는 이런 방식으로 할당했습니다.\n그리고 이 방식은 디렉티브나 컴포넌트를 초기화할 때도 활용할 수 있습니다.\n아래 예제에서 <code>StringInitComponent</code>에 있는 <code>prefix</code> 프로퍼티는 고정된 문자열이며 템플릿 표현식으로 평가될 필요도 없습니다.\n그렇다면 이렇게 작성하면 됩니다.</p>\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"string-init\" header=\"src/app/app.component.html\">\n&#x3C;app-string-init prefix=\"This is a one-time initialized string.\">&#x3C;/app-string-init>\n\n</code-example>\n<p>하지만 <code>[item]</code>의 경우에는 컴포넌트에 있는 <code>currentItems</code> 프로퍼티를 참조해야 하기 때문에 이렇게 작성할 수 없습니다.</p>\n<!--\n## Property binding vs. interpolation\n-->\n<h2 id=\"프로퍼티-바인딩-vs-문자열-바인딩\">프로퍼티 바인딩 vs. 문자열 바인딩<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/property-binding#프로퍼티-바인딩-vs-문자열-바인딩\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nYou often have a choice between interpolation and property binding.\nThe following binding pairs do the same thing:\n\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"property-binding-interpolation\" header=\"src/app/app.component.html\">\n&lt;p&gt;&lt;img src=&quot;{{itemImageUrl}}&quot;&gt; is the &lt;i&gt;interpolated&lt;/i&gt; image.&lt;/p&gt;\n&lt;p&gt;&lt;img [src]=&quot;itemImageUrl&quot;&gt; is the &lt;i&gt;property bound&lt;/i&gt; image.&lt;/p&gt;\n\n&lt;p&gt;&lt;span&gt;&quot;{{interpolationTitle}}&quot; is the &lt;i&gt;interpolated&lt;/i&gt; title.&lt;/span&gt;&lt;/p&gt;\n&lt;p&gt;&quot;&lt;span [innerHTML]=&quot;propertyTitle&quot;&gt;&lt;/span&gt;&quot; is the &lt;i&gt;property bound&lt;/i&gt; title.&lt;/p&gt;\n\n</code-example>\n\nInterpolation is a convenient alternative to property binding in\nmany cases. When rendering data values as strings, there is no\ntechnical reason to prefer one form to the other, though readability\ntends to favor interpolation. However, *when setting an element\nproperty to a non-string data value, you must use property binding*.\n-->\n<p>개발을 하다보면 문자열 바인딩(interpolation)과 프로퍼티 바인딩 중에 어떤 것을 사용할지 결정해야 하는 경우가 있습니다.\n이런 경우가 그렇습니다:</p>\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"property-binding-interpolation\" header=\"src/app/app.component.html\">\n&#x3C;p>&#x3C;img src=\"{{itemImageUrl}}\"> is the &#x3C;i>interpolated&#x3C;/i> image.&#x3C;/p>\n&#x3C;p>&#x3C;img [src]=\"itemImageUrl\"> is the &#x3C;i>property bound&#x3C;/i> image.&#x3C;/p>\n\n&#x3C;p>&#x3C;span>\"{{interpolationTitle}}\" is the &#x3C;i>interpolated&#x3C;/i> title.&#x3C;/span>&#x3C;/p>\n&#x3C;p>\"&#x3C;span [innerHTML]=\"propertyTitle\">&#x3C;/span>\" is the &#x3C;i>property bound&#x3C;/i> title.&#x3C;/p>\n\n</code-example>\n<p>대부분의 경우에 프로퍼티 바인딩보다 문자열 바인딩을 사용할 때 더 간단하게 해결됩니다.\n데이터가 문자열 타입인 경우에 특히 그런 편이며, 문법 말고는 두 방식의 차이도 거의 없기 때문에 가독성이 좋은 방식을 선택하면 됩니다.\n하지만 데이터가 문자열 타입이 아니라면 반드시 프로퍼티 바인딩을 사용해야 합니다.</p>\n<!--\n## Content security\n-->\n<h2 id=\"보안\">보안<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/property-binding#보안\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nImagine the following malicious content.\n\n<code-example path=\"property-binding/src/app/app.component.ts\" region=\"malicious-content\" header=\"src/app/app.component.ts\">\nevilTitle = &#39;Template &lt;script&gt;alert(&quot;evil never sleeps&quot;)&lt;/script&gt; Syntax&#39;;\n\n</code-example>\n\nIn the component template, the content might be used with interpolation:\n\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"malicious-interpolated\" header=\"src/app/app.component.html\">\n&lt;p&gt;&lt;span&gt;&quot;{{evilTitle}}&quot; is the &lt;i&gt;interpolated&lt;/i&gt; evil title.&lt;/span&gt;&lt;/p&gt;\n\n</code-example>\n\nFortunately, Angular data binding is on alert for dangerous HTML. In the above case,\nthe HTML displays as is, and the Javascript does not execute. Angular **does not**\nallow HTML with script tags to leak into the browser, neither with interpolation\nnor property binding.\n\nIn the following example, however, Angular [sanitizes](guide/security#sanitization-and-security-contexts)\nthe values before displaying them.\n\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"malicious-content\" header=\"src/app/app.component.html\">\n &lt;!--\n Angular가 아래와 같이 위험한 코드를 발견하면 경고를 표시합니다.\n WARNING: 안전성 검사를 우회하는 방법은 http://g.co/ng/security#xss 를 참고하세요.\n--&gt;\n &lt;p&gt;&quot;&lt;span [innerHTML]=&quot;evilTitle&quot;&gt;&lt;/span&gt;&quot; is the &lt;i&gt;property bound&lt;/i&gt; evil title.&lt;/p&gt;\n\n</code-example>\n\nInterpolation handles the `<script>` tags differently than\nproperty binding but both approaches render the\ncontent harmlessly. The following is the browser output\nof the `evilTitle` examples.\n\n<code-example language=\"bash\">\n\"Template <script>alert(\"evil never sleeps\")</script> Syntax\" is the interpolated evil title.\n\"Template alert(\"evil never sleeps\")Syntax\" is the property bound evil title.\n</code-example>\n-->\n<p>다음과 같은 악성 코드가 있다고 합시다.</p>\n<code-example path=\"property-binding/src/app/app.component.ts\" region=\"malicious-content\" header=\"src/app/app.component.ts\">\nevilTitle = 'Template &#x3C;script>alert(\"evil never sleeps\")&#x3C;/script> Syntax';\n\n</code-example>\n<p>그리고 이 코드는 컴포넌트 템플릿에 문자열 바인딩 되어 사용됩니다:</p>\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"malicious-interpolated\" header=\"src/app/app.component.html\">\n&#x3C;p>&#x3C;span>\"{{evilTitle}}\" is the &#x3C;i>interpolated&#x3C;/i> evil title.&#x3C;/span>&#x3C;/p>\n\n</code-example>\n<p>하지만 다행히도 Angular는 위험한 HTML을 발견하면 경고 메시지를 표시합니다.\n위 예제에서 HTML 구문은 문자열 그대로 표시되며 JavaScript 코드도 실행되지 않습니다.\nAngular는 브라우저의 취약점을 공격할 수 있는 스크립트 태그를 허용하지 않으며, 이 정책은 문자열 바인딩과 프로퍼티 바인딩 모두 해당됩니다.</p>\n<p>하지만 <a href=\"guide/security#sanitization-and-security-contexts\">안전성 검사</a>를 거친 후라면 이 데이터를 템플릿에 활용할 수도 있습니다.</p>\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"malicious-content\" header=\"src/app/app.component.html\">\n &#x3C;!--\n Angular가 아래와 같이 위험한 코드를 발견하면 경고를 표시합니다.\n WARNING: 안전성 검사를 우회하는 방법은 http://g.co/ng/security#xss 를 참고하세요.\n-->\n &#x3C;p>\"&#x3C;span [innerHTML]=\"evilTitle\">&#x3C;/span>\" is the &#x3C;i>property bound&#x3C;/i> evil title.&#x3C;/p>\n\n</code-example>\n<p>문자열 바인딩과 프로퍼티 바인딩은 <code>&#x3C;script></code> 태그를 처리하는 방식이 조금 다르지만, 위험한 코드를 처리하는 방식은 비슷합니다.\n위 예제 코드는 브라우저에 다음과 같이 일반 문자열로 표시됩니다.</p>\n<code-example language=\"bash\">\n\"Template <script>alert(\"evil never sleeps\")</script> Syntax\" is the interpolated evil title.\n\"Template alert(\"evil never sleeps\")Syntax\" is the property bound evil title.\n</code-example>\n\n</div>\n\n<!-- links to this doc:\n - guide/ajs-quick-reference\n - guide/architecture-components\n - guide/attribute-binding\n - guide/event-binding\n - guide/glossary\n - guide/inputs-outputs\n - guide/router\n - guide/template-syntax\n - tutorial/toh-pt3\n-->\n<!-- links from this doc:\n - api/common/NgClass\n - api/core/ContentChild\n - api/core/Input\n - api/core/ViewChild\n - guide/attribute-binding#colspan\n - guide/event-binding\n - guide/property-binding#객체-전달하기\n - guide/property-binding#단방향-연결\n - guide/property-binding#대괄호를-빼먹지-마세요\n - guide/property-binding#문자열로-한-번만-초기화-할-때\n - guide/property-binding#바인딩-대상\n - guide/property-binding#보안\n - guide/property-binding#부수효과-최소화\n - guide/property-binding#예제\n - guide/property-binding#적절한-타입-반환하기\n - guide/property-binding#프로퍼티-바인딩-vs-문자열-바인딩\n - guide/property-binding#프로퍼티-바인딩-프로퍼티\n - guide/security#sanitization-and-security-contexts\n - https://developer.mozilla.org/en-US/docs/Web/API/HTMLTableCellElement\n - https://github.com/angular/angular/edit/master/aio/content/guide/property-binding.md?message=docs%3A%20describe%20your%20change...\n-->"
}