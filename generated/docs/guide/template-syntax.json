{
  "id": "guide/template-syntax",
  "title": "템플릿 문법",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/template-syntax.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Template syntax\n-->\n<h1 id=\"템플릿-문법\">템플릿 문법<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#템플릿-문법\"><i class=\"material-icons\">link</i></a></h1>\n<style>\n  h4 {font-size: 17px !important; text-transform: none !important;}\n  .syntax { font-family: Consolas, 'Lucida Sans', Courier, sans-serif; color: black; font-size: 85%; }\n  h4 .syntax { font-size: 100%; }\n</style>\n<!--\nThe Angular application manages what the user sees and can do, achieving this through the interaction of a component class instance (the *component*) and its user-facing template.\n\nYou may be familiar with the component/template duality from your experience with model-view-controller (MVC) or model-view-viewmodel (MVVM).\nIn Angular, the component plays the part of the controller/viewmodel, and the template represents the view.\n\nThis page is a comprehensive technical reference to the Angular template language.\nIt explains basic principles of the template language and describes most of the syntax that you'll encounter elsewhere in the documentation.\n\nMany code snippets illustrate the points and concepts, all of them available\nin the <live-example title=\"Template Syntax Live Code\"></live-example>.\n-->\n<p>Angular 애플리케이션은 사용자의 행동에 반응하면서 화면에 데이터를 표시하는데, 이 과정은 컴포넌트 클래스와 템플릿이 상호작용하면서 이루어집니다.</p>\n<p>MVC(모델-뷰-컨트롤러)나 MVVM(모델-뷰-뷰모델) 구조를 다뤄봤다면 컴포넌트와 템플릿의 관계가 좀 더 익숙할 수 있습니다.\nAngular에서는 컴포넌트가 컨트롤러나 뷰모델 역할을 하고, 템플릿이 뷰 역할을 합니다.</p>\n<p>이 문서에서는 Angular 템플릿 문법의 기술적인 부분을 종합적으로 다룹니다.\n템플릿 문법의 기초부터 시작해서 다른 가이드 페이지에서도 등장하는 템플릿 문법 대부분을 이 문서에서 다룹니다.</p>\n<p>템플릿 문법의 개념을 확실하게 이해하기 위해 많은 코드를 살펴볼 것이며,\n이 문서에서 설명하는 코드는 <live-example title=\"템플릿 문법 라이브 코딩\"></live-example> 에서 확인하거나 다운받을 수 있습니다.</p>\n<a id=\"html\"></a>\n<!--\n## HTML in templates\n-->\n<h2 id=\"템플릿과-html\">템플릿과 HTML<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#템플릿과-html\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nHTML is the language of the Angular template.\nAlmost all HTML syntax is valid template syntax.\nThe `<script>` element is a notable exception;\nit is forbidden, eliminating the risk of script injection attacks.\nIn practice, `<script>` is ignored and a warning appears in the browser console.\nSee the [Security](guide/security) page for details.\n-->\n<p>Angular 템플릿에는 HTML을 사용하며 거의 모든 HTML 문법은 템플릿 문법에서도 유효합니다.\n하지만 <code>&#x3C;script></code> 엘리먼트는 예외입니다. 이 엘리먼트는 스크립트 인젝션 공격에 노출될 수 있기 때문에 Angular 템플릿에 있더라도 처리되지 않고 브라우저 콘솔에 경고 메시지를 출력합니다.\n더 자세한 내용은 <a href=\"guide/security\">보안</a> 문서를 확인하세요.</p>\n<!--\nSome legal HTML doesn't make much sense in a template.\nThe `<html>`, `<body>`, and `<base>` elements have no useful role.\nPretty much everything else is fair game.\n-->\n<p>Angular 템플릿에 유효하지 않은 HTML 엘리먼트가 몇가지 더 있습니다.\n<code>&#x3C;html></code> 이나 <code>&#x3C;body></code>, <code>&#x3C;base></code> 엘리먼트는 Angular 템플릿에 사용해도 에러나 경고가 표시되지 않지만, 별다른 역할을 하지는 않습니다.\n언급하지 않은 엘리먼트는 사용해도 됩니다.</p>\n<!--\nYou can extend the HTML vocabulary of your templates with components and directives that appear as new elements and attributes.\nIn the following sections, you'll learn how to get and set DOM (Document Object Model) values dynamically through data binding.\n-->\n<p>컴포넌트나 디렉티브를 정의하면 템플릿에 사용할 수 있는 HTML 엘리먼트를 새롭게 정의하거나 표준 HTML 엘리먼트에는 없던 속성을 추가할 수 있습니다.\n이 문서에서는 템플릿 문법을 하나씩 살펴보면서 DOM(Document Object Model) 값을 어떻게 참조하고 어떻게 원하는 값으로 변경하는지 알아볼 것입니다.</p>\n<!--\nBegin with the first form of data binding&mdash;interpolation&mdash;to see how much richer template HTML can be.\n-->\n<p>가장 간단한 데이터 바인딩인 문자열 바인딩(interpolation)부터 살펴보면서 템플릿 HTML이 어떻게 확장되는지 알아봅시다.</p>\n<hr>\n<a id=\"interpolation\"></a>\n<!--\n## Interpolation and Template Expressions\n-->\n<h2 id=\"문자열-바인딩과-템플릿-표현식\">문자열 바인딩과 템플릿 표현식<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#문자열-바인딩과-템플릿-표현식\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nInterpolation allows you to incorporate calculated strings into the text\nbetween HTML element tags and within attribute assignments. Template\nexpressions are what you use to calculate those strings.\n\nThe interpolation <live-example></live-example> demonstrates all of\nthe syntax and code snippets described in this section.\n-->\n<p>문자열 바인딩(Interpolation)을 사용하면 HTML 엘리먼트 태그나 어트리뷰트에 지정하는 문자열을 조합할 수 있습니다.\n그리고 이 문자열은 템플릿 표현식(template expressions)으로도 조합할 수 있습니다.</p>\n<p>이 섹션에서 다루는 예제는 <live-example></live-example>에서 직접 확인하거나 다운받아 확인할 수 있습니다.</p>\n<!--\n### Interpolation `{{...}}`\n-->\n<h3 id=\"문자열-바인딩-\">문자열 바인딩 <code>{{...}}</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#문자열-바인딩-\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nInterpolation refers to embedding expressions into marked up text.\nBy default, interpolation uses as its delimiter the double curly braces, `{{` and `}}`.\n\nIn the following snippet, `{{ currentCustomer }}` is an example of interpolation.\n-->\n<p>문자열 바인딩은 문자열 안에 포함된 표현식을 의미합니다.\n기본적으로 문자열 바인딩 문법은 이중 중괄호 <code>{{</code>와 <code>}}</code>를 사용합니다.</p>\n<p>그래서 아래 코드에서 <code>{{ currentCustomer }}</code> 부분이 문자열 바인딩이 사용된 코드입니다.</p>\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"interpolation-example1\" header=\"src/app/app.component.html\">\n&#x3C;h3>Current customer: {{ currentCustomer }}&#x3C;/h3>\n\n</code-example>\n<!--\nThe text between the braces is often the name of a component\nproperty. Angular replaces that name with the\nstring value of the corresponding component property.\n-->\n<p>이중 중괄호 안에는 보통 컴포넌트 프로퍼티 이름을 사용합니다.\n그러면 Angular가 템플릿을 파싱하면서 이 프로퍼티 이름을 해당 프로퍼티에 할당된 문자열 값으로 치환합니다.</p>\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"component-property\" header=\"src/app/app.component.html\">\n&#x3C;p>{{title}}&#x3C;/p>\n&#x3C;div>&#x3C;img src=\"{{itemImageUrl}}\">&#x3C;/div>\n\n</code-example>\n<!--\nIn the example above, Angular evaluates the `title` and `itemImageUrl` properties\nand fills in the blanks, first displaying some title text and then an image.\n\nMore generally, the text between the braces is a **template expression**\nthat Angular first **evaluates** and then **converts to a string**.\nThe following interpolation illustrates the point by adding two numbers:\n-->\n<p>위 예제에서 Angular는 <code>title</code>과 <code>itemImageUrl</code> 프로퍼티의 값으로 템플릿의 내용을 치환하기 때문에 화면에는 애플리케이션의 이름과 이미지가 표시됩니다.</p>\n<p>좀 더 일반적으로 이야기하면, 이중 중괄호 안에 있는 텍스트는 <strong>템플릿 표현식(template expression)</strong>인데, 이 표현식은 Angular가 가장 먼저 <strong>평가(evaluate)</strong>해서 <strong>문자열로 변환합니다</strong>.\n그래서 다음과 같이 숫자 2개를 더하는 연산도 처리할 수 있습니다:</p>\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"convert-string\" header=\"src/app/app.component.html\">\n&#x3C;!-- \"The sum of 1 + 1 is 2\" -->\n&#x3C;p>The sum of 1 + 1 is {{1 + 1}}.&#x3C;/p>\n\n</code-example>\n<!--\nThe expression can invoke methods of the host component such as `getVal()` in\nthe following example:\n-->\n<p>템플릿 표현식에서는 메소드를 실행할 수도 있습니다. 아래 예제에 사용된 <code>getVal()</code>은 호스트 컴포넌트에 선언된 메소드입니다:</p>\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"invoke-method\" header=\"src/app/app.component.html\">\n&#x3C;!-- \"The sum of 1 + 1 is not 4\" -->\n&#x3C;p>The sum of 1 + 1 is not {{1 + 1 + getVal()}}.&#x3C;/p>\n\n</code-example>\n<!--\nAngular evaluates all expressions in double curly braces,\nconverts the expression results to strings, and links them with neighboring literal strings. Finally,\nit assigns this composite interpolated result to an **element or directive property**.\n\nYou appear to be inserting the result between element tags and assigning it to attributes.\nHowever, interpolation is a special syntax that Angular converts into a *property binding*.\n-->\n<p>이중 중괄호 안에 있는 템플릿 표현식은 Angular 프레임워크가 평가하고 문자열로 변환해서 같은 엘리먼트에 있는 문자열과 연결합니다. 이렇게 템플릿에 삽입된 문자열은 <strong>엘리먼트나 디렉티브의 프로퍼티</strong>로 사용됩니다.\n사실 문자열 바인딩은 프로퍼티 바인딩을 사용하는 문법 중 하나입니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nIf you'd like to use something other than `{{` and `}}`, you can\nconfigure the interpolation delimiter via the\n[interpolation](api/core/Component#interpolation)\noption in the `Component` metadata.\n-->\n<p><code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 메타데이터에 <a href=\"api/core/Component#interpolation\">interpolation</a> 옵션을 지정하면 <code>{{</code>와 <code>}}</code> 대신 다른 표기법을 사용할 수 있습니다.</p>\n</div>\n<a id=\"template-expressions\"></a>\n<!--\n### Template expressions\n-->\n<h3 id=\"템플릿-표현식-template-expressions\">템플릿 표현식 (Template expressions)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#템플릿-표현식-template-expressions\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nA template **expression** produces a value and appears within the double\ncurly braces, `{{ }}`.\nAngular executes the expression and assigns it to a property of a binding target;\nthe target could be an HTML element, a component, or a directive.\n\nThe interpolation braces in `{{1 + 1}}` surround the template expression `1 + 1`.\nIn the property binding,\na template expression appears in quotes to the right of the&nbsp;`=` symbol as in `[property]=\"expression\"`.\n-->\n<p>템플릿 <strong>표현식</strong>은 이중 중괄호를 사용해서 <code>{{ }}</code>와 같이 사용하며, 표현식이 실행된 결과를 반환합니다.\nAngular는 이 표현식을 실행하고 HTML 엘리먼트나 컴포넌트, 디렉티브 등 바인딩 대상이 되는 프로퍼티에 연결합니다.</p>\n<p>그리고 문자열 바인딩은 템플릿 표현식을 감싼 형태입니다. 그래서 <code>1 + 1</code> 이라는 템플릿 표현식을 문자열 바인딩하면 <code>{{1 + 1}}</code>과 같은 형태가 됩니다.\n프로퍼티 바인딩과 함께 사용한다면 큰따옴표(<code>\"</code>)와 등호(<code>=</code>)를 사용해서 <code>[프로퍼티]=\"표현식\"</code>과 같이 사용합니다.</p>\n<!--\nIn terms of syntax, template expressions are similar to JavaScript.\nMany JavaScript expressions are legal template expressions, with a few exceptions.\n\nYou can't use JavaScript expressions that have or promote side effects,\nincluding:\n\n* Assignments (`=`, `+=`, `-=`, `...`)\n* Operators such as `new`, `typeof`, `instanceof`, etc.\n* Chaining expressions with <code>;</code> or <code>,</code>\n* The increment and decrement operators `++` and `--`\n* Some of the ES2015+ operators\n-->\n<p>문법으로만 보면 템플릿 표현식은 JavaScript 문법과 비슷합니다.\n그래서 JavaScript 문법 대부분은 템플릿 표현식에도 사용할 수 있지만 예외가 몇가지 있습니다.</p>\n<p>다음 JavaScript 표현식은 템플릿 표현식에 사용할 수 없습니다:</p>\n<ul>\n<li>값을 할당하는 표현 (<code>=</code>, <code>+=</code>, <code>-=</code>, <code>...</code>)</li>\n<li><code>new</code>, <code>typeof</code>, <code>instanceof</code> 연산자</li>\n<li><code>;</code>나 <code>,</code>로 체이닝하는 표현식</li>\n<li>증감연산자 <code>++</code>, <code>--</code></li>\n<li>ES2015 이후에 도입된 연산자 중 일부</li>\n</ul>\n<!--\nOther notable differences from JavaScript syntax include:\n\n* No support for the bitwise operators such as `|` and `&`\n* New [template expression operators](guide/template-syntax#expression-operators), such as `|`, `?.` and `!`\n-->\n<p>그리고 이런 점도 JavaScript 문법과 다릅니다:</p>\n<ul>\n<li>비트 연산자 <code>|</code>와 <code>&#x26;</code>는 사용할 수 없습니다.</li>\n<li><a href=\"guide/template-syntax#expression-operators\">템플릿 표현식</a>에서만 사용하는 연산자도 존재합니다: <code>|</code>, <code>?.</code>, <code>!</code></li>\n</ul>\n<!--\n### Expression context\n-->\n<h3 id=\"표현식의-컨텍스트\">표현식의 컨텍스트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#표현식의-컨텍스트\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe *expression context* is typically the _component_ instance.\nIn the following snippets, the `recommended` within double curly braces and the\n`itemImageUrl2` in quotes refer to properties of the `AppComponent`.\n-->\n<p><em>템플릿 표현식의 컨텍스트</em>는 일반적으로 <em>컴포넌트</em> 인스턴스의 범위와 같습니다.\n그래서 아래 예제에서 이중 중괄호 안에 사용된 <code>recommended</code>와 <code>itemImageUrl2</code>는 모두 <code>AppComponent</code>에 선언된 프로퍼티를 가리킵니다.</p>\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"component-context\" header=\"src/app/app.component.html\">\n&#x3C;h4>{{recommended}}&#x3C;/h4>\n&#x3C;img [src]=\"itemImageUrl2\">\n\n</code-example>\n<!--\nAn expression may also refer to properties of the _template's_ context\nsuch as a template input variable,\n&lt;!-- link to built-in-directives#template-input-variables --&gt;\n`let customer`, or a template reference variable, `#customerInput`.\n&lt;!-- link to guide/template-ref-variables --&gt;\n-->\n<p>템플릿 표현식에서는 <em>템플릿 안에</em> 선언된 템플릿 입력 변수(template input variable)도 참조할 수 있습니다.\n그래서 아래 코드에 선언된 <code>let customer</code>나 <code>#customerInput</code>도 템플릿 표현식에 사용할 수 있습니다.</p>\n<!--\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"template-input-variable\" header=\"src/app/app.component.html (template input variable)\">\n&lt;ul&gt;\n  &lt;li *ngFor=&quot;let customer of customers&quot;&gt;{{customer.name}}&lt;/li&gt;\n&lt;/ul&gt;\n\n</code-example>\n\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"template-reference-variable\" header=\"src/app/app.component.html (template reference variable)\">\n&lt;label&gt;Type something:\n  &lt;input #customerInput&gt;{{customerInput.value}}\n&lt;/label&gt;\n\n</code-example>\n-->\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"template-input-variable\" header=\"src/app/app.component.html (템플릿 입력 변수)\">\n&#x3C;ul>\n  &#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let customer of customers\">{{customer.name}}&#x3C;/li>\n&#x3C;/ul>\n\n</code-example>\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"template-reference-variable\" header=\"src/app/app.component.html (템플릿 참조 변수)\">\n&#x3C;label><a href=\"api/core/Type\" class=\"code-anchor\">Type</a> something:\n  &#x3C;input #customerInput>{{customerInput.value}}\n&#x3C;/label>\n\n</code-example>\n<!--\nThe context for terms in an expression is a blend of the _template variables_,\nthe directive's _context_ object (if it has one), and the component's _members_.\nIf you reference a name that belongs to more than one of these namespaces,\nthe template variable name takes precedence, followed by a name in the directive's _context_,\nand, lastly, the component's member names.\n-->\n<p>Angular 템플릿의 컨텍스트는 <em>템플릿 변수</em>와 디렉티브의 <em>context</em> 객체, 컴포넌트의 <em>멤버</em> 가 조합된 범위입니다.\n이 중 참조하는 항목의 이름이 동시에 두 군데 존재하면 템플릿 변수의 우선순위가 가장 높습니다.\n그 다음 우선순위는 디렉티브의 <em>context</em> 객체이며, 컴포넌트 멤버의 우선순위가 가장 낮습니다.</p>\n<!--\nThe previous example presents such a name collision. The component has a `customer`\nproperty and the `*ngFor` defines a `customer` template variable.\n-->\n<p>위에서 살펴본 예제에도 이름이 겹치는 상황이 있습니다.\n템플릿에 사용된 변수 <code>customer</code>는 컴포넌트 프로퍼티로도 존재하고 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 안에도 존재합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nThe `customer` in `{{customer.name}}`\nrefers to the template input variable, not the component's property.\n\nTemplate expressions cannot refer to anything in\nthe global namespace, except `undefined`. They can't refer to\n`window` or `document`. Additionally, they\ncan't call `console.log()` or `Math.max()` and they are restricted to referencing\nmembers of the expression context.\n-->\n<p><code>{{customer.name}}</code>에 사용된 <code>customer</code>는 컴포넌트 프로퍼티가 아니라 템플릿 입력 변수를 가리킵니다.</p>\n<p>그리고 템플릿 표현식은 전역 범위에 있는 객체는 사용할 수 없으며 <code>undefined</code>만 허용됩니다.\n그래서 <code>window</code>나 <code><a href=\"api/platform-server/PlatformConfig#document\" class=\"code-anchor\">document</a></code>도 참조할 수 없습니다.\n마찬가지로, <code>console.log()</code>나 <code>Math.max()</code>와 같은 템플릿 표현식도 사용할 수 없습니다.</p>\n</div>\n<!--\n### Expression guidelines\n-->\n<h3 id=\"템플릿-표현식-가이드라인\">템플릿 표현식 가이드라인<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#템플릿-표현식-가이드라인\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nWhen using template expressions follow these guidelines:\n\n* [Simplicity](guide/template-syntax#simplicity)\n* [Quick execution](guide/template-syntax#quick-execution)\n* [No visible side effects](guide/template-syntax#no-visible-side-effects)\n-->\n<p>템플릿 표현식은 다음 가이드라인을 준수하며 사용하는 것을 권장합니다:</p>\n<ul>\n<li><a href=\"guide/template-syntax#simplicity\">간단하게</a></li>\n<li><a href=\"guide/template-syntax#quick-execution\">빠르게 실행되도록</a></li>\n<li><a href=\"guide/template-syntax#no-visible-side-effects\">외부 영향 최소화</a></li>\n</ul>\n<a id=\"simplicity\"></a>\n<!--\n#### Simplicity\n-->\n<h4 id=\"간단하게\">간단하게<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#간단하게\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nAlthough it's possible to write complex template expressions, it's a better\npractice to avoid them.\n\nA property name or method call should be the norm, but an occasional Boolean negation, `!`, is OK.\nOtherwise, confine application and business logic to the component,\nwhere it is easier to develop and test.\n-->\n<p>템플릿 표현식을 복잡하게 작성해도 동작은 하지만 이런 로직은 피하는 것이 좋습니다.</p>\n<p>프로퍼티 이름이나 메소드 실행을 간단하게 작성하는 것이 일반적이고 필요하면 <code>!</code>와 같은 불리언 값을 바꾸는 것도 좋습니다.\n하지만 애플리케이션이나 컴포넌트 로직의 일부를 템플릿 표현식에 작성하면 개발하기도 어렵고 테스트하기도 어렵습니다.</p>\n<a id=\"quick-execution\"></a>\n<!--\n#### Quick execution\n-->\n<h4 id=\"빠르게-실행되도록\">빠르게 실행되도록<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#빠르게-실행되도록\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nAngular executes template expressions after every change detection cycle.\nChange detection cycles are triggered by many asynchronous activities such as\npromise resolutions, HTTP results, timer events, key presses and mouse moves.\n\nExpressions should finish quickly or the user experience may drag, especially on slower devices.\nConsider caching values when their computation is expensive.\n-->\n<p>Angular는 변화감지 싸이클마다 템플릿 표현식을 실행합니다.\n그리고 변화감지 싸이클은 프로미스(promise)가 완료되거나 HTTP 응답이 왔을때, 타이머 이벤트나 키 이벤트, 마우스 이벤트가 있을 때도 실행됩니다.</p>\n<p>마우스 드래그를 활용하거나 디바이스의 사양이 낮을수록 템플릿 표현식은 빠르게 실행되어야 합니다.\n연산이 많이 필요하다면 캐싱을 활용하는 방법도 고려해 보세요.</p>\n<a id=\"no-visible-side-effects\"></a>\n<!--\n#### No visible side effects\n-->\n<h4 id=\"외부-영향-최소화\">외부 영향 최소화<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#외부-영향-최소화\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nA template expression should not change any application state other than the value of the\ntarget property.\n-->\n<p>템플릿 표현식은 대상 프로퍼티의 값만 변경하는 방식으로 작성하는 것이 좋습니다.\n여러 프로퍼티나 애플리케이션의 상태를 변경하는 로직은 작성하지 않는 것을 권장합니다.</p>\n<!--\nThis rule is essential to Angular's \"unidirectional data flow\" policy.\nYou should never worry that reading a component value might change some other displayed value.\nThe view should be stable throughout a single rendering pass.\n-->\n<p>이 규칙은 Angular가 권장하는 \"단방향 데이터 흐름\"의 관점에서도 아주 중요합니다.\n다른 프로퍼티의 영향을 최소화하면 컴포넌트 프로퍼티를 참조하는 동안 다른 프로퍼티의 영향을 걱정할 필요가 없으며, 화면은 렌더링 단계에서 한 번만 갱신됩니다.</p>\n<!--\nAn [idempotent](https://en.wikipedia.org/wiki/Idempotence) expression is ideal because\nit is free of side effects and improves Angular's change detection performance.\nIn Angular terms, an idempotent expression always returns\n*exactly the same thing* until one of its dependent values changes.\n-->\n<p>그래서 템플릿 표현식은 사이드 이펙트를 방지하고 Angular의 변화 감지 성능을 최대화하기 위해 <a href=\"https://en.wikipedia.org/wiki/Idempotence\">멱등적 (idempotent)</a>인 표현식으로 작성하는 것이 이상적입니다.</p>\n<p>Angular에서 이야기하는 멱등적인 표현식이란, 어떤 값을 기준으로 표현식을 실행했을 때 <em>항상 같은 값을</em> 반환하는 표현식을 의미합니다.</p>\n<!--\nDependent values should not change during a single turn of the event loop.\nIf an idempotent expression returns a string or a number, it returns the same string or number when called twice in a row. If the expression returns an object, including an `array`, it returns the same object *reference* when called twice in a row.\n-->\n<p>그리고 템플릿 표현식에 사용된 값은 이벤트 루프가 한 번 실행되는 동안 변경되면 안됩니다.\n템플릿 표현식이 어떤 문자열이나 숫자를 반환한다면, 이 템플릿 표현식은 여러번 실행되더라도 항상 같은 값을 반환해야 합니다.\n그리고 객체나 배열을 반환한다면, 이 템플릿 표현식은 여러번 실행되더라도 항상 같은 객체를 참조해야 합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nThere is one exception to this behavior that applies to `*ngFor`. `*ngFor` has `trackBy` functionality that can deal with referential inequality of objects when iterating over them. See [*ngFor with `trackBy`](guide/template-syntax#ngfor-with-trackby) for details.\n-->\n<p><code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>의 동작을 제어할 때는 이 규칙을 예외로 처리할 수 있습니다.\n<code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>를 사용하면서 <code>trackBy</code> 기능을 사용하면 이전과 다른 객체를 참조하더라도 같은 객체를 참조하는 것으로 간주할 수 있습니다.</p>\n<p>더 자세한 내용을 확인하려면 이 문서의 <a href=\"guide/template-syntax#trackBy\"><code>trackBy</code>와 함께 사용하기</a> 섹션을 참고하세요.</p>\n</div>\n<!-- end of Interpolation doc -->\n<hr>\n<a id=\"template-statements\"></a>\n<!--\n## Template statements\n-->\n<h2 id=\"템플릿-실행문-template-statements\">템플릿 실행문 (Template statements)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#템플릿-실행문-template-statements\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nA template **statement** responds to an **event** raised by a binding target\nsuch as an element, component, or directive.\nYou'll see template statements in the [event binding](guide/template-syntax#event-binding) section,\nappearing in quotes to the right of the `=`&nbsp;symbol as in `(event)=\"statement\"`.\n-->\n<p>템플릿 <strong>실행문</strong>은 엘리먼트나 컴포넌트, 디렉티브에서 발생하는 <strong>이벤트</strong>에 반응하기 위해 사용합니다.\n템플릿 실행문은 이 문서의 <a href=\"guide/template-syntax#event-binding\">이벤트 바인딩</a> 섹션에서도 확인할 수 있으며,\n<code>=</code> 기호를 사용해서 <code>(이벤트)=\"실행문\"</code>과 같이 작성합니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"context-component-statement\" header=\"src/app/app.component.html\">\n&#x3C;button (click)=\"deleteHero()\">Delete hero&#x3C;/button>\n\n</code-example>\n<!--\nA template statement *has a side effect*.\nThat's the whole point of an event.\nIt's how you update application state from user action.\n-->\n<p>템플릿 실행문은 <em>변화를 발생</em>시키며, 이벤트의 목적도 이것을 위한 것입니다.\n템플릿 실행문은 사용자의 행동에 따라 애플리케이션을 동작시키기 위해 사용합니다.</p>\n<!--\nResponding to events is the other side of Angular's \"unidirectional data flow\".\nYou're free to change anything, anywhere, during this turn of the event loop.\n-->\n<p>이벤트에 반응하는 것은 Angular가 권장하는 \"단방향 데이터 흐름\"의 또다른 한 방향입니다.\n이 방향은 컴포넌트 프로퍼티가 화면으로 반영되는 것의 반대 방향이며, 이벤트 루프에서는 어떠한 객체의 어떠한 값도 자유롭게 변경할 수 있습니다.</p>\n<!--\nLike template expressions, template *statements* use a language that looks like JavaScript.\nThe template statement parser differs from the template expression parser and\nspecifically supports both basic assignment (`=`) and chaining expressions with <code>;</code>.\n-->\n<p>템플릿 표현식과 비슷하게 템플릿 <em>실행문</em>도 JavaScript와 비슷한 문법을 사용합니다.\n하지만 템플릿 실행문을 파싱하는 파서는 템플릿 표현식을 파싱하는 파서와 다르며, 템플릿 표현식에서는 사용할 수 없는 문법도 몇 가지는 사용할 수 있습니다.\n템플릿 실행문에서는 값을 할당하는 표현이나(<code>=</code>) 여러 줄에 걸친 표현(<code>;</code>)도 사용할 수 있습니다.</p>\n<!--\nHowever, certain JavaScript and template expression syntax is not allowed:\n-->\n<p>하지만 다음과 같은 JavaScript 문법은 사용할 수 없습니다.</p>\n<!--\n* <code>new</code>\n* increment and decrement operators, `++` and `--`\n* operator assignment, such as `+=` and `-=`\n* the bitwise operators, such as `|` and `&`\n* the [pipe operator](guide/template-syntax#pipe)\n-->\n<ul>\n<li><code>new</code> 키워드</li>\n<li>연산 할당자: <code>+=</code>, <code>-=</code></li>\n<li>비트 연산자: <code>|</code>, <code>&#x26;</code></li>\n<li><a href=\"guide/template-syntax#pipe\">파이프 연산자</a></li>\n</ul>\n<!--\n### Statement context\n-->\n<h3 id=\"템플릿-실행문의-컨텍스트\">템플릿 실행문의 컨텍스트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#템플릿-실행문의-컨텍스트\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAs with expressions, statements can refer only to what's in the statement context\nsuch as an event handling method of the component instance.\n-->\n<p>템플릿 표현식과 비슷하게 템플릿 실행문도 컨텍스트가 제한되어 있으며, 컴포넌트 인스턴스에 있는 이벤트 핸들링 메소드를 주로 사용합니다.</p>\n<!--\nThe *statement context* is typically the component instance.\nThe *deleteHero* in `(click)=\"deleteHero()\"` is a method of the data-bound component.\n-->\n<p><em>템플릿 실행문의 컨텍스트</em>는 컴포넌트 인스턴스의 범위와 같습니다.\n예를 들어 아래 코드에서 <code>(click)=\"deleteHero()\"</code>에 사용된 <code>deleteHero</code>는 컴포넌트에서 데이터를 처리하는 메소드입니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"context-component-statement\" header=\"src/app/app.component.html\">\n&#x3C;button (click)=\"deleteHero()\">Delete hero&#x3C;/button>\n\n</code-example>\n<!--\nThe statement context may also refer to properties of the template's own context.\nIn the following examples, the template `$event` object,\na [template input variable](guide/template-syntax#template-input-variable) (`let hero`),\nand a [template reference variable](guide/template-syntax#ref-vars) (`#heroForm`)\nare passed to an event handling method of the component.\n-->\n<p>템플릿 실행문의 컨텍스트에서는 템플릿 컨텍스트 안에 있는 프로퍼티에 접근할 수도 있습니다.\n아래 예제에서 <code>$event</code> 객체는 템플릿 변수이며, <code>let hero</code>는 <a href=\"guide/template-syntax#template-input-variable\">템플릿 입력 변수</a>이고,\n<code>#heroForm</code>은 <a href=\"guide/template-syntax#template-reference-variable\">템플릿 참조 변수</a>입니다.\n각각의 변수는 컴포넌트의 이벤트 핸들링 메소드로 전달됩니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"context-var-statement\" header=\"src/app/app.component.html\">\n&#x3C;button (click)=\"onSave($event)\">Save&#x3C;/button>\n&#x3C;button *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\" (click)=\"deleteHero(hero)\">{{hero.name}}&#x3C;/button>\n&#x3C;form #heroForm (ngSubmit)=\"onSubmit(heroForm)\"> ... &#x3C;/form>\n\n</code-example>\n<!--\nTemplate context names take precedence over component context names.\nIn `deleteHero(hero)` above, the `hero` is the template input variable,\nnot the component's `hero` property.\n-->\n<p>템플릿 컨텍스트의 항목 이름과 컴포넌트의 프로퍼티 이름이 중복되면 템플릿 컨텍스트의 우선순위가 높습니다.\n위 코드를 예로 들면, <code>deleteHero(hero)</code>에 사용된 <code>hero</code>는 템플릿 입력 변수이며, 컴포넌트에 있는 <code>hero</code> 프로퍼티는 템플릿 변수에 의해 가려졌습니다.</p>\n<!--\n### Statement guidelines\n-->\n<h3 id=\"템플릿-실행문-가이드라인\">템플릿 실행문 가이드라인<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#템플릿-실행문-가이드라인\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nTemplate statements cannot refer to anything in the global namespace. They\ncan't refer to `window` or `document`.\nThey can't call `console.log` or `Math.max`.\n-->\n<p>템플릿 실행문에서는 템플릿 표현식과 마찬가지로 전역 공간에 접근할 수 없습니다.\n<code>window</code>나 <code><a href=\"api/platform-server/PlatformConfig#document\" class=\"code-anchor\">document</a></code>에도 접근할 수 없고, <code>console.log</code>나 <code>Math.max</code>와 같은 함수도 실행할 수 없습니다.</p>\n<!--\nAs with expressions, avoid writing complex template statements.\nA method call or simple property assignment should be the norm.\n-->\n<p>템플릿 표현식과 마찬가지로 템플릿 실행문에도 복잡한 로직을 작성하지 않는 것이 좋습니다.\n간단하게 프로퍼티를 참조하거나 함수를 실행하는 것이 가장 좋은 방법입니다.</p>\n<hr>\n<a id=\"binding-syntax\"></a>\n<!--\n## Binding syntax: an overview\n-->\n<h2 id=\"바인딩-문법--개요\">바인딩 문법 : 개요<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#바인딩-문법--개요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nData-binding is a mechanism for coordinating what users see, specifically\nwith application data values.\nWhile you could push values to and pull values from HTML,\nthe application is easier to write, read, and maintain if you turn these tasks over to a binding framework.\nYou simply declare bindings between binding sources, target HTML elements, and let the framework do the rest.\n\nFor a demonstration of the syntax and code snippets in this section, see the <live-example name=\"binding-syntax\">binding syntax example</live-example>.\n\nAngular provides many kinds of data-binding. Binding types can be grouped into three categories distinguished by the direction of data flow:\n\n* From the _source-to-view_\n* From _view-to-source_\n* Two-way sequence: _view-to-source-to-view_\n-->\n<p>사용자가 보는 화면과 애플리케이션 데이터의 값은 데이터 바인딩을 통해 자동으로 동기화됩니다.\n데이터 바인딩을 지원하는 프레임워크에서는 HTML에 값을 반영하거나 HTML에서 값을 가져오는 과정이 훨씬 간단하기 때문에,\n애플리케이션 로직을 쉽게, 빠르게, 간결하게 작성할 수 있습니다.\n바인딩할 객체와 HTML을 단순하게 연결하기만 하면 그 이후는 프레임워크가 알아서 필요한 작업을 수행합니다.</p>\n<p>이 섹션에서 다루는 문법이 실행되는 것을 직접 확인하려면 <live-example name=\"binding-syntax\">바인딩 문법 예제</live-example>를 참소하세요.</p>\n<p>Angular는 데이터 바인딩을 여러가지 방식으로 제공합니다.\n이 문서에서는 Angular가 제공하는 데이터 바인딩을 기본부터 차근차근 알아봅시다.</p>\n<ul>\n<li>소스에서 화면으로</li>\n<li>화면에서 소스로</li>\n<li>양방향으로: 화면에서 소스로, 소스에서 화면으로</li>\n</ul>\n<style>\n  td, th {vertical-align: top}\n</style>\n<table width=\"100%\">\n  <colgroup><col width=\"30%\">\n  \n  <col width=\"50%\">\n  \n  <col width=\"20%\">\n  \n  </colgroup><tbody><tr>\n    <th>\n      <!--\n      Type\n      -->\n      종류\n    </th>\n    <th>\n      <!--\n      Syntax\n      -->\n      문법\n    </th>\n    <th>\n      Category\n    </th>\n  </tr>\n  <tr>\n     <td>\n      <!--\n      Interpolation<br>\n      Property<br>\n      Attribute<br>\n      Class<br>\n      Style\n      -->\n      문자열(Interpolation)<br>\n      프로퍼티(property)<br>\n      어트리뷰트(attribute)<br>\n      클래스(class)<br>\n      스타일(style)\n    </td>\n    <td>\n      <!--\n      <code-example>\n        {{expression}}\n        [target]=\"expression\"\n        bind-target=\"expression\"\n      </code-example>\n      -->\n      <code-example>\n        {{표현식}}\n        [대상]=\"표현식\"\n        bind-대상=\"표현식\"\n      </code-example>\n    </td>\n    <td>\n      <!--\n      One-way<br>from data source<br>to view target\n      -->\n      원천 소스에서<br>화면으로<br>단방향\n    </td>\n    </tr><tr>\n      <td>\n        <!--\n        Event\n        -->\n        이벤트\n      </td>\n      <td>\n        <!--\n        <code-example>\n          (target)=\"statement\"\n          on-target=\"statement\"\n        </code-example>\n      -->\n        <code-example>\n          (대상)=\"실행문\"\n          on-대상=\"실행문\"\n        </code-example>\n      </td>\n      <td>\n        <!--\n        One-way<br>from view target<br>to data source\n        -->\n        대상에서<br>데이터 소스로<br>단방향\n      </td>\n    </tr>\n    <tr>\n      <td>\n        <!--\n        Two-way\n        -->\n        양방향\n      </td>\n      <td>\n        <!--\n        <code-example>\n          [(target)]=\"expression\"\n          bindon-target=\"expression\"\n        </code-example>\n        -->\n        <code-example>\n          [(대상)]=\"표현식\"\n          bindon-대상=\"표현식\"\n        </code-example>\n      </td>\n      <td>\n        <!--\n        Two-way\n        -->\n        양방향\n      </td>\n    </tr>\n  \n</tbody></table>\n<!--\nBinding types other than interpolation have a **target name** to the left of the equal sign, either surrounded by punctuation, `[]` or `()`,\nor preceded by a prefix: `bind-`, `on-`, `bindon-`.\n\nThe *target* of a binding is the property or event inside the binding punctuation: `[]`, `()` or `[()]`.\n\nEvery public member of a **source** directive is automatically available for binding.\nYou don't have to do anything special to access a directive member in a template expression or statement.\n-->\n<p>문자열 바인딩을 제외하면 모든 바인딩 방식에는 등호 왼쪽에 <strong>바인딩할 대상의 이름</strong>이 있고, <code>[]</code>나 <code>()</code>로 둘러싸여 있거나 <code>bind-</code>, <code>on-</code>, <code>bindon-</code> 접두사가 붙습니다.</p>\n<p>바인딩 <em>대상</em>은 <code>[]</code>나 <code>()</code>, <code>[()]</code> 안에 들어가는 프로퍼티나 이벤트입니다.</p>\n<p>디렉티브의 멤버 중 <code>public</code>으로 지정된 멤버는 모두 바인딩할 수 있습니다.\n디렉티브의 템플릿 표현식이나 실행문에 사용하기 위해 특별히 뭔가 더 해야 하는 것은 없습니다.</p>\n<!--\n### Data-binding and HTML\n-->\n<h3 id=\"데이터-바인딩과-html\">데이터 바인딩과 HTML<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#데이터-바인딩과-html\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn the normal course of HTML development, you create a visual structure with HTML elements, and\nyou modify those elements by setting element attributes with string constants.\n-->\n<p>일반적으로 HTML 문서를 작성할 때는 화면에 표시하는 모양에 맞게 HTML 엘리먼트 구조를 잡고 각 엘리먼트의 어트리뷰트를 문자열로 직접 지정했습니다.</p>\n<code-example language=\"html\">\n&#x3C;div class=\"special\">Plain old <a href=\"api/core/SecurityContext#HTML\" class=\"code-anchor\">HTML</a>&#x3C;/div>\n&#x3C;img src=\"images/item.png\">\n&#x3C;button disabled>Save&#x3C;/button>\n</code-example>\n<!--\nWith data-binding, you can control things like the state of a button:\n-->\n<p>데이터 바인딩을 활용하면 다음과 같이 버튼의 상태를 제어할 수 있습니다:</p>\n<code-example path=\"binding-syntax/src/app/app.component.html\" region=\"disabled-button\" header=\"src/app/app.component.html\">\n&#x3C;!-- 버튼의 활성화 여부를 `isUnchanged` 프로퍼티와 바인딩합니다. -->\n&#x3C;button [disabled]=\"isUnchanged\">Save&#x3C;/button>\n\n</code-example>\n<!--\nNotice that the binding is to the `disabled` property of the button's DOM element,\n**not** the attribute. This applies to data-binding in general. Data-binding works with *properties* of DOM elements, components, and directives, not HTML *attributes*.\n-->\n<p>위 예제 코드에서 버튼의 DOM 엘리먼트에 바인딩된 <code>disabled</code>는 프로퍼티이며 어트리뷰트가 <strong>아닙니다.</strong>\n데이터 바인딩은 이런 방식이 일반적입니다.\n데이터 바인딩은 DOM 엘리먼트나 컴포넌트, 이렉티브의 <em>프로퍼티</em>와 바인딩합니다. <em>어트리뷰트</em>가 아닙니다.</p>\n<!--\n### HTML attribute vs. DOM property\n-->\n<h3 id=\"html-어트리뷰트-vs-dom-프로퍼티\">HTML 어트리뷰트 vs. DOM 프로퍼티<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#html-어트리뷰트-vs-dom-프로퍼티\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe distinction between an HTML attribute and a DOM property is key to understanding\nhow Angular binding works. **Attributes are defined by HTML. Properties are accessed from DOM (Document Object Model) nodes.**\n\n* A few HTML attributes have 1:1 mapping to properties; for example, `id`.\n\n* Some HTML attributes don't have corresponding properties; for example, `aria-*`.\n\n* Some DOM properties don't have corresponding attributes; for example, `textContent`.\n\nIt is important to remember that *HTML attribute* and the *DOM property* are different things, even when they have the same name.\nIn Angular, the only role of HTML attributes is to initialize element and directive state.\n\n**Template binding works with *properties* and *events*, not *attributes*.**\n\nWhen you write a data-binding, you're dealing exclusively with the *DOM properties* and *events* of the target object.\n-->\n<p>Angular에서 바인딩이 어떻게 동작하는지 이해하려면, HTML 어트리뷰트와 DOM 프로퍼티를 확실하게 구분해야 합니다.\n<strong>어트리뷰트는 HTML에 지정합니다. 그리고 프로퍼티는 DOM(Document Object Model)에 지정합니다.</strong></p>\n<ul>\n<li>\n<p>일부 HTML 어트리뷰트는 프로퍼티와 1:1 매칭됩니다. <code>id</code>가 그렇습니다.</p>\n</li>\n<li>\n<p>일부 HTML 어트리뷰트는 프로퍼티와 매칭되지 않는 어트리뷰트도 있습니다. <code>aria-*</code> 어트리뷰트가 그렇습니다.</p>\n</li>\n<li>\n<p>일부 DOM 프로퍼티는 해당되는 어트리뷰트가 없는 경우도 있습니다. <code>textContent</code>가 그렇습니다.</p>\n</li>\n</ul>\n<p><em>HTML 어트리뷰트</em>와 <em>DOM 프로퍼티</em>는 이름이 같은 것도 있지만 엄연히 다르다는 것을 명심해야 합니다.\nAngular에서 HTML 어트리뷰트는 엘리먼트나 디렉티브 상태를 초기화할 때만 사용합니다.</p>\n<p><strong>템플릿에서 하는 바인딩도 <em>어트리뷰트</em>가 아니라 <em>프로퍼티</em>와 <em>이벤트</em>를 바인딩하는 것입니다.</strong></p>\n<p>그래서 데이터 바인딩은 <em>DOM 프로퍼티</em>와 <em>이벤트</em>를 대상 객체와 바인딩하는 것을 의미합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nThis general rule can help you build a mental model of attributes and DOM properties:\n**Attributes initialize DOM properties and then they are done.\nProperty values can change; attribute values can't.**\n\nThere is one exception to this rule.\nAttributes can be changed by `setAttribute()`, which re-initializes corresponding DOM properties.\n-->\n<p>어트리뷰트와 DOM 프로퍼티를 구별하려면 확실한 규칙을 세워놓는 것이 좋습니다:\n<strong>어트리뷰트는 DOM 프로퍼티를 초기화하고 나면 역할을 다한 것입니다.\n프로퍼티는 변경될 수 있지만 어트리뷰트는 변경되지 않습니다.</strong></p>\n<p>다만 한가지 예외는 있습니다.\n<code>setAttribute()</code>를 사용하면 어트리뷰트가 변경되기 때문에 관련된 DOM 프로퍼티도 다시 초기화됩니다.</p>\n</div>\n<!--\nFor more information, see the [MDN Interfaces documentation](https://developer.mozilla.org/en-US/docs/Web/API#Interfaces) which has API docs for all the standard DOM elements and their properties.\nComparing the [`<td>` attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/td) attributes to the [`<td>` properties](https://developer.mozilla.org/en-US/docs/Web/API/HTMLTableCellElement) provides a helpful example for differentiation.\nIn particular, you can navigate from the attributes page to the properties via \"DOM interface\" link, and navigate the inheritance hierarchy up to `HTMLTableCellElement`.\n-->\n<p>더 자세한 내용을 알아보려면 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API#Interfaces\">MDN 인터페이스 문서</a>에서 설명하는 표준 DOM 엘리먼트와 이 엘리먼트의 프로퍼티에 대한 설명을 보는 것도 좋습니다.\n그리고 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/td\"><code>&#x3C;td></code> 어트리뷰트</a>와 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/HTMLTableCellElement\"><code>&#x3C;td></code> 프로퍼티</a>가 어떻게 다른지 비교해 보는 것도 좋습니다.\n이 문서에서는 \"DOM 인터페이스\" 링크를 통해 어트리뷰트와 프로퍼티를 비교해볼 수 있기 때문에 <code>HTMLTableCellElement</code>의 계층 구조에 대해서도 함께 보면 더 좋습니다.</p>\n<!--\n#### Example 1: an `<input>`\n-->\n<h4 id=\"예제-1-input\">예제 1: <code>&#x3C;input></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#예제-1-input\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nWhen the browser renders `<input type=\"text\" value=\"Sarah\">`, it creates a\ncorresponding DOM node with a `value` property initialized to \"Sarah\".\n-->\n<p>브라우저가 <code>&#x3C;input type=\"text\" value=\"Sarah\"></code> 엘리먼트를 렌더링하면 DOM 노드의 <code>value</code> 프로퍼티를 \"Sarah\"로 초기화합니다.</p>\n<code-example language=\"html\">\n&#x3C;input type=\"text\" value=\"Sarah\">\n</code-example>\n<!--\nWhen the user enters \"Sally\" into the `<input>`, the DOM element `value` *property* becomes \"Sally\".\nHowever, if you look at the HTML attribute `value` using `input.getAttribute('value')`, you can see that the *attribute* remains unchanged&mdash;it returns \"Sarah\".\n\nThe HTML attribute `value` specifies the *initial* value; the DOM `value` property is the *current* value.\n\nTo see attributes versus DOM properties in a functioning app, see the <live-example name=\"binding-syntax\"></live-example> especially for binding syntax.\n-->\n<p>그리고 사용자가 <code>&#x3C;input></code> 엘리먼트에 \"Sally\"를 입력하면 DOM 엘리먼트의 <code>value</code> <em>프로퍼티</em>가 \"Sally\"로 변경됩니다.\n하지만 <code>input.getAttribute('value')</code>를 실행해서 <code>value</code> HTML 어트리뷰트의 값을 확인해보면 이 <em>어트리뷰트</em> 값은 여전히 \"Sarah\"인 것을 확인할 수 있습니다.</p>\n<p><code>value</code> HTML 어트리뷰트는 <em>초기값</em>을 지정하는 용도로 사용되지만, <code>value</code> DOM 프로퍼티는 <em>현재값</em>을 저장하는 용도로 사용됩니다.</p>\n<p>동작하는 앱에서 어트리뷰트와 DOM 프로퍼티의 관계를 확인해 보려면 <live-example name=\"binding-syntax\"></live-example>를 참고하세요.</p>\n<!--\n#### Example 2: a disabled button\n-->\n<h4 id=\"예제-2-버튼-비활성화\">예제 2: 버튼 비활성화<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#예제-2-버튼-비활성화\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe `disabled` attribute is another example. A button's `disabled`\n*property* is `false` by default so the button is enabled.\n\nWhen you add the `disabled` *attribute*, its presence alone\ninitializes the button's `disabled` *property* to `true`\nso the button is disabled.\n-->\n<p><code>disabled</code> 어트리뷰트는 조금 다릅니다.\n버튼의 <code>disabled</code> <em>프로퍼티</em>의 기본값은 <code>false</code>이기 때문에 기본 상태에서 버튼은 활성화되어 있습니다.</p>\n<p>그리고 <code>disabled</code> <em>어트리뷰트</em>를 추가하면 이 어트리뷰트는 버튼의 <code>disabled</code> <em>프로퍼티</em> 값을 <code>true</code>로 바꾸기 때문에 버튼도 비활성화 됩니다.</p>\n<code-example language=\"html\">\n&#x3C;button disabled>Test Button&#x3C;/button>\n</code-example>\n<!--\nAdding and removing the `disabled` *attribute* disables and enables the button.\nHowever, the value of the *attribute* is irrelevant,\nwhich is why you cannot enable a button by writing `<button disabled=\"false\">Still Disabled</button>`.\n\nTo control the state of the button, set the `disabled` *property*,\n-->\n<p>이때 <code>disabled</code> <em>어트리뷰트</em>가 존재하는지에 따라서 버튼이 활성화 되거나 비활성화 되며, <em>어트리뷰트</em> 값은 중요하지 않습니다.\n<code>&#x3C;button disabled=\"false\">Still Disabled&#x3C;/button></code>와 같이 작성해도 버튼은 비활성화됩니다.</p>\n<p>버튼의 활성화 여부를 결정하는 것은 <code>disabled</code> <em>프로퍼티</em> 입니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nThough you could technically set the `[attr.disabled]` attribute binding, the values are different in that the property binding requires to a boolean value, while its corresponding attribute binding relies on whether the value is `null` or not. Consider the following:\n-->\n<p>문법으로 보면 <code>[attr.disabled]</code> 처럼 어트리뷰트 바인딩을 사용할 수도 있지만 이 때 지정하는 값은 프로퍼티를 바인딩할 때 사용했던 불리언 값이 아니라 <code>null</code>이거나 <code>null</code>이 아닌 값만을 구별합니다.\n다음 코드를 참고하세요:</p>\n<code-example language=\"html\">\n&#x3C;input [disabled]=\"condition ? true : false\">\n&#x3C;input [attr.disabled]=\"condition ? 'disabled' : null\">\n</code-example>\n<!--\nGenerally, use property binding over attribute binding as it is more intuitive (being a boolean value), has a shorter syntax, and is more performant.\n-->\n<p>일반적으로 프로퍼티 바인딩을 사용하면 어트리뷰트 바인딩을 사용할때보다 코드가 짧으며, 성능이 좋고 이 경우에는 불리언 값을 그대로 반영하기 때문에 좀 더 직관적입니다.</p>\n</div>\n<!--\nTo see the `disabled` button example in a functioning app, see the <live-example name=\"binding-syntax\"></live-example> especially for binding syntax. This example shows you how to toggle the disabled property from the component.\n-->\n<p><code>disabled</code> 버튼이 동작하는 것을 직접 확인해 보려면 <live-example name=\"binding-syntax\"></live-example>에서 바인딩 문법 쪽을 보면 좋습니다.\n이 예제는 컴포넌트의 프로퍼티에 따라 버튼의 비활성화를 토글하는 예제입니다.</p>\n<!--\n## Binding types and targets\n-->\n<h2 id=\"타입별-바인딩-대상\">타입별 바인딩 대상<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#타입별-바인딩-대상\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe **target of a data-binding** is something in the DOM.\nDepending on the binding type, the target can be a property (element, component, or directive),\nan event (element, component, or directive), or sometimes an attribute name.\nThe following table summarizes the targets for the different binding types.\n-->\n<p><strong>데이터 바인딩 대상</strong>은 DOM에 있는 무언가입니다.\n이 때 바인딩 대상은 바인딩 종류에 따라 엘리먼트,컴포넌트, 디렉티브의 프로퍼티가 될수도 있고 이벤트가 될수도 있으며, 어트리뷰트 이름이 될수도 있습니다.\n바인딩 종류에 따라 어떤 것이 바인딩 대상이 되는지 아래 표로 확인해 보세요.</p>\n<style>\n  td, th {vertical-align: top}\n</style>\n<table width=\"100%\">\n  <!--\n  <col width=\"10%\">\n  </col>\n  <col width=\"15%\">\n  </col>\n  <col width=\"75%\">\n  </col>\n  -->\n  <colgroup><col width=\"15%\">\n  \n  <col width=\"21%\">\n  \n  <col width=\"64%\">\n  \n  </colgroup><tbody><tr>\n    <th>\n      <!--\n      Type\n  \t  -->\n  \t  종류\n    </th>\n    <th>\n      <!--\n      Target\n      -->\n      대상\n    </th>\n    <th>\n      <!--\n      Examples\n      -->\n      예제\n    </th>\n  </tr>\n  <tr>\n    <td>\n      <!--\n      Property\n      -->\n      프로퍼티\n    </td>\n    <td>\n      <!--\n      Element&nbsp;property<br>\n      Component&nbsp;property<br>\n      Directive&nbsp;property\n      -->\n      엘리먼트 프로퍼티<br>\n      컴포넌트 프로퍼티<br>\n      디렉티브 프로퍼티\n    </td>\n    <td>\n      <!--\n      <code>src</code>, <code>hero</code>, and <code>ngClass</code> in the following:\n      -->\n      <code>src</code>, <code>hero</code>, <code><a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a></code> 프로퍼티:\n      <code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-syntax-1\">\n&#x3C;img [src]=\"heroImageUrl\">\n&#x3C;app-hero-detail [hero]=\"currentHero\">&#x3C;/app-hero-detail>\n&#x3C;div [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"{'special': isSpecial}\">&#x3C;/div>\n\n</code-example>\n      <!-- For more information, see [Property Binding](guide/property-binding). -->\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <!--\n      Event\n      -->\n      이벤트\n    </td>\n    <td>\n      <!--\n      Element&nbsp;event<br>\n      Component&nbsp;event<br>\n      Directive&nbsp;event\n      -->\n      엘리먼트 이벤트<br>\n      컴포넌트 이벤트<br>\n      디렉티브 이벤트\n    </td>\n    <td>\n      <!--\n      <code>click</code>, <code>deleteRequest</code>, and <code>myClick</code> in the following:\n      -->\n      <code>click</code>, <code>deleteRequest</code>, <code>myClick</code> 이벤트:\n      <code-example path=\"template-syntax/src/app/app.component.html\" region=\"event-binding-syntax-1\">\n&#x3C;button (click)=\"onSave()\">Save&#x3C;/button>\n&#x3C;app-hero-detail (deleteRequest)=\"deleteHero()\">&#x3C;/app-hero-detail>\n&#x3C;div (myClick)=\"clicked=$event\" clickable>click me&#x3C;/div>\n\n</code-example>\n      <!-- KW--Why don't these links work in the table? -->\n      <!-- <div>For more information, see [Event Binding](guide/event-binding).</div> -->\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <!--\n      Two-way\n      -->\n      양방향\n    </td>\n    <td>\n      <!--\n      Event and property\n      -->\n      이벤트, 프로퍼티\n    </td>\n    <td>\n      <code-example path=\"template-syntax/src/app/app.component.html\" region=\"2-way-binding-syntax-1\">\n&#x3C;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"name\">\n\n</code-example>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <!--\n      Attribute\n      -->\n      어트리뷰트\n    </td>\n    <td>\n      <!--\n      Attribute\n      (the&nbsp;exception)\n      -->\n      어트리뷰트(일부)\n    </td>\n    <td>\n      <code-example path=\"template-syntax/src/app/app.component.html\" region=\"attribute-binding-syntax-1\">\n&#x3C;button [attr.aria-label]=\"help\">help&#x3C;/button>\n\n</code-example>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <!--\n      Class\n      -->\n      클래스\n    </td>\n    <td>\n      <!--\n      <code>class</code> property\n      -->\n      <code>class</code> 프로퍼티\n    </td>\n    <td>\n      <code-example path=\"template-syntax/src/app/app.component.html\" region=\"class-binding-syntax-1\">\n&#x3C;div [class.special]=\"isSpecial\">Special&#x3C;/div>\n\n</code-example>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <!--\n      Style\n      -->\n      스타일\n    </td>\n    <td>\n      <!--\n      <code>style</code> property\n      -->\n      <code><a href=\"api/animations/style\" class=\"code-anchor\">style</a></code> 프로퍼티\n    </td>\n    <td>\n      <code-example path=\"template-syntax/src/app/app.component.html\" region=\"style-binding-syntax-1\">\n&#x3C;button [style.color]=\"isSpecial ? 'red' : 'green'\">\n\n</code-example>\n    </td>\n  </tr>\n</tbody></table>\n<!-- end of binding syntax -->\n<hr>\n<a id=\"property-binding\"></a>\n<!--\n## Property binding `[property]`\n-->\n<h2 id=\"프로퍼티-바인딩-property\">프로퍼티 바인딩 <code>[property]</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#프로퍼티-바인딩-property\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nUse property binding to _set_ properties of target elements or\ndirective `@Input()` decorators. For an example\ndemonstrating all of the points in this section, see the\n<live-example name=\"property-binding\">property binding example</live-example>.\n-->\n<p>프로퍼티 바인딩은 대상 엘리먼트나 디렉티브에 있는 프로퍼티 중 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터를 사용한 프로퍼티의 값을 <em>설정하기 위해</em> 사용합니다.\n이 문서에서 다루는 내용을 확인하려면 <live-example name=\"property-binding\">프로퍼티 바인딩 예제</live-example>를 참고하세요.</p>\n<!--\n### One-way in\n-->\n<h3 id=\"단방향-전달\">단방향 전달<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#단방향-전달\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nProperty binding flows a value in one direction,\nfrom a component's property into a target element property.\n\nYou can't use property\nbinding to read or pull values out of target elements. Similarly, you cannot use\nproperty binding to call a method on the target element.\nIf the element raises events, you can listen to them with an [event binding](guide/template-syntax#event-binding).\n\nIf you must read a target element property or call one of its methods,\nsee the API reference for [ViewChild](api/core/ViewChild) and\n[ContentChild](api/core/ContentChild).\n-->\n<p>프로퍼티 바인딩은 컴포넌트의 프로퍼티 값 하나를 대상 엘리먼트 프로퍼티로 전달합니다.</p>\n<p>그래서 프로퍼티 바인딩은 대상 엘리먼트의 값을 읽는 용도로 사용할 수는 없습니다.\n이와 비슷하게, 대상 엘리먼트에 있는 메소드를 실행하는 용도로도 사용할 수 없습니다.\n엘리먼트에서 발생하는 이벤트에 반응하려면 <a href=\"guide/template-syntax#event-binding\">이벤트 바인딩</a>을 사용해야 합니다.</p>\n<p>대상 엘리먼트의 프로퍼티를 읽거나 메소드를 실행해야 한다면 <a href=\"api/core/ViewChild\">ViewChild</a>나 <a href=\"api/core/ContentChild\">ContentChild</a>를 활용하는 것이 좋습니다.</p>\n<!--\n### Examples\n-->\n<h3 id=\"예제\">예제<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#예제\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe most common property binding sets an element property to a component\nproperty value. An example is\nbinding the `src` property of an image element to a component's `itemImageUrl` property:\n\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"property-binding\" header=\"src/app/app.component.html\">\n&lt;img [src]=&quot;itemImageUrl&quot;&gt;\n\n</code-example>\n\nHere's an example of binding to the `colSpan` property. Notice that it's not `colspan`,\nwhich is the attribute, spelled with a lowercase `s`.\n\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"colSpan\" header=\"src/app/app.component.html\">\n&lt;!-- colSpan 프로퍼티는 캐멀 케이스입니다. --&gt;\n&lt;tr&gt;&lt;td [colSpan]=&quot;2&quot;&gt;Span 2 columns&lt;/td&gt;&lt;/tr&gt;\n\n</code-example>\n\nFor more details, see the [MDN HTMLTableCellElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLTableCellElement) documentation.\n-->\n<p>프로퍼티 바인딩은 보통 컴포넌트의 프로퍼티 값을 지정하기 위해 사용합니다.\n컴포넌트의 <code>itemImageUrl</code> 프로퍼티 값을 <code>&#x3C;img></code> 엘리먼트의 <code>src</code> 프로퍼티에 지정하려면 다음과 같이 구현합니다:</p>\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"property-binding\" header=\"src/app/app.component.html\">\n&#x3C;img [src]=\"itemImageUrl\">\n\n</code-example>\n<p><code>colSpan</code> 프로퍼티도 바인딩할 수 있습니다.\n소문자 <code>s</code>가 사용된 어트리뷰트 <code>colspan</code>이 아니라 <code>colSpan</code> 프로퍼티라는 것에 주의하세요.</p>\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"colSpan\" header=\"src/app/app.component.html\">\n&#x3C;!-- colSpan 프로퍼티는 캐멀 케이스입니다. -->\n&#x3C;tr>&#x3C;td [colSpan]=\"2\">Span 2 columns&#x3C;/td>&#x3C;/tr>\n\n</code-example>\n<p>테이블 셀에 사용할 수 있는 프로퍼티 목록은 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/HTMLTableCellElement\">MDN HTMLTableCellElement</a> 문서를 참고하세요.</p>\n<!-- Add link when Attribute Binding updates are merged:\nFor more about `colSpan` and `colspan`, see (Attribute Binding)[guide/template-syntax]. -->\n<!--\nAnother example is disabling a button when the component says that it `isUnchanged`:\n\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"disabled-button\" header=\"src/app/app.component.html\">\n&lt;!-- 버튼의 활성화 여부를 `isUnchanged` 프로퍼티와 바인딩합니다. --&gt;\n&lt;button [disabled]=&quot;isUnchanged&quot;&gt;Disabled Button&lt;/button&gt;\n\n</code-example>\n\nAnother is setting a property of a directive:\n\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"class-binding\" header=\"src/app/app.component.html\">\n&lt;p [ngClass]=&quot;classes&quot;&gt;[ngClass] binding to the classes property making this blue&lt;/p&gt;\n\n</code-example>\n\nYet another is setting the model property of a custom component&mdash;a great way\nfor parent and child components to communicate:\n\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"model-property-binding\" header=\"src/app/app.component.html\">\n&lt;app-item-detail [childItem]=&quot;parentItem&quot;&gt;&lt;/app-item-detail&gt;\n\n</code-example>\n-->\n<p>컴포넌트의 <code>isUnchanged</code> 프로퍼티를 사용했던 것처럼 버튼을 비활성화하는 용도로도 사용할 수 있습니다:</p>\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"disabled-button\" header=\"src/app/app.component.html\">\n&#x3C;!-- 버튼의 활성화 여부를 `isUnchanged` 프로퍼티와 바인딩합니다. -->\n&#x3C;button [disabled]=\"isUnchanged\">Disabled Button&#x3C;/button>\n\n</code-example>\n<p>디렉티브에서는 이렇게 사용합니다:</p>\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"class-binding\" header=\"src/app/app.component.html\">\n&#x3C;p [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"classes\">[<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>] binding to the classes property making this blue&#x3C;/p>\n\n</code-example>\n<p>그리고 아직 다루지는 않았지만, 부모 컴포넌트의 객체를 자식 컴포넌트로 전달할 때는 이렇게 사용할 수 있습니다:</p>\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"model-property-binding\" header=\"src/app/app.component.html\">\n&#x3C;app-item-detail [childItem]=\"parentItem\">&#x3C;/app-item-detail>\n\n</code-example>\n<!--\n### Binding targets\n-->\n<h3 id=\"바인딩-대상\">바인딩 대상<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#바인딩-대상\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAn element property between enclosing square brackets identifies the target property.\nThe target property in the following code is the image element's `src` property.\n-->\n<p>엘리먼트의 프로퍼티를 대괄호(<code>[</code>, <code>]</code>)로 감싸면 프로퍼티 바인딩 대상으로 지정할 수 있습니다.\n그래서 다음 코드에서는 이미지 엘리먼트의 <code>src</code> 프로퍼티가 프로퍼티 바인딩의 대상 프로퍼티입니다.</p>\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"property-binding\" header=\"src/app/app.component.html\">\n&#x3C;img [src]=\"itemImageUrl\">\n\n</code-example>\n<!--\nThere's also the `bind-` prefix alternative:\n-->\n<p>이 방식이 익숙하지 않다면 다음과 같이 <code>bind-</code> 접두사를 사용할 수도 있습니다.</p>\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"bind-prefix\" header=\"src/app/app.component.html\">\n&#x3C;img bind-src=\"itemImageUrl\">\n\n</code-example>\n<!--\nIn most cases, the target name is the name of a property, even\nwhen it appears to be the name of an attribute.\nSo in this case, `src` is the name of the `<img>` element property.\n\nElement properties may be the more common targets,\nbut Angular looks first to see if the name is a property of a known directive,\nas it is in the following example:\n-->\n<p>대부분의 경우에 바인딩 대상으로 지정한 이름은 프로퍼티 이름입니다. 어트리뷰트같이 보여도 프로퍼티인 경우가 더 많습니다.\n위 예제도 <code>src</code>는 <code>&#x3C;img></code> 엘리먼트의 프로퍼티입니다.</p>\n<p>바인딩되는 프로퍼티는 대상 엘리먼트의 프로퍼티인 것이 일반적이지만, 다음과 같이 Angular가 제공하는 기본 디렉티브의 프로퍼티일 수도 있습니다.\n이 때는 엘리먼트 프로퍼티보다 디렉티브 프로퍼티의 우선순위가 높습니다:</p>\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"class-binding\" header=\"src/app/app.component.html\">\n&#x3C;p [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"classes\">[<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>] binding to the classes property making this blue&#x3C;/p>\n\n</code-example>\n<!--\nTechnically, Angular is matching the name to a directive `@Input()`,\none of the property names listed in the directive's `inputs` array\nor a property decorated with `@Input()`.\nSuch inputs map to the directive's own properties.\n\nIf the name fails to match a property of a known directive or element, Angular reports an “unknown directive” error.\n-->\n<p>Angular는 바인딩 대상을 찾을 때 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>이 지정된 프로퍼티나 디렉티브의 <code>inputs</code> 배열을 찾습니다.</p>\n<p>그리고 매칭되는 이름을 찾지 못하면 \"unknown directive\" 에러가 발생합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nThough the target name is usually the name of a property,\nthere is an automatic attribute-to-property mapping in Angular for\nseveral common attributes. These include `class`/`className`, `innerHtml`/`innerHTML`, and\n`tabindex`/`tabIndex`.\n-->\n<p>일반적으로 바인딩 대상은 프로퍼티의 이름과 매칭되지만 어트리뷰트 값이 프로퍼티 값과 자동으로 연결된 경우도 있습니다.\n<code>class</code>/<code>className</code>, <code>innerHtml</code>/<code>innerHTML</code>, <code>tabindex</code>/<code>tabIndex</code>가 그렇습니다.</p>\n</div>\n<a id=\"avoid-side-effects\"></a>\n<!--\n### Avoid side effects\n-->\n<h3 id=\"외부-영향-최소화-1\">외부 영향 최소화<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#외부-영향-최소화-1\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nEvaluation of a template expression should have no visible side effects.\nThe expression language itself, or the way you write template expressions,\nhelps to a certain extent;\nyou can't assign a value to anything in a property binding expression\nnor use the increment and decrement operators.\n\nFor example, you could have an expression that invoked a property or method that had\nside effects. The expression could call something like `getFoo()` where only you\nknow what `getFoo()` does. If `getFoo()` changes something\nand you happen to be binding to that something,\nAngular may or may not display the changed value. Angular may detect the\nchange and throw a warning error.\nAs a best practice, stick to properties and to methods that return\nvalues and avoid side effects.\n-->\n<p>템플릿 표현식을 평가하는 것은 다른 곳에 영향을 주지 않는 것이 좋습니다.\n표현식은 그 자체로 실행되고 끝나야지 이 표현식의 결과가 다른 컨텍스트에 영향을 주면 디버깅하기 어렵습니다.\n템플릿 표현식의 결과값으로 바인딩된 프로퍼티 값을 지정하는 것은 좋지만 템플릿 표현식에서 증감연산자를 사용하는 것도 좋지 않습니다.</p>\n<p>템플릿 표현식 밖으로 영향을 미치는 표현식에 대해 생각해 봅시다.\n<code>getFoo()</code>라는 함수가 어떤 동작을 하는지 제대로 이해하고 있다면 템플릿 표현식에서 이 함수를 사용하는 것이 문제되지 않습니다.\n그런데 <code>getFoo()</code> 함수는 한 템플릿 표현식 외에도 다른 곳에 사용되어 바인딩된 값을 바꿀 수 있습니다.\nAngular가 이런 문제를 발견한다면 경고 메시지를 표시하겠지만 모든 경우를 감지할 수는 없기 때문에 사용하지 않는 것이 좋습니다.\n컴포넌트 프로퍼티를 그대로 전달하거나 메소드가 실행된 후에 반환한 값을 그대로 전달하는 것이 가장 좋습니다.</p>\n<!--\n### Return the proper type\n-->\n<h3 id=\"맞는-타입으로-반환하세요\">맞는 타입으로 반환하세요.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#맞는-타입으로-반환하세요\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe template expression should evaluate to the type of value\nthat the target property expects.\nReturn a string if the target property expects a string, a number if it\nexpects a number, an object if it expects an object, and so on.\n\nIn the following example, the `childItem` property of the `ItemDetailComponent` expects a string, which is exactly what you're sending in the property binding:\n\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"model-property-binding\" header=\"src/app/app.component.html\">\n&lt;app-item-detail [childItem]=&quot;parentItem&quot;&gt;&lt;/app-item-detail&gt;\n\n</code-example>\n\nYou can confirm this by looking in the `ItemDetailComponent` where the `@Input` type is set to a string:\n<code-example path=\"property-binding/src/app/item-detail/item-detail.component.ts\" region=\"input-type\" header=\"src/app/item-detail/item-detail.component.ts (setting the @Input() type)\">\n@Input() childItem: string;\n\n</code-example>\n\nAs you can see here, the `parentItem` in `AppComponent` is a string, which the `ItemDetailComponent` expects:\n<code-example path=\"property-binding/src/app/app.component.ts\" region=\"parent-data-type\" header=\"src/app/app.component.ts\">\nparentItem = &#39;lamp&#39;;\n\n</code-example>\n-->\n<p>템플릿 표현식을 작성할 때는 이 표현식이 반환하는 값의 타입을 적절하게 지정해야 합니다.\n대상 프로퍼티가 문자열이라면 문자열을 반환해야 하고, 대상 프로퍼티가 숫자라면 숫자를, 대상 프로퍼티가 객체라면 객체를 반환해야 합니다.</p>\n<p>아래 예제에서 <code>ItemDetailComponent</code>의 <code>childItem</code> 프로퍼티는 <code>string</code> 타입으로 선언되어 있으며 프로퍼티 바인딩은 다음과 같이 사용되었습니다:</p>\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"model-property-binding\" header=\"src/app/app.component.html\">\n&#x3C;app-item-detail [childItem]=\"parentItem\">&#x3C;/app-item-detail>\n\n</code-example>\n<p>아래 <code>ItemDetailComponent</code> 코드에서도 알 수 있듯이 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>으로 지정된 프로퍼티는 <code>string</code> 타입입니다:</p>\n<code-example path=\"property-binding/src/app/item-detail/item-detail.component.ts\" region=\"input-type\" header=\"src/app/item-detail/item-detail.component.ts (@Input() 데코레이터가 지정된 프로퍼티)\">\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() childItem: string;\n\n</code-example>\n<p>그렇다면 <code>AppComponent</code>가 전달하는 <code>parentItem</code> 프로퍼티도 문자열이어야 이 코드가 모두 제대로 동작할 것입니다:</p>\n<code-example path=\"property-binding/src/app/app.component.ts\" region=\"parent-data-type\" header=\"src/app/app.component.ts\">\nparentItem = 'lamp';\n\n</code-example>\n<!--\n#### Passing in an object\n-->\n<h4 id=\"객체-전달하기\">객체 전달하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#객체-전달하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe previous simple example showed passing in a string. To pass in an object,\nthe syntax and thinking are the same.\n\nIn this scenario, `ListItemComponent` is nested within `AppComponent` and the `items` property expects an array of objects.\n\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"pass-object\" header=\"src/app/app.component.html\">\n&lt;app-list-item [items]=&quot;currentItem&quot;&gt;&lt;/app-list-item&gt;\n\n</code-example>\n\nThe `items` property is declared in the `ListItemComponent` with a type of `Item` and decorated with `@Input()`:\n\n<code-example path=\"property-binding/src/app/list-item/list-item.component.ts\" region=\"item-input\" header=\"src/app/list-item.component.ts\">\n@Input() items: Item[];\n\n</code-example>\n\nIn this sample app, an `Item` is an object that has two properties; an `id` and a `name`.\n\n<code-example path=\"property-binding/src/app/item.ts\" region=\"item-class\" header=\"src/app/item.ts\">\nexport interface Item {\n  id: number;\n  name: string;\n}\n\n</code-example>\n\nWhile a list of items exists in another file, `mock-items.ts`, you can\nspecify a different item in `app.component.ts` so that the new item will render:\n\n<code-example path=\"property-binding/src/app/app.component.ts\" region=\"pass-object\" header=\"src/app.component.ts\">\ncurrentItem = [{\n  id: 21,\n  name: &#39;phone&#39;\n}];\n\n</code-example>\n\nYou just have to make sure, in this case, that you're supplying an array of objects because that's the type of `items` and is what the nested component, `ListItemComponent`, expects.\n\nIn this example, `AppComponent` specifies a different `item` object\n(`currentItem`) and passes it to the nested `ListItemComponent`. `ListItemComponent` was able to use `currentItem` because it matches what an `Item` object is according to `item.ts`. The `item.ts` file is where\n`ListItemComponent` gets its definition of an `item`.\n-->\n<p>위 예제는 문자열을 전달하기 때문에 아주 간단합니다.\n그리고 객체의 경우도 마찬가지입니다.</p>\n<p><code>AppComponent</code>의 <code>items</code> 프로퍼티는 객체의 배열이고 이 프로퍼티가 <code>ListItemComponent</code>로 바인딩되는 경우를 봅시다.</p>\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"pass-object\" header=\"src/app/app.component.html\">\n&#x3C;app-list-item [items]=\"currentItem\">&#x3C;/app-list-item>\n\n</code-example>\n<p><code>ListItemComponent</code>의 <code>items</code> 프로퍼티는 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터로 지정되었으며 이 배열은 <code>Item</code> 타입의 배열입니다.</p>\n<code-example path=\"property-binding/src/app/list-item/list-item.component.ts\" region=\"item-input\" header=\"src/app/list-item.component.ts\">\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() items: Item[];\n\n</code-example>\n<p>이 예제 앱에서 <code>Item</code> 객체에는 <code>id</code> 프로퍼티와 <code>name</code> 프로퍼티가 존재합니다.</p>\n<code-example path=\"property-binding/src/app/item.ts\" region=\"item-class\" header=\"src/app/item.ts\">\nexport interface Item {\n  id: number;\n  name: string;\n}\n\n</code-example>\n<p>원래 이 데이터는 외부 파일 <code>mock-items.ts</code>에 있지만, <code>AppComponent</code>에 다음과 같이 작성해도 동작합니다:</p>\n<code-example path=\"property-binding/src/app/app.component.ts\" region=\"pass-object\" header=\"src/app.component.ts\">\ncurrentItem = [{\n  id: 21,\n  name: 'phone'\n}];\n\n</code-example>\n<p>여기에서 확인해야 할 것은, <code>ListItemComponent</code>의 <code>items</code> 프로퍼티는 객체의 배열을 할당받는 것으로 정의했기 때문에 이 타입에 맞는 값을 바인딩해야 한다는 것입니다.</p>\n<p>위 코드처럼 <code>AppComponent</code>의 <code>currentItem</code> 프로퍼티 값을 <code>Item</code> 배열 형식으로 할당하면 자식 컴포넌트 <code>ListItemComponent</code>도 제대로 동작합니다.\n<code>AppComponent</code>에서는 <code>Item</code> 타입이라는 것을 명시하지 않았지만 이 객체가 <code>ListItemComponent</code>에서 원하는 형식과 같기 때문입니다.</p>\n<!--\n### Remember the brackets\n-->\n<h3 id=\"괄호를-깜빡하면-안됩니다\">괄호를 깜빡하면 안됩니다.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#괄호를-깜빡하면-안됩니다\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe brackets, `[]`, tell Angular to evaluate the template expression.\nIf you omit the brackets, Angular treats the string as a constant\nand *initializes the target property* with that string:\n-->\n<p>템플릿 표현식은 프로퍼티를 대괄호로 감싸야 Angular가 템플릿 표현식이라고 인식하고 실행할 수 있습니다.\n그래서 대괄호가 없으면 Angular는 이 문장을 단순하게 문자열로 판단하고 <em>대상 프로퍼티를 그 문자열로 초기화</em>할 것입니다.</p>\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"no-evaluation\" header=\"src/app.component.html\">\n&#x3C;app-item-detail childItem=\"parentItem\">&#x3C;/app-item-detail>\n\n</code-example>\n<!--\nOmitting the brackets will render the string\n`parentItem`, not the value of `parentItem`.\n-->\n<p>괄호를 깜빡하면 <code>parentItem</code>의 값 대신 <code>parentItem</code>이라는 문자열을 할당합니다.</p>\n<!--\n### One-time string initialization\n-->\n<h3 id=\"문자열을-그대로-사용하는-경우\">문자열을 그대로 사용하는 경우<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#문자열을-그대로-사용하는-경우\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou *should* omit the brackets when all of the following are true:\n-->\n<p>다음과 같은 경우라면 프로퍼티 바인딩에 사용하는 대괄호를 빼는 것이 좋습니다.</p>\n<!--\n* The target property accepts a string value.\n* The string is a fixed value that you can put directly into the template.\n* This initial value never changes.\n-->\n<ul>\n<li>바인딩 대상 프로퍼티에 문자열 값을 할당하는 경우</li>\n<li>템플릿에서 고정된 문자열 값을 전달하는 경우</li>\n<li>변경되지 않는 문자열</li>\n</ul>\n<!--\nYou routinely initialize attributes this way in standard HTML, and it works\njust as well for directive and component property initialization.\nThe following example initializes the `prefix` property of the `StringInitComponent` to a fixed string,\nnot a template expression. Angular sets it and forgets about it.\n-->\n<p>HTML에서 어트리뷰트를 초기화하는 방식은 Angular에서도 유효하며, 디렉티브나 컴포넌트 프로퍼티를 초기화할 때도 같은 방식을 사용합니다.\n다음 예제를 보면 <code>HeroDetailComponent</code> 에 사용할 <code>prefix</code> 프로퍼티를 초기화하는데, 이 때 템플릿 표현식을 사용하지 않고 고정된 문자열을 사용했습니다.\n그러면 Angular는 대상 프로퍼티의 초기값을 설정할 때만 이 문자열을 사용하고, 이후에는 신경쓰지 않습니다.</p>\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"string-init\" header=\"src/app/app.component.html\">\n&#x3C;app-string-init prefix=\"This is a one-time initialized string.\">&#x3C;/app-string-init>\n\n</code-example>\n<!--\nThe `[item]` binding, on the other hand, remains a live binding to the component's `currentItem` property.\n-->\n<p>하지만 <code>[<a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>]</code> 바인딩에서는 컴포넌트의 <code>currentItem</code> 프로퍼티 값에 따라 전달되는 값이 달라지기 때문에 대괄호를 사용하는 것이 좋습니다.</p>\n<!--\n### Property binding vs. interpolation\n-->\n<h3 id=\"프로퍼티-바인딩-vs-문자열-바인딩\">프로퍼티 바인딩 vs. 문자열 바인딩<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#프로퍼티-바인딩-vs-문자열-바인딩\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou often have a choice between interpolation and property binding.\nThe following binding pairs do the same thing:\n-->\n<p>코드를 작성하다보면 프로퍼티 바인딩을 해야할 지 문자열 바인딩(Interpolation)을 해야할 지 고민될 때가 있습니다.\n코드를 보면서 생각해봅시다:</p>\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"property-binding-interpolation\" header=\"src/app/app.component.html\">\n&#x3C;p>&#x3C;img src=\"{{itemImageUrl}}\"> is the &#x3C;i>interpolated&#x3C;/i> image.&#x3C;/p>\n&#x3C;p>&#x3C;img [src]=\"itemImageUrl\"> is the &#x3C;i>property bound&#x3C;/i> image.&#x3C;/p>\n\n&#x3C;p>&#x3C;span>\"{{interpolationTitle}}\" is the &#x3C;i>interpolated&#x3C;/i> title.&#x3C;/span>&#x3C;/p>\n&#x3C;p>\"&#x3C;span [innerHTML]=\"propertyTitle\">&#x3C;/span>\" is the &#x3C;i>property bound&#x3C;/i> title.&#x3C;/p>\n\n</code-example>\n<!--\nInterpolation is a convenient alternative to property binding in\nmany cases. When rendering data values as strings, there is no\ntechnical reason to prefer one form to the other, though readability\ntends to favor interpolation. However, *when setting an element\nproperty to a non-string data value, you must use property binding*.\n-->\n<p>일반적으로 문자열 바인딩은 프로퍼티 바인딩을 간단하게 사용하는 테크닉으로 간주할 수 있습니다.\n그리고 문자열을 화면에 렌더링하는 경우라면 꼭 필요한 경우가 아닌 이상 문자열 바인딩을 사용한 코드가 가독성이 좋습니다.\n<em>하지만 문자열이 아닌 값으로 엘리먼트 프로퍼티 값을 지정하는 경우라면 반드시 프로퍼티 바인딩을 사용해야 합니다.</em></p>\n<!--\n### Content security\n-->\n<h3 id=\"컨텐츠-보안\">컨텐츠 보안<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#컨텐츠-보안\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nImagine the following malicious content.\n\n<code-example path=\"property-binding/src/app/app.component.ts\" region=\"malicious-content\" header=\"src/app/app.component.ts\">\nevilTitle = &#39;Template &lt;script&gt;alert(&quot;evil never sleeps&quot;)&lt;/script&gt; Syntax&#39;;\n\n</code-example>\n\nIn the component template, the content might be used with interpolation:\n\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"malicious-interpolated\" header=\"src/app/app.component.html\">\n&lt;p&gt;&lt;span&gt;&quot;{{evilTitle}}&quot; is the &lt;i&gt;interpolated&lt;/i&gt; evil title.&lt;/span&gt;&lt;/p&gt;\n\n</code-example>\n\nFortunately, Angular data binding is on alert for dangerous HTML. In the above case,\nthe HTML displays as is, and the Javascript does not execute. Angular **does not**\nallow HTML with script tags to leak into the browser, neither with interpolation\nnor property binding.\n\nIn the following example, however, Angular [sanitizes](guide/security#sanitization-and-security-contexts)\nthe values before displaying them.\n\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"malicious-content\" header=\"src/app/app.component.html\">\n &lt;!--\n Angular가 아래와 같이 위험한 코드를 발견하면 경고를 표시합니다.\n WARNING: 안전성 검사를 우회하는 방법은 http://g.co/ng/security#xss 를 참고하세요.\n--&gt;\n &lt;p&gt;&quot;&lt;span [innerHTML]=&quot;evilTitle&quot;&gt;&lt;/span&gt;&quot; is the &lt;i&gt;property bound&lt;/i&gt; evil title.&lt;/p&gt;\n\n</code-example>\n\nInterpolation handles the `<script>` tags differently than\nproperty binding but both approaches render the\ncontent harmlessly. The following is the browser output\nof the `evilTitle` examples.\n\n<code-example language=\"bash\">\n\"Template <script>alert(\"evil never sleeps\")</script> Syntax\" is the interpolated evil title.\n\"Template alert(\"evil never sleeps\")Syntax\" is the property bound evil title.\n</code-example>\n-->\n<p>다음과 같은 악성 코드가 있다고 합시다.</p>\n<code-example path=\"property-binding/src/app/app.component.ts\" region=\"malicious-content\" header=\"src/app/app.component.ts\">\nevilTitle = '<a href=\"\" class=\"code-anchor\">Template</a> &#x3C;script>alert(\"evil never sleeps\")&#x3C;/script> Syntax';\n\n</code-example>\n<p>이 프로퍼티는 템플릿에서 다음과 같이 문자열 바인딩되어 사용됩니다:</p>\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"malicious-interpolated\" header=\"src/app/app.component.html\">\n&#x3C;p>&#x3C;span>\"{{evilTitle}}\" is the &#x3C;i>interpolated&#x3C;/i> evil title.&#x3C;/span>&#x3C;/p>\n\n</code-example>\n<p>다행히 Angular는 데이터 바인딩을 처리하면서 위험한 HTML을 발견하면 경고를 표시합니다.\n그리고 위와 같은 코드가 있더라도 이 코드의 JavaScript 부분을 실행하지 않고 HTML 문자열로 그냥 표시합니다.\n프로퍼티 바인딩의 경우도 마찬가지입니다.</p>\n<p>아래 예제 코드처럼 작성해도 Angular는 화면에 프로퍼티값을 표시하기 전에 <a href=\"guide/security#sanitization-and-security-contexts\">코드의 안전성을 검사</a>합니다.</p>\n<code-example path=\"property-binding/src/app/app.component.html\" region=\"malicious-content\" header=\"src/app/app.component.html\">\n &#x3C;!--\n Angular가 아래와 같이 위험한 코드를 발견하면 경고를 표시합니다.\n WARNING: 안전성 검사를 우회하는 방법은 http://g.co/ng/security#xss 를 참고하세요.\n-->\n &#x3C;p>\"&#x3C;span [innerHTML]=\"evilTitle\">&#x3C;/span>\" is the &#x3C;i>property bound&#x3C;/i> evil title.&#x3C;/p>\n\n</code-example>\n<p>문자열 바인딩을 사용한 경우와 프로퍼티 바인딩을 사용한 경우에 <code>&#x3C;script></code> 태그를 처리하는 방식이 조금 다르지만, 두 경우 모두 코드의 안전성을 검사한 이후에 화면에 렌더링한다는 점은 같습니다.\n위 코드처럼 작성하면 브라우저 콘솔에 다음과 같은 경고 문구가 출력됩니다.</p>\n<code-example language=\"bash\">\n\"Template <script>alert(\"evil never sleeps\")</script> Syntax\" is the interpolated evil title.\n\"Template alert(\"evil never sleeps\")Syntax\" is the property bound evil title.\n</code-example>\n<hr>\n<a id=\"other-bindings\"></a>\n<!--\n## Attribute, class, and style bindings\n-->\n<h2 id=\"어트리뷰트-클래스-스타일-바인딩\">어트리뷰트, 클래스, 스타일 바인딩<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#어트리뷰트-클래스-스타일-바인딩\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe template syntax provides specialized one-way bindings for scenarios less well-suited to property binding.\n\nTo see attribute, class, and style bindings in a functioning app, see the <live-example name=\"attribute-binding\"></live-example> especially for this section.\n-->\n<p>Angular 템플릿에서는 프로퍼티 바인딩 외에도 다음과 같은 특수한 바인딩을 사용할 수 있습니다.</p>\n<p>이 섹션에서 설명하는 내용을 앱에서 직접 확인하려면 <live-example name=\"attribute-binding\"></live-example>를 참고하세요.</p>\n<a id=\"attribute-binding\"></a>\n<!--\n### Attribute binding\n-->\n<h3 id=\"어트리뷰트-바인딩\">어트리뷰트 바인딩<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#어트리뷰트-바인딩\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nSet the value of an attribute directly with an **attribute binding**. This is the only exception to the rule that a binding sets a target property and the only binding that creates and sets an attribute.\n\nUsually, setting an element property with a [property binding](guide/template-syntax#property-binding)\nis preferable to setting the attribute with a string. However, sometimes\nthere is no element property to bind, so attribute binding is the solution.\n\nConsider the [ARIA](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA) and\n[SVG](https://developer.mozilla.org/en-US/docs/Web/SVG). They are purely attributes, don't correspond to element properties, and don't set element properties. In these cases, there are no property targets to bind to.\n\nAttribute binding syntax resembles property binding, but\ninstead of an element property between brackets, start with the prefix `attr`,\nfollowed by a dot (`.`), and the name of the attribute.\nYou then set the attribute value, using an expression that resolves to a string,\nor remove the attribute when the expression resolves to `null`.\n\nOne of the primary use cases for attribute binding\nis to set ARIA attributes, as in this example:\n-->\n<p><strong>어트리뷰트 바인딩</strong>은 어트리뷰트 값을 직접 설정할 때 사용합니다.\n이 방식은 프로퍼티를 바인딩하는 것과 조금 다릅니다.</p>\n<p>일반적으로 엘리먼트 프로퍼티값을 지정하려면 문자열로 어트리뷰트를 바인딩하는 것보다 <a href=\"guide/template-syntax#property-binding\">프로퍼티 바인딩</a>을 사용하는 것이 더 좋습니다.\n하지만 원하는 프로퍼티가 없어서 어트리뷰트 바인딩을 사용해야만 하는 경우가 있습니다.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA\">ARIA</a>나 <a href=\"https://developer.mozilla.org/en-US/docs/Web/SVG\">SVG</a>의 경우를 생각해 봅시다.\n이 객체들은 어트리뷰트로만 구성되기 때문에 엘리먼트 프로퍼티가 존재하지 않아서 엘리먼트의 프로퍼티를 지정할 수 없습니다.\n프로퍼티 바인딩의 대상이 되는 것이 존재하지 않는 상황입니다.</p>\n<p>어트리뷰트 바인딩 문법은 프로퍼티 바인딩 문법과 비슷하지만 대괄호 안에 엘리먼트 프로퍼티를 지정하는 대신 <code>attr</code>이라는 접미사와 <code>.</code> 문자를 붙인다는 점이 다릅니다.\n그리고 어트리뷰트에 할당되는 값이 문자열인 경우에는 이 어트리뷰트 바인딩이 유효하지만, <code>null</code> 값이 할당되는 경우에는 어트리뷰트 자체가 사라집니다.</p>\n<p>그래서 ARIA 어트리뷰트는 다음과 같은 방식으로 지정합니다:</p>\n<code-example path=\"attribute-binding/src/app/app.component.html\" region=\"attrib-binding-aria\" header=\"src/app/app.component.html\">\n&#x3C;!-- 웹 접근성 향상을 위해 ARIA 어트리뷰트를 지정할 수 있습니다. -->\n&#x3C;button [attr.aria-label]=\"actionName\">{{actionName}} with Aria&#x3C;/button>\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\n#### `colspan` and `colSpan`\n-->\n<h4 id=\"colspan과-colspan\"><code>colspan</code>과 <code>colSpan</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#colspan과-colspan\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nNotice the difference between the `colspan` attribute and the `colSpan` property.\n\nIf you wrote something like this:\n-->\n<p><code>colspan</code> 어트리뷰트와 <code>colSpan</code> 프로퍼티의 차이점에 대해 알아봅시다.</p>\n<p>다음과 같은 코드를 작성했다고 합시다:</p>\n<code-example language=\"html\">\n  &#x3C;tr>&#x3C;td colspan=\"{{1 + 1}}\">Three-Four&#x3C;/td>&#x3C;/tr>\n</code-example>\n<!--\nYou'd get this error:\n-->\n<p>그러면 에러가 발생합니다:</p>\n<code-example language=\"bash\">\n  Template parse errors:\n  Can't bind to 'colspan' since it isn't a known native property\n</code-example>\n<!--\nAs the message says, the `<td>` element does not have a `colspan` property. This is true\nbecause `colspan` is an attribute&mdash;`colSpan`, with a capital `S`, is the\ncorresponding property. Interpolation and property binding can set only *properties*, not attributes.\n\nInstead, you'd use property binding and write it like this:\n-->\n<p>이 메시지는 <code>&#x3C;td></code> 엘리먼트에 <code>colspan</code> 프로퍼티가 없다는 의미입니다.\n왜냐하면 소문자 <code>s</code>가 들어간 <code>colspan</code>은 어트리뷰트이고 대문자 <code>S</code>가 들어간 <code>colSpan</code>은 프로퍼티이기 때문입니다.\n문자열 바인딩이나 프로퍼티 바인딩은 <em>프로퍼티에만</em> 동작합니다.\n어트리뷰트는 이렇게 바인딩할 수 없습니다.</p>\n<p>이 코드는 프로퍼티 바인딩 규칙에 맞게 다음과 같이 작성되어야 합니다:</p>\n<code-example path=\"attribute-binding/src/app/app.component.html\" region=\"colSpan\" header=\"src/app/app.component.html\">\n&#x3C;!-- colSpan 프로퍼티는 캐멀 케이스입니다. -->\n&#x3C;tr>&#x3C;td [colSpan]=\"1 + 1\">Three-Four&#x3C;/td>&#x3C;/tr>\n\n</code-example>\n</div>\n<hr>\n<a id=\"class-binding\"></a>\n<!--\n### Class binding\n-->\n<h3 id=\"클래스-바인딩\">클래스 바인딩<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#클래스-바인딩\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nHere's how to set the `class` attribute without a binding in plain HTML:\n\n```html\n<!- standard class attribute setting ->\n<div class=\"foo bar\">Some text</div>\n```\n\nYou can also add and remove CSS class names from an element's `class` attribute with a **class binding**.\n\nTo create a single class binding, start with the prefix `class` followed by a dot (`.`) and the name of the CSS class (for example, `[class.foo]=\"hasFoo\"`). \nAngular adds the class when the bound expression is truthy, and it removes the class when the expression is falsy (with the exception of `undefined`, see [styling delegation](#styling-delegation)).\n\nTo create a binding to multiple classes, use a generic `[class]` binding without the dot (for example, `[class]=\"classExpr\"`).\nThe expression can be a space-delimited string of class names, or you can format it as an object with class names as the keys and truthy/falsy expressions as the values. \nWith object format, Angular will add a class only if its associated value is truthy. \n\nIt's important to note that with any object-like expression (`object`, `Array`, `Map`, `Set`, etc), the identity of the object must change for the class list to be updated.\nUpdating the property without changing object identity will have no effect.\n\nIf there are multiple bindings to the same class name, conflicts are resolved using [styling precedence](#styling-precedence).\n-->\n<p>바인딩을 사용하지 않고 문자열로 <code>class</code> 어트리뷰트를 지정하려면 다음과 같이 작성하면 됩니다:</p>\n<code-example language=\"html\">\n&#x3C;!-- 일반적인 클래스 어트리뷰트 설정 방법 -->\n&#x3C;div class=\"foo bar\">Some text&#x3C;/div>\n</code-example>\n<p>여기에 <strong>클래스 바인딩</strong> 을 사용하면 엘리먼트의 <code>class</code> 어트리뷰트를 원하는 대로 추가하거나 제거할 수 있습니다.</p>\n<p>CSS 클래스 하나를 바인딩하려면 <code>class</code>라는 접미사 뒤에 <code>.</code> 문자를 붙여서 <code>[class.foo]=\"hasFoo\"</code>와 같이 작성하면 됩니다.\n그러면 <code>hasFoo</code>라는 표현식이 참으로 평가될 때 <code>foo</code> 클래스가 추가되며, 표현식이 거짓으로 평가되면 <code>foo</code> 클래스가 제거됩니다.\n(이 때 <code>undefined</code>는 예외입니다. <a href=\"guide/template-syntax#styling-delegation\">스타일 위임</a> 섹션을 참고하세요.)</p>\n<p>CSS 클래스 여러 개를 한번에 바인딩하려면 <code>.</code> 방식을 사용하지 않고 <code>[class]</code>에 표현식을 할당하는 방식을 사용합니다.\n이 방식은 <code>[class]=\"클래스<a href=\"\" class=\"code-anchor\">_</a>표현식\"</code>과 같이 작성하는데, 표현식 부분에 공백으로 구분되는 문자열을 지정하거나, 클래스 이름이 키(key)이고 지정 여부가 값(value)인 형태의 객체를 지정합니다.\n객체를 지정하는 방식을 사용하면 엘리먼트에 원하는 CSS 클래스만 지정하기 편합니다.</p>\n<p>이 때 객체는 <code>object</code>나 <code>Array</code>, <code>Map</code>, <code>Set</code> 등의 형식을 사용할 수 있는데, CSS 클래스가 제대로 지정되려면 이 객체 자체가 변경되어야 합니다.\n객체는 그대로이고 프로퍼티 값만 변경되는 경우는 제대로 동작하지 않을 수 있습니다.</p>\n<p>같은 클래스 이름이 동시에 사용되어 충돌하는 경우라면 <a href=\"guide/template-syntax#styling-precedence\">스타일 적용 우선순위</a> 섹션을 참고하세요.</p>\n<style>\n  td, th {vertical-align: top}\n</style>\n<table width=\"100%\">\n  <colgroup><col width=\"15%\">\n  \n  <col width=\"20%\">\n  \n  <col width=\"35%\">\n  \n  <col width=\"30%\">\n  \n  </colgroup><tbody><tr>\n    <th>\n      <!--\n      Binding Type\n      -->\n      바인딩 타입\n    </th>\n    <th>\n      <!--\n      Syntax\n      -->\n      문법\n    </th>\n    <th>\n      <!--\n      Input Type\n      -->\n      입력값 타입\n    </th>\n    <th>\n      <!--\n      Example Input Values\n      -->\n      사용할 수 있는 값\n    </th>\n  </tr>\n  <tr>\n    <!--\n    <td>Single class binding</td>\n    -->\n    <td>단일 클래스 바인딩</td>\n    <td><code>[class.foo]=\"hasFoo\"</code></td>\n    <td><code>boolean | undefined | null</code></td>\n    <td><code>true</code>, <code>false</code></td>\n  </tr>\n  <tr>\n    <!--\n    <td rowspan=3>Multi-class binding</td>\n    -->\n    <td rowspan=\"3\">여러 클래스 바인딩</td>\n    <td rowspan=\"3\"><code>[class]=\"classExpr\"</code></td>\n    <td><code>string</code></td>\n    <td><code>\"my-class-1 my-class-2 my-class-3\"</code></td>\n  </tr>\n  <tr>\n    <td><code>{[key: string]: boolean | undefined | null}</code></td>\n    <td><code>{foo: true, bar: false}</code></td>\n  </tr>\n  <tr>\n    <td><code>Array</code>&#x3C;<code>string</code>></td>\n    <td><code>['foo', 'bar']</code></td>\n  </tr>\n</tbody></table>\n<!--\nThe [NgClass](#ngclass) directive can be used as an alternative to direct `[class]` bindings. \nHowever, using the above class binding syntax without `NgClass` is preferred because due to improvements in class binding in Angular, `NgClass` no longer provides significant value, and might eventually be removed in the future.\n-->\n<p><code>[class]</code>를 직접 바인딩하는 방식 외에 <a href=\"guide/template-syntax#ngclass\">NgClass</a> 디렉티브를 사용하는 방식도 고려해 볼 만 합니다.\n하지만 Angular 차원에서 클래스 바인딩 방식의 개선을 고려하고 있기 때문에 <code>[class]</code>를 직접 바인딩하는 방식도 나쁜 것은 아닙니다.\n<code><a href=\"api/common/NgClass\" class=\"code-anchor\">NgClass</a></code> 디렉티브를 아예 없애는 것도 고려하고 있습니다.</p>\n<hr>\n<a id=\"style-binding\"></a>\n<!--\n### Style binding\n-->\n<h3 id=\"스타일-바인딩\">스타일 바인딩<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#스타일-바인딩\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nHere's how to set the `style` attribute without a binding in plain HTML:\n\n```html\n<!- standard style attribute setting ->\n<div style=\"color: blue\">Some text</div>\n```\n\nYou can also set styles dynamically with a **style binding**.\n\nTo create a single style binding, start with the prefix `style` followed by a dot (`.`) and the name of the CSS style property (for example, `[style.width]=\"width\"`). \nThe property will be set to the value of the bound expression, which is normally a string.\nOptionally, you can add a unit extension like `em` or `%`, which requires a number type.\n\n<div class=\"alert is-helpful\">\n\nNote that a _style property_ name can be written in either\n[dash-case](guide/glossary#dash-case), as shown above, or\n[camelCase](guide/glossary#camelcase), such as `fontSize`.\n\n</div>\n\nIf there are multiple styles you'd like to toggle, you can bind to the `[style]` property directly without the dot (for example, `[style]=\"styleExpr\"`).\nThe expression attached to the `[style]` binding is most often a string list of styles like `\"width: 100px; height: 100px;\"`. \n\nYou can also format the expression as an object with style names as the keys and style values as the values, like `{width: '100px', height: '100px'}`. \nIt's important to note that with any object-like expression (`object`, `Array`, `Map`, `Set`, etc), the identity of the object must change for the class list to be updated.\nUpdating the property without changing object identity will have no effect.\n\nIf there are multiple bindings to the same style property, conflicts are resolved using [styling precedence rules](#styling-precedence).\n-->\n<p>바인딩을 사용하지 않고 문자열로 <code><a href=\"api/animations/style\" class=\"code-anchor\">style</a></code> 어트리뷰트를 지정하려면 다음과 같이 작성하면 됩니다:</p>\n<code-example language=\"html\">\n&#x3C;!-- 일반적인 스타일 어트리뷰트 설정 방법 -->\n&#x3C;div <a href=\"api/animations/style\" class=\"code-anchor\">style</a>=\"color: blue\">Some text&#x3C;/div>\n</code-example>\n<p>여기에 동적으로 스타일을 지정하려면 <strong>스타일 바인딩</strong>을 사용하면 됩니다.</p>\n<p>스타일 하나를 바인딩하려면 <code><a href=\"api/animations/style\" class=\"code-anchor\">style</a></code>이라는 접미사 뒤에 <code>.</code> 문자를 붙이고 원하는 CSS 스타일 프로퍼티의 이름을 지정해서 <code>[style.width]=\"width\"</code>와 같이 작성하면 됩니다.\n그러면 바인딩 표현식의 결과값으로 프로퍼티 값이 지정되며, 이 값은 일반적으로 문자열입니다.\n<code>em</code>이나 <code>%</code>와 같은 단위를 명시한다면 숫자 타입을 사용할 수도 있습니다.</p>\n<div class=\"alert is-helpful\">\n<p><em>스타일 프로퍼티</em> 이름은 <a href=\"guide/glossary#dash-case\">대시 케이스(dash-case)</a>일 수도 있고 <code>fontSize</code>와 같이 <a href=\"guide/glossary#camelcase\">캐멀 케이스(camelCase)</a>일 수도 있습니다.</p>\n</div>\n<p>스타일 여러개를 동시에 바인딩하려면 접미사와 <code>.</code> 문자 없이 <code>[<a href=\"api/animations/style\" class=\"code-anchor\">style</a>]</code> 프로퍼티를 직접 바인딩하는 방식을 사용할 수 있습니다.\n이 방식은 <code>[<a href=\"api/animations/style\" class=\"code-anchor\">style</a>]=\"스타일<a href=\"\" class=\"code-anchor\">_</a>표현식\"</code>과 같이 작성하는데, 이때 스타일 표현식은 일반적으로 <code>\"width: 100px; height: 100px;\"</code>과 같은 형식의 문자열로 지정합니다.</p>\n<p>문자열 방식 외에도 스타일 이름을 키(key)로 하고 원하는 값을 지정하는 객체형식(<code>{width: '100px', height: '100px'}</code>)도 사용할 수 있습니다.\n이 때 객체는 <code>object</code>나 <code>Array</code>, <code>Map</code>, <code>Set</code> 등의 형식을 사용할 수 있는데, CSS 클래스가 제대로 지정되려면 이 객체 자체가 변경되어야 합니다.\n객체는 그대로이고 프로퍼티 값만 변경되는 경우는 제대로 동작하지 않을 수 있습니다.</p>\n<p>같은 스타일 프로퍼티가 동시에 사용되어 충돌하는 경우라면 <a href=\"guide/template-syntax#styling-precedence\">스타일 적용 우선순위</a> 섹션을 참고하세요.</p>\n<style>\n  td, th {vertical-align: top}\n</style>\n<table width=\"100%\">\n  <colgroup><col width=\"15%\">\n  \n  <col width=\"20%\">\n  \n  <col width=\"35%\">\n  \n  <col width=\"30%\">\n  \n  </colgroup><tbody><tr>\n    <th>\n      <!--\n      Binding Type\n      -->\n      바인딩 타입\n    </th>\n    <th>\n      <!--\n      Syntax\n      -->\n      문법\n    </th>\n    <th>\n      <!--\n      Input Type\n      -->\n      입력값 타입\n    </th>\n    <th>\n      <!--\n      Example Input Values\n      -->\n      사용할 수 있는 값\n    </th>\n  </tr>\n  <tr>\n    <!--\n    <td>Single style binding</td>\n    -->\n    <td>단일 스타일 바인딩</td>\n    <td><code>[style.width]=\"width\"</code></td>\n    <td><code>string | undefined | null</code></td>\n    <td><code>\"100px\"</code></td>\n  </tr>\n  <tr>\n  </tr><tr>\n  \t<!--\n    <td>Single style binding with units</td>\n    -->\n    <td>단위와 함께 사용하는 단일 스타일 바인딩</td>\n    <td><code>[style.width.px]=\"width\"</code></td>\n    <td><code>number | undefined | null</code></td>\n    <td><code>100</code></td>\n  </tr>\n    <tr>\n    <!--\n    <td rowspan=3>Multi-style binding</td>\n    -->\n    <td rowspan=\"3\">여러 스탕리 바인딩</td>\n    <td rowspan=\"3\"><code>[<a href=\"api/animations/style\" class=\"code-anchor\">style</a>]=\"styleExpr\"</code></td>\n    <td><code>string</code></td>\n    <td><code>\"width: 100px; height: 100px\"</code></td>\n  </tr>\n  <tr>\n    <td><code>{[key: string]: string | undefined | null}</code></td>\n    <td><code>{width: '100px', height: '100px'}</code></td>\n  </tr>\n  <tr>\n    <td><code>Array</code>&#x3C;<code>string</code>></td>\n    <td><code>['width', '100px']</code></td>\n  </tr>\n</tbody></table>\n<!--\nThe [NgStyle](#ngstyle) directive can be used as an alternative to direct `[style]` bindings. \nHowever, using the above style binding syntax without `NgStyle` is preferred because due to improvements in style binding in Angular, `NgStyle` no longer provides significant value, and might eventually be removed in the future.\n-->\n<p><code>[<a href=\"api/animations/style\" class=\"code-anchor\">style</a>]</code>을 직접 바인딩하는 방식 외에 <a href=\"guide/template-syntax#ngstyle\">NgStyle</a> 디렉티브를 사용하는 방식도 고려해 볼 만 합니다.\n하지만 Angular 차원에서 스타일 바인딩 방식의 개선을 고려하고 있기 때문에 <code>[<a href=\"api/animations/style\" class=\"code-anchor\">style</a>]</code>를 직접 바인딩하는 방식도 나쁜 것은 아닙니다.\n<code><a href=\"api/common/NgStyle\" class=\"code-anchor\">NgStyle</a></code> 디렉티브를 아예 없애는 것도 고려하고 있습니다.</p>\n<hr>\n<a id=\"styling-precedence\"></a>\n<!--\n### Styling Precedence\n-->\n<h3 id=\"스타일-적용-우선순위\">스타일 적용 우선순위<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#스타일-적용-우선순위\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nA single HTML element can have its CSS class list and style values bound to multiple sources (for example, host bindings from multiple directives).\n\nWhen there are multiple bindings to the same class name or style property, Angular uses a set of precedence rules to resolve conflicts and determine which classes or styles are ultimately applied to the element.\n\n<div class=\"alert is-helpful\">\n<h4>Styling precedence (highest to lowest)</h4>\n\n1. Template bindings\n    1. Property binding (for example, `<div [class.foo]=\"hasFoo\">` or `<div [style.color]=\"color\">`)\n    1. Map binding (for example, `<div [class]=\"classExpr\">` or `<div [style]=\"styleExpr\">`)\n    1. Static value (for example, `<div class=\"foo\">` or `<div style=\"color: blue\">`) \n1. Directive host bindings\n    1. Property binding (for example, `host: {'[class.foo]': 'hasFoo'}` or `host: {'[style.color]': 'color'}`)\n    1. Map binding (for example, `host: {'[class]': 'classExpr'}` or `host: {'[style]': 'styleExpr'}`)\n    1. Static value (for example, `host: {'class': 'foo'}` or `host: {'style': 'color: blue'}`)    \n1. Component host bindings\n    1. Property binding (for example, `host: {'[class.foo]': 'hasFoo'}` or `host: {'[style.color]': 'color'}`)\n    1. Map binding (for example, `host: {'[class]': 'classExpr'}` or `host: {'[style]': 'styleExpr'}`)\n    1. Static value (for example, `host: {'class': 'foo'}` or `host: {'style': 'color: blue'}`)    \n\n</div>\n\nThe more specific a class or style binding is, the higher its precedence.\n\nA binding to a specific class (for example, `[class.foo]`) will take precedence over a generic `[class]` binding, and a binding to a specific style (for example, `[style.bar]`) will take precedence over a generic `[style]` binding.\n\n<code-example path=\"attribute-binding/src/app/app.component.html\" region=\"basic-specificity\" header=\"src/app/app.component.html\">\n&lt;h3&gt;기본 순서&lt;/h3&gt;\n\n&lt;!-- `class.special`이 `class`보다 우선순위가 높습니다.  --&gt;\n&lt;div [class.special]=&quot;isSpecial&quot; [class]=&quot;classExpr&quot;&gt;Some text.&lt;/div&gt;\n\n&lt;!-- `style.color`가 `style`보다 우선순위가 높습니다.  --&gt;\n&lt;div [style.color]=&quot;color&quot; [style]=&quot;styleExpr&quot;&gt;Some text.&lt;/div&gt;\n\n</code-example>\n\nSpecificity rules also apply when it comes to bindings that originate from different sources. \nIt's possible for an element to have bindings in the template where it's declared, from host bindings on matched directives, and from host bindings on matched components.\n\nTemplate bindings are the most specific because they apply to the element directly and exclusively, so they have the highest precedence.\n\nDirective host bindings are considered less specific because directives can be used in multiple locations, so they have a lower precedence than template bindings.\n\nDirectives often augment component behavior, so host bindings from components have the lowest precedence. \n\n<code-example path=\"attribute-binding/src/app/app.component.html\" region=\"source-specificity\" header=\"src/app/app.component.html\">\n&lt;h3&gt;소스별 우선순위&lt;/h3&gt;\n\n&lt;!-- `dirWithClassBinding`이나 `comp-with-host-binding`보다 `class.special` 템플릿 바인딩의 우선순위가 더 높습니다. --&gt;\n&lt;comp-with-host-binding [class.special]=&quot;isSpecial&quot; dirWithClassBinding&gt;Some text.&lt;/comp-with-host-binding&gt;\n\n&lt;!-- `dirWithStyleBinding`이나 `comp-with-host-binding`보다 `style.color` 템플릿 바인딩의 우선순위가 더 높습니다. --&gt;\n&lt;comp-with-host-binding [style.color]=&quot;color&quot; dirWithStyleBinding&gt;Some text.&lt;/comp-with-host-binding&gt;\n\n</code-example>\n\nIn addition, bindings take precedence over static attributes. \n\nIn the following case, `class` and `[class]` have similar specificity, but the `[class]` binding will take precedence because it is dynamic.\n\n<code-example path=\"attribute-binding/src/app/app.component.html\" region=\"dynamic-priority\" header=\"src/app/app.component.html\">\n&lt;h3&gt;동적 vs 정적&lt;/h3&gt;\n\n&lt;!-- `classExpr`이 동적으로 처리되기 때문에 `class`보다 우선순위가 높습니다. --&gt;\n&lt;div class=&quot;special&quot; [class]=&quot;classExpr&quot;&gt;Some text.&lt;/div&gt;\n\n&lt;!-- `styleExpr`이 동적으로 처리되기 때문에 `style`보다 우선순위가 높습니다. --&gt;\n&lt;div style=&quot;color: blue&quot; [style]=&quot;styleExpr&quot;&gt;Some text.&lt;/div&gt;\n\n\n</code-example>\n-->\n<p>HTML 엘리먼트는 CSS 클래스와 스타일 값을 여러개 가질 수 있습니다. 클래스나 스타일을 지정하는 디렉티브가 여러개 적용된 경우도 마찬가지입니다.</p>\n<p>그런데 같은 클래스 이름이나 스타일 프로퍼티가 동시에 바인딩되면 충돌이 발생할 수 있는데 Angular는 이 충돌을 발생하기 위해 우선순위를 마련해두었습니다.</p>\n<div class=\"alert is-helpful\">\n<h4 id=\"스타일-적용-우선순위-높은-것부터-낮은-순으로\">스타일 적용 우선순위 (높은 것부터 낮은 순으로)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#스타일-적용-우선순위-높은-것부터-낮은-순으로\"><i class=\"material-icons\">link</i></a></h4>\n<ol>\n<li>\n<p>템플릿 바인딩</p>\n<ol>\n<li>프로퍼티 바인딩 (ex. <code>&#x3C;div [class.foo]=\"hasFoo\"></code>, <code>&#x3C;div [style.color]=\"color\"></code>)</li>\n<li>Map 바인딩 (ex. <code>&#x3C;div [class]=\"classExpr\"></code>, <code>&#x3C;div [<a href=\"api/animations/style\" class=\"code-anchor\">style</a>]=\"styleExpr\"></code>)</li>\n<li>정적 바인딩 (ex. <code>&#x3C;div class=\"foo\"></code>, <code>&#x3C;div <a href=\"api/animations/style\" class=\"code-anchor\">style</a>=\"color: blue\"></code>) </li>\n</ol>\n</li>\n<li>\n<p>디렉티브 호스트 바인딩</p>\n<ol>\n<li>프로퍼티 바인딩 (ex. <code><a href=\"api/core/Directive#host\" class=\"code-anchor\">host</a>: {'[class.foo]': 'hasFoo'}</code>, <code><a href=\"api/core/Directive#host\" class=\"code-anchor\">host</a>: {'[style.color]': 'color'}</code>)</li>\n<li>Map 바인딩 (ex. <code><a href=\"api/core/Directive#host\" class=\"code-anchor\">host</a>: {'[class]': 'classExpr'}</code>, <code><a href=\"api/core/Directive#host\" class=\"code-anchor\">host</a>: {'[<a href=\"api/animations/style\" class=\"code-anchor\">style</a>]': 'styleExpr'}</code>)</li>\n<li>정적 바인딩 (ex. <code><a href=\"api/core/Directive#host\" class=\"code-anchor\">host</a>: {'class': 'foo'}</code>, <code><a href=\"api/core/Directive#host\" class=\"code-anchor\">host</a>: {'<a href=\"api/animations/style\" class=\"code-anchor\">style</a>': 'color: blue'}</code>)    </li>\n</ol>\n</li>\n<li>\n<p>컴포넌트 호스트 바인딩</p>\n<ol>\n<li>프로퍼티 바인딩 (ex. <code><a href=\"api/core/Directive#host\" class=\"code-anchor\">host</a>: {'[class.foo]': 'hasFoo'}</code>, <code><a href=\"api/core/Directive#host\" class=\"code-anchor\">host</a>: {'[style.color]': 'color'}</code>)</li>\n<li>Map 바인딩 (ex. <code><a href=\"api/core/Directive#host\" class=\"code-anchor\">host</a>: {'[class]': 'classExpr'}</code>, <code><a href=\"api/core/Directive#host\" class=\"code-anchor\">host</a>: {'[<a href=\"api/animations/style\" class=\"code-anchor\">style</a>]': 'styleExpr'}</code>)</li>\n<li>정적 바인딩 (ex. <code><a href=\"api/core/Directive#host\" class=\"code-anchor\">host</a>: {'class': 'foo'}</code>, <code><a href=\"api/core/Directive#host\" class=\"code-anchor\">host</a>: {'<a href=\"api/animations/style\" class=\"code-anchor\">style</a>': 'color: blue'}</code>)    </li>\n</ol>\n</li>\n</ol>\n</div>\n<p>더 구체적으로 지정하는 클래스와 스타일 바인딩의 우선순위가 더 높습니다.</p>\n<p>그래서 <code>[class.foo]</code>처럼 바인딩하는 방식이 <code>[class]</code>를 바인딩하는 것보다 우선순위가 높고, <code>[style.bar]</code>처럼 바인딩하는 방식이 <code>[<a href=\"api/animations/style\" class=\"code-anchor\">style</a>]</code>을 바인딩하는 것보다 우선순위가 높습니다.</p>\n<code-example path=\"attribute-binding/src/app/app.component.html\" region=\"basic-specificity\" header=\"src/app/app.component.html\">\n&#x3C;h3>기본 순서&#x3C;/h3>\n\n&#x3C;!-- `class.special`이 `class`보다 우선순위가 높습니다.  -->\n&#x3C;div [class.special]=\"isSpecial\" [class]=\"classExpr\">Some text.&#x3C;/div>\n\n&#x3C;!-- `style.color`가 `<a href=\"api/animations/style\" class=\"code-anchor\">style</a>`보다 우선순위가 높습니다.  -->\n&#x3C;div [style.color]=\"color\" [<a href=\"api/animations/style\" class=\"code-anchor\">style</a>]=\"styleExpr\">Some text.&#x3C;/div>\n\n</code-example>\n<p>이 규칙은 클래스나 스타일을 지정하는 소스가 다른 경우에도 마찬가지입니다.\n그래서 템플릿에서 직접 지정한 것보다 디렉티브로 호스트 바인딩한 스타일이 적용될 수도 있습니다.</p>\n<p>하지만 일반적으로는 템플릿에서 직접 바인딩할 때 가장 구체적인 규칙을 사용하기 때문에 대부분의 경우 템플릿 바인딩의 우선순위가 가장 높습니다.</p>\n<p>그리고 디렉티브로 바인딩할 때는 이 디렉티브가 여러 곳에서 다른 방식으로 사용될 수 있기 때문에 템플릿 바인딩에 비하면 우선순위가 낮을 수 있습니다.</p>\n<p>디렉티브는 컴포넌트의 동작을 확장하는 용도로 하는 것이 주목적이기 때문에 이 방식의 우선순위가 가장 낮습니다.</p>\n<code-example path=\"attribute-binding/src/app/app.component.html\" region=\"source-specificity\" header=\"src/app/app.component.html\">\n&#x3C;h3>소스별 우선순위&#x3C;/h3>\n\n&#x3C;!-- `dirWithClassBinding`이나 `comp-with-host-binding`보다 `class.special` 템플릿 바인딩의 우선순위가 더 높습니다. -->\n&#x3C;comp-with-host-binding [class.special]=\"isSpecial\" dirWithClassBinding>Some text.&#x3C;/comp-with-host-binding>\n\n&#x3C;!-- `dirWithStyleBinding`이나 `comp-with-host-binding`보다 `style.color` 템플릿 바인딩의 우선순위가 더 높습니다. -->\n&#x3C;comp-with-host-binding [style.color]=\"color\" dirWithStyleBinding>Some text.&#x3C;/comp-with-host-binding>\n\n</code-example>\n<p>클래스나 스타일을 바인딩하면 정적 어트리뷰트로 지정한 것보다 우선순위가 높습니다.</p>\n<p>아래 예제에서 <code>class</code>와 <code>[class]</code>를 사용한 것은 비슷해보이지만 <code>[class]</code>는 정적인 규칙이 적용된 이후에 동적으로 적용되기 때문에 우선순위가 더 높습니다.</p>\n<code-example path=\"attribute-binding/src/app/app.component.html\" region=\"dynamic-priority\" header=\"src/app/app.component.html\">\n&#x3C;h3>동적 vs 정적&#x3C;/h3>\n\n&#x3C;!-- `classExpr`이 동적으로 처리되기 때문에 `class`보다 우선순위가 높습니다. -->\n&#x3C;div class=\"special\" [class]=\"classExpr\">Some text.&#x3C;/div>\n\n&#x3C;!-- `styleExpr`이 동적으로 처리되기 때문에 `<a href=\"api/animations/style\" class=\"code-anchor\">style</a>`보다 우선순위가 높습니다. -->\n&#x3C;div <a href=\"api/animations/style\" class=\"code-anchor\">style</a>=\"color: blue\" [<a href=\"api/animations/style\" class=\"code-anchor\">style</a>]=\"styleExpr\">Some text.&#x3C;/div>\n\n\n</code-example>\n<a id=\"styling-delegation\"></a>\n<!--\n### Delegating to styles with lower precedence\n-->\n<h3 id=\"낮은-우선순위로-위임될-때\">낮은 우선순위로 위임될 때<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#낮은-우선순위로-위임될-때\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIt is possible for higher precedence styles to \"delegate\" to lower precedence styles using `undefined` values.\nWhereas setting a style property to `null` ensures the style is removed, setting it to `undefined` will cause Angular to fall back to the next-highest precedence binding to that style.\n\nFor example, consider the following template: \n\n<code-example path=\"attribute-binding/src/app/app.component.html\" region=\"style-delegation\" header=\"src/app/app.component.html\">\n&lt;comp-with-host-binding dirWithHostBinding&gt;&lt;/comp-with-host-binding&gt;\n\n</code-example>\n\nImagine that the `dirWithHostBinding` directive and the `comp-with-host-binding` component both have a `[style.width]` host binding.\nIn that case, if `dirWithHostBinding` sets its binding to `undefined`, the `width` property will fall back to the value of the `comp-with-host-binding` host binding.\nHowever, if `dirWithHostBinding` sets its binding to `null`, the `width` property will be removed entirely.\n-->\n<p>클래스나 스타일 적용 우선순위가 높다고 해도 <code>undefined</code> 값이 바인딩 된 경우라면 낮은 우선순위가 적용될 수 있습니다.\n스타일 프로퍼티를 <code>null</code>로 지정하면 해당 스타일이 확실하게 제거되며, <code>undefined</code>로 지정하면 다음 우선순위로 넘어갑니다.</p>\n<p>예를 들어 다음과 같은 템플릿 코드가 있다고 합시다:</p>\n<code-example path=\"attribute-binding/src/app/app.component.html\" region=\"style-delegation\" header=\"src/app/app.component.html\">\n&#x3C;comp-with-host-binding dirWithHostBinding>&#x3C;/comp-with-host-binding>\n\n</code-example>\n<p><code>dirWithHostBinding</code> 디렉티브와 <code>comp-with-host-binding</code> 컴포넌트가 모두 <code>[style.width]</code>를 호스트 바인딩한다고 합시다.\n그런데 <code>dirWithHostBinding</code>에서 <code>width</code> 프로퍼티에 <code>undefined</code> 값을 바인딩하면 <code>comp-with-host-binding</code>에 있는 스타일이 적용됩니다.\n하지만 <code>dirWithHostBinding</code>에서 <code>width</code> 프로퍼티에 <code>null</code> 값을 바인딩하면 <code>width</code> 프로퍼티는 제거됩니다.</p>\n<a id=\"event-binding\"></a>\n<!--\n## Event binding `(event)`\n-->\n<h2 id=\"이벤트-바인딩-event\">이벤트 바인딩 <code>(event)</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#이벤트-바인딩-event\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nEvent binding allows you to listen for certain events such as\nkeystrokes, mouse movements, clicks, and touches. For an example\ndemonstrating all of the points in this section, see the <live-example name=\"event-binding\">event binding example</live-example>.\n\nAngular event binding syntax consists of a **target event** name\nwithin parentheses on the left of an equal sign, and a quoted\ntemplate statement on the right.\nThe following event binding listens for the button's click events, calling\nthe component's `onSave()` method whenever a click occurs:\n-->\n<p>이벤트 바인딩 문법을 사용하면 키 입력이나 마우스의 움직임, 클릭이나 터치 이벤트를 감지할 수 있습니다.\n이 섹션에서 설명하는 내용은 <live-example name=\"event-binding\">이벤트 바인딩 예제</live-example> 에서 직접 확인할 수 있습니다.</p>\n<p>이벤트 바인딩은 <strong>대상 이벤트</strong> 이름을 괄호(<code>(</code>, <code>)</code>)로 감싸고 템플릿 실행문을 등호로 연결해서 작성합니다.\n예를 들어 버튼의 클릭 이벤트를 감지하고 있다가 사용자가 버튼을 클릭할 때 컴포넌트에 있는 <code>onSave()</code> 메소드를 실행하려면 다음과 같이 구현합니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/template-syntax/syntax-diagram.svg\" alt=\"Syntax diagram\" width=\"600\" height=\"125\">\n</div>\n<!--\n### Target event\n-->\n<h3 id=\"대상-이벤트\">대상 이벤트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#대상-이벤트\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAs above, the target is the button's click event.\n-->\n<p>위에서 언급한 것처럼, 대상 이벤트는 버튼 클릭 이벤트입니다.</p>\n<code-example path=\"event-binding/src/app/app.component.html\" region=\"event-binding-1\" header=\"src/app/app.component.html\">\n&#x3C;button (click)=\"onSave($event)\">Save&#x3C;/button>\n\n</code-example>\n<!--\nAlternatively, use the `on-` prefix, known as the canonical form:\n-->\n<p>이 방식이 익숙하지 않다면 다음과 같이 <code>on-</code> 접두사를 사용할 수도 있습니다.</p>\n<code-example path=\"event-binding/src/app/app.component.html\" region=\"event-binding-2\" header=\"src/app/app.component.html\">\n&#x3C;button on-click=\"onSave($event)\">on-click Save&#x3C;/button>\n\n</code-example>\n<!--\nElement events may be the more common targets, but Angular looks first to see if the name matches an event property\nof a known directive, as it does in the following example:\n-->\n<p>엘리먼트에서 발생하는 이벤트는 HTML 스펙에 정의된 이벤트인 경우가 대부분입니다. 하지만 커스텀 이벤트가 정의되어 있다면 그 이벤트도 같은 방식으로 사용할 수 있습니다. 커스텀 이벤트의 이름이 일반 이벤트 이름과 겹치면 커스텀 이벤트의 우선순위가 더 높습니다:</p>\n<code-example path=\"event-binding/src/app/app.component.html\" region=\"custom-directive\" header=\"src/app/app.component.html\">\n&#x3C;h4>myClick is an event on the custom ClickDirective:&#x3C;/h4>\n&#x3C;button (myClick)=\"clickMessage=$event\" clickable>click with myClick&#x3C;/button>\n{{clickMessage}}\n\n</code-example>\n<!--\nIf the name fails to match an element event or an output property of a known directive,\nAngular reports an “unknown directive” error.\n-->\n<p>그리고 엘리먼트 이벤트나 커스텀 디렉티브에서 해당되는 이벤트 이름을 찾지 못하면 “unknown directive” 에러가 발생합니다.</p>\n<!--\n### *$event* and event handling statements\n-->\n<h3 id=\"event-객체와-이벤트-처리-실행문\"><em>$event</em> 객체와 이벤트 처리 실행문<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#event-객체와-이벤트-처리-실행문\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn an event binding, Angular sets up an event handler for the target event.\n-->\n<p>이벤트를 바인딩하면 Angular의 이벤트 처리 함수가 대상 이벤트와 연결됩니다.</p>\n<!--\nWhen the event is raised, the handler executes the template statement.\nThe template statement typically involves a receiver, which performs an action\nin response to the event, such as storing a value from the HTML control\ninto a model.\n-->\n<p>그러면 이벤트가 발생했을 때 Angular 프레임워크의 이벤트 처리 함수가 템플릿 실행문을 실행하는데,\n이 템플릿 실행문을 사용해서 원하는 동작을 실행할 수 있습니다.</p>\n<!--\nThe binding conveys information about the event. This information can include data values such as an event object, string, or number named `$event`.\n\nThe target event determines the shape of the `$event` object.\nIf the target event is a native DOM element event, then `$event` is a\n[DOM event object](https://developer.mozilla.org/en-US/docs/Web/Events),\nwith properties such as `target` and `target.value`.\n-->\n<p>이 때 템플릿 실행문에는 이벤트에 대한 정보와 이벤트가 발생한 HTML 컨트롤에 대한 정보가 <code>$event</code> 라는 객체에 담겨 전달됩니다.\n그리고 이 정보는 <code>$event</code>라는 이름으로 뭉뚱그려지기는 했지만 객체가 될 수도 있고 문자열이나 숫자가 될 수도 있습니다.</p>\n<p><code>$event</code> 객체의 타입은 이벤트가 어떤것이냐에 따라 달라집니다.\n대상 이벤트가 네이티브 DOM 엘리먼트의 이벤트라면 <code>$envet</code> 객체는 <a href=\"https://developer.mozilla.org/en-US/docs/Web/Events\">DOM 이벤트 객체</a>이며, 이 객체에서 <code><a href=\"api/router/RouterLinkWithHref#target\" class=\"code-anchor\">target</a></code> 프로퍼티나 <code>target.value</code> 값을 참조할 수 있습니다.</p>\n<!--\nConsider this example:\n-->\n<p>다음 예제를 봅시다:</p>\n<code-example path=\"event-binding/src/app/app.component.html\" region=\"event-binding-3\" header=\"src/app/app.component.html\">\n&#x3C;input [value]=\"currentItem.name\"\n       (input)=\"currentItem.name=$event.target.value\" >\nwithout <a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a>\n\n</code-example>\n<!--\nThis code sets the `<input>` `value` property by binding to the `name` property.\nTo listen for changes to the value, the code binds to the `input`\nevent of the `<input>` element.\nWhen the user makes changes, the `input` event is raised, and the binding executes\nthe statement within a context that includes the DOM event object, `$event`.\n-->\n<p>이 코드에서는 <code>currentHero.name</code> 프로퍼티를 <code>&#x3C;input></code> 엘리먼트의 <code>value</code> 프로퍼티로 바인딩하면서 초기값을 지정합니다.\n그리고 값이 변경되는 것을 감지하기 위해 <code>&#x3C;input></code> 엘리먼트의 <code>input</code> 이벤트를 바인딩합니다.\n사용자가 입력 필드의 값을 변경하면 <code>input</code> 이벤트가 발생하고 이 이벤트에 연결된 템플릿 실행문이 실행되는데, 이 때 DOM 이벤트 객체가 <code>$event</code> 객체로 템플릿 실행문에 전달됩니다.</p>\n<!--\nTo update the `name` property, the changed text is retrieved by following the path `$event.target.value`.\n-->\n<p>그리고 이벤트 객체에서 값을 참조해서 <code>name</code> 프로퍼티 값을 다시 지정하기 위해 템플릿 실행문을 <code>$event.target.value</code> 와 같이 작성했습니다.</p>\n<!--\nIf the event belongs to a directive&mdash;recall that components\nare directives&mdash;`$event` has whatever shape the directive produces.\n-->\n<p>대상 이벤트가 DOM 엘리먼트의 이벤트가 아니고 커스텀 디렉티브(컴포넌트)에서 정의하는 이벤트라면, <code>$event</code> 객체는 해당 디렉티브에서 정의하는 대로 자유로운 형식이 될 수 있습니다.</p>\n<!--\n### Custom events with `EventEmitter`\n-->\n<a id=\"custom-events-with-eventemitter\"></a>\n<h3 id=\"eventemitter로-커스텀-이벤트-보내기\"><code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code>로 커스텀 이벤트 보내기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#eventemitter로-커스텀-이벤트-보내기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nDirectives typically raise custom events with an Angular [EventEmitter](api/core/EventEmitter).\nThe directive creates an `EventEmitter` and exposes it as a property.\nThe directive calls `EventEmitter.emit(payload)` to fire an event, passing in a message payload, which can be anything.\nParent directives listen for the event by binding to this property and accessing the payload through the `$event` object.\n-->\n<p>Angular에서 제공하는 <a href=\"api/core/EventEmitter\">EventEmitter</a>를 사용하면 커스텀 이벤트를 만들 수 있습니다.\n우선, 디렉티브에 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 타입의 프로퍼티를 선언하고 이 프로퍼티를 디렉티브 외부로 열어줍니다.\n그런 뒤 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 객체의 <code>emit(데이터)</code> 함수를 실행하면 데이터가 <code>$event</code> 객체에 담겨 디렉티브 외부로 전달됩니다.\n부모 디렉티브에서는 자식 디렉티브의 이벤트 프로퍼티를 바인딩해서 이 커스텀 이벤트를 감지하고 있다가, 이벤트가 발생했을 때 <code>$event</code> 이벤트에 담긴 데이터를 받아서 처리하면 됩니다.</p>\n<!--\nConsider an `ItemDetailComponent` that presents item information and responds to user actions.\nAlthough the `ItemDetailComponent` has a delete button, it doesn't know how to delete the hero. It can only raise an event reporting the user's delete request.\n\nHere are the pertinent excerpts from that `ItemDetailComponent`:\n-->\n<p><code>ItemDetailComponent</code> 는 아이템을 화면에 표시하면서 사용자의 동작에도 반응해야 한다고 합시다.\n그런데 이 컴포넌트에 삭제 버튼이 있다고 해도 이 컴포넌트는 히어로를 어떻게 삭제하는지 알지 못합니다.\n이 동작을 구현하려면 사용자가 삭제 요청을 했을 때 이벤트를 발생시키고, 부모 컴포넌트에서 이 이벤트를 받아 처리하는 방법이 가장 좋습니다.</p>\n<p><code>ItemDetailComponent</code> 코드에서 관련된 부분을 봅시다:</p>\n<!--\n<code-example path=\"event-binding/src/app/item-detail/item-detail.component.html\" header=\"src/app/item-detail/item-detail.component.html (template)\" region=\"line-through\">\n&lt;img src=&quot;{{itemImageUrl}}&quot; [style.display]=&quot;displayNone&quot;&gt;\n&lt;span [style.text-decoration]=&quot;lineThrough&quot;&gt;{{ item.name }}\n&lt;/span&gt;\n&lt;button (click)=&quot;delete()&quot;&gt;Delete&lt;/button&gt;\n\n</code-example>\n-->\n<code-example path=\"event-binding/src/app/item-detail/item-detail.component.html\" header=\"src/app/item-detail/item-detail.component.html (템플릿)\" region=\"line-through\">\n&#x3C;img src=\"{{itemImageUrl}}\" [style.display]=\"displayNone\">\n&#x3C;span [style.text-decoration]=\"lineThrough\">{{ item.name }}\n&#x3C;/span>\n&#x3C;button (click)=\"delete()\">Delete&#x3C;/button>\n\n</code-example>\n<code-example path=\"event-binding/src/app/item-detail/item-detail.component.ts\" header=\"src/app/item-detail/item-detail.component.ts (deleteRequest)\" region=\"deleteRequest\">\n// 이 컴포넌트는 직접 히어로를 삭제하지 않고 히어로 삭제 요청을 보내기만 합니다.\n@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() deleteRequest = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;Item>();\n\ndelete() {\n  this.deleteRequest.emit(this.item);\n  this.displayNone = this.displayNone ? '' : 'none';\n  this.lineThrough = this.lineThrough ? '' : 'line-through';\n}\n\n</code-example>\n<!--\nThe component defines a `deleteRequest` property that returns an `EventEmitter`.\nWhen the user clicks *delete*, the component invokes the `delete()` method,\ntelling the `EventEmitter` to emit an `Item` object.\n\nNow imagine a hosting parent component that binds to the `deleteRequest` event\nof the `ItemDetailComponent`.\n-->\n<p>컴포넌트에는 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code>를 반환하는 <code>deleteRequest</code> 프로퍼티가 존재합니다.\n사용자가 <em>삭제</em> 버튼을 클릭하면 <code>delete()</code> 메소드를 실행하고,\n이 함수에서는 컴포넌트에 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 타입으로 선언한 <code>deleteRequest</code> 프로퍼티에 <code>Item</code> 객체를 담아 컴포넌트 외부로 보냅니다.</p>\n<p>그러면 부모 컴포넌트에서 이 이벤트를 받기 위해 <code>deleteRequest</code> 프로퍼티를 바인딩하고 있어야 합니다.</p>\n<!--\n<code-example path=\"event-binding/src/app/app.component.html\" header=\"src/app/app.component.html (event-binding-to-component)\" region=\"event-binding-to-component\">\n&lt;app-item-detail (deleteRequest)=&quot;deleteItem($event)&quot; [item]=&quot;currentItem&quot;&gt;&lt;/app-item-detail&gt;\n\n</code-example>\n-->\n<code-example path=\"event-binding/src/app/app.component.html\" header=\"src/app/app.component.html (부모 컴포넌트의 이벤트 바인딩)\" region=\"event-binding-to-component\">\n&#x3C;app-item-detail (deleteRequest)=\"deleteItem($event)\" [<a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>]=\"currentItem\">&#x3C;/app-item-detail>\n\n</code-example>\n<!--\nWhen the `deleteRequest` event fires, Angular calls the parent component's\n`deleteItem()` method, passing the *item-to-delete* (emitted by `ItemDetail`)\nin the `$event` variable.\n-->\n<p>최종적으로 <code>deleteRequest</code> 이벤트가 발생하면 Angular는 부모 컴포넌트의 <code>deleteItem()</code> 메소드를 실행하면서\n(<code>ItemDetail</code>에서 보낸) <em>삭제해야 할 아이템</em>에 대한 정보를 <code>$event</code> 변수에 담아 전달합니다.</p>\n<!--\n### Template statements have side effects\n-->\n<h3 id=\"템플릿-실행문의-영향\">템플릿 실행문의 영향<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#템플릿-실행문의-영향\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThough [template expressions](guide/template-syntax#template-expressions) shouldn't have [side effects](guide/template-syntax#avoid-side-effects), template\nstatements usually do. The `deleteItem()` method does have\na side effect: it deletes an item.\n\nDeleting an item updates the model, and depending on your code, triggers\nother changes including queries and saving to a remote server.\nThese changes propagate through the system and ultimately display in this and other views.\n-->\n<p><a href=\"guide/template-syntax#template-expressions\">템플릿 표현식</a>은 실행되더라도 <a href=\"guide/template-syntax#avoid-side-effects\">사이드 이펙트</a>가 없지만, 템플릿 실행문은 사이드 이펙트를 유발할 수 있습니다. 예를 들어 <code>deleteItem()</code> 메소드를 실행하면 목록에서 항목이 하나 제거되는 것도 사이드 이펙트로 볼 수 있습니다.</p>\n<p>예제 코드로 보면, 아이템을 삭제하면 모델이 업데이트 되면서 서버에 새로운 목록을 요청하거나 삭제 요청을 보내는 등 다른 동작을 유발할 수 있습니다.\n이런 동작들은 뷰 데이터를 갱신하고 서버에 반영하면서 시스템을 자연스럽게 유지합니다.</p>\n<hr>\n<a id=\"two-way\"></a>\n<!--\n## Two-way binding `[(...)]`\n-->\n<h2 id=\"양방향-바인딩-\">양방향 바인딩 <code>[(...)]</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#양방향-바인딩-\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nTwo-way binding gives your app a way to share data between a component class and\nits template.\n\nFor a demonstration of the syntax and code snippets in this section, see the <live-example name=\"two-way-binding\">two-way binding example</live-example>.\n-->\n<p>양방향 바인딩(two-way binding)을 사용하면 컴포넌트 클래스와 템플릿이 서로 데이터를 주고받을 수 있습니다.</p>\n<p>이 섹션에서 설명하는 내용을 어떻게 동작하는지 확인하려면 <live-example name=\"two-way-binding\">양방향 바인딩 예제</live-example>를 참고하세요.</p>\n<!--\n### Basics of two-way binding\n-->\n<h3 id=\"양방향-바인딩-기본\">양방향 바인딩 기본<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#양방향-바인딩-기본\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nTwo-way binding does two things:\n\n1. Sets a specific element property.\n1. Listens for an element change event.\n\nAngular offers a special _two-way data binding_ syntax for this purpose, `[()]`.\nThe `[()]` syntax combines the brackets\nof property binding, `[]`, with the parentheses of event binding, `()`.\n-->\n<p>양방향 바인딩은 다음 두 가지 용도로 사용합니다:</p>\n<ol>\n<li>엘리먼트 프로퍼티의 값을 설정합니다.</li>\n<li>프로퍼티 값이 변경되는 이벤트를 감지합니다.</li>\n</ol>\n<p>Angular는 <em>양방향 데이터 바인딩</em> 에만 사용하는 <code>[()]</code> 문법을 제공합니다.\n<code>[()]</code>라는 문법은 프로퍼티 바인딩 문법 <code>[]</code>과 이벤트 바인딩 문법 <code>()</code>을 동시에 사용하는 형태입니다.</p>\n<div class=\"callout is-important\">\n<header>\n<!--\n  [( )] = banana in a box\n-->\n  [( )] = 상자 안에 든 바나나\n</header>\n<!--\nVisualize a *banana in a box* to remember that the parentheses go _inside_ the brackets.\n-->\n<p>두 괄호 중 어떤 괄호가 안에 들어가는지 헷갈린다면 <em>상자 안에 든 바나나</em> 의 모양을 떠올려 보세요.</p>\n</div>\n<!--\nThe `[()]` syntax is easy to demonstrate when the element has a settable\nproperty called `x` and a corresponding event named `xChange`.\nHere's a `SizerComponent` that fits this pattern.\nIt has a `size` value property and a companion `sizeChange` event:\n-->\n<p><code>[()]</code> 문법을 사용하면 컴포넌트에서 이름이 <code>x</code>인 프로퍼티가 프로퍼티 바인딩 되면서, 이벤트 이름이 <code>xChange</code>인 이벤트가 함께 이벤트 바인딩 됩니다.\n<code>SizerComponent</code> 예제를 보면서 이 내용을 확인해봅시다.\n이 컴포넌트에는 <code>size</code> 프로퍼티와 <code>sizeChange</code> 이벤트가 선언되어 있습니다.</p>\n<code-example path=\"two-way-binding/src/app/sizer/sizer.component.ts\" header=\"src/app/sizer.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/Output\" class=\"code-anchor\">Output</a>, <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-sizer',\n  <a href=\"api/core/Component#templateUrl\" class=\"code-anchor\">templateUrl</a>: './sizer.component.html',\n  <a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a>: ['./sizer.component.css']\n})\nexport class SizerComponent {\n\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()  size: number | string;\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() sizeChange = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;number>();\n\n  dec() { this.resize(-1); }\n  inc() { this.resize(+1); }\n\n  resize(delta: number) {\n    this.size = Math.min(40, Math.max(8, +this.size + delta));\n    this.sizeChange.emit(this.size);\n  }\n\n}\n\n\n</code-example>\n<code-example path=\"two-way-binding/src/app/sizer/sizer.component.html\" header=\"src/app/sizer.component.html\">\n&#x3C;div>\n  &#x3C;button (click)=\"dec()\" title=\"smaller\">-&#x3C;/button>\n  &#x3C;button (click)=\"inc()\" title=\"bigger\">+&#x3C;/button>\n  &#x3C;label [style.font-size.px]=\"size\">FontSize: {{size}}px&#x3C;/label>\n&#x3C;/div>\n\n\n</code-example>\n<!--\nThe initial `size` is an input value from a property binding.\nClicking the buttons increases or decreases the `size`, within\nmin/max value constraints,\nand then raises, or emits, the `sizeChange` event with the adjusted size.\n\nHere's an example in which the `AppComponent.fontSizePx` is two-way bound to the `SizerComponent`:\n-->\n<p>입력 프로퍼티 <code>size</code>의 초기값은 프로퍼티 바인딩에 의해 지정됩니다.\n그리고 증감 버튼을 누르면 최소/최대값의 범위에 따라 <code>size</code> 값이 변경됩니다.\n그리고 이때 변경된 값이 담긴 <code>sizeChange</code> 이벤트가 발생합니다.</p>\n<p>이 때 받은 커스텀 이벤트를 활용해서 <code>SizerComponent</code> 의 부모 컴포넌트인 <code>AppComponent</code>의 <code>fontSizePx</code> 프로퍼티를 양방향 바인딩으로 연결해 봅시다.</p>\n<code-example path=\"two-way-binding/src/app/app.component.html\" header=\"src/app/app.component.html (two-way-1)\" region=\"two-way-1\">\n&#x3C;app-sizer [(size)]=\"fontSizePx\">&#x3C;/app-sizer>\n&#x3C;div [style.font-size.px]=\"fontSizePx\">Resizable Text&#x3C;/div>\n\n</code-example>\n<!--\nThe `AppComponent.fontSizePx` establishes the initial `SizerComponent.size` value.\n-->\n<p><code>AppComponent</code>에서도 <code>fontSizePx</code> 프로퍼티의 초기값은 <code>SizerComponent.size</code> 값으로 초기화 됩니다.</p>\n<code-example path=\"two-way-binding/src/app/app.component.ts\" header=\"src/app/app.component.ts\" region=\"font-size\">\nfontSizePx = 16;\n\n</code-example>\n<!--\nClicking the buttons updates the `AppComponent.fontSizePx` via the two-way binding.\nThe revised `AppComponent.fontSizePx` value flows through to the _style_ binding,\nmaking the displayed text bigger or smaller.\n-->\n<p>그리고 증감 버튼을 누를때마다 <code>AppComponent.fontSizePx</code>값이 양방향 바인딩에 의해 갱신됩니다.\n이렇게 갱신된 <code>AppComponent.fontSizePx</code> 값은 <em>스타일</em> 바인딩으로 연결되면서, <code>Resizable Text</code>의 크기가 커지거나 작아집니다.</p>\n<!--\nThe two-way binding syntax is really just syntactic sugar for a _property_ binding and an _event_ binding.\nAngular desugars the `SizerComponent` binding into this:\n-->\n<p>엄밀히 얘기하면, 양방향 바인딩 문법은 <em>프로퍼티</em> 바인딩과 <em>이벤트</em> 바인딩을 하나로 묶어둔 문법 설탕(syntatic sugar)일 뿐입니다.\n프로퍼티 바인딩과 이벤트 바인딩을 각각 구현하려면 코드를 다음과 같이 작성합니다:</p>\n<code-example path=\"two-way-binding/src/app/app.component.html\" header=\"src/app/app.component.html (two-way-2)\" region=\"two-way-2\">\n&#x3C;app-sizer [size]=\"fontSizePx\" (sizeChange)=\"fontSizePx=$event\">&#x3C;/app-sizer>\n\n</code-example>\n<!--\nThe `$event` variable contains the payload of the `SizerComponent.sizeChange` event.\nAngular assigns the `$event` value to the `AppComponent.fontSizePx` when the user clicks the buttons.\n-->\n<p><code>$event</code> 객체에는 <code>SizeComponent.sizeChange</code> 이벤트에서 보내는 폰트 크기값이 담겨 있습니다.\n그래서 사용자가 증감 버튼을 클릭해서 이벤트가 발생할 때마다 <code>AppComponent.fontSizePx</code> 프로퍼티의 값을 새로운 값으로 할당하고 있습니다.</p>\n<!--\n### Two-way binding in forms\n-->\n<h3 id=\"폼에서-양방향-바인딩-사용하기\">폼에서 양방향 바인딩 사용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#폼에서-양방향-바인딩-사용하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe two-way binding syntax is a great convenience compared to\nseparate property and event bindings. It would be convenient to\nuse two-way binding with HTML form elements like `<input>` and\n`<select>`. However, no native HTML element follows the `x`\nvalue and `xChange` event pattern.\n\nFor more on how to use two-way binding in forms, see\nAngular [NgModel](guide/template-syntax#ngModel).\n-->\n<p>양방향 바인딩 문법을 사용하는 것은 프로퍼티 바인딩 문법과 이벤트 바인딩 문법을 따로 사용하는 것보다 훨씬 편합니다.\n<code>&#x3C;input></code>이나 <code>&#x3C;select></code>와 같은 HTML 폼 엘리먼트인 경우에 특히 그렇습니다.\n그리고 표준 HTML 엘리먼트가 아닌 경우에는 <code>x</code> 값이 변경되었을 때 <code>xChange</code> 이벤트가 발생하는 패턴으로 구현하는 것을 권장합니다.</p>\n<p>폼에서 사용하는 양방향 바인딩에 대해 자세하게 알아보려면 <a href=\"guide/template-syntax#ngModel\">NgModel</a> 문서를 참고하세요.</p>\n<hr>\n<a id=\"directives\"></a>\n<!--\n## Built-in directives\n-->\n<h2 id=\"기본-디렉티브\">기본 디렉티브<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#기본-디렉티브\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAngular offers two kinds of built-in directives: attribute\ndirectives and structural directives. This segment reviews some of the most common built-in directives,\nclassified as either [_attribute_ directives](guide/template-syntax#attribute-directives) or [_structural_ directives](guide/template-syntax#structural-directives) and has its own <live-example name=\"built-in-directives\">built-in directives example</live-example>.\n\nFor more detail, including how to build your own custom directives, see [Attribute Directives](guide/attribute-directives) and [Structural Directives](guide/structural-directives).\n-->\n<p>Angular에서 디렉티브는 어트리뷰트 디렉티브와 구조 디렉티브, 이렇게 두 종류입니다.\n이번 섹션에서는 자주 사용하는 Angular 기본 디렉티브에 대해 <a href=\"guide/template-syntax#attribute-directives\"><em>어트리뷰트</em> 디렉티브</a>와 <a href=\"guide/template-syntax#structural-directives\"><em>구조</em> 디렉티브</a> 차원에서 각각 살펴봅시다.\n직접 실행할 수 있는 예제 앱은 <live-example name=\"built-in-directives\">기본 디렉티브 예제</live-example>를 참고하세요.</p>\n<p>커스텀 디렉티브에 대한 내용은 <a href=\"guide/attribute-directives\">어트리뷰트 디렉티브</a>와 <a href=\"guide/structural-directives\">구조 디렉티브</a> 문서를 참고하세요.</p>\n<hr>\n<a id=\"attribute-directives\"></a>\n<!--\n### Built-in attribute directives\n-->\n<h2 id=\"기본-어트리뷰트-디렉티브\">기본 어트리뷰트 디렉티브<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#기본-어트리뷰트-디렉티브\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAttribute directives listen to and modify the behavior of\nother HTML elements, attributes, properties, and components.\nYou usually apply them to elements as if they were HTML attributes, hence the name.\n\nMany NgModules such as the [`RouterModule`](guide/router \"Routing and Navigation\")\nand the [`FormsModule`](guide/forms \"Forms\") define their own attribute directives.\nThe most common attribute directives are as follows:\n\n* [`NgClass`](guide/template-syntax#ngClass)&mdash;adds and removes a set of CSS classes.\n* [`NgStyle`](guide/template-syntax#ngStyle)&mdash;adds and removes a set of HTML styles.\n* [`NgModel`](guide/template-syntax#ngModel)&mdash;adds two-way data binding to an HTML form element.\n-->\n<p>어트리뷰트 디렉티브는 HTML 엘리먼트나 어트리뷰트, 프로퍼티, 컴포넌트의 동작을 조작합니다.\n그리고 일반 HTML 어트리뷰트처럼 이름을 지정하는 방식으로 사용합니다.</p>\n<p><a href=\"guide/router\" title=\"Routing and Navigation\"><code>RouterModule</code></a>이나 <a href=\"guide/forms\" title=\"Forms\"><code>FormsModule</code></a>처럼 모듈이 어트리뷰트 디렉티브를 제공하기도 합니다.\n그 중 자주 사용하는 어트리뷰트 디렉티브는 이런 것들이 있습니다:</p>\n<ul>\n<li><a href=\"guide/template-syntax#ngClass\"><code>NgClass</code></a>—CSS 클래스를 추가하거나 제거합니다.</li>\n<li><a href=\"guide/template-syntax#ngStyle\"><code>NgStyle</code></a>—HTML 스타일을 추가하거나 제거합니다.</li>\n<li><a href=\"guide/template-syntax#ngModel\"><code>NgModel</code></a>—HTML 폼 엘리먼트에 양방향 바인딩을 연결합니다.</li>\n</ul>\n<hr>\n<a id=\"ngClass\"></a>\n<h3 id=\"ngclass\"><code><a href=\"api/common/NgClass\" class=\"code-anchor\">NgClass</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#ngclass\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAdd or remove several CSS classes simultaneously with `ngClass`.\n-->\n<p><code><a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a></code>를 사용하면 CSS 클래스 여러개를 동시에 추가하거나 제거할 수 있습니다.</p>\n<code-example path=\"built-in-directives/src/app/app.component.html\" region=\"special-div\" header=\"src/app/app.component.html\">\n&#x3C;!-- \"special\" 클래스는 프로퍼티 바인딩으로 켜고 끌 수 있습니다. -->\n&#x3C;div [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"isSpecial ? 'special' : ''\">This div is special&#x3C;/div>\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\nTo add or remove a *single* class, use [class binding](guide/template-syntax#class-binding) rather than `NgClass`.\n-->\n<p>클래스 <em>하나를</em> 조작한다면 <code><a href=\"api/common/NgClass\" class=\"code-anchor\">NgClass</a></code> 보다 <a href=\"guide/template-syntax#class-binding\">클래스 바인딩</a>을 사용하는 것이 더 좋습니다.</p>\n</div>\n<!--\nConsider a `setCurrentClasses()` component method that sets a component property,\n`currentClasses`, with an object that adds or removes three classes based on the\n`true`/`false` state of three other component properties. Each key of the object is a CSS class name; its value is `true` if the class should be added,\n`false` if it should be removed.\n-->\n<p>컴포넌트 메소드 <code>setCurrentClasses()</code>는 컴포넌트 프로퍼티 <code>currentClasses</code>의 값을 지정하는데, 이 때 지정하는 클래스는 3개이며 다른 컴포넌트 프로퍼티 값에 따라 객체로 구성됩니다.\n이 객체의 키(key)는 CSS 클래스 이름이며 키에 연결된 값이 <code>true</code>면 클래스가 추가되고 <code>false</code>면 클래스가 제거됩니다.</p>\n<code-example path=\"built-in-directives/src/app/app.component.ts\" region=\"setClasses\" header=\"src/app/app.component.ts\">\ncurrentClasses: {};\nsetCurrentClasses() {\n  // CSS 클래스는 컴포넌트 프로퍼티 값에 따라 추가되거나 제거됩니다.\n  this.currentClasses =  {\n    'saveable': this.canSave,\n    'modified': !this.isUnchanged,\n    'special':  this.isSpecial\n  };\n}\n\n</code-example>\n<!--\nAdding an `ngClass` property binding to `currentClasses` sets the element's classes accordingly:\n-->\n<p><code>currentClasses</code>는 엘리먼트의 클래스를 지정하기 위해 <code><a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a></code>에 다음과 같이 프로퍼티 바인딩합니다::</p>\n<code-example path=\"built-in-directives/src/app/app.component.html\" region=\"NgClass-1\" header=\"src/app/app.component.html\">\n&#x3C;div [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"currentClasses\">This div is initially saveable, unchanged, and special.&#x3C;/div>\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\nRemember that in this situation you'd call `setCurrentClasses()`,\nboth initially and when the dependent properties change.\n-->\n<p>이 예제에서는 초기값을 지정하거나 연결된 프로퍼티 값이 변경된 것을 반영하기 위해 <code>setCurrentClasses()</code>를 직접 실행했습니다.</p>\n</div>\n<hr>\n<a id=\"ngStyle\"></a>\n<h3 id=\"ngstyle\"><code><a href=\"api/common/NgStyle\" class=\"code-anchor\">NgStyle</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#ngstyle\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nUse `NgStyle` to set many inline styles simultaneously and dynamically, based on the state of the component.\n-->\n<p><code><a href=\"api/common/NgStyle\" class=\"code-anchor\">NgStyle</a></code>을 사용하면 컴포넌트 상태에 따라 인라인 스타일을 여러개를 동적으로 지정할 수 있습니다.</p>\n<!--\n#### Without `NgStyle`\n-->\n<h4 id=\"ngstyle을-사용하지-않는-방식\"><code><a href=\"api/common/NgStyle\" class=\"code-anchor\">NgStyle</a></code>을 사용하지 않는 방식<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#ngstyle을-사용하지-않는-방식\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nFor context, consider setting a *single* style value with [style binding](guide/template-syntax#style-binding), without `NgStyle`.\n\n<code-example path=\"built-in-directives/src/app/app.component.html\" region=\"without-ng-style\" header=\"src/app/app.component.html\">\n&lt;div [style.font-size]=&quot;isSpecial ? &#39;x-large&#39; : &#39;smaller&#39;&quot;&gt;\n  This div is x-large or smaller.\n&lt;/div&gt;\n\n</code-example>\n\nHowever, to set *many* inline styles at the same time, use the `NgStyle` directive.\n\nThe following is a `setCurrentStyles()` method that sets a component\nproperty, `currentStyles`, with an object that defines three styles,\nbased on the state of three other component properties:\n\n<code-example path=\"built-in-directives/src/app/app.component.ts\" region=\"setStyles\" header=\"src/app/app.component.ts\">\ncurrentStyles: {};\nsetCurrentStyles() {\n  // CSS 스타일은 컴포넌트 프로퍼티 값에 따라 지정됩니다.\n  this.currentStyles = {\n    &#39;font-style&#39;:  this.canSave      ? &#39;italic&#39; : &#39;normal&#39;,\n    &#39;font-weight&#39;: !this.isUnchanged ? &#39;bold&#39;   : &#39;normal&#39;,\n    &#39;font-size&#39;:   this.isSpecial    ? &#39;24px&#39;   : &#39;12px&#39;\n  };\n}\n\n</code-example>\n\nAdding an `ngStyle` property binding to `currentStyles` sets the element's styles accordingly:\n\n<code-example path=\"built-in-directives/src/app/app.component.html\" region=\"NgStyle-2\" header=\"src/app/app.component.html\">\n&lt;div [ngStyle]=&quot;currentStyles&quot;&gt;\n  This div is initially italic, normal weight, and extra large (24px).\n&lt;/div&gt;\n\n</code-example>\n\n<div class=\"alert is-helpful\">\n\nRemember to call `setCurrentStyles()`, both initially and when the dependent properties change.\n-->\n<p><code><a href=\"api/common/NgStyle\" class=\"code-anchor\">NgStyle</a></code>을 사용하지 않고 스타일 <em>하나를</em> <a href=\"guide/template-syntax#style-binding\">스타일 바인딩</a>하는 코드를 살펴봅니다.</p>\n<code-example path=\"built-in-directives/src/app/app.component.html\" region=\"without-ng-style\" header=\"src/app/app.component.html\">\n&#x3C;div [style.font-size]=\"isSpecial ? 'x-large' : 'smaller'\">\n  This div is x-large or smaller.\n&#x3C;/div>\n\n</code-example>\n<p>이 때 인라인 스타일 <em>여러 개를</em> 동시에 지정하려면 <code><a href=\"api/common/NgStyle\" class=\"code-anchor\">NgStyle</a></code> 디렉티브를 사용합니다.</p>\n<p>다음 코드에서 <code>setCurrentStyles()</code> 메소드는 컴포넌트 프로퍼티 <code>currentStyles</code>의 값을 설정합니다. <code>currentStyles</code>는 객체로 구성되며 다른 컴포넌트 프로퍼티 값에 따라 3개의 스타일을 지정합니다:</p>\n<code-example path=\"built-in-directives/src/app/app.component.ts\" region=\"setStyles\" header=\"src/app/app.component.ts\">\ncurrentStyles: {};\nsetCurrentStyles() {\n  // CSS 스타일은 컴포넌트 프로퍼티 값에 따라 지정됩니다.\n  this.currentStyles = {\n    'font-style':  this.canSave      ? 'italic' : 'normal',\n    'font-weight': !this.isUnchanged ? 'bold'   : 'normal',\n    'font-size':   this.isSpecial    ? '24px'   : '12px'\n  };\n}\n\n</code-example>\n<p>그리고 <code>currentStyles</code>를 <code><a href=\"api/common/NgStyle\" class=\"code-anchor\">ngStyle</a></code> 디렉티브에 바인딩하려면 다음과 같이 구현합니다:</p>\n<code-example path=\"built-in-directives/src/app/app.component.html\" region=\"NgStyle-2\" header=\"src/app/app.component.html\">\n&#x3C;div [<a href=\"api/common/NgStyle\" class=\"code-anchor\">ngStyle</a>]=\"currentStyles\">\n  This div is initially italic, normal weight, and extra large (24px).\n&#x3C;/div>\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>이 예제에서는 초기값을 지정하거나 연결된 프로퍼티 값이 변경된 것을 반영하기 위해 <code>setCurrentStyles()</code>를 직접 실행했습니다.</p>\n</div>\n<hr>\n<a id=\"ngModel\"></a>\n<!--\n### `[(ngModel)]`: Two-way binding\n-->\n<h3 id=\"ngmodel-양방향-바인딩\"><code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code>: 양방향 바인딩<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#ngmodel-양방향-바인딩\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe `NgModel` directive allows you to display a data property and\nupdate that property when the user makes changes. Here's an example:\n\n<code-example path=\"built-in-directives/src/app/app.component.html\" header=\"src/app/app.component.html (NgModel example)\" region=\"NgModel-1\">\n&lt;label for=&quot;example-ngModel&quot;&gt;[(ngModel)]:&lt;/label&gt;\n&lt;input [(ngModel)]=&quot;currentItem.name&quot; id=&quot;example-ngModel&quot;&gt;\n\n</code-example>\n-->\n<p><code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 디렉티브를 사용하면 데이터의 값을 화면에 표시하면서 이 데이터가 변경되는 것도 감지할 수 있습니다:</p>\n<code-example path=\"built-in-directives/src/app/app.component.html\" header=\"src/app/app.component.html (NgModel 예제)\" region=\"NgModel-1\">\n&#x3C;label for=\"example-ngModel\">[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]:&#x3C;/label>\n&#x3C;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"currentItem.name\" id=\"example-ngModel\">\n\n</code-example>\n<!--\n#### Import `FormsModule` to use `ngModel`\n-->\n<h3 id=\"ngmodel을-사용하려면-formsmodule을-로드해야-합니다\"><code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code>을 사용하려면 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>을 로드해야 합니다.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#ngmodel을-사용하려면-formsmodule을-로드해야-합니다\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nBefore using the `ngModel` directive in a two-way data binding,\nyou must import the `FormsModule` and add it to the NgModule's `imports` list.\nLearn more about the `FormsModule` and `ngModel` in [Forms](guide/forms#ngModel).\n\nRemember to import the `FormsModule` to make `[(ngModel)]` available as follows:\n\n<code-example path=\"built-in-directives/src/app/app.module.ts\" header=\"src/app/app.module.ts (FormsModule import)\" region=\"import-forms-module\">\nimport { FormsModule } from &#39;@angular/forms&#39;; // &lt;--- FormsModule 패키지 로드\n/* . . . */\n@NgModule({\n/* . . . */\n\n  imports: [\n    BrowserModule,\n    FormsModule // &lt;--- NgModule에 로드\n  ],\n/* . . . */\n})\nexport class AppModule { }\n\n</code-example>\n\nYou could achieve the same result with separate bindings to\nthe `<input>` element's  `value` property and `input` event:\n\n<code-example path=\"built-in-directives/src/app/app.component.html\" region=\"without-NgModel\" header=\"src/app/app.component.html\">\n&lt;label for=&quot;without&quot;&gt;without NgModel:&lt;/label&gt;\n&lt;input [value]=&quot;currentItem.name&quot; (input)=&quot;currentItem.name=$event.target.value&quot; id=&quot;without&quot;&gt;\n\n</code-example>\n\nTo streamline the syntax, the `ngModel` directive hides the details behind its own `ngModel` input and `ngModelChange` output properties:\n\n<code-example path=\"built-in-directives/src/app/app.component.html\" region=\"NgModelChange\" header=\"src/app/app.component.html\">\n&lt;label for=&quot;example-change&quot;&gt;(ngModelChange)=&quot;...name=$event&quot;:&lt;/label&gt;\n&lt;input [ngModel]=&quot;currentItem.name&quot; (ngModelChange)=&quot;currentItem.name=$event&quot; id=&quot;example-change&quot;&gt;\n\n</code-example>\n\nThe `ngModel` data property sets the element's value property and the `ngModelChange` event property\nlistens for changes to the element's value.\n-->\n<p><code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 디렉티브로 양방향 바인딩을 구현하려면 NgModule의 <code>imports</code> 목록에 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>을 추가해야 합니다.\n<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>과 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code>에 대한 자세한 설명은 <a href=\"guide/forms#ngModel\">폼</a> 문서를 참고하세요.</p>\n<p>NgModule에 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 을 다음과 같이 추가합니다.</p>\n<code-example path=\"built-in-directives/src/app/app.module.ts\" header=\"src/app/app.module.ts (FormsModule 로드하기)\" region=\"import-forms-module\">\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms'; // &#x3C;--- <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> 패키지 로드\n/* . . . */\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n/* . . . */\n\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> // &#x3C;--- <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>에 로드\n  ],\n/* . . . */\n})\nexport class AppModule { }\n\n</code-example>\n<p><code>&#x3C;input></code> 엘리먼트의 경우라면 <code>value</code> 프로퍼티와 <code>input</code> 이벤트를 따로 바인딩해도 똑같이 동작합니다:</p>\n<code-example path=\"built-in-directives/src/app/app.component.html\" region=\"without-NgModel\" header=\"src/app/app.component.html\">\n&#x3C;label for=\"without\">without <a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a>:&#x3C;/label>\n&#x3C;input [value]=\"currentItem.name\" (input)=\"currentItem.name=$event.target.value\" id=\"without\">\n\n</code-example>\n<p>이 방식을 간결하게 구현하기 위해 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 디렉티브를 사용하면 내부적으로 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 입력 프로퍼티와 <code>ngModelChange</code> 출력 프로퍼티가 지정됩니다:</p>\n<code-example path=\"built-in-directives/src/app/app.component.html\" region=\"NgModelChange\" header=\"src/app/app.component.html\">\n&#x3C;label for=\"example-change\">(ngModelChange)=\"...name=$event\":&#x3C;/label>\n&#x3C;input [<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>]=\"currentItem.name\" (ngModelChange)=\"currentItem.name=$event\" id=\"example-change\">\n\n</code-example>\n<p><code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 프로퍼티는 엘리먼트의 프로퍼티 값을 지정하고 <code>ngModelChange</code> 이벤트 프로퍼티는 엘리먼트 값이 변경되는 것을 감지합니다.</p>\n<!--\n#### `NgModel` and value accessors\n-->\n<h4 id=\"ngmodel과-밸류-액세서value-accessor\"><code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code>과 밸류 액세서(value accessor)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#ngmodel과-밸류-액세서value-accessor\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe details are specific to each kind of element and therefore the `NgModel` directive only works for an element\nsupported by a [ControlValueAccessor](api/forms/ControlValueAccessor)\nthat adapts an element to this protocol.\nAngular provides *value accessors* for all of the basic HTML form elements and the\n[Forms](guide/forms) guide shows how to bind to them.\n\nYou can't apply `[(ngModel)]` to a non-form native element or a\nthird-party custom component until you write a suitable value accessor. For more information, see\nthe API documentation on [DefaultValueAccessor](https://angular.io/api/forms/DefaultValueAccessor).\n\nYou don't need a value accessor for an Angular component that\nyou write because you can name the value and event properties\nto suit Angular's basic [two-way binding syntax](guide/template-syntax#two-way)\nand skip `NgModel` altogether.\nThe `sizer` in the\n[Two-way Binding](guide/template-syntax#two-way) section is an example of this technique.\n\nSeparate `ngModel` bindings are an improvement over binding to the\nelement's native properties, but you can streamline the binding with a\nsingle declaration using the `[(ngModel)]` syntax:\n\n<code-example path=\"built-in-directives/src/app/app.component.html\" region=\"NgModel-1\" header=\"src/app/app.component.html\">\n&lt;label for=&quot;example-ngModel&quot;&gt;[(ngModel)]:&lt;/label&gt;\n&lt;input [(ngModel)]=&quot;currentItem.name&quot; id=&quot;example-ngModel&quot;&gt;\n\n</code-example>\n\nThis `[(ngModel)]` syntax can only _set_ a data-bound property.\nIf you need to do something more, you can write the expanded form;\nfor example, the following changes the `<input>` value to uppercase:\n\n<code-example path=\"built-in-directives/src/app/app.component.html\" region=\"uppercase\" header=\"src/app/app.component.html\">\n&lt;input [ngModel]=&quot;currentItem.name&quot; (ngModelChange)=&quot;setUppercaseName($event)&quot; id=&quot;example-uppercase&quot;&gt;\n\n</code-example>\n\nHere are all variations in action, including the uppercase version:\n-->\n<p><code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 디렉티브가 동작하는 것은 엘리먼트에 따라 조금씩 다르며, <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 디렉티브는 <a href=\"api/forms/ControlValueAccessor\">ControlValueAccessor</a>가 지원하는 엘리먼트에만 사용할 수 있습니다.\n여기에서 밸류 액세서는 엘리먼트가 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code>과 어떻게 동작하는지 연결하는 프로토콜이라고 볼 수 있습니다.\nAngular는 표준 HTML 폼 엘리먼트에 대한 <em>밸류 액세서</em>는 기본으로 지원하며, 밸류 액세서를 사용하는 방법은 <a href=\"guide/forms\">폼</a> 문서에서 자세하게 소개합니다.</p>\n<p>다만, 표준 폼 엘리먼트가 아니거나 서드파티로 불러온 커스텀 엘리먼트가 밸류 액세서를 제공하지 않는다면 <code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code>을 사용할 수 없습니다.\n자세한 내용은 <a href=\"https://angular.io/api/forms/DefaultValueAccessor\">DefaultValueAccessor</a> 문서를 참고하세요.</p>\n<p>프로퍼티와 이벤트를 바인딩하는 문법이 <a href=\"guide/template-syntax#two-way\">양방향 바인딩 문법</a>에 맞다면 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code>을 꼭 사용할 필요는 없습니다.\n<a href=\"guide/template-syntax#two-way\">양방향 바인딩</a> 섹션에서 살펴본 <code>sizer</code> 프로퍼티가 이렇게 구현되었습니다.</p>\n<p><code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 바인딩을 프로퍼티 바인딩과 이벤트 바인딩으로 나눠서 사용해도 기존 HTML 엘리먼트를 확장하는 것에 변함은 없지만, <code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code> 문법으로 작성하면 문법이 좀 더 간단해질 수 있습니다:</p>\n<code-example path=\"built-in-directives/src/app/app.component.html\" region=\"NgModel-1\" header=\"src/app/app.component.html\">\n&#x3C;label for=\"example-ngModel\">[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]:&#x3C;/label>\n&#x3C;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"currentItem.name\" id=\"example-ngModel\">\n\n</code-example>\n<p><code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code> 문법은 데이터만 바인딩하는 문법입니다.\n이 문법을 사용하면서 값이 변경되는 이벤트를 다른 방식으로 활용하려면 다음과 같이 프로퍼티 바인딩과 이벤트 바인딩을 나눠서 구현하면 됩니다:</p>\n<code-example path=\"built-in-directives/src/app/app.component.html\" region=\"uppercase\" header=\"src/app/app.component.html\">\n&#x3C;input [<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>]=\"currentItem.name\" (ngModelChange)=\"setUppercaseName($event)\" id=\"example-uppercase\">\n\n</code-example>\n<p><code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 디렉티브는 다음과 같이 다양한 문법으로 사용할 수 있습니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/built-in-directives/ng-model-anim.gif\" alt=\"NgModel variations\" width=\"540\" height=\"264\">\n</div>\n<hr>\n<a id=\"structural-directives\"></a>\n<!--\n## Built-in _structural_ directives\n-->\n<h2 id=\"기본-구조-디렉티브\">기본 <em>구조</em> 디렉티브<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#기본-구조-디렉티브\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nStructural directives are responsible for HTML layout.\nThey shape or reshape the DOM's structure, typically by adding, removing, and manipulating\nthe host elements to which they are attached.\n\nThis section is an introduction to the common built-in structural directives:\n\n* [`NgIf`](guide/template-syntax#ngIf)&mdash;conditionally creates or destroys subviews from the template.\n* [`NgFor`](guide/template-syntax#ngFor)&mdash;repeat a node for each item in a list.\n* [`NgSwitch`](guide/template-syntax#ngSwitch)&mdash;a set of directives that switch among alternative views.\n\n<div class=\"alert is-helpful\">\n\nThe deep details of structural directives are covered in the\n[Structural Directives](guide/structural-directives) guide,\nwhich explains the following:\n\n* Why you\n[prefix the directive name with an asterisk (\\*)](guide/structural-directives#the-asterisk--prefix).\n* Using [`<ng-container>`](guide/structural-directives#ngcontainer \"<ng-container>\")\nto group elements when there is no suitable host element for the directive.\n* How to write your own structural directive.\n* That you can only apply [one structural directive](guide/structural-directives#one-per-element \"one per host element\") to an element.\n\n</div>\n-->\n<p>구조 디렉티브는 DOM 엘리먼트의 모양을 바꾸거나 DOM 트리에서 DOM 엘리먼트를 추가하거나 제거하는 등 HTML 레이아웃을 조작합니다.</p>\n<p>그리고 이번 섹션에서는 자주 사용하는 구조 디렉티브에 대해 알아봅시다:</p>\n<ul>\n<li><a href=\"guide/template-syntax#ngIf\"><code>NgIf</code></a>—조건에 따라 템플릿의 일부를 DOM에 추가하거나 제거합니다.</li>\n<li><a href=\"guide/template-syntax#ngFor\"><code>NgFor</code></a>—목록에 있는 아이템마다 노드를 반복합니다.</li>\n<li><a href=\"guide/template-syntax#ngSwitch\"><code>NgSwitch</code></a>—조건에 맞는 노드를 화면에 표시합니다.</li>\n</ul>\n<div class=\"alert is-helpful\">\n<p><a href=\"guide/structural-directives\">구조 디렉티브</a> 문서는 구조 디렉티브에 대해 더 깊이있게 다룹니다.\n다음 내용에 대해 궁금하다면 참고해 보세요:</p>\n<ul>\n<li><a href=\"guide/structural-directives#the-asterisk--prefix\">디렉티브 이름은 왜 별표(*)로 시작해야 하는지</a></li>\n<li><a href=\"guide/structural-directives#ngcontainer\" title=\"<ng-container>\"><code>&#x3C;ng-container></code></a>를 사용해서 엘리먼트를 묶는 방법</li>\n<li>커스텀 구조 디렉티브는 어떻게 구현하는지</li>\n<li>엘리먼트 하나에는 <a href=\"guide/structural-directives#one-per-element\" title=\"one per host element\">구조 디렉티브 하나만</a> 적용할 수 있는지</li>\n</ul>\n</div>\n<hr>\n<a id=\"ngIf\"></a>\n<h3 id=\"ngif\">NgIf<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#ngif\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou can add or remove an element from the DOM by applying an `NgIf` directive to\na host element.\nBind the directive to a condition expression like `isActive` in this example.\n-->\n<p><code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 디렉티브를 사용하면 조건에 따라 원하는 위치(<em>호스트 엘리먼트</em>)에 엘리먼트를 추가하거나 제거할 수 있습니다.\n다음 예제에서 보면 <code><a href=\"api/router/RouterLinkActive#isActive\" class=\"code-anchor\">isActive</a></code>값에 따라 디렉티브가 뷰에 추가되거나 제거됩니다.</p>\n<code-example path=\"built-in-directives/src/app/app.component.html\" region=\"NgIf-1\" header=\"src/app/app.component.html\">\n&#x3C;app-item-detail *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"<a href=\"api/router/RouterLinkActive#isActive\" class=\"code-anchor\">isActive</a>\" [<a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>]=\"<a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>\">&#x3C;/app-item-detail>\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\nDon't forget the asterisk (`*`) in front of `ngIf`. For more information\non the asterisk, see the [asterisk (*) prefix](guide/structural-directives#the-asterisk--prefix) section of\n[Structural Directives](guide/structural-directives).\n-->\n<p><code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 앞에 별표(<code>*</code>)를 꼭 붙여야 합니다.\n왜 <a href=\"guide/structural-directives#the-asterisk--prefix\">별표(*) 접두사</a>를 붙이는지 자세하게 알아보려면 <a href=\"guide/structural-directives\">구조 디렉티브</a> 문서를 참고하세요.</p>\n</div>\n<!--\nWhen the `isActive` expression returns a truthy value, `NgIf` adds the\n`ItemDetailComponent` to the DOM.\nWhen the expression is falsy, `NgIf` removes the `ItemDetailComponent`\nfrom the DOM, destroying that component and all of its sub-components.\n-->\n<p>이 코드에서는 <code><a href=\"api/router/RouterLinkActive#isActive\" class=\"code-anchor\">isActive</a></code> 표현식의 값이 참으로 평가되면 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 디렉티브가 <code>HeroDetailComponent</code>를 DOM에 추가합니다.\n그리고 표현식의 값이 거짓으로 평가되면 이 컴포넌트를 DOM에서 제거합니다. 이 때 이 컴포넌트와 이 컴포넌트의 하위 컴포넌트는 모두 종료됩니다.</p>\n<h4 id=\"showhide-vs-ngif\">Show/hide vs. <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#showhide-vs-ngif\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nHiding an element is different from removing it with `NgIf`.\nFor comparison, the following example shows how to control\nthe visibility of an element with a\n[class](guide/template-syntax#class-binding) or [style](guide/template-syntax#style-binding) binding.\n\n<code-example path=\"built-in-directives/src/app/app.component.html\" region=\"NgIf-3\" header=\"src/app/app.component.html\">\n&lt;!-- isSpecial이 true일 때 --&gt;\n&lt;div [class.hidden]=&quot;!isSpecial&quot;&gt;Show with class&lt;/div&gt;\n&lt;div [class.hidden]=&quot;isSpecial&quot;&gt;Hide with class&lt;/div&gt;\n\n&lt;p&gt;ItemDetail is in the DOM but hidden&lt;/p&gt;\n&lt;app-item-detail [class.hidden]=&quot;isSpecial&quot;&gt;&lt;/app-item-detail&gt;\n\n&lt;div [style.display]=&quot;isSpecial ? &#39;block&#39; : &#39;none&#39;&quot;&gt;Show with style&lt;/div&gt;\n&lt;div [style.display]=&quot;isSpecial ? &#39;none&#39;  : &#39;block&#39;&quot;&gt;Hide with style&lt;/div&gt;\n\n</code-example>\n\nWhen you hide an element, that element and all of its descendants remain in the DOM.\nAll components for those elements stay in memory and\nAngular may continue to check for changes.\nYou could be holding onto considerable computing resources and degrading performance\nunnecessarily.\n\n`NgIf` works differently. When `NgIf` is `false`, Angular removes the element and its descendants from the DOM.\nIt destroys their components, freeing up resources, which\nresults in a better user experience.\n\nIf you are hiding large component trees, consider `NgIf` as a more\nefficient alternative to showing/hiding.\n\n<div class=\"alert is-helpful\">\n\nFor more information on `NgIf` and `ngIfElse`, see the [API documentation about NgIf](api/common/NgIf).\n\n</div>\n-->\n<p>엘리먼트를 보이지 않게 처리하는 것과 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>가 DOM에러 엘리먼트를 제거하는 것은 다릅니다.\n이 내용을 비교해보기 위해 <a href=\"guide/template-syntax#class-binding\">클래스 바인딩</a>과 <a href=\"guide/template-syntax#style-binding\">스타일 바인딩</a>을 사용해서 엘리먼트를 제어하는 예제에 대해 알아봅시다.</p>\n<code-example path=\"built-in-directives/src/app/app.component.html\" region=\"NgIf-3\" header=\"src/app/app.component.html\">\n&#x3C;!-- isSpecial이 true일 때 -->\n&#x3C;div [class.hidden]=\"!isSpecial\">Show with class&#x3C;/div>\n&#x3C;div [class.hidden]=\"isSpecial\">Hide with class&#x3C;/div>\n\n&#x3C;p>ItemDetail is in the DOM but hidden&#x3C;/p>\n&#x3C;app-item-detail [class.hidden]=\"isSpecial\">&#x3C;/app-item-detail>\n\n&#x3C;div [style.display]=\"isSpecial ? 'block' : 'none'\">Show with <a href=\"api/animations/style\" class=\"code-anchor\">style</a>&#x3C;/div>\n&#x3C;div [style.display]=\"isSpecial ? 'none'  : 'block'\">Hide with <a href=\"api/animations/style\" class=\"code-anchor\">style</a>&#x3C;/div>\n\n</code-example>\n<p>엘리먼트를 숨기더라도 그 엘리먼트와 자식 엘리먼트는 DOM에 여전히 남아있습니다.\n이 컴포넌트들은 메모리에 여전히 남아있으며 Angular의 변화 감지 로직이 동작하는 대상에 이 컴포넌트도 포함됩니다.\n자연스럽게 자원 소모도 많아지고 사용자가 느끼는 성능도 좋지 않을 것입니다.</p>\n<p><code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>는 다릅니다. <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 값이 <code>false</code>면 Angular는 이 엘리먼트와 자식 엘리먼트를 DOM에서 완전히 제거합니다.\n이 때 컴포넌트가 종료되고 자원도 반환되기 때문에 사용자가 느끼는 성능도 더 좋습니다.</p>\n<p>그래서 무거운 컴포넌트 트리일수록 show/hide 대신 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>가 효율적입니다.</p>\n<div class=\"alert is-helpful\">\n<p><code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>와 <code><a href=\"api/common/NgIf#ngIfElse\" class=\"code-anchor\">ngIfElse</a></code>에 대해 자세하게 알아보려면 <a href=\"api/common/NgIf\">NgIf API 문서</a>를 참고하세요.</p>\n</div>\n<!--\n#### Guard against null\n-->\n<h4 id=\"null-방지\">null 방지<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#null-방지\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nAnother advantage of `ngIf` is that you can use it to guard against null. Show/hide\nis best suited for very simple use cases, so when you need a guard, opt instead for `ngIf`. Angular will throw an error if a nested expression tries to access a property of `null`.\n\nThe following shows `NgIf` guarding two `<div>`s.\nThe `currentCustomer` name appears only when there is a `currentCustomer`.\nThe `nullCustomer` will not be displayed as long as it is `null`.\n\n<code-example path=\"built-in-directives/src/app/app.component.html\" region=\"NgIf-2\" header=\"src/app/app.component.html\">\n&lt;div *ngIf=&quot;currentCustomer&quot;&gt;Hello, {{currentCustomer.name}}&lt;/div&gt;\n\n</code-example>\n\n<code-example path=\"built-in-directives/src/app/app.component.html\" region=\"NgIf-2b\" header=\"src/app/app.component.html\">\n&lt;div *ngIf=&quot;nullCustomer&quot;&gt;Hello, &lt;span&gt;{{nullCustomer}}&lt;/span&gt;&lt;/div&gt;\n\n</code-example>\n\n<div class=\"alert is-helpful\">\n\nSee also the\n[safe navigation operator](guide/template-syntax#safe-navigation-operator \"Safe navigation operator (?.)\") below.\n\n</div>\n-->\n<p><code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 디렉티브는 <code>null</code> 값을 방지하는 용도로도 사용할 수 있습니다.\n그래서 간단한 방법으로도 템플릿에서 <code>null</code> 객체의 프로퍼티에 접근하는 표현식의 에러를 방지할 수 있습니다.</p>\n<p>다음과 같이 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>를 사용한 두 개의 <code>&#x3C;div></code> 엘리먼트를 봅시다.\n<code>currentCustomer</code>의 이름은 <code>currentCustomer</code> 객체가 존재할 때만 표시됩니다.\n그리고 <code>nullCustomer</code> 프로퍼티의 값은 <code>null</code>이기 때문에 아무것도 표시되지 않을 것입니다.</p>\n<code-example path=\"built-in-directives/src/app/app.component.html\" region=\"NgIf-2\" header=\"src/app/app.component.html\">\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"currentCustomer\">Hello, {{currentCustomer.name}}&#x3C;/div>\n\n</code-example>\n<code-example path=\"built-in-directives/src/app/app.component.html\" region=\"NgIf-2b\" header=\"src/app/app.component.html\">\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"nullCustomer\">Hello, &#x3C;span>{{nullCustomer}}&#x3C;/span>&#x3C;/div>\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p><a href=\"guide/template-syntax#safe-navigation-operator\" title=\"Safe navigation operator (?.)\">안전 참조 연산자</a> 에 대해서도 확인해 보세요.</p>\n</div>\n<hr>\n<a id=\"ngFor\"></a>\n<h3 id=\"ngfor\"><code>NgFor</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#ngfor\"><i class=\"material-icons\">link</i></a></h3>\n<!--\n`NgFor` is a repeater directive&mdash;a way to present a list of items.\nYou define a block of HTML that defines how a single item should be displayed\nand then you tell Angular to use that block as a template for rendering each item in the list.\nThe text assigned to `*ngFor` is the instruction that guides the repeater process.\n\nThe following example shows `NgFor` applied to a simple `<div>`. (Don't forget the asterisk (`*`) in front of `ngFor`.)\n\n<code-example path=\"built-in-directives/src/app/app.component.html\" region=\"NgFor-1\" header=\"src/app/app.component.html\">\n&lt;div *ngFor=&quot;let item of items&quot;&gt;{{item.name}}&lt;/div&gt;\n\n</code-example>\n\nYou can also apply an `NgFor` to a component element, as in the following example.\n\n<code-example path=\"built-in-directives/src/app/app.component.html\" region=\"NgFor-2\" header=\"src/app/app.component.html\">\n&lt;app-item-detail *ngFor=&quot;let item of items&quot; [item]=&quot;item&quot;&gt;&lt;/app-item-detail&gt;\n\n</code-example>\n-->\n<p><code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code>는 템플릿을 반복하는 디렉티브이며, 배열의 각 항목을 뷰에 표시할 때 주로 사용합니다.\n이 디렉티브를 사용할 때는 배열의 한 항목을 뷰로 어떻게 표시할지 HTML 템플릿으로 먼저 정의합니다.\n그러면 Angular가 템플릿을 반복할 때마다 배열의 항목이 하나씩 전달되면서 화면에 표시합니다.\n<code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>가 어떻게 동작하는지는 이 디렉티브에 전달하는 문자열로 지정합니다.</p>\n<p>아래 예제에서는 간단한 <code>&#x3C;div></code> 엘리먼트에 <code>NgFor</code> 디렉티브가 적용되었습니다. (<code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 앞에 별표(<code>*</code>)를 빠뜨리지 마세요.)</p>\n<code-example path=\"built-in-directives/src/app/app.component.html\" region=\"NgFor-1\" header=\"src/app/app.component.html\">\n&#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let <a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a> of items\">{{item.name}}&#x3C;/div>\n\n</code-example>\n<p>그리고 다음과 같이 컴포넌트 엘리먼트에도 적용할 수 있습니다.</p>\n<code-example path=\"built-in-directives/src/app/app.component.html\" region=\"NgFor-2\" header=\"src/app/app.component.html\">\n&#x3C;app-item-detail *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let <a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a> of items\" [<a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>]=\"<a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>\">&#x3C;/app-item-detail>\n\n</code-example>\n<a id=\"microsyntax\"></a>\n<div class=\"callout is-critical\">\n<!--\n<header>*ngFor microsyntax</header>\n\nThe string assigned to `*ngFor` is not a [template expression](guide/template-syntax#template-expressions). Rather,\nit's a *microsyntax*&mdash;a little language of its own that Angular interprets.\nThe string `\"let item of items\"` means:\n\n> *Take each item in the `items` array, store it in the local `item` looping variable, and\nmake it available to the templated HTML for each iteration.*\n\nAngular translates this instruction into an `<ng-template>` around the host element,\nthen uses this template repeatedly to create a new set of elements and bindings for each `item`\nin the list.\nFor more information about microsyntax, see the [Structural Directives](guide/structural-directives#microsyntax) guide.\n-->\n<header>*ngFor 세부문법(microsyntax)</header>\n<p><code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>에 할당되는 문자열은 <a href=\"guide/template-syntax#template-expressions\">템플릿 표현식</a>이 아닙니다.\n이 문자열은 Angular 인터프리터가 처리하는 작은 언어셋이라고 이해할 수 있습니다.\n예를 들어 <code>\"let <a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a> of items\"</code>와 같은 문자열이 있다면 이 문자열은:</p>\n<blockquote>\n<p><em><code>items</code> 배열에서 항목을 가져와서 로컬 변수 <code><a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a></code>에 담은 뒤에 이 변수마다 템플릿 HTML을 반복하라는 것을 의미합니다.</em></p>\n</blockquote>\n<p>Angular는 호스트 엘리먼트 근처에 <code>&#x3C;ng-template></code>을 만들어서 이런 동작을 처리합니다.\n그리고 새로 만들어지는 엘리먼트마다 <code><a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a></code> 항목을 적용합니다.\n세부문법에 대해 자세하게 알아보려면 <a href=\"guide/structural-directives#microsyntax\">구조 디렉티브</a> 문서를 참고하세요.</p>\n</div>\n<a id=\"template-input-variable\"></a>\n<a id=\"template-input-variables\"></a>\n<!--\n#### Template input variables\n-->\n<h4 id=\"템플릿-입력-변수-template-input-variables\">템플릿 입력 변수 (Template input variables)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#템플릿-입력-변수-template-input-variables\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe `let` keyword before `item` creates a template input variable called `item`.\nThe `ngFor` directive iterates over the `items` array returned by the parent component's `items` property\nand sets `item` to the current item from the array during each iteration.\n\nReference `item` within the `ngFor` host element\nas well as within its descendants to access the item's properties.\nThe following example references `item` first in an interpolation\nand then passes in a binding to the `item` property of the `<app-item-detail>` component.\n\n<code-example path=\"built-in-directives/src/app/app.component.html\" region=\"NgFor-1-2\" header=\"src/app/app.component.html\">\n  &lt;div *ngFor=&quot;let item of items&quot;&gt;{{item.name}}&lt;/div&gt;\n&lt;!-- . . . --&gt;\n  &lt;app-item-detail *ngFor=&quot;let item of items&quot; [item]=&quot;item&quot;&gt;&lt;/app-item-detail&gt;\n\n</code-example>\n\nFor more information about template input variables, see\n[Structural Directives](guide/structural-directives#template-input-variable).\n-->\n<p><code>hero</code> 안에 있는 <code>let</code> 키워드는 <em>템플릿 입력 변수</em> <code>hero</code>를 만드는 키워드입니다.\n그리고 <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> 디렉티브는 부모 컴포넌트의 <code>heroes</code> 배열의 각 항목을 반환하면서 이 문법을 반복하고, 각각의 반복마다 새로운 <code>hero</code> 아이템을 템플릿에 적용합니다.</p>\n<p><code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>가 사용된 호스트 엘리먼트에서 <code><a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a></code>에 접근할 수 있다는 것은, 이 호스트 엘리먼트의 자식 엘리먼트에서도 <code><a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a></code>에 접근할 수 있다는 것을 의미합니다.\n그래서 아래 예제에서 볼 수 있듯이 <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>로 반복할 때 받는 <code><a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a></code> 객체는 자식 컴포넌트인 <code>&#x3C;app-item-detail></code>로 전달할 수 있습니다.</p>\n<code-example path=\"built-in-directives/src/app/app.component.html\" region=\"NgFor-1-2\" header=\"src/app/app.component.html\">\n  &#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let <a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a> of items\">{{item.name}}&#x3C;/div>\n&#x3C;!-- . . . -->\n  &#x3C;app-item-detail *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let <a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a> of items\" [<a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>]=\"<a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>\">&#x3C;/app-item-detail>\n\n</code-example>\n<p>템플릿 입력 변수에 대해 자세하게 알아보려면 <a href=\"guide/structural-directives#template-input-variable\">구조 디렉티브</a> 문서를 참고하세요.</p>\n<!--\n#### `*ngFor` with `index`\n-->\n<h4 id=\"ngfor와-index\"><code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>와 <code>index</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#ngfor와-index\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe `index` property of the `NgFor` directive context\nreturns the zero-based index of the item in each iteration.\nYou can capture the `index` in a template input variable and use it in the template.\n\nThe next example captures the `index` in a variable named `i` and displays it with the item name.\n-->\n<p><code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> 디렉티브에서 제공하는 <code>index</code> 프로퍼티는 반복문이 반복되는 횟수를 나타내는 인덱스입니다.\n이 <code>index</code> 프로퍼티는 템플릿 입력 변수로 할당 받아 템플릿 안에서 사용할 수 있습니다.</p>\n<p>다음 코드는 <code>index</code> 프로퍼티를 변수 <code>i</code>로 할당하고 히어로의 이름과 함께 표시하는 예제입니다.</p>\n<code-example path=\"built-in-directives/src/app/app.component.html\" region=\"NgFor-3\" header=\"src/app/app.component.html\">\n&#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let <a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a> of items; let i=index\">{{i + 1}} - {{item.name}}&#x3C;/div>\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\n`NgFor` is implemented by the `NgForOf` directive. Read more about the other `NgForOf` context values such as `last`, `even`,\nand `odd` in the [NgForOf API reference](api/common/NgForOf).\n-->\n<p><code>NgFor</code>는 <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> 디렉티브로 만들어진 또 다른 디렉티브입니다. <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> 컨텍스트에서 제공되는 변수인 <code>last</code>나 <code><a href=\"api/common/NgForOfContext#even\" class=\"code-anchor\">even</a></code>, <code><a href=\"api/common/NgForOfContext#odd\" class=\"code-anchor\">odd</a></code>에 대해 더 알아보려면 <a href=\"api/common/NgForOf\">NgForOf API 문서</a>를 참고하세요.</p>\n</div>\n<a id=\"trackBy\"></a>\n<!--\n#### *ngFor with `trackBy`\n-->\n<h4 id=\"ngfor와-trackby\">*ngFor와 <code>trackBy</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#ngfor와-trackby\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nIf you use `NgFor` with large lists, a small change to one item, such as removing or adding an item, can trigger a cascade of DOM manipulations. For example, re-querying the server could reset a list with all new item objects, even when those items were previously displayed. In this case, Angular sees only a fresh list of new object references and has no choice but to replace the old DOM elements with all new DOM elements.\n\nYou can make this more efficient with `trackBy`.\nAdd a method to the component that returns the value `NgFor` should track.\nIn this case, that value is the hero's `id`. If the `id` has already been rendered,\nAngular keeps track of it and doesn't re-query the server for the same `id`.\n\n<code-example path=\"built-in-directives/src/app/app.component.ts\" region=\"trackByItems\" header=\"src/app/app.component.ts\">\ntrackByItems(index: number, item: Item): number { return item.id; }\n\n</code-example>\n\nIn the microsyntax expression, set `trackBy` to the `trackByItems()` method.\n\n<code-example path=\"built-in-directives/src/app/app.component.html\" region=\"trackBy\" header=\"src/app/app.component.html\">\n&lt;div *ngFor=&quot;let item of items; trackBy: trackByItems&quot;&gt;\n  ({{item.id}}) {{item.name}}\n&lt;/div&gt;\n\n</code-example>\n\nHere is an illustration of the `trackBy` effect.\n\"Reset items\" creates new items with the same `item.id`s.\n\"Change ids\" creates new items with new `item.id`s.\n\n* With no `trackBy`, both buttons trigger complete DOM element replacement.\n* With `trackBy`, only changing the `id` triggers element replacement.\n-->\n<p><code>NgFor</code>로 복잡한 배열을 순회하면서 이 배열에 있는 항목을 추가하거나 제거하는 경우에는 관련된 DOM 전체가 변화 감지 로직의 대상이 됩니다.\n화면에 표시하는 목록을 무시하고 서버에 새로 데이터를 받아 화면을 전체 갱신하는 경우라면 기존에 있는 항목은 그대로 두고 새로운 항목만 DOM 엘리먼트를 생성하게 할 수 있습니다.</p>\n<p><code>trackBy</code>는 이런 경우에 사용합니다.\n컴포넌트 클래스에 <code>NgFor</code>가 추적하는 값을 반환하는 메소드를 정의합니다.\n지금 예제에서는 히어로의 <code>id</code>입니다.\n그러면 <code>id</code>에 해당하는 히어로가 화면에 표시되고 있으면 이 항목을 변경하지 않고 그대로 두게 됩니다.</p>\n<code-example path=\"built-in-directives/src/app/app.component.ts\" region=\"trackByItems\" header=\"src/app/app.component.ts\">\ntrackByItems(index: number, <a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>: Item): number { return item.id; }\n\n</code-example>\n<p>그리고 세부문법으로 <code>trackBy</code>에 <code>trackByItems()</code> 메소드를 지정합니다.</p>\n<code-example path=\"built-in-directives/src/app/app.component.html\" region=\"trackBy\" header=\"src/app/app.component.html\">\n&#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let <a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a> of items; trackBy: trackByItems\">\n  ({{item.id}}) {{item.name}}\n&#x3C;/div>\n\n</code-example>\n<p><code>trackBy</code>가 동작하는 모습을 살펴봅시다.\n\"Reset items\" 버튼을 클릭하면 기존에 있던 <code>item.id</code>와 같은 값으로 항목을 생성합니다.\n그리고 \"Change ids\" 버튼을 누르면 새로운 <code>item.id</code>로 항목을 생성합니다.</p>\n<ul>\n<li><code>trackBy</code>가 사용되지 않은 곳에서는 두 버튼이 모두 DOM 엘리먼트를 갱신합니다.</li>\n<li><code>trackBy</code>가 사용된 곳에서는 <code>id</code>가 바뀐 경우에만 엘리먼트가 갱신됩니다.</li>\n</ul>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/built-in-directives/ngfor-trackby.gif\" alt=\"Animation of trackBy\" width=\"492\" height=\"442\">\n</div>\n<div class=\"alert is-helpful\">\n<!--\nBuilt-in directives use only public APIs; that is,\nthey do not have special access to any private APIs that other directives can't access.\n-->\n<p>기본 디렉티브는 public API만 사용합니다. 다른 디렉티브의 private API에는 접근할 수 없습니다.</p>\n</div>\n<hr>\n<a id=\"ngSwitch\"></a>\n<!--\n## The `NgSwitch` directives\n-->\n<h3 id=\"ngswitch-디렉티브\"><code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code> 디렉티브<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#ngswitch-디렉티브\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nNgSwitch is like the JavaScript `switch` statement.\nIt displays one element from among several possible elements, based on a switch condition.\nAngular puts only the selected element into the DOM.\n-->\n<p><em>NgSwitch</em> 디렉티브는 JavaScript의 <code>switch</code> 문법과 비슷합니다.\n이 디렉티브는 가능한 경우 몇가지 중에서 <em>스위치 조건</em> 에 만족하는 엘리먼트 <em>하나를</em> 뷰에 표시합니다.\n이 때 <em>선택된</em> 엘리먼트만 DOM에 추가되며, 조건을 만족하지 않는 엘리먼트들은 DOM에 존재하지 않습니다.</p>\n<!-- API Flagged -->\n<!--\n`NgSwitch` is actually a set of three, cooperating directives:\n`NgSwitch`, `NgSwitchCase`, and `NgSwitchDefault` as in the following example.\n-->\n<p><code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code>는 일반적으로 <code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code>, <code><a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">NgSwitchCase</a></code>, <code><a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">NgSwitchDefault</a></code> 3개의 디렉티브를 함께 의미합니다:</p>\n<code-example path=\"built-in-directives/src/app/app.component.html\" region=\"NgSwitch\" header=\"src/app/app.component.html\">\n&#x3C;div [<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a>]=\"currentItem.feature\">\n  &#x3C;app-stout-item    *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'stout'\"    [<a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>]=\"currentItem\">&#x3C;/app-stout-item>\n  &#x3C;app-device-item   *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'slim'\"     [<a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>]=\"currentItem\">&#x3C;/app-device-item>\n  &#x3C;app-lost-item     *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'vintage'\"  [<a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>]=\"currentItem\">&#x3C;/app-lost-item>\n  &#x3C;app-best-item     *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'bright'\"   [<a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>]=\"currentItem\">&#x3C;/app-best-item>\n&#x3C;!-- . . . -->\n  &#x3C;app-unknown-item  *<a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">ngSwitchDefault</a>           [<a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>]=\"currentItem\">&#x3C;/app-unknown-item>\n&#x3C;/div>\n\n</code-example>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/built-in-directives/ngswitch.gif\" alt=\"Animation of NgSwitch\" width=\"370\" height=\"256\">\n</div>\n<!--\n`NgSwitch` is the controller directive. Bind it to an expression that returns\nthe *switch value*, such as `feature`. Though the `feature` value in this\nexample is a string, the switch value can be of any type.\n\n**Bind to `[ngSwitch]`**. You'll get an error if you try to set `*ngSwitch` because\n`NgSwitch` is an *attribute* directive, not a *structural* directive.\nRather than touching the DOM directly, it changes the behavior of its companion directives.\n\n**Bind to `*ngSwitchCase` and `*ngSwitchDefault`**.\nThe `NgSwitchCase` and `NgSwitchDefault` directives are _structural_ directives\nbecause they add or remove elements from the DOM.\n\n* `NgSwitchCase` adds its element to the DOM when its bound value equals the switch value and removes\nits bound value when it doesn't equal the switch value.\n\n* `NgSwitchDefault` adds its element to the DOM when there is no selected `NgSwitchCase`.\n\nThe switch directives are particularly useful for adding and removing *component elements*.\nThis example switches among four `item` components defined in the `item-switch.components.ts` file.\nEach component has an `item` [input property](guide/template-syntax#inputs-outputs \"Input property\")\nwhich is bound to the `currentItem` of the parent component.\n\nSwitch directives work as well with native elements and web components too.\nFor example, you could replace the `<app-best-item>` switch case with the following.\n-->\n<p><code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code>는 해당하는 조건을 선택하는 디렉티브입니다. 이 디렉티브는 템플릿 표현식이 반환하는 값에 해당하는 <em>특정 조건</em>을 선택합니다.\n위 예제에서는 문자열 타입의 <code>emotion</code> 변수로 조건을 판단했지만, 타입은 자유롭게 사용할 수 있습니다.</p>\n<p>스위칭 조건을 판단하는 템플릿 표현식은 <strong><code>[<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a>]</code></strong> 와 같이 바인딩합니다.\n이 때 문법을 <code>*<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a></code>로 사용해도 되지 않을까 생각할 수 있지만, <code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code>는 <em>구조</em> 디렉티브가 아니라 <em>어트리뷰트</em> 디렉티브이기 때문에 <code>*<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a></code>로 사용하면 에러가 발생합니다.\n<code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code>는 DOM을 직접 조작하는 디렉티브가 아니라 <code><a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">NgSwitchCase</a></code>와 <code><a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">NgSwitchDefault</a></code> 디렉티브의 동작을 변경하는 디렉티브입니다.</p>\n<p><code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code>와는 다르게 <code><a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">NgSwitchCase</a></code>와 <code><a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">NgSwitchDefault</a></code>는 <em>구조</em> 디렉티브이며, <code>*<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a></code>, <code>*<a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">ngSwitchDefault</a></code>와 같이 사용합니다.\n두 디렉티브는 DOM에 엘리먼트를 직접 추가하거나 제거하는 디렉티브입니다.</p>\n<ul>\n<li><code><a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">NgSwitchCase</a></code>는 스위칭 조건이 맞을 때 해당 엘리먼트를 DOM에 추가하며, 조건에 맞지 않으면 해당 엘리먼트를 제거합니다.</li>\n<li><code><a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">NgSwitchDefault</a></code>는 <code><a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">NgSwitchCase</a></code>가 하나도 선택되지 않았을 때 DOM에 추가하는 엘리먼트를 지정합니다.</li>\n</ul>\n<p>스위치 디렉티브는 <em>컴포넌트 엘리먼트를</em> DOM에 추가하거나 제거하는 용도로도 많이 사용합니다.\n위에서 살펴본 예제는 <code>item-switch.component.ts</code> 파일에 정의된 컴포넌트 4개를 하나씩 선택해서 적용하는 예제입니다.\n각각의 컴포넌트는 부모 컴포넌트에서 전달되는 <code>currentItem</code> 프로퍼티를 <code><a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a></code>를 <a href=\"guide/template-syntax#inputs-outputs\" title=\"Input property\">입력 프로퍼티</a>로 바인딩합니다.</p>\n<p>그리고 스위치 디렉티브는 네이티브 엘리먼트나 웹 컴포넌트에도 자연스럽게 적용할 수 있습니다.\n위 예제에서 <code>&#x3C;confused-hero></code>에 사용했던 스위치 디렉티브는 다음과 같이 네이티브 엘리먼트에도 사용할 수 있습니다.</p>\n<code-example path=\"built-in-directives/src/app/app.component.html\" region=\"NgSwitch-div\" header=\"src/app/app.component.html\">\n&#x3C;div *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'bright'\"> Are you as bright as {{currentItem.name}}?&#x3C;/div>\n\n</code-example>\n<hr>\n<a id=\"template-reference-variable\"></a>\n<a id=\"template-reference-variables--var-\"></a>\n<a id=\"ref-vars\"></a>\n<a id=\"ref-var\"></a>\n<!--\n## Template reference variables (`#var`)\n-->\n<h2 id=\"템플릿-참조-변수-var\">템플릿 참조 변수 (<code>#var</code>)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#템플릿-참조-변수-var\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nA **template reference variable** is often a reference to a DOM element within a template.\nIt can also refer to a directive (which contains a component), an element, [TemplateRef](api/core/TemplateRef), or a <a href=\"https://developer.mozilla.org/en-US/docs/Web/Web_Components\" title=\"MDN: Web Components\">web component</a>.\n\nFor a demonstration of the syntax and code snippets in this section, see the <live-example name=\"template-reference-variables\">template reference variables example</live-example>.\n\n\nUse the hash symbol (#) to declare a reference variable.\nThe following reference variable, `#phone`, declares a `phone` variable on an `<input>` element.\n-->\n<p><strong>템플릿 참조 변수</strong>는 템플릿 안에서 DOM 엘리먼트를 가리킬 때 사용합니다.\n그리고 디렉티브나 엘리먼트, <a href=\"api/core/TemplateRef\">TemplateRef</a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/Web_Components\" title=\"MDN: Web Components\">웹 컴포넌트</a>를 가리킬 때도 사용합니다.</p>\n<p>이 섹션에서 설명하는 내용을 직접 확인하려면 <live-example name=\"template-reference-variables\">템플릿 참조 변수 예제</live-example>를 참고하세요.</p>\n<p>참조 변수는 해시 기호(#)를 사용해서 정의합니다.\n예를 들어, <code>&#x3C;input></code> 엘리먼트를 <code>phone</code> 변수로 가리키려면 <code>#phone</code> 과 같이 정의합니다.</p>\n<code-example path=\"template-reference-variables/src/app/app.component.html\" region=\"ref-var\" header=\"src/app/app.component.html\">\n&#x3C;input #phone placeholder=\"phone number\" />\n\n</code-example>\n<!--\nYou can refer to a template reference variable anywhere in the component's template.\nHere, a `<button>` further down the template refers to the `phone` variable.\n-->\n<p>컴포넌트 템플릿에서는 어디에서라도 템플릿 참조 변수를 사용할 수 있습니다.\n아래 예제에서 <code>&#x3C;button></code> 엘리먼트는 <code>phone</code>으로 지정된 엘리먼트의 값을 참조합니다.</p>\n<code-example path=\"template-reference-variables/src/app/app.component.html\" region=\"ref-phone\" header=\"src/app/app.component.html\">\n&#x3C;input #phone placeholder=\"phone number\" />\n\n&#x3C;!-- 다른 엘리먼트들 -->\n\n&#x3C;!-- input 엘리먼트는 이벤트 핸들러에 phone 엘리먼트의 `value`를 전달합니다. -->\n&#x3C;button (click)=\"callPhone(phone.value)\">Call&#x3C;/button>\n\n</code-example>\n<!--\n<h3 class=\"no-toc\">How a reference variable gets its value</h3>\n-->\n<h3 class=\"no-toc\" id=\"참조-변수를-사용해서-입력값-얻기\">참조 변수를 사용해서 입력값 얻기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#참조-변수를-사용해서-입력값-얻기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn most cases, Angular sets the reference variable's value to the element on which it is declared.\nIn the previous example, `phone` refers to the phone number `<input>`.\nThe button's click handler passes the `<input>` value to the component's `callPhone()` method.\n\nThe `NgForm` directive can change that behavior and set the value to something else. In the following example, the template reference variable, `itemForm`, appears three times separated\nby HTML.\n-->\n<p>템플릿 참조 변수는 일반적으로 엘리먼트의 값을 가져오기 위해 선언합니다.\n이전 예제에서도 <code>&#x3C;input></code>에 입력된 값을 얻기 위해 <code>phone</code> 변수를 선언했습니다.\n<code>&#x3C;input></code> 엘리먼트에서 가져온 값은 버튼을 클릭했을 때 실행되는 핸들러 함수로 전달해서 컴포넌트의 <code>callPhone()</code> 메소드를 실행합니다.</p>\n<p><code><a href=\"api/forms/NgForm\" class=\"code-anchor\">NgForm</a></code> 디렉티브를 사용해서 이 동작을 다른 방식으로 구현하는 방법에 대해 알아봅시다.\n아래 예제에서는 템플릿 참조 변수 <code>itemForm</code>는 3번 사용되었습니다.</p>\n<code-example path=\"template-reference-variables/src/app/app.component.html\" region=\"ngForm\" header=\"src/app/hero-form.component.html\">\n&#x3C;form #itemForm=\"<a href=\"api/forms/NgForm\" class=\"code-anchor\">ngForm</a>\" (ngSubmit)=\"onSubmit(itemForm)\">\n  &#x3C;label for=\"name\"\n    >Name &#x3C;input class=\"form-control\" name=\"name\" <a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a> required />\n  &#x3C;/label>\n  &#x3C;button type=\"submit\">Submit&#x3C;/button>\n&#x3C;/form>\n\n&#x3C;div [hidden]=\"!itemForm.form.valid\">\n  &#x3C;p>{{ submitMessage }}&#x3C;/p>\n&#x3C;/div>\n\n\n</code-example>\n<!--\nThe reference value of itemForm, without the ngForm attribute value, would be\nthe [HTMLFormElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement).\nThere is, however, a difference between a Component and a Directive in that a `Component`\nwill be referenced without specifying the attribute value, and a `Directive` will not\nchange the implicit reference (that is, the element).\n\n\n\nHowever, with `NgForm`, `itemForm` is a reference to the [NgForm](api/forms/NgForm \"API: NgForm\")\ndirective with the ability to track the value and validity of every control in the form.\n\nThe native `<form>` element doesn't have a `form` property, but the `NgForm` directive does, which allows disabling the submit button\nif the `itemForm.form.valid` is invalid and passing the entire form control tree\nto the parent component's `onSubmit()` method.\n\n\n<h3 class=\"no-toc\">Template reference variable considerations</h3>\n\nA template _reference_ variable (`#phone`) is not the same as a template _input_ variable (`let phone`) such as in an [`*ngFor`](guide/template-syntax#template-input-variable).\nSee [_Structural Directives_](guide/structural-directives#template-input-variable) for more information.\n\nThe scope of a reference variable is the entire template. So, don't define the same variable name more than once in the same template as the runtime value will be unpredictable.\n-->\n<p>이 예제는 <code><a href=\"api/forms/NgForm\" class=\"code-anchor\">ngForm</a></code> 어트리뷰트를 사용하지 않고 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement\">HTMLFormElement</a>에 템플릿 참조 변수 <code>itemForm</code>를 지정했습니다.\n이 코드에는 일반적으로 사용하는 <code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code>이나 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code>이 사용되지 않았습니다.</p>\n<p>하지만 <code>itemForm</code>이 <a href=\"api/forms/NgForm\" title=\"API: NgForm\">NgForm</a>을 직접 참조하기 때문에 값이 변경되는 것을 감지하고 유효성을 검사하는 로직은 모두 동일하게 동작합니다.</p>\n<p>표준 엘리먼트 <code>&#x3C;form></code>에는 <code>form</code> 프로퍼티가 없지만 <code><a href=\"api/forms/NgForm\" class=\"code-anchor\">NgForm</a></code>이 적용되었기 때문에 제출 버튼이 <code>itemForm.form.valid</code>라고 사용할 수 있으며, <code>onSubmit()</code> 메소드가 실행될 때는 <code>itemForm</code> 전체가 컴포넌트의 <code>onSubmit()</code> 메소드로 전달됩니다.</p>\n<h3 class=\"no-toc\" id=\"주의할-점\">주의할 점<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#주의할-점\"><i class=\"material-icons\">link</i></a></h3>\n<p>템플릿 <em>참조</em> 변수(<code>#phone</code>)는 <a href=\"guide/template-syntax#template-input-variable\"><code>*ngFor</code></a>에 사용된 템플릿 <em>입력</em> 변수(<code>let phone</code>)와는 다릅니다.\n자세한 내용은 <a href=\"guide/structural-directives#template-input-variable\"><em>구조 디렉티브</em></a> 문서를 참고하세요.</p>\n<p>템플릿 참조 변수의 스코프는 템플릿 전체입니다.\n그래서 같은 이름의 템플릿 참조 변수가 있으면 실행시점에 예기치 않은 문제가 발생할 수 있습니다.</p>\n<!--\n#### Alternative syntax\n-->\n<h4 id=\"대체-문법\">대체 문법<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#대체-문법\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nYou can use the `ref-` prefix alternative to `#`.\nThis example declares the `fax` variable as `ref-fax` instead of `#fax`.\n-->\n<p><code>#</code> 기호를 사용하는 것이 어색하다면 <code>ref-</code> 접두사를 대신 사용할 수도 있습니다.\n접두사를 사용해서 <code>ref-fax</code> 라고 작성하면 <code>#fax</code> 로 <code>fax</code> 변수를 정의한 것과 같습니다.</p>\n<code-example path=\"template-reference-variables/src/app/app.component.html\" region=\"ref-fax\" header=\"src/app/app.component.html\">\n&#x3C;input ref-fax placeholder=\"fax number\" />\n&#x3C;button (click)=\"callFax(fax.value)\">Fax&#x3C;/button>\n\n</code-example>\n<hr>\n<a id=\"inputs-outputs\"></a>\n<a id=\"input-and-output-properties\"></a>\n<!--\n## `@Input()` and `@Output()` properties\n-->\n<h2 id=\"input-output-프로퍼티\"><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>, <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 프로퍼티<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#input-output-프로퍼티\"><i class=\"material-icons\">link</i></a></h2>\n<!--\n`@Input()` and `@Output()` allow Angular to share data between the parent context\nand child directives or components. An `@Input()` property is writable\nwhile an `@Output()` property is observable.\n\nConsider this example of a child/parent relationship:\n\n```html\n<parent-component>\n  <child-component></child-component>\n</parent-component>\n\n```\n\nHere, the `<child-component>` selector, or child directive, is embedded\nwithin a `<parent-component>`, which serves as the child's context.\n\n`@Input()` and `@Output()` act as\nthe API, or application programming interface, of the child\ncomponent in that they allow the child to\ncommunicate with the parent. Think of `@Input()` and `@Output()` like ports\nor doorways&mdash;`@Input()` is the doorway into the component allowing data\nto flow in while `@Output()` is the doorway out of the component, allowing the\nchild component to send data out.\n\nThis section about `@Input()` and `@Output()` has its own <live-example name=\"inputs-outputs\"></live-example>. The following subsections highlight\nkey points in the sample app.\n-->\n<p><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터와 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터는 부모 컨텍스트가 자식 디렉티브나 컴포넌트와 데이터를 주고 받을 때 사용합니다.\n이 때 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 프로퍼티는 일반 데이터 타입이고 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 프로퍼티는 옵저버블 타입입니다.</p>\n<p>다음과 같은 부모/자식 관계에서 생각해 봅시다:</p>\n<code-example language=\"html\">\n&#x3C;parent-component>\n  &#x3C;child-component>&#x3C;/child-component>\n&#x3C;/parent-component>\n</code-example>\n<p>이 코드에서 <code>&#x3C;child-component></code> 셀렉터는 <code>&#x3C;parent-component></code> 안에 존재하는 자식 디렉티브이며, 이 디렉티브 안에 독립적인 컨텍스트가 존재합니다.</p>\n<p><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>과 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code>은 API(application programming interface)처럼 동작하기 때문에 자식 컴포넌트는 이 데코레이터를 사용해서 부모 컴포넌트와 통신할 수 있습니다.\n나눠서 살펴보면, <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>은 컴포넌트로 데이터가 들어오는 문이고 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code>은 컴포넌트에서 데이터가 나가는 문이라고 이해할 수 있습니다.</p>\n<p>이 섹션에서 설명하는 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>과 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code>이 어떻게 동작하는지 직접 확인하려면 <live-example name=\"inputs-outputs\"></live-example>를 참고하세요.</p>\n<div class=\"alert is-helpful\">\n<!--\n#### `@Input()` and `@Output()` are independent\n-->\n<h4 id=\"input과-output은-독립적입니다\"><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>과 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code>은 독립적입니다.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#input과-output은-독립적입니다\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThough `@Input()` and `@Output()` often appear together in apps, you can use\nthem separately. If the nested\ncomponent is such that it only needs to send data to its parent, you wouldn't\nneed an `@Input()`, only an `@Output()`. The reverse is also true in that if the\nchild only needs to receive data from the parent, you'd only need `@Input()`.\n-->\n<p><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>과 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code>은 컴포넌트 코드에 자주 사용되지만 두 데코레이터가 별개로 동작한다는 것을 명심해야 합니다.\n자식 컴포넌트가 부모 컴포넌트로 데이터를 보내기만 한다면 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>은 필요없고 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code>만 있으면 됩니다.\n그리고 자식 컴포넌트가 부모 컴포넌트에서 데이터를 받기만 한다면 반대로 <code>@Inupt()</code>만 있으면 됩니다.</p>\n</div>\n<a id=\"input\"></a>\n<!--\n## How to use `@Input()`\n-->\n<h2 id=\"input-사용하기\"><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 사용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#input-사용하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nUse the `@Input()` decorator in a child component or directive to let Angular know\nthat a property in that component can receive its value from its parent component.\nIt helps to remember that the data flow is from the perspective of the\nchild component. So an `@Input()` allows data to be input _into_ the\nchild component from the parent component.\n-->\n<p><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터를 사용하면 자식 컴포넌트가 디렉티브가 부모 컴포넌트로부터 어떤 데이터를 받아 프로퍼티 값으로 할당할 수 있습니다.\n이 때 데이터는 자식 컴포넌트로 향한다는 것이 중요합니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/inputs-outputs/input.svg\" alt=\"Input data flow diagram\" width=\"671\" height=\"346\">\n</div>\n<!--\nTo illustrate the use of `@Input()`, edit these parts of your app:\n\n* The child component class and template\n* The parent component class and template\n-->\n<p><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터가 동작하는 것을 확인하기 위해 앱을 수정해 봅시다.</p>\n<!--\n### In the child\n-->\n<h3 id=\"자식-컴포넌트에서\">자식 컴포넌트에서<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#자식-컴포넌트에서\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nTo use the `@Input()` decorator in a child component class, first import\n`Input` and then decorate the property with `@Input()`:\n-->\n<p>자식 컴포넌트 클래스에서 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터를 사용하려면 먼저 <code><a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 심볼을 로드하고 프로퍼티에 <code><a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>을 지정하면 됩니다:</p>\n<code-example path=\"inputs-outputs/src/app/item-detail/item-detail.component.ts\" region=\"use-input\" header=\"src/app/item-detail/item-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a> } from '@angular/core'; // <a href=\"api/core/Input\" class=\"code-anchor\">Input</a> 심볼을 로드합니다.\nexport class ItemDetailComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() <a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>: string; // 프로퍼티에 @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() 데코레이터를 지정합니다.\n}\n\n</code-example>\n<!--\nIn this case, `@Input()` decorates the property <code class=\"no-auto-link\">item</code>, which has\na type of `string`, however, `@Input()` properties can have any type, such as\n`number`, `string`, `boolean`, or `object`. The value for `item` will come from the parent component, which the next section covers.\n\nNext, in the child component template, add the following:\n-->\n<p>이 경우에 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터는 <code>string</code> 타입인 <code class=\"no-auto-link\">item</code> 프로퍼티에 지정되었지만, <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터는 <code><a href=\"api/common/DecimalPipe\" class=\"code-anchor\">number</a></code>나 <code>string</code>, <code>boolean</code>, <code>object</code> 타입에도 지정할 수 있습니다.</p>\n<p>그리고 컴포넌트 템플릿을 다음과 같이 수정합니다:</p>\n<code-example path=\"inputs-outputs/src/app/item-detail/item-detail.component.html\" region=\"property-in-template\" header=\"src/app/item-detail/item-detail.component.html\">\n&#x3C;p>\n  Today's <a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>: {{<a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>}}\n&#x3C;/p>\n\n</code-example>\n<!--\n### In the parent\n-->\n<h3 id=\"부모-컴포넌트에서\">부모 컴포넌트에서<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#부모-컴포넌트에서\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe next step is to bind the property in the parent component's template.\nIn this example, the parent component template is `app.component.html`.\n\nFirst, use the child's selector, here `<app-item-detail>`, as a directive within the\nparent component template. Then, use [property binding](guide/template-syntax#property-binding)\nto bind the property in the child to the property of the parent.\n\n<code-example path=\"inputs-outputs/src/app/app.component.html\" region=\"input-parent\" header=\"src/app/app.component.html\">\n&lt;app-item-detail [item]=&quot;currentItem&quot;&gt;&lt;/app-item-detail&gt;\n\n</code-example>\n\nNext, in the parent component class, `app.component.ts`, designate a value for `currentItem`:\n\n<code-example path=\"inputs-outputs/src/app/app.component.ts\" region=\"parent-property\" header=\"src/app/app.component.ts\">\nexport class AppComponent {\n  currentItem = &#39;Television&#39;;\n}\n\n</code-example>\n\nWith `@Input()`, Angular passes the value for `currentItem` to the child so that `item` renders as `Television`.\n\nThe following diagram shows this structure:\n\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/inputs-outputs/input-diagram-target-source.svg\" alt=\"Property binding diagram\">\n</div>\n\nThe target in the square brackets, `[]`, is the property you decorate\nwith `@Input()` in the child component. The binding source, the part\nto the right of the equal sign, is the data that the parent\ncomponent passes to the nested component.\n\nThe key takeaway is that when binding to a child component's property in a parent component&mdash;that is, what's\nin square brackets&mdash;you must\ndecorate the property with `@Input()` in the child component.\n-->\n<p>자식 컴포넌트를 수정하고 나면 이제 부모 컴포넌트 템플릿에서 프로퍼티를 바인딩해야 합니다.\n이 예제에서는 <code>app.component.html</code>를 부모 컴포넌트 템플릿으로 사용해 봅시다.</p>\n<p>먼저, 자식 컴포넌트가 사용된 셀렉터 <code>&#x3C;app-item-detail></code>을 부모 컴포넌트 템플릿에 추가합니다.\n그리고 이 때 <a href=\"guide/template-syntax#property-binding\">프로퍼티 바인딩</a>을 사용해서 부모 컴포넌트의 프로퍼티를 자식 컴포넌트로 바인딩합니다.</p>\n<code-example path=\"inputs-outputs/src/app/app.component.html\" region=\"input-parent\" header=\"src/app/app.component.html\">\n&#x3C;app-item-detail [<a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>]=\"currentItem\">&#x3C;/app-item-detail>\n\n</code-example>\n<p>그 다음에는 부모 컴포넌트 클래스 <code>app.component.ts</code>에 <code>currentItem</code> 프로퍼티를 선언합니다:</p>\n<code-example path=\"inputs-outputs/src/app/app.component.ts\" region=\"parent-property\" header=\"src/app/app.component.ts\">\nexport class AppComponent {\n  currentItem = 'Television';\n}\n\n</code-example>\n<p>그러면 자식 컴포넌트에서 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터를 사용했기 때문에 부모 컴포넌트의 <code>currentItem</code> 프로퍼티의 값이 자식 컴포넌트의 <code><a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a></code> 프로퍼티로 전달됩니다.</p>\n<p>아래 그림을 참고하세요:</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/inputs-outputs/input-diagram-target-source.svg\" alt=\"Property binding diagram\" width=\"502\" height=\"304\">\n</div>\n<p>바인딩 대상이 되는 프로퍼티는 대괄호 <code>[]</code>로 둘러싸인 <code><a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a></code>이며, 이 프로퍼티는 자식 컴포넌트 클래스에서 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터로 지정되어 있습니다.\n그리고 이 데이터의 소스는 등호 오른쪽에 있는 <code>currentItem</code>이며, 이 프로퍼티는 부모 컴포넌트에 있는 프로퍼티입니다.</p>\n<p>결국 부모 컴포넌트의 데이터를 자식 컴포넌트로 전달할 때는 대괄호 <code>[]</code>를 사용해서 프로퍼티 바인딩을 하며, 이 프로퍼티는 자식 컴포넌트 클래스에서 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터로 지정되어야 한다는 점이 가장 중요합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\n#### `OnChanges` and `@Input()`\n-->\n<h4 id=\"onchanges와-input\"><code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a></code>와 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#onchanges와-input\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nTo watch for changes on an `@Input()` property, use\n`OnChanges`, one of Angular's [lifecycle hooks](guide/lifecycle-hooks#onchanges).\n`OnChanges` is specifically designed to work with properties that have the\n`@Input()` decorator. See the [`OnChanges`](guide/lifecycle-hooks#onchanges) section of the [Lifecycle Hooks](guide/lifecycle-hooks) guide for more details and examples.\n-->\n<p><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터가 지정된 프로퍼티의 값이 변경되는 것을 감지하려면 Angular <a href=\"guide/lifecycle-hooks#onchanges\">라이프싸이클 후킹</a>으로 제공하는 <code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a></code>를 사용하면 됩니다.\n<code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a></code>는 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터가 지정된 프로퍼티가 동작하는 것을 감지하기 위해 특별히 만들어진 인터페이스입니다.\n자세한 내용은 <a href=\"guide/lifecycle-hooks\">라이프싸이클 후킹</a> 문서의 <a href=\"guide/lifecycle-hooks#onchanges\"><code>OnChanges</code></a> 섹션을 참고하세요.</p>\n</div>\n<a id=\"output\"></a>\n<a id=\"how-to-use-output\"></a>\n<!--\n## How to use `@Output()`\n-->\n<h2 id=\"output-사용하기\"><code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 사용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#output-사용하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nUse the `@Output()` decorator in the child component or directive to allow data to flow from\nthe child _out_ to the parent.\n\nAn `@Output()` property should normally be initialized to an Angular [`EventEmitter`](api/core/EventEmitter) with values flowing out of the component as [events](#event-binding).\n-->\n<p><code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터를 사용하면 자식 컴포넌트나 디렉티브에서 부모에게 데이터를 전달할 수 있습니다.</p>\n<p><code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터로 지정하는 프로퍼티는 일반적으로 Angular <a href=\"api/core/EventEmitter\"><code>EventEmitter</code></a> 타입으로 선언하며, 부모 컴포넌트에서는 이 <a href=\"guide/template-syntax#event-binding\">이벤트를 바인딩</a>하는 방식으로 데이터를 받습니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/inputs-outputs/output.svg\" alt=\"Output diagram\" width=\"666\" height=\"340\">\n</div>\n<!--\nJust like with `@Input()`, you can use `@Output()`\non a property of the child component but its type should be\n`EventEmitter`.\n\n`@Output()` marks a property in a child component as a doorway\nthrough which data can travel from the child to the parent.\nThe child component then has to raise an event so the\nparent knows something has changed. To raise an event,\n`@Output()` works hand in hand with `EventEmitter`,\nwhich is a class in `@angular/core` that you\nuse to emit custom events.\n\nWhen you use `@Output()`, edit these parts of your app:\n\n* The child component class and template\n* The parent component class and template\n\n\nThe following example shows how to set up an `@Output()` in a child\ncomponent that pushes data you enter in an HTML `<input>` to an array in the\nparent component.\n-->\n<p><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터와 마찬가지로 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터도 자식 컴포넌트의 프로퍼티에 지정하지만, <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터를 지정하는 프로퍼티는 반드시 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 타입이어야 합니다.</p>\n<p><code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터를 사용하면 자식 컴포넌트에 있는 프로퍼티를 외부와 연결된 문처럼 지정하는 것과 비슷합니다.\n그러면 자식 컴포넌트에서 무언가 변경되었을 때 이 문을 통해서 부모 컴포넌트에게 알릴 수 있는데, 이때 <code>@angular/core</code> 패키지가 제공하는 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code>를 사용해서 커스텀 이벤트를 발생시킵니다.</p>\n<p><code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code>이 동작하는 것을 확인하기 위해 앱을 수정해 봅시다.</p>\n<p>아래 예제에서 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터는 자식 컴포넌트에 사용하며, 이 데코레이터가 지정된 프로퍼티에서 전달되는 데이터는 <code>&#x3C;input></code> 엘리먼트를 통해 부모 컴포넌트로 전달됩니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nThe HTML element `<input>` and the Angular decorator `@Input()`\nare different. This documentation is about component communication in Angular as it pertains to `@Input()` and `@Output()`. For more information on the HTML element `<input>`, see the [W3C Recommendation](https://www.w3.org/TR/html5/sec-forms.html#the-input-element).\n-->\n<p>HTML 엘리먼트인 <code>&#x3C;input></code>과 Angular 데코레이터인 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>은 다릅니다.\n이 문서는 Angular가 제공하는 데코레이터인 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>과 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code>에 대해 설명합니다.\nHTML 엘리먼트 <code>&#x3C;input></code>에 대해 자세하게 알아보려면 <a href=\"https://www.w3.org/TR/html5/sec-forms.html#the-input-element\">W3C Recommendation</a>을 참고하세요.</p>\n</div>\n<!--\n### In the child\n-->\n<h3 id=\"자식-컴포넌트에서-1\">자식 컴포넌트에서<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#자식-컴포넌트에서-1\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThis example features an `<input>` where a user can enter a value and click a `<button>` that raises an event. The `EventEmitter` then relays the data to the parent component.\n\nFirst, be sure to import `Output` and `EventEmitter`\nin the child component class:\n\n```js\nimport { Output, EventEmitter } from '@angular/core';\n\n```\n\nNext, still in the child, decorate a property with `@Output()` in the component class.\nThe following example `@Output()` is called `newItemEvent` and its type is\n`EventEmitter`, which means it's an event.\n\n\n<code-example path=\"inputs-outputs/src/app/item-output/item-output.component.ts\" region=\"item-output\" header=\"src/app/item-output/item-output.component.ts\">\n\n@Output() newItemEvent = new EventEmitter&lt;string&gt;();\n\n\n</code-example>\n\nThe different parts of the above declaration are as follows:\n\n* `@Output()`&mdash;a decorator function marking the property as a way for data to go from the child to the parent\n* `newItemEvent`&mdash;the name of the `@Output()`\n* `EventEmitter<string>`&mdash;the `@Output()`'s type\n* `new EventEmitter<string>()`&mdash;tells Angular to create a new event emitter and that the data it emits is of type string. The type could be any type, such as `number`, `boolean`, and so on. For more information on `EventEmitter`, see the [EventEmitter API documentation](api/core/EventEmitter).\n\nNext, create an `addNewItem()` method in the same component class:\n\n<code-example path=\"inputs-outputs/src/app/item-output/item-output.component.ts\" region=\"item-output-class\" header=\"src/app/item-output/item-output.component.ts\">\nexport class ItemOutputComponent {\n\n  @Output() newItemEvent = new EventEmitter&lt;string&gt;();\n\n  addNewItem(value: string) {\n    this.newItemEvent.emit(value);\n  }\n}\n\n</code-example>\n\nThe `addNewItem()` function uses the `@Output()`, `newItemEvent`,\nto raise an event in which it emits the value the user\ntypes into the `<input>`. In other words, when\nthe user clicks the add button in the UI, the child lets the parent know\nabout the event and gives that data to the parent.\n-->\n<p>이번 예제에서는 <code>&#x3C;input></code> 엘리먼트에 사용자가 값을 입력하고 <code>&#x3C;button></code> 엘리먼트를 클릭하면 이벤트가 발생합니다.\n이벤트 데이터는 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 객체를 통해 부모 컴포넌트에 전달될 것입니다.</p>\n<p>먼저, 자식 컴포넌트 클래스에서 <code><a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code> 심볼과 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 심볼을 로드합니다:</p>\n<code-example language=\"js\">\nimport { <a href=\"api/core/Output\" class=\"code-anchor\">Output</a>, <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a> } from '@angular/core';\n</code-example>\n<p>그리고 자식 컴포넌트 클래스 프로퍼티 <code>newItemEvent</code>에 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터를 지정합니다.\n이 프로퍼티의 타입은 반드시 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code>여야 합니다.</p>\n<code-example path=\"inputs-outputs/src/app/item-output/item-output.component.ts\" region=\"item-output\" header=\"src/app/item-output/item-output.component.ts\">\n\n@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() newItemEvent = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;string>();\n\n\n</code-example>\n<p>이전에 살펴본 예제와는 이런점들이 다릅니다:</p>\n<ul>\n<li><code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code>—자식 컴포넌트에서 부모 컴포넌트로 향하는 데이터 전달 통로를 선언하는 데코레이터 함수입니다.</li>\n<li><code>newItemEvent</code>—<code><a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터가 지정된 프로퍼티입니다.</li>\n<li><code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;string></code>—<code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터가 지정된 프로퍼티의 타입입니다.</li>\n<li><code>new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;string>()</code>—Angular 이벤트 이미터의 인스턴스를 생성합니다. 이 예제에서는 전달되는 데이터의 타입으로 <code>string</code>을 지정했지만, 어떤 타입이던지 가능합니다. 더 자세한 내용은 <a href=\"api/core/EventEmitter\">EventEmitter API 문서</a>를 참소하세요.</li>\n</ul>\n<p>그리고 자식 컴포넌트 클래스에 <code>addNewItem()</code> 메소드를 정의합니다:</p>\n<code-example path=\"inputs-outputs/src/app/item-output/item-output.component.ts\" region=\"item-output-class\" header=\"src/app/item-output/item-output.component.ts\">\nexport class ItemOutputComponent {\n\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() newItemEvent = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;string>();\n\n  addNewItem(value: string) {\n    this.newItemEvent.emit(value);\n  }\n}\n\n</code-example>\n<p><code>addNewItem()</code>은 사용자가 <code>&#x3C;input></code> 엘리먼트에 입력한 값을 가져와서 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터가 지정된 <code>newItemEvent</code> 프로퍼티로 보냅니다.\n다르게 표현하자면, 사용자가 자식 컴포넌트 화면에서 버튼을 클릭하면 자식 컴포넌트가 이 값을 이벤트로 전달하면서 부모 컴포넌트에게 알리는 방식입니다.</p>\n<!--\n#### In the child's template\n-->\n<h4 id=\"자식-컴포넌트-템플릿에서\">자식 컴포넌트 템플릿에서<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#자식-컴포넌트-템플릿에서\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe child's template has two controls. The first is an HTML `<input>` with a\n[template reference variable](guide/template-syntax#ref-var) , `#newItem`,\nwhere the user types in an item name. Whatever the user types\ninto the `<input>` gets stored in the `#newItem` variable.\n\n<code-example path=\"inputs-outputs/src/app/item-output/item-output.component.html\" region=\"child-output\" header=\"src/app/item-output/item-output.component.html\">\n&lt;label&gt;Add an item: &lt;input #newItem&gt;&lt;/label&gt;\n&lt;button (click)=&quot;addNewItem(newItem.value)&quot;&gt;Add to parent&#39;s list&lt;/button&gt;\n\n</code-example>\n\nThe second element is a `<button>`\nwith an [event binding](guide/template-syntax#event-binding). You know it's\nan event binding because the part to the left of the equal\nsign is in parentheses, `(click)`.\n\nThe `(click)` event is bound to the `addNewItem()` method in the child component class which\ntakes as its argument whatever the value of `#newItem` is.\n\nNow the child component has an `@Output()`\nfor sending data to the parent and a method for raising an event.\nThe next step is in the parent.\n-->\n<p>자식 컴포넌트 템플릿에는 컨트롤이 2개 있는데, 하나는 사용자의 입력을 받는 HTML <code>&#x3C;input></code> 엘리먼트이고 이 엘리먼트에는 <a href=\"guide/template-syntax#ref-var\">템플릿 참조 변수</a> <code>#newItem</code>이 지정되어 있습니다. 따라서 사용자가 <code>&#x3C;input></code> 엘리먼트에 입력하는 값은 <code>#newItem</code> 변수에 저장됩니다.</p>\n<code-example path=\"inputs-outputs/src/app/item-output/item-output.component.html\" region=\"child-output\" header=\"src/app/item-output/item-output.component.html\">\n&#x3C;label>Add an <a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>: &#x3C;input #newItem>&#x3C;/label>\n&#x3C;button (click)=\"addNewItem(newItem.value)\">Add to parent's list&#x3C;/button>\n\n</code-example>\n<p>또 다른 하나는 <code>&#x3C;button></code> 엘리먼트이며 이 엘리먼트에는 <a href=\"guide/template-syntax#event-binding\">이벤트 바인딩</a>이 사용되었습니다.\n이벤트 바인딩문법은 <code>(click)</code>과 같이 이벤트 이름을 괄호로 둘러싼 문법을 사용하기 때문에 쉽게 구분할 수 있습니다.</p>\n<p><code>(click)</code> 이벤트는 자식 컴포넌트의 <code>addNewItem()</code> 메소드와 바인딩되어 있으며, 이 메소드를 실행할 때 <code>#newItem</code>의 값을 인자로 전달합니다.</p>\n<p>이제 자식 컴포넌트 클래스에 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code>이 사용되었기 때문에 부모 컴포넌트로 이벤트를 보낼 준비가 끝났습니다.\n이제 부모 컴포넌트를 수정해 봅시다.</p>\n<!--\n### In the parent\n-->\n<h3 id=\"부모-컴포넌트에서-1\">부모 컴포넌트에서<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#부모-컴포넌트에서-1\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn this example, the parent component is `AppComponent`, but you could use\nany component in which you could nest the child.\n\nThe `AppComponent` in this example features a list of `items`\nin an array and a method for adding more items to the array.\n\n<code-example path=\"inputs-outputs/src/app/app.component.ts\" region=\"add-new-item\" header=\"src/app/app.component.ts\">\nexport class AppComponent {\n  items = [&#39;item1&#39;, &#39;item2&#39;, &#39;item3&#39;, &#39;item4&#39;];\n\n  addItem(newItem: string) {\n    this.items.push(newItem);\n  }\n}\n\n</code-example>\n\nThe `addItem()` method takes an argument in the form of a string\nand then pushes, or adds, that string to the `items` array.\n-->\n<p>이 예제에서 부모 컴포넌트는 <code>AppComponent</code>를 사용했지만 부모 컴포넌트는 어떤 컴포넌트라도 가능합니다.</p>\n<p>이 예제의 <code>AppComponent</code>에는 <code>items</code> 프로퍼티가 배열 타입으로 선언되어 있으며 이 배열에 항목을 추가하는 메소드도 정의되어 있습니다.</p>\n<code-example path=\"inputs-outputs/src/app/app.component.ts\" region=\"add-new-item\" header=\"src/app/app.component.ts\">\nexport class AppComponent {\n  items = ['item1', 'item2', 'item3', 'item4'];\n\n  addItem(newItem: string) {\n    this.items.push(newItem);\n  }\n}\n\n</code-example>\n<p>이 때 <code>addItem()</code> 메소드는 폼에서 인자로 받은 문자열을 <code>items</code> 배열에 추가합니다.</p>\n<!--\n#### In the parent's template\n-->\n<h4 id=\"부모-컴포넌트-템플릿에서\">부모 컴포넌트 템플릿에서<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#부모-컴포넌트-템플릿에서\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nNext, in the parent's template, bind the parent's\nmethod to the child's event. Put the child selector, here `<app-item-output>`,\nwithin the parent component's\ntemplate, `app.component.html`.\n\n<code-example path=\"inputs-outputs/src/app/app.component.html\" region=\"output-parent\" header=\"src/app/app.component.html\">\n&lt;app-item-output (newItemEvent)=&quot;addItem($event)&quot;&gt;&lt;/app-item-output&gt;\n\n</code-example>\n\nThe event binding, `(newItemEvent)='addItem($event)'`, tells\nAngular to connect the event in the child, `newItemEvent`, to\nthe method in the parent, `addItem()`, and that the event that the child\nis notifying the parent about is to be the argument of `addItem()`.\nIn other words, this is where the actual hand off of data takes place.\nThe `$event` contains the data that the user types into the `<input>`\nin the child template UI.\n\nNow, in order to see the `@Output()` working, add the following to the parent's template:\n\n```html\n  <ul>\n    <li *ngFor=\"let item of items\">{{item}}</li>\n  </ul>\n  ```\n\nThe `*ngFor` iterates over the items in the `items` array. When you enter a value in the child's `<input>` and click the button, the child emits the event and the parent's `addItem()` method pushes the value to the `items` array and it renders in the list.\n-->\n<p>이제 자식 컴포넌트에서 올라오는 이벤트를 부모 컴포넌트의 메소드와 바인딩해봅시다.\n부모 컴포넌트의 템플릿 파일 <code>app.component.html</code>에 자식 컴포넌트 셀렉터 <code>&#x3C;app-item-output></code>을 추가합니다.</p>\n<code-example path=\"inputs-outputs/src/app/app.component.html\" region=\"output-parent\" header=\"src/app/app.component.html\">\n&#x3C;app-item-output (newItemEvent)=\"addItem($event)\">&#x3C;/app-item-output>\n\n</code-example>\n<p>이벤트 바인딩은 <code>(newItemEvent)='addItem($event)'</code>라는 방식으로 사용되었습니다.\n이 바인딩 표현식은 자식 컴포넌트에서 <code>newItemEvent</code>가 발생했을 때 부모 컴포넌트의 <code>addItem()</code>을 실행하는데, 이 때 자식 컴포넌트에서 받은 인자를 <code>addItem()</code>의 인자로 전달한다는 의미입니다.\n데이터가 실제로 전달되는 곳은 이 부분입니다.\n<code>$event</code>에는 사용자가 자식 컴포넌트 템플릿 화면의 <code>&#x3C;input></code> 엘리먼트에 입력한 값이 전달될 것입니다.</p>\n<p>이제 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터가 동작하는 것을 확인하기 위해 부모 컴포넌트 템플릿에 다음 코드를 추가합니다:</p>\n<code-example language=\"html\">\n  &#x3C;ul>\n    &#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let <a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a> of items\">{{<a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>}}&#x3C;/li>\n  &#x3C;/ul>\n</code-example>\n<p><code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>는 <code>items</code> 배열을 순회하는 디렉티브입니다.\n이제 자식 컴포넌트 <code>&#x3C;input></code> 엘리먼트에 값을 입력하고 버튼을 클릭하면 자식 컴포넌트에서 이벤트가 발생하면서 부모 컴포넌트의 <code>addItem()</code> 메소드를 실행하게 되고, <code>items</code> 배열에 추가된 항목이 화면에 표시될 것입니다.</p>\n<!--\n## `@Input()` and `@Output()` together\n-->\n<h2 id=\"input-output-함께-사용하기\"><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>, <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 함께 사용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#input-output-함께-사용하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nYou can use `@Input()` and `@Output()` on the same child component as in the following:\n\n<code-example path=\"inputs-outputs/src/app/app.component.html\" region=\"together\" header=\"src/app/app.component.html\">\n&lt;app-input-output [item]=&quot;currentItem&quot; (deleteRequest)=&quot;crossOffItem($event)&quot;&gt;&lt;/app-input-output&gt;\n\n</code-example>\n\nThe target, `item`, which is an `@Input()` property in the child component class, receives its value from the parent's property, `currentItem`. When you click delete, the child component raises an event, `deleteRequest`, which is the argument for the parent's `crossOffItem()` method.\n\nThe following diagram is of an `@Input()` and an `@Output()` on the same\nchild component and shows the different parts of each:\n\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/inputs-outputs/input-output-diagram.svg\" alt=\"Input/Output diagram\">\n</div>\n\nAs the diagram shows, use inputs and outputs together in the same manner as using them separately. Here, the child selector is `<app-input-output>` with `item` and `deleteRequest` being `@Input()` and `@Output()`\nproperties in the child component class. The property `currentItem` and the method `crossOffItem()` are both in the parent component class.\n\nTo combine property and event bindings using the banana-in-a-box\nsyntax, `[()]`, see [Two-way Binding](guide/template-syntax#two-way).\n\nFor more detail on how these work, see the previous sections on [Input](guide/template-syntax#input) and [Output](guide/template-syntax#output). To see it in action, see the <live-example name=\"inputs-outputs\">Inputs and Outputs Example</live-example>.\n-->\n<p><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>과 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>은 다음과 같이 동시에 사용할 수 있습니다:</p>\n<code-example path=\"inputs-outputs/src/app/app.component.html\" region=\"together\" header=\"src/app/app.component.html\">\n&#x3C;app-input-output [<a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>]=\"currentItem\" (deleteRequest)=\"crossOffItem($event)\">&#x3C;/app-input-output>\n\n</code-example>\n<p><code><a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a></code> 프로퍼티는 자식 컴포넌트 클래스에서 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터가 지정된 프로퍼티이며, 부모 컴포넌트의 프로퍼티 <code>currentItem</code>의 값을 받는 프로퍼티입니다.\n그리고 자식 컴포넌트 화면에서 삭제 버튼을 클릭하면 <code>deleteRequest</code> 이벤트가 발생하는데, 부모 컴포넌트는 이 이벤트가 발생했을 때 <code>crossOffItem()</code> 메소드를 실행합니다.</p>\n<p>아래 그림을 보면서 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터와 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터가 각각 어떻게 사용되었는지 확인해 보세요:</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/inputs-outputs/input-output-diagram.svg\" alt=\"Input/Output diagram\" width=\"800\" height=\"333\">\n</div>\n<p>그림에서 볼 수 있듯이 입력 프로퍼티와 출력 프로퍼티는 이전과 동일하게 작성되엇습니다.\n이 코드에서 자식 컴포넌트의 셀렉터는 <code>&#x3C;app-input-output></code>이며 이 컴포넌트 클래스에 있는 <code><a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a></code> 프로퍼티에는 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터가, <code>deleteRequest</code> 프로퍼티에는 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터가 사용되었습니다.\n<code>currentItem</code> 프로퍼티와 <code>crossOffItem()</code> 메소드는 부모 컴포넌트 클래스에 존재합니다.</p>\n<p>프로퍼티 바인딩과 이벤트 바인딩을 조합한 <code>[()]</code> 문법을 사용하려면 <a href=\"guide/template-syntax#two-way\">양방향 바인딩</a> 섹션을 참고하세요.</p>\n<p>두 방식이 어떻게 동작하는지 자세하게 알아보려면 이전에 설명했던 <a href=\"guide/template-syntax#input\">Input</a>과 <a href=\"guide/template-syntax#output\">Output</a> 섹션을 보면 됩니다.\n그리고 직접 동작하는 것을 확인하려면 <live-example name=\"inputs-outputs\">입출력 프로퍼티 예제</live-example>를 참고하세요.</p>\n<!--\n## `@Input()` and `@Output()` declarations\n-->\n<h2 id=\"input-output-대체-방법\"><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>, <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 대체 방법<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#input-output-대체-방법\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nInstead of using the `@Input()` and `@Output()` decorators\nto declare inputs and outputs, you can identify\nmembers in the `inputs` and `outputs` arrays\nof the directive metadata, as in this example:\n\n<code-example path=\"inputs-outputs/src/app/in-the-metadata/in-the-metadata.component.ts\" region=\"metadata\" header=\"src/app/in-the-metadata/in-the-metadata.component.ts\">\n// tslint:disable: no-inputs-metadata-property no-outputs-metadata-property\ninputs: [&#39;clearanceItem&#39;],\noutputs: [&#39;buyEvent&#39;]\n// tslint:enable: no-inputs-metadata-property no-outputs-metadata-property\n\n</code-example>\n\nWhile declaring `inputs` and `outputs` in the `@Directive` and `@Component`\nmetadata is possible, it is a better practice to use the `@Input()` and `@Output()`\nclass decorators instead, as follows:\n\n<code-example path=\"inputs-outputs/src/app/input-output/input-output.component.ts\" region=\"input-output\" header=\"src/app/input-output/input-output.component.ts\">\n@Input() item: string;\n@Output() deleteRequest = new EventEmitter&lt;string&gt;();\n\n</code-example>\n\nSee the [Decorate input and output properties](guide/styleguide#decorate-input-and-output-properties) section of the\n[Style Guide](guide/styleguide) for details.\n-->\n<p><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>, <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터를 사용하지 않고 입출력 프로퍼티를 지정하는 방법이 있습니다.\n이렇게 구현하려면 다음과 같이 디렉티브 메타데이터에 <code>inputs</code>와 <code>ouputs</code> 배열을 선언하면 됩니다:</p>\n<code-example path=\"inputs-outputs/src/app/in-the-metadata/in-the-metadata.component.ts\" region=\"metadata\" header=\"src/app/in-the-metadata/in-the-metadata.component.ts\">\n// tslint:disable: no-inputs-metadata-property no-outputs-metadata-property\ninputs: ['clearanceItem'],\noutputs: ['buyEvent']\n// tslint:enable: no-inputs-metadata-property no-outputs-metadata-property\n\n</code-example>\n<p><code>inputs</code>, <code>outputs</code> 배열을 선언하는 방식은 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code>와 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 메타데이터에 모두 사용할 수 있으며 이렇게 구현해도 입출력 프로퍼티는 이전과 같이 동작하지만, 다음과 같이 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>, <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터를 사용하는 방식을 권장합니다.</p>\n<code-example path=\"inputs-outputs/src/app/input-output/input-output.component.ts\" region=\"input-output\" header=\"src/app/input-output/input-output.component.ts\">\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() <a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>: string;\n@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() deleteRequest = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;string>();\n\n</code-example>\n<p>더 자세한 내용은 <a href=\"guide/styleguide\">스타일 가이드</a> 문서의 <a href=\"guide/styleguide#decorate-input-and-output-properties\">입출력 프로퍼티 지정하기</a> 섹션을 참고하세요.</p>\n<div class=\"alert is-helpful\">\n<!--\nIf you get a template parse error when trying to use inputs or outputs, but you know that the\nproperties do indeed exist, double check\nthat your properties are annotated with `@Input()` / `@Output()` or that you've declared\nthem in an `inputs`/`outputs` array:\n-->\n<p>입출력 프로퍼티를 지정했을 때 템플릿에서 파싱 에러가 발생한다면 먼저 이 프로퍼티들이 컴포넌트 클래스에 존재하는지 확인해 보세요.\n그리고 입출력 프로퍼티가 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>/<code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code>으로, 아니면 <code>inputs</code>/<code>outputs</code> 배열로 지정되었는지 확인해 보세요:</p>\n<code-example language=\"bash\">\nUncaught Error: Template parse errors:\nCan't bind to 'item' since it isn't a known property of 'app-item-detail'\n</code-example>\n</div>\n<a id=\"aliasing-io\"></a>\n<!--\n## Aliasing inputs and outputs\n-->\n<h2 id=\"입출력-프로퍼티-이름-변경하기\">입출력 프로퍼티 이름 변경하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#입출력-프로퍼티-이름-변경하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nSometimes the public name of an input/output property should be different from the internal name. While it is a best practice to avoid this situation, Angular does\noffer a solution.\n-->\n<p>어떤 경우에는 외부에 노출된 입출력 프로퍼티 이름과 컴포넌트 내부에 사용하는 이름이 달라야 하는 때가 있습니다.\n이런 경우에 활용할 수 있는 테크닉에 대해 알아봅시다.</p>\n<!--\n### Aliasing in the metadata\n-->\n<h3 id=\"메타데이터에서-변경하기\">메타데이터에서 변경하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#메타데이터에서-변경하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAlias inputs and outputs in the metadata using a colon-delimited (`:`) string with\nthe directive property name on the left and the public alias on the right:\n-->\n<p>메타데이터에서 콜론(<code>:</code>)으로 구분되는 문자열을 사용하면 디렉티브 프로퍼티의 이름을 변경할 수 있습니다.\n이 때 콜론 왼쪽에는 클래스 안에서 사용하는 이름을 지정하고 콜론 오른쪽에는 클래스 밖에서 사용할 이름을 지정합니다:</p>\n<code-example path=\"inputs-outputs/src/app/aliasing/aliasing.component.ts\" region=\"alias\" header=\"src/app/aliasing/aliasing.component.ts\">\n// tslint:disable: no-inputs-metadata-property no-outputs-metadata-property\ninputs: ['input1: saveForLaterItem'], // 프로퍼티<a href=\"\" class=\"code-anchor\">_</a>이름:클래스<a href=\"\" class=\"code-anchor\">_</a>밖에서<a href=\"\" class=\"code-anchor\">_</a>사용할<a href=\"\" class=\"code-anchor\">_</a>이름\noutputs: ['outputEvent1: saveForLaterEvent']\n// tslint:disable: no-inputs-metadata-property no-outputs-metadata-property\n\n</code-example>\n<!--\n### Aliasing with the `@Input()`/`@Output()` decorator\n-->\n<h3 id=\"inputoutput-데코레이터에서-변경하기\"><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>/<code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터에서 변경하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#inputoutput-데코레이터에서-변경하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou can specify the alias for the property name by passing the alias name to the `@Input()`/`@Output()` decorator. The internal name remains as usual.\n-->\n<p><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>/<code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터에 원하는 프로퍼티 이름을 사용하면 이 이름을 클래스 밖에서 사용할 수 있습니다.\n내부에서 사용하는 이름은 그대로 유지됩니다.</p>\n<code-example path=\"inputs-outputs/src/app/aliasing/aliasing.component.ts\" region=\"alias-input-output\" header=\"src/app/aliasing/aliasing.component.ts\">\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('wishListItem') input2: string; //  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>(클래스<a href=\"\" class=\"code-anchor\">_</a>밖에서<a href=\"\" class=\"code-anchor\">_</a>사용할<a href=\"\" class=\"code-anchor\">_</a>이름)\n@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>('wishEvent') outputEvent2 = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;string>(); //  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>(클래스<a href=\"\" class=\"code-anchor\">_</a>밖에서<a href=\"\" class=\"code-anchor\">_</a>사용할<a href=\"\" class=\"code-anchor\">_</a>이름) 프로퍼티<a href=\"\" class=\"code-anchor\">_</a>이름 = ...\n\n</code-example>\n<hr>\n<a id=\"expression-operators\"></a>\n<!--\n## Template expression operators\n-->\n<h2 id=\"템플릿-표현식-전용-연산자\">템플릿 표현식 전용 연산자<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#템플릿-표현식-전용-연산자\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe Angular template expression language employs a subset of JavaScript syntax supplemented with a few special operators\nfor specific scenarios. The next sections cover three of these operators:\n\n* [pipe](guide/template-syntax#pipe)\n* [safe navigation operator](guide/template-syntax#safe-navigation-operator)\n* [non-null assertion operator](guide/template-syntax#non-null-assertion-operator)\n-->\n<p>Angular의 템플릿 표현식은 JavaScript 문법의 서브셋(subset)이며 특정 시나리오를 위해 몇가지 연산자가 추가된 언어를 사용합니다.\n이 섹션은 다음 3개의 연산자에 대해 다룹니다:</p>\n<ul>\n<li><a href=\"guide/template-syntax#pipe\">파이프</a></li>\n<li><a href=\"guide/template-syntax#safe-navigation-operator\">안전 참조 연산자</a></li>\n<li><a href=\"guide/template-syntax#non-null-assertion-operator\">null 보장 연산자</a></li>\n</ul>\n<a id=\"pipe\"></a>\n<!--\n### The pipe operator (`|`)\n-->\n<h3 id=\"파이프-연산자-\">파이프 연산자 (<code>|</code>)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#파이프-연산자-\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe result of an expression might require some transformation before you're ready to use it in a binding.\nFor example, you might display a number as a currency, change text to uppercase, or filter a list and sort it.\n\nPipes are simple functions that accept an input value and return a transformed value.\nThey're easy to apply within template expressions, using the pipe operator (`|`):\n-->\n<p>템플릿 표현식의 결과값을 그대로 사용하지 않고 바인딩하기 전에 적당한 형태로 변환해야 하는 경우가 있습니다.\n숫자를 화폐 단위로 표시하거나, 문자열을 대문자로 변환하거나, 배열의 일부를 필터링하거나 정렬하는 경우가 이런 경우에 해당됩니다.</p>\n<p>파이프는 입력값을 간단하게 변환해서 새로운 값으로 반환하는 함수입니다.\n템플릿에서는 다음과 같이 <strong>파이프 연산자 (<code>|</code>)</strong>를 사용해서 적용할 수 있습니다:</p>\n<code-example path=\"template-expression-operators/src/app/app.component.html\" region=\"uppercase-pipe\" header=\"src/app/app.component.html\">\n&#x3C;p><a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a> through uppercase pipe: {{title | <a href=\"api/common/UpperCasePipe\" class=\"code-anchor\">uppercase</a>}}&#x3C;/p>\n\n</code-example>\n<!--\nThe pipe operator passes the result of an expression on the left to a pipe function on the right.\n-->\n<p>파이프 연산자 왼쪽에 있는 값은 파이프 연산자의 오른쪽으로 전달됩니다.</p>\n<!--\nYou can chain expressions through multiple pipes:\n-->\n<p>그래서 다음과 같이 파이프 여러개를 연달아 사용할 수도 있습니다:</p>\n<code-example path=\"template-expression-operators/src/app/app.component.html\" region=\"pipe-chain\" header=\"src/app/app.component.html\">\n&#x3C;!-- title 을 대문자로 변경한 후에 소문자로 변경합니다. -->\n&#x3C;p><a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a> through a pipe chain: {{title | <a href=\"api/common/UpperCasePipe\" class=\"code-anchor\">uppercase</a> | <a href=\"api/common/LowerCasePipe\" class=\"code-anchor\">lowercase</a>}}&#x3C;/p>\n\n</code-example>\n<!--\nAnd you can also [apply parameters](guide/pipes#parameterizing-a-pipe) to a pipe:\n-->\n<p>그리고 파이프 함수에 <a href=\"guide/pipes#%ED%8C%8C%EC%9D%B4%ED%94%84-%EC%9D%B8%EC%9E%90-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\">파이프 인자</a>를 전달해서 파이프의 동작을 구체적으로 지정할 수도 있습니다:</p>\n<code-example path=\"template-expression-operators/src/app/app.component.html\" region=\"date-pipe\" header=\"src/app/app.component.html\">\n&#x3C;!-- 파이프에 인자 사용하기 => \"February 25, 1980\" -->\n&#x3C;p>Manufacture date with date format pipe: {{item.manufactureDate | <a href=\"api/common/DatePipe\" class=\"code-anchor\">date</a>:'longDate'}}&#x3C;/p>\n\n</code-example>\n<!--\nThe `json` pipe is particularly helpful for debugging bindings:\n-->\n<p>바인딩되는 객체를 확인해야 할때 <code><a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code> 파이프를 사용하면 디버깅이 훨씬 편해집니다:</p>\n<code-example path=\"template-expression-operators/src/app/app.component.html\" region=\"json-pipe\" header=\"src/app/app.component.html\">\n&#x3C;p>Item json pipe: {{<a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a> | <a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a>}}&#x3C;/p>\n\n</code-example>\n<!--\nThe generated output would look something like this:\n-->\n<p>이 코드를 실행하면 화면에 다음과 같은 문자열이 표시됩니다:</p>\n<code-example language=\"json\">\n  { \"name\": \"Telephone\",\n    \"manufactureDate\": \"1980-02-25T05:00:00.000Z\",\n    \"price\": 98 }\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\nThe pipe operator has a higher precedence than the ternary operator (`?:`),\nwhich means `a ? b : c | x` is parsed as `a ? b : (c | x)`.\nNevertheless, for a number of reasons,\nthe pipe operator cannot be used without parentheses in the first and second operands of `?:`.\nA good practice is to use parentheses in the third operand too.\n-->\n<p>파이프 연산자는 삼항연산자(<code>?:</code>)보다 우선순위가 높기 때문에 <code>a ? b : c | x</code>는 <code>a ? b : (c | x)</code>로 처리됩니다.\n그리고 몇가지 이유때문에 파이프 연산자는 삼항연산자와 함께 사용할 때 첫번째 항목이나 두번째 항목에는 사용할 수 없습니다.\n파이프 연산자와 삼항연산자를 함께 사용할 때는 세번째 항목에만 파이프를 사용하거나 삼항연산자 전체에 파이프를 사용할 수 있습니다.</p>\n</div>\n<hr>\n<a id=\"safe-navigation-operator\"></a>\n<!--\n### The safe navigation operator ( `?` ) and null property paths\n-->\n<h3 id=\"안전참조-연산자로-null-프로퍼티-경로-다루기\">안전참조 연산자(<code>?</code>)로 null 프로퍼티 경로 다루기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#안전참조-연산자로-null-프로퍼티-경로-다루기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe Angular safe navigation operator, `?`, guards against `null` and `undefined`\nvalues in property paths. Here, it protects against a view render failure if `item` is `null`.\n-->\n<p>안전 참조 연산자(safe navigation operator, <code>?</code>)는 프로퍼티 경로에 있을 수 있는 <code>null</code>과 <code>undefined</code>를 방지할 때 사용합니다.\n<code><a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a></code>값이 <code>null</code>일 때 발생하는 렌더링 에러는 다음과 같이 방지할 수 있습니다:</p>\n<code-example path=\"template-expression-operators/src/app/app.component.html\" region=\"safe\" header=\"src/app/app.component.html\">\n&#x3C;p>The <a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a> name is: {{<a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>?.name}}&#x3C;/p>\n\n</code-example>\n<!--\nIf `item` is `null`, the view still renders but the displayed value is blank; you see only \"The item name is:\" with nothing after it.\n\nConsider the next example, with a `nullItem`.\n-->\n<p><code><a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a></code>의 값이 <code>null</code> 이라면 화면을 렌더링하는 데에 아무 문제가 없으며 \"The item name is:\" 뒤에 아무것도 표시되지 않을 것입니다.</p>\n<p>그리고 <code>nullItem</code>이 사용된 코드를 봅시다.</p>\n<code-example language=\"html\">\n  The null <a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a> name is {{nullItem.name}}\n</code-example>\n<!--\nSince there is no safe navigation operator and `nullItem` is `null`, JavaScript and Angular would throw a `null` reference error and break the rendering process of Angular:\n-->\n<p>이 코드에서 <code>nullItem</code> 값은 <code>null</code>이지만 안전 참조 연산자가 없기 때문에 JavaScript와 Angular가 <code>null</code> 참조 에러를 발생시키면서 화면 렌더링도 중단됩니다:</p>\n<code-example language=\"bash\">\n  TypeError: Cannot read property 'name' of null.\n</code-example>\n<!--\nSometimes however, `null` values in the property\npath may be OK under certain circumstances,\nespecially when the value starts out null but the data arrives eventually.\n\nWith the safe navigation operator, `?`, Angular stops evaluating the expression when it hits the first `null` value and renders the view without errors.\n\nIt works perfectly with long property paths such as `a?.b?.c?.d`.\n-->\n<p>참조 시작점이 되는 객체는 존재하지만 이 객체를 참조하는 중간에 <code>null</code> 값을 만나게 되는 경우도 있습니다.</p>\n<p>이런 경우에도 안전 참조 연산자 <code>?</code>를 사용하면 중간에 <code>null</code> 값이 있더라도 에러없이 화면 렌더링을 끝낼 수 있습니다.</p>\n<p><code>a?.b?.c?.d</code>와 같은 경우에도 완벽하게 동작합니다.</p>\n<hr>\n<a id=\"non-null-assertion-operator\"></a>\n<!--\n### The non-null assertion operator ( `!` )\n-->\n<h3 id=\"null-보장-연산자---\">null 보장 연산자 ( <code>!</code> )<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#null-보장-연산자---\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAs of Typescript 2.0, you can enforce [strict null checking](http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html \"Strict null checking in TypeScript\") with the `--strictNullChecks` flag. TypeScript then ensures that no variable is unintentionally null or undefined.\n\nIn this mode, typed variables disallow `null` and `undefined` by default. The type checker throws an error if you leave a variable unassigned or try to assign `null` or `undefined` to a variable whose type disallows `null` and `undefined`.\n\nThe type checker also throws an error if it can't determine whether a variable will be `null` or undefined at runtime. You tell the type checker not to throw an error by applying the postfix\n[non-null assertion operator, !](http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-assertion-operator \"Non-null assertion operator\").\n\nThe Angular non-null assertion operator, `!`, serves the same purpose in\nan Angular template. For example, after you use [*ngIf](guide/template-syntax#ngIf)\nto check that `item` is defined, you can assert that\n`item` properties are also defined.\n\n<code-example path=\"template-expression-operators/src/app/app.component.html\" region=\"non-null\" header=\"src/app/app.component.html\">\n&lt;!-- color 값이 없어도 에러가 발생하지 않습니다. --&gt;\n&lt;p *ngIf=&quot;item&quot;&gt;The item&#39;s color is: {{item!.color}}&lt;/p&gt;\n\n</code-example>\n\nWhen the Angular compiler turns your template into TypeScript code,\nit prevents TypeScript from reporting that `item` might be `null` or `undefined`.\n\nUnlike the [_safe navigation operator_](guide/template-syntax#safe-navigation-operator \"Safe navigation operator (?)\"),\nthe non-null assertion operator does not guard against `null` or `undefined`.\nRather, it tells the TypeScript type checker to suspend strict `null` checks for a specific property expression.\n\nThe non-null assertion operator, `!`, is optional with the exception that you must use it when you turn on strict null checks.\n-->\n<p>TypeScript 2.0 버전부터  <a href=\"http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html\" title=\"Strict null checking in TypeScript\">null 검사를 더 엄격하게</a>하는 옵션이 추가되었습니다. 옵션은 <code>--strictNullChecks</code>로 활성화하며, 이 옵션을 설정하면 객체의 값이 null이나 undefined이 되는 것을 방지합니다.</p>\n<p>이 모드를 활성화하면 타입을 지정한 변수에 null이나 undefined을 할당하는 것이 허용되지 않습니다. 그래서 변수의 값을 할당하지 않고 놔두거나, 변수에 null이나 undefined을 할당하는 코드가 있으면 타입을 체크할 때 오류가 발생합니다.</p>\n<p>그런데 TypeScript 컴파일러는 앱이 실행되는 시점에 변수의 값이 null이나 undefined가 될 수 있는 코드에서도 에러를 발생합니다.\n개발자는 발생하지 않는 경우라고 할 수 있지만 TypeScript 컴파일러가 알수는 없기 때문입니다.\n그래서 실행시점에서도 이 객체가 null이 되지 않는다는 것을 <a href=\"http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-assertion-operator\" title=\"Non-null assertion operator\">null 보장 연산자</a>를 사용해서 TypeScript 컴파일러에게 알려줘야 합니다.</p>\n<p>null 보장 연산자 <code>!</code>는 템플릿에서도 똑같은 역할을 합니다.\n그래서 <code><a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a></code>의 값이 유효한지 확인한 <a href=\"guide/template-syntax#ngIf\"><code>*ngIf</code></a> 안에 null 보장 연산자를 사용하면 에러 경고를 방지할 수 있습니다.</p>\n<code-example path=\"template-expression-operators/src/app/app.component.html\" region=\"non-null\" header=\"src/app/app.component.html\">\n&#x3C;!-- color 값이 없어도 에러가 발생하지 않습니다. -->\n&#x3C;p *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"<a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>\">The <a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>'s color is: {{<a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>!.color}}&#x3C;/p>\n\n</code-example>\n<p>이렇게 작성하면 Angular 컴파일러가 템플릿 코드를 TypeScript 코드로 변환할 때 <code><a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a></code> 프로퍼티의 값이 <code>null</code>이나 <code>undefined</code>가 아니라는 것을 TypeScript 컴파일러가 인식합니다.</p>\n<p>다만, null 보장 연산자는 <a href=\"guide/template-syntax#safe-navigation-operator\" title=\"Safe navigation operator (?)\"><em>안전 참조 연산자</em></a>와는 다르게 <code>null</code> 값이나 <code>undefined</code> 값을 방지하지는 않습니다.\nnull 보장 연산자는 단순하게 TypeScript 타입 체크 에러를 우회하는 역할만 합니다.</p>\n<p>null 보장 연산자는 꼭 사용할 필요 없이 <code>--strictNullChecks</code> 옵션을 사용했을 때만 사용하면 됩니다.</p>\n<p><a href=\"guide/template-syntax#top-of-page\">back to top</a></p>\n<hr>\n<a id=\"built-in-template-functions\"></a>\n<!--\n## Built-in template functions\n-->\n<h2 id=\"기본-템플릿-함수\">기본 템플릿 함수<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#기본-템플릿-함수\"><i class=\"material-icons\">link</i></a></h2>\n<a id=\"any-type-cast-function\"></a>\n<!--\n### The `$any()` type cast function\n-->\n<h3 id=\"any-타입-캐스팅-함수\"><code>$any</code> 타입 캐스팅 함수<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#any-타입-캐스팅-함수\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nSometimes a binding expression triggers a type error during [AOT compilation](guide/aot-compiler) and it is not possible or difficult to fully specify the type.\nTo silence the error, you can use the `$any()` cast function to cast\nthe expression to the [`any` type](http://www.typescriptlang.org/docs/handbook/basic-types.html#any) as in the following example:\n-->\n<p>바인딩 표현식을 사용하다보면 <a href=\"guide/aot-compiler\">AOT 컴파일러</a>로 컴파일할 때 변수 타입에 맞지 않다는 에러가 발생하지만, 이 객체의 타입을 특정지을 수 없는 경우가 종종 발생합니다.\n이 에러를 없애려면 <code>$any()</code> 타입 캐스팅 함수를 사용해서 바인딩 표현식의 결과값이 <a href=\"http://www.typescriptlang.org/docs/handbook/basic-types.html#any\"><code>any</code> 타입</a>이 되도록 변환할 수 있습니다.</p>\n<code-example path=\"built-in-template-functions/src/app/app.component.html\" region=\"any-type-cast-function-1\" header=\"src/app/app.component.html\">\n&#x3C;p>The <a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>'s undeclared best by date is: {{$any(<a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>).bestByDate}}&#x3C;/p>\n\n</code-example>\n<!--\nWhen the Angular compiler turns this template into TypeScript code,\nit prevents TypeScript from reporting that `bestByDate` is not a member of the `item`\nobject when it runs type checking on the template.\n\nThe `$any()` cast function also works with `this` to allow access to undeclared members of\nthe component.\n-->\n<p>Angular 컴파일러가 이 템플릿 코드를 TypeScript 코드로 변환하고 나면 <code><a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a></code> 객체에 <code>bestByDate</code> 멤버가 없더라도 이제는 에러를 발생시키지 않고 그대로 실행됩니다.</p>\n<p>그리고 템플릿에서 <code>this</code>를 사용해서 컴포넌트 클래스에 직접 접근할 때도 <code>$any</code> 캐스트 함수를 사용할 수 있습니다.</p>\n<code-example path=\"built-in-template-functions/src/app/app.component.html\" region=\"any-type-cast-function-2\" header=\"src/app/app.component.html\">\n&#x3C;p>The <a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>'s undeclared best by date is: {{$any(this).bestByDate}}&#x3C;/p>\n\n</code-example>\n<!--\nThe `$any()` cast function works anywhere in a binding expression where a method call is valid.\n-->\n<p><code>$any()</code> 캐스팅 함수는 함수를 실행할 수 있는 바인딩 표현식이라면 어디에나 자유롭게 사용할 수 있습니다.</p>\n<!--\n## SVG in templates\n-->\n<h2 id=\"svg를-템플릿으로-사용하기\">SVG를 템플릿으로 사용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#svg를-템플릿으로-사용하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nIt is possible to use SVG as valid templates in Angular. All of the template syntax below is\napplicable to both SVG and HTML. Learn more in the SVG [1.1](https://www.w3.org/TR/SVG11/) and\n[2.0](https://www.w3.org/TR/SVG2/) specifications.\n\nWhy would you use SVG as template, instead of simply adding it as image to your application?\n\nWhen you use an SVG as the template, you are able to use directives and bindings just like with HTML\ntemplates. This means that you will be able to dynamically generate interactive graphics.\n\nRefer to the sample code snippet below for a syntax example:\n\n<code-example path=\"template-syntax/src/app/svg.component.ts\" header=\"src/app/svg.component.ts\">\nimport { Component } from &#39;@angular/core&#39;;\n\n@Component({\n  selector: &#39;app-svg&#39;,\n  templateUrl: &#39;./svg.component.svg&#39;,\n  styleUrls: [&#39;./svg.component.css&#39;]\n})\nexport class SvgComponent {\n  fillColor = &#39;rgb(255, 0, 0)&#39;;\n\n  changeColor() {\n    const r = Math.floor(Math.random() * 256);\n    const g = Math.floor(Math.random() * 256);\n    const b = Math.floor(Math.random() * 256);\n    this.fillColor = `rgb(${r}, ${g}, ${b})`;\n  }\n}\n\n\n</code-example>\n\nAdd the following code to your `svg.component.svg` file:\n\n<code-example path=\"template-syntax/src/app/svg.component.svg\" header=\"src/app/svg.component.svg\">\n&lt;svg&gt;\n  &lt;g&gt;\n    &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;100&quot; [attr.fill]=&quot;fillColor&quot; (click)=&quot;changeColor()&quot; /&gt;\n    &lt;text x=&quot;120&quot; y=&quot;50&quot;&gt;click the rectangle to change the fill color&lt;/text&gt;\n  &lt;/g&gt;\n&lt;/svg&gt;\n\n\n</code-example>\n\nHere you can see the use of a `click()` event binding and the property binding syntax\n(`[attr.fill]=\"fillColor\"`).\n-->\n<p>Angular에서는 SVG 파일도 템플릿으로 사용할 수 있습니다.\n이 때 모든 템플릿 문법은 SVG와 HTML 표준을 그대로 따릅니다.\nSVG 스펙은 <a href=\"https://www.w3.org/TR/SVG11/\">1.1 스펙</a>과 <a href=\"https://www.w3.org/TR/SVG2/\">2.0 스펙</a>을 참고하세요.</p>\n<p>간단하게 이미지를 사용하는 대신 왜 템플릿에 SVG를 사용할까요?</p>\n<p>SVG를 템플릿으로 사용하면 일반 HTML 템플릿을 사용하듯이 이 템플릿에 디렉티브와 바인딩 문법을 사용할 수 있습니다.</p>\n<p>이런 컴포넌트 코드를 한 번 봅시다:</p>\n<code-example path=\"template-syntax/src/app/svg.component.ts\" header=\"src/app/svg.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-svg',\n  <a href=\"api/core/Component#templateUrl\" class=\"code-anchor\">templateUrl</a>: './svg.component.svg',\n  <a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a>: ['./svg.component.css']\n})\nexport class SvgComponent {\n  fillColor = 'rgb(255, 0, 0)';\n\n  changeColor() {\n    const r = Math.floor(Math.random() * 256);\n    const g = Math.floor(Math.random() * 256);\n    const b = Math.floor(Math.random() * 256);\n    this.fillColor = `rgb(${r}, ${g}, ${b})`;\n  }\n}\n\n\n</code-example>\n<p>그리고 <code>svg.component.svg</code> 파일은 이렇게 정의되어 있습니다:</p>\n<code-example path=\"template-syntax/src/app/svg.component.svg\" header=\"src/app/svg.component.svg\">\n&#x3C;svg>\n  &#x3C;g>\n    &#x3C;rect x=\"0\" y=\"0\" width=\"100\" height=\"100\" [attr.fill]=\"fillColor\" (click)=\"changeColor()\" />\n    &#x3C;text x=\"120\" y=\"50\">click the rectangle to change the fill color&#x3C;/text>\n  &#x3C;/g>\n&#x3C;/svg>\n\n\n</code-example>\n<p>이렇게 구현하면 <code>click()</code> 이벤트를 컴포넌트 클래스와 바인딩 할 수 있고, <code>[attr.fill]=\"fillColor\"</code>처럼 프로퍼티 바인딩도 할 수 있습니다.</p>\n\n</div>\n\n<!-- links to this doc:\n - api/common/NgForOf\n - api/common/NgIf\n - api/core/Input\n - api/core/Output\n - guide/accessibility\n - guide/ajs-quick-reference\n - guide/aot-compiler\n - guide/architecture-components\n - guide/architecture-next-steps\n - guide/attribute-directives\n - guide/component-interaction\n - guide/displaying-data\n - guide/forms\n - guide/glossary\n - guide/observables-in-angular\n - guide/pipes\n - guide/router\n - guide/structural-directives\n - guide/styleguide\n - guide/template-typecheck\n - guide/upgrade\n - guide/user-input\n - start\n - tutorial/toh-pt2\n - tutorial/toh-pt3\n - tutorial/toh-pt4\n - tutorial/toh-pt5\n-->\n<!-- links from this doc:\n - api/animations/style\n - api/common/DatePipe\n - api/common/DecimalPipe\n - api/common/JsonPipe\n - api/common/LowerCasePipe\n - api/common/NgClass\n - api/common/NgForOf\n - api/common/NgForOfContext#even\n - api/common/NgForOfContext#odd\n - api/common/NgIf\n - api/common/NgIf#ngIfElse\n - api/common/NgStyle\n - api/common/NgSwitch\n - api/common/NgSwitchCase\n - api/common/NgSwitchDefault\n - api/common/UpperCasePipe\n - api/core/Component\n - api/core/Component#interpolation\n - api/core/Component#styleUrls\n - api/core/Component#templateUrl\n - api/core/ContentChild\n - api/core/Directive\n - api/core/Directive#host\n - api/core/EventEmitter\n - api/core/Input\n - api/core/IterableChangeRecord#item\n - api/core/NgModule\n - api/core/OnChanges\n - api/core/Output\n - api/core/SecurityContext#HTML\n - api/core/TemplateRef\n - api/core/Type\n - api/core/ViewChild\n - api/forms/ControlValueAccessor\n - api/forms/FormControl\n - api/forms/FormGroup\n - api/forms/FormsModule\n - api/forms/NgForm\n - api/forms/NgModel\n - api/platform-browser/BrowserModule\n - api/platform-browser/Title\n - api/platform-server/PlatformConfig#document\n - api/router/RouterLinkActive#isActive\n - api/router/RouterLinkWithHref#target\n - guide/aot-compiler\n - guide/attribute-directives\n - guide/forms\n - guide/forms#ngModel\n - guide/glossary#camelcase\n - guide/glossary#dash-case\n - guide/lifecycle-hooks\n - guide/lifecycle-hooks#onchanges\n - guide/pipes#%ED%8C%8C%EC%9D%B4%ED%94%84-%EC%9D%B8%EC%9E%90-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\n - guide/router\n - guide/security\n - guide/security#sanitization-and-security-contexts\n - guide/structural-directives\n - guide/structural-directives#microsyntax\n - guide/structural-directives#ngcontainer\n - guide/structural-directives#one-per-element\n - guide/structural-directives#template-input-variable\n - guide/structural-directives#the-asterisk--prefix\n - guide/styleguide\n - guide/styleguide#decorate-input-and-output-properties\n - guide/template-syntax#any-타입-캐스팅-함수\n - guide/template-syntax#attribute-directives\n - guide/template-syntax#avoid-side-effects\n - guide/template-syntax#class-binding\n - guide/template-syntax#colspan과-colspan\n - guide/template-syntax#event-binding\n - guide/template-syntax#event-객체와-이벤트-처리-실행문\n - guide/template-syntax#eventemitter로-커스텀-이벤트-보내기\n - guide/template-syntax#expression-operators\n - guide/template-syntax#html-어트리뷰트-vs-dom-프로퍼티\n - guide/template-syntax#input\n - guide/template-syntax#input-output-대체-방법\n - guide/template-syntax#input-output-프로퍼티\n - guide/template-syntax#input-output-함께-사용하기\n - guide/template-syntax#input-사용하기\n - guide/template-syntax#inputoutput-데코레이터에서-변경하기\n - guide/template-syntax#inputs-outputs\n - guide/template-syntax#input과-output은-독립적입니다\n - guide/template-syntax#ngClass\n - guide/template-syntax#ngFor\n - guide/template-syntax#ngIf\n - guide/template-syntax#ngModel\n - guide/template-syntax#ngStyle\n - guide/template-syntax#ngSwitch\n - guide/template-syntax#ngclass\n - guide/template-syntax#ngfor\n - guide/template-syntax#ngfor와-index\n - guide/template-syntax#ngfor와-trackby\n - guide/template-syntax#ngif\n - guide/template-syntax#ngmodel-양방향-바인딩\n - guide/template-syntax#ngmodel과-밸류-액세서value-accessor\n - guide/template-syntax#ngmodel을-사용하려면-formsmodule을-로드해야-합니다\n - guide/template-syntax#ngstyle\n - guide/template-syntax#ngstyle을-사용하지-않는-방식\n - guide/template-syntax#ngswitch-디렉티브\n - guide/template-syntax#no-visible-side-effects\n - guide/template-syntax#non-null-assertion-operator\n - guide/template-syntax#null-방지\n - guide/template-syntax#null-보장-연산자---\n - guide/template-syntax#onchanges와-input\n - guide/template-syntax#output\n - guide/template-syntax#output-사용하기\n - guide/template-syntax#pipe\n - guide/template-syntax#property-binding\n - guide/template-syntax#quick-execution\n - guide/template-syntax#ref-var\n - guide/template-syntax#safe-navigation-operator\n - guide/template-syntax#showhide-vs-ngif\n - guide/template-syntax#simplicity\n - guide/template-syntax#structural-directives\n - guide/template-syntax#style-binding\n - guide/template-syntax#styling-delegation\n - guide/template-syntax#styling-precedence\n - guide/template-syntax#svg를-템플릿으로-사용하기\n - guide/template-syntax#template-expressions\n - guide/template-syntax#template-input-variable\n - guide/template-syntax#template-reference-variable\n - guide/template-syntax#top-of-page\n - guide/template-syntax#trackBy\n - guide/template-syntax#two-way\n - guide/template-syntax#간단하게\n - guide/template-syntax#객체-전달하기\n - guide/template-syntax#괄호를-깜빡하면-안됩니다\n - guide/template-syntax#기본-구조-디렉티브\n - guide/template-syntax#기본-디렉티브\n - guide/template-syntax#기본-어트리뷰트-디렉티브\n - guide/template-syntax#기본-템플릿-함수\n - guide/template-syntax#낮은-우선순위로-위임될-때\n - guide/template-syntax#단방향-전달\n - guide/template-syntax#대상-이벤트\n - guide/template-syntax#대체-문법\n - guide/template-syntax#데이터-바인딩과-html\n - guide/template-syntax#맞는-타입으로-반환하세요\n - guide/template-syntax#메타데이터에서-변경하기\n - guide/template-syntax#문자열-바인딩-\n - guide/template-syntax#문자열-바인딩과-템플릿-표현식\n - guide/template-syntax#문자열을-그대로-사용하는-경우\n - guide/template-syntax#바인딩-대상\n - guide/template-syntax#바인딩-문법--개요\n - guide/template-syntax#부모-컴포넌트-템플릿에서\n - guide/template-syntax#부모-컴포넌트에서\n - guide/template-syntax#부모-컴포넌트에서-1\n - guide/template-syntax#빠르게-실행되도록\n - guide/template-syntax#스타일-바인딩\n - guide/template-syntax#스타일-적용-우선순위\n - guide/template-syntax#스타일-적용-우선순위-높은-것부터-낮은-순으로\n - guide/template-syntax#안전참조-연산자로-null-프로퍼티-경로-다루기\n - guide/template-syntax#양방향-바인딩-\n - guide/template-syntax#양방향-바인딩-기본\n - guide/template-syntax#어트리뷰트-바인딩\n - guide/template-syntax#어트리뷰트-클래스-스타일-바인딩\n - guide/template-syntax#예제\n - guide/template-syntax#예제-1-input\n - guide/template-syntax#예제-2-버튼-비활성화\n - guide/template-syntax#외부-영향-최소화\n - guide/template-syntax#외부-영향-최소화-1\n - guide/template-syntax#이벤트-바인딩-event\n - guide/template-syntax#입출력-프로퍼티-이름-변경하기\n - guide/template-syntax#자식-컴포넌트-템플릿에서\n - guide/template-syntax#자식-컴포넌트에서\n - guide/template-syntax#자식-컴포넌트에서-1\n - guide/template-syntax#주의할-점\n - guide/template-syntax#참조-변수를-사용해서-입력값-얻기\n - guide/template-syntax#컨텐츠-보안\n - guide/template-syntax#클래스-바인딩\n - guide/template-syntax#타입별-바인딩-대상\n - guide/template-syntax#템플릿-문법\n - guide/template-syntax#템플릿-실행문-template-statements\n - guide/template-syntax#템플릿-실행문-가이드라인\n - guide/template-syntax#템플릿-실행문의-영향\n - guide/template-syntax#템플릿-실행문의-컨텍스트\n - guide/template-syntax#템플릿-입력-변수-template-input-variables\n - guide/template-syntax#템플릿-참조-변수-var\n - guide/template-syntax#템플릿-표현식-template-expressions\n - guide/template-syntax#템플릿-표현식-가이드라인\n - guide/template-syntax#템플릿-표현식-전용-연산자\n - guide/template-syntax#템플릿과-html\n - guide/template-syntax#파이프-연산자-\n - guide/template-syntax#폼에서-양방향-바인딩-사용하기\n - guide/template-syntax#표현식의-컨텍스트\n - guide/template-syntax#프로퍼티-바인딩-property\n - guide/template-syntax#프로퍼티-바인딩-vs-문자열-바인딩\n - http://www.typescriptlang.org/docs/handbook/basic-types.html#any\n - http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html\n - http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-assertion-operator\n - https://angular.io/api/forms/DefaultValueAccessor\n - https://developer.mozilla.org/en-US/docs/Web/API#Interfaces\n - https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement\n - https://developer.mozilla.org/en-US/docs/Web/API/HTMLTableCellElement\n - https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA\n - https://developer.mozilla.org/en-US/docs/Web/Events\n - https://developer.mozilla.org/en-US/docs/Web/HTML/Element/td\n - https://developer.mozilla.org/en-US/docs/Web/SVG\n - https://developer.mozilla.org/en-US/docs/Web/Web_Components\n - https://en.wikipedia.org/wiki/Idempotence\n - https://github.com/angular/angular/edit/master/aio/content/guide/template-syntax.md?message=docs%3A%20describe%20your%20change...\n - https://www.w3.org/TR/SVG11/\n - https://www.w3.org/TR/SVG2/\n - https://www.w3.org/TR/html5/sec-forms.html#the-input-element\n-->"
}