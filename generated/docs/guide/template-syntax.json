{
  "id": "guide/template-syntax",
  "title": "템플릿 문법",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/template-syntax.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Template Syntax\n-->\n<h1 id=\"템플릿-문법\">템플릿 문법<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#템플릿-문법\"><i class=\"material-icons\">link</i></a></h1>\n<style>\n  h4 {font-size: 17px !important; text-transform: none !important;}\n  .syntax { font-family: Consolas, 'Lucida Sans', Courier, sans-serif; color: black; font-size: 85%; }\n  h4 .syntax { font-size: 100%; }\n</style>\n<!--\nThe Angular application manages what the user sees and can do, achieving this through the interaction of a\ncomponent class instance (the *component*) and its user-facing template.\n-->\n<p>Angular 애플리케이션은 사용자의 행동에 반응하면서 화면에 데이터를 표시하는데, 이 과정은 컴포넌트 클래스와 템플릿이 상호작용하면서 이루어집니다.</p>\n<!--\nYou may be familiar with the component/template duality from your experience with model-view-controller (MVC) or model-view-viewmodel (MVVM).\nIn Angular, the component plays the part of the controller/viewmodel, and the template represents the view.\n-->\n<p>MVC(모델-뷰-컨트롤러)나 MVVM(모델-뷰-뷰모델) 구조를 다뤄봤다면 컴포넌트와 템플릿의 관계가 이미 익숙할 수도 있습니다.\nAngular에서는 컴포넌트가 컨트롤러나 뷰모델의 역할을 하고, 템플릿이 뷰 역할을 합니다.</p>\n<!--\nThis page is a comprehensive technical reference to the Angular template language.\nIt explains basic principles of the template language and describes most of the syntax that you'll encounter elsewhere in the documentation.\n-->\n<p>이 문서에서는 Angular 템플릿 문법의 기술적인 부분을 종합적으로 다룹니다.\n템플릿 문법의 기초부터 시작해서 다른 가이드 페이지에서도 등장하는 템플릿 문법 대부분을 이 문서에서 다룹니다.</p>\n<!--\nMany code snippets illustrate the points and concepts, all of them available\nin the <live-example title=\"Template Syntax Live Code\"></live-example>.\n-->\n<p>템플릿 문법의 개념을 확실하게 이해하기 위해 많은 코드를 살펴볼 것이며,\n이 문서에서 설명하는 코드는 <live-example title=\"Template Syntax Live Code\"></live-example> 에서 확인하거나 다운받을 수 있습니다.</p>\n<a id=\"html\"></a>\n<!--\n## HTML in templates\n-->\n<h2 id=\"템플릿과-html\">템플릿과 HTML<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#템플릿과-html\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nHTML is the language of the Angular template.\nAlmost all HTML syntax is valid template syntax.\nThe `<script>` element is a notable exception;\nit is forbidden, eliminating the risk of script injection attacks.\nIn practice, `<script>` is ignored and a warning appears in the browser console.\nSee the [Security](guide/security) page for details.\n-->\n<p>Angular 템플릿에는 HTML을 사용하며, 거의 모든 HTML 문법은 템플릿 문법에서도 유효합니다.\n다만 <code>&#x3C;script></code> 엘리먼트는 예외입니다. 이 엘리먼트는 스크립트 인젝션 공격에 노출될 수 있기 때문에 Angular 템플릿 문법에서 처리되지 않습니다.\nAngular 템플릿에 <code>&#x3C;script></code> 엘리먼트가 있어도 이 엘리먼트는 처리되지 않으며, 브라우저 콘솔에 경고 메시지를 출력합니다.\n더 자세한 내용은 <a href=\"guide/security\">보안</a> 문서를 확인하세요.</p>\n<!--\nSome legal HTML doesn't make much sense in a template.\nThe `<html>`, `<body>`, and `<base>` elements have no useful role.\nPretty much everything else is fair game.\n-->\n<p>Angular 템플릿에 유효하지 않은 HTML 엘리먼트는 몇가지 더 있습니다.\n<code>&#x3C;html></code> 이나 <code>&#x3C;body></code>, <code>&#x3C;base></code> 엘리먼트는 Angular 템플릿에 사용해도 에러나 경고가 표시되지 않지만, 별다른 역할을 하지는 않습니다.\n언급하지 않은 엘리먼트는 그대로 사용해도 됩니다.</p>\n<!--\nYou can extend the HTML vocabulary of your templates with components and directives that appear as new elements and attributes.\nIn the following sections, you'll learn how to get and set DOM (Document Object Model) values dynamically through data binding.\n-->\n<p>컴포넌트나 디렉티브를 정의하면 템플릿에 사용할 수 있는 HTML 엘리먼트를 새롭게 정의하거나 표준 HTML 엘리먼트에는 없던 속성을 추가할 수 있습니다.\n이 문서에서는 템플릿 문법을 하나씩 살펴보면서 DOM(Document Object Model) 값을 어떻게 참조하고 어떻게 원하는 값을 지정하는지 알아볼 것입니다.</p>\n<!--\nBegin with the first form of data binding&mdash;interpolation&mdash;to see how much richer template HTML can be.\n-->\n<p>가장 간단한 데이터 바인딩인 문자열 바인딩(interpolation)부터 살펴보면서 템플릿 HTML이 어떻게 확장되는지 알아봅시다.</p>\n<hr>\n<a id=\"interpolation\"></a>\n<a id=\"문자열-바인딩\"></a>\n<!--\n## Interpolation ( <span class=\"syntax\">{&#xfeff;{...}}</span> )\n-->\n<h2 id=\"문자열-바인딩interpolation----\">문자열 바인딩(Interpolation ( <span class=\"syntax\">{﻿{...}}</span> )<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#문자열-바인딩interpolation----\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nYou met the double-curly braces of interpolation, `{{` and `}}`, early in your Angular education.\n-->\n<p>다른 문서에서도 살펴봤듯이, 문자열 바인딩에는 이중 중괄호(<code>{{</code>, <code>}}</code>)를 사용합니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"first-interpolation\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;p>My current hero is {{currentHero.name}}&#x3C;/p>\n\n</code-example>\n<!--\nYou use interpolation to weave calculated strings into the text between HTML element tags and within attribute assignments.\n-->\n<p>그리고 HTML 엘리먼트 태그 안에 내용을 넣거나 어트리뷰트를 지정할 때도 문자열 바인딩을 사용할 수 있습니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"title+image\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;h3>\n  {{title}}\n  &#x3C;img src=\"{{heroImageUrl}}\" <a href=\"api/animations/style\" class=\"code-anchor\">style</a>=\"height:30px\">\n&#x3C;/h3>\n\n</code-example>\n<!--\nThe text between the braces is often the name of a component property. Angular replaces that name with the\nstring value of the corresponding component property. In the example above, Angular evaluates the `title` and `heroImageUrl` properties\nand \"fills in the blanks\", first displaying a bold application title and then a heroic image.\n-->\n<p>중괄호 안에는 컴포넌트 프로퍼티를 바인딩 할 수 있습니다. 프로퍼티 이름을 템플릿에 바인딩하면 Angular가 처리하면서 프로퍼티 이름을 프로퍼티 값으로 변경해서 템플릿에 적용합니다.\n위에서 살펴본 코드를 예로 들면, 템플릿에 사용된 <code>title</code> 프로퍼티의 값을 애플리케이션 제목으로 표시하고, <code>heroImageUrl</code> 프로퍼티에 지정된 주소를 찾아서 히어로의 이미지를 표시합니다.</p>\n<!--\nMore generally, the text between the braces is a **template expression** that Angular first **evaluates**\nand then **converts to a string**. The following interpolation illustrates the point by adding the two numbers:\n-->\n<p>좀 더 자세히 얘기하면 중괄호 안에 있는 <strong>템플릿 표현식</strong>은 Angular에서 가장 먼저 <strong>평가</strong>되며, 평가된 값은 <strong>문자열로 변환</strong>되어 템플릿에 반영됩니다. 이 때문에 문자열 바인딩은 문자열 삽입이라고도 하며, 문자열로 변환되는 특성 덕분에 두 숫자를 더하는 표현식도 템플릿에 바로 사용할 수 있습니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"sum-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- \"The sum of 1 + 1 is 2\" -->\n&#x3C;p>The sum of 1 + 1 is {{1 + 1}}&#x3C;/p>\n\n</code-example>\n<!--\nThe expression can invoke methods of the host component such as `getVal()`, seen here:\n-->\n<p>템플릿 표현식에서는 컴포넌트 메서드를 바로 실행할 수도 있습니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"sum-2\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- \"The sum of 1 + 1 is not 4\" -->\n&#x3C;p>The sum of 1 + 1 is not {{1 + 1 + getVal()}}&#x3C;/p>\n\n</code-example>\n<!--\nAngular evaluates all expressions in double curly braces,\nconverts the expression results to strings, and links them with neighboring literal strings. Finally,\nit assigns this composite interpolated result to an **element or directive property**.\n-->\n<p>이중 중괄호 안에 있는 템플릿 표현식은 Angular 프레임워크가 평가하고 문자열로 변환해서 같은 엘리먼트에 있는 문자열과 연결합니다. 이렇게 템플릿에 삽입된 문자열은 <strong>엘리먼트나 디렉티브의 속성값</strong>으로 사용됩니다.</p>\n<!--\nYou appear to be inserting the result between element tags and assigning it to attributes.\nIt's convenient to think so, and you rarely suffer for this mistake.\nThough this is not exactly true. Interpolation is a special syntax that Angular converts into a\n[property binding](guide/template-syntax#property-binding), as is explained [below](guide/template-syntax#property-binding-or-interpolation).\n-->\n<p>이 과정은 템플릿 표현식의 결과값이 엘리먼트 태그의 값이나 속성값으로 바로 삽입된다고 생각할 수도 있습니다. 이렇게 단순하게 이해하는 것도 틀린 것은 아닙니다만, 정확한 것은 아닙니다. 문자열 바인딩은 <a href=\"guide/template-syntax#%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EB%B0%94%EC%9D%B8%EB%94%A9\">프로퍼티 바인딩</a>의 특별한 케이스이며, <a href=\"guide/template-syntax#%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EB%B0%94%EC%9D%B8%EB%94%A9-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%B0%94%EC%9D%B8%EB%94%A9\">아래</a>에서 자세하게 설명할 것입니다.</p>\n<!--\nBut first, let's take a closer look at template expressions and statements.\n-->\n<p>우선 템플릿 표현식에 대해 자세하게 알아봅시다.</p>\n<hr>\n<!--\n<a id=\"template-expressions\"></a>\n-->\n<a id=\"템플릿-표현식\"></a>\n<!--\n## Template expressions\n-->\n<h2 id=\"템플릿-표현식-template-expressions\">템플릿 표현식 (Template expressions)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#템플릿-표현식-template-expressions\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nA template **expression** produces a value.\nAngular executes the expression and assigns it to a property of a binding target;\nthe target might be an HTML element, a component, or a directive.\n-->\n<p>템플릿 <strong>표현식</strong>은 실행된 후에 결과값을 반환하는데, 반환된 값은 Angular 프레임워크가 HTML 엘리먼트나 컴포넌트, 디렉티브에 바인딩합니다.</p>\n<!--\nThe interpolation braces in `{{1 + 1}}` surround the template expression `1 + 1`.\nIn the [property binding](guide/template-syntax#property-binding) section below,\na template expression appears in quotes to the right of the&nbsp;`=` symbol as in `[property]=\"expression\"`.\n-->\n<p><code>{{1 + 1}}</code> 이라는 표현은 템플릿 표현식 <code>1 + 1</code>을 문자열 바인딩 표현식으로 감싼 것입니다.\n이후에 알아볼 <a href=\"guide/template-syntax#%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EB%B0%94%EC%9D%B8%EB%94%A9\">프로퍼티 바인딩</a>에서 자세히 설명하겠지만,\n템플릿 표현식은 큰따옴표로 둘러싸서 <code>=</code> 기호 오른쪽에 <code>[프로퍼티]=\"표현식\"</code>과 같이 사용합니다.</p>\n<!--\nYou write these template expressions in a language that looks like JavaScript.\nMany JavaScript expressions are legal template expressions, but not all.\n-->\n<p>템플릿 표현식은 JavaScript처럼 보이기도 하며, JavaScript 구문은 대부분 템플릿 표현식에 사용할 수 있지만, 모두 가능한 것은 아닙니다.</p>\n<!--\nJavaScript expressions that have or promote side effects are prohibited,\nincluding:\n-->\n<p>JavaScript 문법 중에 템플릿 표현식의 용도에 맞지 않는 다음 문법들은 사용할 수 없습니다:</p>\n<!--\n* assignments (`=`, `+=`, `-=`, ...)\n* <code>new</code>\n* chaining expressions with <code>;</code> or <code>,</code>\n* increment and decrement operators (`++` and `--`)\n-->\n<ul>\n<li>값을 할당하는 구문(<code>=</code>, <code>+=</code>, <code>-=</code> 등)</li>\n<li><code>new</code> 키워드</li>\n<li>여러 줄일 때 사용하는 <code>;</code> 와 <code>,</code></li>\n<li>증감연산자 (<code>++</code>, <code>--</code>)</li>\n</ul>\n<!--\nOther notable differences from JavaScript syntax include:\n-->\n<p>그리고 일부 JavaScript 연산자는 템플릿에 사용할 수 없으며, JavaScript에는 없는 연산자를 사용하기도 합니다:</p>\n<!--\n* no support for the bitwise operators `|` and `&`\n* new [template expression operators](guide/template-syntax#expression-operators), such as `|`, `?.` and `!`.\n-->\n<ul>\n<li>비트 연산자 <code>|</code>, <code>&#x26;</code> 는 템플릿 표현식에서 지원하지 않습니다.</li>\n<li><code>|</code>, <code>?.</code>, <code>!</code>와 같은 <a href=\"guide/template-syntax#%ED%85%9C%ED%94%8C%EB%A6%BF-%ED%91%9C%ED%98%84%EC%8B%9D-%EC%A0%84%EC%9A%A9-%EC%97%B0%EC%82%B0%EC%9E%90\">템플릿 표현식 전용 연산자</a>도 있습니다.</li>\n</ul>\n<!--\n<a id=\"expression-context\"></a>\n-->\n<a id=\"템플릿-표현식의-컨텍스트\"></a>\n<!--\n### Expression context\n-->\n<h3 id=\"템플릿-표현식의-컨텍스트\">템플릿 표현식의 컨텍스트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#템플릿-표현식의-컨텍스트\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe *expression context* is typically the _component_ instance.\nIn the following snippets, the `title`  within double-curly braces and the\n`isUnchanged` in quotes refer to properties of the `AppComponent`.\n-->\n<p><em>템플릿 표현식의 컨텍스트</em>는 일반적으로 <em>컴포넌트</em> 인스턴스의 컨텍스트와 같습니다.\n따라서 아래 예제에서 이중 중괄호로 문자열 바인딩 된  <code>title</code>과 <code>&#x3C;span></code>에 사용된 <code>isUnchanged</code> 어트리뷰트는 모두 <code>AppComponent</code>에 있는 프로퍼티를 가리킵니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"context-component-expression\" header=\"src/app/app.component.html\" linenums=\"false\">\n{{title}}\n&#x3C;span [hidden]=\"isUnchanged\">changed&#x3C;/span>\n\n</code-example>\n<!--\nAn expression may also refer to properties of the _template's_ context\nsuch as a [template input variable](guide/template-syntax#template-input-variable) (`let hero`)\nor a [template reference variable](guide/template-syntax#ref-vars) (`#heroInput`).\n-->\n<p>그리고 <em>템플릿</em> 안에서만 유효한 변수도 있습니다. 아래 코드에서 <code>let hero</code>로 쓰인 <a href=\"guide/template-syntax#%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%9E%85%EB%A0%A5-%EB%B3%80%EC%88%98\">템플릿 입력 변수</a>와\n<code>#heroInput</code>으로 쓰인 <a href=\"guide/template-syntax#%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%B0%B8%EC%A1%B0-%EB%B3%80%EC%88%98\">템플릿 참조 변수</a>는 템플릿 안에서만 유효합니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"context-var\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">{{hero.name}}&#x3C;/div>\n&#x3C;input #heroInput> {{heroInput.value}}\n\n</code-example>\n<!--\nThe context for terms in an expression is a blend of the _template variables_,\nthe directive's _context_ object (if it has one), and the component's _members_.\nIf you reference a name that belongs to more than one of these namespaces,\nthe template variable name takes precedence, followed by a name in the directive's _context_,\nand, lastly, the component's member names.\n-->\n<p>Angular 템플릿의 컨텍스트는 <em>템플릿 변수</em>와 디렉티브의 <em>context</em> 객체, 컴포넌트의 <em>멤버</em> 가 조합된 범위입니다.\n이 중 참조하는 항목의 이름이 동시에 두 군데 존재하면 템플릿 변수의 우선순위가 가장 높습니다.\n그 다음 우선순위는 디렉티브의 <em>context</em> 객체이며, 컴포넌트 멤버의 우선순위가 가장 낮습니다.</p>\n<!--\nThe previous example presents such a name collision. The component has a `hero`\nproperty and the `*ngFor` defines a `hero` template variable.\nThe `hero` in `{{hero.name}}`\nrefers to the template input variable, not the component's property.\n-->\n<p>위에서 살펴본 예제에서 이미 중복된 이름이 사용되었습니다.\n컴포넌트에 <code>hero</code> 프로퍼티가 있지만 템플릿에서 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>를 사용하면서 다시 한 번 <code>hero</code> 템플릿 변수를 선언했는데,\n이 경우 <code>{{hero.name}}</code>에 사용된 변수 <code>hero</code>는 참조 우선순위에 따라 컴포넌트의 프로퍼티 대신 템플릿 입력 변수를 참조합니다.</p>\n<!--\nTemplate expressions cannot refer to anything in\nthe global namespace (except `undefined`). They can't refer to `window` or `document`. They\ncan't call `console.log` or `Math.max`. They are restricted to referencing\nmembers of the expression context.\n-->\n<p>템플릿 표현식에서는 전역 공간에 있는 어떠한 객체에도 접근할 수 없으며 <code>undefined</code>만 허용됩니다.\n<code>window</code>나 <code><a href=\"api/platform-server/PlatformConfig#document\" class=\"code-anchor\">document</a></code>는 참조할 수 없으며, <code>console.log</code>나 <code>Math.max</code>와 같은 함수도 실행할 수 없습니다.</p>\n<a id=\"no-side-effects\"></a>\n<!--\n<a id=\"expression-guidelines\"></a>\n-->\n<a id=\"템플릿-표현식-가이드라인\"></a>\n<!--\n### Expression guidelines\n-->\n<h3 id=\"템플릿-표현식-가이드라인\">템플릿 표현식 가이드라인<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#템플릿-표현식-가이드라인\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nTemplate expressions can make or break an application.\nPlease follow these guidelines:\n-->\n<p>템플릿 표현식을 잘못 사용하면 애플리케이션이 중단되는 에러가 발생할 수도 있습니다.\n다음 가이드라인을 꼭 확인하세요:</p>\n<!--\n* [No visible side effects](guide/template-syntax#no-visible-side-effects)\n* [Quick execution](guide/template-syntax#quick-execution)\n* [Simplicity](guide/template-syntax#simplicity)\n* [Idempotence](guide/template-syntax#idempotence)\n-->\n<ul>\n<li><a href=\"guide/template-syntax#%EC%99%B8%EB%B6%80-%EC%98%81%ED%96%A5-%EC%B5%9C%EC%86%8C%ED%99%94\">외부 영향 최소화</a></li>\n<li><a href=\"guide/template-syntax#%EC%8B%A4%ED%96%89%EC%8B%9C%EA%B0%84%EC%9D%80-%EC%B5%9C%EB%8C%80%ED%95%9C-%EC%A7%A7%EA%B2%8C\">실행시간은 최대한 짧게</a></li>\n<li><a href=\"guide/template-syntax#%EB%A1%9C%EC%A7%81%EC%9D%80-%EC%B5%9C%EB%8C%80%ED%95%9C-%EB%8B%A8%EC%88%9C%ED%95%98%EA%B2%8C\">로직은 최대한 단순하게</a></li>\n<li><a href=\"guide/template-syntax#%EB%A9%B1%EB%93%B1%EC%84%B1\">멱등성</a></li>\n</ul>\n<!--\nThe only exceptions to these guidelines should be in specific circumstances that you thoroughly understand.\n-->\n<p>이 가이드라인들은 불가피한 상황이 아니라면 지키는 것이 좋습니다.</p>\n<!--\n#### No visible side effects\n-->\n<h4 id=\"외부-영향-최소화\">외부 영향 최소화<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#외부-영향-최소화\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nA template expression should not change any application state other than the value of the\ntarget property.\n-->\n<p>템플릿 표현식은 표현식에 사용된 프로퍼티 값 하나에 의해서만 영향을 받아야 하며, 애플리케이션의 상태와는 관련이 없어야 합니다.</p>\n<!--\nThis rule is essential to Angular's \"unidirectional data flow\" policy.\nYou should never worry that reading a component value might change some other displayed value.\nThe view should be stable throughout a single rendering pass.\n-->\n<p>이 규칙은 Angular가 제안하는 \"단방향 데이터 흐름\"의 관점에서도 아주 중요합니다.\n다른 프로퍼티의 영향을 최소화하면 컴포넌트 프로퍼티를 참조하는 과정에서 다른 컴포넌트 프로퍼티가 영향을 줄 걱정은 할 필요가 없으며, 뷰는 렌더링 단계에서 한 번만 갱신됩니다.</p>\n<!--\n#### Quick execution\n-->\n<h4 id=\"실행시간은-최대한-짧게\">실행시간은 최대한 짧게<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#실행시간은-최대한-짧게\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nAngular executes template expressions after every change detection cycle.\nChange detection cycles are triggered by many asynchronous activities such as\npromise resolutions, http results, timer events, keypresses and mouse moves.\n-->\n<p>변화 감지 싸이클은 Promise 완료, http 응답, 타이머 이벤트, 키보드나 마우스 입력등에 의해 발생하는데,\nAngular는 변화 감지 싸이클마다 템플릿 표현식을 다시 평가합니다.</p>\n<!--\nExpressions should finish quickly or the user experience may drag, especially on slower devices.\nConsider caching values when their computation is expensive.\n-->\n<p>따라서 템플릿 표현식은 최대한 빠르게 완료되어야 하며, 실행 시간이 오래 걸린다면 사용자가 불편을 느낄 것입니다.\n연산이 많이 필요한 작업이라면 결과값을 캐싱하는 방법도 고려해 보세요.</p>\n<!--\n#### Simplicity\n-->\n<h4 id=\"로직은-최대한-단순하게\">로직은 최대한 단순하게<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#로직은-최대한-단순하게\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nAlthough it's possible to write quite complex template expressions, you should avoid them.\n-->\n<p>템플릿 표현식에 아주 복잡한 로직을 작성해도 실행은 되지만, 이런 로직은 피하는 것이 좋습니다.</p>\n<!--\nA property name or method call should be the norm.\nAn occasional Boolean negation (`!`) is OK.\nOtherwise, confine application and business logic to the component itself,\nwhere it will be easier to develop and test.\n-->\n<p>프로퍼티를 바로 참조하거나 메소드 실행만 간단하게 하는 것이 가장 좋습니다.\n필요하다면 <code>!</code> 연산자로 불리언 연산을 하는 것까지도 좋습니다.\n이정도의 로직 외에 애플리케이션 로직이나 비즈니스 로직이 더 필요하다면, 템플릿보다 테스트하기 쉬운 컴포넌트에 구현하는 것이 좋습니다.</p>\n<!--\n#### Idempotence\n-->\n<h4 id=\"멱등성\">멱등성<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#멱등성\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nAn [idempotent](https://en.wikipedia.org/wiki/Idempotence) expression is ideal because\nit is free of side effects and improves Angular's change detection performance.\n-->\n<p><a href=\"https://en.wikipedia.org/wiki/Idempotence\">멱등성</a>은 어떤 연산을 몇 번 반복해도 결과가 같은 상태를 뜻하며, 다음과 같은 연산은 멱등성이 있다고 할 수 있습니다.\n<code>7 x 0 = 7 x 0 x 0 x 0 x 0</code></p>\n<p>이 법칙을 따르는 템플릿 표현식은 다른 프로퍼티값의 변화를 걱정할 필요가 없고, Angular의 변화 감지 성능도 향상시킬 수 있기 때문에 가장 좋습니다.</p>\n<!--\nIn Angular terms, an idempotent expression always returns *exactly the same thing* until\none of its dependent values changes.\n-->\n<p>Angular의 기준으로 보면, 멱등성을 띄는 템플릿 표현식은 참조하는 변수의 값이 변하지 않는 이상 언제나 <em>정확하게 같은 값</em>을 반환해야 합니다.</p>\n<!--\nDependent values should not change during a single turn of the event loop.\nIf an idempotent expression returns a string or a number, it returns the same string or number\nwhen called twice in a row. If the expression returns an object (including an `array`),\nit returns the same object *reference* when called twice in a row.\n-->\n<p>템플릿 표현식에서 참조하는 변수는 한 번 도는 이벤트 루프에서 여러 번 변경되지 않습니다.\n만약 멱등성을 띄는 템플릿 표현식에서 문자열이나 숫자를 반환한다면, 이 템플릿 표현식은 다시 실행되어도 같은 결과값을 반환해야 합니다.\n그리고 객체나 배열을 반환하는 템플릿 표현식이라면 여러번 실행되더라도 그 결과값은 <em>같은 객체</em>를 가리켜야 합니다.</p>\n<hr>\n<!--\n<a id=\"template-statements\"></a>\n-->\n<a id=\"템플릿-실행문\"></a>\n<!--\n## Template statements\n-->\n<h2 id=\"템플릿-실행문-template-statements\">템플릿 실행문 (Template statements)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#템플릿-실행문-template-statements\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nA template **statement** responds to an **event** raised by a binding target\nsuch as an element, component, or directive.\nYou'll see template statements in the [event binding](guide/template-syntax#event-binding) section,\nappearing in quotes to the right of the `=`&nbsp;symbol as in `(event)=\"statement\"`.\n-->\n<p>템플릿 <strong>실행문</strong>은 엘리먼트나 컴포넌트, 디렉티브에서 발생하는 <strong>이벤트</strong>에 반응합니다.\n템플릿 실행문은 이 문서의 <a href=\"guide/template-syntax#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%B0%94%EC%9D%B8%EB%94%A9\">이벤트 바인딩</a> 섹션에서도 확인할 수 있으며,\n<code>=</code> 기호를 사용해서 <code>(이벤트)=\"실행문\"</code>과 같이 작성합니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"context-component-statement\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;button (click)=\"deleteHero()\"><a href=\"api/http/RequestMethod#Delete\" class=\"code-anchor\">Delete</a> hero&#x3C;/button>\n\n</code-example>\n<!--\nA template statement *has a side effect*.\nThat's the whole point of an event.\nIt's how you update application state from user action.\n-->\n<p>템플릿 실행문은 <em>변화를 발생</em>시키며, 이벤트의 목적도 이것을 위한 것입니다.\n템플릿 실행문은 사용자의 행동에 따라 애플리케이션을 동작시키기 위해 사용합니다.</p>\n<!--\nResponding to events is the other side of Angular's \"unidirectional data flow\".\nYou're free to change anything, anywhere, during this turn of the event loop.\n-->\n<p>이벤트에 반응하는 것은 Angular가 제안하는 \"단방향 데이터 흐름\"의 또다른 한 방향입니다.\n이 방향은 컴포넌트 프로퍼티가 뷰로 반영되는 것의 반대 방향이며, 이벤트 루프에서는 어떠한 객체의 어떠한 값도 자유롭게 변경할 수 있습니다.</p>\n<!--\nLike template expressions, template *statements* use a language that looks like JavaScript.\nThe template statement parser differs from the template expression parser and\nspecifically supports both basic assignment (`=`) and chaining expressions\n(with <code>;</code> or <code>,</code>).\n-->\n<p>템플릿 표현식과 비슷하게 템플릿 <em>실행문</em>도 JavaScript와 비슷한 문법을 사용합니다.\n하지만 템플릿 실행문을 파싱하는 파서는 템플릿 표현식을 파싱하는 파서와 다르며, 템플릿 표현식에서는 사용할 수 없는 문법도 몇 가지는 사용할 수 있습니다.\n템플릿 실행문에서는 값을 할당하는 표현이나(<code>=</code>) 여러 줄에 걸친 표현(<code>;</code>, <code>,</code>)도 사용할 수 있습니다.</p>\n<!--\nHowever, certain JavaScript syntax is not allowed:\n-->\n<p>하지만 다음과 같은 JavaScript 문법은 사용할 수 없습니다.</p>\n<!--\n* <code>new</code>\n* increment and decrement operators, `++` and `--`\n* operator assignment, such as `+=` and `-=`\n* the bitwise operators `|` and `&`\n* the [template expression operators](guide/template-syntax#expression-operators)\n-->\n<ul>\n<li><code>new</code> 키워드</li>\n<li><code>+=</code>나 <code>-=</code>와 같은 연산 할당자</li>\n<li><code>|</code>나 <code>&#x26;</code>와 같은 비트 연산자</li>\n<li><a href=\"guide/template-syntax#%ED%85%9C%ED%94%8C%EB%A6%BF-%ED%91%9C%ED%98%84%EC%8B%9D-%EC%A0%84%EC%9A%A9-%EC%97%B0%EC%82%B0%EC%9E%90\">템플릿 표현식 전용 연산자</a></li>\n</ul>\n<!--\n### Statement context\n-->\n<h3 id=\"템플릿-실행문의-컨텍스트\">템플릿 실행문의 컨텍스트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#템플릿-실행문의-컨텍스트\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAs with expressions, statements can refer only to what's in the statement context\nsuch as an event handling method of the component instance.\n-->\n<p>템플릿 표현식과 비슷하게 템플릿 실행문도 컨텍스트가 제한되어 있으며, 컴포넌트 인스턴스에 있는 이벤트 핸들링 메소드를 주로 사용합니다.</p>\n<!--\nThe *statement context* is typically the component instance.\nThe *deleteHero* in `(click)=\"deleteHero()\"` is a method of the data-bound component.\n-->\n<p><em>템플릿 실행문의 컨텍스트</em>는 컴포넌트 인스턴스의 범위와 같습니다.\n예를 들어 아래 코드에서 <code>(click)=\"deleteHero()\"</code>에 사용된 <code>deleteHero</code>는 컴포넌트에서 데이터를 처리하는 메소드입니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"context-component-statement\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;button (click)=\"deleteHero()\"><a href=\"api/http/RequestMethod#Delete\" class=\"code-anchor\">Delete</a> hero&#x3C;/button>\n\n</code-example>\n<!--\nThe statement context may also refer to properties of the template's own context.\nIn the following examples, the template `$event` object,\na [template input variable](guide/template-syntax#template-input-variable) (`let hero`),\nand a [template reference variable](guide/template-syntax#ref-vars) (`#heroForm`)\nare passed to an event handling method of the component.\n-->\n<p>템플릿 실행문의 컨텍스트에서는 템플릿 컨텍스트 안에 있는 프로퍼티에 접근할 수도 있습니다.\n아래 예제에서 <code>$event</code> 객체는 템플릿 변수이며, <code>let hero</code>는 <a href=\"guide/template-syntax#%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%9E%85%EB%A0%A5-%EB%B3%80%EC%88%98\">템플릿 입력 변수</a>이고,\n<code>#heroForm</code>은 <a href=\"guide/template-syntax#%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%B0%B8%EC%A1%B0-%EB%B3%80%EC%88%98\">템플릿 참조 변수</a>입니다.\n각각의 변수는 컴포넌트의 이벤트 핸들링 메소드로 전달됩니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"context-var-statement\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;button (click)=\"onSave($event)\">Save&#x3C;/button>\n&#x3C;button *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\" (click)=\"deleteHero(hero)\">{{hero.name}}&#x3C;/button>\n&#x3C;form #heroForm (ngSubmit)=\"onSubmit(heroForm)\"> ... &#x3C;/form>\n\n</code-example>\n<!--\nTemplate context names take precedence over component context names.\nIn `deleteHero(hero)` above, the `hero` is the template input variable,\nnot the component's `hero` property.\n-->\n<p>템플릿 컨텍스트의 항목 이름과 컴포넌트의 프로퍼티 이름이 중복되면 템플릿 컨텍스트의 우선순위가 높습니다.\n위 코드를 예로 들면, <code>deleteHero(hero)</code>에 사용된 <code>hero</code>는 템플릿 입력 변수이며, 컴포넌트에 있는 <code>hero</code> 프로퍼티는 템플릿 변수에 의해 가려졌습니다.</p>\n<!--\nTemplate statements cannot refer to anything in the global namespace. They\ncan't refer to `window` or `document`.\nThey can't call `console.log` or `Math.max`.\n-->\n<p>템플릿 실행문에서는 템플릿 표현식과 마찬가지로 전역 공간에 접근할 수 없습니다.\n또, <code>window</code>나 <code><a href=\"api/platform-server/PlatformConfig#document\" class=\"code-anchor\">document</a></code>에도 접근할 수 없고, <code>console.log</code>나 <code>Math.max</code>와 같은 함수도 실행할 수 없습니다.</p>\n<!--\n### Statement guidelines\n-->\n<h3 id=\"템플릿-실행문-가이드라인\">템플릿 실행문 가이드라인<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#템플릿-실행문-가이드라인\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAs with expressions, avoid writing complex template statements.\nA method call or simple property assignment should be the norm.\n-->\n<p>템플릿 표현식과 마찬가지로 템플릿 실행문에도 복잡한 로직을 작성하지 않는 것이 좋습니다.\n간단하게 프로퍼티를 참조하거나 함수를 실행하는 것이 가장 좋은 방법입니다.</p>\n<!--\nNow that you have a feel for template expressions and statements,\nyou're ready to learn about the varieties of data binding syntax beyond interpolation.\n-->\n<p>지금까지 템플릿 표현식과 템플릿 실행문에 대해 알아봤습니다.\n이제부터는 문자열 바인딩을 포함한 데이터 바인딩에 대해 자세하게 알아봅시다.</p>\n<hr>\n<!--\n<a id=\"binding-syntax\"></a>\n-->\n<a id=\"바인딩-문법\"></a>\n<!--\n## Binding syntax: An overview\n-->\n<h2 id=\"바인딩-문법--개요\">바인딩 문법 : 개요<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#바인딩-문법--개요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nData binding is a mechanism for coordinating what users see, with application data values.\nWhile you could push values to and pull values from HTML,\nthe application is easier to write, read, and maintain if you turn these chores over to a binding framework.\nYou simply declare bindings between binding sources and target HTML elements and let the framework do the work.\n-->\n<p>사용자가 보는 화면과 애플리케이션 데이터의 값은 데이터 바인딩을 통해 자동으로 동기화됩니다.\n데이터 바인딩을 지원하는 프레임워크에서는 HTML에 값을 반영하거나 HTML에서 값을 가져오는 과정이 훨씬 간단하기 때문에,\n애플리케이션 로직을 쉽고 빠르면서 간결하게 작성할 수 있습니다.\n바인딩할 객체와 HTML을 단순하게 연결하기만 하면 그 이후는 프레임워크가 알아서 필요한 작업을 수행합니다.</p>\n<!--\nAngular provides many kinds of data binding.\nThis guide covers most of them, after a high-level view of Angular data binding and its syntax.\n-->\n<p>Angular는 데이터 바인딩을 여러가지 방식으로 제공합니다.\n이 문서에서는 Angular가 제공하는 데이터 바인딩을 기본부터 차근차근 알아봅시다.</p>\n<!--\nBinding types can be grouped into three categories distinguished by the direction of data flow:\nfrom the _source-to-view_, from _view-to-source_, and in the two-way sequence: _view-to-source-to-view_:\n-->\n<p>바인딩 방식은 데이터가 반영되는 방향에 따라 3종류로 구분할 수 있습니다. 이 때 데이터가 흐르는 방향은 <em>소스에서 뷰로 가는 방향</em>, <em>뷰에서 소스로 가는 방향</em>, <em>양방향</em> 이 있습니다.</p>\n<style>\n  td, th {vertical-align: top}\n</style>\n<table width=\"100%\">\n  <colgroup><col width=\"30%\">\n  \n  <col width=\"50%\">\n  \n  <col width=\"20%\">\n  \n  </colgroup><tbody><tr>\n    <th>\n      <!--\n      Data direction\n      -->\n      데이터 방향\n    </th>\n    <th>\n      <!--\n      Syntax\n      -->\n      문법\n    </th>\n    <th>\n      <!--\n      Type\n      -->\n      종류\n    </th>\n  </tr>\n  <tr>\n    <td>\n      <!--\n      One-way<br>from data source<br>to view target\n      -->\n      데이터 소스에서<br>뷰로 가는<br>단방향\n    </td>\n    <td>\n      <!--\n      <code-example>\n        {{expression}}\n        [target]=\"expression\"\n        bind-target=\"expression\"\n      </code-example>\n      -->\n      <code-example>\n        {{표현식}}\n        [대상]=\"표현식\"\n        bind-대상=\"표현식\"\n      </code-example>\n    </td>\n    <td>\n      <!--\n      Interpolation<br>\n      Property<br>\n      Attribute<br>\n      Class<br>\n      Style\n      -->\n      문자열 바인딩(Interpolation)<br>\n      프로퍼티<br>\n      어트리뷰트<br>\n      클래스<br>\n      스타일\n    </td>\n    </tr><tr>\n      <td>\n        <!--\n        One-way<br>from view target<br>to data source\n        -->\n        뷰에서<br>데이터 소스로 가는<br>단방향\n      </td>\n      <td>\n        <!--\n        <code-example>\n          (target)=\"statement\"\n          on-target=\"statement\"\n        </code-example>\n      -->\n        <code-example>\n          (대상)=\"실행문\"\n          on-대상=\"실행문\"\n        </code-example>\n      </td>\n      <td>\n        <!--\n        Event\n        -->\n        이벤트\n      </td>\n    </tr>\n    <tr>\n      <td>\n        <!--\n        Two-way\n        -->\n        양방향\n      </td>\n      <td>\n        <!--\n        <code-example>\n          [(target)]=\"expression\"\n          bindon-target=\"expression\"\n        </code-example>\n        -->\n        <code-example>\n          [(대상)]=\"표현식\"\n          bindon-대상=\"표현식\"\n        </code-example>\n      </td>\n      <td>\n        <!--\n        Two-way\n        -->\n        양방향\n      </td>\n    </tr>\n  \n</tbody></table>\n<!--\nBinding types other than interpolation have a **target name** to the left of the equal sign,\neither surrounded by punctuation (`[]`, `()`) or preceded by a prefix (`bind-`, `on-`, `bindon-`).\n-->\n<p>문자열 바인딩을 제외하면 모든 바인딩 방식에는 등호 왼쪽에 <strong>바인딩할 대상의 이름</strong>이 있고, <code>[]</code>나 <code>()</code>로 둘러싸여 있거나 <code>bind-</code>, <code>on-</code>, <code>bindon-</code> 접두사가 붙습니다.</p>\n<!--\nThe target name is the name of a _property_. It may look like the name of an _attribute_ but it never is.\nTo appreciate the difference, you must develop a new way to think about template HTML.\n-->\n<p>바인딩할 대상의 이름은 <em>프로퍼티</em> 의 이름이 되는데, <em>어트리뷰트</em> 와 헷갈릴 수 있으니 주의해야 합니다.\n프로퍼티 바인딩과 어트리뷰트 바인딩의 차이를 알아보기 위해 템플릿 HTML를 조금 다른 시각으로 알아봅시다.</p>\n<!--\n### A new mental model\n-->\n<h3 id=\"새로운-html-구현방식으로-생각하기\">새로운 HTML 구현방식으로 생각하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#새로운-html-구현방식으로-생각하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nWith all the power of data binding and the ability to extend the HTML vocabulary\nwith custom markup, it is tempting to think of template HTML as *HTML Plus*.\n-->\n<p>기존에 있던 HTML 요소에 데이터 바인딩 기능을 추가하는 것은 <em>HTML 요소를 확장</em> 하는 것이라고 생각할 수도 있습니다.</p>\n<!--\nIt really *is* HTML Plus.\nBut it's also significantly different than the HTML you're used to.\nIt requires a new mental model.\n-->\n<p>하지만 기존에 사용하던 HTML과 다른 점도 많습니다.\n좀 더 자세하게 알아봅시다.</p>\n<!--\nIn the normal course of HTML development, you create a visual structure with HTML elements, and\nyou modify those elements by setting element attributes with string constants.\n-->\n<p>일반적으로 HTML 문서를 작성할 때는 화면에 표시하는 모양에 맞게 HTML 엘리먼트 구조를 잡고 각 엘리먼트의 어트리뷰트를 문자열로 직접 지정했습니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"img+button\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div class=\"special\">Mental Model&#x3C;/div>\n&#x3C;img src=\"assets/images/hero.png\">\n&#x3C;button disabled>Save&#x3C;/button>\n\n</code-example>\n<!--\nYou still create a structure and initialize attribute values this way in Angular templates.\n-->\n<p>지금까지 살펴본 Angular 템플릿에서도 엘리먼트 구조를 잡거나 어트리뷰트 값을 지정할 때도 이런 방법을 사용했습니다.</p>\n<!--\nThen you learn to create new elements with components that encapsulate HTML\nand drop them into templates as if they were native HTML elements.\n-->\n<p>그리고 HTML을 캡슐화하는 컴포넌트를 작성한 후에는 일반 HTML 엘리먼트처럼 템플릿에 사용할 수 있습니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"hero-detail-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- 일반 <a href=\"api/core/SecurityContext#HTML\" class=\"code-anchor\">HTML</a> -->\n&#x3C;div class=\"special\">Mental Model&#x3C;/div>\n&#x3C;!-- 와우! 새로운 엘리먼트를 사용할 수 있습니다! -->\n&#x3C;app-hero-detail>&#x3C;/app-hero-detail>\n\n</code-example>\n<!--\nThat's HTML Plus.\n-->\n<p>그래서 이것을 HTML가 확장되었다고 하는 것입니다.</p>\n<!--\nThen you learn about data binding. The first binding you meet might look like this:\n-->\n<p>이제 데이터 바인딩에 대해 알아봅시다. 첫번째로 살펴볼 바인딩은 다음과 같습니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"disabled-button-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- `isUnchanged` 프로퍼티로 disabled 스테이트를 바인딩합니다. -->\n&#x3C;button [disabled]=\"isUnchanged\">Save&#x3C;/button>\n\n</code-example>\n<!--\nYou'll get to that peculiar bracket notation in a moment. Looking beyond it,\nyour intuition suggests that you're binding to the button's `disabled` attribute and setting\nit to the current value of the component's `isUnchanged` property.\n-->\n<p>코드에 사용된 중괄호(<code>[</code>, <code>]</code>)가 낯설어 보일 수 있습니다.\n이 문법은 컴포넌트에 있는 <code>isUnchanged</code> 프로퍼티 값을 버튼의 <code>disabled</code> 어트리뷰트 값에 바인딩하는 문법일까요?</p>\n<!--\nYour intuition is incorrect! Your everyday HTML mental model is misleading.\nIn fact, once you start data binding, you are no longer working with HTML *attributes*. You aren't setting attributes.\nYou are setting the *properties* of DOM elements, components, and directives.\n-->\n<p>아닙니다! 이전까지 작업하던 HTML 모델과는 이 점이 다릅니다.\n사실 데이터 바인딩을 사용하고 나면 더이상 HTML <em>어트리뷰트</em> 를 직접 조작할 필요가 없습니다.\n단지 DOM 엘리먼트나 컴포넌트, 디렉티브의 <em>프로퍼티</em> 값만 지정하게 될 뿐입니다.</p>\n<div class=\"alert is-helpful\">\n<!--\n### HTML attribute vs. DOM property\n-->\n<h3 id=\"html-어트리뷰트-vs-dom-프로퍼티\">HTML 어트리뷰트 vs. DOM 프로퍼티<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#html-어트리뷰트-vs-dom-프로퍼티\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe distinction between an HTML attribute and a DOM property is crucial to understanding how Angular binding works.\n-->\n<p>Angular에서 바인딩이 어떻게 동작하는지 이해하려면, HTML 어트리뷰트와 DOM 프로퍼티를 확실하게 구분해야 합니다.</p>\n<!--\n**Attributes are defined by HTML. Properties are defined by the DOM (Document Object Model).**\n-->\n<p><strong>어트리뷰트는 HTML에 지정합니다. 그리고 프로퍼티는 DOM(Document Object Model)에 지정합니다.</strong></p>\n<!--\n* A few HTML attributes have 1:1 mapping to properties. `id` is one example.\n\n* Some HTML attributes don't have corresponding properties. `colspan` is one example.\n\n* Some DOM properties don't have corresponding attributes. `textContent` is one example.\n\n* Many HTML attributes appear to map to properties ... but not in the way you might think!\n-->\n<ul>\n<li>어떤 HTML 어트리뷰트는 프로퍼티와 같은 역할을 합니다. <code>id</code>가 그렇습니다.</li>\n<li>프로퍼티에는 없는 HTML 어트리뷰트도 있습니다. <code>colspan</code>이 그렇습니다.</li>\n<li>어트리뷰트에는 없는 DOM 프로퍼티도 있습니다. <code>textContent</code>가 그렇습니다.</li>\n<li>그 외에 서로 연관이 있는 어트리뷰트와 프로퍼티는... 이 부분은 일단 넘어가죠!</li>\n</ul>\n<!--\nThat last category is confusing until you grasp this general rule:\n-->\n<p>마지막 분류가 좀 헷갈릴 수 있지만, 일반적인 규칙은 이렇습니다:</p>\n<!--\n**Attributes *initialize* DOM properties and then they are done.\nProperty values can change; attribute values can't.**\n-->\n<p><strong>어트리뷰트는 DOM 프로퍼티의 <em>초기값</em>을 지정하고 역할이 끝납니다. 값도 변하지 않습니다.\n프로퍼티는 값을 바꾸면서 계속 유지됩니다.</strong> </p>\n<!--\nFor example, when the browser renders `<input type=\"text\" value=\"Bob\">`, it creates a\ncorresponding DOM node with a `value` property *initialized* to \"Bob\".\n-->\n<p>브라우저가 렌더링하는 <code>&#x3C;input type=\"text\" value=\"Bob\"></code> 엘리먼트로 설명하면,\n이 DOM 노드는 어트리뷰트 값인 \"Bob\"으로 <code>value</code> 프로퍼티가 <em>초기화</em> 되면서 만들어 집니다.</p>\n<!--\nWhen the user enters \"Sally\" into the input box, the DOM element `value` *property* becomes \"Sally\".\nBut the HTML `value` *attribute* remains unchanged as you discover if you ask the input element\nabout that attribute: `input.getAttribute('value')` returns \"Bob\".\n-->\n<p>그리고 사용자가 이 입력 필드에 \"Sally\" 라고 입력하면 DOM 엘리번트의 <code>value</code> <em>프로퍼티</em> 는 \"Sally\"라는 값으로 변경됩니다.\n하지만 HTML에 있는 <code>value</code> <em>어트리뷰트</em>는 <code>input.getAttribute('value')</code>로 찾아봐도 \"Bob\"으로 남아있습니다.</p>\n<!--\nThe HTML attribute `value` specifies the *initial* value; the DOM `value` property is the *current* value.\n-->\n<p>HTML에 있는 <code>value</code> 어트리뷰트는 연결된 DOM 필드의 값을 초기화할 뿐이고, DOM에 있는 <code>value</code> 프로퍼티가 <em>현재값</em> 을 나타냅니다.</p>\n<!--\nThe `disabled` attribute is another peculiar example. A button's `disabled` *property* is\n`false` by default so the button is enabled.\nWhen you add the `disabled` *attribute*, its presence alone initializes the  button's `disabled` *property* to `true`\nso the button is disabled.\n-->\n<p>하지만 <code>disabled</code> 어트리뷰트는 조금 다릅니다. 버튼의 <code>disabled</code> <em>프로퍼티</em> 기본값은 <code>fasle</code>이기 때문에 버튼은 활성화되어 있습니다.\n이 버튼에 <code>disabled</code> <em>어트리뷰트</em>를 지정하면, 버튼의 <code>disabled</code> <em>프로퍼티</em>가 <code>true</code>로 초기화되면서 버튼이 비활성화 됩니다.</p>\n<!--\nAdding and removing the `disabled` *attribute* disables and enables the button. The value of the *attribute* is irrelevant,\nwhich is why you cannot enable a button by writing `<button disabled=\"false\">Still Disabled</button>`.\n-->\n<p><code>disabled</code> <em>어트리뷰트</em>를 지정하는 것에 따라 버튼이 활성화되거나 비활성화됩니다. 이 때 <code>disabled</code> 어트리뷰트의 값은 상관없습니다.\n<code>&#x3C;button disabled=\"false\">Still Disabled&#x3C;/button></code> 라고 지정해도 이 버튼은 비활성화 됩니다.</p>\n<!--\nSetting the button's `disabled` *property*  (say, with an Angular binding) disables or enables the button.\nThe value of the *property* matters.\n-->\n<p>하지만 버튼의 <code>disabled</code> <em>프로퍼티</em>를 Angular로 바인딩하면 버튼을 비활성화하거나 활성화할 수 있습니다.\n이 때는 <em>프로퍼티</em> 값의 영향을 받습니다.</p>\n<!--\n**The HTML attribute and the DOM property are not the same thing, even when they have the same name.**\n-->\n<p><strong>HTML 어트리뷰트와 DOM 프로퍼티의 이름이 같더라도, 둘의 역할은 엄연히 다릅니다.</strong></p>\n</div>\n<!--\nThis fact bears repeating:\n**Template binding works with *properties* and *events*, not *attributes*.**\n-->\n<p>중요한 내용이니 다시 한 번 설명하자면:\n<strong>템플릿 바인딩은 <em>프로퍼티</em>나 <em>이벤트</em>와 합니다. <em>어트리뷰트</em>가 아닙니다.</strong></p>\n<div class=\"callout is-helpful\">\n<header>\n<!--\n  A world without attributes\n-->\n어트리뷰트가 없는 세상\n</header>\n<!--\nIn the world of Angular, the only role of attributes is to initialize element and directive state.\nWhen you write a data binding, you're dealing exclusively with properties and events of the target object.\nHTML attributes effectively disappear.\n-->\n<p>Angular에서 어트리뷰트는 엘리먼트의 초기값을 지정하거나 디렉티브의 초기 상태를 지정하는 역할만 합니다.\n데이터 바인딩을 할 때도 온전히 프로퍼티나 이벤트를 객체와 연결할 뿐입니다.\nHTML 어트리뷰트의 역할은 거의 없습니다.</p>\n</div>\n<!--\nWith this model firmly in mind, read on to learn about binding targets.\n-->\n<p>이런 내용을 염두에 두면서, 바인딩 대상에 대해 알아봅시다.</p>\n<!--\n### Binding targets\n-->\n<h3 id=\"바인딩-대상\">바인딩 대상<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#바인딩-대상\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe **target of a data binding** is something in the DOM.\nDepending on the binding type, the target can be an\n(element | component | directive) property, an\n(element | component | directive) event, or (rarely) an attribute name.\nThe following table summarizes:\n-->\n<p><em>데이터 바인딩의 대상</em>은 DOM에 있는 무언가 입니다.\n이 대상은 바인딩의 종류에 따라 (엘리먼트 | 컴포넌트 | 디렉티브)의 프로퍼티나, (엘리먼트 | 컴포넌트 | 디렉티브)의 이벤트, (가끔은) 어트리뷰트가 되기도 합니다.\n표로 정리해보면 다음과 같습니다.</p>\n<style>\n  td, th {vertical-align: top}\n</style>\n<table width=\"100%\">\n  <!--\n  <col width=\"10%\">\n  </col>\n  <col width=\"15%\">\n  </col>\n  <col width=\"75%\">\n  </col>\n  -->\n  <colgroup><col width=\"15%\">\n  \n  <col width=\"21%\">\n  \n  <col width=\"64%\">\n  \n  </colgroup><tbody><tr>\n    <th>\n      <!--\n      Type\n  \t  -->\n  \t  종류\n    </th>\n    <th>\n      <!--\n      Target\n      -->\n      대상\n    </th>\n    <th>\n      <!--\n      Examples\n      -->\n      예제\n    </th>\n  </tr>\n  <tr>\n    <td>\n      <!--\n      Property\n      -->\n      프로퍼티\n    </td>\n    <td>\n      <!--\n      Element&nbsp;property<br>\n      Component&nbsp;property<br>\n      Directive&nbsp;property\n      -->\n      엘리먼트 프로퍼티<br>\n      컴포넌트 프로퍼티<br>\n      디렉티브 프로퍼티\n    </td>\n    <td>\n      <code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-syntax-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;img [src]=\"heroImageUrl\">\n&#x3C;app-hero-detail [hero]=\"currentHero\">&#x3C;/app-hero-detail>\n&#x3C;div [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"{'special': isSpecial}\">&#x3C;/div>\n\n</code-example>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <!--\n      Event\n      -->\n      이벤트\n    </td>\n    <td>\n      <!--\n      Element&nbsp;event<br>\n      Component&nbsp;event<br>\n      Directive&nbsp;event\n      -->\n      엘리먼트 이벤트<br>\n      컴포넌트 이벤트<br>\n      디렉티브 이벤트\n    </td>\n    <td>\n      <code-example path=\"template-syntax/src/app/app.component.html\" region=\"event-binding-syntax-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;button (click)=\"onSave()\">Save&#x3C;/button>\n&#x3C;app-hero-detail (deleteRequest)=\"deleteHero()\">&#x3C;/app-hero-detail>\n&#x3C;div (myClick)=\"clicked=$event\" clickable>click me&#x3C;/div>\n\n</code-example>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <!--\n      Two-way\n      -->\n      양방향\n    </td>\n    <td>\n      <!--\n      Event and property\n      -->\n      이벤트나 프로퍼티\n    </td>\n    <td>\n      <code-example path=\"template-syntax/src/app/app.component.html\" region=\"2-way-binding-syntax-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"name\">\n\n</code-example>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <!--\n      Attribute\n      -->\n      어트리뷰트\n    </td>\n    <td>\n      <!--\n      Attribute\n      (the&nbsp;exception)\n      -->\n      어트리뷰트(일부)\n    </td>\n    <td>\n      <code-example path=\"template-syntax/src/app/app.component.html\" region=\"attribute-binding-syntax-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;button [attr.aria-label]=\"help\">help&#x3C;/button>\n\n</code-example>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <!--\n      Class\n      -->\n      클래스\n    </td>\n    <td>\n      <!--\n      <code>class</code> property\n      -->\n      <code>class</code> 프로퍼티\n    </td>\n    <td>\n      <code-example path=\"template-syntax/src/app/app.component.html\" region=\"class-binding-syntax-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div [class.special]=\"isSpecial\">Special&#x3C;/div>\n\n</code-example>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <!--\n      Style\n      -->\n      스타일\n    </td>\n    <td>\n      <!--\n      <code>style</code> property\n      -->\n      <code><a href=\"api/animations/style\" class=\"code-anchor\">style</a></code> 프로퍼티\n    </td>\n    <td>\n      <code-example path=\"template-syntax/src/app/app.component.html\" region=\"style-binding-syntax-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;button [style.color]=\"isSpecial ? 'red' : 'green'\">\n\n</code-example>\n    </td>\n  </tr>\n</tbody></table>\n<!--\nWith this broad view in mind, you're ready to look at binding types in detail.\n-->\n<p>이제 하나씩 자세하게 알아봅시다.</p>\n<hr>\n<!--\n<a id=\"property-binding\"></a>\n-->\n<a id=\"프로퍼티-바인딩\"></a>\n<!--\n## Property binding ( <span class=\"syntax\">[property]</span> )\n-->\n<h2 id=\"프로퍼티-바인딩--프로퍼티-\">프로퍼티 바인딩 ( <span class=\"syntax\">[프로퍼티]</span> )<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#프로퍼티-바인딩--프로퍼티-\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nWrite a template **property binding** to set a property of a view element.\nThe binding sets the property to the value of a [template expression](guide/template-syntax#template-expressions).\n-->\n<p><strong>프로퍼티 바인딩</strong>은 뷰 엘리먼트의 프로퍼티를 연결하는 바인딩입니다.\n이 때 프로퍼티 값은 <a href=\"guide/template-syntax#%ED%85%9C%ED%94%8C%EB%A6%BF-%ED%91%9C%ED%98%84%EC%8B%9D\">템플릿 표현식</a>의 결과값으로 지정됩니다.</p>\n<!--\nThe most common property binding sets an element property to a component property value. An example is\nbinding the `src` property of an image element to a component's `heroImageUrl` property:\n-->\n<p>프로퍼티 바인딩은 컴포넌트의 프로퍼티 값을 엘리먼트의 프로퍼티 값으로 지정하는 용도에 주로 사용합니다.\n그래서 컴포넌트에 있는 <code>heroImageUrl</code> 프로퍼티 값을 이미지 엘리먼트의 <code>src</code> 프로퍼티에 지정하려면 다음과 같이 사용합니다:</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;img [src]=\"heroImageUrl\">\n\n</code-example>\n<!--\nAnother example is disabling a button when the component says that it `isUnchanged`:\n-->\n<p>그리고 컴포넌트에 있는 <code>isUnchanged</code> 프로퍼티 값에 따라 버튼을 비활성화 하려면 다음과 같이 사용합니다:</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-2\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;button [disabled]=\"isUnchanged\">Cancel is disabled&#x3C;/button>\n\n</code-example>\n<!--\nAnother is setting a property of a directive:\n-->\n<p>디렉티브 프로퍼티를 설정하려면 다음과 같이 사용합니다:</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-3\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"<a href=\"api/core/DebugElement#classes\" class=\"code-anchor\">classes</a>\">[<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>] binding to the <a href=\"api/core/DebugElement#classes\" class=\"code-anchor\">classes</a> property&#x3C;/div>\n\n</code-example>\n<!--\nYet another is setting the model property of a custom component (a great way\nfor parent and child components to communicate):\n-->\n<p>그리고 커스텀 컴포넌트의 모델 프로퍼티를 설정하려면 다음과 같이 사용합니다. 이 방법을 사용하면 부모 컴포넌트에서 자식 컴포넌트로 간단하게 데이터를 전달할 수 있습니다:</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-4\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;app-hero-detail [hero]=\"currentHero\">&#x3C;/app-hero-detail>\n\n</code-example>\n<!--\n### One-way *in*\n-->\n<h3 id=\"단방향-바인딩\">단방향 바인딩<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#단방향-바인딩\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nPeople often describe property binding as *one-way data binding* because it flows a value in one direction,\nfrom a component's data property into a target element property.\n-->\n<p>프로퍼티 바인딩은 컴포넌트의 데이터 프로퍼티에서 대상 엘리먼트 프로퍼티로만 값이 반영되기 때문에 <em>단방향 데이터 바인딩</em> 이라고도 합니다.</p>\n<!--\nYou cannot use property binding to pull values *out* of the target element.\nYou can't bind to a property of the target element to _read_ it. You can only _set_ it.\n-->\n<p>그래서 대상 엘리먼트의 값을 <em>가져오는</em> 용도로는 프로퍼티 바인딩을 사용할 수 없습니다.\n이 말은 대상 엘리먼트의 값을 <em>읽는 용도</em>로는 프로퍼티를 바인딩 할 수 없다는 뜻입니다. 대상 엘리먼트의 값을 <em>설정하는 용도로만</em> 프로퍼티 바인딩 할 수 있습니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nSimilarly, you cannot use property binding to *call* a method on the target element.\n-->\n<p>이와 비슷하게, 대상 엘리먼트에 있는 메소드를 <em>실행</em> 하는 용도로 프로퍼티 바인딩 할 수는 없습니다.</p>\n<!--\nIf the element raises events, you can listen to them with an [event binding](guide/template-syntax#event-binding).\n-->\n<p>그래서 엘리먼트에서 발생하는 이벤트는 <a href=\"guide/template-syntax#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%B0%94%EC%9D%B8%EB%94%A9\">이벤트 바인딩</a> 으로 처리할 수 있습니다.</p>\n<!--\nIf you must read a target element property or call one of its methods,\nyou'll need a different technique.\nSee the API reference for\n[ViewChild](api/core/ViewChild) and\n[ContentChild](api/core/ContentChild).\n-->\n<p>대상 엘리먼트의 프로퍼티 값을 참조해야 하거나, 대상 엘리먼트의 메소드를 실행해야 한다면 다른 방법을 사용해야 합니다.\n<a href=\"api/core/ViewChild\">ViewChild</a>나 <a href=\"api/core/ContentChild\">ContentChild</a>를 참고하세요.</p>\n</div>\n<!--\n### Binding target\n-->\n<h3 id=\"바인딩-대상-1\">바인딩 대상<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#바인딩-대상-1\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAn element property between enclosing square brackets identifies the target property.\nThe target property in the following code is the image element's `src` property.\n-->\n<p>엘리먼트의 프로퍼티를 대괄호(<code>[</code>, <code>]</code>)로 감싸면 프로퍼티 바인딩 대상으로 지정할 수 있습니다.\n그래서 다음 코드에서는 이미지 엘리먼트의 <code>src</code> 프로퍼티가 프로퍼티 바인딩의 대상 프로퍼티입니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;img [src]=\"heroImageUrl\">\n\n</code-example>\n<!--\nSome people prefer the `bind-` prefix alternative, known as the *canonical form*:\n-->\n<p>이 방식이 익숙하지 않다면 다음과 같이 <code>bind-</code> 접두사를 사용할 수도 있습니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-5\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;img bind-src=\"heroImageUrl\">\n\n</code-example>\n<!--\nThe target name is always the name of a property, even when it appears to be the name of something else.\nYou see `src` and may think it's the name of an attribute. No. It's the name of an image element property.\n-->\n<p>이 때 대괄호로 감싸는 대상은 반드시 프로퍼티 이름이어야 합니다.\n위 코드에 사용한 <code>src</code>가 어트리뷰트 이름처럼 보일 수 있지만, <code>src</code>는 이미지 엘리먼트의 프로퍼티 이름입니다.</p>\n<!--\nElement properties may be the more common targets,\nbut Angular looks first to see if the name is a property of a known directive,\nas it is in the following example:\n-->\n<p>바인딩되는 프로퍼티는 대상 엘리먼트의 프로퍼티인 것이 일반적이지만, 다음과 같이 Angular가 제공하는 기본 디렉티브의 프로퍼티일 수도 있습니다.\n이 때는 엘리먼트 프로퍼티보다 디렉티브 프로퍼티의 우선순위가 높습니다:</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-3\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"<a href=\"api/core/DebugElement#classes\" class=\"code-anchor\">classes</a>\">[<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>] binding to the <a href=\"api/core/DebugElement#classes\" class=\"code-anchor\">classes</a> property&#x3C;/div>\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\nTechnically, Angular is matching the name to a directive [input](guide/template-syntax#inputs-outputs),\none of the property names listed in the directive's `inputs` array or a property decorated with `@Input()`.\nSuch inputs map to the directive's own properties.\n-->\n<p>문법적으로 보면 디렉티브의 <a href=\"guide/template-syntax#%EC%9E%85%EC%B6%9C%EB%A0%A5-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0\">입력 프로퍼티</a>로 지정된 프로퍼티 중에 같은 이름인 프로퍼티에 바인딩됩니다.\n이 때 바인딩을 받는 디렉티브에서는 입력값을 받기 위해 <code>inputs</code> 배열을 지정하거나 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터를 지정해야 합니다.</p>\n</div>\n<!--\nIf the name fails to match a property of a known directive or element, Angular reports an “unknown directive” error.\n-->\n<p>디렉티브나 엘리먼트에서 프로퍼티 이름을 찾지 못하면 “unknown directive” 에러가 발생합니다.</p>\n<!--\n### Avoid side effects\n-->\n<h3 id=\"외부-영향-최소화-1\">외부 영향 최소화<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#외부-영향-최소화-1\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAs mentioned previously, evaluation of a template expression should have no visible side effects.\nThe expression language itself does its part to keep you safe.\nYou can't assign a value to anything in a property binding expression nor use the increment and decrement operators.\n-->\n<p>이전에도 언급했듯이, 템플릿 표현식은 외부의 영향을 최소한으로 받도록 작성해야 합니다.\n그리고 템플릿 표현식 자체도 간단하게 작성해서 불필요한 동작을 최소화해야 하며, 비슷한 이유로 템플릿 표현식에서는 값을 할당하거나 증감연산자를 사용할 수 없습니다.</p>\n<!--\nOf course, the expression might invoke a property or method that has side effects.\nAngular has no way of knowing that or stopping you.\n-->\n<p>템플릿 표현식에서 프로퍼티나 메소드를 잘못 사용하더라도, Angular는 로직이 잘못된 것을 감지할 수는 없으니 주의해야 합니다.</p>\n<!--\nThe expression could call something like `getFoo()`. Only you know what `getFoo()` does.\nIf `getFoo()` changes something and you happen to be binding to that something, you risk an unpleasant experience.\nAngular may or may not display the changed value. Angular may detect the change and throw a warning error.\nIn general, stick to data properties and to methods that return values and do no more.\n-->\n<p>예를 들어 템플릿 표현식에서 <code>getFoo()</code>라는 함수를 실행할 수 있습니다. 그런데 <code>getFoo()</code>가 어떤 동작을 하는지는 이 코드를 작성한 개발자만 알 수 있습니다.\n만약 <code>getFoo()</code> 함수가 어떤 프로퍼티의 값을 바꾸는데, 이 프로퍼티가 다른 곳에 바인딩 되어 있으면 바인딩이 연쇄적으로 일어나면서 어떤 결과가 발생할 지 예측하기 어려워집니다.\n심지어 동작의 결과가 뷰에 나타나지 않을 수도 있습니다. 그래서 이렇게 값이 연쇄적으로 변경되는 로직은 Angular가 검출하고 경고 메시지를 출력합니다.\n보통 데이터를 바인딩할 때는 데이터 프로퍼티를 직접 연결하거나, 함수의 실행 결과를 연결하는 것 이상은 하지 않는 것이 좋습니다.</p>\n<!--\n### Return the proper type\n-->\n<h3 id=\"어울리는-반환값-타입-사용하기\">어울리는 반환값 타입 사용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#어울리는-반환값-타입-사용하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe template expression should evaluate to the type of value expected by the target property.\nReturn a string if the target property expects a string.\nReturn a number if the target property expects a number.\nReturn an object if the target property expects an object.\n-->\n<p>템플릿 표현식의 실행 결과는 바인딩 대상이 되는 프로퍼티에 어울리는 타입이어야 합니다.\n대상 프로퍼티가 문자열로 설정된다면 템플릿 표현식은 문자열을 반환해야 하며, 대상 프로퍼티가 사용하는 타입이 숫자, 객체인 경우에도 마찬가지입니다.</p>\n<!--\nThe `hero` property of the `HeroDetail` component expects a `Hero` object, which is exactly what you're sending in the property binding:\n-->\n<p><code>HeroDetail</code> 컴포넌트에 정의된 <code>hero</code> 프로퍼티는 <code>Hero</code> 객체 타입이어야 한다고 합시다. 그러면 컴포넌트 외부에서 <code>hero</code> 프로퍼티에 데이터를 전달할 때도 <code>Hero</code> 타입을 전달해야 합니다:</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-4\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;app-hero-detail [hero]=\"currentHero\">&#x3C;/app-hero-detail>\n\n</code-example>\n<!--\n### Remember the brackets\n-->\n<h3 id=\"괄호-빼먹지-않기\">괄호 빼먹지 않기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#괄호-빼먹지-않기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe brackets tell Angular to evaluate the template expression.\nIf you omit the brackets, Angular treats the string as a constant\nand *initializes the target property* with that string.\nIt does *not* evaluate the string!\n-->\n<p>템플릿 표현식은 프로퍼티를 대괄호로 감싸야 Angular가 템플릿 표현식이라고 인식하고 실행할 수 있습니다.\n그래서 대괄호가 없으면 Angular는 이 문장을 단순하게 문자열로 판단하고 <em>대상 프로퍼티를 그 문자열로 초기화</em>할 것입니다.\n그 문자열은 <em>표현식으로 평가되지 않으며</em> 단순하게 문자열일 뿐입니다!</p>\n<!--\nDon't make the following mistake:\n-->\n<p>다음과 같은 경우는 예상하지 못한 에러가 발생할 수도 있습니다:</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-6\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- 에러: HeroDetailComponent.hero에는 Hero 객체를 바인딩해야 합니다.\n     하지만 괄호가 없으면 \"currentHero\"는 문자열일 뿐입니다. -->\n  &#x3C;app-hero-detail hero=\"currentHero\">&#x3C;/app-hero-detail>\n\n</code-example>\n<a id=\"one-time-initialization\"></a>\n<a id=\"문자열로-그대로-사용하는-경우\"></a>\n<!--\n### One-time string initialization\n-->\n<h3 id=\"문자열을-그대로-사용하는-경우\">문자열을 그대로 사용하는 경우<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#문자열을-그대로-사용하는-경우\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou *should* omit the brackets when all of the following are true:\n-->\n<p>다음과 같은 경우라면 프로퍼티 바인딩에 사용하는 대괄호를 사용하지 않는 것이 좋습니다.</p>\n<!--\n* The target property accepts a string value.\n* The string is a fixed value that you can bake into the template.\n* This initial value never changes.\n-->\n<ul>\n<li>바인딩 대상 프로퍼티에 문자열 값을 할당하는 경우</li>\n<li>변경되지 않는 문자열</li>\n</ul>\n<!--\nYou routinely initialize attributes this way in standard HTML, and it works\njust as well for directive and component property initialization.\nThe following example initializes the `prefix` property of the `HeroDetailComponent` to a fixed string,\nnot a template expression. Angular sets it and forgets about it.\n-->\n<p>HTML에서 어트리뷰트를 초기화하는 방식은 Angular에서도 유효하며, 디렉티브나 컴포넌트 프로퍼티를 초기화할 때도 같은 방식을 사용합니다.\n다음 예제를 보면 <code>HeroDetailComponent</code> 에 사용할 <code>prefix</code> 프로퍼티를 초기화하는데, 이 때 템플릿 표현식을 사용하지 않고 고정된 문자열을 사용했습니다.\n그러면 Angular는 대상 프로퍼티의 초기값을 설정할 때만 이 문자열을 사용하고, 이후에는 신경쓰지 않습니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-7\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;app-hero-detail prefix=\"You are my\" [hero]=\"currentHero\">&#x3C;/app-hero-detail>\n\n</code-example>\n<!--\nThe `[hero]` binding, on the other hand, remains a live binding to the component's `currentHero` property.\n-->\n<p>하지만 <code>[hero]</code>는 컴포넌트의 <code>currentHero</code> 프로퍼티와 바인딩 되어 있습니다. 이 때는 대괄호를 사용해서 프로퍼티 바인딩으로 선언했기 때문에 <code>currentHero</code> 프로퍼티 값이 변경될 때마다 <code>hero</code> 프로퍼티가 갱신됩니다.</p>\n<a id=\"property-binding-or-interpolation\"></a>\n<a id=\"프로퍼티-바인딩-문자열-바인딩\"></a>\n<!--\n### Property binding or interpolation?\n-->\n<h3 id=\"프로퍼티-바인딩-문자열-바인딩\">프로퍼티 바인딩? 문자열 바인딩?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#프로퍼티-바인딩-문자열-바인딩\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou often have a choice between interpolation and property binding.\nThe following binding pairs do the same thing:\n-->\n<p>코드를 작성하다보면 프로퍼티 바인딩을 해야할 지 문자열 바인딩(Interpolation)을 해야할 지 고민될 때가 있습니다.\n코드를 보면서 생각해봅시다:</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-vs-interpolation\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;p>&#x3C;img src=\"{{heroImageUrl}}\"> is the &#x3C;i>interpolated&#x3C;/i> image.&#x3C;/p>\n&#x3C;p>&#x3C;img [src]=\"heroImageUrl\"> is the &#x3C;i>property bound&#x3C;/i> image.&#x3C;/p>\n\n&#x3C;p>&#x3C;span>\"{{title}}\" is the &#x3C;i>interpolated&#x3C;/i> title.&#x3C;/span>&#x3C;/p>\n&#x3C;p>\"&#x3C;span [innerHTML]=\"title\">&#x3C;/span>\" is the &#x3C;i>property bound&#x3C;/i> title.&#x3C;/p>\n\n</code-example>\n<!--\n_Interpolation_ is a convenient alternative to _property binding_ in many cases.\n-->\n<p><em>문자열 바인딩</em>을 사용하면 <em>프로퍼티 바인딩</em> 을 사용하는 것보다 더 편한 경우도 있습니다.</p>\n<!--\nWhen rendering data values as strings, there is no technical reason to prefer one form to the other.\nYou lean toward readability, which tends to favor interpolation.\nYou suggest establishing coding style rules and choosing the form that\nboth conforms to the rules and feels most natural for the task at hand.\n-->\n<p>사실, 데이터를 그대로 뷰에 렌더링 한다면 두 바인딩 방식의 차이는 없습니다.\n단순하게 코드를 작성하면서 가독성이 더 좋은 방식을 선택하면 됩니다.</p>\n<!--\nWhen setting an element property to a non-string data value, you must use _property binding_.\n-->\n<p>하지만 바인딩되는 프로퍼티의 타입이 문자열이 아니라면 반드시 <em>프로퍼티 바인딩</em> 을 사용해야 합니다.</p>\n<!--\n#### Content security\n-->\n<h4 id=\"코드-안전성-검증\">코드 안전성 검증<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#코드-안전성-검증\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nImagine the following *malicious content*.\n-->\n<p><code>&#x3C;script></code> 태그가 포함된 악성 코드로 프로퍼티 바인딩 하는 경우를 생각해봅시다.</p>\n<code-example path=\"template-syntax/src/app/app.component.ts\" region=\"evil-title\" header=\"src/app/app.component.ts\" linenums=\"false\">\nevilTitle = 'Template &#x3C;script>alert(\"evil never sleeps\")&#x3C;/script>Syntax';\n\n</code-example>\n<!--\nFortunately, Angular data binding is on alert for dangerous HTML.\nIt [*sanitizes*](guide/security#sanitization-and-security-contexts) the values before displaying them.\nIt **will not** allow HTML with script tags to leak into the browser, neither with interpolation\nnor property binding.\n-->\n<p>다행히, Angular는 템플릿에 값을 반영하기 전에 코드의 안전성을 <a href=\"guide/security#%EC%BD%94%EB%93%9C-%EC%95%88%EC%A0%84%EC%84%B1-%EA%B2%80%EC%82%AC%EC%99%80-%EB%B3%B4%EC%95%88-%EC%98%81%EC%97%AD\"><em>검증</em></a> 하기 때문에,\n위험한 HTML 코드로 프로퍼티 바인딩을 시도하면 Angular가 감지하고 경고를 표시합니다.\n그래서 <code>&#x3C;script></code> 태그를 문자열 바인딩이나 프로퍼티 바인딩에 사용해도 <code>&#x3C;script></code> 태그는 동작하지 않습니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-vs-interpolation-sanitization\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!--\n  이 두 줄은 Angular에서 경고 메시지를 출력합니다.\n  경고: 위험한 <a href=\"api/core/SecurityContext#HTML\" class=\"code-anchor\">HTML</a> 요소는 Angular가 무효화시킵니다. (<a href=\"api/common/http\" class=\"code-anchor\">http</a>://g.co/ng/security#xss 를 참고하세요).\n -->\n&#x3C;p>&#x3C;span>\"{{evilTitle}}\" is the &#x3C;i>interpolated&#x3C;/i> evil title.&#x3C;/span>&#x3C;/p>\n&#x3C;p>\"&#x3C;span [innerHTML]=\"evilTitle\">&#x3C;/span>\" is the &#x3C;i>property bound&#x3C;/i> evil title.&#x3C;/p>\n\n</code-example>\n<!--\nInterpolation handles the script tags differently than property binding but both approaches render the\ncontent harmlessly.\n-->\n<p>문자열 바인딩도 프로퍼티 바인딩과 마찬가지로 코드의 안전성을 검증하지만, <code>&#x3C;script></code> 태그를 처리하는 방식이 다르기 때문에 템플릿에 표시되는 결과가 약간 다릅니다.</p>\n<figure>\n  <img src=\"generated/images/guide/template-syntax/evil-title.png\" alt=\"evil title made safe\" width=\"500\" height=\"40\">\n</figure>\n<hr>\n<a id=\"other-bindings\"></a>\n<a id=\"기타-바인딩\"></a>\n<!--\n## Attribute, class, and style bindings\n-->\n<h2 id=\"어트리뷰트-클래스-스타일-바인딩\">어트리뷰트, 클래스, 스타일 바인딩<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#어트리뷰트-클래스-스타일-바인딩\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe template syntax provides specialized one-way bindings for scenarios less well suited to property binding.\n-->\n<p>Angular 템플릿에서는 프로퍼티 바인딩 외에도 다음과 같은 특수한 바인딩을 사용할 수 있습니다.</p>\n<a id=\"attribute-binding\"></a>\n<!--\n### Attribute binding\n-->\n<h3 id=\"어트리뷰트-바인딩\">어트리뷰트 바인딩<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#어트리뷰트-바인딩\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou can set the value of an attribute directly with an **attribute binding**.\n-->\n<p><strong>어트리뷰트 바인딩</strong> 을 사용하면 어트리뷰트의 값을 직접 설정할 수 있습니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nThis is the only exception to the rule that a binding sets a target property.\nThis is the only binding that creates and sets an attribute.\n-->\n<p>어트리뷰트 바인딩은 대상 프로퍼티를 바인딩한다고 한 것의 유일한 예외 케이스입니다.\n이 바인딩은 프로퍼티가 아니라 어트리뷰트를 직접 바인딩합니다.</p>\n</div>\n<!--\nThis guide stresses repeatedly that setting an element property with a property binding\nis always preferred to setting the attribute with a string. Why does Angular offer attribute binding?\n-->\n<p>조금 지루하겠지만 중요한 내용이니 다시 언급하자면, 엘리먼트의 프로퍼티 값은 어트리뷰트에 문자열로 직접 지정하는 것보다 프로퍼티 바인딩을 사용하는 것이 언제나 좋습니다.\n그러면 Angular는 왜 어트리뷰트 바인딩을 제공할까요?</p>\n<!--\n**You must use attribute binding when there is no element property to bind.**\n-->\n<p><strong>어트리뷰트 바인딩은 지정하려는 속성이 프로퍼티에 없고 어트리뷰트에 있을 때만 사용해야 합니다.</strong></p>\n<!--\nConsider the [ARIA](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA),\n[SVG](https://developer.mozilla.org/en-US/docs/Web/SVG), and\ntable span attributes. They are pure attributes.\nThey do not correspond to element properties, and they do not set element properties.\nThere are no property targets to bind to.\n-->\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA\">ARIA</a>나\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/SVG\">SVG</a>,\n<code>&#x3C;table></code> 엘리먼트의 <code>span</code> 어트리뷰트에 대해 생각해봅시다. 이 객체들은 순수하게 어트리뷰트만으로 구성됩니다.\n이 객체들은 어트리뷰트와 같은 역할을 하는 프로퍼티가 없기 때문에 프로퍼티 바인딩을 사용할 수 없습니다.</p>\n<!--\nThis fact becomes painfully obvious when you write something like this.\n-->\n<p>코드를 다음과 같이 작성했다고 합시다.</p>\n<code-example language=\"html\">\n  &#x3C;tr>&#x3C;td colspan=\"{{1 + 1}}\">Three-Four&#x3C;/td>&#x3C;/tr>\n</code-example>\n<!--\nAnd you get this error:\n-->\n<p>그러면 에러가 발생합니다:</p>\n<code-example format=\"nocode\">\n  Template parse errors:\n  Can't bind to 'colspan' since it isn't <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> known native property\n</code-example>\n<!--\nAs the message says, the `<td>` element does not have a `colspan` property.\nIt has the \"colspan\" *attribute*, but\ninterpolation and property binding can set only *properties*, not attributes.\n-->\n<p>이 에러 메시지는 <code>&#x3C;td></code> 엘리먼트의 <code>colspan</code> 프로퍼티를 문자열 바인딩으로 지정할 수 없다는 뜻입니다.\n\"colspan\"은 <em>어트리뷰트</em>입니다. 따라서 이 어트리뷰트 값을 지정하기 위해 문자열 바인딩이나 프로퍼티 바인딩은 사용할 수 없습니다.\n문자열 바인딩이나 프로퍼티 바인딩은 <em>프로퍼티</em>를 바인딩 할 때만 사용할 수 있습니다.</p>\n<!--\nYou need attribute bindings to create and bind to such attributes.\n-->\n<p>이런 경우에 어트리뷰트 바인딩을 사용합니다.</p>\n<!--\nAttribute binding syntax resembles property binding.\nInstead of an element property between brackets, start with the prefix **`attr`**,\nfollowed by a dot (`.`) and the name of the attribute.\nYou then set the attribute value, using an expression that resolves to a string.\n-->\n<p>어트리뷰트 바인딩 문법은 프로퍼티 바인딩 문법과 비슷합니다.\n어트리뷰트 바인딩은 <strong><code>attr</code></strong> 접두사와 마침표(<code>.</code>)를 쓴 이후에 어트리뷰트 이름을 지정합니다.\n그리고 지정되는 어트리뷰트 값은 문자열로 지정합니다.</p>\n<!--\nBind `[attr.colspan]` to a calculated value:\n-->\n<p>그래서 <code>colspan</code> 어트리뷰트는 <code>[attr.colspan]</code> 와 같이 바인딩합니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"attrib-binding-colspan\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;table border=1>\n  &#x3C;!--  표현식이 실행된 결과는 colspan=2 입니다. -->\n  &#x3C;tr>&#x3C;td [attr.colspan]=\"1 + 1\">One-Two&#x3C;/td>&#x3C;/tr>\n\n  &#x3C;!-- ERROR: 엘리먼트에는 `colspan` 프로퍼티가 없습니다!\n    &#x3C;tr>&#x3C;td colspan=\"{{1 + 1}}\">Three-Four&#x3C;/td>&#x3C;/tr>\n  -->\n\n  &#x3C;tr>&#x3C;td>Five&#x3C;/td>&#x3C;td>Six&#x3C;/td>&#x3C;/tr>\n&#x3C;/table>\n\n</code-example>\n<!--\nHere's how the table renders:\n-->\n<p>그러면 테이블이 다음과 같이 렌더링됩니다:</p>\n<table border=\"1px\">\n  <tbody><tr><td colspan=\"2\">One-Two</td></tr>\n  <tr><td>Five</td><td>Six</td></tr>\n </tbody></table>\n<!--\nOne of the primary use cases for attribute binding\nis to set ARIA attributes, as in this example:\n-->\n<p>어트리뷰트 바인딩은 ARIA 어트리뷰트를 바인딩할 때도 많이 사용합니다:</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"attrib-binding-aria\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- 웹 접근성을 위해 aria 어트리뷰트를 지정합니다. -->\n&#x3C;button [attr.aria-label]=\"actionName\">{{actionName}} with Aria&#x3C;/button>\n\n</code-example>\n<hr>\n<!--\n### Class binding\n-->\n<h3 id=\"클래스-바인딩\">클래스 바인딩<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#클래스-바인딩\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou can add and remove CSS class names from an element's `class` attribute with\na **class binding**.\n-->\n<p>엘리먼트의 <code>class</code> 어트리뷰트를 바인딩하면 CSS 클래스를 동적으로 지정할 수 있습니다. 이것을 <strong>클래스 바인딩</strong>이라고 합니다.</p>\n<!--\nClass binding syntax resembles property binding.\nInstead of an element property between brackets, start with the prefix `class`,\noptionally followed by a dot (`.`) and the name of a CSS class: `[class.class-name]`.\n-->\n<p>클래스 바인딩 문법은 프로퍼티 바인딩 문법과 비슷합니다.\n클래스 바인딩은 <code>class</code> 접두사와 마침표(<code>.</code>) 를 사용해서 <code>[class.클래스-이름]</code> 과 같이 작성합니다.</p>\n<!--\nThe following examples show how to add and remove the application's \"special\" class\nwith class bindings.  Here's how to set the attribute without binding:\n-->\n<p>이제 클래스 바인디을 사용해서 \"special\" 클래스를 동적으로 지정하는 방법을 알아봅시다.\n먼저, 바인딩을 사용하지 않고 원래 사용하던 방식대로 클래스를 적용하려면 다음과 같이 작성합니다:</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"class-binding-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- 일반적인 클래스 설정 -->\n&#x3C;div class=\"bad curly special\">Bad curly special&#x3C;/div>\n\n</code-example>\n<!--\nYou can replace that with a binding to a string of the desired class names; this is an all-or-nothing, replacement binding.\n-->\n<p><code>class</code> 어트리뷰트를 바인딩하면 이미 지정된 클래스 전체를 새로운 값으로 초기화합니다. 하지만 이 방식은 이미 지정된 클래스 전체를 새로운 값으로 덮어쓰는 방식입니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"class-binding-2\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- 바인딩을 사용해서 클래스를 새롭게 덮어쓰는 설정 -->\n&#x3C;div class=\"bad curly special\"\n     [class]=\"badCurly\">Bad curly&#x3C;/div>\n\n</code-example>\n<!--\nFinally, you can bind to a specific class name.\nAngular adds the class when the template expression evaluates to truthy.\nIt removes the class when the expression is falsy.\n-->\n<p>원하는 클래스만 바인딩해 봅시다.\n다음과 같이 작성하면 템플릿 표현식의 평가값이 참일 때 해당 클래스가 지정되고, 평가값이 거짓일 때 해당 클래스가 해제됩니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"class-binding-3\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- 프로퍼티로 \"special\" 클래스 토글하기 -->\n&#x3C;div [class.special]=\"isSpecial\">The class binding is special&#x3C;/div>\n\n&#x3C;!-- 클래스 프로퍼티로 `class.special` 클래스 바인딩하기 -->\n&#x3C;div class=\"special\"\n     [class.special]=\"!isSpecial\">This one is not so special&#x3C;/div>\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\nWhile this is a fine way to toggle a single class name,\nthe [NgClass directive](guide/template-syntax#ngClass) is usually preferred when managing multiple class names at the same time.\n-->\n<p>실제로 DOM에 클래스를 지정할 때는 이 방법을 사용하지 않고 <a href=\"guide/template-syntax#ngClass\">NgClass 디렉티브</a>를 사용합니다.\n<code><a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a></code>를 사용하면 여러 클래스 중 어떤 클래스를 지정할지 자유롭게 조작할 수 있습니다.</p>\n</div>\n<hr>\n<!--\n### Style binding\n-->\n<h3 id=\"스타일-바인딩\">스타일 바인딩<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#스타일-바인딩\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou can set inline styles with a **style binding**.\n-->\n<p>인라인 스타일은 <strong>스타일 바인딩</strong>으로도 지정할 수 있습니다.</p>\n<!--\nStyle binding syntax resembles property binding.\nInstead of an element property between brackets, start with the prefix `style`,\nfollowed by a dot (`.`) and the name of a CSS style property: `[style.style-property]`.\n-->\n<p>스타일 바인딩 문법은 프로퍼티 바인딩 문법과 비슷합니다.\n스타일 바인딩은 <code><a href=\"api/animations/style\" class=\"code-anchor\">style</a></code> 접두사와 마침표(<code>.</code>) 를 사용해서 <code>[style.스타일-프로퍼티]</code>와 같이 작성합니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"style-binding-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;button [style.color]=\"isSpecial ? 'red': 'green'\">Red&#x3C;/button>\n&#x3C;button [style.background-color]=\"canSave ? 'cyan': 'grey'\" >Save&#x3C;/button>\n\n</code-example>\n<!--\nSome style binding styles have a unit extension.\nThe following example conditionally sets the font size in  “em” and “%” units .\n-->\n<p>그리고 스타일을 바인딩하면서 단위를 함께 사용할 수도 있습니다.\n글자 크기를 지정하면서 “em” 이나 “%” 단위를 사용하려면 다음과 같이 작성합니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"style-binding-2\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;button [style.font-size.em]=\"isSpecial ? 3 : 1\" >Big&#x3C;/button>\n&#x3C;button [style.font-size.%]=\"!isSpecial ? 150 : 50\" >Small&#x3C;/button>\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\nWhile this is a fine way to set a single style,\nthe [NgStyle directive](guide/template-syntax#ngStyle) is generally preferred when setting several inline styles at the same time.\n-->\n<p>실제로 DOM에 스타일을 지정할 때는 이 방법을 사용하지 않고 <a href=\"guide/template-syntax#ngStyle\">NgStyle directive</a>를 사용합니다.\n<code><a href=\"api/common/NgStyle\" class=\"code-anchor\">ngStyle</a></code>을 사용하면 여러 스타일 중 어떤 스타일을 지정할지 자유롭게 조작할 수 있습니다.</p>\n</div>\n<div class=\"alert is-helpful\">\n<!--\nNote that a _style property_ name can be written in either\n[dash-case](guide/glossary#dash-case), as shown above, or\n[camelCase](guide/glossary#camelcase), such as `fontSize`.\n-->\n<p><em>스타일 프로퍼티</em> 이름은 <a href=\"guide/glossary#dash-case\">대시 케이스</a>를 사용하거나 <a href=\"guide/glossary#camelcase\">캐멀 케이스</a>를 사용할 수 있습니다.</p>\n</div>\n<hr>\n<!--\n<a id=\"event-binding\"></a>\n-->\n<a id=\"이벤트-바인딩\"></a>\n<!--\n## Event binding  ( <span class=\"syntax\">(event)</span> )\n-->\n<h2 id=\"이벤트-바인딩--이벤트-\">이벤트 바인딩 ( <span class=\"syntax\">(이벤트)</span> )<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#이벤트-바인딩--이벤트-\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe bindings directives you've met so far flow data in one direction: **from a component to an element**.\n-->\n<p>지금까지 알아본 바인딩은 <strong>컴포넌트에서 엘리먼트로</strong> 향하는 단방향 바인딩이었습니다.</p>\n<!--\nUsers don't just stare at the screen. They enter text into input boxes. They pick items from lists.\nThey click buttons. Such user actions may result in a flow of data in the opposite direction:\n**from an element to a component**.\n-->\n<p>하지만 사용자가 화면만 보고 있는 것은 아닙니다. 입력 필드에 텍스트를 입력하기도 하고, 리스트에 있는 아이템을 선택하기도 하며, 버튼을 클릭하기도 합니다.\n이런 사용자 동작에 대한 정보는 <strong>엘리먼트에서 컴포넌트로</strong> 향하는 방향으로 전달되어야 합니다.</p>\n<!--\nThe only way to know about a user action is to listen for certain events such as\nkeystrokes, mouse movements, clicks, and touches.\nYou declare your interest in user actions through Angular event binding.\n-->\n<p>사용자의 동작에 반응하려면 키 입력이나 마우스 이벤트, 터치 이벤트가 발생하는지 컴포넌트가 감지하고 있어야 하며,\n이 때 Angular에서는 제공하는 이벤트 바인딩 기능을 사용합니다.</p>\n<!--\nEvent binding syntax consists of a **target event** name\nwithin parentheses on the left of an equal sign, and a quoted\n[template statement](guide/template-syntax#template-statements) on the right.\nThe following event binding listens for the button's click events, calling\nthe component's `onSave()` method whenever a click occurs:\n-->\n<p>이벤트 바인딩은 <strong>대상 이벤트</strong> 이름을 괄호(<code>(</code>, <code>)</code>)로 감싸고 <a href=\"guide/template-syntax#%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%8B%A4%ED%96%89%EB%AC%B8\">템플릿 실행문</a> 을 등호로 연결해서 작성합니다.\n예를 들어 버튼의 클릭 이벤트를 감지하고 있다가 사용자가 버튼을 클릭할 때 컴포넌트에 있는 <code>onSave()</code> 메소드를 실행하려면 다음과 같이 구현합니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"event-binding-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;button (click)=\"onSave()\">Save&#x3C;/button>\n\n</code-example>\n<!--\n### Target event\n-->\n<h3 id=\"대상-이벤트\">대상 이벤트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#대상-이벤트\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nA **name between parentheses** &mdash; for example, `(click)` &mdash;\nidentifies the target event. In the following example, the target is the button's click event.\n-->\n<p>대상 이벤트는 <strong>괄호로 둘러싼 이벤트 이름</strong>으로 구별합니다. 위 코드에서는 <code>click</code> 이벤트를 괄호로 감싸서 <code>(click)</code>과 같이 작성했기 때문에 <code>click</code> 이벤트가 대상 이벤트이며, 아래 코드에서도 바인딩 대상 이벤트는 버튼의 클릭 이벤트입니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"event-binding-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;button (click)=\"onSave()\">Save&#x3C;/button>\n\n</code-example>\n<!--\nSome people prefer the `on-` prefix alternative, known as the **canonical form**:\n-->\n<p>이 방식이 익숙하지 않다면 다음과 같이 <code>on-</code> 접두사를 사용할 수도 있습니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"event-binding-2\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;button on-click=\"onSave()\">On Save&#x3C;/button>\n\n</code-example>\n<!--\nElement events may be the more common targets, but Angular looks first to see if the name matches an event property\nof a known directive, as it does in the following example:\n-->\n<p>엘리먼트에서 발생하는 이벤트는 HTML 스펙에 정의된 이벤트인 경우가 대부분입니다. 하지만 커스텀 이벤트가 정의되어 있다면 그 이벤트도 같은 방식으로 사용할 수 있습니다. 커스텀 이벤트의 이름이 일반 이벤트 이름과 겹치면 커스텀 이벤트의 우선순위가 더 높습니다:</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"event-binding-3\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- `myClick` 이벤트는 `ClickDirective`에서 보내는 이벤트입니다. -->\n&#x3C;div (myClick)=\"clickMessage=$event\" clickable>click with myClick&#x3C;/div>\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\nThe `myClick` directive is further described in the section\non [aliasing input/output properties](guide/template-syntax#aliasing-io).\n-->\n<p><code>myClick</code> 디렉티브는 <a href=\"guide/template-syntax#aliasing-io\">입출력 프로퍼티 이름 변경하기</a> 섹션에서 자세하게 알아봅니다.</p>\n</div>\n<!--\nIf the name fails to match an element event or an output property of a known directive,\nAngular reports an “unknown directive” error.\n-->\n<p>그리고 엘리먼트 이벤트나 커스텀 디렉티브에서 해당되는 이벤트 이름을 찾지 못하면 “unknown directive” 에러가 발생합니다.</p>\n<!--\n### *$event* and event handling statements\n-->\n<h3 id=\"event-객체와-이벤트-처리-실행문\"><em>$event</em> 객체와 이벤트 처리 실행문<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#event-객체와-이벤트-처리-실행문\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn an event binding, Angular sets up an event handler for the target event.\n-->\n<p>이벤트를 바인딩하면 Angular의 이벤트 처리 함수가 대상 이벤트와 연결됩니다.</p>\n<!--\nWhen the event is raised, the handler executes the template statement.\nThe template statement typically involves a receiver, which performs an action\nin response to the event, such as storing a value from the HTML control\ninto a model.\n-->\n<p>그러면 이벤트가 발생했을 때 Angular 프레임워크의 이벤트 처리 함수가 템플릿 실행문을 실행하는데,\n이 템플릿 실행문을 사용해서 원하는 동작을 실행할 수 있습니다.</p>\n<!--\nThe binding conveys information about the event, including data values, through\nan **event object named `$event`**.\n-->\n<p>이 때 템플릿 실행문에는 이벤트에 대한 정보와 이벤트가 발생한 HTML 컨트롤에 대한 정보가 <code>$event</code> 라는 객체에 담겨 전달됩니다.</p>\n<!--\nThe shape of the event object is determined by the target event.\nIf the target event is a native DOM element event, then `$event` is a\n[DOM event object](https://developer.mozilla.org/en-US/docs/Web/Events),\nwith properties such as `target` and `target.value`.\n-->\n<p>이벤트 객체의 형식은 대상 이벤트에 따라 달라집니다.\n대상 이벤트가 네이티브 DOM 엘리먼트의 이벤트라면 <code>$envet</code> 객체는 <a href=\"https://developer.mozilla.org/en-US/docs/Web/Events\">DOM 이벤트 객체</a>이며, 이 객체에서 <code><a href=\"api/router/RouterLinkWithHref#target\" class=\"code-anchor\">target</a></code> 프로퍼티나 <code>target.value</code> 값을 참조할 수 있습니다.</p>\n<!--\nConsider this example:\n-->\n<p>다음 예제를 봅시다:</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"without-NgModel\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;input [value]=\"currentHero.name\"\n       (input)=\"currentHero.name=$event.target.value\" >\n\n</code-example>\n<!--\nThis code sets the input box `value` property by binding to the `name` property.\nTo listen for changes to the value, the code binds to the input box's `input` event.\nWhen the user makes changes, the `input` event is raised, and the binding executes\nthe statement within a context that includes the DOM event object, `$event`.\n-->\n<p>이 코드에서는 <code>currentHero.hero</code> 값을 입력 필드의 <code>value</code> 프로퍼티로 바인딩하면서 초기값을 지정합니다.\n그리고 값이 변경되는 것을 감지하기 위해 <code>input</code> 이벤트를 <code>(input)</code> 으로 바인딩합니다.\n사용자가 입력 필드의 값을 변경하면 <code>input</code> 이벤트가 발생하고 이 이벤트에 연결된 템플릿 실행문이 실행되는데, 이 때 DOM 이벤트 객체가 <code>$event</code> 객체로 템플릿 실행문에 전달됩니다.</p>\n<!--\nTo update the `name` property, the changed text is retrieved by following the path `$event.target.value`.\n-->\n<p>그리고 이벤트 객체에서 값을 참조해서 <code>name</code> 프로퍼티 값을 다시 지정하기 위해 템플릿 실행문을 <code>$event.target.value</code> 와 같이 작성했습니다.</p>\n<!--\nIf the event belongs to a directive (recall that components are directives),\n`$event` has whatever shape the directive decides to produce.\n-->\n<p>대상 이벤트가 DOM 엘리먼트의 이벤트가 아니고 커스텀 디렉티브(컴포넌트)에서 정의하는 이벤트라면, <code>$event</code> 객체는 해당 디렉티브에서 정의하는 형식의 객체가 됩니다.</p>\n<a id=\"eventemitter\"></a>\n<!--\n<a id=\"custom-event\"></a>\n-->\n<a id=\"커스텀-이벤트\"></a>\n<!--\n### Custom events with <span class=\"syntax\">EventEmitter</span>\n-->\n<h3 id=\"커스텀-이벤트와-eventemitter\">커스텀 이벤트와 <span class=\"syntax\">EventEmitter</span><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#커스텀-이벤트와-eventemitter\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nDirectives typically raise custom events with an Angular [EventEmitter](api/core/EventEmitter).\nThe directive creates an `EventEmitter` and exposes it as a property.\nThe directive calls `EventEmitter.emit(payload)` to fire an event, passing in a message payload, which can be anything.\nParent directives listen for the event by binding to this property and accessing the payload through the `$event` object.\n-->\n<p>Angular에서 제공하는 <a href=\"api/core/EventEmitter\">EventEmitter</a>를 사용하면 커스텀 이벤트를 만들 수 있습니다.\n우선, 디렉티브에 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 타입의 프로퍼티를 선언하고 이 프로퍼티를 디렉티브 외부로 열어줍니다.\n그런 뒤 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 객체의 <code>emit(데이터)</code> 함수를 실행하면 데이터가 <code>$event</code> 객체에 담겨 디렉티브 외부로 전달됩니다.\n부모 디렉티브에서는 자식 디렉티브의 이벤트 프로퍼티를 바인딩해서 이 커스텀 이벤트를 감지하고 있다가, 이벤트가 발생했을 때 <code>$event</code> 이벤트에 담긴 데이터를 받아서 처리하면 됩니다.</p>\n<!--\nConsider a `HeroDetailComponent` that presents hero information and responds to user actions.\nAlthough the `HeroDetailComponent` has a delete button it doesn't know how to delete the hero itself.\nThe best it can do is raise an event reporting the user's delete request.\n-->\n<p><code>HeroDetailComponent</code> 는 히어로의 정보를 보여주면서 사용자의 동작에도 반응해야 한다고 합시다.\n이 컴포넌트에 히어로 삭제 버튼을 마련해 둘 수 있지만, 이 컴포넌트에서는 히어로를 어떻게 삭제하는지 알지 못합니다.\n이 동작을 구현하려면 사용자가 삭제 요청을 했을 때 이벤트를 발생시키고, 부모 컴포넌트에서 이 이벤트를 받아 처리하는 방법이 가장 좋습니다.</p>\n<!--\nHere are the pertinent excerpts from that `HeroDetailComponent`:\n-->\n<p><code>HeroDetailComponent</code> 코드에서 관련된 부분을 봅시다:</p>\n<code-example path=\"template-syntax/src/app/hero-detail.component.ts\" linenums=\"false\" header=\"src/app/hero-detail.component.ts (template)\" region=\"template-1\">\n<a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n&#x3C;div>\n  &#x3C;img src=\"{{heroImageUrl}}\">\n  &#x3C;span [style.text-decoration]=\"lineThrough\">\n    {{prefix}} {{hero?.name}}\n  &#x3C;/span>\n  &#x3C;button (click)=\"delete()\"><a href=\"api/http/RequestMethod#Delete\" class=\"code-anchor\">Delete</a>&#x3C;/button>\n&#x3C;/div>`\n\n</code-example>\n<code-example path=\"template-syntax/src/app/hero-detail.component.ts\" linenums=\"false\" header=\"src/app/hero-detail.component.ts (deleteRequest)\" region=\"deleteRequest\">\n// 이 컴포넌트는 삭제 요청을 보내기만 하고, 실제 삭제 동작을 수행하지는 않습니다.\ndeleteRequest = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;Hero>();\n\ndelete() {\n  this.deleteRequest.emit(this.hero);\n}\n\n</code-example>\n<!--\nThe component defines a `deleteRequest` property that returns an `EventEmitter`.\nWhen the user clicks *delete*, the component invokes the `delete()` method,\ntelling the `EventEmitter` to emit a `Hero` object.\n-->\n<p>사용자가 <em>삭제</em> 버튼을 클릭하면 <code>delete()</code> 메소드를 실행하고,\n이 함수에서는 컴포넌트에 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 타입으로 선언한 <code>deleteRequest</code> 프로퍼티에 <code>Hero</code> 객체를 담아 컴포넌트 외부로 보냅니다.</p>\n<!--\nNow imagine a hosting parent component that binds to the `HeroDetailComponent`'s `deleteRequest` event.\n-->\n<p>그러면 부모 컴포넌트에서 이 이벤트를 받기 위해 <code>deleteRequest</code> 프로퍼티를 바인딩하고 있어야 합니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" linenums=\"false\" header=\"src/app/app.component.html (event-binding-to-component)\" region=\"event-binding-to-component\">\n&#x3C;app-hero-detail (deleteRequest)=\"deleteHero($event)\" [hero]=\"currentHero\">&#x3C;/app-hero-detail>\n\n</code-example>\n<!--\nWhen the `deleteRequest` event fires, Angular calls the parent component's `deleteHero` method,\npassing the *hero-to-delete* (emitted by `HeroDetail`) in the `$event` variable.\n-->\n<p>최종적으로 <code>deleteRequest</code> 이벤트가 발생하면 Angular는 부모 컴포넌트의 <code>deleteHero</code> 메소드를 실행하면서\n<em>삭제해야할 히어로</em>에 대한 정보를 <code>$event</code> 변수에 담아 전달합니다.</p>\n<!--\n### Template statements have side effects\n-->\n<h3 id=\"템플릿-실행문의-영향\">템플릿 실행문의 영향<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#템플릿-실행문의-영향\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe `deleteHero` method has a side effect: it deletes a hero.\nTemplate statement side effects are not just OK, but expected.\n-->\n<p><code>deleteHero()</code> 메소드는 히어로 목록 중 하나를 삭제합니다.\n템플릿 실행문이 항상 애플리케이션에 영향을 줄지 정확하게 알 수는 없지만, 영향을 줄 가능성은 있습니다.</p>\n<!--\nDeleting the hero updates the model, perhaps triggering other changes\nincluding queries and saves to a remote server.\nThese changes percolate through the system and are ultimately displayed in this and other views.\n-->\n<p>예제 코드로 보면, 히어로를 삭제하면 모델이 업데이트 되면서 서버에 새로운 목록을 요청하거나 삭제 요청을 보내는 등 다른 동작을 유발할 수 있습니다.\n이런 동작들은 뷰 데이터를 갱신하고 서버에 반영하면서 시스템을 자연스럽게 유지합니다.</p>\n<hr>\n<!--\n<a id=\"two-way\"></a>\n-->\n<a id=\"양방향-바인딩\"></a>\n<!--\n## Two-way binding ( <span class=\"syntax\">[(...)]</span> )\n-->\n<h2 id=\"양방향-바인딩---\">양방향 바인딩 ( <span class=\"syntax\">[(...)]</span> )<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#양방향-바인딩---\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nYou often want to both display a data property and update that property when the user makes changes.\n-->\n<p>어떤 데이터는 화면에 표시되기도 하지만 사용자의 동작에 따라 새로운 값으로 갱신되어야 하는 경우도 있습니다.</p>\n<!--\nOn the element side that takes a combination of setting a specific element property\nand listening for an element change event.\n-->\n<p>이 동작은 지금까지 살펴본 두 종류의 단방향 바인딩, 컴포넌트 프로퍼티 값을 템플릿에 반영하거나 템플릿에서 발생한 이벤트를 컴포넌트로 바인딩하는 방법을 조합해서 구현할 수 있습니다.</p>\n<!--\nAngular offers a special _two-way data binding_ syntax for this purpose, **`[(x)]`**.\nThe `[(x)]` syntax combines the brackets\nof _property binding_, `[x]`, with the parentheses of _event binding_, `(x)`.\n-->\n<p>이렇게 구현하는 바인딩을 양방향 바인딩이라고 하며,\n양방향 바인딩은 <em>프로퍼티 바인딩</em> 문법인 <code>[x]</code>과 <em>이벤트 바인딩</em> 문법인 <code>(x)</code>를 조합해서 <strong><code>[(x)]</code></strong>와 같이 구현합니다.</p>\n<div class=\"callout is-important\">\n<header>\n<!--\n  [( )] = banana in a box\n-->\n  [( )] = 상자 안에 든 바나나\n</header>\n<!--\nVisualize a *banana in a box* to remember that the parentheses go _inside_ the brackets.\n-->\n<p>두 괄호 중 어떤 괄호가 안에 들어가는지 헷갈린다면 <em>상자 안에 든 바나나</em> 의 모양을 떠올려 보세요.</p>\n</div>\n<!--\nThe `[(x)]` syntax is easy to demonstrate when the element has a settable property called `x`\nand a corresponding event named `xChange`.\nHere's a `SizerComponent` that fits the pattern.\nIt has a `size` value property and a companion `sizeChange` event:\n-->\n<p><code>[(x)]</code> 라고 사용하면 컴포넌트에서 이름이 <code>x</code>인 프로퍼티가 프로퍼티 바인딩 되면서, 이벤트 이름이 <code>xChange</code>인 이벤트가 함께 이벤트 바인딩 됩니다.\n<code>SizerComponent</code> 예제를 보면서 이 내용을 확인해봅시다.\n이 컴포넌트에는 <code>size</code> 프로퍼티와 <code>sizeChange</code> 이벤트가 선언되어 있습니다.</p>\n<code-example path=\"template-syntax/src/app/sizer.component.ts\" header=\"src/app/sizer.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/Output\" class=\"code-anchor\">Output</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-sizer',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n  &#x3C;div>\n    &#x3C;button (click)=\"dec()\" title=\"smaller\">-&#x3C;/button>\n    &#x3C;button (click)=\"inc()\" title=\"bigger\">+&#x3C;/button>\n    &#x3C;label [style.font-size.px]=\"size\">FontSize: {{size}}px&#x3C;/label>\n  &#x3C;/div>`\n})\nexport class SizerComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()  size: number | string;\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() sizeChange = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;number>();\n\n  dec() { this.resize(-1); }\n  inc() { this.resize(+1); }\n\n  resize(delta: number) {\n    this.size = Math.min(40, Math.max(8, +this.size + delta));\n    this.sizeChange.emit(this.size);\n  }\n}\n\n\n</code-example>\n<!--\nThe initial `size` is an input value from a property binding.\nClicking the buttons increases or decreases the `size`, within min/max values constraints,\nand then raises (_emits_) the `sizeChange` event with the adjusted size.\n-->\n<p><code>size</code> 프로퍼티의 초기값은 프로퍼티 바인딩에 의해 할당됩니다.\n그리고 사용자가 증가 버튼이나 감소 버튼을 클릭하면 <code>size</code> 값을 증가시키거나 감소시키고,\n<code>sizeChange</code> 프로퍼티를 통해 커스텀 이벤트를 발생시킵니다.</p>\n<!--\nHere's an example in which the `AppComponent.fontSizePx` is two-way bound to the `SizerComponent`:\n-->\n<p>이 때 받은 커스텀 이벤트를 활용해서 <code>SizerComponent</code> 의 부모 컴포넌트인 <code>AppComponent</code>의 <code>fontSizePx</code> 프로퍼티를 양방향 바인딩으로 연결해 봅시다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" linenums=\"false\" header=\"src/app/app.component.html (two-way-1)\" region=\"two-way-1\">\n&#x3C;app-sizer [(size)]=\"fontSizePx\">&#x3C;/app-sizer>\n&#x3C;div [style.font-size.px]=\"fontSizePx\">Resizable <a href=\"api/http/ResponseContentType#Text\" class=\"code-anchor\">Text</a>&#x3C;/div>\n\n</code-example>\n<!--\nThe `AppComponent.fontSizePx` establishes the initial `SizerComponent.size` value.\nClicking the buttons updates the `AppComponent.fontSizePx` via the two-way binding.\nThe revised `AppComponent.fontSizePx` value flows through to the _style_ binding,\nmaking the displayed text bigger or smaller.\n-->\n<p><code>AppComponent</code>에서도 <code>fontSizePx</code> 프로퍼티의 초기값은 <code>SizerComponent.size</code> 값으로 초기화 됩니다.\n그리고 증감 버튼을 누를때마다 <code>AppComponent.fontSizePx</code>값이 양방향 바인딩에 의해 갱신됩니다.\n이렇게 갱신된 <code>AppComponent.fontSizePx</code> 값은 <em>스타일</em> 바인딩으로 연결되면서, <code>Resizable <a href=\"api/http/ResponseContentType#Text\" class=\"code-anchor\">Text</a></code>의 크기가 커지거나 작아집니다.</p>\n<!--\nThe two-way binding syntax is really just syntactic sugar for a _property_ binding and an _event_ binding.\nAngular _desugars_ the `SizerComponent` binding into this:\n-->\n<p>엄밀히 얘기하면, 양방향 바인딩 문법은 <em>프로퍼티</em> 바인딩과 <em>이벤트</em> 바인딩을 하나로 묶어둔 문법 설탕(syntatic sugar)일 뿐입니다.\n프로퍼티 바인딩과 이벤트 바인딩을 각각 구현하려면 코드를 다음과 같이 작성합니다:</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" linenums=\"false\" header=\"src/app/app.component.html (two-way-2)\" region=\"two-way-2\">\n&#x3C;app-sizer [size]=\"fontSizePx\" (sizeChange)=\"fontSizePx=$event\">&#x3C;/app-sizer>\n\n</code-example>\n<!--\nThe `$event` variable contains the payload of the `SizerComponent.sizeChange` event.\nAngular assigns the `$event` value to the `AppComponent.fontSizePx` when the user clicks the buttons.\n-->\n<p><code>$event</code> 객체에는 <code>SizeComponent.sizeChange</code> 이벤트에서 보내는 폰트 크기값이 담겨 있습니다.\n그래서 사용자가 증감 버튼을 클릭해서 이벤트가 발생할 때마다 <code>AppComponent.fontSizePx</code> 프로퍼티의 값을 새로운 값으로 할당하고 있습니다.</p>\n<!--\nClearly the two-way binding syntax is a great convenience compared to separate property and event bindings.\n-->\n<p>이렇게 보면 프로퍼티 바인딩과 이벤트 바인딩을 각각 구현하는 것보다 양방향 바인딩 문법을 사용하는 것이 훨씬 간단합니다.</p>\n<!--\nIt would be convenient to use two-way binding with HTML form elements like `<input>` and `<select>`.\nHowever, no native HTML element follows the `x` value and `xChange` event pattern.\n-->\n<p>그리고 양방향 바인딩을 <code>&#x3C;input></code> 엘리먼트나 <code>&#x3C;select></code> 엘리먼트와 같은 HTML 폼 엘리먼트에 사용한다면 양방향 문법의 편리함을 확실하게 느낄 수 있습니다.\n하지만 네이티브 HTML 엘리먼트에 <code>x</code> 프로퍼티나 <code>xChange</code> 라는 이벤트가 있지는 않습니다.</p>\n<!--\nFortunately, the Angular [_NgModel_](guide/template-syntax#ngModel) directive is a bridge that enables two-way binding to form elements.\n-->\n<p>다행히 Angular는 폼 엘리먼트에 양방향 바인딩을 간편하게 연결할 수 있도록 <a href=\"guide/template-syntax#ngModel\"><em>NgModel</em></a> 디렉티브를 제공합니다.</p>\n<hr>\n<!--\n<a id=\"directives\"></a>\n-->\n<a id=\"디렉티브\"></a>\n<!--\n## Built-in directives\n-->\n<h2 id=\"기본-디렉티브\">기본 디렉티브<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#기본-디렉티브\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nEarlier versions of Angular included over seventy built-in directives.\nThe community contributed many more, and countless private directives\nhave been created for internal applications.\n-->\n<p>Angular 1.x 버전이었던 AngularJS에는 프레임워크가 제공하는 디렉티브가 70개 이상 있었습니다.\n이것은 Angular 커뮤니티에서 너무 큰 의욕을 가지고 개발에 참여한 결과이며, 내부용으로만 쓰이던 디렉티브도 자꾸만 늘어나고 있었습니다.</p>\n<!--\nYou don't need many of those directives in Angular.\nYou can often achieve the same results with the more capable and expressive Angular binding system.\nWhy create a directive to handle a click when you can write a simple binding such as this?\n-->\n<p>이제 Angular에 이렇게 많은 디렉티브는 필요없습니다.\nAngularJS에서 디렉티브로 해야 했던 많은 작업들은 이제 바인딩 시스템으로 더 간단하고 우아하게 구현할 수 있습니다.\n클릭 이벤트를 처리하는 경우만 생각해봐도, 이벤트 바인딩이 이렇게 간단한데 클릭 이벤트를 처리하는 디렉티브를 굳이 만들 필요는 없겠죠?</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"event-binding-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;button (click)=\"onSave()\">Save&#x3C;/button>\n\n</code-example>\n<!--\nYou still benefit from directives that simplify complex tasks.\nAngular still ships with built-in directives; just not as many.\nYou'll write your own directives, just not as many.\n-->\n<p>하지만 복잡한 로직을 간단하게 표현하는 디렉티브의 역할은 아직 유효합니다.\n그리고 이전보다 줄었지만 Angular가 제공하는 기본 디렉티브도 아직 있습니다.\n필요하면 얼마든지 디렉티브를 만들어서 활용할 수 있습니다.</p>\n<!--\nThis segment reviews some of the most frequently used built-in directives,\nclassified as either [_attribute_ directives](guide/template-syntax#attribute-directives) or [_structural_ directives](guide/template-syntax#structural-directives).\n-->\n<p>이번에는 기본 디렉티브 중에서 가장 많이 쓰이는 디렉티브인 <a href=\"guide/template-syntax#%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8-%EB%94%94%EB%A0%89%ED%8B%B0%EB%B8%8C\"><em>어트리뷰트</em> 디렉티브</a>와 <a href=\"guide/template-syntax#%EA%B5%AC%EC%A1%B0-%EB%94%94%EB%A0%89%ED%8B%B0%EB%B8%8C\"><em>구조 디렉티브</em></a>에 대해 알아보겠습니다.</p>\n<hr>\n<!--\n<a id=\"attribute-directives\"></a>\n-->\n<a id=\"어트리뷰트-디렉티브\"></a>\n<!--\n## Built-in _attribute_ directives\n-->\n<h2 id=\"기본-어트리뷰트-디렉티브\">기본 <em>어트리뷰트</em> 디렉티브<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#기본-어트리뷰트-디렉티브\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAttribute directives listen to and modify the behavior of\nother HTML elements, attributes, properties, and components.\nThey are usually applied to elements as if they were HTML attributes, hence the name.\n-->\n<p>어트리뷰트 디렉티브는 HTML 엘리먼트나 어트리뷰트, 프로퍼티, 컴포넌트의 동작을 조작합니다.\n같은 이름의 어트리뷰트가 있으면 어트리뷰트 디렉티브의 우선순위가 더 높습니다.</p>\n<!--\nMany details are covered in the [_Attribute Directives_](guide/attribute-directives) guide.\nMany NgModules such as the [`RouterModule`](guide/router \"Routing and Navigation\")\nand the [`FormsModule`](guide/forms \"Forms\") define their own attribute directives.\nThis section is an introduction to the most commonly used attribute directives:\n-->\n<p>어트리뷰트 디렉티브는 별도의 <a href=\"guide/attribute-directives\"><em>어트리뷰트 디렉티브</em></a> 가이드 문서에서 자세하게 다룹니다.\n그리고 <a href=\"guide/router\" title=\"Routing and Navigation\"><code>RouterModule</code></a>이나 <a href=\"guide/forms\" title=\"Forms\"><code>FormsModule</code></a>같은 모듈은 해당 모듈에 필요한 어트리뷰트 디렉티브를 따로 정의해두기도 합니다.\n다음과 같은 어트리뷰트 디렉티브는 개발하면서 자주 사용하게 될 것입니다:</p>\n<!--\n* [`NgClass`](guide/template-syntax#ngClass) - add and remove a set of CSS classes\n* [`NgStyle`](guide/template-syntax#ngStyle) - add and remove a set of HTML styles\n* [`NgModel`](guide/template-syntax#ngModel) - two-way data binding to an HTML form element\n-->\n<ul>\n<li><a href=\"guide/template-syntax#ngClass\"><code>NgClass</code></a> - CSS 클래스를 추가하거나 제거합니다.</li>\n<li><a href=\"guide/template-syntax#ngStyle\"><code>NgStyle</code></a> - HTML 스타일을 추가하거나 제거합니다.</li>\n<li><a href=\"guide/template-syntax#ngModel\"><code>NgModel</code></a> - HTML 폼 엘리먼트에 양방향 바인딩을 연결합니다.</li>\n</ul>\n<hr>\n<a id=\"ngClass\"></a>\n<h3 id=\"ngclass\">NgClass<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#ngclass\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou typically control how elements appear\nby adding and removing CSS classes dynamically.\nYou can bind to the `ngClass` to add or remove several classes simultaneously.\n-->\n<p>엘리먼트가 화면에 표시되는 형식을 지정할 때는 보통 CSS 클래스를 사용하는데,\n이 때 <code><a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a></code>를 사용하면 여러 개의 클래스를 조건에 따라 각각 지정하거나 해제할 수 있습니다.</p>\n<!--\nA [class binding](guide/template-syntax#class-binding) is a good way to add or remove a *single* class.\n-->\n<p>클래스 <em>하나만</em> 조작한다면 <a href=\"guide/template-syntax#%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%B0%94%EC%9D%B8%EB%94%A9\">클래스 바인딩</a>을 사용하는 것도 나쁘지 않습니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"class-binding-3a\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- 프로퍼티로 \"special\" 클래스 토글하기 -->\n&#x3C;div [class.special]=\"isSpecial\">The class binding is special&#x3C;/div>\n\n</code-example>\n<!--\nTo add or remove *many* CSS classes at the same time, the `NgClass` directive may be the better choice.\n-->\n<p>하지만 클래스 <em>여러 개를 동시에</em> 조작한다면 클래스 바인딩을 사용하는 것보다 <code><a href=\"api/common/NgClass\" class=\"code-anchor\">NgClass</a></code> 디렉티브를 사용하는 것이 더 좋습니다.</p>\n<!--\nTry binding `ngClass` to a key:value control object.\nEach key of the object is a CSS class name; its value is `true` if the class should be added,\n`false` if it should be removed.\n-->\n<p><code><a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a></code>에는 <code>키:값</code> 형식의 객체를 바인딩합니다.\n이 때 각각의 키에 CSS 클래스 이름을 지정하며, 키 값이 <code>true</code>면 해당 클래스가 지정되고 키 값이 <code>false</code>면 해당 클래스가 해제됩니다.</p>\n<!--\nConsider a `setCurrentClasses` component method that sets a component property,\n`currentClasses` with an object that adds or removes three classes based on the\n`true`/`false` state of three other component properties:\n-->\n<p>지정해야 하는 클래스가 여러 개라면 컴포넌트 프로퍼티를 따로 선언하고, 이 프로퍼티 값을 메소드로 지정하는 방법도 고려해볼만 합니다.\n아래 예제에서는 다른 프로퍼티 값에 따라 3개의 클래스를 각각 제어하기 위해 <code>currentClasses</code> 프로퍼티 값을 지정하는 <code>setCurrentClasses</code> 메소드를 정의했습니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.ts\" region=\"setClasses\" header=\"src/app/app.component.ts\" linenums=\"false\">\ncurrentClasses: {};\nsetCurrentClasses() {\n  // 컴포넌트 프로퍼티의 현재 스테이트에 따라 CSS 클래스를 지정하거나 제거합니다.\n  this.currentClasses =  {\n    'saveable': this.canSave,\n    'modified': !this.isUnchanged,\n    'special':  this.isSpecial\n  };\n}\n\n</code-example>\n<!--\nAdding an `ngClass` property binding to `currentClasses` sets the element's classes accordingly:\n-->\n<p>그리고 <code>currentClasses</code>를 <code><a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a></code> 디렉티브에 바인딩하려면 다음과 같이 구현합니다:</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgClass-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"currentClasses\">This div is initially saveable, unchanged, and special&#x3C;/div>\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\nIt's up to you to call `setCurrentClasses()`, both initially and when the dependent properties change.\n-->\n<p><code>setCurrentClasses()</code> 함수는 컴포넌트가 초기화될 때 실행되고, 연결된 컴포넌트 프로퍼티의 값이 변경될 때마다 실행됩니다.</p>\n</div>\n<hr>\n<a id=\"ngStyle\"></a>\n<h3 id=\"ngstyle\">NgStyle<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#ngstyle\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou can set inline styles dynamically, based on the state of the component.\nWith `NgStyle` you can set many inline styles simultaneously.\n-->\n<p><code><a href=\"api/common/NgStyle\" class=\"code-anchor\">NgStyle</a></code> 디렉티브를 사용하면 여러 개의 인라인 스타일을 각각 조건에 맞게 동적으로 지정할 수 있습니다.</p>\n<!--\nA [style binding](guide/template-syntax#style-binding) is an easy way to set a *single* style value.\n-->\n<p>이 때 지정해야 하는 스타일이 <em>하나</em>라면 <a href=\"guide/template-syntax#%EC%8A%A4%ED%83%80%EC%9D%BC-%EB%B0%94%EC%9D%B8%EB%94%A9\">스타일 바인딩</a>을 사용하는 것이 간단할 수 있습니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgStyle-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div [style.font-size]=\"isSpecial ? 'x-large' : 'smaller'\" >\n  This div is x-large or smaller.\n&#x3C;/div>\n\n</code-example>\n<!--\nTo set *many* inline styles at the same time, the `NgStyle` directive may be the better choice.\n-->\n<p>하지만 <em>여러 개</em>의 인라인 스타일을 한 번에 지정하려면 <code><a href=\"api/common/NgStyle\" class=\"code-anchor\">NgStyle</a></code> 디렉티브를 사용하는 것이 더 좋습니다.</p>\n<!--\nTry binding `ngStyle` to a key:value control object.\nEach key of the object is a style name; its value is whatever is appropriate for that style.\n-->\n<p><code><a href=\"api/common/NgStyle\" class=\"code-anchor\">ngStyle</a></code>에는 <code>키:값</code> 형식의 객체를 바인딩합니다.\n이 때 각각의 키에 스타일 이름을 지정하며, 해당 스타일은 키 값으로 지정됩니다.</p>\n<!--\nConsider a `setCurrentStyles` component method that sets a component property, `currentStyles`\nwith an object that defines three styles, based on the state of three other component properties:\n-->\n<p>지정해야 하는 스타일이 여러 개라면 컴포넌트 프로퍼티를 따로 선언하고, 이 프로퍼티 값을 메소드로 지정하는 것도 고려해볼만 합니다.\n아래 예제에서는 다른 프로퍼티 값에 따라 3개의 스타일을 각각 제어하기 위해 <code>currentStyles</code> 프로퍼티 값을 지정하는 <code>setCurrentStyles</code> 메소드를 정의했습니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.ts\" region=\"setStyles\" header=\"src/app/app.component.ts\" linenums=\"false\">\ncurrentStyles: {};\nsetCurrentStyles() {\n  // 컴포넌트 프로퍼티의 현재 스테이트에 따라 CSS 스타일을 지정합니다.\n  this.currentStyles = {\n    'font-style':  this.canSave      ? 'italic' : 'normal',\n    'font-weight': !this.isUnchanged ? 'bold'   : 'normal',\n    'font-size':   this.isSpecial    ? '24px'   : '12px'\n  };\n}\n\n</code-example>\n<!--\nAdding an `ngStyle` property binding to `currentStyles` sets the element's styles accordingly:\n-->\n<p>그리고 <code>currentStyles</code>를 <code><a href=\"api/common/NgStyle\" class=\"code-anchor\">ngStyle</a></code> 디렉티브에 바인딩하려면 다음과 같이 구현합니다:</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgStyle-2\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div [<a href=\"api/common/NgStyle\" class=\"code-anchor\">ngStyle</a>]=\"currentStyles\">\n  This div is initially italic, normal weight, and extra large (24px).\n&#x3C;/div>\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\nIt's up to you to call `setCurrentStyles()`, both initially and when the dependent properties change.\n-->\n<p><code>setCurrentStyles()</code> 함수는 컴포넌트가 초기화될 때 실행되고, 연결된 컴포넌트 프로퍼티의 값이 변경될 때마다 실행됩니다.</p>\n</div>\n<hr>\n<a id=\"ngModel\"></a>\n<!--\n### NgModel - Two-way binding to form elements with <span class=\"syntax\">[(ngModel)]</span>\n-->\n<h3 id=\"ngmodel---양방향-바인딩-디렉티브-ngmodel\">NgModel - 양방향 바인딩 디렉티브 <span class=\"syntax\">[(ngModel)]</span><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#ngmodel---양방향-바인딩-디렉티브-ngmodel\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nWhen developing data entry forms, you often both display a data property and\nupdate that property when the user makes changes.\n-->\n<p>폼을 사용해서 데이터를 입력받을 때, 폼에 있는 데이터를 뷰에 표시한 후에는 뷰에서 사용자가 변경하는 값을 다시 폼 데이터에 반영해야 하는 경우가 있습니다.</p>\n<!--\nTwo-way data binding with the `NgModel` directive makes that easy. Here's an example:\n-->\n<p>이 때 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 디렉티브를 사용하면 양방향 바인딩을 간단하게 구현할 수 있습니다. <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 디렉티브는 다음과 같이 사용합니다:</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" linenums=\"false\" header=\"src/app/app.component.html (NgModel-1)\" region=\"NgModel-1\">\n&#x3C;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"currentHero.name\">\n\n</code-example>\n<!--\n#### _FormsModule_ is required to use _ngModel_\n-->\n<h4 id=\"ngmodel-을-사용하려면-formsmodule-이-필요합니다\"><em>ngModel</em> 을 사용하려면 <em>FormsModule</em> 이 필요합니다.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#ngmodel-을-사용하려면-formsmodule-이-필요합니다\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nBefore using the `ngModel` directive in a two-way data binding,\nyou must import the `FormsModule` and add it to the NgModule's `imports` list.\nLearn more about the `FormsModule` and `ngModel` in the\n[Forms](guide/forms#ngModel) guide.\n-->\n<p><code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 디렉티브로 양방향 바인딩을 구현하려면 NgModule의 <code><a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a></code> 목록에 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>을 추가해야 합니다.\n<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>과 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code>에 대한 자세한 설명은 <a href=\"guide/forms#ngModel\">Forms</a> 문서를 참고하세요.</p>\n<!--\nHere's how to import the `FormsModule` to make `[(ngModel)]` available.\n-->\n<p>NgModule에 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 을 다음과 같이 추가합니다.</p>\n<code-example path=\"template-syntax/src/app/app.module.1.ts\" linenums=\"false\" header=\"src/app/app.module.ts (FormsModule import)\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> }  from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms'; // &#x3C;--- JavaScript import from Angular\n\n/* 기타 심볼 로드 */\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>  // &#x3C;--- 이 모듈을 현재 <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>에 로드합니다.\n  ],\n  /* 모듈 메타데이터 기타 설정 */\n})\nexport class AppModule { }\n\n\n</code-example>\n<!--\n#### Inside <span class=\"syntax\">[(ngModel)]</span>\n-->\n<h4 id=\"ngmodel-동작-원리\"><span class=\"syntax\">[(ngModel)]</span> 동작 원리<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#ngmodel-동작-원리\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nLooking back at the `name` binding, note that\nyou could have achieved the same result with separate bindings to\nthe `<input>` element's  `value` property and `input` event.\n-->\n<p><code>&#x3C;input></code> 엘리먼트에 <code>name</code> 프로퍼티를 양방향 바인딩 한 것을 <code>value</code> 프로퍼티 바인딩과 <code>input</code> 이벤트 바인딩으로 나눠서 구현하면\n다음과 같이 구현할 수 있습니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"without-NgModel\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;input [value]=\"currentHero.name\"\n       (input)=\"currentHero.name=$event.target.value\" >\n\n</code-example>\n<!--\nThat's cumbersome. Who can remember which element property to set and which element event emits user changes?\nHow do you extract the currently displayed text from the input box so you can update the data property?\nWho wants to look that up each time?\n-->\n<p>하지만 이런 구현방식은 비효율적입니다. 지정해야 할 프로퍼티 이름과 바인딩 해야 할 이벤트 이름을 계속 기억할 수 있을까요?\n그리고 사용자가 입력한 값이 바뀔 때마다 연결된 프로퍼티를 찾아서 새로운 값으로 갱신하는 로직을 직접 작성해야 합니다.\n입력 필드마다 이런 작업을 할 필요가 있을까요?</p>\n<!--\nThat `ngModel` directive hides these onerous details behind its own  `ngModel` input and `ngModelChange` output properties.\n-->\n<p><code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 디렉티브를 사용하면 같은 로직을 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 프로퍼티와 <code>ngModelChange</code> 이벤트로 간단하게 연결할 수 있습니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgModel-3\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;input\n  [<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>]=\"currentHero.name\"\n  (ngModelChange)=\"currentHero.name=$event\">\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\nThe `ngModel` data property sets the element's value property and the `ngModelChange` event property\nlistens for changes to the element's value.\n-->\n<p><code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 프로퍼티는 엘리먼트의 프로퍼티 값을 지정하고 <code>ngModelChange</code> 이벤트 프로퍼티는 엘리먼트 값이 변경되는 것을 감지합니다.</p>\n<!--\nThe details are specific to each kind of element and therefore the `NgModel` directive only works for an element\nsupported by a [ControlValueAccessor](api/forms/ControlValueAccessor)\nthat adapts an element to this protocol.\nThe `<input>` box is one of those elements.\nAngular provides *value accessors* for all of the basic HTML form elements and the\n[_Forms_](guide/forms) guide shows how to bind to them.\n-->\n<p><code>&#x3C;input></code> 엘리먼트가 아닌 경우에도 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 디렉티브는 <a href=\"api/forms/ControlValueAccessor\">ControlValueAccessor</a>를 정의하고 있기 때문에 어떤 폼 엘리먼트에서도 같은 효과를 확인할 수 있습니다.\n<code>&#x3C;input></code> 도 이렇게 정의되어 있는 ControlValueAccessor 중 하나를 활용합니다.\nAngular는 모든 HTML 폼 엘리먼트에 대해 <em>값을 참조할 수 있는 중개자</em>를 제공하며, 더 자세한 내용은 <a href=\"guide/forms\"><em>Forms</em></a> 문서를 참고하세요.</p>\n<!--\nYou can't apply `[(ngModel)]` to a non-form native element or a third-party custom component\nuntil you write a suitable *value accessor*,\na technique that is beyond the scope of this guide.\n-->\n<p>HTML 기본 폼 엘리먼트가 아니거나 서드 파티에서 불러온 커스텀 컴포넌트에는 <code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code>을 사용할 수 없습니다.\n이것은 Angular에서 제공하는 폼 중개자가 없기 때문이며, 이 문서에서 설명하는 범위를 넘어서는 문제입니다.</p>\n<!--\nYou don't need a _value accessor_ for an Angular component that you write because you\ncan name the value and event properties\nto suit Angular's basic [two-way binding syntax](guide/template-syntax#two-way) and skip `NgModel` altogether.\nThe [`sizer` shown above](guide/template-syntax#two-way) is an example of this technique.\n-->\n<p>직접 Angular 컴포넌트를 만들어서 사용하는 경우라면 <em>값을 참조하는 중개자</em>를 따로 준비할 필요가 없습니다.\n왜냐하면 컴포넌트를 정의할 때 Angular의 <a href=\"guide/template-syntax#%EC%96%91%EB%B0%A9%ED%96%A5-%EB%B0%94%EC%9D%B8%EB%94%A9\">양방향 바인딩 문법</a>에 맞게 프로퍼티 이름과 이벤트 이름을 지정해야 하기 때문입니다.\n이전에 살펴본 <a href=\"guide/template-syntax#%EC%96%91%EB%B0%A9%ED%96%A5-%EB%B0%94%EC%9D%B8%EB%94%A9\"><code>sizer</code> 예제</a>를 다시 한 번 확인해 보세요.</p>\n</div>\n<!--\nSeparate `ngModel` bindings is an improvement over binding to the element's native properties. You can do better.\n-->\n<p>하지만 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code>과 <code>ngModelChange</code>로 구현하는 양방향 바인딩이 최선의 방법은 아닙니다.\n더 간단한 문법을 사용할 수 있습니다.</p>\n<!--\nYou shouldn't have to mention the data property twice. Angular should be able to capture\nthe component's data property and set it\nwith a single declaration, which it can with the `[(ngModel)]` syntax:\n-->\n<p>데이터 프로퍼티를 두 번이나 참조할 필요는 없습니다. <code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code> 문법을 다음과 같이 사용하면 컴포넌트의 데이터 프로퍼티를 아주 간단하게 양방향 바인딩할 수 있습니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgModel-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"currentHero.name\">\n\n</code-example>\n<!--\nIs `[(ngModel)]` all you need? Is there ever a reason to fall back to its expanded form?\n-->\n<p>이것으로 끝난 걸까요? 폼을 처리하는 로직이 더 복잡하면 어떻게 해야 할까요?</p>\n<!--\nThe `[(ngModel)]` syntax can only _set_ a data-bound property.\nIf you need to do something more or something different, you can write the expanded form.\n-->\n<p><code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code> 문법은 데이터 프로퍼티의 값을 <em>갱신</em>하기만 합니다.\n데이터 프로퍼티 값을 갱신하고 다른 작업이 더 필요하다면, 두 종류 바인딩으로 나눠서 구현해야 합니다.</p>\n<!--\nThe following contrived example forces the input value to uppercase:\n-->\n<p>예를 들어 입력 필드에 있는 값을 대문자로 바꿔서 사용해야 한다면 다음과 같이 구현하면 됩니다:</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgModel-4\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;input\n  [<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>]=\"currentHero.name\"\n  (ngModelChange)=\"setUppercaseName($event)\">\n\n</code-example>\n<!--\nHere are all variations in action, including the uppercase version:\n-->\n<p><code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 디렉티브는 다음과 같이 다양한 문법으로 사용할 수 있습니다.</p>\n<figure>\n  <img src=\"generated/images/guide/template-syntax/ng-model-anim.gif\" alt=\"NgModel variations\" width=\"548\" height=\"208\">\n</figure>\n<hr>\n<!--\n<a id=\"structural-directives\"></a>\n-->\n<a id=\"구조-디렉티브\"></a>\n<!--\n## Built-in _structural_ directives\n-->\n<h2 id=\"기본-구조-디렉티브\">기본 <em>구조</em> 디렉티브<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#기본-구조-디렉티브\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nStructural directives are responsible for HTML layout.\nThey shape or reshape the DOM's _structure_, typically by adding, removing, and manipulating\nthe host elements to which they are attached.\n-->\n<p>구조 디렉티브는 DOM 엘리먼트의 모양을 바꾸거나, DOM 트리에서 DOM 엘리먼트를 추가하거나 제거하는 등 HTML 레이아웃을 조작합니다.</p>\n<!--\nThe deep details of structural directives are covered in the\n[_Structural Directives_](guide/structural-directives) guide\nwhere you'll learn:\n-->\n<p>구조 디렉티브에 대한 자세한 설명은 <a href=\"guide/structural-directives\"><em>구조 디렉티브</em></a> 문서에서 다루며,\n이런 내용을 다룹니다:</p>\n<!--\n* why you\n[_prefix the directive name with an asterisk_ (\\*)](guide/structural-directives#asterisk \"The * in *ngIf\").\n* to use [`<ng-container>`](guide/structural-directives#ngcontainer \"<ng-container>\")\nto group elements when there is no suitable host element for the directive.\n* how to write your own structural directive.\n* that you can only apply [one structural directive](guide/structural-directives#one-per-element \"one per host element\") to an element.\n-->\n<ul>\n<li><a href=\"guide/structural-directives#asterisk\" title=\"The * in *ngIf\"><em>왜 디렉티브 이름 앞에 (*)가 붙는지</em></a></li>\n<li>엘리먼트를 그룹으로 묶는 <a href=\"guide/structural-directives#ngcontainer\" title=\"<ng-container>\"><code>&#x3C;ng-container></code></a> 사용하기</li>\n<li>커스텀 구조 디렉티브 정의하기</li>\n<li>한 엘리먼트에는 <a href=\"guide/structural-directives#one-per-element\" title=\"one per host element\">하나의 구조 디렉티브만</a> 사용할 수 있다는 것</li>\n</ul>\n<!--\n_This_ section is an introduction to the common structural directives:\n-->\n<p>그리고 <em>이 문서</em> 에서는 구조 디렉티브 중에 가장 많이 사용하는 다음 디렉티브들에 대해 알아봅니다.</p>\n<!--\n* [`NgIf`](guide/template-syntax#ngIf) - conditionally add or remove an element from the DOM\n* [`NgSwitch`](guide/template-syntax#ngSwitch) - a set of directives that switch among alternative views\n* [NgForOf](guide/template-syntax#ngFor) - repeat a template for each item in a list\n-->\n<ul>\n<li><a href=\"guide/template-syntax#ngIf\"><code>NgIf</code></a> - 조건에 따라 DOM을 추가하거나 제거합니다.</li>\n<li><a href=\"guide/template-syntax#ngSwitch\"><code>NgSwitch</code></a> - 조건에 따라 여러 뷰 중 하나를 선택합니다.</li>\n<li><a href=\"guide/template-syntax#ngFor\">NgForOf</a> - 배열의 각 항목마다 템플릿을 반복합니다.</li>\n</ul>\n<hr>\n<a id=\"ngIf\"></a>\n<h3 id=\"ngif\">NgIf<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#ngif\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou can add or remove an element from the DOM by applying an `NgIf` directive to\nthat element (called the _host element_).\nBind the directive to a condition expression like `isActive` in this example.\n-->\n<p><code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 디렉티브를 사용하면 조건에 따라 원하는 위치(<em>호스트 엘리먼트</em>)에 엘리먼트를 추가하거나 제거할 수 있습니다.\n다음 예제에서 보면 <code><a href=\"api/router/RouterLinkActive#isActive\" class=\"code-anchor\">isActive</a></code>값에 따라 디렉티브가 뷰에 추가되거나 제거됩니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgIf-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;app-hero-detail *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"<a href=\"api/router/RouterLinkActive#isActive\" class=\"code-anchor\">isActive</a>\">&#x3C;/app-hero-detail>\n\n</code-example>\n<div class=\"alert is-critical\">\n<!--\nDon't forget the asterisk (`*`) in front of `ngIf`.\n-->\n<p><code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 앞에 별표(<code>*</code>)를 꼭 붙여야 합니다.</p>\n</div>\n<!--\nWhen the `isActive` expression returns a truthy value, `NgIf` adds the `HeroDetailComponent` to the DOM.\nWhen the expression is falsy, `NgIf` removes the `HeroDetailComponent`\nfrom the DOM, destroying that component and all of its sub-components.\n-->\n<p>이 코드에서는 <code><a href=\"api/router/RouterLinkActive#isActive\" class=\"code-anchor\">isActive</a></code> 표현식의 값이 참으로 평가되면 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 디렉티브가 <code>HeroDetailComponent</code>를 DOM에 추가합니다.\n그리고 표현식의 값이 거짓으로 평가되면 이 컴포넌트를 DOM에서 제거합니다. 이 때 이 컴포넌트와 이 컴포넌트의 하위 컴포넌트는 모두 종료됩니다.</p>\n<!--\n#### Show/hide is not the same thing\n-->\n<h4 id=\"보이게-하거나-숨기는-것과는-다릅니다\">보이게 하거나 숨기는 것과는 다릅니다.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#보이게-하거나-숨기는-것과는-다릅니다\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nYou can control the visibility of an element with a\n[class](guide/template-syntax#class-binding) or [style](guide/template-syntax#style-binding) binding:\n-->\n<p>엘리먼트가 표시되는 것을 제어할 때는 다음과 같이 <a href=\"guide/template-syntax#%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%B0%94%EC%9D%B8%EB%94%A9\">클래스 바인딩</a>이나 <a href=\"guide/template-syntax#%EC%8A%A4%ED%83%80%EC%9D%BC-%EB%B0%94%EC%9D%B8%EB%94%A9\">스타일 바인딩</a>을 사용해도 됩니다:</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgIf-3\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- isSpecial이 true인 경우 -->\n&#x3C;div [class.hidden]=\"!isSpecial\">Show with class&#x3C;/div>\n&#x3C;div [class.hidden]=\"isSpecial\">Hide with class&#x3C;/div>\n\n&#x3C;!-- HeroDetail 컴포넌트는 DOM에 존재하지만 화면에 표시되지 않습니다. -->\n&#x3C;app-hero-detail [class.hidden]=\"isSpecial\">&#x3C;/app-hero-detail>\n\n&#x3C;div [style.display]=\"isSpecial ? 'block' : 'none'\">Show with <a href=\"api/animations/style\" class=\"code-anchor\">style</a>&#x3C;/div>\n&#x3C;div [style.display]=\"isSpecial ? 'none'  : 'block'\">Hide with <a href=\"api/animations/style\" class=\"code-anchor\">style</a>&#x3C;/div>\n\n</code-example>\n<!--\nHiding an element is quite different from removing an element with `NgIf`.\n-->\n<p>하지만 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 디렉티브의 값이 거짓으로 평가되면 DOM에서 엘리먼트를 완전히 제거합니다.</p>\n<!--\nWhen you hide an element, that element and all of its descendents remain in the DOM.\nAll components for those elements stay in memory and\nAngular may continue to check for changes.\nYou could be holding onto considerable computing resources and degrading performance,\nfor something the user can't see.\n-->\n<p>엘리먼트를 뷰에서 숨기는 방식은 엘리먼트와 하위 엘리먼트가 화면에 보이지 않더라도 여전히 DOM에 남아있습니다.\n이 엘리먼트는 여전히 메모리에도 남아있으며, Angular에서 변화를 감지할 때도 이 엘리먼트가 검사 대상에 포함됩니다.\n이로 인해 엘리먼트가 보이지 않는 상황에서도 불필요한 연산이 실행될 수 있으며, 성능면에서도 좋지 않습니다.</p>\n<!--\nWhen `NgIf` is `false`, Angular removes the element and its descendents from the DOM.\nIt destroys their components, potentially freeing up substantial resources,\nresulting in a more responsive user experience.\n-->\n<p>하지만 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 디렉티브의 값이 <code>false</code>로 평가되면 Angular는 그 엘리먼트와 하위 엘리먼트를 DOM에서 완전히 제거합니다.\n엘리먼트에 해당하는 컴포넌트도 종료되며, 컴포넌트가 종료된 만큼 사용하던 리소스도 반환됩니다.\n애플리케이션의 성능도 물론 좋아집니다.</p>\n<!--\nThe show/hide technique is fine for a few elements with few children.\nYou should be wary when hiding large component trees; `NgIf` may be the safer choice.\n-->\n<p>DOM 구조가 단순하다면 엘리먼트를 보이게 하거나 감추는 것만으로도 충분할 수 있습니다.\n하지만 DOM 구조가 좀 더 복잡해질 수록 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>를 사용하는 것이 더 안전합니다.</p>\n<!--\n#### Guard against null\n-->\n<h4 id=\"null-방지\">null 방지<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#null-방지\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe `ngIf` directive is often used to guard against null.\nShow/hide is useless as a guard.\nAngular will throw an error if a nested expression tries to access a property of `null`.\n-->\n<p><code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 디렉티브는 null 값을 방지하는 용도로도 사용합니다.\n왜냐하면 엘리먼트를 숨기거나 표시하는 것만으로는 엘리먼트에 바인딩되는 값이 null일 때 대응할 수 없기 때문입니다.\n<code>null</code> 객체가 바인딩 된 엘리먼트를 화면에서는 숨겨놨지만, 이 엘리먼트 안쪽의 템플릿 표현식에서 <code>null</code> 객체의 프로퍼티를 참조하려고 하면 Angular가 에러를 발생시킵니다.</p>\n<!--\nHere we see `NgIf` guarding two `<div>`s.\nThe `currentHero` name will appear only when there is a `currentHero`.\nThe `nullHero` will never be displayed.\n-->\n<p>그래서 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 는 다음과 같이 <code>null</code> 값을 방지하는 용도로 사용할 수 있습니다.\n이 코드에서 <code>currentHero</code> 가 바인딩 된 <code>&#x3C;div></code> 는 <code>currentHero</code> 객체가 존재할 때만 표시됩니다.\n그리고 <code>nullHero</code> 가 바인딩 된 <code>&#x3C;div></code>는 절대 표시되지 않을 것입니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgIf-2\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"currentHero\">Hello, {{currentHero.name}}&#x3C;/div>\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"nullHero\">Hello, {{nullHero.name}}&#x3C;/div>\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\nSee also the\n[_safe navigation operator_](guide/template-syntax#safe-navigation-operator \"Safe navigation operator (?.)\")\ndescribed below.\n-->\n<p><a href=\"guide/template-syntax#%EC%95%88%EC%A0%84-%EC%B0%B8%EC%A1%B0-%EC%97%B0%EC%82%B0%EC%9E%90\" title=\"Safe navigation operator (?.)\"><em>안전 참조 연산자</em></a> 에 대해서도 확인해 보세요.</p>\n</div>\n<hr>\n<a id=\"ngFor\"></a>\n<h3 id=\"ngforof\">NgForOf<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#ngforof\"><i class=\"material-icons\">link</i></a></h3>\n<!--\n`NgForOf` is a _repeater_ directive &mdash; a way to present a list of items.\nYou define a block of HTML that defines how a single item should be displayed.\nYou tell Angular to use that block as a template for rendering each item in the list.\n-->\n<p><code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code>는 템플릿을 반복하는 디렉티브이며, 배열의 각 항목을 뷰에 표시할 때 주로 사용합니다.\n이 디렉티브를 사용할 때는 배열의 한 항목을 뷰로 어떻게 표시할지 HTML 템플릿으로 먼저 정의합니다.\n그러면 Angular가 템플릿을 반복할 때마다 배열의 항목이 하나씩 전달되면서 뷰를 표시합니다.</p>\n<!--\nHere is an example of `NgForOf` applied to a simple `<div>`:\n-->\n<p><code>&#x3C;div></code> 엘리먼트에 간단하게 적용해보면 다음과 같이 사용할 수 있습니다:</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgFor-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">{{hero.name}}&#x3C;/div>\n\n</code-example>\n<!--\nYou can also apply an `NgForOf` to a component element, as in this example:\n-->\n<p>그리고 <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> 디렉티브는 컴포넌트에도 직접 사용할 수 있습니다:</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgFor-2\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;app-hero-detail *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\" [hero]=\"hero\">&#x3C;/app-hero-detail>\n\n</code-example>\n<div class=\"alert is-critical\">\n<!--\nDon't forget the asterisk (`*`) in front of `ngFor`.\n-->\n<p><code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 를 사용할 때 별표(*)를 꼭 붙여야 합니다.</p>\n</div>\n<!--\nThe text assigned to `*ngFor` is the instruction that guides the repeater process.\n-->\n<p><code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>의 반복 과정은 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 디렉티브의 오른쪽에 할당하는 문자열로 지정합니다.</p>\n<a id=\"microsyntax\"></a>\n<!--\n#### *ngFor* microsyntax\n-->\n<h4 id=\"ngfor-세부-문법\"><em>ngFor</em> 세부 문법<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#ngfor-세부-문법\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe string assigned to `*ngFor` is not a [template expression](guide/template-syntax#template-expressions).\nIt's a *microsyntax* &mdash; a little language of its own that Angular interprets.\nThe string `\"let hero of heroes\"` means:\n-->\n<p><code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>에 할당하는 문자열은 <a href=\"guide/template-syntax#%ED%85%9C%ED%94%8C%EB%A6%BF-%ED%91%9C%ED%98%84%EC%8B%9D\">템플릿 표현식</a>과는 다릅니다.\n이 문법은 <em>ngFor에만 적용되는 세부 문법</em> 이며, Angular에서 <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 디렉티브를 처리할 때만 사용됩니다.\n<code>\"let hero of heroes\"</code> 이라는 문법은 다음과 같은 의미입니다:</p>\n<!--\n> *Take each hero in the `heroes` array, store it in the local `hero` looping variable, and\nmake it available to the templated HTML for each iteration.*\n-->\n<blockquote>\n<p><em><code>heroes</code> 배열에서 히어로를 하나씩 가져오고, 반복문 안에서만 유효한 지역 변수 <code>hero</code>에 할당합니다. 그러면 반복되는 템플릿 안에서 이 변수를 사용할 수 있습니다.</em></p>\n</blockquote>\n<!--\nAngular translates this instruction into a `<ng-template>` around the host element,\nthen uses this template repeatedly to create a new set of elements and bindings for each `hero`\nin the list.\n-->\n<p>Angular는 부모 엘리먼트 안에 <code>&#x3C;ng-template></code> 을 만들고, 배열의 항목마다 새로운 템플릿을 생성합니다.</p>\n<!--\nLearn about the _microsyntax_ in the [_Structural Directives_](guide/structural-directives#microsyntax) guide.\n-->\n<p><em>ngFor 세부 문법</em> 에 대한 자세한 설명은 <a href=\"guide/structural-directives#microsyntax\"><em>구조 디렉티브</em></a> 가이드를 참고하세요.</p>\n<a id=\"template-input-variable\"></a>\n<a id=\"템플릿-입력-변수\"></a>\n<!--\n### Template input variables\n-->\n<h3 id=\"템플릿-입력-변수\">템플릿 입력 변수<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#템플릿-입력-변수\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe `let` keyword before `hero` creates a _template input variable_ called `hero`.\nThe `NgForOf` directive iterates over the `heroes` array returned by the parent component's `heroes` property\nand sets `hero` to the current item from the array during each iteration.\n-->\n<p><code>hero</code> 안에 있는 <code>let</code> 키워드는 <em>템플릿 입력 변수</em> <code>hero</code>를 만드는 키워드입니다.\n그리고 <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> 디렉티브는 부모 컴포넌트의 <code>heroes</code> 배열의 각 항목을 반환하면서 이 문법을 반복하고, 각각의 반복마다 새로운 <code>hero</code> 아이템을 템플릿에 적용합니다.</p>\n<!--\nYou reference the `hero` input variable within the `NgForOf` host element\n(and within its descendants) to access the hero's properties.\nHere it is referenced first in an interpolation\nand then passed in a binding to the `hero` property of the `<hero-detail>` component.\n-->\n<p><code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> 반복문 안에서는 템플릿 입력변수 <code>hero</code>를 참조해서 객체 안에 있는 데이터에 접근할 수 있습니다.\n아래 코드의 첫번째 반복문은 전달된 <code>hero</code> 객체에서 <code>name</code> 프로퍼티를 뷰에 표시하는 코드이며,\n두 번째 반복문은 반복되는 <code>hero</code> 객체를 <code>&#x3C;app-hero-detail></code> 컴포넌트에 바인딩해서 표시하는 문법입니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgFor-1-2\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">{{hero.name}}&#x3C;/div>\n&#x3C;app-hero-detail *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\" [hero]=\"hero\">&#x3C;/app-hero-detail>\n\n</code-example>\n<!--Learn more about _template input variables_ in the\n[_Structural Directives_](guide/structural-directives#template-input-variable) guide.\n-->\n<p><em>템플릿 입력 변수</em> 에 대한 자세한 설명은 <a href=\"guide/structural-directives#%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%9E%85%EB%A0%A5-%EB%B3%80%EC%88%98\"><em>구조 디렉티브</em></a> 가이드를 참고하세요.</p>\n<!--\n#### *ngFor* with _index_\n-->\n<h4 id=\"인덱스-와-함께-사용하기\"><em>인덱스</em> 와 함께 사용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#인덱스-와-함께-사용하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe `index` property of the `NgForOf` directive context returns the zero-based index of the item in each iteration.\nYou can capture the `index` in a template input variable and use it in the template.\n-->\n<p><code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> 디렉티브에서 제공하는 <code>index</code> 프로퍼티는 반복문이 반복되는 횟수를 나타내는 인덱스입니다.\n이 <code>index</code> 프로퍼티는 템플릿 입력 변수로 할당 받아 템플릿 안에서 사용할 수 있습니다.</p>\n<!--\nThe next example captures the `index` in a variable named `i` and displays it with the hero name like this.\n-->\n<p>다음 코드는 <code>index</code> 프로퍼티를 변수 <code>i</code>로 할당하고 히어로의 이름과 함께 표시하는 예제입니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgFor-3\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes; let i=index\">{{i + 1}} - {{hero.name}}&#x3C;/div>\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\n`NgFor` is implemented by the `NgForOf` directive. Read more about the other `NgForOf` context values such as `last`, `even`,\nand `odd` in the [NgForOf API reference](api/common/NgForOf).\n-->\n<p><code>NgFor</code>는 <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> 디렉티브로 만들어진 또 다른 디렉티브입니다. <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> 컨텍스트에서 제공되는 변수인 <code>last</code>나 <code><a href=\"api/common/NgForOfContext#even\" class=\"code-anchor\">even</a></code>, <code><a href=\"api/common/NgForOfContext#odd\" class=\"code-anchor\">odd</a></code>에 대해 더 알아보려면 <a href=\"api/common/NgForOf\">NgForOf API 문서</a>를 참고하세요.</p>\n</div>\n<a id=\"trackBy\"></a>\n<!--\n#### *ngFor with _trackBy_\n-->\n<h4 id=\"trackby-와-함께-사용하기\"><em>trackBy</em> 와 함께 사용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#trackby-와-함께-사용하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe `NgForOf` directive may perform poorly, especially with large lists.\nA small change to one item, an item removed, or an item added can trigger a cascade of DOM manipulations.\n-->\n<p>배열의 길이가 길수록 <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> 디렉티브의 성능이 나빠질 수 있습니다.\n항목의 내용이 변하거나 목록에서 하나가 제거될 때, 목록에 아이템이 추가될 때마다 DOM을 조작하는 동작이 연쇄적으로 실행될 수도 있습니다.</p>\n<!--\nFor example, re-querying the server could reset the list with all new hero objects.\n-->\n<p>서버에서 새로 리스트를 받아오면서 배열을 초기화하는 경우를 생각해 봅시다.</p>\n<!--\nMost, if not all, are previously displayed heroes.\n*You* know this because the `id` of each hero hasn't changed.\nBut Angular sees only a fresh list of new object references.\nIt has no choice but to tear down the old DOM elements and insert all new DOM elements.\n-->\n<p>항상 그렇지는 않겠지만, 목록 전체가 새로운 데이터로 바뀌는 것은 아닙니다.\n그리고 <em>개발자</em>는 각각의 영웅마다 고유한 값으로 할당되는 <code>id</code> 프로퍼티가 있다는 것을 알고 있습니다.\n새로운 객체가 배열에 할당되면 Angular는 이것을 새로운 객체에 대한 참조로 인식하기 때문에 이전 DOM을 모두 제거하고 새로운 DOM으로 추가할 수 밖에 없습니다.\n하지만 변경되지 않은 데이터가 있는데 DOM을 비우고 배열에 모든 항목에 대해 DOM을 다시 추가하는 것은 비효율적입니다.</p>\n<!--\nAngular can avoid this churn with `trackBy`.\nAdd a method to the component that returns the value `NgForOf` _should_ track.\nIn this case, that value is the hero's `id`.\n-->\n<p>이 때 Angular에서 제공하는 <code>trackBy</code>를 활용할 수 있습니다.\n<code>trackBy</code>를 사용하려면 <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> 디렉티브가 기준으로 삼을 값을 반환하는 함수를 지정합니다.\n위에서 설명한 것처럼, <code>hero</code> 객체에 있는 <code>id</code> 프로퍼티를 활용하려면 다음과 같이 작성합니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.ts\" region=\"trackByHeroes\" header=\"src/app/app.component.ts\" linenums=\"false\">\ntrackByHeroes(index: number, hero: Hero): number { return hero.id; }\n\n</code-example>\n<!--\nIn the microsyntax expression, set `trackBy` to this method.\n-->\n<p>그리고 세부 문법에 <code>trackBy</code>를 사용해서 이 함수를 지정합니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"trackBy\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes; trackBy: trackByHeroes\">\n  ({{hero.id}}) {{hero.name}}\n&#x3C;/div>\n\n</code-example>\n<!--\nHere is an illustration of the _trackBy_ effect.\n\"Reset heroes\" creates new heroes with the same `hero.id`s.\n\"Change ids\" creates new heroes with new `hero.id`s.\n-->\n<p><em>trackBy</em> 가 어떻게 동작하는지 다음 그림을 보면서 확인해 보세요.\n\"Reset heroes\" 버튼은 히어로 목록을 초기화하면서 고정된 <code>id</code> 프로퍼티 값을 할당합니다.\n그리고 \"Change ids\" 버튼은 히어로의 <code>id</code> 프로퍼티를 새로운 값으로 지정합니다.</p>\n<!--\n* With no `trackBy`, both buttons trigger complete DOM element replacement.\n* With `trackBy`, only changing the `id` triggers element replacement.\n-->\n<ul>\n<li><code>trackBy</code>가 없는 경우에는 목록을 초기화하는 동작과 <code>id</code> 프로퍼티를 변경하는 값 모두 DOM 엘리먼트를 갱신합니다.</li>\n<li><code>trackBy</code>가 있는 경우에는 <code>id</code> 프로퍼티가 변경되었을 때만 엘리먼트를 갱신합니다.</li>\n</ul>\n<figure>\n  <img src=\"generated/images/guide/template-syntax/ng-for-track-by-anim.gif\" alt=\"trackBy\" width=\"626\" height=\"578\">\n</figure>\n<hr>\n<a id=\"ngSwitch\"></a>\n<!--\n### The _NgSwitch_ directives\n-->\n<h3 id=\"ngswitch-디렉티브\"><em>NgSwitch</em> 디렉티브<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#ngswitch-디렉티브\"><i class=\"material-icons\">link</i></a></h3>\n<!--\n*NgSwitch* is like the JavaScript `switch` statement.\nIt can display _one_ element from among several possible elements, based on a _switch condition_.\nAngular puts only the *selected* element into the DOM.\n-->\n<p><em>NgSwitch</em> 디렉티브는 JavaScript의 <code>switch</code> 문법과 비슷합니다.\n이 디렉티브는 가능한 경우 몇가지 중에서 <em>스위치 조건</em> 에 만족하는 엘리먼트 <em>하나를</em> 뷰에 표시합니다.\n이 때 <em>선택된</em> 엘리먼트만 DOM에 추가되며, 조건을 만족하지 않는 엘리먼트들은 DOM에 존재하지 않습니다.</p>\n<!--\n*NgSwitch* is actually a set of three, cooperating directives:\n`NgSwitch`, `NgSwitchCase`, and `NgSwitchDefault` as seen in this example.\n-->\n<p>실제로는 <em>NgSwitch</em> 디렉티브 하나만 사용하지는 않습니다.\n스위칭 동작을 하려면 <code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code>, <code><a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">NgSwitchCase</a></code>, <code><a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">NgSwitchDefault</a></code> 3개의 디렉티브를 함께 사용합니다.\n예제 코드를 확인해 보세요.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgSwitch\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div [<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a>]=\"currentHero.emotion\">\n  &#x3C;app-happy-hero    *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'happy'\"    [hero]=\"currentHero\">&#x3C;/app-happy-hero>\n  &#x3C;app-sad-hero      *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'sad'\"      [hero]=\"currentHero\">&#x3C;/app-sad-hero>\n  &#x3C;app-confused-hero *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'confused'\" [hero]=\"currentHero\">&#x3C;/app-confused-hero>\n  &#x3C;app-unknown-hero  *<a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">ngSwitchDefault</a>           [hero]=\"currentHero\">&#x3C;/app-unknown-hero>\n&#x3C;/div>\n\n</code-example>\n<figure>\n  <img src=\"generated/images/guide/template-syntax/switch-anim.gif\" alt=\"trackBy\" width=\"444\" height=\"100\">\n</figure>\n<!--\n`NgSwitch` is the controller directive. Bind it to an expression that returns the *switch value*.\nThe `emotion` value in this example is a string, but the switch value can be of any type.\n-->\n<p><code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code>는 해당하는 조건을 선택하는 디렉티브입니다. 이 디렉티브는 템플릿 표현식이 반환하는 값에 해당하는 <em>특정 조건</em>을 선택합니다.\n위 예제에서는 문자열 타입의 <code>emotion</code> 변수로 조건을 판단했지만, 타입은 자유롭게 사용할 수 있습니다.</p>\n<!--\n**Bind to `[ngSwitch]`**. You'll get an error if you try to set `*ngSwitch` because\n`NgSwitch` is an *attribute* directive, not a *structural* directive.\nIt changes the behavior of its companion directives.\nIt doesn't touch the DOM directly.\n-->\n<p>스위칭 조건을 판단하는 템플릿 표현식은 <strong><code>[<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a>]</code></strong> 와 같이 바인딩합니다.\n이 때 문법을 <code>*<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a></code>로 사용해도 되지 않을까 생각할 수 있지만, <code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code>는 <em>구조</em> 디렉티브가 아니라 <em>어트리뷰트</em> 디렉티브이기 때문에 <code>*<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a></code>로 사용하면 에러가 발생합니다.\n<code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code>는 엘리먼트의 동작을 변화시키는 디렉티브이며, DOM을 직접 조작하지는 않습니다.</p>\n<!--\n**Bind to `*ngSwitchCase` and `*ngSwitchDefault`**.\nThe `NgSwitchCase` and `NgSwitchDefault` directives are _structural_ directives\nbecause they add or remove elements from the DOM.\n-->\n<p><code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code>와는 다르게 <code><a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">NgSwitchCase</a></code>와 <code><a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">NgSwitchDefault</a></code>는 <em>구조</em> 디렉티브이며, <code>*<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a></code>, <code>*<a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">ngSwitchDefault</a></code>와 같이 사용합니다.\n두 디렉티브는 DOM에 엘리먼트를 직접 추가하거나 제거하는 디렉티브입니다.</p>\n<!--\n* `NgSwitchCase` adds its element to the DOM when its bound value equals the switch value.\n* `NgSwitchDefault` adds its element to the DOM when there is no selected `NgSwitchCase`.\n-->\n<ul>\n<li><code><a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">NgSwitchCase</a></code>는 스위칭 조건이 맞을 때 해당 엘리먼트를 DOM에 추가합니다.</li>\n<li><code><a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">NgSwitchDefault</a></code>는 <code><a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">NgSwitchCase</a></code>가 하나도 선택되지 않았을 때 DOM에 추가하는 엘리먼트를 지정합니다.</li>\n</ul>\n<!--\nThe switch directives are particularly useful for adding and removing *component elements*.\nThis example switches among four \"emotional hero\" components defined in the `hero-switch.components.ts` file.\nEach component has a `hero` [input property](guide/template-syntax#inputs-outputs \"Input property\")\nwhich is bound to the `currentHero` of the parent component.\n-->\n<p>스위치 디렉티브는 <em>컴포넌트 엘리먼트를</em> DOM에 추가하거나 제거하는 용도로도 많이 사용합니다.\n위에서 살펴본 예제는 <code>hero-switch.component.ts</code> 파일에 정의된 컴포넌트 4개를 하나씩 선택해서 적용하는 예제입니다.\n각각의 컴포넌트는 부모 컴포넌트에서 전달되는 <code>currentHero</code> 프로퍼티를 <code>hero</code>를 <a href=\"guide/template-syntax#%EC%9E%85%EC%B6%9C%EB%A0%A5-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0\" title=\"Input property\">입력 프로퍼티</a>로 바인딩합니다.</p>\n<!--\nSwitch directives work as well with native elements and web components too.\nFor example, you could replace the `<confused-hero>` switch case with the following.\n-->\n<p>그리고 스위치 디렉티브는 네이티브 엘리먼트나 웹 컴포넌트에도 자연스럽게 적용할 수 있습니다.\n위 예제에서 <code>&#x3C;confused-hero></code>에 사용했던 스위치 디렉티브는 다음과 같이 네이티브 엘리먼트에도 사용할 수 있습니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgSwitch-div\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'confused'\">Are you as confused as {{currentHero.name}}?&#x3C;/div>\n\n</code-example>\n<hr>\n<a id=\"template-reference-variable\"></a>\n<a id=\"ref-vars\"></a>\n<a id=\"ref-var\"></a>\n<a id=\"템플릿-참조-변수\"></a>\n<!--\n## Template reference variables ( <span class=\"syntax\">#var</span> )\n-->\n<h2 id=\"템플릿-참조-변수--var-\">템플릿 참조 변수 ( <span class=\"syntax\">#var</span> )<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#템플릿-참조-변수--var-\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nA **template reference variable** is often a reference to a DOM element within a template.\nIt can also be a reference to an Angular component or directive or a\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/Web_Components\" title=\"MDN: Web Components\">web component</a>.\n-->\n<p><strong>템플릿 참조 변수</strong>는 템플릿 안에서 DOM 엘리먼트를 가리킬 때 사용합니다.\n그리고 DOM뿐 아니라 Angular 컴포넌트나 디렉티브, <a href=\"https://developer.mozilla.org/en-US/docs/Web/Web_Components\" title=\"MDN: Web Components\">웹 컴포넌트</a>를 가리킬 때도 사용할 수 있습니다.</p>\n<!--\nUse the hash symbol (#) to declare a reference variable.\nThe `#phone` declares a `phone` variable on an `<input>` element.\n-->\n<p>참조 변수는 해시 기호(#)를 사용해서 정의합니다.\n예를 들어, <code>&#x3C;input></code> 엘리먼트를 <code>phone</code> 변수로 가리키려면 <code>#phone</code> 과 같이 정의합니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"ref-var\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;input #phone placeholder=\"phone number\">\n\n</code-example>\n<!--\nYou can refer to a template reference variable _anywhere_ in the template.\nThe `phone` variable declared on this `<input>` is\nconsumed in a `<button>` on the other side of the template\n-->\n<p>템플릿 참조 변수는 템플릿 안이라면 <em>어디에서도</em> 사용할 수 있습니다.\n그래서 템플릿 안에 있는 <code>&#x3C;button></code> 엘리먼트는 <code>phone</code> 변수를 사용해서 <code>&#x3C;input></code> 엘리먼트를 참조할 수 있습니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"ref-phone\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;input #phone placeholder=\"phone number\">\n\n&#x3C;!-- 기타 엘리먼트 -->\n\n&#x3C;!-- phone은 input 엘리먼트를 가리킵니다. 그래서 엘리먼트의 `value` 값을 다음과 같이 전달할 수 있습니다. -->\n&#x3C;button (click)=\"callPhone(phone.value)\">Call&#x3C;/button>\n\n</code-example>\n<!--\n<h3 class=\"no-toc\">How a reference variable gets its value</h3>\n-->\n<h3 class=\"no-toc\" id=\"참조-변수를-사용해서-입력값-얻기\">참조 변수를 사용해서 입력값 얻기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#참조-변수를-사용해서-입력값-얻기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn most cases, Angular sets the reference variable's value to the element on which it was declared.\nIn the previous example, `phone` refers to the _phone number_ `<input>` box.\nThe phone button click handler passes the _input_ value to the component's `callPhone` method.\nBut a directive can change that behavior and set the value to something else, such as itself.\nThe `NgForm` directive does that.\n-->\n<p>템플릿 참조 변수는 입력 엘리먼트의 값에 접근하기 위해 주로 사용합니다.\n이전 예제에서 보면, <code>phone</code> 변수는 <code>&#x3C;input></code> 엘리먼트를 참조하며, 버튼을 클릭했을 때 실행되는 <code>callPhone</code> 메소드에 입력 필드의 값을 전달하기 위해 <code>phone.value</code>를 사용했습니다.\n이 방식은 하나의 방법일 뿐이며, 필요하다면 <code>&#x3C;input></code> 엘리먼트 자체를 넘겨서 사용할 수도 있습니다.\n<code><a href=\"api/forms/NgForm\" class=\"code-anchor\">NgForm</a></code> 디렉티브가 이런 방식으로 동작합니다.</p>\n<!--\nThe following is a *simplified* version of the form example in the [Forms](guide/forms) guide.\n-->\n<p><a href=\"guide/forms\">폼</a> 문서에 있는 예제를 <em>간단하게만</em> 살펴보면 다음과 같습니다.</p>\n<code-example path=\"template-syntax/src/app/hero-form.component.html\" header=\"src/app/hero-form.component.html\" linenums=\"false\">\n&#x3C;form (ngSubmit)=\"onSubmit(heroForm)\" #heroForm=\"<a href=\"api/forms/NgForm\" class=\"code-anchor\">ngForm</a>\">\n  &#x3C;div class=\"form-group\">\n    &#x3C;label for=\"name\">Name\n      &#x3C;input class=\"form-control\" name=\"name\" required [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.name\">\n    &#x3C;/label>\n  &#x3C;/div>\n  &#x3C;button type=\"submit\" [disabled]=\"!heroForm.form.valid\">Submit&#x3C;/button>\n&#x3C;/form>\n&#x3C;div [hidden]=\"!heroForm.form.valid\">\n  {{submitMessage}}\n&#x3C;/div>\n\n</code-example>\n<!--\nA template reference variable, `heroForm`, appears three times in this example, separated\nby a large amount of HTML.\nWhat is the value of `heroForm`?\n-->\n<p>이 예제에서 템플릿 참조 변수 <code>heroForm</code>은 총 3번 사용됩니다.\n<code>heroForm</code>은 어떤 값을 갖고 있을까요?</p>\n<!--\nIf Angular hadn't taken it over when you imported the `FormsModule`,\nit would be the [HTMLFormElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement).\nThe `heroForm` is actually a reference to an Angular [NgForm](api/forms/NgForm \"API: NgForm\")\ndirective with the ability to track the value and validity of every control in the form.\n-->\n<p>만약 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>을 로드하지 않았다면 이 변수의 값은 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement\">HTMLFormElement</a>가 됩니다.\n실제로 <code>heroForm</code> 변수는 Angular <a href=\"api/forms/NgForm\" title=\"API: NgForm\">NgForm</a> 디렉티브를 가리키는 변수입니다.\n<code><a href=\"api/forms/NgForm\" class=\"code-anchor\">NgForm</a></code>은 폼에 입력된 값을 담고 있으며, 폼에 있는 모든 폼 컨트롤의 유효성에 대한 정보도 갖고 있습니다.</p>\n<!--\nThe native `<form>` element doesn't have a `form` property.\nBut the `NgForm` directive does, which explains how you can disable the submit button\nif the `heroForm.form.valid` is invalid and pass the entire form control tree\nto the parent component's `onSubmit` method.\n-->\n<p>네이티브 <code>&#x3C;form></code> 엘리멘트에는 <code>form</code>이라는 프로퍼티가 없습니다.\n하지만 <code><a href=\"api/forms/NgForm\" class=\"code-anchor\">NgForm</a></code> 디렉티브에는 이 프로퍼티가 있고, <code>heroForm.form.valid</code> 값을 사용해서 제출 버튼을 비활성화 하거나, 모든 폼 유효성 검사가 통과했을 때 부모 컴포넌트의 <code>onSubmit</code> 메소드를 실행하도록 할 수 있습니다.</p>\n<!--\n<h3 class=\"no-toc\">Template reference variable warning notes</h3>\n-->\n<h3 class=\"no-toc\" id=\"템플릿-참조-변수를-사용할-때-주의할-점\">템플릿 참조 변수를 사용할 때 주의할 점<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#템플릿-참조-변수를-사용할-때-주의할-점\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nA template _reference_ variable (`#phone`) is _not_ the same as a template _input_ variable (`let phone`)\nsuch as you might see in an [`*ngFor`](guide/template-syntax#template-input-variable).\nLearn the difference in the [_Structural Directives_](guide/structural-directives#template-input-variable) guide.\n-->\n<p>템플릿 <em>참조</em> 변수 (<code>#phone</code>)는 <a href=\"guide/template-syntax#%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%9E%85%EB%A0%A5-%EB%B3%80%EC%88%98\"><code>*ngFor</code></a>에서 살펴봤던 템플릿 <em>입력</em> 변수 (<code>let phone</code>)와는 <em>다릅니다</em>.\n어떻게 다른지 자세하게 알아보려면 <a href=\"guide/structural-directives#%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%9E%85%EB%A0%A5-%EB%B3%80%EC%88%98\"><em>구조 디렉티브</em></a> 문서를 참고하세요.</p>\n<!--\nThe scope of a reference variable is the _entire template_.\nDo not define the same variable name more than once in the same template.\nThe runtime value will be unpredictable.\n-->\n<p>템플릿 참조 변수를 사용할 수 있는 스코프는 <em>템플릿 전체</em> 입니다.\n한 템플릿 안에서 같은 이름의 템플릿 참조 변수를 참조하지 않도록 주의하세요.\n에러는 나지 않더라도 어떤 동작을 할지 알 수 없습니다.</p>\n<!--\nYou can use the `ref-` prefix alternative to `#`.\nThis example declares the `fax` variable as `ref-fax` instead of `#fax`.\n-->\n<p><code>#</code> 기호를 사용하는 것이 어색하다면 <code>ref-</code> 접두사를 대신 사용할 수도 있습니다.\n접두사를 사용해서 <code>ref-fax</code> 라고 작성하면 <code>#fax</code> 로 <code>fax</code> 변수를 정의한 것과 같습니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"ref-fax\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;input ref-fax placeholder=\"fax number\">\n&#x3C;button (click)=\"callFax(fax.value)\">Fax&#x3C;/button>\n\n</code-example>\n<hr>\n<a id=\"inputs-outputs\"></a>\n<a id=\"입출력 프로퍼티\"></a>\n<!--\n## Input and Output properties\n-->\n<h2 id=\"입출력-프로퍼티\">입출력 프로퍼티<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#입출력-프로퍼티\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAn _Input_ property is a _settable_ property annotated with an `@Input` decorator.\nValues flow _into_ the property when it is data bound with a [property binding](#property-binding)\n-->\n<p><em>입력 프로퍼티</em> 는 컴포넌트 프로퍼티에 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 데코레이터를 붙여서 <em>외부에서 값을 받도록</em> 한 프로퍼티입니다.\n이 때 데이터는 <a href=\"guide/template-syntax#%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EB%B0%94%EC%9D%B8%EB%94%A9\">프로퍼티 바인딩</a>을 통해 컴포넌트 밖에서 컴포넌트 <em>안으로</em> 전달됩니다.</p>\n<!--\nAn _Output_ property is an _observable_ property annotated with an `@Output` decorator.\nThe property almost always returns an Angular [`EventEmitter`](api/core/EventEmitter).\nValues flow _out_ of the component as events bound with an [event binding](#event-binding).\n-->\n<p>그리고 <em>출력 프로퍼티</em> 는 컴포넌트 프로퍼티에 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code> 데코레이터를 붙여서 외부로 공개한 <em>옵저버블</em> 프로퍼티입니다.\n이 때 옵저버블 프로퍼티는 Angular에서 제공하는 <a href=\"api/core/EventEmitter\"><code>EventEmitter</code></a>를 사용하는 것이 일반적입니다.\n컴포넌트 안쪽에서 발생하는 이벤트는 <a href=\"guide/template-syntax#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%B0%94%EC%9D%B8%EB%94%A9\">이벤트 바인딩</a>을 통해 컴포넌트 <em>밖으로</em> 전달됩니다.</p>\n<!--\nYou can only bind to _another_ component or directive through its _Input_ and _Output_ properties.\n-->\n<p>컴포넌트나 디렉티브를 <em>다른</em> 컴포넌트와 디렉티브와 직접 바인딩하려면 <em>입력</em> 프로퍼티나 <em>출력</em> 프로퍼티를 사용해야 합니다.</p>\n<div class=\"alert is-important\">\n<!--\nRemember that all **components** are **directives**.\n-->\n<p><strong>컴포넌트</strong>는 <strong>디렉티브</strong>의 종류 중 하나라는 것을 잊지 마세요.</p>\n<!--\nThe following discussion refers to _components_ for brevity and \nbecause this topic is mostly a concern for component authors. \n-->\n<p>아래 설명에서는 컴포넌트를 개발하는 입장에서 설명하기 위해\n컴포넌트와 디렉티브를 간단하게 <em>컴포넌트</em> 라고만 언급하겠습니다.</p>\n</div>\n<!--\n<h3 class=\"no-toc\">Discussion</h3>\n-->\n<h3 class=\"no-toc\" id=\"개요\">개요<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#개요\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou are usually binding a template to its _own component class_.\nIn such binding expressions, the component's property or method is to the _right_ of the (`=`).\n-->\n<p>템플릿은 <em>컴포넌트 클래스</em> 와 연결합니다.\n그래서 입출력 프로퍼티를 바인딩하기 위해 등호(<code>=</code>) <em>오른쪽</em> 에 사용하는 표현식은 컴포넌트 안에 있는 프로퍼티나 메소드가 됩니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"io-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;img [src]=\"iconUrl\"/>\n&#x3C;button (click)=\"onSave()\">Save&#x3C;/button>\n\n</code-example>\n<!--\nThe `iconUrl` and `onSave` are members of the `AppComponent` class.\nThey are _not_ decorated with `@Input()` or `@Output`.\nAngular does not object.\n-->\n<p>위 코드에서 <code>iconUrl</code>과 <code>onSave</code>는 <code>AppComponent</code> 클래스에 있는 프로퍼티와 메소드입니다.\n하지만 일반적인 프로퍼티 바인딩이나 이벤트 바인딩을 할 때는 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터와 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터가 <em>필요 없습니다</em> .\n이 데코레이터들은 자식 컴포넌트와 바인딩할 때 사용됩니다.</p>\n<!--\n**You can always bind to a public property of a component in its own template.**\nIt doesn't have to be an _Input_ or _Output_ property\n-->\n<p><strong>그리고 입력 프로퍼티로 자식 컴포넌트에 연결하는 프로퍼티는 <code>public</code> 접근자로 지정되어야 템플릿에서 사용할 수 있습니다.</strong>\n전달하는 컴포넌트의 입장에서 <em>입출력</em> 프로퍼티일 필요는 없습니다.</p>\n<!--\nA component's class and template are closely coupled.\nThey are both parts of the same thing.\nTogether they _are_ the component.\nExchanges between a component class and its template are internal implementation details.\n-->\n<p>컴포넌트 클래스와 템플릿은 긴밀하게 연결되어 있습니다.\n컴포넌트 클래스와 템플릿이 <em>모여서</em> 컴포넌트를 구성하기 때문에 각각은 컴포넌트의 구성요소라고 할 수도 있습니다.\n컴포넌트 클래스와 템플릿 사이에 데이터가 전달되는 과정을 자세하게 알아봅시다.</p>\n<!--\n### Binding to a different component\n-->\n<h3 id=\"다른-컴포넌트와-바인딩하기\">다른 컴포넌트와 바인딩하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#다른-컴포넌트와-바인딩하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou can also bind to a property of a _different_ component.\nIn such bindings, the _other_ component's property is to the _left_ of the (`=`).\n-->\n<p>컴포넌트 프로퍼티는 <em>다른</em> 컴포넌트로 바인딩할 수도 있습니다.\n이런 바인딩에서 <em>다른</em> 컴포넌트의 프로퍼티는 괄호(<code>=</code>) <em>왼쪽</em> 에 지정합니다.</p>\n<!--\nIn the following example, the `AppComponent` template binds `AppComponent` class members to properties of the `HeroDetailComponent` whose selector is `'app-hero-detail'`.\n-->\n<p>아래 예제에서 <code>AppComponent</code>의 템플릿은 <code>AppComponent</code> 클래스 멤버를 <code>HeroDetailComponent</code>의 프로퍼티로 바인딩합니다.\n<code>HeroDetailComponent</code>는 <code>'app-hero-detail'</code> 셀렉터로 표현되는 컴포넌트입니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"io-2\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;app-hero-detail [hero]=\"currentHero\" (deleteRequest)=\"deleteHero($event)\">\n&#x3C;/app-hero-detail>\n\n</code-example>\n<!--\nThe Angular compiler _may_ reject these bindings with errors like this one:\n-->\n<p>하지만 이렇게 사용하면 Angular 컴파일 과정에서 다음과 같은 에러가 발생합니다:</p>\n<code-example language=\"sh\" class=\"code-shell\">\nUncaught Error: Template parse errors:\nCan't bind to 'hero' since it isn't <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> known property of 'app-hero-detail'\n</code-example>\n<!--\nYou know that `HeroDetailComponent` has `hero` and `deleteRequest` properties.\nBut the Angular compiler refuses to recognize them.\n-->\n<p><code>HeroDetailComponent</code>에는 <code>hero</code> 프로퍼티와 <code>deleteRequest</code> 메소드가 이미 있다고 합시다.\n하지만 Angular 컴파일러는 이 항목이 있는지 알 수 없습니다.</p>\n<!--\n**The Angular compiler won't bind to properties of a different component\nunless they are Input or Output properties**.\n-->\n<p>그래서 컴포넌트를 다른 컴포넌트와 연결할 수 있도록 Angular 컴파일러에게 정보를 제공하기 위해\n입출력 프로퍼티를 지정합니다.</p>\n<!--\nThere's a good reason for this rule.\n-->\n<p>규칙은 단순합니다.</p>\n<!--\nIt's OK for a component to bind to its _own_ properties.\nThe component author is in complete control of those bindings.\n-->\n<p>컴포넌트 안에서 자신의 프로퍼티에 접근하는 것은 아무 문제가 없습니다.\n템플릿 안에서는 프로퍼티를 자유롭게 사용할 수 있습니다.</p>\n<!--\nBut other components shouldn't have that kind of unrestricted access.\nYou'd have a hard time supporting your component if anyone could bind to any of its properties.\nOutside components should only be able to bind to the component's public binding API.\n-->\n<p>하지만 다른 컴포넌트의 프로퍼티에 접근하는 것은 기본적으로 제한되어 있습니다.\n다른 컴포넌트에서 컴포넌트 내부에 마음대로 접근하는 것은 컴포넌트를 관리하기에 그리 효율적이지 않습니다.\n컴포넌트 밖에서는 컴포넌트에서 공개하는 API에만 접근할 수 있게 하는 것이 좋습니다.</p>\n<!--\nAngular asks you to be _explicit_ about that API.\nIt's up to _you_ to decide which properties are available for binding by\nexternal components.\n-->\n<p>그래서 Angular는 외부로 공개하는 API를 명확하게 지정하도록 요구하는 것입니다.\n어떤 프로퍼티를 컴포넌트 외부로 공개해서 다른 컴포넌트와 바인딩할 지 설정하는 것은 오로지 <em>개발자</em> 의 판단에 달려있습니다.</p>\n<!--\n#### TypeScript _public_ doesn't matter\n-->\n<h4 id=\"typescript-접근제어자-설정\">TypeScript 접근제어자 설정<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#typescript-접근제어자-설정\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nYou can't use the TypeScript _public_ and _private_ access modifiers to\nshape the component's public binding API.\n-->\n<p>컴포넌트 외부로 공개되는 API는 TypeScript 접근 제어자인 <em>public</em> 이나 <em>private</em> 로 접근 권한을 제어할 수 없습니다.</p>\n<div class=\"alert is-important\">\n<!--\nAll data bound properties must be TypeScript _public_ properties.\nAngular never binds to a TypeScript _private_ property.\n-->\n<p>데이터가 바인딩되는 프로퍼티는 항상 TypeScript <em>public</em> 프로퍼티로 지정되어야 합니다.\n<em>private</em> 으로 지정된 프로퍼티를 바인딩하는 것은 Angular에서 허용하지 않습니다.</p>\n</div>\n<!--\nAngular requires some other way to identify properties that _outside_ components are allowed to bind to.\nThat _other way_ is the `@Input()` and `@Output()` decorators.\n-->\n<p>그리고 컴포넌트 외부로 프로퍼티를 공개할 때 Angular가 제공하는 방식을 사용할 수도 있습니다.\n이 때 사용되는 것이 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터와 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터입니다.</p>\n<!--\n### Declaring Input and Output properties\n-->\n<h3 id=\"입출력-프로퍼티-지정하기\">입출력 프로퍼티 지정하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#입출력-프로퍼티-지정하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn the sample for this guide, the bindings to `HeroDetailComponent` do not fail\nbecause the data bound properties are annotated with `@Input()` and `@Output()` decorators.\n-->\n<p>위에서 살펴본 예제에서는 <code>HeroDetailComponent</code>에 바인딩하는 로직이 실패했습니다.\n왜냐하면 컴포넌트 외부에서 바인딩하는 프로퍼티를 참조할 때, 이 프로퍼티들이 입출력 프로퍼티로 선언되지 않았기 때문입니다.\n그래서 외부에서 입력을 받는 프로퍼티는 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터로, 외부로 이벤트를 보내는 프로퍼티는 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 데코레이터로 다음과 같이 지정해야 합니다.</p>\n<code-example path=\"template-syntax/src/app/hero-detail.component.ts\" region=\"input-output-1\" header=\"src/app/hero-detail.component.ts\" linenums=\"false\">\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()  hero: Hero;\n@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() deleteRequest = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;Hero>();\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\nAlternatively, you can identify members in the `inputs` and `outputs` arrays\nof the directive metadata, as in this example:\n-->\n<p>데코레이터를 사용하지 않고 디렉티브 메타데이터를 활용하려면, 아래와 같이 디렉티브 메타데이터의 <code>inputs</code> 멤버와 <code>outputs</code> 멤버를 사용해도 됩니다:</p>\n<code-example path=\"template-syntax/src/app/hero-detail.component.ts\" region=\"input-output-2\" header=\"src/app/hero-detail.component.ts\" linenums=\"false\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  inputs: ['hero'],\n  outputs: ['deleteRequest'],\n})\n\n</code-example>\n</div>\n<!--\n### Input or output?\n-->\n<h3 id=\"입력일까-출력일까\">입력일까? 출력일까?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#입력일까-출력일까\"><i class=\"material-icons\">link</i></a></h3>\n<!--\n*Input* properties usually receive data values.\n*Output* properties expose event producers, such as `EventEmitter` objects.\n-->\n<p><em>입력</em> 프로퍼티는 외부에서 데이터를 받을 때 사용합니다.\n<em>출력</em> 프로퍼티는 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 와 같은 객체를 통해 외부로 이벤트를 보낼 때 사용합니다.</p>\n<!--\nThe terms _input_ and _output_ reflect the perspective of the target directive.\n-->\n<p>그래서 <em>입력</em> 이나 <em>출력</em> 이라는 말은 바인딩 대상이 되는 디렉티브의 입장에서 표현하는 말입니다.</p>\n<figure>\n  <img src=\"generated/images/guide/template-syntax/input-output.png\" alt=\"Inputs and outputs\" width=\"546\" height=\"50\">\n</figure>\n<!--\n`HeroDetailComponent.hero` is an **input** property from the perspective of `HeroDetailComponent`\nbecause data flows *into* that property from a template binding expression.\n-->\n<p><code>HeroDetailComponent.hero</code>는 <code>HeroDetailComponent</code>의 입장에서 보면 <strong>입력</strong> 프로퍼티입니다.\n왜냐하면 템플릿 바인딩 표현식에 의해 데이터가 컴포넌트 <em>안으로</em> 전달되기 때문입니다.</p>\n<!--\n`HeroDetailComponent.deleteRequest` is an **output** property from the perspective of `HeroDetailComponent`\nbecause events stream *out* of that property and toward the handler in a template binding statement.\n-->\n<p>그리고 <code>HeroDetailComponent.deleteRequest</code> 는 <code>HeroDetailComponent</code>의 입장에서 볼 때 <strong>출력</strong> 프로퍼티입니다.\n이 컴포넌트가 <em>밖으로</em> 보내는 이벤트는 템플릿 바인딩 평가식에 의해 실행되는 함수로 전달됩니다.</p>\n<h3 id=\"aliasing-io\">\n\t<!--\n  Aliasing input/output properties\n-->\n  입출력 프로퍼티 이름 변경하기\n<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#aliasing-io\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nSometimes the public name of an input/output property should be different from the internal name.\n-->\n<p>어떤 경우에는 입출력 프로퍼티로 자주 사용하는 이름이 디렉티브 프로퍼티의 이름과 다를 수 있습니다.</p>\n<!--\nThis is frequently the case with [attribute directives](guide/attribute-directives).\nDirective consumers expect to bind to the name of the directive.\nFor example, when you apply a directive with a `myClick` selector to a `<div>` tag,\nyou expect to bind to an event property that is also called `myClick`.\n-->\n<p>이런 경우는 <a href=\"guide/attribute-directives\">어트리뷰트 디렉티브</a>인 경우에 자주 발생합니다.\n디렉티브를 사용하는 입장에서는 자주 사용하던 이름을 그대로 사용하지만 디렉티브에는 이 프로퍼티가 없는 경우가 있을 수 있습니다.\n예를 들어 <code>&#x3C;div></code> 태그에 <code>myClick</code> 셀렉터로 지정하는 디렉티브가 있고, 이 디렉티브에서 발생하는 이벤트의 이름도 <code>myClick</code>이라고 합시다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"myClick\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div (myClick)=\"clickMessage=$event\" clickable>click with myClick&#x3C;/div>\n\n</code-example>\n<!--\nHowever, the directive name is often a poor choice for the name of a property within the directive class.\nThe directive name rarely describes what the property does.\nThe `myClick` directive name is not a good name for a property that emits click messages.\n-->\n<p>하지만 디렉티브 클래스 안에 있는 프로퍼티의 이름으로 디렉티브 이름을 정하는 것은 좋은 선택이 아닙니다.\n디렉티브 안에 있는 프로퍼티 하나가 그 디렉티브가 어떤 역할을 하는지 충분히 설명할 수 없기 때문입니다.\n그래서 이 예제처럼 <code>myClick</code> 디렉티브의 이름을 디렉티브 안에 있는 <code>myClick</code> 프로퍼티 이름과 똑같이 지정하는 것은 좋지 않습니다.</p>\n<!--\nFortunately, you can have a public name for the property that meets conventional expectations,\nwhile using a different name internally.\nIn the example immediately above, you are actually binding *through the* `myClick` *alias* to\nthe directive's own `clicks` property.\n-->\n<p>다행히도, 디렉티브 밖에서 일반적으로 사용하는 이름을 그대로 사용하면서 디렉티브 안에서는 다른 이름으로 지정하는 방법이 있습니다.\n위에서 살펴본 예제를 다시 보면, 디렉티브 밖에서는 <code>myClick</code> 이라는 이벤트를 바인딩하지만 디렉티브 안에서는 이 이벤트를 <code>clicks</code> 라는 프로퍼티로 지정할 수 있습니다.</p>\n<!--\nYou can specify the alias for the property name by passing it into the input/output decorator like this:\n-->\n<p>디렉티브 밖에서 사용하는 프로퍼티 이름과 디렉티브 안에서 사용하는 프로퍼티 이름을 다르게 하려면 다음과 같이 지정합니다:</p>\n<code-example path=\"template-syntax/src/app/click.directive.ts\" region=\"output-myClick\" header=\"src/app/click.directive.ts\" linenums=\"false\">\n@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>('myClick') clicks = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;string>(); //  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>(별칭) 프로퍼티_이름 = ...\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\nYou can also alias property names in the `inputs` and `outputs` arrays.\nYou write a colon-delimited (`:`) string with\nthe directive property name on the *left* and the public alias on the *right*:\n-->\n<p>디렉티브 메타데이터의 <code>inputs</code>와 <code>outputs</code>를 사용할 때도 프로퍼티 이름을 변환해서 지정할 수 있습니다.\n이 때는 순서대로 디렉티브의 프로퍼티 이름, 콜론(<code>:</code>), 디렉티브 밖에서 사용하는 프로퍼티 이름 순으로 지정합니다:</p>\n<code-example path=\"template-syntax/src/app/click.directive.ts\" region=\"output-myClick2\" header=\"src/app/click.directive.ts\" linenums=\"false\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  outputs: ['clicks:myClick']  // 프로퍼티_이름:별칭\n})\n\n</code-example>\n</div>\n<hr>\n<a id=\"expression-operators\"></a>\n<a id=\"템플릿-표현식-전용-연산자\"></a>\n<!--\n## Template expression operators\n-->\n<h2 id=\"템플릿-표현식-전용-연산자\">템플릿 표현식 전용 연산자<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#템플릿-표현식-전용-연산자\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe template expression language employs a subset of JavaScript syntax supplemented with a few special operators\nfor specific scenarios. The next sections cover two of these operators: _pipe_ and _safe navigation operator_.\n-->\n<p>템플릿 표현식의 문법은 JavaScript 문법의 일부와 템플릿에서만 사용할 수 있는 연산자가 추가되어 만들어진 것입니다.\n이번 섹션에서는 <em>파이프</em> 와 <em>안전 참조 연산자</em> 에 대해 알아보겠습니다.</p>\n<a id=\"pipe\"></a>\n<!--\n### The pipe operator ( <span class=\"syntax\">|</span> )\n-->\n<h3 id=\"파이프-연산자---\">파이프 연산자 ( <span class=\"syntax\">|</span> )<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#파이프-연산자---\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe result of an expression might require some transformation before you're ready to use it in a binding.\nFor example, you might display a number as a currency, force text to uppercase, or filter a list and sort it.\n-->\n<p>템플릿 표현식의 결과값을 그대로 사용하지 않고 바인딩하기 전에 적당한 형태로 변환해야 하는 경우가 있습니다.\n숫자를 화폐 단위로 표시하거나, 문자열을 대문자로 변환하거나, 배열의 일부를 필터링하거나 정렬하는 경우가 이런 경우에 해당됩니다.</p>\n<!--\nAngular [pipes](guide/pipes) are a good choice for small transformations such as these.\nPipes are simple functions that accept an input value and return a transformed value.\nThey're easy to apply within template expressions, using the **pipe operator (`|`)**:\n-->\n<p>이 때 변환 로직이 복잡하지 않다면 Angular에서 제공하는 <a href=\"guide/pipes\">파이프</a>를 사용하는 것이 좋습니다.\n파이프는 입력값을 간단하게 변환해서 새로운 값으로 반환하는 함수입니다.\n템플릿에서는 다음과 같이 <strong>파이프 연산자 (<code>|</code>)</strong>를 사용해서 적용할 수 있습니다:</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"pipes-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;div><a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a> through uppercase pipe: {{title | <a href=\"api/common/UpperCasePipe\" class=\"code-anchor\">uppercase</a>}}&#x3C;/div>\n\n</code-example>\n<!--\nThe pipe operator passes the result of an expression on the left to a pipe function on the right.\n-->\n<p>파이프 연산자 왼쪽에 있는 값은 파이프 연산자의 오른쪽으로 전달됩니다.</p>\n<!--\nYou can chain expressions through multiple pipes:\n-->\n<p>그래서 다음과 같이 파이프 여러개를 연달아 사용할 수도 있습니다:</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"pipes-2\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- 파이프 체이닝: 제목을 대문자로 변환하고, 다시 소문자로 변환합니다. -->\n&#x3C;div>\n  <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a> through <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> pipe chain:\n  {{title | <a href=\"api/common/UpperCasePipe\" class=\"code-anchor\">uppercase</a> | <a href=\"api/common/LowerCasePipe\" class=\"code-anchor\">lowercase</a>}}\n&#x3C;/div>\n\n</code-example>\n<!--\nAnd you can also [apply parameters](guide/pipes#parameterizing-a-pipe) to a pipe:\n-->\n<p>그리고 파이프 함수에 <a href=\"guide/pipes#%ED%8C%8C%EC%9D%B4%ED%94%84-%EC%9D%B8%EC%9E%90-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\">파이프 인자</a>를 전달해서 파이프의 동작을 구체적으로 지정할 수도 있습니다:</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"pipes-3\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- 파이프에 인자를 전달할 수도 있습니다 => 결과) \"February 25, 1970\" -->\n&#x3C;div>Birthdate: {{currentHero?.birthdate | date:'longDate'}}&#x3C;/div>\n\n</code-example>\n<!--\nThe `json` pipe is particularly helpful for debugging bindings:\n-->\n<p>바인딩되는 객체를 확인해야 할때 <code><a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code> 파이프를 사용하면 디버깅이 훨씬 편해집니다:</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" linenums=\"false\" header=\"src/app/app.component.html (pipes-json)\" region=\"pipes-json\">\n&#x3C;div>{{currentHero | <a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a>}}&#x3C;/div>\n\n</code-example>\n<!--\nThe generated output would look something like this\n-->\n<p>이 코드를 실행하면 화면에 다음과 같은 문자열이 표시됩니다.</p>\n<code-example language=\"json\">\n  { \"id\": 0, \"name\": \"Hercules\", \"emotion\": \"happy\",\n    \"birthdate\": \"1970-02-25T08:00:00.000Z\",\n    \"url\": \"<a href=\"api/common/http\" class=\"code-anchor\">http</a>://www.imdb.com/title/tt0065832/\",\n    \"rate\": 325 }\n</code-example>\n<hr>\n<!--\n<a id=\"safe-navigation-operator\"></a>\n-->\n<a id=\"안전-참조-연산자\"></a>\n<!--\n### The safe navigation operator ( <span class=\"syntax\">?.</span> ) and null property paths\n-->\n<h3 id=\"null-객체-참조를-방지하는-안전-참조-연산자--\">null 객체 참조를 방지하는 안전 참조 연산자( <span class=\"syntax\">?.</span> )<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#null-객체-참조를-방지하는-안전-참조-연산자--\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe Angular **safe navigation operator (`?.`)** is a fluent and convenient way to\nguard against null and undefined values in property paths.\nHere it is, protecting against a view render failure if the `currentHero` is null.\n-->\n<p>객체를 참조하면서 프로퍼티 값이 <code>null</code>이거나 <code>undefined</code>인지 확인하는 로직은\n<strong>안전 참조 연산자 (<code>?.</code>)</strong>를 사용하면 간단하게 구현할 수 있습니다.\n<code>currentHero</code>의 값이 <code>null</code>인지 확인하고, 객체가 유효할 때만 <code>name</code> 프로퍼티를 참조하는 로직은 다음과 같이 구현합니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"safe-2\" header=\"src/app/app.component.html\" linenums=\"false\">\nThe current hero's name is {{currentHero?.name}}\n\n</code-example>\n<!--\nWhat happens when the following data bound `title` property is null?\n-->\n<p>이 문법이 왜 필요한지 생각해 봅시다. 프로퍼티 바인딩하는 <code>title</code>의 값이 null이라면 어떻게 될까요?</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"safe-1\" header=\"src/app/app.component.html\" linenums=\"false\">\nThe title is {{title}}\n\n</code-example>\n<!--\nThe view still renders but the displayed value is blank; you see only \"The title is\" with nothing after it.\nThat is reasonable behavior. At least the app doesn't crash.\n-->\n<p>이 경우에 <code>title</code>은 빈 값이지만 뷰는 그대로 표시됩니다. 그래서 \"The title is\" 라는 문자열 뒤에는 아무것도 붙지 않습니다.\n이 정도는 쉽게 이해할 수 없습니다. 오류가 발생하지 않으니 앱이 중단되지도 않습니다.</p>\n<!--\nSuppose the template expression involves a property path, as in this next example\nthat displays the `name` of a null hero.\n-->\n<p>그런데 다음 예제처럼 <code>null</code> 값인 객체의 프로퍼티를 참조하는 템플릿 표현식이 있다고 합시다.</p>\n<code-example language=\"html\">\n  The null hero's name is {{nullHero.name}}\n</code-example>\n<!--\nJavaScript throws a null reference error, and so does Angular:\n-->\n<p>이 코드를 실행하면 JavaScript null 객체 참조 에러가 발생하기 때문에 Angular에서도 다음과 같은 에러가 발생함니다:</p>\n<code-example format=\"nocode\">\n  TypeError: Cannot <a href=\"api/core/Query#read\" class=\"code-anchor\">read</a> property 'name' of null in [null].\n</code-example>\n<!--\nWorse, the *entire view disappears*.\n-->\n<p>그리고 이 에러의 영향으로 <em>뷰 전체가 동작하지 않습니다</em>.</p>\n<!--\nThis would be reasonable behavior if the `hero` property could never be null.\nIf it must never be null and yet it is null,\nthat's a programming error that should be caught and fixed.\nThrowing an exception is the right thing to do.\n-->\n<p>참조하는 객체가 null이 되는 경우가 전혀 없다면 이 로직만으로도 문제는 없습니다.\n하지만 객체가 null이 되지 않도록 계속 신경을 써야 하고, 개발자의 실수로 null이 되는 경우가 발생할 수도 있습니다.\n이런 경우라면 수동으로 에러를 발생시켜서 객체를 참조하지 못하도록 끊어줘야 합니다.</p>\n<!--\nOn the other hand, null values in the property path may be OK from time to time,\nespecially when the data are null now and will arrive eventually.\n-->\n<p>하지만 이런 로직은 객체가 null인 경우에만 필요한 로직이며, 올바른 객체를 참조할 때는 필요하지 않습니다.</p>\n<!--\nWhile waiting for data, the view should render without complaint, and\nthe null property path should display as blank just as the `title` property does.\n-->\n<p>그리고 데이터에 문제가 있는 상황에서도 뷰가 렌더링되는 것이 멈춰서는 안됩니다.\n이전에 살펴봤던 것처럼 <code>title</code> 프로퍼티 값이 null이라면 빈칸으로 비워두는 것이 더 합리적입니다.</p>\n<!--\nUnfortunately, the app crashes when the `currentHero` is null.\n-->\n<p>하지만 지금 코드에서 <code>currentHero</code> 객체가 null 이면 앱 전체가 중단됩니다.</p>\n<!--\nYou could code around that problem with [*ngIf](guide/template-syntax#ngIf).\n-->\n<p>이 문제는 <a href=\"guide/template-syntax#ngIf\"><em>ngIf</em></a>로 방지할 수도 있습니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"safe-4\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- 히어로 객체가 유효하지 않으면 div가 표시되지 않으며, 에러도 발생하지 않습니다. -->\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"nullHero\">The null hero's name is {{nullHero.name}}&#x3C;/div>\n\n</code-example>\n<!--\nYou could try to chain parts of the property path with `&&`, knowing that the expression bails out\nwhen it encounters the first null.\n-->\n<p>그리고 <code>&#x26;&#x26;</code> 연산자를 사용해서 null이 발생하는 경우를 순차적으로 검사할 수도 있습니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"safe-5\" header=\"src/app/app.component.html\" linenums=\"false\">\nThe null hero's name is {{nullHero &#x26;&#x26; nullHero.name}}\n\n</code-example>\n<!--\nThese approaches have merit but can be cumbersome, especially if the property path is long.\nImagine guarding against a null somewhere in a long property path such as `a.b.c.d`.\n-->\n<p>이런 방법을 사용해도 원하는 로직을 구현할 수 있지만, 매번 이런 로직을 작성하기는 번거롭습니다. 게다가 참조하는 깊이가 깊어질수록 더 번거로워 집니다.\n<code>a.b.c.d</code>와 같은 경우에 이런 로직을 구현해야 한다고 생각해 보세요.</p>\n<!--\nThe Angular safe navigation operator (`?.`) is a more fluent and convenient way to guard against nulls in property paths.\nThe expression bails out when it hits the first null value.\nThe display is blank, but the app keeps rolling without errors.\n-->\n<p>이 때 Angular에서 제공하는 안전 참조 연산자 (<code>?.</code>)를 사용하면, 객체가 null인지 검사하는 로직을 아주 간단하게 구현할 수 있습니다.\n안전 참조 연산자로 참조하는 객체의 값이 null이면 더이상 객체를 참조하지 않고 종료하며, 뷰는 비어있겠지만 에러로 앱이 중단되는 상황은 막을 수 있습니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"safe-6\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- 히어로 객체가 유효하지 않아도 괜찮습니다! -->\nThe null hero's name is {{nullHero?.name}}\n\n</code-example>\n<!--\nIt works perfectly with long property paths such as `a?.b?.c?.d`.\n-->\n<p>안전 참조 연산자는 <code><a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>?.b?.c?.d</code>와 같은 경우에도 완벽하게 동작합니다.</p>\n<hr>\n<a id=\"non-null-assertion-operator\"></a>\n<a id=\"null-방지-연산자\"></a>\n<!--\n### The non-null assertion operator ( <span class=\"syntax\">!</span> )\n-->\n<h3 id=\"null-방지-연산자---\">null 방지 연산자 ( <span class=\"syntax\">!</span> )<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#null-방지-연산자---\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAs of Typescript 2.0, you can enforce [strict null checking](http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html \"Strict null checking in TypeScript\") with the `--strictNullChecks` flag. TypeScript then ensures that no variable is _unintentionally_ null or undefined.\n-->\n<p>TypeScript 2.0 버전부터  <a href=\"http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html\" title=\"Strict null checking in TypeScript\">null 검사를 더 엄격하게</a>하는 옵션이 추가되었습니다. 옵션은 <code>--strictNullChecks</code>로 활성화하며, 이 옵션을 설정하면 객체의 값이 null이나 undefined이 되는 것을 방지합니다.</p>\n<!--\nIn this mode, typed variables disallow null and undefined by default. The type checker throws an error if you leave a variable unassigned or try to assign null or undefined to a variable whose type disallows null and undefined.\n-->\n<p>이 모드를 활성화하면 타입을 지정한 변수에 null이나 undefined을 할당하는 것이 허용되지 않습니다. 그래서 변수의 값을 할당하지 않고 놔두거나, 변수에 null이나 undefined을 할당하는 코드가 있으면 타입을 체크할 때 오류가 발생합니다.</p>\n<!--\nThe type checker also throws an error if it can't determine whether a variable will be null or undefined at runtime.\nYou may know that can't happen but the type checker doesn't know.\nYou tell the type checker that it can't happen by applying the post-fix\n[_non-null assertion operator (!)_](http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-assertion-operator \"Non-null assertion operator\").\n-->\n<p>그런데 TypeScript 컴파일러는 앱이 실행되는 시점에 변수의 값이 null이나 undefined가 될 수 있는 코드에서도 에러를 발생합니다.\n개발자는 발생하지 않는 경우라고 할 수 있지만 TypeScript 컴파일러가 알수는 없기 때문이죠.\n그래서 실행시점에서도 이 객체가 null이 되지 않는다는 것을 <a href=\"http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-assertion-operator\" title=\"Non-null assertion operator\">null 방지 연산자</a>를 사용해서 TypeScript 컴파일러에게 알려줘야 합니다.</p>\n<!--\nThe _Angular_ **non-null assertion operator (`!`)** serves the same purpose in an Angular template.\n-->\n<p>Angular 템플릿에서도 이 연산자를 사용할 수 있습니다.</p>\n<!--\nFor example, after you use [*ngIf](guide/template-syntax#ngIf) to check that `hero` is defined, you can assert that\n`hero` properties are also defined.\n-->\n<p>만약 <code>hero</code> 객체가 정의되어있는지 <a href=\"guide/template-syntax#ngIf\"><em>ngIf</em></a>로 검사하고, 이 객체가 유효할 때만 동작하는 로직을 다음과 같이 구현했다고 합시다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"non-null-assertion-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- 히어로 객체가 유효하지 않으면 표시되지 않습니다. -->\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero\">\n  The hero's name is {{hero!.name}}\n&#x3C;/div>\n\n</code-example>\n<!--\nWhen the Angular compiler turns your template into TypeScript code,\nit prevents TypeScript from reporting that `hero.name` might be null or undefined.\n-->\n<p>이 템플릿은 Angular 컴파일러가 TypeScript 코드로 변환합니다. 그러면 null 방지 연산자를 사용했기 때문에 TypeScript 컴파일러가 <code>hero</code> 객체는 null이거나 undefined가 되지 않는다는 것을 인식합니다.</p>\n<!--\nUnlike the [_safe navigation operator_](guide/template-syntax#safe-navigation-operator \"Safe navigation operator (?.)\"),\nthe **non-null assertion operator** does not guard against null or undefined.\nRather it tells the TypeScript type checker to suspend strict null checks for a specific property expression.\n-->\n<p>하지만 <a href=\"guide/template-syntax#%EC%95%88%EC%A0%84-%EC%B0%B8%EC%A1%B0-%EC%97%B0%EC%82%B0%EC%9E%90\" title=\"Safe navigation operator (?.)\"><em>안전 참조 연산자</em></a>와는 다르게,\n<strong>null 방지 연산자</strong> 는 객체의 값이 null이나 undefined일 때 발생하는 오류를 방지하지는 않습니다.\n이 연산자의 역할은 템플릿에서 객체를 참조할 때 엄격한 null 검사를 하지 않도록 지정하는 것 뿐입니다.</p>\n<!--\nYou'll need this template operator when you turn on strict null checks. It's optional otherwise.\n-->\n<p>그리고 이 연산자는 TypeScript 옵션 중 엄격한 null 검사 옵션을 활성화 할 때만 의미가 있습니다. 모든 상황에서 필요한 코드는 아닙니다.</p>\n<!--\n<a href=\"guide/template-syntax#top-of-page\">back to top</a>\n-->\n<hr>\n<a id=\"any-type-cast-function\"></a>\n<a id=\"any-타입-캐스트-함수\"></a>\n<!--\n## The `$any` type cast function (`$any( <expression> )`) \n-->\n<h2 id=\"any-타입-캐스트-함수-any-expression-\"><code>$any</code> 타입 캐스트 함수 (<code>$any( &#x3C;expression> )</code>)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#any-타입-캐스트-함수-any-expression-\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nSometimes a binding expression will be reported as a type error and it is not possible or difficult\nto fully specify the type. To silence the error, you can use the `$any` cast function to cast\nthe expression to [the `any` type](http://www.typescriptlang.org/docs/handbook/basic-types.html#any).\n-->\n<p>바인딩 표현식을 사용하다보면 변수 타입에 맞지 않다는 에러가 종종 발생합니다. 이 에러를 없애기 위해 타입을 정확히 맞춰도 되지만, 타입을 맞추기 까다로운 경우라면 <code>$any</code> 타입 캐스트 함수를 사용해서 바인딩 표현식의 결과값이 <a href=\"http://www.typescriptlang.org/docs/handbook/basic-types.html#any\"><code>any</code> 타입</a>이 되도록 지정할 수 있습니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"any-type-cast-function-1\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- 선언되지 않은 타입 참조하기 -->\n&#x3C;div>\n  The hero's marker is {{$any(hero).marker}}\n&#x3C;/div>\n\n</code-example>\n<!--\nIn this example, when the Angular compiler turns your template into TypeScript code, \nit prevents TypeScript from reporting that `marker` is not a member of the `Hero`\ninterface.\n-->\n<p>Angular가 이 코드를 TypeScript 코드로 변환하면 <code>Hero</code> 객체에 <code>marker</code> 멤버가 없어도 TypeScript가 컴파일 할 때 에러가 발생하지 않습니다.</p>\n<!--\nThe `$any` cast function can be used in conjunction with `this` to allow access to undeclared members of\nthe component.\n-->\n<p>그리고 템플릿에서 <code>this</code>를 사용해서 컴포넌트 클래스에 직접 접근할 때도 <code>$any</code> 캐스트 함수를 사용할 수 있습니다.</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"any-type-cast-function-2\" header=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;!-- 선언되지 않은 타입 참조하기 -->\n&#x3C;div>\n  Undeclared members is {{$any(this).member}}\n&#x3C;/div>\n\n</code-example>\n<!--\nThe `$any` cast function can be used anywhere in a binding expression where a method call is valid.\n-->\n<p><code>$any</code> 캐스트 함수는 함수를 실행할 수 있는 바인딩 표현식이라면 어디에나 자유롭게 사용할 수 있습니다.</p>\n<!--\n## Summary\n-->\n<h2 id=\"정리\">정리<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-syntax#정리\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nYou've completed this survey of template syntax.\nNow it's time to put that knowledge to work on your own components and directives.\n-->\n<p>지금까지 템플릿 문법에 대해 아주 자세하게 알아봤습니다.\n이 문서에서 알아본 템플릿 문법을 컴포넌트와 디렉티브에 직접 적용해 보세요.</p>\n\n</div>\n\n<!-- links to this doc:\n - guide/ajs-quick-reference\n - guide/aot-compiler\n - guide/architecture-components\n - guide/attribute-directives\n - guide/change-log\n - guide/component-interaction\n - guide/displaying-data\n - guide/forms\n - guide/glossary\n - guide/pipes\n - guide/router\n - guide/structural-directives\n - guide/styleguide\n - guide/upgrade\n - guide/user-input\n - tutorial/toh-pt2\n - tutorial/toh-pt3\n - tutorial/toh-pt4\n - tutorial/toh-pt5\n-->\n<!-- links from this doc:\n - api/animations/style\n - api/common/JsonPipe\n - api/common/LowerCasePipe\n - api/common/NgClass\n - api/common/NgForOf\n - api/common/NgForOfContext#even\n - api/common/NgForOfContext#odd\n - api/common/NgIf\n - api/common/NgStyle\n - api/common/NgSwitch\n - api/common/NgSwitchCase\n - api/common/NgSwitchDefault\n - api/common/UpperCasePipe\n - api/common/http\n - api/core/Component\n - api/core/Component#template\n - api/core/ContentChild\n - api/core/DebugElement#classes\n - api/core/Directive\n - api/core/EventEmitter\n - api/core/Input\n - api/core/NgModule\n - api/core/NgModule#imports\n - api/core/Output\n - api/core/Query#read\n - api/core/SecurityContext#HTML\n - api/core/ViewChild\n - api/forms/ControlValueAccessor\n - api/forms/FormsModule\n - api/forms/NgForm\n - api/forms/NgModel\n - api/http/RequestMethod#Delete\n - api/http/ResponseContentType#Text\n - api/platform-browser/BrowserModule\n - api/platform-browser/Title\n - api/platform-server/PlatformConfig#document\n - api/router/RouterLinkActive#isActive\n - api/router/RouterLinkWithHref\n - api/router/RouterLinkWithHref#target\n - guide/attribute-directives\n - guide/forms\n - guide/forms#ngModel\n - guide/glossary#camelcase\n - guide/glossary#dash-case\n - guide/pipes\n - guide/pipes#%ED%8C%8C%EC%9D%B4%ED%94%84-%EC%9D%B8%EC%9E%90-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\n - guide/router\n - guide/security\n - guide/security#%EC%BD%94%EB%93%9C-%EC%95%88%EC%A0%84%EC%84%B1-%EA%B2%80%EC%82%AC%EC%99%80-%EB%B3%B4%EC%95%88-%EC%98%81%EC%97%AD\n - guide/structural-directives\n - guide/structural-directives#%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%9E%85%EB%A0%A5-%EB%B3%80%EC%88%98\n - guide/structural-directives#asterisk\n - guide/structural-directives#microsyntax\n - guide/structural-directives#ngcontainer\n - guide/structural-directives#one-per-element\n - guide/template-syntax#%EA%B5%AC%EC%A1%B0-%EB%94%94%EB%A0%89%ED%8B%B0%EB%B8%8C\n - guide/template-syntax#%EB%A1%9C%EC%A7%81%EC%9D%80-%EC%B5%9C%EB%8C%80%ED%95%9C-%EB%8B%A8%EC%88%9C%ED%95%98%EA%B2%8C\n - guide/template-syntax#%EB%A9%B1%EB%93%B1%EC%84%B1\n - guide/template-syntax#%EC%8A%A4%ED%83%80%EC%9D%BC-%EB%B0%94%EC%9D%B8%EB%94%A9\n - guide/template-syntax#%EC%8B%A4%ED%96%89%EC%8B%9C%EA%B0%84%EC%9D%80-%EC%B5%9C%EB%8C%80%ED%95%9C-%EC%A7%A7%EA%B2%8C\n - guide/template-syntax#%EC%95%88%EC%A0%84-%EC%B0%B8%EC%A1%B0-%EC%97%B0%EC%82%B0%EC%9E%90\n - guide/template-syntax#%EC%96%91%EB%B0%A9%ED%96%A5-%EB%B0%94%EC%9D%B8%EB%94%A9\n - guide/template-syntax#%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8-%EB%94%94%EB%A0%89%ED%8B%B0%EB%B8%8C\n - guide/template-syntax#%EC%99%B8%EB%B6%80-%EC%98%81%ED%96%A5-%EC%B5%9C%EC%86%8C%ED%99%94\n - guide/template-syntax#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%B0%94%EC%9D%B8%EB%94%A9\n - guide/template-syntax#%EC%9E%85%EC%B6%9C%EB%A0%A5-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0\n - guide/template-syntax#%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%B0%94%EC%9D%B8%EB%94%A9\n - guide/template-syntax#%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%8B%A4%ED%96%89%EB%AC%B8\n - guide/template-syntax#%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%9E%85%EB%A0%A5-%EB%B3%80%EC%88%98\n - guide/template-syntax#%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%B0%B8%EC%A1%B0-%EB%B3%80%EC%88%98\n - guide/template-syntax#%ED%85%9C%ED%94%8C%EB%A6%BF-%ED%91%9C%ED%98%84%EC%8B%9D\n - guide/template-syntax#%ED%85%9C%ED%94%8C%EB%A6%BF-%ED%91%9C%ED%98%84%EC%8B%9D-%EC%A0%84%EC%9A%A9-%EC%97%B0%EC%82%B0%EC%9E%90\n - guide/template-syntax#%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EB%B0%94%EC%9D%B8%EB%94%A9\n - guide/template-syntax#%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EB%B0%94%EC%9D%B8%EB%94%A9-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%B0%94%EC%9D%B8%EB%94%A9\n - guide/template-syntax#aliasing-io\n - guide/template-syntax#any-타입-캐스트-함수-any-expression-\n - guide/template-syntax#event-객체와-이벤트-처리-실행문\n - guide/template-syntax#html-어트리뷰트-vs-dom-프로퍼티\n - guide/template-syntax#ngClass\n - guide/template-syntax#ngFor\n - guide/template-syntax#ngIf\n - guide/template-syntax#ngModel\n - guide/template-syntax#ngStyle\n - guide/template-syntax#ngSwitch\n - guide/template-syntax#ngclass\n - guide/template-syntax#ngfor-세부-문법\n - guide/template-syntax#ngforof\n - guide/template-syntax#ngif\n - guide/template-syntax#ngmodel---양방향-바인딩-디렉티브-ngmodel\n - guide/template-syntax#ngmodel-동작-원리\n - guide/template-syntax#ngmodel-을-사용하려면-formsmodule-이-필요합니다\n - guide/template-syntax#ngstyle\n - guide/template-syntax#ngswitch-디렉티브\n - guide/template-syntax#null-객체-참조를-방지하는-안전-참조-연산자--\n - guide/template-syntax#null-방지\n - guide/template-syntax#null-방지-연산자---\n - guide/template-syntax#trackby-와-함께-사용하기\n - guide/template-syntax#typescript-접근제어자-설정\n - guide/template-syntax#개요\n - guide/template-syntax#괄호-빼먹지-않기\n - guide/template-syntax#기본-구조-디렉티브\n - guide/template-syntax#기본-디렉티브\n - guide/template-syntax#기본-어트리뷰트-디렉티브\n - guide/template-syntax#다른-컴포넌트와-바인딩하기\n - guide/template-syntax#단방향-바인딩\n - guide/template-syntax#대상-이벤트\n - guide/template-syntax#로직은-최대한-단순하게\n - guide/template-syntax#멱등성\n - guide/template-syntax#문자열-바인딩interpolation----\n - guide/template-syntax#문자열을-그대로-사용하는-경우\n - guide/template-syntax#바인딩-대상\n - guide/template-syntax#바인딩-대상-1\n - guide/template-syntax#바인딩-문법--개요\n - guide/template-syntax#보이게-하거나-숨기는-것과는-다릅니다\n - guide/template-syntax#새로운-html-구현방식으로-생각하기\n - guide/template-syntax#스타일-바인딩\n - guide/template-syntax#실행시간은-최대한-짧게\n - guide/template-syntax#양방향-바인딩---\n - guide/template-syntax#어울리는-반환값-타입-사용하기\n - guide/template-syntax#어트리뷰트-바인딩\n - guide/template-syntax#어트리뷰트-클래스-스타일-바인딩\n - guide/template-syntax#외부-영향-최소화\n - guide/template-syntax#외부-영향-최소화-1\n - guide/template-syntax#이벤트-바인딩--이벤트-\n - guide/template-syntax#인덱스-와-함께-사용하기\n - guide/template-syntax#입력일까-출력일까\n - guide/template-syntax#입출력-프로퍼티\n - guide/template-syntax#입출력-프로퍼티-지정하기\n - guide/template-syntax#정리\n - guide/template-syntax#참조-변수를-사용해서-입력값-얻기\n - guide/template-syntax#커스텀-이벤트와-eventemitter\n - guide/template-syntax#코드-안전성-검증\n - guide/template-syntax#클래스-바인딩\n - guide/template-syntax#템플릿-문법\n - guide/template-syntax#템플릿-실행문-template-statements\n - guide/template-syntax#템플릿-실행문-가이드라인\n - guide/template-syntax#템플릿-실행문의-영향\n - guide/template-syntax#템플릿-실행문의-컨텍스트\n - guide/template-syntax#템플릿-입력-변수\n - guide/template-syntax#템플릿-참조-변수--var-\n - guide/template-syntax#템플릿-참조-변수를-사용할-때-주의할-점\n - guide/template-syntax#템플릿-표현식-template-expressions\n - guide/template-syntax#템플릿-표현식-가이드라인\n - guide/template-syntax#템플릿-표현식-전용-연산자\n - guide/template-syntax#템플릿-표현식의-컨텍스트\n - guide/template-syntax#템플릿과-html\n - guide/template-syntax#파이프-연산자---\n - guide/template-syntax#프로퍼티-바인딩--프로퍼티-\n - guide/template-syntax#프로퍼티-바인딩-문자열-바인딩\n - http://www.typescriptlang.org/docs/handbook/basic-types.html#any\n - http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html\n - http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-assertion-operator\n - https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement\n - https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA\n - https://developer.mozilla.org/en-US/docs/Web/Events\n - https://developer.mozilla.org/en-US/docs/Web/SVG\n - https://developer.mozilla.org/en-US/docs/Web/Web_Components\n - https://en.wikipedia.org/wiki/Idempotence\n - https://github.com/angular/angular/edit/master/aio/content/guide/template-syntax.md?message=docs%3A%20describe%20your%20change...\n-->"
}