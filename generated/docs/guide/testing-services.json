{
  "id": "guide/testing-services",
  "title": "서비스 테스트하기",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/testing-services.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Testing services\n-->\n<h1 id=\"서비스-테스트하기\">서비스 테스트하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#서비스-테스트하기\"><i class=\"material-icons\">link</i></a></h1>\n<!--\nTo check that your services are working as you intend, you can write tests specifically for them.\n\n<div class=\"alert is-helpful\">\n\n  For the sample app that the testing guides describe, see the <live-example name=\"testing\" embedded-style noDownload>sample app</live-example>.\n\n  For the tests features in the testing guides, see <live-example name=\"testing\" stackblitz=\"specs\" noDownload>tests</live-example>.\n\n</div>\n\n\nServices are often the easiest files to unit test.\nHere are some synchronous and asynchronous unit tests of the `ValueService`\nwritten without assistance from Angular testing utilities.\n\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"ValueService\" header=\"app/demo/demo.spec.ts\">\n// Angular가 제공하는 테스트 유틸리티를 사용하지 않고 Jasmine을 그대로 사용합니다.\ndescribe(&#39;ValueService&#39;, () =&gt; {\n  let service: ValueService;\n  beforeEach(() =&gt; { service = new ValueService(); });\n\n  it(&#39;#getValue should return real value&#39;, () =&gt; {\n    expect(service.getValue()).toBe(&#39;real value&#39;);\n  });\n\n  it(&#39;#getObservableValue should return value from observable&#39;,\n    (done: DoneFn) =&gt; {\n    service.getObservableValue().subscribe(value =&gt; {\n      expect(value).toBe(&#39;observable value&#39;);\n      done();\n    });\n  });\n\n  it(&#39;#getPromiseValue should return value from a promise&#39;,\n    (done: DoneFn) =&gt; {\n    service.getPromiseValue().then(value =&gt; {\n      expect(value).toBe(&#39;promise value&#39;);\n      done();\n    });\n  });\n});\n\n</code-example>\n-->\n<p>서비스가 의도한 대로 동작하는지 확인하려면 이 서비스를 테스트하는 테스트 코드를 작성하면 됩니다.</p>\n<div class=\"alert is-helpful\">\n<p>이 문서에서 다루는 예제 앱은 <live-example name=\"testing\" embedded-style=\"\" nodownload=\"\">sample app</live-example>에서 확인할 수 있습니다.</p>\n<p>이 문서에서 설명하는 테스트 기능은 <live-example name=\"testing\" stackblitz=\"specs\" nodownload=\"\">tests</live-example>에서 확인할 수 있습니다.</p>\n</div>\n<p>Angular 구성요소 중에 유닛 테스트를 적용하기 가장 쉬운 것은 서비스입니다.\n이 문서에서는 <code>ValueService</code>를 대상으로 동기/비동기 방식으로 유닛 테스트를 작성하는 방법에 대해 알아봅시다.</p>\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"ValueService\" header=\"app/demo/demo.spec.ts\">\n// Angular가 제공하는 테스트 유틸리티를 사용하지 않고 Jasmine을 그대로 사용합니다.\ndescribe('ValueService', () => {\n  let service: ValueService;\n  beforeEach(() => { service = new ValueService(); });\n\n  it('#getValue should return real value', () => {\n    expect(service.getValue()).toBe('real value');\n  });\n\n  it('#getObservableValue should return value from observable',\n    (done: DoneFn) => {\n    service.getObservableValue().subscribe(value => {\n      expect(value).toBe('observable value');\n      done();\n    });\n  });\n\n  it('#getPromiseValue should return value from a promise',\n    (done: DoneFn) => {\n    service.getPromiseValue().then(value => {\n      expect(value).toBe('promise value');\n      done();\n    });\n  });\n});\n\n</code-example>\n<a id=\"services-with-dependencies\"></a>\n<!--\n## Services with dependencies\n-->\n<h2 id=\"의존성-객체가-있는-서비스\">의존성 객체가 있는 서비스<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#의존성-객체가-있는-서비스\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nServices often depend on other services that Angular injects into the constructor.\nIn many cases, it's easy to create and _inject_ these dependencies by hand while\ncalling the service's constructor.\n\nThe `MasterService` is a simple example:\n\n<code-example path=\"testing/src/app/demo/demo.ts\" region=\"MasterService\" header=\"app/demo/demo.ts\">\n@Injectable()\nexport class MasterService {\n  constructor(private valueService: ValueService) { }\n  getValue() { return this.valueService.getValue(); }\n}\n\n</code-example>\n\n`MasterService` delegates its only method, `getValue`, to the injected `ValueService`.\n\nHere are several ways to test it.\n\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"MasterService\" header=\"app/demo/demo.spec.ts\">\ndescribe(&#39;MasterService without Angular testing support&#39;, () =&gt; {\n  let masterService: MasterService;\n\n  it(&#39;#getValue should return real value from the real service&#39;, () =&gt; {\n    masterService = new MasterService(new ValueService());\n    expect(masterService.getValue()).toBe(&#39;real value&#39;);\n  });\n\n  it(&#39;#getValue should return faked value from a fakeService&#39;, () =&gt; {\n    masterService = new MasterService(new FakeValueService());\n    expect(masterService.getValue()).toBe(&#39;faked service value&#39;);\n  });\n\n  it(&#39;#getValue should return faked value from a fake object&#39;, () =&gt; {\n    const fake =  { getValue: () =&gt; &#39;fake value&#39; };\n    masterService = new MasterService(fake as ValueService);\n    expect(masterService.getValue()).toBe(&#39;fake value&#39;);\n  });\n\n  it(&#39;#getValue should return stubbed value from a spy&#39;, () =&gt; {\n    // `getValue` 메소드가 정의된 스파이 객체를 정의합니다.\n    const valueServiceSpy =\n      jasmine.createSpyObj(&#39;ValueService&#39;, [&#39;getValue&#39;]);\n\n    // `getValue` 스파이 메소드가 반환할 값을 정의합니다.\n    const stubValue = &#39;stub value&#39;;\n    valueServiceSpy.getValue.and.returnValue(stubValue);\n\n    masterService = new MasterService(valueServiceSpy);\n\n    expect(masterService.getValue())\n      .toBe(stubValue, &#39;service returned stub value&#39;);\n    expect(valueServiceSpy.getValue.calls.count())\n      .toBe(1, &#39;spy method was called once&#39;);\n    expect(valueServiceSpy.getValue.calls.mostRecent().returnValue)\n      .toBe(stubValue);\n  });\n});\n\n</code-example>\n\nThe first test creates a `ValueService` with `new` and passes it to the `MasterService` constructor.\n\nHowever, injecting the real service rarely works well as most dependent services are difficult to create and control.\n\nInstead you can mock the dependency, use a dummy value, or create a\n[spy](https://jasmine.github.io/2.0/introduction.html#section-Spies)\non the pertinent service method.\n\n<div class=\"alert is-helpful\">\n\nPrefer spies as they are usually the easiest way to mock services.\n\n</div>\n\nThese standard testing techniques are great for unit testing services in isolation.\n\nHowever, you almost always inject services into application classes using Angular\ndependency injection and you should have tests that reflect that usage pattern.\nAngular testing utilities make it easy to investigate how injected services behave.\n-->\n<p>서비스는 다른 서비스를 의존성으로 주입받는 경우가 종종 있습니다.\n이런 의존성 객체들은 대부분 간단하게 생성해서 서비스 생성자를 실행할 때 직접 인자로 전달하면 됩니다.</p>\n<p>예제를 봅시다:</p>\n<code-example path=\"testing/src/app/demo/demo.ts\" region=\"MasterService\" header=\"app/demo/demo.ts\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class MasterService {\n  constructor(private valueService: ValueService) { }\n  getValue() { return this.valueService.getValue(); }\n}\n\n</code-example>\n<p><code>MasterService</code>에는 <code>getValue</code> 메서드가 있으며 이 서비스에는 <code>ValueService</code>가 의존성으로 주입됩니다.</p>\n<p><code>MasterService</code>는 이렇게 테스트할 수 있습니다.</p>\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"MasterService\" header=\"app/demo/demo.spec.ts\">\ndescribe('MasterService without Angular testing support', () => {\n  let masterService: MasterService;\n\n  it('#getValue should return real value from the real service', () => {\n    masterService = new MasterService(new ValueService());\n    expect(masterService.getValue()).toBe('real value');\n  });\n\n  it('#getValue should return faked value from a fakeService', () => {\n    masterService = new MasterService(new FakeValueService());\n    expect(masterService.getValue()).toBe('faked service value');\n  });\n\n  it('#getValue should return faked value from a fake object', () => {\n    const fake =  { getValue: () => 'fake value' };\n    masterService = new MasterService(fake as ValueService);\n    expect(masterService.getValue()).toBe('fake value');\n  });\n\n  it('#getValue should return stubbed value from a spy', () => {\n    // `getValue` 메소드가 정의된 스파이 객체를 정의합니다.\n    const valueServiceSpy =\n      jasmine.createSpyObj('ValueService', ['getValue']);\n\n    // `getValue` 스파이 메소드가 반환할 값을 정의합니다.\n    const stubValue = 'stub value';\n    valueServiceSpy.getValue.and.returnValue(stubValue);\n\n    masterService = new MasterService(valueServiceSpy);\n\n    expect(masterService.getValue())\n      .toBe(stubValue, 'service returned stub value');\n    expect(valueServiceSpy.getValue.calls.count())\n      .toBe(1, 'spy method was called once');\n    expect(valueServiceSpy.getValue.calls.mostRecent().returnValue)\n      .toBe(stubValue);\n  });\n});\n\n</code-example>\n<p>첫 번째 테스트 코드에서 <code>ValueService</code> 인스턴스는 <code>new</code> 키워드로 생성해서 <code>MasterService</code> 생성자로 전달했습니다.</p>\n<p>하지만 실제 서비스 클래스를 인스턴스로 만들어서 의존성으로 주입하는 방식은 제대로 동작하지 않을 가능성이 크고 이 의존성 객체를 다루기도 쉽지 않습니다.</p>\n<p>그래서 실제 서비스 대신 목 객체나 더미 값, <a href=\"https://jasmine.github.io/2.0/introduction.html#section-Spies\">스파이</a>를 활용하는 것이 더 좋습니다.</p>\n<div class=\"alert is-helpful\">\n<p>목 서비스는 스파이를 활용해서 만드는 방법이 가장 쉽습니다.</p>\n</div>\n<p>이런 방식을 활용하면 테스트하려는 서비스를 독립된 컨텍스트에 두고 테스트할 수 있습니다.</p>\n<p>하지만 결국 Angular 의존성 주입 시스템을 활용해서 실제 사용하는 시나리오에서 애플리케이션이 제대로 동작하는지 확인하는 테스트가 필요합니다.\nAngular가 제공하는 테스트 유틸리티를 활용하면 이 작업을 더 쉽게 처리할 수 있습니다.</p>\n<!--\n## Testing services with the _TestBed_\n-->\n<h2 id=\"testbed-로-서비스-테스트하기\"><em>TestBed</em> 로 서비스 테스트하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#testbed-로-서비스-테스트하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nYour app relies on Angular [dependency injection (DI)](guide/dependency-injection)\nto create services.\nWhen a service has a dependent service, DI finds or creates that dependent service.\nAnd if that dependent service has its own dependencies, DI finds-or-creates them as well.\n\nAs service _consumer_, you don't worry about any of this.\nYou don't worry about the order of constructor arguments or how they're created.\n\nAs a service _tester_, you must at least think about the first level of service dependencies\nbut you _can_ let Angular DI do the service creation and deal with constructor argument order\nwhen you use the `TestBed` testing utility to provide and create services.\n-->\n<p>서비스가 생성될 때는 Angular가 제공하는 <a href=\"guide/dependency-injection\">의존성 주입(Dependency Injection, DI</a> 시스템을 사용해서 서비스 인스턴스를 생성합니다.\n서비스가 의존성 객체로 요청되면 Angular 의존성 주입 시스템이 해당 서비스와 관련 의존성 객체를 모두 생성해서 반환하는 식입니다.</p>\n<p>그래서 서비스를 주입받는 쪽에서는 이 과정을 걱정할 필요가 없습니다.\n생성자의 인자 순서를 신경쓸 필요 없으며 인스턴스를 어떻게 생성하는지도 알 필요가 없습니다.</p>\n<p>서비스를 테스트하는 코드에서도 테스트하려는 서비스만 신경쓰면 됩니다.\n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 를 활용하면 테스트 코드 컨텍스트에서 사용할 의존성 주입 시스템의 동작을 변경할 수 있습니다.</p>\n<a id=\"testbed\"></a>\n<h2 id=\"angular-testbed\">Angular <em>TestBed</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#angular-testbed\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe `TestBed` is the most important of the Angular testing utilities.\nThe `TestBed` creates a dynamically-constructed Angular _test_ module that emulates\nan Angular [@NgModule](guide/ngmodules).\n\nThe `TestBed.configureTestingModule()` method takes a metadata object that can have most of the properties of an [@NgModule](guide/ngmodules).\n\nTo test a service, you set the `providers` metadata property with an\narray of the services that you'll test or mock.\n\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"value-service-before-each\" header=\"app/demo/demo.testbed.spec.ts (provide ValueService in beforeEach)\">\nlet service: ValueService;\n\nbeforeEach(() =&gt; {\n  TestBed.configureTestingModule({ providers: [ValueService] });\n});\n\n</code-example>\n\nThen inject it inside a test by calling `TestBed.inject()` with the service class as the argument.\n\n<div class=\"alert is-helpful\">\n\n**Note:** `TestBed.get()` was deprecated as of Angular version 9.\nTo help minimize breaking changes, Angular introduces a new function called `TestBed.inject()`, which you should use instead.\nFor information on the removal of `TestBed.get()`,\nsee its entry in the [Deprecations index](guide/deprecations#index).\n\n</div>\n\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"value-service-inject-it\">\nit(&#39;should use ValueService&#39;, () =&gt; {\n  service = TestBed.inject(ValueService);\n  expect(service.getValue()).toBe(&#39;real value&#39;);\n});\n\n</code-example>\n\nOr inside the `beforeEach()` if you prefer to inject the service as part of your setup.\n\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"value-service-inject-before-each\">\nbeforeEach(() =&gt; {\n  TestBed.configureTestingModule({ providers: [ValueService] });\n  service = TestBed.inject(ValueService);\n});\n\n</code-example>\n\nWhen testing a service with a dependency, provide the mock in the `providers` array.\n\nIn the following example, the mock is a spy object.\n\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"master-service-before-each\">\nlet masterService: MasterService;\nlet valueServiceSpy: jasmine.SpyObj&lt;ValueService&gt;;\n\nbeforeEach(() =&gt; {\n  const spy = jasmine.createSpyObj(&#39;ValueService&#39;, [&#39;getValue&#39;]);\n\n  TestBed.configureTestingModule({\n    // 테스트할 서비스와 의존성으로 사용될 목 객체를 등록합니다.\n    providers: [\n      MasterService,\n      { provide: ValueService, useValue: spy }\n    ]\n  });\n  // 서비스의 인스턴스와 목 객체의 인스턴스를 가져옵니다.\n  masterService = TestBed.inject(MasterService);\n  valueServiceSpy = TestBed.inject(ValueService) as jasmine.SpyObj&lt;ValueService&gt;;\n});\n\n</code-example>\n\nThe test consumes that spy in the same way it did earlier.\n\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"master-service-it\">\nit(&#39;#getValue should return stubbed value from a spy&#39;, () =&gt; {\n  const stubValue = &#39;stub value&#39;;\n  valueServiceSpy.getValue.and.returnValue(stubValue);\n\n  expect(masterService.getValue())\n    .toBe(stubValue, &#39;service returned stub value&#39;);\n  expect(valueServiceSpy.getValue.calls.count())\n    .toBe(1, &#39;spy method was called once&#39;);\n  expect(valueServiceSpy.getValue.calls.mostRecent().returnValue)\n    .toBe(stubValue);\n});\n\n</code-example>\n-->\n<p><code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>는 Angular가 제공하는 테스트 유틸리티 중에서 가장 중요한 클래스입니다.\n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>는 <a href=\"guide/ngmodules\">@NgModule</a> 역할을 하는 Angular 테스트 모듈을 동적으로 구성합니다.</p>\n<p><code>TestBed.configureTestingModule()</code> 메서드는 보통 <a href=\"guide/ngmodules\">@NgModule</a>에 사용하는 메타데이터 객체를 인자로 받습니다.</p>\n<p>서비스를 테스트하려면 이 메타데이터의 <code>providers</code> 배열에 테스트하려는 서비스와 관련 서비스를 등록하면 됩니다.</p>\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"value-service-before-each\" header=\"app/demo/demo.testbed.spec.ts (beforeEach()에서 ValueService 동작 환경 구성하기)\">\nlet service: ValueService;\n\nbeforeEach(() => {\n  TestBed.configureTestingModule({ providers: [ValueService] });\n});\n\n</code-example>\n<p>이렇게 구성하고 나면 서비스 인스턴스를 의존성으로 주입할 때 <code>TestBed.inject()</code> 메서드를 실행해서 인스턴스를 가져올 수 있습니다.</p>\n<div class=\"alert is-helpful\">\n<p><strong>참고:</strong> <code>TestBed.get()</code>은 Angular 9 버전부터 지원이 중단되었으며, 이 메서드 대신 <code>TestBed.inject()</code>를 사용해야 합니다.</p>\n<p>자세한 내용은 <a href=\"guide/deprecations#index\">지원 중단 기능</a> 문서를 참고하세요.</p>\n</div>\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"value-service-inject-it\">\nit('should use ValueService', () => {\n  service = TestBed.inject(ValueService);\n  expect(service.getValue()).toBe('real value');\n});\n\n</code-example>\n<p>아니면 <code>beforeEach()</code> 안에서 의존성 객체의 인스턴스를 미리 받아두는 방법을 사용할 수도 있습니다.</p>\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"value-service-inject-before-each\">\nbeforeEach(() => {\n  TestBed.configureTestingModule({ providers: [ValueService] });\n  service = TestBed.inject(ValueService);\n});\n\n</code-example>\n<p>의존성 객체가 있는 서비스를 테스트하려면 해당 의존성 객체의 목도 <code>providers</code> 배열에 추가해야 합니다.</p>\n<p>아래 코드는 스파이 객체를 의존성 객체로 사용하는 예제 코드입니다.</p>\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"master-service-before-each\">\nlet masterService: MasterService;\nlet valueServiceSpy: jasmine.SpyObj&#x3C;ValueService>;\n\nbeforeEach(() => {\n  const spy = jasmine.createSpyObj('ValueService', ['getValue']);\n\n  TestBed.configureTestingModule({\n    // 테스트할 서비스와 의존성으로 사용될 목 객체를 등록합니다.\n    providers: [\n      MasterService,\n      { provide: ValueService, useValue: spy }\n    ]\n  });\n  // 서비스의 인스턴스와 목 객체의 인스턴스를 가져옵니다.\n  masterService = TestBed.inject(MasterService);\n  valueServiceSpy = TestBed.inject(ValueService) as jasmine.SpyObj&#x3C;ValueService>;\n});\n\n</code-example>\n<p>스파이 객체는 이렇게 사용합니다.</p>\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"master-service-it\">\nit('#getValue should return stubbed value from a spy', () => {\n  const stubValue = 'stub value';\n  valueServiceSpy.getValue.and.returnValue(stubValue);\n\n  expect(masterService.getValue())\n    .toBe(stubValue, 'service returned stub value');\n  expect(valueServiceSpy.getValue.calls.count())\n    .toBe(1, 'spy method was called once');\n  expect(valueServiceSpy.getValue.calls.mostRecent().returnValue)\n    .toBe(stubValue);\n});\n\n</code-example>\n<a id=\"no-before-each\"></a>\n<!--\n## Testing without _beforeEach()_\n-->\n<h2 id=\"beforeeach-밖에서-테스트하세요\"><em>beforeEach()</em> 밖에서 테스트하세요.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#beforeeach-밖에서-테스트하세요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nMost test suites in this guide call `beforeEach()` to set the preconditions for each `it()` test\nand rely on the `TestBed` to create classes and inject services.\n\nThere's another school of testing that never calls `beforeEach()` and prefers to create classes explicitly rather than use the `TestBed`.\n\nHere's how you might rewrite one of the `MasterService` tests in that style.\n\nBegin by putting re-usable, preparatory code in a _setup_ function instead of `beforeEach()`.\n\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"no-before-each-setup\" header=\"app/demo/demo.spec.ts (setup)\">\nfunction setup() {\n  const valueServiceSpy =\n    jasmine.createSpyObj(&#39;ValueService&#39;, [&#39;getValue&#39;]);\n  const stubValue = &#39;stub value&#39;;\n  const masterService = new MasterService(valueServiceSpy);\n\n  valueServiceSpy.getValue.and.returnValue(stubValue);\n  return { masterService, stubValue, valueServiceSpy };\n}\n\n</code-example>\n\nThe `setup()` function returns an object literal\nwith the variables, such as `masterService`, that a test might reference.\nYou don't define _semi-global_ variables (e.g., `let masterService: MasterService`)\nin the body of the `describe()`.\n\nThen each test invokes `setup()` in its first line, before continuing\nwith steps that manipulate the test subject and assert expectations.\n\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"no-before-each-test\">\nit(&#39;#getValue should return stubbed value from a spy&#39;, () =&gt; {\n  const { masterService, stubValue, valueServiceSpy } = setup();\n  expect(masterService.getValue())\n    .toBe(stubValue, &#39;service returned stub value&#39;);\n  expect(valueServiceSpy.getValue.calls.count())\n    .toBe(1, &#39;spy method was called once&#39;);\n  expect(valueServiceSpy.getValue.calls.mostRecent().returnValue)\n    .toBe(stubValue);\n});\n\n</code-example>\n\nNotice how the test uses\n[_destructuring assignment_](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)\nto extract the setup variables that it needs.\n\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"no-before-each-setup-call\">\nconst { masterService, stubValue, valueServiceSpy } = setup();\n\n</code-example>\n\nMany developers feel this approach is cleaner and more explicit than the\ntraditional `beforeEach()` style.\n\nAlthough this testing guide follows the traditional style and\nthe default [CLI schematics](https://github.com/angular/angular-cli)\ngenerate test files with `beforeEach()` and `TestBed`,\nfeel free to adopt _this alternative approach_ in your own projects.\n-->\n<p>이 문서에서는 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>를 구성하거나 <code>it()</code> 구문 안쪽에 사용할 객체를 미리 준비하는 코드를 <code>beforeEach()</code> 안에 작성했습니다.</p>\n<p><code>beforeEach()</code> 안에는 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>를 구성하는 코드 외에는 최대한 작성하지 않는 것이 좋습니다.\n기능을 테스트하는 코드도 마찬가지입니다.</p>\n<p><code>MasterService</code>를 테스트하는 코드도 이런 방식으로 작성되었습니다.</p>\n<p>테스트 환경을 설정하거나 개별 테스트 스펙에 필요한 로직은 <code>beforeEach()</code> 대신 <code>setup()</code> 함수를 별도로 만들어서 사용할 수도 있습니다.</p>\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"no-before-each-setup\" header=\"app/demo/demo.spec.ts (setup())\">\nfunction setup() {\n  const valueServiceSpy =\n    jasmine.createSpyObj('ValueService', ['getValue']);\n  const stubValue = 'stub value';\n  const masterService = new MasterService(valueServiceSpy);\n\n  valueServiceSpy.getValue.and.returnValue(stubValue);\n  return { masterService, stubValue, valueServiceSpy };\n}\n\n</code-example>\n<p><code>setup()</code> 함수는 테스트 스펙에서 활용할 <code>masterService</code>와 같은 인스턴스를 객체 리터럴로 반환합니다.\n그래서 이 함수를 활용하면 <code>let masterService: MasterService</code>와 같이 거의 전역으로 사용되는 변수들을 선언하지 않아도 됩니다.</p>\n<p>개별 테스트 스펙에서는 <code>setup()</code>를 먼저 실행한 후에 서비스를 테스트하는 코드를 작성하면 됩니다.</p>\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"no-before-each-test\">\nit('#getValue should return stubbed value from a spy', () => {\n  const { masterService, stubValue, valueServiceSpy } = setup();\n  expect(masterService.getValue())\n    .toBe(stubValue, 'service returned stub value');\n  expect(valueServiceSpy.getValue.calls.count())\n    .toBe(1, 'spy method was called once');\n  expect(valueServiceSpy.getValue.calls.mostRecent().returnValue)\n    .toBe(stubValue);\n});\n\n</code-example>\n<p>객체에서 원하는 항목만 참조하는 문법은 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\">분해 할당자(destructuring assignment)</a> 문서를 참고하세요.</p>\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"no-before-each-setup-call\">\nconst { masterService, stubValue, valueServiceSpy } = setup();\n\n</code-example>\n<p>최근 조사를 보면 <code>beforeEach()</code> 스타일보다 <code>setup()</code>과 같은 함수를 활용하는 방식이 더 명확하다는 의견이 많았습니다.</p>\n<p>이 문서에서는 <code>beforeEach()</code>를 활용하는 방식을 기본으로 설명하고 있으며, <a href=\"https://github.com/angular/angular-cli\">Angular CLI 스키매틱</a>으로 생성된 테스트 파일도 <code>beforeEach()</code> 스타일로 구성됩니다.\n하지만 기존 방식을 꼭 지켜야 하는 것은 아니니 새로운 방식을 도입하는 것도 검토해 보세요.</p>\n<!--\n## Testing HTTP services\n-->\n<h2 id=\"http-서비스-테스트하기\">HTTP 서비스 테스트하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#http-서비스-테스트하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nData services that make HTTP calls to remote servers typically inject and delegate\nto the Angular [`HttpClient`](guide/http) service for XHR calls.\n\nYou can test a data service with an injected `HttpClient` spy as you would\ntest any service with a dependency.\n<code-example path=\"testing/src/app/model/hero.service.spec.ts\" region=\"test-with-spies\" header=\"app/model/hero.service.spec.ts (tests with spies)\">\nlet httpClientSpy: { get: jasmine.Spy };\nlet heroService: HeroService;\n\nbeforeEach(() =&gt; {\n  // TODO: 다른 스파이 메소드 추가하기\n  httpClientSpy = jasmine.createSpyObj(&#39;HttpClient&#39;, [&#39;get&#39;]);\n  heroService = new HeroService(httpClientSpy as any);\n});\n\nit(&#39;should return expected heroes (HttpClient called once)&#39;, () =&gt; {\n  const expectedHeroes: Hero[] =\n    [{ id: 1, name: &#39;A&#39; }, { id: 2, name: &#39;B&#39; }];\n\n  httpClientSpy.get.and.returnValue(asyncData(expectedHeroes));\n\n  heroService.getHeroes().subscribe(\n    heroes =&gt; expect(heroes).toEqual(expectedHeroes, &#39;expected heroes&#39;),\n    fail\n  );\n  expect(httpClientSpy.get.calls.count()).toBe(1, &#39;one call&#39;);\n});\n\nit(&#39;should return an error when the server returns a 404&#39;, () =&gt; {\n  const errorResponse = new HttpErrorResponse({\n    error: &#39;test 404 error&#39;,\n    status: 404, statusText: &#39;Not Found&#39;\n  });\n\n  httpClientSpy.get.and.returnValue(asyncError(errorResponse));\n\n  heroService.getHeroes().subscribe(\n    heroes =&gt; fail(&#39;expected an error, not heroes&#39;),\n    error  =&gt; expect(error.message).toContain(&#39;test 404 error&#39;)\n  );\n});\n\n</code-example>\n\n<div class=\"alert is-important\">\n\nThe `HeroService` methods return `Observables`. You must\n_subscribe_ to an observable to (a) cause it to execute and (b)\nassert that the method succeeds or fails.\n\nThe `subscribe()` method takes a success (`next`) and fail (`error`) callback.\nMake sure you provide _both_ callbacks so that you capture errors.\nNeglecting to do so produces an asynchronous uncaught observable error that\nthe test runner will likely attribute to a completely different test.\n\n</div>\n-->\n<p>리모트 서버로 HTTP 요청을 보내는 데이터 서비스는 Angular <a href=\"guide/http\"><code>HttpClient</code></a> 객체를 의존성으로 주입받고 이 객체로 XHR 요청을 보냅니다.</p>\n<p>이런 서비스는 이렇게 테스트할 수 있습니다.\n<code-example path=\"testing/src/app/model/hero.service.spec.ts\" region=\"test-with-spies\" header=\"app/model/hero.service.spec.ts (스파이로 테스트하기)\">\nlet httpClientSpy: { get: jasmine.Spy };\nlet heroService: HeroService;\n\nbeforeEach(() => {\n  // TODO: 다른 스파이 메소드 추가하기\n  httpClientSpy = jasmine.createSpyObj('<a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>', ['get']);\n  heroService = new HeroService(httpClientSpy as any);\n});\n\nit('should return expected heroes (<a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a> called once)', () => {\n  const expectedHeroes: Hero[] =\n    [{ id: 1, name: 'A' }, { id: 2, name: 'B' }];\n\n  httpClientSpy.get.and.returnValue(asyncData(expectedHeroes));\n\n  heroService.getHeroes().subscribe(\n    heroes => expect(heroes).toEqual(expectedHeroes, 'expected heroes'),\n    fail\n  );\n  expect(httpClientSpy.get.calls.count()).toBe(1, 'one call');\n});\n\nit('should return an error when the server returns a 404', () => {\n  const errorResponse = new <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a>({\n    error: 'test 404 error',\n    status: 404, statusText: 'Not Found'\n  });\n\n  httpClientSpy.get.and.returnValue(asyncError(errorResponse));\n\n  heroService.getHeroes().subscribe(\n    heroes => fail('expected an error, not heroes'),\n    error  => expect(error.message).toContain('test 404 error')\n  );\n});\n\n</code-example></p>\n<div class=\"alert is-important\">\n<p><code>HeroService</code> 메서드들은 <code>Observable</code>을 반환합니다.\n그래서 반드시 이 옵저버블을 <em>구독해야</em> (a) 실제 요청이 발생하며 (b) 메서드가 종료된 시점에 성공했는지 실패했는지 판단할 수 있습니다.</p>\n<p><code>subscribe()</code> 메서드는 옵저버블이 성공했을 때 실행될 콜백(<code>next</code>)과 실패했을 때 실행될 콜백(<code>error</code>)을 인자로 받습니다.\n옵저버블로 에러가 전달되는 것을 감지하려면 <em>두</em> 콜백 함수를 모두 정의해야 합니다.</p>\n<p>두 콜백 함수 중 하나를 정의하지 않으면 다른 테스트에서 발생하는 에러가 영향을 미쳐 예상하지 못한 동작을 할 수 있으니 주의하세요.</p>\n</div>\n<h2 id=\"httpclienttestingmodule\"><em>HttpClientTestingModule</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#httpclienttestingmodule\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nExtended interactions between a data service and the `HttpClient` can be complex\nand difficult to mock with spies.\n\nThe `HttpClientTestingModule` can make these testing scenarios more manageable.\n\nWhile the _code sample_ accompanying this guide demonstrates `HttpClientTestingModule`,\nthis page defers to the [Http guide](guide/http#testing-http-requests),\nwhich covers testing with the `HttpClientTestingModule` in detail.\n-->\n<p>목 스파이로 데이터 서비스나 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>를 직접 조작하는 것은 복잡하고 어렵습니다.</p>\n<p>이런 경우에는 <code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code>을 사용하는 것이 좋습니다.</p>\n<p>이 문서에서 <code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code>를 다루는 방식은 <a href=\"guide/http#testing-http-requests\">Http 가이드</a> 문서에서와는 조금 다릅니다.\n자세한 내용은 해당 문서를 참고하세요.</p>\n\n</div>\n\n<!-- links to this doc:\n - guide/testing\n - guide/testing-components-basics\n-->\n<!-- links from this doc:\n - api/common/http/HttpClient\n - api/common/http/HttpErrorResponse\n - api/common/http/testing/HttpClientTestingModule\n - api/core/Injectable\n - api/core/testing/TestBed\n - guide/dependency-injection\n - guide/deprecations#index\n - guide/http\n - guide/http#testing-http-requests\n - guide/ngmodules\n - guide/testing-services#angular-testbed\n - guide/testing-services#beforeeach-밖에서-테스트하세요\n - guide/testing-services#http-서비스-테스트하기\n - guide/testing-services#httpclienttestingmodule\n - guide/testing-services#testbed-로-서비스-테스트하기\n - guide/testing-services#서비스-테스트하기\n - guide/testing-services#의존성-객체가-있는-서비스\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\n - https://github.com/angular/angular-cli\n - https://github.com/angular/angular/edit/master/aio/content/guide/testing-services.md?message=docs%3A%20describe%20your%20change...\n - https://jasmine.github.io/2.0/introduction.html#section-Spies\n-->"
}