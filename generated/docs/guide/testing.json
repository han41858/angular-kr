{
  "id": "guide/testing",
  "title": "테스트",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/testing.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<a id=\"top\"></a>\n<!--\n# Testing\n-->\n<h1 id=\"테스트\">테스트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#테스트\"><i class=\"material-icons\">link</i></a></h1>\n<!--\nThis guide offers tips and techniques for unit and integration testing Angular applications.\n\nThe guide presents tests of a sample application created with the [Angular CLI](cli). This sample application is much like the one created in the [_Tour of Heroes_ tutorial](tutorial).\nThe sample application and all tests in this guide are available for inspection and experimentation:\n\n- <live-example embedded-style>Sample app</live-example>\n- <live-example stackblitz=\"specs\">Tests</live-example>\n-->\n<p>이 문서는 Angular 애플리케이션에 유닛 테스트와 통합 테스트를 적용하는 방법에 대해 설명합니다.</p>\n<p>내용을 설명하면서 사용하는 예제 애플리케이션은 <a href=\"cli\">Angular CLI</a>를 사용해서 만든 것이며, <a href=\"tutorial\"><em>히어로들의 여행</em> 튜토리얼</a>에서 다룬 애플리케이션과도 비슷합니다.\n이 문서에서 다루는 예제 애플리케이션과 모든 테스트 코드는 다음 링크에서 직접 확인하거나 다운받아 확인할 수 있습니다.</p>\n<ul>\n<li><live-example embedded-style=\"\">예제 앱 실행</live-example></li>\n<li><live-example stackblitz=\"specs\">테스트 코드 실행</live-example></li>\n</ul>\n<hr>\n<!--\n## Setup\n-->\n<h2 id=\"환경-설정\">환경 설정<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#환경-설정\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe Angular CLI downloads and install everything you need to test an Angular application with the [Jasmine test framework](https://jasmine.github.io/).\n\nThe project you create with the CLI is immediately ready to test.\nJust run the [`ng test`](cli/test) CLI command:\n-->\n<p>Angular 애플리케이션은 <a href=\"https://jasmine.github.io/\">Jasmine 테스트 프레임워크</a>로 테스트하는데, 애플리케이션을 테스트할 때 필요한 환경은 Angular CLI가 프로젝트를 생성하면서 모두 준비하기 때문에 바로 테스트할 수 있는 상태입니다.\n프로젝트 최상위 폴더에서 <a href=\"cli/test\"><code>ng test</code></a> 명령을 실행해 보세요:</p>\n<code-example language=\"sh\" class=\"code-shell\">\n  ng test\n</code-example>\n<!--\nThe `ng test` command builds the app in _watch mode_,\nand launches the [karma test runner](https://karma-runner.github.io).\n\nThe console output looks a bit like this:\n-->\n<p><code>ng test</code> 명령을 실행하면 애플리케이션을 <em>워치 모드(watch mode)</em> 로 빌드하고 <a href=\"https://karma-runner.github.io\">karma 테스트 러너</a>를 실행합니다.</p>\n<p>콘솔은 다음과 같이 출력될 것입니다:</p>\n<code-example language=\"sh\" class=\"code-shell\">\n10% building modules 1/1 modules 0 active\n...INFO [karma]: Karma v1.7.1 server started at <a href=\"api/common/http\" class=\"code-anchor\">http</a>://0.0.0.0:9876/\n...INFO [launcher]: Launching <a href=\"api/animations/browser\" class=\"code-anchor\">browser</a> Chrome ...\n...INFO [launcher]: Starting <a href=\"api/animations/browser\" class=\"code-anchor\">browser</a> Chrome\n...INFO [Chrome ...]: Connected on socket ...\nChrome ...: Executed 3 of 3 SUCCESS (0.135 secs / 0.205 secs)\n</code-example>\n<!--\nThe last line of the log is the most important.\nIt shows that Karma ran three tests that all passed.\n\nA chrome browser also opens and displays the test output in the \"Jasmine HTML Reporter\" like this.\n-->\n<p>이 로그에서 마지막 줄이 가장 중요합니다.\n마지막 줄을 보면 Karma가 3개의 테스트를 실행했고, 실행한 테스트는 모두 통과했다는 것을 확인할 수 있습니다.</p>\n<p>테스트 실행 결과는 Chrome 브라우저에서도 확인할 수 있습니다.\n브라우저에서는 \"Jasmine HTML Reporter\"를 사용해서 다음과 같이 표시됩니다.</p>\n<!--\n<figure>\n  <img src='generated/images/guide/testing/initial-jasmine-html-reporter.png' alt=\"Jasmine HTML Reporter in the browser\">\n</figure>\n-->\n<figure>\n  <img src=\"generated/images/guide/testing/initial-jasmine-html-reporter.png\" alt=\"브라우저에서 Jasmine HTML Reporter 확인하기\" width=\"502\" height=\"306\">\n</figure>\n<!--\nMost people find this browser output easier to read than the console log.\nYou can click on a test row to re-run just that test or click on a description to re-run the tests in the selected test group (\"test suite\").\n\nMeanwhile, the `ng test` command is watching for changes.\n\nTo see this in action, make a small change to `app.component.ts` and save.\nThe tests run again, the browser refreshes, and the new test results appear.\n-->\n<p>테스트 결과는 콘솔 로그로 확인하는 것보다 브라우저에서 확인하는 것이 더 편합니다.\n브라우저에서는 특정 테스트 스펙을 클릭해서 해당 스펙만 다시 실행해볼 수 있고, 테스트 그룹(test suite)을 클릭해서 그룹 단위로 다시 실행할 수도 있습니다.</p>\n<p>그리고 <code>ng test</code> 명령을 실행했기 때문에 코드가 변경되는 것도 감지합니다.</p>\n<p><code>app.component.ts</code> 파일의 내용을 수정하고 저장해 보세요.\n그러면 테스트가 다시 실행되면서 브라우저도 갱신되고, 새로운 결과 화면이 표시될 것입니다.</p>\n<!--\n#### Configuration\n-->\n<h4 id=\"테스트-설정\">테스트 설정<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#테스트-설정\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe CLI takes care of Jasmine and karma configuration for you.\n\nYou can fine-tune many options by editing the `karma.conf.js` and\nthe `test.ts` files in the `src/` folder.\n\nThe `karma.conf.js` file is a partial karma configuration file.\nThe CLI constructs the full runtime configuration in memory,based on application structure specified in the `angular.json` file, supplemented by `karma.conf.js`.\n\nSearch the web for more details about Jasmine and karma configuration.\n-->\n<p>Angular CLI로 프로젝트를 생성하면 Jasmine과 Karma를 실행할 수 있는 환경 설정이 자동으로 구성됩니다.\n이후에 이 설정을 튜닝하고 싶으면 <code>karma.conf.js</code> 파일과 <code>src/test.ts</code> 파일을 수정하면 됩니다.</p>\n<p><code>karma.conf.js</code> 파일은 Karma가 실행되는 환경설정 중 일부를 구성합니다.\nKarma의 전체 설정값은 테스트를 실행하는 시점에 <code>angular.json</code> 파일과 <code>karma.conf.js</code>를 분석해서 Angular CLI가 구성합니다.</p>\n<p>자세한 내용은 Jasmine 문서와 Karma 문서를 참고하세요.</p>\n<!--\n#### Other test frameworks\n-->\n<h4 id=\"다른-테스트-프레임워크\">다른 테스트 프레임워크<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#다른-테스트-프레임워크\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nYou can also unit test an Angular app with other testing libraries and test runners.\nEach library and runner has its own distinctive installation procedures, configuration, and syntax.\n\nSearch the web to learn more.\n-->\n<p>Jasmine과 Karma 말고도 다른 라이브러리나 테스트 러너를 사용해서 Angular 앱을 테스트할 수도 있습니다.\n이 때 라이브러리를 설치하는 방법, 환경을 설정하는 방법, 실행하는 방법은 라이브러리에 따라 다르기 때문에 사용하려는 라이브러리가 제공하는 문서를 참고하세요.</p>\n<!--\n#### Test file name and location\n-->\n<h4 id=\"테스트-파일의-이름과-위치\">테스트 파일의 이름과 위치<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#테스트-파일의-이름과-위치\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nLook inside the `src/app` folder.\n\nThe CLI generated a test file for the `AppComponent` named `app.component.spec.ts`.\n-->\n<p><code>src/app</code> 폴더를 봅시다.</p>\n<p>Angular CLI로 프로젝트를 생성하면 <code>AppComponent</code>를 테스트 하는 코드가 <code>app.component.spec.ts</code> 파일에 존재합니다.</p>\n<div class=\"alert is-important\">\n<!--\nThe test file extension **must be `.spec.ts`** so that tooling can identify it as a file with tests (AKA, a _spec_ file).\n-->\n<p>IDE와 같은 툴에서 스펙 파일을 구분하려면 테스트 파일의 확장자를 <strong>반드시 <code>.spec.ts</code></strong>로 지정해야 합니다.</p>\n</div>\n<!--\nThe `app.component.ts` and `app.component.spec.ts` files are siblings in the same folder.\nThe root file names (`app.component`) are the same for both files.\n\nAdopt these two conventions in your own projects for _every kind_ of test file.\n-->\n<p>두 파일을 보면 <code>app.component.ts</code> 파일과 <code>app.component.spec.ts</code> 파일은 같은 폴더에 이웃한 파일이며, 두 파일의 컴포넌트 이름 부분(<code>app.component</code>)이 같다는 것을 확인할 수 있습니다.</p>\n<p>이 룰은 프로젝트 안에 있는 <em>모든</em> 테스트 파일에 적용하는 것이 좋습니다.</p>\n<a id=\"ci\"></a>\n<!--\n## Set up continuous integration\n-->\n<h2 id=\"지속적인-통합환경-구성하기\">지속적인 통합환경 구성하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#지속적인-통합환경-구성하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nOne of the best ways to keep your project bug free is through a test suite, but it's easy to forget to run tests all the time. \nContinuous integration (CI) servers let you set up your project repository so that your tests run on every commit and pull request.\n\nThere are paid CI services like Circle CI and Travis CI, and you can also host your own for free using Jenkins and others. \nAlthough Circle CI and Travis CI are paid services, they are provided free for open source projects. \nYou can create a public project on GitHub and add these services without paying. \nContributions to the Angular repo are automatically run through a whole suite of Circle CI tests.\n\nThis article explains how to configure your project to run Circle CI and Travis CI, and also update your test configuration to be able to run tests in the Chrome browser in either environment.\n-->\n<p>프로젝트에서 발생하는 버그를 방지하려면 주기적으로 테스트를 실행하는 것이 좋지만, 매번 테스트를 실행해야 하는 것은 번거로운 일입니다.\n이 때 프로젝트 레파지토리에 CI(Continuous integration) 서버를 연결하면 이 레파지토리에 커밋이나 풀 리퀘스트가 있을 때마다 자동으로 테스트를 실행하게 할 수 있습니다.</p>\n<p>Circle CI와 Travis CI는 이런 경우에 사용하는 유료 CI 서비스입니다. 그리고 Jenkins와 같은 툴을 사용하면 무료 CI 환경을 구성할 수도 있습니다.\nCircle CI와 Travis CI는 기본적으로 유료 서비스지만, 오픈 소스 프로젝트에는 무료로 사용할 수 있습니다.\n그래서 GitHub에 public 프로젝트를 만들면 이 서비스를 무료로 사용할 수 있습니다.\nAngular 공식 레파지토리에 코드를 반영할 때도 Circle CI 테스트가 자동으로 실행됩니다.</p>\n<p>이 섹션에서는 프로젝트에 Circle CI와 Travis CI를 연결하는 방법에 대해 설명하고, 프로젝트의 테스트 스펙을 리모트 서버의 Chrome 브라우저에서 실행하는 방법에 대해 안내합니다.</p>\n<!--\n### Configure project for Circle CI\n-->\n<h3 id=\"circle-ci-환경-설정하기\">Circle CI 환경 설정하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#circle-ci-환경-설정하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nStep 1: Create a folder called `.circleci` at the project root.\n\nStep 2: In the new folder, create a file called `config.yml` with the following content:\n-->\n<p>1단계: 프로젝트 최상위 폴더에 <code>.circleci</code> 폴더를 생성합니다.</p>\n<p>2단계: 이 폴더에 <code>config.yml</code> 파일을 생성하고 파일의 내용을 다음과 같이 작성합니다:</p>\n<code-example>\nversion: 2\njobs:\n  build:\n    working_directory: ~/my-project\n    docker:\n      - image: circleci/node:8-browsers\n    steps:\n      - checkout\n      - restore_cache:\n          key: my-project-{{ .Branch }}-{{ checksum \"package-lock.json\" }}\n      - run: npm install\n      - save_cache:\n          key: my-project-{{ .Branch }}-{{ checksum \"package-lock.json\" }}\n          paths:\n            - \"node_modules\"\n      - run: npm run test -- --no-watch --no-progress --browsers=ChromeHeadlessCI\n      - run: npm run e2e -- --protractor-config=e2e/protractor-ci.conf.js\n</code-example>\n<!--\nThis configuration caches `node_modules/` and uses [`npm run`](https://docs.npmjs.com/cli/run-script) to run CLI commands, because `@angular/cli` is not installed globally. \nThe double dash (`--`) is needed to pass arguments into the `npm` script.\n\nStep 3: Commit your changes and push them to your repository.\n\nStep 4: [Sign up for Circle CI](https://circleci.com/docs/2.0/first-steps/) and [add your project](https://circleci.com/add-projects). \nYour project should start building.\n\n* Learn more about Circle CI from [Circle CI documentation](https://circleci.com/docs/2.0/).\n-->\n<p>이 환경설정 파일의 내용은 <code>node_modules/</code> 폴더의 내용을 캐싱하고 <a href=\"https://docs.npmjs.com/cli/run-script\"><code>npm run</code></a>으로 Angular CLI 명령을 실행하는 것입니다.\n<code>@angular/cli</code>는 전역 범위에 필요하기 때문에 <code>npm install</code> 명령을 실행해서 설치했습니다.\n그리고 <code>npm</code> 스크립트에 옵션을 지정하려면 대시 2개(<code>--</code>)를 함께 사용해야 합니다.</p>\n<p>3단계: 변경사항을 커밋하고 레파지토리에 푸시합니다.</p>\n<p>4단계: <a href=\"https://circleci.com/docs/2.0/first-steps/\">Circle CI에 회원가입</a>한 뒤에 <a href=\"https://circleci.com/add-projects\">프로젝트를 추가</a>하면 프로젝트 빌드가 시작됩니다.</p>\n<ul>\n<li>더 자세한 내용은 <a href=\"https://circleci.com/docs/2.0/\">Circle CI 문서</a>를 참고하세요.</li>\n</ul>\n<!--\n### Configure project for Travis CI\n-->\n<h3 id=\"travis-ci-환경-설정하기\">Travis CI 환경 설정하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#travis-ci-환경-설정하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nStep 1: Create a file called `.travis.yml` at the project root, with the following content:\n-->\n<p>1단계: 프로젝트 최상위 폴더에 <code>.travis.yml</code> 파일을 생성하고 내용을 다음과 같이 작성합니다:</p>\n<code-example>\ndist: trusty\nsudo: false\n\nlanguage: node_js\nnode_js:\n  - \"8\"\n  \naddons:\n  apt:\n    sources:\n      - google-chrome\n    packages:\n      - google-chrome-stable\n\ncache:\n  directories:\n     - ./node_modules\n\ninstall:\n  - npm install\n\nscript:\n  - npm run test -- --no-watch --no-progress --browsers=ChromeHeadlessCI\n  - npm run e2e -- --protractor-config=e2e/protractor-ci.conf.js\n</code-example>\n<!--\nThis does the same things as the Circle CI configuration, except that Travis doesn't come with Chrome, so we use Chromium instead.\n\nStep 2: Commit your changes and push them to your repository.\n\nStep 3: [Sign up for Travis CI](https://travis-ci.org/auth) and [add your project](https://travis-ci.org/profile). \nYou'll need to push a new commit to trigger a build.\n\n* Learn more about Travis CI testing from [Travis CI documentation](https://docs.travis-ci.com/).\n-->\n<p>이 환경설정 파일의 내용은 Circle CI에서 설정했던 내용과 같지만, Travis에는 Chrome이 설치되어있지 않기 때문에 Chromium을 추가로 설치했습니다.</p>\n<p>2단계: 변경사항을 커밋하고 레파지토리에 푸시합니다.</p>\n<p>3단계: <a href=\"https://travis-ci.org/auth\">Travis CI에 회원가입</a>한 뒤에 <a href=\"https://circleci.com/add-projects\">프로젝트를 추가</a>합니다.\n빌드를 실행하려면 레파지토리에 새로운 커밋이 푸시되어야 합니다.</p>\n<ul>\n<li>더 자세한 내용은 <a href=\"https://docs.travis-ci.com/\">Travis CI 문서</a>를 참고하세요.</li>\n</ul>\n<!--\n### Configure CLI for CI testing in Chrome\n-->\n<h3 id=\"ci-환경에서-chrome으로-테스트하기\">CI 환경에서 Chrome으로 테스트하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#ci-환경에서-chrome으로-테스트하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nWhen the CLI commands `ng test` and `ng e2e` are generally running the CI tests in your environment, you might still need to adjust your configuration to run the Chrome browser tests.\n\nThere are configuration files for both the [Karma JavaScript test runner](https://karma-runner.github.io/latest/config/configuration-file.html) \nand [Protractor](https://www.protractortest.org/#/api-overview) end-to-end testing tool, \nwhich  you must adjust to start Chrome without sandboxing.\n\nWe'll be using [Headless Chrome](https://developers.google.com/web/updates/2017/04/headless-chrome#cli) in these examples.\n\n* In the Karma configuration file, `karma.conf.js`, add a custom launcher called ChromeHeadlessCI below browsers:\n-->\n<p>로컬 개발환경에서 Angular CLI로 <code>ng test</code> 명령이나 <code>ng e2e</code> 명령을 실행하면 Chrome 브라우저가 실행되고 이 브라우저에서 테스트가 실행됩니다.</p>\n<p>이런 환경을 구성하려면 <a href=\"https://karma-runner.github.io/latest/config/configuration-file.html\">Karma JavaScript 테스트 러너</a>와 e2e 테스트 툴인 <a href=\"https://www.protractortest.org/#/api-overview\">Protractor</a>가 실행될 환경이 모두 설정되어야 하며, Angular CLI로 생성한 프로젝트에는 이 환경은 자동으로 구성되어 있습니다.\n하지만 CI 환경에서는 Chrome 브라우저를 직접 실행하지 않고 화면과 샌드박스 기능 없이 사용하는 것이 더 좋습니다.</p>\n<p>이번 섹션에서는 <a href=\"https://developers.google.com/web/updates/2017/04/headless-chrome#cli\">Headless Chrome</a>을 사용하는 방법에 대해 알아봅시다.</p>\n<ul>\n<li>Karma 환경설정 파일 <code>karma.conf.js</code>에 커스텀 런처를 ChromeHeadlessCI를 추가합니다:</li>\n</ul>\n<code-example>\nbrowsers: ['Chrome'],\ncustomLaunchers: {\n  ChromeHeadlessCI: {\n    base: 'ChromeHeadless',\n    flags: ['--no-sandbox']\n  }\n},\n</code-example>\n<!--\n* In the root folder of your e2e tests project, create a new file named `protractor-ci.conf.js`. This new file extends the original `protractor.conf.js`.\n-->\n<ul>\n<li>e2e 테스트 프로젝트의 최상위 폴더에 <code>protractor-ci.conf.js</code> 파일을 생성합니다. 이 파일은 기존에 존재하는 <code>protractor.conf.js</code> 파일을 확장하는 용도로 사용합니다.</li>\n</ul>\n<code-example>\nconst <a href=\"api/router/Router#config\" class=\"code-anchor\">config</a> = require('./protractor.conf').config;\n\nconfig.capabilities = {\n  browserName: 'chrome',\n  chromeOptions: {\n    args: ['--headless', '--no-sandbox']\n  }\n};\n\nexports.config = <a href=\"api/router/Router#config\" class=\"code-anchor\">config</a>;\n</code-example>\n<!--\nNow you can run the following commands to use the `--no-sandbox` flag:\n-->\n<p>그러면 아래 명령들은 <code>--no-sandbox</code> 플래그가 지정된 채로 실행됩니다.</p>\n<code-example language=\"sh\" class=\"code-shell\">\n  ng test -- --no-watch --no-progress --browsers=ChromeHeadlessCI\n  ng e2e -- --protractor-config=e2e/protractor-ci.conf.js\n</code-example>\n<div class=\"alert is-helpful\">\n   <!--\n   **Note:** Right now, you'll also want to include the `--disable-gpu` flag if you're running on Windows. See [crbug.com/737678](https://crbug.com/737678).\n   -->\n<p>   <strong>참고:</strong> 개발 환경이 Windows라면 <code>--disable-gpu</code> 플래그를 사용하는 것이 나을 수 있습니다. 자세한 내용은 <a href=\"https://crbug.com/737678\">이 링크</a>를 참고하세요.</p>\n</div>\n<a id=\"code-coverage\"></a>\n<!--\n## Enable code coverage reports\n-->\n<h2 id=\"코드-커버리지-리포트-활성화하기\">코드 커버리지 리포트 활성화하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#코드-커버리지-리포트-활성화하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe CLI can run unit tests and create code coverage reports. \nCode coverage reports show you  any parts of our code base that may not be properly tested by your unit tests.\n\nTo generate a coverage report run the following command in the root of your project.\n-->\n<p>Angular CLI로 유닛 테스트를 실행하면서 코드 커버리지 리포트를 생성할 수 있습니다.\n코드 커버리지 리포트를 확인하면 유닛 테스트가 얼마나 충실하게 작성되었는지 확인할 수 있습니다.</p>\n<p>커버리지 리포트를 생성하려면 프로젝트를 테스트할 때 다음과 같이 실행하면 됩니다.</p>\n<code-example language=\"sh\" class=\"code-shell\">\n  ng test --no-watch --code-coverage\n</code-example>\n<!--\nWhen  the tests are complete, the command creates a new `/coverage` folder in the project. Open the `index.html` file to see a report with your source code and code coverage values.\n\nIf you want to create code-coverage reports every time you test, you can set the following option in the CLI configuration file, `angular.json`:\n-->\n<p>이제 테스트가 끝나면 프로젝트에 <code>/coverage</code> 폴더가 생성됩니다.\n이 폴더에 있는 <code>index.html</code> 파일을 확인하면 소스 코드가 분석된 내용과 코드 커버리지를 확인할 수 있습니다.</p>\n<p>그리고 애플리케이션을 테스트를 할때마다 코드 커버리지 리포트를 생성하려면 Angular CLI 설정 파일 <code>angular.json</code>를 다음과 같이 수정하면 됩니다:</p>\n<code-example>\n  \"test\": {\n    \"options\": {\n      \"codeCoverage\": true\n    }\n  }\n</code-example>\n<!--\n### Code coverage enforcement\n-->\n<h3 id=\"코드-커버리지-강제하기\">코드 커버리지 강제하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#코드-커버리지-강제하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe code coverage percentages let you estimate how much of your code is tested.  \nIf your team decides on a set minimum amount to be unit tested, you can enforce this minimum with the Angular CLI. \n\nFor example, suppose you want the code base to have a minimum of 80% code coverage. \nTo enable this, open the [Karma](https://karma-runner.github.io) test platform configuration file, `karma.conf.js`, and add the following in the `coverageIstanbulReporter:` key.\n-->\n<p>코드 커버리지 퍼센트를 확인하면 프로젝트 코드가 얼마나 충실하게 테스트되는지 확인할 수 있습니다.\n이 때 팀에서 유닛 테스트하기로 정한 최소한의 비율이 있다면, 이 비율을 강제하도록 Angular CLI를 설정할 수 있습니다.</p>\n<p>예를 들어 최소한 80% 이상의 코드가 테스트 대상이 되어야 한다고 합시다.\n그러면 <a href=\"https://karma-runner.github.io\">Karma</a> 설정 파일 <code>karma.conf.js</code> 파일을 열어서 <code>coverageIstanbulReporter</code> 키에 선언된 내용을 다음과 같이 수정하면 됩니다.</p>\n<code-example>\ncoverageIstanbulReporter: {\n  reports: [ 'html', 'lcovonly' ],\n  fixWebpackSourcePaths: true,\n  thresholds: {\n    statements: 80,\n    lines: 80,\n    branches: 80,\n    functions: 80\n  }\n}\n</code-example>\n<!--\nThe `thresholds` property causes the tool to enforce a minimum of 80% code coverage when the unit tests are run in the project.\n-->\n<p>이제 <code>thresholds</code> 프로퍼티를 추가했기 때문에 이 프로젝트에서 유닛테스트를 실행할 때 코드 커버리지는8 0% 이상이 되어야 합니다.</p>\n<!--\n## Service Tests\n-->\n<h2 id=\"서비스-테스트하기\">서비스 테스트하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#서비스-테스트하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nServices are often the easiest files to unit test.\nHere are some synchronous and asynchronous unit tests of the `ValueService`\nwritten without assistance from Angular testing utilities.\n-->\n<p>서비스는 Angular 구성요소 중에서 유닛 테스트하기 가장 쉬운 구성요소입니다.\n이번 섹션에서는 Angular 테스트 유틸리티를 활용해서 <code>ValueService</code>를 동기적으로, 비동기적으로 테스트하는 방법에 대해 소개합니다.</p>\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"ValueService\" header=\"app/demo/demo.spec.ts\">\n// Angular가 제공하는 테스트 유틸리티를 사용하지 않고 Jasmine을 그대로 사용합니다.\ndescribe('ValueService', () => {\n  let service: ValueService;\n  beforeEach(() => { service = new ValueService(); });\n\n  it('#getValue should return real value', () => {\n    expect(service.getValue()).toBe('real value');\n  });\n\n  it('#getObservableValue should return value from observable',\n    (<a href=\"api/core/ApplicationInitStatus#done\" class=\"code-anchor\">done</a>: DoneFn) => {\n    service.getObservableValue().subscribe(value => {\n      expect(value).toBe('observable value');\n      <a href=\"api/core/ApplicationInitStatus#done\" class=\"code-anchor\">done</a>();\n    });\n  });\n\n  it('#getPromiseValue should return value from <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> promise',\n    (<a href=\"api/core/ApplicationInitStatus#done\" class=\"code-anchor\">done</a>: DoneFn) => {\n    service.getPromiseValue().then(value => {\n      expect(value).toBe('promise value');\n      <a href=\"api/core/ApplicationInitStatus#done\" class=\"code-anchor\">done</a>();\n    });\n  });\n});\n\n</code-example>\n<a id=\"services-with-dependencies\"></a>\n<!--\n#### Services with dependencies\n-->\n<h4 id=\"의존성-객체가-존재하는-서비스\">의존성 객체가 존재하는 서비스<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#의존성-객체가-존재하는-서비스\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nServices often depend on other services that Angular injects into the constructor.\nIn many cases, it easy to create and _inject_ these dependencies by hand while\ncalling the service's constructor.\n\nThe `MasterService` is a simple example:\n-->\n<p>서비스는 생성자로 다른 서비스를 의존성으로 주입받을 수 있습니다.\n의존성 객체가 있는 서비스를 간단하게 생성하려면 의존성 객체를 직접 생성한 후에 서비스 클래스에 <code>new</code> 키워드를 사용할 때 인자로 전달하면 됩니다.</p>\n<p><code>MasterService</code>의 경우를 봅시다:</p>\n<code-example path=\"testing/src/app/demo/demo.ts\" region=\"MasterService\" header=\"app/demo/demo.ts\" linenums=\"false\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class MasterService {\n  constructor(private valueService: ValueService) { }\n  getValue() { return this.valueService.getValue(); }\n}\n\n</code-example>\n<!--\n`MasterService` delegates its only method, `getValue`, to the injected `ValueService`.\n\nHere are several ways to test it.\n-->\n<p><code>MasterService</code>에는 <code>getValue</code> 메소드만 정의되어 있으며, 이 서비스는 <code>ValueService</code>를 의존성으로 주입받습니다.</p>\n<p>그러면 <code>MasterService</code>를 다음과 같이 다양하게 테스트할 수 있습니다.</p>\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"MasterService\" header=\"app/demo/demo.spec.ts\">\ndescribe('MasterService without Angular testing support', () => {\n  let masterService: MasterService;\n\n  it('#getValue should return real value from the real service', () => {\n    masterService = new MasterService(new ValueService());\n    expect(masterService.getValue()).toBe('real value');\n  });\n\n  it('#getValue should return faked value from <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> fakeService', () => {\n    masterService = new MasterService(new FakeValueService());\n    expect(masterService.getValue()).toBe('faked service value');\n  });\n\n  it('#getValue should return faked value from <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> fake object', () => {\n    const fake =  { getValue: () => 'fake value' };\n    masterService = new MasterService(fake as ValueService);\n    expect(masterService.getValue()).toBe('fake value');\n  });\n\n  it('#getValue should return stubbed value from <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> spy', () => {\n    // `getValue` 메소드가 정의된 스파이 객체를 정의합니다.\n    const valueServiceSpy =\n      jasmine.createSpyObj('ValueService', ['getValue']);\n\n    // `getValue` 스파이 메소드가 반환할 값을 정의합니다.\n    const stubValue = 'stub value';\n    valueServiceSpy.getValue.and.returnValue(stubValue);\n\n    masterService = new MasterService(valueServiceSpy);\n\n    expect(masterService.getValue())\n      .toBe(stubValue, 'service returned stub value');\n    expect(valueServiceSpy.getValue.calls.count())\n      .toBe(1, 'spy method was called once');\n    expect(valueServiceSpy.getValue.calls.mostRecent().returnValue)\n      .toBe(stubValue);\n  });\n});\n\n</code-example>\n<!--\nThe first test creates a `ValueService` with `new` and passes it to the `MasterService` constructor.\n\nHowever, injecting the real service rarely works well as most dependent services are difficult to create and control.\n\nInstead you can mock the dependency, use a dummy value, or create a\n[spy](https://jasmine.github.io/2.0/introduction.html#section-Spies)\non the pertinent service method.\n-->\n<p>첫번째 테스트에서는 <code>new</code> 키워드를 사용해서 <code>ValueService</code>의 인스턴스를 직접 생성하고, 이 인스턴스를 <code>MasterService</code>의 생성자로 전달합니다.</p>\n<p>그런데 실제 서비스 클래스를 의존성으로 주입하면, 이 클래스가 실제로 어떤 동작을 할지 제어하기 힘들기 때문에  테스트가 제대로 동작하지 않을 가능성이 더 높아집니다.</p>\n<p>그렇다면 실제 서비스 대신 더미 객체나 <a href=\"https://jasmine.github.io/2.0/introduction.html#section-Spies\">스파이(spy)</a>를 활용하는 것이 더 간편합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nPrefer spies as they are usually the easiest way to mock services.\n-->\n<p>서비스를 모킹(mocking)하는 방법 중 간단한 방법은 스파이를 활용하는 것입니다.\n스파이를 적극적으로 활용하세요.</p>\n</div>\n<!--\nThese standard testing techniques are great for unit testing services in isolation.\n\nHowever, you almost always inject service into application classes using Angular\ndependency injection and you should have tests that reflect that usage pattern.\nAngular testing utilities make it easy to investigate how injected services behave.\n-->\n<p>이렇게 작성하면 테스트하려는 서비스만 따로 분리할 수 있기 때문에 테스트하기 편합니다.</p>\n<p>하지만 의존성 관계가 복잡하게 엮여 있거나 실제 사용하는 패턴으로 테스트를 실행해야 한다면 조금 다른 방법이 필요합니다.\n이런 상황에서 활용할 수 있는 Angular 테스트 기능에 대해 알아봅시다.</p>\n<!--\n#### Testing services with the _TestBed_\n-->\n<h4 id=\"testbed-로-서비스-테스트하기\"><em>TestBed</em> 로 서비스 테스트하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#testbed-로-서비스-테스트하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nYour app relies on Angular [dependency injection (DI)](guide/dependency-injection)\nto create services.\nWhen a service has a dependent service, DI finds or creates that dependent service.\nAnd if that dependent service has its own dependencies, DI finds-or-creates them as well.\n\nAs service _consumer_, you don't worry about any of this.\nYou don't worry about the order of constructor arguments or how they're created.\n\nAs a service _tester_, you must at least think about the first level of service dependencies\nbut you _can_ let Angular DI do the service creation and deal with constructor argument order\nwhen you use the `TestBed` testing utility to provide and create services.\n-->\n<p>서비스의 인스턴스를 생성할 때는 Angular가 제공하는 <a href=\"guide/dependency-injection\">의존성 주입(Dependency Injection, DI)</a> 시스템을 활용할 수도 있습니다.\n서비스에 의존성으로 주입될 서비스가 있다면, 이 의존성 객체의 인스턴스를 찾는 역할을 DI에 맡기는 방식입니다.\n의존성으로 주입되는 서비스에 또다른 의존성이 필요하다면 이 의존성 객체를 찾는 것도 DI가 처리합니다.</p>\n<p>개발자는 테스트할 서비스만 신경쓰면 됩니다.\n의존성 객체를 어떻게 생성하는지, 생성자에 전달하는 순서는 어떻게 되는지 신경쓸 필요가 없습니다.</p>\n<p>서비스를 테스트하는 입장에서도 테스트할 서비스 하나만 생각하면 됩니다.\n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>를 활용하면 해당 서비스에 연결된 의존성 관계는 모두 Angular DI가 처리합니다.</p>\n<a id=\"testbed\"></a>\n<h4 id=\"angular-testbed\">Angular <em>TestBed</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#angular-testbed\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe `TestBed` is the most important of the Angular testing utilities.\nThe `TestBed` creates a dynamically-constructed Angular _test_ module that emulates\nan Angular [@NgModule](guide/ngmodules).\n\nThe `TestBed.configureTestingModule()` method takes a metadata object that can have most of the properties of an [@NgModule](guide/ngmodules).\n\nTo test a service, you set the `providers` metadata property with an\narray of the services that you'll test or mock.\n-->\n<p><code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>는 Angular가 제공하는 테스트 유틸리티 중 가장 중요한 객체입니다.\n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>는 Angular에서 <a href=\"guide/ngmodules\">@NgModule</a> 역할을 하는 <em>테스트</em> 모듈을 동적으로 생성합니다.</p>\n<p><code>TestBed.configureTestingModule()</code> 메소드는 메타데이터 객체를 인자로 받는데, 메타데이터는 <a href=\"guide/ngmodules\">@NgModule</a>에 사용하는 프로퍼티를 거의 대부분 지원합니다.</p>\n<p>그래서 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>에 <code>providers</code> 메타데이터 프로퍼티를 지정했던 것처럼 <code>TestBed.configureTestingModule()</code> 메소드에도 <code>providers</code> 프로퍼티를 지정할 수 있습니다.</p>\n<!--\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"value-service-before-each\" header=\"app/demo/demo.testbed.spec.ts (provide ValueService in beforeEach\">\nlet service: ValueService;\n\nbeforeEach(() =&gt; {\n  TestBed.configureTestingModule({ providers: [ValueService] });\n});\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"value-service-before-each\" header=\"app/demo/demo.testbed.spec.ts (beforeEach()에서 ValueService 준비하기)\">\nlet service: ValueService;\n\nbeforeEach(() => {\n  TestBed.configureTestingModule({ providers: [ValueService] });\n});\n\n</code-example>\n<!--\nThen inject it inside a test by calling `TestBed.get()` with the service class as the argument.\n-->\n<p>그리고 <code>TestBed.get()</code> 함수를 실행하면서 인자로 서비스 클래스를 전달하면 서비스 클래스의 인스턴스를 참조할 수 있습니다.</p>\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"value-service-inject-it\">\nit('should use ValueService', () => {\n  service = TestBed.get(ValueService);\n  expect(service.getValue()).toBe('real value');\n});\n\n</code-example>\n<!--\nOr inside the `beforeEach()` if you prefer to inject the service as part of your setup.\n-->\n<p>아니면 <code>beforeEach()</code> 안쪽에서 서비스 객체의 인스턴스를 변수에 할당해 둘 수도 있습니다.</p>\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"value-service-inject-before-each\">\nbeforeEach(() => {\n  TestBed.configureTestingModule({ providers: [ValueService] });\n  service = TestBed.get(ValueService);\n});\n\n</code-example>\n<!--\nWhen testing a service with a dependency, provide the mock in the `providers` array.\n\nIn the following example, the mock is a spy object.\n-->\n<p>서비스에 의존성으로 주입되는 객체가 있다면, 이 객체의 목(mock) 역할을 하는 객체도 <code>providers</code> 배열에 지정할 수 있습니다.</p>\n<p>아래 예제에서는 Jasmine 스파이 객체가 목으로 사용되었습니다.</p>\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"master-service-before-each\" linenums=\"false\">\nlet masterService: MasterService;\nlet valueServiceSpy: jasmine.SpyObj&#x3C;ValueService>;\n\nbeforeEach(() => {\n  const spy = jasmine.createSpyObj('ValueService', ['getValue']);\n\n  TestBed.configureTestingModule({\n    // 테스트할 서비스와 의존성으로 사용될 목 객체를 등록합니다.\n    providers: [\n      MasterService,\n      { provide: ValueService, useValue: spy }\n    ]\n  });\n  // 서비스의 인스턴스와 목 객체의 인스턴스를 가져옵니다.\n  masterService = TestBed.get(MasterService);\n  valueServiceSpy = TestBed.get(ValueService);\n});\n\n</code-example>\n<!--\nThe test consumes that spy in the same way it did earlier.\n-->\n<p>이 목 객체는 이전에 살펴봤던 테스트 코드에서 다음과 같이 사용되었습니다.</p>\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"master-service-it\">\nit('#getValue should return stubbed value from <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> spy', () => {\n  const stubValue = 'stub value';\n  valueServiceSpy.getValue.and.returnValue(stubValue);\n\n  expect(masterService.getValue())\n    .toBe(stubValue, 'service returned stub value');\n  expect(valueServiceSpy.getValue.calls.count())\n    .toBe(1, 'spy method was called once');\n  expect(valueServiceSpy.getValue.calls.mostRecent().returnValue)\n    .toBe(stubValue);\n});\n\n</code-example>\n<a id=\"no-before-each\"></a>\n<!--\n#### Testing without _beforeEach()_\n-->\n<h4 id=\"beforeeach-없이-테스트하기\"><em>beforeEach()</em> 없이 테스트하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#beforeeach-없이-테스트하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nMost test suites in this guide call `beforeEach()` to set the preconditions for each `it()` test\nand rely on the `TestBed` to create classes and inject services.\n\nThere's another school of testing that never calls `beforeEach()` and prefers to create classes explicitly rather than use the `TestBed`.\n\nHere's how you might rewrite one of the `MasterService` tests in that style.\n\nBegin by putting re-usable, preparatory code in a _setup_ function instead of `beforeEach()`.\n-->\n<p>이 문서에서 다루는 테스트 스윗(test suites) 대부분은 테스트가 실제로 수행되는 <code>it()</code> 블럭에 필요한 준비를 하기 위해 <code>beforeEach()</code> 함수를 실행합니다. <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>를 사용해서 의존성 관계를 연결하고, 서비스 인스턴스를 생성해서 변수에 할당하는 것이 이런 과정에 해당됩니다.</p>\n<p>그런데 <code>beforeEach()</code>를 한번도 사용하지 않으면서 테스트 준비를 모두 끝낼 수 있는 방법도 있습니다.</p>\n<p>이번에는 새로운 방식으로 <code>MasterService</code>를 테스트 코드를 작성해 봅시다.</p>\n<p>먼저, <code>beforeEach()</code> 함수에서 하던 작업을 대신하는 <em>setup</em> 함수를 정의합니다.</p>\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"no-before-each-setup\" header=\"app/demo/demo.spec.ts (setup)\" linenums=\"false\">\nfunction setup() {\n  const valueServiceSpy =\n    jasmine.createSpyObj('ValueService', ['getValue']);\n  const stubValue = 'stub value';\n  const masterService = new MasterService(valueServiceSpy);\n\n  valueServiceSpy.getValue.and.returnValue(stubValue);\n  return { masterService, stubValue, valueServiceSpy };\n}\n\n</code-example>\n<!--\nThe `setup()` function returns an object literal\nwith the variables, such as `masterService`, that a test might reference.\nYou don't define _semi-global_ variables (e.g., `let masterService: MasterService`)\nin the body of the `describe()`.\n\nThen each test invokes `setup()` in its first line, before continuing\nwith steps that manipulate the test subject and assert expectations.\n-->\n<p><code>setup()</code> 함수는 객체 리터럴을 반환하는데, 이 객체에는 <code>masterService</code>와 같이 테스트에서 사용할 객체의 인스턴스가 들어 있습니다.\n그래서 <code>let masterService: MasterService</code>와 같이 <em>거의 전역으로 사용되는</em> 변수를 따로 선언할 필요가 없습니다.</p>\n<p>이제는 테스트 스펙 제일 첫 줄에서 <code>setup()</code> 함수를 실행한 후에 이 함수가 반환하는 객체를 사용해서 테스트 로직을 작성하면 됩니다.</p>\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"no-before-each-test\" linenums=\"false\">\nit('#getValue should return stubbed value from <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> spy', () => {\n  const { masterService, stubValue, valueServiceSpy } = setup();\n  expect(masterService.getValue())\n    .toBe(stubValue, 'service returned stub value');\n  expect(valueServiceSpy.getValue.calls.count())\n    .toBe(1, 'spy method was called once');\n  expect(valueServiceSpy.getValue.calls.mostRecent().returnValue)\n    .toBe(stubValue);\n});\n\n</code-example>\n<!--\nNotice how the test uses\n[_destructuring assignment_](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)\nto extract the setup variables that it needs.\n-->\n<p>객체 리터럴에서 필요한 객체를 추출해서 각 변수에 할당하는 문법은 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\"><em>구조 분해 할당(destructuring assignment)</em></a> 문법을 활용한 것입니다.</p>\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"no-before-each-setup-call\">\nconst { masterService, stubValue, valueServiceSpy } = setup();\n\n</code-example>\n<!--\nMany developers feel this approach is cleaner and more explicit than the\ntraditional `beforeEach()` style.\n\nAlthough this testing guide follows the tradition style and\nthe default [CLI schematics](https://github.com/angular/angular-cli)\ngenerate test files with `beforeEach()` and `TestBed`,\nfeel free to adopt _this alternative approach_ in your own projects.\n-->\n<p>전통적인 <code>beforeEach()</code> 스타일보다는 이 방식이 더 깔끔하고 좀 더 명확할 수 있습니다.</p>\n<p>이 문서에서는 기본 <a href=\"https://github.com/angular/angular-cli\">Angular CLI 스키매틱(schematics)</a>에 정의된 대로 <code>beforeEach()</code>와 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>를 활용하는 방식으로 테스트 스펙을 작성하지만, 프로젝트에 <em>이 새로운 방식</em> 을 적용해보는 것도 좋습니다.</p>\n<!--\n#### Testing HTTP services\n-->\n<h4 id=\"http-서비스-테스트하기\">HTTP 서비스 테스트하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#http-서비스-테스트하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nData services that make HTTP calls to remote servers typically inject and delegate\nto the Angular [`HttpClient`](guide/http) service for XHR calls.\n\nYou can test a data service with an injected `HttpClient` spy as you would\ntest any service with a dependency.\n-->\n<p>HTTP 요청을 보내는 데이터 서비스는 리모트 서버로 XHR 요청을 보내기 위해 Angular <a href=\"guide/http\"><code>HttpClient</code></a> 서비스를 의존성으로 주입받습니다.</p>\n<p>이런 데이터 서비스는 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 스파이를 활용해서 테스트할 수 있습니다.</p>\n<!--\n<code-example path=\"testing/src/app/model/hero.service.spec.ts\" region=\"test-with-spies\" header=\"app/model/hero.service.spec.ts (tests with spies)\">\nlet httpClientSpy: { get: jasmine.Spy };\nlet heroService: HeroService;\n\nbeforeEach(() =&gt; {\n  // TODO: 다른 스파이 메소드 추가하기\n  httpClientSpy = jasmine.createSpyObj(&#39;HttpClient&#39;, [&#39;get&#39;]);\n  heroService = new HeroService(&lt;any&gt; httpClientSpy);\n});\n\nit(&#39;should return expected heroes (HttpClient called once)&#39;, () =&gt; {\n  const expectedHeroes: Hero[] =\n    [{ id: 1, name: &#39;A&#39; }, { id: 2, name: &#39;B&#39; }];\n\n  httpClientSpy.get.and.returnValue(asyncData(expectedHeroes));\n\n  heroService.getHeroes().subscribe(\n    heroes =&gt; expect(heroes).toEqual(expectedHeroes, &#39;expected heroes&#39;),\n    fail\n  );\n  expect(httpClientSpy.get.calls.count()).toBe(1, &#39;one call&#39;);\n});\n\nit(&#39;should return an error when the server returns a 404&#39;, () =&gt; {\n  const errorResponse = new HttpErrorResponse({\n    error: &#39;test 404 error&#39;,\n    status: 404, statusText: &#39;Not Found&#39;\n  });\n\n  httpClientSpy.get.and.returnValue(asyncError(errorResponse));\n\n  heroService.getHeroes().subscribe(\n    heroes =&gt; fail(&#39;expected an error, not heroes&#39;),\n    error  =&gt; expect(error.message).toContain(&#39;test 404 error&#39;)\n  );\n});\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/model/hero.service.spec.ts\" region=\"test-with-spies\" header=\"app/model/hero.service.spec.ts (HttpClient 스파이로 테스트하기)\">\nlet httpClientSpy: { get: jasmine.Spy };\nlet heroService: HeroService;\n\nbeforeEach(() => {\n  // TODO: 다른 스파이 메소드 추가하기\n  httpClientSpy = jasmine.createSpyObj('<a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>', ['get']);\n  heroService = new HeroService(&#x3C;any> httpClientSpy);\n});\n\nit('should return expected heroes (<a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a> called once)', () => {\n  const expectedHeroes: Hero[] =\n    [{ id: 1, name: 'A' }, { id: 2, name: 'B' }];\n\n  httpClientSpy.get.and.returnValue(asyncData(expectedHeroes));\n\n  heroService.getHeroes().subscribe(\n    heroes => expect(heroes).toEqual(expectedHeroes, 'expected heroes'),\n    fail\n  );\n  expect(httpClientSpy.get.calls.count()).toBe(1, 'one call');\n});\n\nit('should return an error when the server returns <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> 404', () => {\n  const errorResponse = new <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a>({\n    error: 'test 404 error',\n    status: 404, statusText: 'Not Found'\n  });\n\n  httpClientSpy.get.and.returnValue(asyncError(errorResponse));\n\n  heroService.getHeroes().subscribe(\n    heroes => fail('expected an error, not heroes'),\n    error  => expect(error.message).toContain('test 404 error')\n  );\n});\n\n</code-example>\n<div class=\"alert is-important\">\n<!--\nThe `HeroService` methods return `Observables`. You must\n_subscribe_ to an observable to (a) cause it to execute and (b)\nassert that the method succeeds or fails.\n\nThe `subscribe()` method takes a success (`next`) and fail (`error`) callback.\nMake sure you provide _both_ callbacks so that you capture errors.\nNeglecting to do so produces an asynchronous uncaught observable error that\nthe test runner will likely attribute to a completely different test.\n-->\n<p><code>HeroService</code>에 정의한 메소드는 모두 <code>Observable</code> 타입을 반환합니다.\n그러면 이 옵저버블은 (a) 실행하기 위해서, 그리고 (b) 메소드가 정상적으로 실행되었는지, 실패했는지 확인하기 위해 반드시 <em>구독(subscribe)</em> 해야 합니다.</p>\n<p><code>subscribe()</code> 메소드는 성공했을 때 실행할 콜백(<code>next</code>)과 실패했을 때 실행할 콜백(<code>error</code>)을 인자로 받습니다.\n그래서 옵저버블에서 발생한 에러를 확인하려면 두 인자를 모두 지정해야 합니다.\n옵저버블은 비동기로 실행되기 때문에 이 옵저버블에서 발생하는 에러를 확인하지 않으면 전혀 다른 테스트 결과를 낼 수도 있습니다.</p>\n</div>\n<h4 id=\"httpclienttestingmodule\"><em>HttpClientTestingModule</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#httpclienttestingmodule\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nExtended interactions between a data service and the `HttpClient` can be complex\nand difficult to mock with spies.\n\nThe `HttpClientTestingModule` can make these testing scenarios more manageable.\n\nWhile the _code sample_ accompanying this guide demonstrates `HttpClientTestingModule`,\nthis page defers to the [Http guide](guide/http#testing-http-requests),\nwhich covers testing with the `HttpClientTestingModule` in detail.\n-->\n<p>데이터 서비스와 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>는 복잡하게 연결될 수 있기 때문에 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 역할을 대신하는 목 스파이를 새로 만드는 것은 쉬운 작업이 아닙니다.</p>\n<p>하지만 <code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code>을 활용하면 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>가 실행되는 과정을 좀 더 편하게 제어할 수 있어서 테스트 시나리오를 작성하기도 편합니다.</p>\n<p>다만, 이 문서에서 <code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code>의 내용을 다루기에는 그 내용이 너무 많기 때문에 이 내용을 자세하게 다루는 <a href=\"guide/http#http-%EC%9A%94%EC%B2%AD-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EA%B8%B0\">Http guide</a> 문서를 참고하세요.</p>\n<div class=\"alert is-helpful\">\n<!--\nThis guide's sample code also demonstrates testing of the _legacy_ `HttpModule`\nin `app/model/http-hero.service.spec.ts`.\n-->\n<p><em>이전 버전에서 제공하던</em> <code><a href=\"api/http/HttpModule\" class=\"code-anchor\">HttpModule</a></code>을 사용하는 예제 코드는 <code>app/<a href=\"api/forms/NgModel#model\" class=\"code-anchor\">model</a>/http-hero.service.spec.ts</code>에서 확인할 수 있습니다.</p>\n</div>\n<!--\n## Component Test Basics\n-->\n<h2 id=\"컴포넌트-테스트\">컴포넌트 테스트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#컴포넌트-테스트\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nA component, unlike all other parts of an Angular application,\ncombines an HTML template and a TypeScript class.\nThe component truly is the template and the class _working together_.\nand to adequately test a component, you should test that they work together\nas intended.\n\nSuch tests require creating the component's host element in the browser DOM,\nas Angular does, and investigating the component class's interaction with\nthe DOM as described by its template.\n\nThe Angular `TestBed` facilitates this kind of testing as you'll see in the sections below.\nBut in many cases, _testing the component class alone_, without DOM involvement,\ncan validate much of the component's behavior in an easier, more obvious way.\n-->\n<p>다른 Angular 구성요소와는 다르게, 컴포넌트는 HTML 템플릿과 TypeScript 클래스가 조합되어 정의됩니다.\n그리고 컴포넌트가 실행될 때도 템플릿과 클래스가 <em>상호작용 하면서</em> 동작합니다.\n그래서 컴포넌트를 테스트하려면 템플릿과 TypeScript 클래스 코드가 서로 연동된다는 것을 염두에 두어야 합니다.</p>\n<p>컴포넌트가 위치할 호스트 엘리먼트는 테스트 환경의 DOM 트리에도 생성되어야 합니다.\n그래야 컴포넌트 클래스는 컴포넌트 템플릿이 렌더링되는 DOM과 상호작용할 수 있습니다.</p>\n<p>이 작업들은 모두 Angular <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>가 모두 처리하기 때문에 컴포넌트를 테스트하는 것이 그리 어려운 것만은 아닙니다.\n하지만 일반적으로는 DOM을 신경쓰지 않고 <em>컴포넌트 클래스만 테스트하는 경우</em> 가 많습니다.\n컴포넌트는 동작 위주로 테스트하는 것이 더 간단하고, 테스트 스펙을 정의하기도 명확합니다.</p>\n<!--\n### Component class testing\n-->\n<h3 id=\"컴포넌트-클래스-테스트\">컴포넌트 클래스 테스트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#컴포넌트-클래스-테스트\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nTest a component class on its own as you would test a service class.\n\nConsider this `LightswitchComponent` which toggles a light on and off\n(represented by an on-screen message) when the user clicks the button.\n-->\n<p>컴포넌트 클래스를 테스트하는 것은 서비스 클래스를 테스트하는 것과 비슷합니다.</p>\n<p>사용자가 버튼을 누르면 조명을 켜고 끄는 <code>LightswitchComponent</code>가 있다고 합시다. 조명이 켜졌는지 여부는 화면에 텍스트로 표시됩니다.</p>\n<code-example path=\"testing/src/app/demo/demo.ts\" region=\"LightswitchComp\" header=\"app/demo/demo.ts (LightswitchComp)\" linenums=\"false\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'lightswitch-comp',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n    &#x3C;button (click)=\"clicked()\">Click me!&#x3C;/button>\n    &#x3C;span>{{<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>}}&#x3C;/span>`\n})\nexport class LightswitchComponent {\n  isOn = false;\n  clicked() { this.isOn = !this.isOn; }\n  get <a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>() { return `The light is ${this.isOn ? 'On' : 'Off'}`; }\n}\n\n</code-example>\n<!--\nYou might decide only to test that the `clicked()` method\ntoggles the light's _on/off_ state and sets the message appropriately.\n\nThis component class has no dependencies.\nTo test a service with no dependencies, you create it with `new`, poke at its API,\nand assert expectations on its public state.\nDo the same with the component class.\n-->\n<p>이 컴포넌트를 테스트한다면 조명을 <em>켜거나/끄는</em> 동작을 하는 <code>clicked()</code> 메소드를 테스트하는 것이 가장 합리적입니다.\n조명이 켜진 상태는 화면에 표시된 메시지로 체크하면 됩니다.</p>\n<p>이 클래스에는 의존성으로 주입되는 객체가 없습니다.\n그러면 의존성이 없는 서비스를 테스트했던 것과 마찬가지로, <code>new</code> 키워드로 컴포넌트 인스턴스를 생성하고, API를 직접 실행한 후에, public 프로퍼티를 검사하면 됩니다.</p>\n<!--\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"Lightswitch\" header=\"app/demo/demo.spec.ts (Lightswitch tests)\" linenums=\"false\">\ndescribe(&#39;LightswitchComp&#39;, () =&gt; {\n  it(&#39;#clicked() should toggle #isOn&#39;, () =&gt; {\n    const comp = new LightswitchComponent();\n    expect(comp.isOn).toBe(false, &#39;off at first&#39;);\n    comp.clicked();\n    expect(comp.isOn).toBe(true, &#39;on after click&#39;);\n    comp.clicked();\n    expect(comp.isOn).toBe(false, &#39;off after second click&#39;);\n  });\n\n  it(&#39;#clicked() should set #message to &quot;is on&quot;&#39;, () =&gt; {\n    const comp = new LightswitchComponent();\n    expect(comp.message).toMatch(/is off/i, &#39;off at first&#39;);\n    comp.clicked();\n    expect(comp.message).toMatch(/is on/i, &#39;on after clicked&#39;);\n  });\n});\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"Lightswitch\" header=\"app/demo/demo.spec.ts (Lightswitch 테스트하기)\" linenums=\"false\">\ndescribe('LightswitchComp', () => {\n  it('#clicked() should toggle #isOn', () => {\n    const comp = new LightswitchComponent();\n    expect(comp.isOn).toBe(false, 'off at first');\n    comp.clicked();\n    expect(comp.isOn).toBe(true, 'on after click');\n    comp.clicked();\n    expect(comp.isOn).toBe(false, 'off after second click');\n  });\n\n  it('#clicked() should set #<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a> to \"is on\"', () => {\n    const comp = new LightswitchComponent();\n    expect(comp.message).toMatch(/is off/i, 'off at first');\n    comp.clicked();\n    expect(comp.message).toMatch(/is on/i, 'on after clicked');\n  });\n});\n\n</code-example>\n<!--\nHere is the `DashboardHeroComponent` from the _Tour of Heroes_ tutorial.\n-->\n<p><em>히어로들의 여행</em> 튜토리얼에서 다룬 <code>DashboardHeroComponent</code>의 클래스 코드는 이렇게 정의되어 있습니다.</p>\n<!--\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.ts\" region=\"class\" header=\"app/dashboard/dashboard-hero.component.ts (component)\" linenums=\"false\">\nexport class DashboardHeroComponent {\n  @Input() hero: Hero;\n  @Output() selected = new EventEmitter&lt;Hero&gt;();\n  click() { this.selected.emit(this.hero); }\n}\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.ts\" region=\"class\" header=\"app/dashboard/dashboard-hero.component.ts (컴포넌트 코드)\" linenums=\"false\">\nexport class DashboardHeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() selected = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;Hero>();\n  click() { this.selected.emit(this.hero); }\n}\n\n</code-example>\n<!--\nIt appears within the template of a parent component,\nwhich binds a _hero_ to the `@Input` property and\nlistens for an event raised through the _selected_ `@Output` property.\n\nYou can test that the class code works without creating the `DashboardHeroComponent`\nor its parent component.\n-->\n<p>이 컴포넌트에는 부모 컴포넌트의 템플릿에서 받는 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> <em>hero</em> 프로퍼티가 존재하고, 부모 컴포넌트로 이벤트를 보내는 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code> <em>selected</em> 프로퍼티도 존재합니다.</p>\n<p>이 컴포넌트는 부모 컴포넌트를 생성하지 않아도 직접 테스트할 수 있습니다.</p>\n<!--\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"class-only\" header=\"app/dashboard/dashboard-hero.component.spec.ts (class tests)\" linenums=\"false\">\nit(&#39;raises the selected event when clicked&#39;, () =&gt; {\n  const comp = new DashboardHeroComponent();\n  const hero: Hero = { id: 42, name: &#39;Test&#39; };\n  comp.hero = hero;\n\n  comp.selected.subscribe(selectedHero =&gt; expect(selectedHero).toBe(hero));\n  comp.click();\n});\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"class-only\" header=\"app/dashboard/dashboard-hero.component.spec.ts (class 테스트하기)\" linenums=\"false\">\nit('raises the selected event when clicked', () => {\n  const comp = new DashboardHeroComponent();\n  const hero: Hero = { id: 42, name: 'Test' };\n  comp.hero = hero;\n\n  comp.selected.subscribe(selectedHero => expect(selectedHero).toBe(hero));\n  comp.click();\n});\n\n</code-example>\n<!--\nWhen a component has dependencies, you may wish to use the `TestBed` to both\ncreate the component and its dependencies.\n\nThe following `WelcomeComponent` depends on the `UserService` to know the name of the user to greet.\n-->\n<p>그리고 컴포넌트에 주입되어야 하는 의존성이 있다면, <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>를 사용해서 이 컴포넌트의 인스턴스를 생성할 수 있습니다.</p>\n<p>아래 예제로 다루는 <code>WelcomeComponent</code>는 사용자의 이름을 참조하기 위해 <code>UserService</code>가 의존성으로 주입되어야 합니다.</p>\n<code-example path=\"testing/src/app/welcome/welcome.component.ts\" region=\"class\" header=\"app/welcome/welcome.component.ts\" linenums=\"false\">\nexport class WelcomeComponent  implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  welcome: string;\n  constructor(private userService: UserService) { }\n\n  ngOnInit(): void {\n    this.welcome = this.userService.isLoggedIn ?\n      'Welcome, ' + this.userService.user.name : 'Please <a href=\"api/animations/browser/testing/MockAnimationDriver#log\" class=\"code-anchor\">log</a> in.';\n  }\n}\n\n</code-example>\n<!--\nYou might start by creating a mock of the `UserService` that meets the minimum needs of this component.\n-->\n<p>이 경우에는 먼저 <code>UserService</code> 코드 중 컴포넌트에 필요한 메소드만 최소한으로 구현한 목 클래스를 만드는 것부터 시작합니다.</p>\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"mock-user-service\" header=\"app/welcome/welcome.component.spec.ts (MockUserService)\" linenums=\"false\">\nclass MockUserService {\n  isLoggedIn = true;\n  user = { name: 'Test <a href=\"api/common/http/HttpEventType#User\" class=\"code-anchor\">User</a>'};\n};\n\n</code-example>\n<!--\nThen provide and inject _both the_ **component** _and the service_ in the `TestBed` configuration.\n-->\n<p>그리고 이렇게 정의한 컴포넌트를 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 환경에 등록합니다. 이 때 <em><strong>컴포넌트</strong>도</em> 함께 등록합니다.</p>\n<!--\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"class-only-before-each\" header=\"app/welcome/welcome.component.spec.ts (class-only setup)\" linenums=\"false\">\nbeforeEach(() =&gt; {\n  TestBed.configureTestingModule({\n    // 테스트할 컴포넌트와 의존성으로 주입될 서비스를 프로바이더에 등록합니다.\n    providers: [\n      WelcomeComponent,\n      { provide: UserService, useClass: MockUserService }\n    ]\n  });\n  // TestBed를 사용해서 컴포넌트 인스턴스와 서비스 인스턴스를 참조합니다.\n  comp = TestBed.get(WelcomeComponent);\n  userService = TestBed.get(UserService);\n});\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"class-only-before-each\" header=\"app/welcome/welcome.component.spec.ts (TestBed 설정)\" linenums=\"false\">\nbeforeEach(() => {\n  TestBed.configureTestingModule({\n    // 테스트할 컴포넌트와 의존성으로 주입될 서비스를 프로바이더에 등록합니다.\n    providers: [\n      WelcomeComponent,\n      { provide: UserService, useClass: MockUserService }\n    ]\n  });\n  // <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>를 사용해서 컴포넌트 인스턴스와 서비스 인스턴스를 참조합니다.\n  comp = TestBed.get(WelcomeComponent);\n  userService = TestBed.get(UserService);\n});\n\n</code-example>\n<!--\nThen exercise the component class, remembering to call the [lifecycle hook methods](guide/lifecycle-hooks) as Angular does when running the app.\n-->\n<p>그러면 테스트 스펙을 정의할 때 Angular 앱이 실행되는 것처럼 <a href=\"guide/lifecycle-hooks\">라이프싸이클 후킹 함수</a>를 활용할 수 있습니다.</p>\n<!--\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"class-only-tests\" header=\"app/welcome/welcome.component.spec.ts (class-only tests)\" linenums=\"false\">\nit(&#39;should not have welcome message after construction&#39;, () =&gt; {\n  expect(comp.welcome).toBeUndefined();\n});\n\nit(&#39;should welcome logged in user after Angular calls ngOnInit&#39;, () =&gt; {\n  comp.ngOnInit();\n  expect(comp.welcome).toContain(userService.user.name);\n});\n\nit(&#39;should ask user to log in if not logged in after ngOnInit&#39;, () =&gt; {\n  userService.isLoggedIn = false;\n  comp.ngOnInit();\n  expect(comp.welcome).not.toContain(userService.user.name);\n  expect(comp.welcome).toContain(&#39;log in&#39;);\n});\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"class-only-tests\" header=\"app/welcome/welcome.component.spec.ts (컴포넌트 클래스 테스트하기)\" linenums=\"false\">\nit('should not have welcome <a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a> after construction', () => {\n  expect(comp.welcome).toBeUndefined();\n});\n\nit('should welcome logged in user after Angular calls ngOnInit', () => {\n  comp.ngOnInit();\n  expect(comp.welcome).toContain(userService.user.name);\n});\n\nit('should ask user to <a href=\"api/animations/browser/testing/MockAnimationDriver#log\" class=\"code-anchor\">log</a> in if not logged in after ngOnInit', () => {\n  userService.isLoggedIn = false;\n  comp.ngOnInit();\n  expect(comp.welcome).not.toContain(userService.user.name);\n  expect(comp.welcome).toContain('<a href=\"api/animations/browser/testing/MockAnimationDriver#log\" class=\"code-anchor\">log</a> in');\n});\n\n</code-example>\n<!--\n### Component DOM testing\n-->\n<h3 id=\"컴포넌트-dom-테스트\">컴포넌트 DOM 테스트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#컴포넌트-dom-테스트\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nTesting the component _class_ is as easy as testing a service.\n\nBut a component is more than just its class.\nA component interacts with the DOM and with other components.\nThe _class-only_ tests can tell you about class behavior.\nThey cannot tell you if the component is going to render properly,\nrespond to user input and gestures, or integrate with its parent and child components.\n\nNone of the _class-only_ tests above can answer key questions about how the\ncomponents actually behave on screen.\n\n- Is `Lightswitch.clicked()` bound to anything such that the user can invoke it?\n- Is the `Lightswitch.message` displayed?\n- Can the user actually select the hero displayed by `DashboardHeroComponent`?\n- Is the hero name displayed as expected (i.e, in uppercase)?\n- Is the welcome message displayed by the template of `WelcomeComponent`?\n\nThese may not be troubling questions for the simple components illustrated above.\nBut many components have complex interactions with the DOM elements\ndescribed in their templates, causing HTML to appear and disappear as\nthe component state changes.\n\nTo answer these kinds of questions, you have to create the DOM elements associated\nwith the components, you must examine the DOM to confirm that component state\ndisplays properly at the appropriate times, and you must simulate user interaction\nwith the screen to determine whether those interactions cause the component to\nbehave as expected.\n\nTo write these kinds of test, you'll use additional features of the `TestBed`\nas well as other testing helpers.\n-->\n<p>컴포넌트 <em>클래스</em> 를 테스트하는 것은 서비스를 테스트하는 것만큼이나 쉽습니다.</p>\n<p>하지만 컴포넌트는 클래스로만 구성되는 것이 아닙니다.\n컴포넌트는 DOM에 존재하며 DOM에서 다른 컴포넌트와 상호작용할 수도 있습니다.\n그래서 <em>컴포넌트 클래스만</em> 테스트하면 이 클래스의 행동은 테스트할 수 있지만, 이 컴포넌트가 제대로 렌더링 되었는지, 사용자의 입력이나 제스처에 잘 반응하는지, 부모 컴포넌트나 자식 컴포넌트와 상호작용을 제대로 하는지는 확인할 수 없습니다.</p>\n<p>결국 컴포넌트의 클래스만 테스트하면 다음 물음에 대해 답할 수 없습니다.</p>\n<ul>\n<li>사용자가 컴포넌트에 있는 버튼을 클릭하면 <code>Lightswitch.clicked()</code> 함수는 제대로 실행될까?</li>\n<li><code>Lightswitch.message</code>는 화면에 제대로 표시될까?</li>\n<li>사용자가 <code>DashboardHeroComponent</code>에서 선택한 히어로 정보가 이 컴포넌트에도 표시될까?</li>\n<li>히어로의 이름은 정해둔 방식으로 표시될까?</li>\n<li><code>WelcomeComponent</code> 템플릿에는 환영 메시지가 제대로 표시될까?</li>\n</ul>\n<p>컴포넌트가 간단하다면 이런 내용을 신경쓰지 않아도 됩니다.\n하지만 일반적으로 컴포넌트 템플릿은 클래스 코드와 복잡한 과정으로 상호작용하기도 하고, 컴포넌트의 상태에 따라 일부 HTML 조각을 표시하지 않는 경우도 많습니다.</p>\n<p>그래서 컴포넌트를 제대로 테스트하려면 해당 컴포넌트와 관련된 DOM 엘리먼트를 구성해야 하며, 지정된 로직에 따라 DOM도 제대로 연동되는지 확인해야 합니다. 그리고 사용자가 화면에서 발생시키는 이벤트에 컴포넌트가 제대로 반응하는지도 확인해야 합니다.</p>\n<p>이 요구사항들은 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>가 제공하는 기능으로 모두 처리할 수 있습니다.</p>\n<!--\n#### CLI-generated tests\n-->\n<h4 id=\"angular-cli가-생성한-테스트-코드\">Angular CLI가 생성한 테스트 코드<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#angular-cli가-생성한-테스트-코드\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe CLI creates an initial test file for you by default when you ask it to\ngenerate a new component.\n\nFor example, the following CLI command generates a `BannerComponent` in the `app/banner` folder (with inline template and styles):\n-->\n<p>Angular CLI를 사용해서 컴포넌트를 생성하면 이 컴포넌트를 테스트하는 파일이 함께 생성됩니다.</p>\n<p>예를 들어 다음 명령을 실행하면 <code>app/banner</code> 폴더에 <code>BannerComponent</code> 컴포넌트 파일이 생성되는데, 인라인 옵션을 지정했기 때문에 템플릿과 스타일이 인라인으로 구성됩니다:</p>\n<code-example language=\"sh\" class=\"code-shell\">\nng generate component banner --inline-template --inline-style --module app\n</code-example>\n<!--\nIt also generates an initial test file for the component, `banner-external.component.spec.ts`, that looks like this:\n-->\n<p>Angular CLI는 이 컴포넌트를 생성하면서 다음 내용으로 <code>banner-external.component.spec.ts</code> 파일을 함께 생성합니다:</p>\n<!--\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v1\" header=\"app/banner/banner-external.component.spec.ts (initial)\" linenums=\"false\">\nimport { async, ComponentFixture, TestBed } from &#39;@angular/core/testing&#39;;\nimport { BannerComponent } from &#39;./banner.component&#39;;\n\ndescribe(&#39;BannerComponent&#39;, () =&gt; {\n  let component: BannerComponent;\n  let fixture: ComponentFixture&lt;BannerComponent&gt;;\n\n  beforeEach(async(() =&gt; {\n    TestBed.configureTestingModule({\n      declarations: [ BannerComponent ]\n    })\n    .compileComponents();\n  }));\n\n  beforeEach(() =&gt; {\n    fixture = TestBed.createComponent(BannerComponent);\n    component = fixture.componentInstance;\n    fixture.detectChanges();\n  });\n\n  it(&#39;should create&#39;, () =&gt; {\n    expect(component).toBeDefined();\n  });\n});\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v1\" header=\"app/banner/banner-external.component.spec.ts (기본 코드)\" linenums=\"false\">\nimport { <a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>, <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>, <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a> } from '@angular/core/testing';\nimport { BannerComponent } from './banner.component';\n\ndescribe('BannerComponent', () => {\n  let component: BannerComponent;\n  let fixture: <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>&#x3C;BannerComponent>;\n\n  beforeEach(<a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>(() => {\n    TestBed.configureTestingModule({\n      <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [ BannerComponent ]\n    })\n    .compileComponents();\n  }));\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(BannerComponent);\n    component = fixture.componentInstance;\n    fixture.detectChanges();\n  });\n\n  it('should create', () => {\n    expect(component).toBeDefined();\n  });\n});\n\n</code-example>\n<!--\n#### Reduce the setup\n-->\n<h4 id=\"간단하게-줄이기\">간단하게 줄이기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#간단하게-줄이기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nOnly the last three lines of this file actually test the component\nand all they do is assert that Angular can create the component.\n\nThe rest of the file is boilerplate setup code anticipating more advanced tests that _might_ become necessary if the component evolves into something substantial.\n\nYou'll learn about these advanced test features below.\nFor now, you can radically reduce this test file to a more manageable size:\n-->\n<p>그런데 컴포넌트가 제대로 생성되는지 확인하려면 이 테스트 코드 중에서 마지막 3줄만 필요합니다.</p>\n<p>그밖의 코드는 이후에 이 컴포넌트에 추가되는 기능을 테스트하기 위해 미리 준비해 둔 코드들입니다.</p>\n<p>컴포넌트를 테스트할 때 필요한 내용은 아래에서 자세하게 살펴볼 것입니다.\n지금은 지금 단계에서 꼭 필요한 내용만 남도록 간단하게 줄여봅시다:</p>\n<!--\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v2\" header=\"app/banner/banner-initial.component.spec.ts (minimal)\" linenums=\"false\">\ndescribe(&#39;BannerComponent (minimal)&#39;, () =&gt; {\n  it(&#39;should create&#39;, () =&gt; {\n    TestBed.configureTestingModule({\n      declarations: [ BannerComponent ]\n    });\n    const fixture = TestBed.createComponent(BannerComponent);\n    const component = fixture.componentInstance;\n    expect(component).toBeDefined();\n  });\n});\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v2\" header=\"app/banner/banner-initial.component.spec.ts (최소 코드)\" linenums=\"false\">\ndescribe('BannerComponent (minimal)', () => {\n  it('should create', () => {\n    TestBed.configureTestingModule({\n      <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [ BannerComponent ]\n    });\n    const fixture = TestBed.createComponent(BannerComponent);\n    const component = fixture.componentInstance;\n    expect(component).toBeDefined();\n  });\n});\n\n</code-example>\n<!--\nIn this example, the metadata object passed to `TestBed.configureTestingModule`\nsimply declares `BannerComponent`, the component to test.\n-->\n<p>이 예제에서 <code>TestBed.configureTestingModule</code>로 전달하는 메타데이터 객체에는 단순하게 <code>BannerComponent</code>를 선언하는 내용만 있습니다.</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"configureTestingModule\">\nTestBed.configureTestingModule({\n  <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [ BannerComponent ]\n});\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\nThere's no need to declare or import anything else.\nThe default test module is pre-configured with\nsomething like the `BrowserModule` from `@angular/platform-browser`.\n\nLater you'll call `TestBed.configureTestingModule()` with\nimports, providers, and more declarations to suit your testing needs.\nOptional `override` methods can further fine-tune aspects of the configuration.\n-->\n<p>컴포넌트가 제대로 생성되는지 확인하는 코드는 이것으로 충분합니다.\n테스트 모듈은 <code>@angular/platform-browser</code> 패키지가 제공하는 <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>을 활용하도록 자동으로 구성되기 때문에, 테스트는 이대로도 실행할 수 있습니다.</p>\n<p>나중에 테스트할 내용이 많아지면 <code>TestBed.configureTestingModule()</code> 메타데이터의 imports, providers, declarations 프로퍼티를 수정해서 사용하면 됩니다.\n그리고 테스트 환경을 좀 더 튜닝하려면 오버라이드 메소드를 활용할 수도 있습니다.</p>\n</div>\n<a id=\"create-component\"></a>\n<h4 id=\"createcomponent\"><em>createComponent()</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#createcomponent\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nAfter configuring `TestBed`, you call its `createComponent()` method.\n-->\n<p><code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>를 설정한 뒤에는 <code>createComponent()</code> 메소드를 실행합니다.</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"createComponent\">\nconst fixture = TestBed.createComponent(BannerComponent);\n\n</code-example>\n<!--\n`TestBed.createComponent()` creates an instance of the `BannerComponent`,\nadds a corresponding element to the test-runner DOM,\nand returns a [`ComponentFixture`](#component-fixture).\n-->\n<p><code>TestBed.createComponent()</code>를 실행하면 <code>BannerComponent</code>의 인스턴스를 생성하면서 이 컴포넌트의 템플릿을 테스트 러너의 DOM에 추가하고 <a href=\"guide/testing#component-fixture\"><code>ComponentFixture</code></a>를 반환합니다.</p>\n<div class=\"alert is-important\">\n<!--\nDo not re-configure `TestBed` after calling `createComponent`.\n\nThe `createComponent` method freezes the current `TestBed` definition,\nclosing it to further configuration.\n\nYou cannot call any more `TestBed` configuration methods, not `configureTestingModule()`,\nnor `get()`, nor any of the `override...` methods.\nIf you try, `TestBed` throws an error.\n-->\n<p><code>createComponent</code>를 실행한 뒤에 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 설정을 바꾸지 마세요.</p>\n<p><code>createComponent</code> 메소드는 이 메소드가 실행되는 시점에 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>에 설정된 내용으로 생성되며, 이후에 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 설정을 변경해도 변경된 내용이 반영되지 않습니다.</p>\n<p>그래서 <code>createComponent</code> 메소드를 실행한 후에는 <code>configureTestingModule()</code> 메소드를 다시 실행할 수 없으며, 반대로 <code>configureTestingModule()</code>를 실행하기 전에는 <code>get()</code>이나 <code>override...</code> 메소드를 실행할 수 없습니다.\n이렇게 실행하면 에러가 발생합니다.</p>\n</div>\n<a id=\"component-fixture\"></a>\n<h4 id=\"componentfixture\"><em>ComponentFixture</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#componentfixture\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe [ComponentFixture](api/core/testing/ComponentFixture) is a test harness for interacting with the created component and its corresponding element.\n\nAccess the component instance through the fixture and confirm it exists with a Jasmine expectation:\n-->\n<p><a href=\"api/core/testing/ComponentFixture\">ComponentFixture</a>는 컴포넌트와 이 컴포넌트의 엘리먼트를 테스트할 때 사용하는 객체입니다.</p>\n<p>이 객체를 참조하면 컴포넌트 인스턴스에 직접 접근할 수 있기 때문에, 다음과 같은 Jasmine 검증식을 작성할 수 있습니다:</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"componentInstance\">\nconst component = fixture.componentInstance;\nexpect(component).toBeDefined();\n\n</code-example>\n<h4 id=\"beforeeach\"><em>beforeEach()</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#beforeeach\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nYou will add more tests as this component evolves.\nRather than duplicate the `TestBed` configuration for each test,\nyou refactor to pull the setup into a Jasmine `beforeEach()` and some supporting variables:\n-->\n<p>컴포넌트에 기능이 추가될수록 컴포넌트를 테스트하는 코드도 점점 많아질 것입니다.\n그렇다면 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>를 설정하는 로직을 모든 테스트 스펙에 반복할 필요 없이, 이 내용을 Jasmine <code>beforeEach()</code>에 작성하는 것이 더 효율적입니다.</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v3\" linenums=\"false\">\ndescribe('BannerComponent (with beforeEach)', () => {\n  let component: BannerComponent;\n  let fixture: <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>&#x3C;BannerComponent>;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [ BannerComponent ]\n    });\n    fixture = TestBed.createComponent(BannerComponent);\n    component = fixture.componentInstance;\n  });\n\n  it('should create', () => {\n    expect(component).toBeDefined();\n  });\n});\n\n</code-example>\n<!--\nNow add a test that gets the component's element from `fixture.nativeElement` and\nlooks for the expected text.\n-->\n<p>그러면 테스트 스펙을 작성할 때 공통 로직을 생략하고 테스트에 꼭 필요한 내용만 작성할 수 있습니다.</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v4-test-2\">\nit('should contain \"banner works!\"', () => {\n  const bannerElement: HTMLElement = fixture.nativeElement;\n  expect(bannerElement.textContent).toContain('banner works!');\n});\n\n</code-example>\n<a id=\"native-element\"></a>\n<h4 id=\"nativeelement\"><em>nativeElement</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#nativeelement\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe value of `ComponentFixture.nativeElement` has the `any` type.\nLater you'll encounter the `DebugElement.nativeElement` and it too has the `any` type.\n\nAngular can't know at compile time what kind of HTML element the `nativeElement` is or\nif it even is an HTML element.\nThe app might be running on a _non-browser platform_, such as the server or a\n[Web Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API),\nwhere the element may have a diminished API or not exist at all.\n\nThe tests in this guide are designed to run in a browser so a\n`nativeElement` value will always be an `HTMLElement` or\none of its derived classes.\n\nKnowing that it is an `HTMLElement` of some sort, you can use\nthe standard HTML `querySelector` to dive deeper into the element tree.\n\nHere's another test that calls `HTMLElement.querySelector` to get the paragraph element and look for the banner text:\n-->\n<p><code><a href=\"api/core/testing/ComponentFixture#nativeElement\" class=\"code-anchor\">ComponentFixture.nativeElement</a></code>에 할당되는 객체는 <code>any</code> 타입입니다.\n그리고 나중에 살펴볼 <code><a href=\"api/core/DebugElement#nativeElement\" class=\"code-anchor\">DebugElement.nativeElement</a></code>에 할당되는 객체도 <code>any</code> 타입입니다.</p>\n<p>Angular 코드가 컴파일되는 시점에는 <code>nativeElement</code>에 할당되는 객체가 어떤 HTML 엘리먼트인지 알 수 없으며, 심지어 HTML 엘리먼트가 정말 할당되는지도 알 수 없습니다.\n그리고 Angular 애플리케이션이 <em>서버가 아닌 환경</em>, 예를 들면 서버에서 실행되거나 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API\">Web Worker</a>로 실행된다면 엘리먼트와 관련된 API가 일부 존재하지 않거나 전부 없을 수도 있습니다.</p>\n<p>하지만 이 문서에서 다루는 예제는 모두 브라우저에서 실행되는 것을 전제로 작성되었기 때문에 <code>nativeElement</code>에 할당되는 객체는 언제나 <code>HTMLElement</code>이거나 이 엘리먼트의 자식 클래스입니다.</p>\n<p>그래서 테스트 코드에서는 <code>HTMLElement</code>에서 제공하는 프로퍼티나 메소드를 활용할 수 있으며, HTML <code>querySelector</code>를 사용해서 엘리먼트 트리 안쪽을 참조할 수 있습니다.</p>\n<p><code>HTMLElement.querySelector</code> 메소드를 사용해서 <code>&#x3C;p></code> 엘리먼트를 참조하고, 이 엘리먼트의 텍스트를 검사하는 로직은 다음과 같이 작성할 수 있습니다:</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v4-test-3\">\nit('should have &#x3C;p> with \"banner works!\"', () => {\n  const bannerElement: HTMLElement = fixture.nativeElement;\n  const p = bannerElement.querySelector('p');\n  expect(p.textContent).toEqual('banner works!');\n});\n\n</code-example>\n<a id=\"debug-element\"></a>\n<h4 id=\"debugelement\"><em>DebugElement</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#debugelement\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe Angular _fixture_ provides the component's element directly through the `fixture.nativeElement`.\n-->\n<p>Angular 픽스쳐(fixture)가 제공하는 API를 활용하면 컴포넌트 엘리먼트에 직접 접근할 수 있습니다.</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"nativeElement\">\nconst bannerElement: HTMLElement = fixture.nativeElement;\n\n</code-example>\n<!--\nThis is actually a convenience method, implemented as `fixture.debugElement.nativeElement`.\n-->\n<p>이 프로퍼티는 사실 <code>fixture.debugElement.nativeElement</code>를 사용하기 쉬운 방법으로 제공하는 것 뿐입니다.</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"debugElement-nativeElement\">\nconst bannerDe: <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> = fixture.debugElement;\nconst bannerEl: HTMLElement = bannerDe.nativeElement;\n\n</code-example>\n<!--\nThere's a good reason for this circuitous path to the element.\n\nThe properties of the `nativeElement` depend upon the runtime environment.\nYou could be running these tests on a _non-browser_ platform that doesn't have a DOM or\nwhose DOM-emulation doesn't support the full `HTMLElement` API.\n\nAngular relies on the `DebugElement` abstraction to work safely across _all supported platforms_.\nInstead of creating an HTML element tree, Angular creates a `DebugElement` tree that wraps the _native elements_ for the runtime platform.\nThe `nativeElement` property unwraps the `DebugElement` and returns the platform-specific element object.\n\nBecause the sample tests for this guide are designed to run only in a browser,\na `nativeElement` in these tests is always an `HTMLElement`\nwhose familiar methods and properties you can explore within a test.\n\nHere's the previous test, re-implemented with `fixture.debugElement.nativeElement`:\n-->\n<p>이렇게 우회하는 이유가 있습니다.</p>\n<p><code>nativeElement</code>에 할당되는 객체는 이 컴포넌트가 어떤 환경에서 실행되는지에 따라 달라집니다.\n<em>브라우저가 아닌</em> 환경에서 애플리케이션을 실행한다면 DOM이 존재하지 않을 수도 있고, DOM을 에뮬레이트한 환경에서는 <code>HTMLElement</code>가 제공하는 API를 온전히 제공하지 않을 수도 있습니다.</p>\n<p>그래서 Angular는 <em>어떠한 플랫폼에서도</em> 이 코드를 문제없이 실행할 수 있도록 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>를 추상화했습니다.\nAngular는 실제로 HTML 엘리먼트 트리를 구성하는 대신, 실행되는 플랫폼에 맞게 랩핑된 <em>네이티브 엘리먼트</em> 로 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 트리를 구성합니다.\n결국 <code>nativeElement</code> 프로퍼티에 접근하는 것은 Angular가 생성한 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>에 접근하는 것이며, 이 방식 덕분에 플랫폼에서 제공하는 엘리먼트 객체에 안전하게 접근할 수 있습니다.</p>\n<p>이 문서에서 다루는 예제는 모두 브라우저에서 실행되는 것을 전제로 작성되었기 때문에 이 문서에서 사용하는 모든 <code>nativeElement</code>는 <code>HTMLElement</code> 객체가 할당됩니다.\n그래서 기존에 DOM에서 사용하던 프로퍼티와 메소드를 그대로 활용할 수 있습니다.</p>\n<p>위에서 살펴본 테스트 코드를 풀어서 쓰면 다음과 같이 작성할 수 있습니다:</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v4-test-4\">\nit('should find the &#x3C;p> with fixture.debugElement.nativeElement)', () => {\n  const bannerDe: <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> = fixture.debugElement;\n  const bannerEl: HTMLElement = bannerDe.nativeElement;\n  const p = bannerEl.querySelector('p');\n  expect(p.textContent).toEqual('banner works!');\n});\n\n</code-example>\n<!--\nThe `DebugElement` has other methods and properties that\nare useful in tests, as you'll see elsewhere in this guide.\n\nYou import the `DebugElement` symbol from the Angular core library.\n-->\n<p><code>@angular/core</code> 패키지에서 제공하는 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>에는 테스트에 활용할만한 메소드나 프로퍼티들이 더 정의되어 있습니다.\n이 내용은 이후 내용에서 더 알아봅시다.</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"import-debug-element\">\nimport { <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> } from '@angular/core';\n\n</code-example>\n<a id=\"by-css\"></a>\n<h4 id=\"bycss\"><em>By.css()</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#bycss\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nAlthough the tests in this guide all run in the browser,\nsome apps might run on a different platform at least some of the time.\n\nFor example, the component might render first on the server as part of a strategy to make the application launch faster on poorly connected devices. The server-side renderer might not support the full HTML element API.\nIf it doesn't support `querySelector`, the previous test could fail.\n\nThe `DebugElement` offers query methods that work for all supported platforms.\nThese query methods take a _predicate_ function that returns `true` when a node in the `DebugElement` tree matches the selection criteria.\n\nYou create a _predicate_ with the help of a `By` class imported from a\nlibrary for the runtime platform. Here's the `By` import for the browser platform:\n-->\n<p>이 문서에서 다루는 모든 테스트 코드는 브라우저에서 실행되는 것을 전제로 작성되었지만, Angular 애플리케이션은 브라우저가 아닌 환경에서도 실행될 수 있습니다.</p>\n<p>예를 들어보면, 접속 환경이 좋지 않은 디바이스를 위해 애플리케이션은 서버에서 미리 렌더링한 뒤에 제공될 수도 있는데, 서버사이드 렌더링 시점에는 HTML 엘리먼트가 제공하는 API를 제대로 사용할 수 없습니다.\n위에서 다뤘던 <code>querySelector</code>도 사용할 수 없기 때문에 테스트는 실패할 것입니다.</p>\n<p>하지만 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>가 제공하는 쿼리 메소드는 모든 플랫폼에서 동작합니다.\n그래서 <code>querySelector</code> 대신 <code><a href=\"api/platform-browser/By\" class=\"code-anchor\">By</a></code> 클래스로 제공되는 쿼리 메소드를 활용하면 모든 플랫폼에서 원하는 엘리먼트를 참조할 수 있습니다.</p>\n<p><code><a href=\"api/platform-browser/By\" class=\"code-anchor\">By</a></code> 클래스는 애플리케이션이 실행되는 플랫폼에 따라 다르게 제공됩니다.\n그래서 브라우저 환경에서 동작하는 <code><a href=\"api/platform-browser/By\" class=\"code-anchor\">By</a></code> 클래스는 다음과 같이 제공됩니다:</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"import-by\">\nimport { <a href=\"api/platform-browser/By\" class=\"code-anchor\">By</a> } from '@angular/platform-browser';\n\n</code-example>\n<!--\nThe following example re-implements the previous test with\n`DebugElement.query()` and the browser's `By.css` method.\n-->\n<p>위에서 살펴본 쿼리 예제는 <code>DebugElement.query()</code> 메소드와 <code>By.css</code> 메소드를 사용해서 다음과 같이 작성할 수 있습니다.</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v4-test-5\">\nit('should find the &#x3C;p> with fixture.debugElement.query(By.css)', () => {\n  const bannerDe: <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> = fixture.debugElement;\n  const paragraphDe = bannerDe.query(By.css('p'));\n  const p: HTMLElement = paragraphDe.nativeElement;\n  expect(p.textContent).toEqual('banner works!');\n});\n\n</code-example>\n<!--\nSome noteworthy observations:\n\n- The `By.css()` static method selects `DebugElement` nodes\n  with a [standard CSS selector](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started/Selectors 'CSS selectors').\n- The query returns a `DebugElement` for the paragraph.\n- You must unwrap that result to get the paragraph element.\n\nWhen you're filtering by CSS selector and only testing properties of a browser's _native element_, the `By.css` approach may be overkill.\n\nIt's often easier and more clear to filter with a standard `HTMLElement` method\nsuch as `querySelector()` or `querySelectorAll()`,\nas you'll see in the next set of tests.\n-->\n<p>몇가지 알아둬야 할 내용이 있습니다:</p>\n<ul>\n<li><code><a href=\"api/platform-browser/By#css\" class=\"code-anchor\">By.css()</a></code> 정적 메소드는 <a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started/Selectors\" title=\"CSS selectors\">표준 CSS 셀렉터</a> 문법으로 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 노드를 탐색합니다.</li>\n<li>이 메소드를 실행하면 <code>&#x3C;p></code> 타입의 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>를 반환합니다.</li>\n<li>반환값으로 받은 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>는 <code>nativeElement</code> 프로퍼티를 사용해서 <code>HTMLElement</code>로 참조할 수 있습니다.</li>\n</ul>\n<p>그래서 브라우저 환경에서 <em>네이티브 엘리먼트</em> 를 테스트한다면 CSS 셀렉터와 <code>By.css</code> 메소드를 사용하는 것으로 충분합니다.</p>\n<p>하지만 <code>querySelector()</code>나 <code>querySelectorAll()</code>을 사용해서 표준 <code>HTMLElement</code>를 참조하는 것이 더 나을 때도 있습니다. 이 내용은 다음 섹션부터 자세하게 알아봅시다.</p>\n<hr>\n<!--\n## Component Test Scenarios\n-->\n<h2 id=\"컴포넌트-테스트-시나리오\">컴포넌트 테스트 시나리오<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#컴포넌트-테스트-시나리오\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe following sections, comprising most of this guide, explore common\ncomponent testing scenarios\n-->\n<p>이제부터는 컴포넌트를 테스트하는 다양한 시나리오에 대해 알아봅시다.</p>\n<!--\n### Component binding\n-->\n<h3 id=\"바인딩\">바인딩<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#바인딩\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe current `BannerComponent` presents static title text in the HTML template.\n\nAfter a few changes, the `BannerComponent` presents a dynamic title by binding to\nthe component's `title` property like this.\n-->\n<p>지금까지 작성한 <code>BannerComponent</code>를 보면, HTML 템플릿에 표시되는 <code>title</code> 프로퍼티는 정적(static) 변수였습니다.</p>\n<p>그런데 이제 이 프로퍼티의 값은 동적으로 변경될 수 있으며, 그때마다 변경된 값이 화면에 바인딩되어 표시된다고 합시다.</p>\n<code-example path=\"testing/src/app/banner/banner.component.ts\" region=\"component\" header=\"app/banner/banner.component.ts\" linenums=\"false\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-banner',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: '&#x3C;h1>{{title}}&#x3C;/h1>',\n  styles: ['h1 { color: green; font-size: 350%}']\n})\nexport class BannerComponent {\n  title = 'Test Tour of Heroes';\n}\n\n</code-example>\n<!--\nSimple as this is, you decide to add a test to confirm that component\nactually displays the right content where you think it should.\n-->\n<p>그러면 <code>title</code> 프로퍼티의 값이 변경되었을 때 이 문자열이 화면에 제대로 표시되는지 검사하는 테스트 코드를 작성해 봅시다.</p>\n<!--\n#### Query for the _&lt;h1&gt;_\n-->\n<h4 id=\"h1-쿼리하기\"><em>&#x3C;h1></em> 쿼리하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#h1-쿼리하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nYou'll write a sequence of tests that inspect the value of the `<h1>` element\nthat wraps the _title_ property interpolation binding.\n\nYou update the `beforeEach` to find that element with a standard HTML `querySelector`\nand assign it to the `h1` variable.\n-->\n<p>가장 먼저 <em>title</em> 프로퍼티가 바인딩되는 <code>&#x3C;h1></code> 엘리먼트에는 실제로 어떤 값이 들어가는지 확인해야 합니다.</p>\n<p>그래서 <code>beforeEach</code> 로직 안에서 HTML <code>querySelector</code> 메소드를 실행해서 <code>&#x3C;h1></code> 엘리먼트를 참조하고, 이 엘리먼트를 변수 <code>h1</code>에 할당합니다.</p>\n<!--\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"setup\" header=\"app/banner/banner.component.spec.ts (setup)\" linenums=\"false\">\nlet component: BannerComponent;\nlet fixture:   ComponentFixture&lt;BannerComponent&gt;;\nlet h1:        HTMLElement;\n\nbeforeEach(() =&gt; {\n  TestBed.configureTestingModule({\n    declarations: [ BannerComponent ],\n  });\n  fixture = TestBed.createComponent(BannerComponent);\n  component = fixture.componentInstance; // BannerComponent 인스턴스\n  h1 = fixture.nativeElement.querySelector(&#39;h1&#39;);\n});\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"setup\" header=\"app/banner/banner.component.spec.ts (테스트환경 설정)\" linenums=\"false\">\nlet component: BannerComponent;\nlet fixture:   <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>&#x3C;BannerComponent>;\nlet h1:        HTMLElement;\n\nbeforeEach(() => {\n  TestBed.configureTestingModule({\n    <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [ BannerComponent ],\n  });\n  fixture = TestBed.createComponent(BannerComponent);\n  component = fixture.componentInstance; // BannerComponent 인스턴스\n  h1 = fixture.nativeElement.querySelector('h1');\n});\n\n</code-example>\n<a id=\"detect-changes\"></a>\n<!--\n#### _createComponent()_ does not bind data\n-->\n<h4 id=\"createcomponent-는-데이터를-바인딩하지-않습니다\"><em>createComponent()</em> 는 데이터를 바인딩하지 않습니다.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#createcomponent-는-데이터를-바인딩하지-않습니다\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nFor your first test you'd like to see that the screen displays the default `title`.\nYour instinct is to write a test that immediately inspects the `<h1>` like this:\n-->\n<p>그러면 이렇게 참조한 <code>&#x3C;h1></code> 엘리먼트의 텍스트가 <code>title</code> 프로퍼티의 기본값과 같다고 테스트 코드를 작성할 수도 있습니다.\n<code>title</code> 프로퍼티는 <code>&#x3C;h1></code> 엘리먼트에 바인딩되기 때문입니다:</p>\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"expect-h1-default-v1\">\nit('should display original title', () => {\n  expect(h1.textContent).toContain(component.title);\n});\n\n</code-example>\n<!--\n_That test fails_ with the message:\n-->\n<p>하지만 이 테스트는 실패합니다:</p>\n<code-example language=\"javascript\">\nexpected '' to contain 'Test Tour of Heroes'.\n</code-example>\n<!--\nBinding happens when Angular performs **change detection**.\n\nIn production, change detection kicks in automatically\nwhen Angular creates a component or the user enters a keystroke or\nan asynchronous activity (e.g., AJAX) completes.\n\nThe `TestBed.createComponent` does _not_ trigger change detection.\na fact confirmed in the revised test:\n-->\n<p>프로퍼티 바인딩은 Angular가 <strong>변화감지 동작</strong>을 실행할 때 발생합니다.</p>\n<p>그리고 실제 운영 환경에서는 Angular가 컴포넌트 인스턴스를 생성하거나 사용자가 키를 입력했을 때, AJAX와 같은 비동기 작업이 완료되었을 때 자동으로 변화감지 동작이 실행됩니다.</p>\n<p><code>TestBed.createComponent</code>는 변화감지 동작을 <em>실행하지 않습니다</em>.\n그래서 사실 이 테스트 코드는 다음과 같은 의미로 실행되었습니다:</p>\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"test-w-o-detect-changes\" linenums=\"false\">\nit('no title in the DOM after createComponent()', () => {\n  expect(h1.textContent).toEqual('');\n});\n\n</code-example>\n<h4 id=\"detectchanges\"><em>detectChanges()</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#detectchanges\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nYou must tell the `TestBed` to perform data binding by calling `fixture.detectChanges()`.\nOnly then does the `<h1>` have the expected title.\n-->\n<p><code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>로 구성한 컴포넌트에 데이터를 바인딩하려면 <code>fixture.detectChanges()</code> 함수를 실행하면 됩니다.\n이 함수를 실행하면 <code>title</code> 프로퍼티의 값이 <code>&#x3C;h1></code>에 바인딩 됩니다.</p>\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"expect-h1-default\">\nit('should display original title after detectChanges()', () => {\n  fixture.detectChanges();\n  expect(h1.textContent).toContain(component.title);\n});\n\n</code-example>\n<!--\nDelayed change detection is intentional and useful.\nIt gives the tester an opportunity to inspect and change the state of\nthe component _before Angular initiates data binding and calls [lifecycle hooks](guide/lifecycle-hooks)_.\n\nHere's another test that changes the component's `title` property _before_ calling `fixture.detectChanges()`.\n-->\n<p>변화감지 동작이 자동으로 실행되지 않는 것은 Angular가 의도한 것이며, 이렇게 동작해야 테스트 코드를 작성하기 더 편합니다.\n왜냐하면 변화감지 동작을 수동으로 실행할 수 있어야 Angular가 데이터 바인딩을 초기화하하기 전에 컴포넌트의 상태를 검사할 수 있으며, <a href=\"guide/lifecycle-hooks\">라이프싸이클 후킹 함수</a>가 동작하기 전에도 컴포넌트를 체크할 수 있기 때문입니다.</p>\n<p>그래서 컴포넌트의 <code>title</code> 프로퍼티를 직접 변경한 후에는 <code>fixture.detectChanges()</code> 함수를 실행해야 원하는 대로 동작하는 테스트 코드를 작성할 수 있습니다.</p>\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"after-change\">\nit('should display <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> different test title', () => {\n  component.title = 'Test <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a>';\n  fixture.detectChanges();\n  expect(h1.textContent).toContain('Test <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a>');\n});\n\n</code-example>\n<a id=\"auto-detect-changes\"></a>\n<!--\n#### Automatic change detection\n-->\n<h4 id=\"변화감지-자동으로-실행하기\">변화감지 자동으로 실행하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#변화감지-자동으로-실행하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe `BannerComponent` tests frequently call `detectChanges`.\nSome testers prefer that the Angular test environment run change detection automatically.\n\nThat's possible by configuring the `TestBed` with the `ComponentFixtureAutoDetect` provider.\nFirst import it from the testing utility library:\n-->\n<p><code>BannerComponent</code>를 테스트할 때는 변화감지 동작을 실행해야 하는 경우가 그리 많지 않기 때문에 <code>detectChanges</code>를 수동으로 실행해도 크게 번거롭지 않습니다.\n하지만 Angular 테스트 환경에서도 변화감지 로직이 자동으로 동작해야 편한 경우가 있습니다.</p>\n<p>그러면 변화감지 로직을 자동으로 실행하도록 <code>TtestBed</code>를 구성할 수 있습니다.\n먼저, 테스트 라이브러리에서 <code><a href=\"api/core/testing/ComponentFixtureAutoDetect\" class=\"code-anchor\">ComponentFixtureAutoDetect</a></code> 프로바이더를 로드합니다:</p>\n<code-example path=\"testing/src/app/banner/banner.component.detect-changes.spec.ts\" region=\"import-ComponentFixtureAutoDetect\" header=\"app/banner/banner.component.detect-changes.spec.ts (import)\" linenums=\"false\">\nimport { <a href=\"api/core/testing/ComponentFixtureAutoDetect\" class=\"code-anchor\">ComponentFixtureAutoDetect</a> } from '@angular/core/testing';\n\n</code-example>\n<!--\nThen add it to the `providers` array of the testing module configuration:\n-->\n<p>그리고 이 프로바이더를 <code>providers</code> 배열에 추가합니다:</p>\n<code-example path=\"testing/src/app/banner/banner.component.detect-changes.spec.ts\" region=\"auto-detect\" header=\"app/banner/banner.component.detect-changes.spec.ts (AutoDetect)\" linenums=\"false\">\nTestBed.configureTestingModule({\n  <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [ BannerComponent ],\n  providers: [\n    { provide: <a href=\"api/core/testing/ComponentFixtureAutoDetect\" class=\"code-anchor\">ComponentFixtureAutoDetect</a>, useValue: true }\n  ]\n});\n\n</code-example>\n<!--\nHere are three tests that illustrate how automatic change detection works.\n-->\n<p>이 프로바이더가 동작하는지 확인해 봅시다. 테스트 스펙 3개를 다음과 같이 정의합니다.</p>\n<code-example path=\"testing/src/app/banner/banner.component.detect-changes.spec.ts\" region=\"auto-detect-tests\" header=\"app/banner/banner.component.detect-changes.spec.ts (AutoDetect Tests)\" linenums=\"false\">\nit('should display original title', () => {\n  // 만세! `fixture.detectChanges()`는 더이상 필요 없습니다.\n  expect(h1.textContent).toContain(comp.title);\n});\n\nit('should still see original title after comp.title change', () => {\n  const oldTitle = comp.title;\n  comp.title = 'Test <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a>';\n  // 화면에 표시되는 문자열은 갱신되지 않습니다. 이 경우에는 변화감지 로직이 실행되지 않았습니다 :(\n  expect(h1.textContent).toContain(oldTitle);\n});\n\nit('should display updated title after detectChanges', () => {\n  comp.title = 'Test <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a>';\n  fixture.detectChanges(); // 명시적으로 변화감지 로직을 실행합니다.\n  expect(h1.textContent).toContain(comp.title);\n});\n\n</code-example>\n<!--\nThe first test shows the benefit of automatic change detection.\n\nThe second and third test reveal an important limitation.\nThe Angular testing environment does _not_ know that the test changed the component's `title`.\nThe `ComponentFixtureAutoDetect` service responds to _asynchronous activities_ such as promise resolution, timers, and DOM events.\nBut a direct, synchronous update of the component property is invisible.\nThe test must call `fixture.detectChanges()` manually to trigger another cycle of change detection.\n-->\n<p>변화감지 로직은 첫번째 테스트 스펙에서만 자동으로 실행됩니다.</p>\n<p>두번째 스펙과 세번째 스펙에서는 왜 자동으로 실행되지 않는지 자세하게 알아봅시다.\nAngular 테스트 환경은 컴포넌트의 <code>title</code> 프로퍼티 값이 변경되는지 확인하지 않습니다.\n<code><a href=\"api/core/testing/ComponentFixtureAutoDetect\" class=\"code-anchor\">ComponentFixtureAutoDetect</a></code> 서비스는 Promise가 완료되었을 때, 타이머가 완료되었을 때, DOM 이벤트가 발생했을 때와 같이 <em>비동기로 일어나는 동작</em> 에만 반응합니다.\n그래서 동기 로직으로 컴포넌트 프로퍼티 값을 변경하면 이 값은 화면에 반영되지 않습니다.\n변화감지 동작을 실행하려면 <code>fixture.detectChanges()</code>를 수동으로 호출해야 합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nRather than wonder when the test fixture will or won't perform change detection,\nthe samples in this guide _always call_ `detectChanges()` _explicitly_.\nThere is no harm in calling `detectChanges()` more often than is strictly necessary.\n-->\n<p>이 문서에서 다루는 예제에서는 테스트 코드가 실행되는 환경에 변화감지 동작이 필요할 때 <code><a href=\"api/core/testing/ComponentFixture#detectChanges\" class=\"code-anchor\">detectChanges()</a></code>를 <em>명시적으로 실행</em> 했습니다.\n<code><a href=\"api/core/testing/ComponentFixture#detectChanges\" class=\"code-anchor\">detectChanges()</a></code> 함수는 꼭 필요한 경우 외에 더 실행되더라도 문제되지 않습니다.</p>\n</div>\n<hr>\n<a id=\"dispatch-event\"></a>\n<!--\n#### Change an input value with _dispatchEvent()_\n-->\n<h4 id=\"dispatchevent-입력값-변경하기\"><em>dispatchEvent()</em>: 입력값 변경하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#dispatchevent-입력값-변경하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nTo simulate user input, you can find the input element and set its `value` property.\n\nYou will call `fixture.detectChanges()` to trigger Angular's change detection.\nBut there is an essential, intermediate step.\n\nAngular doesn't know that you set the input element's `value` property.\nIt won't read that property until you raise the element's `input` event by calling `dispatchEvent()`.\n_Then_ you call `detectChanges()`.\n\nThe following example demonstrates the proper sequence.\n-->\n<p>테스트 코드에서 사용자의 입력을 흉내내려면 <code>&#x3C;input></code> 엘리먼트를 찾아서 이 엘리먼트의 <code>value</code> 프로퍼티를 변경해야 합니다.</p>\n<p>그리고 <code>fixture.detectChanges()</code>를 실행하면 Angular의 변화감지 로직을 실행할 수 있지만, 이 메소드를 실행하기 전에 꼭 해야하는 작업이 있습니다.</p>\n<p>Angular는 개발자가 <code>&#x3C;input></code> 엘리먼트의 <code>value</code> 프로퍼티를 변경했다는 것을 알지 못합니다.\n그래서 엘리먼트에서 <code>input</code> 이벤트가 발생했다는 것을 알리기 위해 <code>dispatchEvent()</code> 함수를 실행해야 이 엘리먼트의 변경된 프로퍼티를 참조할 수 있습니다.\n<code><a href=\"api/core/testing/ComponentFixture#detectChanges\" class=\"code-anchor\">detectChanges()</a></code>는 <em>그 다음에</em> 실행해야 합니다.</p>\n<p>이 순서대로 테스트 코드를 작성해 봅시다.</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"title-case-pipe\" header=\"app/hero/hero-detail.component.spec.ts (pipe test)\">\nit('should convert hero name to <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a> Case', () => {\n  // 이름에 해당하는 input 엘리먼트와 이 이름을 화면에 표시하는 span 엘리먼트를 DOM에서 참조합니다.\n  const hostElement = fixture.nativeElement;\n  const nameInput: HTMLInputElement = hostElement.querySelector('input');\n  const nameDisplay: HTMLElement = hostElement.querySelector('span');\n\n  // 사용자가 입력한 것처럼 입력 필드의 내용을 변경합니다.\n  nameInput.value = 'quick BROWN  fOx';\n\n  // 엘리먼트의 값이 변경되었다는 것을 Angular에게 알리기 위해 DOM 이벤트를 생성합니다.\n  nameInput.dispatchEvent(newEvent('input'));\n\n  // Angular가 화면을 갱신하도록 detectChanges() 함수를 실행합니다.\n  fixture.detectChanges();\n\n  expect(nameDisplay.textContent).toBe('Quick Brown  Fox');\n});\n\n</code-example>\n<hr>\n<!--\n### Component with external files\n-->\n<h3 id=\"외부-파일로-구성된-컴포넌트\">외부 파일로 구성된 컴포넌트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#외부-파일로-구성된-컴포넌트\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe `BannerComponent` above is defined with an _inline template_ and _inline css_, specified in the `@Component.template` and `@Component.styles` properties respectively.\n\nMany components specify _external templates_ and _external css_ with the\n`@Component.templateUrl` and `@Component.styleUrls` properties respectively,\nas the following variant of `BannerComponent` does.\n-->\n<p>위에서 살펴본 <code>BannerComponent</code>는 메타데이터에 <code>@<a href=\"api/core/Component#template\" class=\"code-anchor\">Component.template</a></code>과 <code>@<a href=\"api/core/Component#styles\" class=\"code-anchor\">Component.styles</a></code> 프로퍼티를 사용했기 때문에 <em>인라인 템플릿</em> 과 <em>인라인 CSS</em> 로 구성됩니다.</p>\n<p>하지만 이런 경우보다는 <code>@<a href=\"api/core/Component#templateUrl\" class=\"code-anchor\">Component.templateUrl</a></code>과 <code>@<a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">Component.styleUrls</a></code> 프로퍼티를 사용해서 <em>외부 템플릿 파일</em> 과 <em>외부 CSS 파일</em> 로 구성하는 경우가 더 많습니다.\n이런 경우에 컴포넌트 메타데이터는 다음과 같이 구성됩니다.</p>\n<!--\n<code-example path=\"testing/src/app/banner/banner-external.component.ts\" region=\"metadata\" header=\"app/banner/banner-external.component.ts (metadata)\" linenums=\"false\">\n@Component({\n  selector: &#39;app-banner&#39;,\n  templateUrl: &#39;./banner-external.component.html&#39;,\n  styleUrls:  [&#39;./banner-external.component.css&#39;]\n})\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/banner/banner-external.component.ts\" region=\"metadata\" header=\"app/banner/banner-external.component.ts (메타데이터)\" linenums=\"false\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-banner',\n  templateUrl: './banner-external.component.html',\n  <a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a>:  ['./banner-external.component.css']\n})\n\n</code-example>\n<!--\nThis syntax tells the Angular compiler to read the external files during component compilation.\n\nThat's not a problem when you run the CLI `ng test` command because it\n_compiles the app before running the tests_.\n\nHowever, if you run the tests in a **non-CLI environment**,\ntests of this component may fail.\nFor example, if you run the `BannerComponent` tests in a web coding environment such as [plunker](https://plnkr.co/), you'll see a message like this one:\n-->\n<p>이 방식을 사용하면 Angular 컴파일러가 컴포넌트를 컴파일할 때 별개 파일로 존재하는 템플릿 파일과 스타일 파일을 로드합니다.</p>\n<p>Angular CLI 명령 <code>ng test</code>를 실행한다면 이 방식은 딱히 문제가 되지 않습니다.\n애플리케이션은 <em>테스트가 실행되기 전에 먼저 컴파일됩니다</em>.</p>\n<p>그런데 <strong>Angular CLI를 사용하지 않는 환경</strong>에서 테스트를 실행할 때는 문제가 될 수 있습니다.\n<a href=\"https://plnkr.co/\">plunker</a>와 같은 웹 코딩 환경에서 <code>BannerComponent</code> 테스트를 실행하면 다음과 같은 에러가 발생할 수 있습니다:</p>\n<code-example language=\"sh\" class=\"code-shell\" hidecopy=\"\">\nError: This test module uses the component BannerComponent\nwhich is using <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> \"templateUrl\" or \"<a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a>\", but they were never compiled.\nPlease call \"TestBed.compileComponents\" before your test.\n</code-example>\n<!--\nYou get this test failure message when the runtime environment\ncompiles the source code _during the tests themselves_.\n\nTo correct the problem, call `compileComponents()` as explained [below](#compile-components).\n-->\n<p>이 에러는 테스트할 컴포넌트를 실행 시점에 컴파일 하려고 하기 때문에 발생하는 에러입니다.</p>\n<p>이 문제를 해결하려면 <code>compileComponents()</code>를 명시적으로 실행해줘야 합니다.\n이 내용은 <a href=\"guide/testing#compile-components\">아래</a>에서 자세하게 알아봅니다.</p>\n<a id=\"component-with-dependency\"></a>\n<!--\n### Component with a dependency\n-->\n<h3 id=\"의존성-주입이-필요한-컴포넌트\">의존성 주입이 필요한 컴포넌트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#의존성-주입이-필요한-컴포넌트\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nComponents often have service dependencies.\n\nThe `WelcomeComponent` displays a welcome message to the logged in user.\nIt knows who the user is based on a property of the injected `UserService`:\n-->\n<p>컴포넌트는 서비스 클래스를 의존성으로 주입받을 수 있습니다.</p>\n<p><code>WelcomeComponent</code>는 로그인한 사용자에게 환영 메시지를 출력하는 컴포넌트입니다.\n그리고 이 컴포넌트는 어떤 사용자가 로그인했는지 확인하기 위해 <code>UserService</code>를 의존성으로 주입받습니다:</p>\n<code-example path=\"testing/src/app/welcome/welcome.component.ts\" header=\"app/welcome/welcome.component.ts\" linenums=\"false\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\nimport { UserService }       from '../<a href=\"api/forms/NgModel#model\" class=\"code-anchor\">model</a>/user.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-welcome',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: '&#x3C;h3 class=\"welcome\">&#x3C;i>{{welcome}}&#x3C;/i>&#x3C;/h3>'\n})\nexport class WelcomeComponent  implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  welcome: string;\n  constructor(private userService: UserService) { }\n\n  ngOnInit(): void {\n    this.welcome = this.userService.isLoggedIn ?\n      'Welcome, ' + this.userService.user.name : 'Please <a href=\"api/animations/browser/testing/MockAnimationDriver#log\" class=\"code-anchor\">log</a> in.';\n  }\n}\n\n\n</code-example>\n<!--\nThe `WelcomeComponent` has decision logic that interacts with the service, logic that makes this component worth testing.\nHere's the testing module configuration for the spec file, `app/welcome/welcome.component.spec.ts`:\n-->\n<p><code>WelcomeComponent</code>가 동작할때 실행되는 로직은 의존성으로 주입받은 서비스를 사용하지만, 컴포넌트를 테스트하면서 서비스까지 테스트할 필요는 없습니다.\n그래서 이런 경우에는 테스트 모듈을 다음과 같이 구성합니다:</p>\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"config-test-module\" header=\"app/welcome/welcome.component.spec.ts\" linenums=\"false\">\nTestBed.configureTestingModule({\n   <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [ WelcomeComponent ],\n// providers:    [ UserService ]  // NO! 프로바이더에 실제 서비스 클래스를 등록하면 안됩니다!\n                                  // 목 서비스를 등록하세요.\n   providers:    [ {provide: UserService, useValue: userServiceStub } ]\n});\n\n</code-example>\n<!--\nThis time, in addition to declaring the _component-under-test_,\nthe configuration adds a `UserService` provider to the `providers` list.\nBut not the real `UserService`.\n-->\n<p>이 코드에는 테스트하려는 컴포넌트 외에도 <code>providers</code> 목록에 <code>UserService</code> 타입의 객체를 등록했습니다.\n하지만 실제 <code>UserService</code>가 사용되는 것은 아닙니다.</p>\n<a id=\"service-test-doubles\"></a>\n<!--\n#### Provide service test doubles\n-->\n<h4 id=\"목-서비스-사용하기\">목 서비스 사용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#목-서비스-사용하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nA _component-under-test_ doesn't have to be injected with real services.\nIn fact, it is usually better if they are test doubles (stubs, fakes, spies, or mocks).\nThe purpose of the spec is to test the component, not the service,\nand real services can be trouble.\n\nInjecting the real `UserService` could be a nightmare.\nThe real service might ask the user for login credentials and\nattempt to reach an authentication server.\nThese behaviors can be hard to intercept.\nIt is far easier and safer to create and register a test double in place of the real `UserService`.\n\nThis particular test suite supplies a minimal mock of the `UserService` that satisfies the needs of the `WelcomeComponent`\nand its tests:\n-->\n<p>컴포넌트를 테스트하기 위해 실제 서비스를 의존성으로 등록할 필요는 없습니다.\n이런 경우에는 보통 목(mocks, doubles, stubs, fakes, spies) 서비스를 사용하는 것이 더 좋습니다.\n컴포넌트를 테스트하는 스펙의 목적은 컴포넌트를 테스트하는 것이지 서비스를 테스트하는 것이 아닙니다.\n실제로 사용하는 서비스를 주입한다면 컴포넌트를 테스트하는 로직이 더 복잡해지기만 할 뿐입니다.</p>\n<p>만약 실제 <code>UserService</code>를 주입해야 한다면 아주 괴로운 경험을 겪게될 수도 있습니다.\n실제 서비스는 사용자에게 로그인 인증정보를 제공하라고 할 수도, 있고 인증 서버에 HTTP 요청을 보낼지도 모릅니다.\n이런 동작은 인터셉트하기도 힘듭니다.\n그렇다면 실제 <code>UserService</code>를 대신해서 컴포넌트 동작에 꼭 필요한 로직만 제공하는 무언가를 만드는 것이 훨씬 간단합니다.</p>\n<p><code>UserService</code>의 로직 중 <code>WelcomeComponent</code>의 요구사항에 맞는 기능만 최소한으로 정의하면 다음과 같이 구현할 수 있습니다:</p>\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"user-service-stub\" header=\"app/welcome/welcome.component.spec.ts\" linenums=\"false\">\nlet userServiceStub: Partial&#x3C;UserService>;\n\nuserServiceStub = {\n  isLoggedIn: true,\n  user: { name: 'Test <a href=\"api/common/http/HttpEventType#User\" class=\"code-anchor\">User</a>'}\n};\n\n</code-example>\n<a id=\"get-injected-service\"></a>\n<!--\n#### Get injected services\n-->\n<h4 id=\"의존성으로-주입한-서비스-가져오기\">의존성으로 주입한 서비스 가져오기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#의존성으로-주입한-서비스-가져오기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe tests need access to the (stub) `UserService` injected into the `WelcomeComponent`.\n\nAngular has a hierarchical injection system.\nThere can be injectors at multiple levels, from the root injector created by the `TestBed`\ndown through the component tree.\n\nThe safest way to get the injected service, the way that **_always works_**,\nis to **get it from the injector of the _component-under-test_**.\nThe component injector is a property of the fixture's `DebugElement`.\n-->\n<p>테스트 스펙을 작성하려면 <code>WelcomeComponent</code>에 주입된 <code>UserService</code> 타입의 목 클래스에 접근해야 합니다.</p>\n<p>Angular는 의존성 주입 시스템을 계층 구조로 제공합니다.\n그래서 인젝터는 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>가 생성한 최상위 인젝터부터 컴포넌트 트리 전체에 걸쳐 여러 계층에 존재할 수 있습니다.</p>\n<p>의존성으로 주입된 서비스를 가져오는 방법 중 가장 안전한 방법은 <strong>테스트하는 컴포넌트</strong>에 있는 인젝터에서 서비스 인스턴스를 가져오는 것입니다.\n이 방법은 <strong><em>언제나 동작합니다</em></strong>.\n컴포넌트 인젝터는 픽스쳐의 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 클래스 프로퍼티로 참조할 수 있습니다.</p>\n<!--\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"injected-service\" header=\"WelcomeComponent's injector\">\n// 컴포넌트에 주입된 UserService를 가져옵니다.\nuserService = fixture.debugElement.injector.get(UserService);\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"injected-service\" header=\"WelcomeComponent의 인젝터\">\n// 컴포넌트에 주입된 UserService를 가져옵니다.\nuserService = fixture.debugElement.injector.get(UserService);\n\n</code-example>\n<a id=\"testbed-get\"></a>\n<h4 id=\"testbedget\"><em>TestBed.get()</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#testbedget\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nYou _may_ also be able to get the service from the root injector via `TestBed.get()`.\nThis is easier to remember and less verbose.\nBut it only works when Angular injects the component with the service instance in the test's root injector.\n\nIn this test suite, the _only_ provider of `UserService` is the root testing module,\nso it is safe to call `TestBed.get()` as follows:\n-->\n<p>서비스의 인스턴스는 <code>TestBed.get()</code>을 사용해서 최상위 인젝터에서 참조할 <em>수도</em> 있습니다.\n이렇게 작성하는 것이 더 간단하고 외우기도 쉽습니다.\n하지만 이 방식은 컴포넌트와 서비스 클래스가 테스트 모듈의 최상위 인젝터로 등록되었을 때만 제대로 동작합니다.</p>\n<p>다행히 지금 다루는 예제에서는 <code>UserService</code>가 최상위 테스트 모듈에만 등록되었기 때문에 <code>TestBed.get()</code>을 써서 다음과 같이 작성할 수 있습니다:</p>\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"inject-from-testbed\" header=\"TestBed injector\">\n// 최상위 인젝터에서 UserService를 가져옵니다.\nuserService = TestBed.get(UserService);\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\nFor a use case in which `TestBed.get()` does not work,\nsee the [_Override component providers_](#component-override) section that\nexplains when and why you must get the service from the component's injector instead.\n-->\n<p><code>TestBed.get()</code>로 의존성으로 주입된 서비스의 인스턴스를 가져올 수 없으면, <a href=\"guide/testing#component-override\"><em>컴포넌트 프로바이더 오버라이드</em></a> 섹션을 참고하세요.\n서비스 인스턴스는 컴포넌트의 인젝터에서 가져와야 할 수도 있습니다.</p>\n</div>\n<a id=\"service-from-injector\"></a>\n<!--\n#### Always get the service from an injector\n-->\n<h4 id=\"서비스-인스턴스는-반드시-인젝터에서-가져오세요\">서비스 인스턴스는 반드시 인젝터에서 가져오세요.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#서비스-인스턴스는-반드시-인젝터에서-가져오세요\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nDo _not_ reference the `userServiceStub` object\nthat's provided to the testing module in the body of your test.\n**It does not work!**\nThe `userService` instance injected into the component is a completely _different_ object,\na clone of the provided `userServiceStub`.\n-->\n<p>테스트 스펙을 작성할 때 모듈에 등록한 <code>userServiceStub</code> 객체를 직접 <em>참조하지 마세요</em>.\n<strong>이렇게 하면 동작하지 않습니다!</strong>\n<code>userServiceStub</code>은 모듈에 등록될 때 한 번 복제되기 때문에, 모듈에 등록한 <code>userService</code> 객체의 인스턴스와 컴포넌트에 주입된 인스턴스는 <em>다릅니다</em>.</p>\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"stub-not-injected\" header=\"app/welcome/welcome.component.spec.ts\" linenums=\"false\">\nit('stub object and injected UserService should not be the same', () => {\n  expect(userServiceStub === userService).toBe(false);\n\n  // 목 객체의 프로퍼티 값을 변경해도 의존성으로 주입된 서비스에는 반영되지 않습니다.\n  userServiceStub.isLoggedIn = false;\n  expect(userService.isLoggedIn).toBe(true);\n});\n\n</code-example>\n<a id=\"welcome-spec-setup\"></a>\n<!--\n#### Final setup and tests\n-->\n<h4 id=\"마지막-환경설정-테스트\">마지막 환경설정, 테스트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#마지막-환경설정-테스트\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nHere's the complete `beforeEach()`, using `TestBed.get()`:\n-->\n<p><code>TestBed.get()</code>을 사용하면 <code>beforeEach()</code> 코드를 다음과 같이 작성할 수 있습니다:</p>\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"setup\" header=\"app/welcome/welcome.component.spec.ts\" linenums=\"false\">\n  let userServiceStub: Partial&#x3C;UserService>;\n\nbeforeEach(() => {\n  // 테스트하기 위해 만든 목 UserService\n  userServiceStub = {\n    isLoggedIn: true,\n    user: { name: 'Test <a href=\"api/common/http/HttpEventType#User\" class=\"code-anchor\">User</a>'}\n  };\n\n  TestBed.configureTestingModule({\n     <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [ WelcomeComponent ],\n     providers:    [ {provide: UserService, useValue: userServiceStub } ]\n  });\n\n  fixture = TestBed.createComponent(WelcomeComponent);\n  comp    = fixture.componentInstance;\n\n  // 최상위 인젝터에서 UserService를 가져옵니다.\n  userService = TestBed.get(UserService);\n\n  // 클래스 이름으로 CSS 셀렉터를 사용해서 \"welcome\" 엘리먼트를 가져옵니다.\n  el = fixture.nativeElement.querySelector('.welcome');\n});\n\n</code-example>\n<!--\nAnd here are some tests:\n-->\n<p>그리고 테스트 코드는 이렇게 작성합니다:</p>\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"tests\" header=\"app/welcome/welcome.component.spec.ts\" linenums=\"false\">\nit('should welcome the user', () => {\n  fixture.detectChanges();\n  const content = el.textContent;\n  expect(content).toContain('Welcome', '\"Welcome ...\"');\n  expect(content).toContain('Test <a href=\"api/common/http/HttpEventType#User\" class=\"code-anchor\">User</a>', 'expected name');\n});\n\nit('should welcome \"Bubba\"', () => {\n  userService.user.name = 'Bubba'; // 환영 메시지는 아직 표시되지 않습니다.\n  fixture.detectChanges();\n  expect(el.textContent).toContain('Bubba');\n});\n\nit('should request login if not logged in', () => {\n  userService.isLoggedIn = false; // 환영 메시지는 아직 표시되지 않습니다.\n  fixture.detectChanges();\n  const content = el.textContent;\n  expect(content).not.toContain('Welcome', 'not welcomed');\n  expect(content).toMatch(/<a href=\"api/animations/browser/testing/MockAnimationDriver#log\" class=\"code-anchor\">log</a> in/i, '\"<a href=\"api/animations/browser/testing/MockAnimationDriver#log\" class=\"code-anchor\">log</a> in\"');\n});\n\n</code-example>\n<!--\nThe first is a sanity test; it confirms that the stubbed `UserService` is called and working.\n-->\n<p>첫번째 테스트 스펙은 서비스가 제대로 주입되었는지 확인하는 스펙입니다.\n이 테스트가 성공하면 목으로 만든 <code>UserService</code> 객체가 제대로 실행된 것으로 판단할 수 있습니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nThe second parameter to the Jasmine matcher (e.g., `'expected name'`) is an optional failure label.\nIf the expectation fails, Jasmine displays appends this label to the expectation failure message.\nIn a spec with multiple expectations, it can help clarify what went wrong and which expectation failed.\n-->\n<p>Jasmine 매처의 두번째 인자는 테스트가 실패했을 때 표시할 라벨을 지정하는 옵션 인자입니다.\n이 인자가 지정된 검증식이 실패하면 Jasmine은 에러 메시지 뒤에 이 라벨을 붙여서 화면에 표시합니다.\n그래서 한 테스트 스펙 안에서 여러 검증식을 사용하는 경우에 이 인자를 지정하면 어떤 검증식이 잘못되었는지 빠르게 확인할 수 있습니다.</p>\n</div>\n<!--\nThe remaining tests confirm the logic of the component when the service returns different values.\nThe second test validates the effect of changing the user name.\nThe third test checks that the component displays the proper message when there is no logged-in user.\n-->\n<p>두번째와 세번째 테스트 스펙은 서비스가 다른 값을 반환했을 때 컴포넌트의 로직이 제대로 동작하는지 확인하는 스펙입니다.\n두번째 스펙은 사용자의 이름을 변경한 것이 제대로 반영되는지 확인하는 것이고, 세번째 스펙은 사용자가 로그인하지 않았을 때 올바른 메시지를 표시하는지 확인하는 것입니다.</p>\n<hr>\n<a id=\"component-with-async-service\"></a>\n<!--\n### Component with async service\n-->\n<h3 id=\"비동기-서비스를-사용하는-컴포넌트\">비동기 서비스를 사용하는 컴포넌트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#비동기-서비스를-사용하는-컴포넌트\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn this sample, the `AboutComponent` template hosts a `TwainComponent`.\nThe `TwainComponent` displays Mark Twain quotes.\n-->\n<p>이번 예제에서는 <code>AboutComponent</code> 템플릿 안에 <code>TwainComponent</code>가 존재합니다.\n그리고 <code>TwainComponent</code>는 Mark Twain의 명언을 표시할 것입니다.</p>\n<!--\n<code-example path=\"testing/src/app/twain/twain.component.ts\" region=\"template\" header=\"app/twain/twain.component.ts (template)\" linenums=\"false\">\ntemplate: `\n  &lt;p class=&quot;twain&quot;&gt;&lt;i&gt;{{quote | async}}&lt;/i&gt;&lt;/p&gt;\n  &lt;button (click)=&quot;getQuote()&quot;&gt;Next quote&lt;/button&gt;\n  &lt;p class=&quot;error&quot; *ngIf=&quot;errorMessage&quot;&gt;{{ errorMessage }}&lt;/p&gt;`,\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/twain/twain.component.ts\" region=\"template\" header=\"app/twain/twain.component.ts (템플릿)\" linenums=\"false\">\n<a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n  &#x3C;p class=\"twain\">&#x3C;i>{{quote | async}}&#x3C;/i>&#x3C;/p>\n  &#x3C;button (click)=\"getQuote()\">Next quote&#x3C;/button>\n  &#x3C;p class=\"error\" *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"errorMessage\">{{ errorMessage }}&#x3C;/p>`,\n\n</code-example>\n<!--\nNote that value of the component's `quote` property passes through an `AsyncPipe`.\nThat means the property returns either a `Promise` or an `Observable`.\n\nIn this example, the `TwainComponent.getQuote()` method tells you that\nthe `quote` property returns an `Observable`.\n-->\n<p>이 때 컴포넌트의 <code>quote</code> 프로퍼티는 <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">AsyncPipe</a></code>로 처리됩니다.\n이 말은 <code>quote</code> 프로퍼티에 <code>Promise</code> 타입이나 <code>Observable</code> 타입이 할당된다는 의미입니다.</p>\n<p>실제로 <code>TwainComponent.getQuote()</code> 메소드에서 확인할 수 있듯이, <code>quote</code> 프로퍼티가 반환하는 값은 <code>Observable</code> 타입입니다.</p>\n<code-example path=\"testing/src/app/twain/twain.component.ts\" region=\"get-quote\" header=\"app/twain/twain.component.ts (getQuote)\" linenums=\"false\">\ngetQuote() {\n  this.errorMessage = '';\n  this.quote = this.twainService.getQuote().pipe(\n    startWith('...'),\n    catchError( (err: any) => {\n      // 이번 싸이클에서 errorMessage가 한 번 할당되었기 때문에 한 싸이클 기다립니다.\n      setTimeout(() => this.errorMessage = err.message || err.toString());\n      return of('...'); // quote 프로퍼티의 값을 '...'로 재설정합니다.\n    })\n  );\n\n</code-example>\n<!--\nThe `TwainComponent` gets quotes from an injected `TwainService`.\nThe component starts the returned `Observable` with a placeholder value (`'...'`),\nbefore the service can returns its first quote.\n\nThe `catchError` intercepts service errors, prepares an error message,\nand returns the placeholder value on the success channel.\nIt must wait a tick to set the `errorMessage`\nin order to avoid updating that message twice in the same change detection cycle.\n\nThese are all features you'll want to test.\n-->\n<p><code>TwainComponent</code>의 <code>quote</code> 프로퍼티는 기본 문자열 <code>'...'</code>을 <code>Observable</code> 타입으로 전달하며, 컴포넌트가 초기화된 이후에는 의존성으로 주입된 <code>TwainService</code>에서 데이터를 가져옵니다.</p>\n<p>서비스에서 에러가 발생하면 <code>catchError</code> 인터셉트 함수가 실행됩니다.\n이 함수는 화면에 표시할 에러 메시지를 준비하며, 서비스를 실행했을 때와 마찬가지로 기본 문자열을 반환합니다.\n그런데 이 때 같은 변화감지 싸이클에서 프로퍼티의 값이 두 번 변경되면 안되기 때문에 <code>errorMessage</code>에 값을 할당할 때는 한 싸이클 기다려야 합니다.</p>\n<!--\n#### Testing with a spy\n-->\n<h4 id=\"스파이로-테스트하기\">스파이로 테스트하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#스파이로-테스트하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nWhen testing a component, only the service's public API should matter.\nIn general, tests themselves should not make calls to remote servers.\nThey should emulate such calls. The setup in this `app/twain/twain.component.spec.ts` shows one way to do that:\n-->\n<p>컴포넌트를 테스트할 때는 서비스가 제공하는 public API만 신경쓰면 됩니다.\n그리고 일반적으로 테스트 코드는 리모트 서버로 보내는 HTTP 요청을 생략하고 테스트 환경 안에서 완료되었다고 처리하는 것이 좋습니다.\n<code>app/twain/twain.component.spec.ts</code> 파일에 작성된 테스트 환경 설정 코드를 봅시다:</p>\n<!--\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"setup\" header=\"app/twain/twain.component.spec.ts (setup)\" linenums=\"false\">\nbeforeEach(() =&gt; {\n  testQuote = &#39;Test Quote&#39;;\n\n  // `getQuote()` 스파이 메소드가 선언된 가짜 TwainService 객체를 정의합니다.\n  const twainService = jasmine.createSpyObj(&#39;TwainService&#39;, [&#39;getQuote&#39;]);\n  // `getQuote()` 메소드는 테스트 데이터를 Observable 형태로 즉시 반환합니다.\n  getQuoteSpy = twainService.getQuote.and.returnValue( of(testQuote) );\n\n  TestBed.configureTestingModule({\n    declarations: [ TwainComponent ],\n    providers:    [\n      { provide: TwainService, useValue: twainService }\n    ]\n  });\n\n  fixture = TestBed.createComponent(TwainComponent);\n  component = fixture.componentInstance;\n  quoteEl = fixture.nativeElement.querySelector(&#39;.twain&#39;);\n});\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"setup\" header=\"app/twain/twain.component.spec.ts (테스트 모듈 설정)\" linenums=\"false\">\nbeforeEach(() => {\n  testQuote = 'Test Quote';\n\n  // `getQuote()` 스파이 메소드가 선언된 가짜 TwainService 객체를 정의합니다.\n  const twainService = jasmine.createSpyObj('TwainService', ['getQuote']);\n  // `getQuote()` 메소드는 테스트 데이터를 Observable 형태로 즉시 반환합니다.\n  getQuoteSpy = twainService.getQuote.and.returnValue( of(testQuote) );\n\n  TestBed.configureTestingModule({\n    <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [ TwainComponent ],\n    providers:    [\n      { provide: TwainService, useValue: twainService }\n    ]\n  });\n\n  fixture = TestBed.createComponent(TwainComponent);\n  component = fixture.componentInstance;\n  quoteEl = fixture.nativeElement.querySelector('.twain');\n});\n\n</code-example>\n<a id=\"service-spy\"></a>\n<!--\nFocus on the spy.\n-->\n<p>스파이 메소드를 정의하는 부분을 봅시다.</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"spy\">\n// `getQuote()` 스파이 메소드가 선언된 가짜 TwainService 객체를 정의합니다.\nconst twainService = jasmine.createSpyObj('TwainService', ['getQuote']);\n// `getQuote()` 메소드는 테스트 데이터를 Observable 형태로 즉시 반환합니다.\ngetQuoteSpy = twainService.getQuote.and.returnValue( of(testQuote) );\n\n</code-example>\n<!--\nThe spy is designed such that any call to `getQuote` receives an observable with a test quote.\nUnlike the real `getQuote()` method, this spy bypasses the server\nand returns a synchronous observable whose value is available immediately.\n\nYou can write many useful tests with this spy, even though its `Observable` is synchronous.\n-->\n<p>이 스파이 함수는 <code>getQuote</code>가 실행되었을 때 테스트 문자열을 Observable 타입으로 반환하도록 선언되었습니다.\n그리고 실제 <code>getQuote()</code> 메소드와 다르게, 이 스파이 함수는 서버로 보내는 요청을 생략하고 문자열을 즉시 반환합니다.</p>\n<p>스파이는 이것과 비슷한 상황에서도 얼마든지 활용할 수 있습니다.\n반환하는 타입이 <code>Observable</code>이며, 이 Observable이 동기로 실행되어도 문제될 것은 전혀 없습니다.</p>\n<a id=\"sync-tests\"></a>\n<!--\n#### Synchronous tests\n-->\n<h4 id=\"동기-테스트\">동기 테스트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#동기-테스트\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nA key advantage of a synchronous `Observable` is that\nyou can often turn asynchronous processes into synchronous tests.\n-->\n<p><code>Observable</code>을 동기 방식으로 실행하면 비동기 로직 흐름을 동기 로직 흐름 안으로 자연스럽게 합칠 수 있습니다.</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"sync-test\">\nit('should show quote after component initialized', () => {\n  fixture.detectChanges(); // onInit()\n\n  // 스파이 메소드가 반환한 결과는 컴포넌트가 초기화된 이후에 바로 표시됩니다.\n  expect(quoteEl.textContent).toBe(testQuote);\n  expect(getQuoteSpy.calls.any()).toBe(true, 'getQuote called');\n});\n\n</code-example>\n<!--\nBecause the spy result returns synchronously, the `getQuote()` method updates\nthe message on screen immediately _after_\nthe first change detection cycle during which Angular calls `ngOnInit`.\n\nYou're not so lucky when testing the error path.\nAlthough the service spy will return an error synchronously,\nthe component method calls `setTimeout()`.\nThe test must wait at least one full turn of the JavaScript engine before the\nvalue becomes available. The test must become _asynchronous_.\n-->\n<p>스파이 함수로 정의한 <code>getQuote()</code> 메소드는 반환값을 즉시 동기 방식으로 반환하기 때문에, Angular가 <code>ngOnInit</code>을 실행하면서 함께 실행된 첫번째 변화 감지 싸이클이 <em>끝나면</em> 이 메소드가 반환한 값을 화면에서 바로 확인할 수 있습니다.</p>\n<p>하지만 에러를 처리하려면 조금 더 신경써야 할 부분이 있습니다.\n서비스 스파이가 에러를 동기 흐름으로 반환하면 컴포넌트 메소드가 <code>setTimeout()</code>을 실행하는데, 그러면 이 테스트 스펙은 완료되기 전에 JavaScript 엔진이 한 싸이클 도는 것을 기다려야 합니다.\n결국 테스트 로직은 <em>비동기</em> 로 실행되어야 합니다.</p>\n<a id=\"fake-async\"></a>\n<!--\n#### Async test with _fakeAsync()_\n-->\n<h4 id=\"비동기로-테스트하기-fakeasync\">비동기로 테스트하기: <em>fakeAsync()</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#비동기로-테스트하기-fakeasync\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nTo use `fakeAsync()` functionality, you need to import `zone-testing`, for details, please read [setup guide](guide/setup#appendix-test-using-fakeasyncasync).\n\nThe following test confirms the expected behavior when the service returns an `ErrorObservable`.\n-->\n<p><code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>를 사용하려면 <code>zone-testing</code> 패키지를 로드해야 합니다.\n자세한 내용은 <a href=\"guide/setup#%EB%B6%80%EB%A1%9D-fakeasyncasync-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0\">환경설정 가이드</a>를 참고하세요.</p>\n<p>아래 코드는 서비스가 <code>ErrorObservable</code>을 반환했을 때 정해진 로직을 제대로 실행하는지 검증하는 테스트 코드입니다.</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"error-test\">\nit('should display error when TwainService fails', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() => {\n  // 스파이 메소드가 에러를 Observable 타입으로 반환합니다.\n  getQuoteSpy.and.returnValue(\n    throwError('TwainService test failure'));\n\n  fixture.detectChanges(); // onInit()\n  // 스파이가 보내는 에러는 init이 실행된 직후에 받습니다.\n\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(); // 컴포넌트가 실행한 setTimeout()을 끝냅니다.\n\n  fixture.detectChanges(); // setTimeout() 안에서 변경한 errorMessage를 반영합니다.\n\n  expect(errorMessage()).toMatch(/test failure/, 'should display error');\n  expect(quoteEl.textContent).toBe('...', 'should show placeholder');\n}));\n\n</code-example>\n<!--\nNote that the `it()` function receives an argument of the following form.\n-->\n<p><code>it()</code> 함수에 전달하는 인자는 이런 형태입니다.</p>\n<!--\n```javascript\nfakeAsync(() => { /* test body */ })`\n```\n-->\n<code-example language=\"javascript\">\n<a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() => { /* 테스트 코드 */ })`\n</code-example>\n<!--\nThe `fakeAsync()` function enables a linear coding style by running the test body in a special `fakeAsync test zone`.\nThe test body appears to be synchronous.\nThere is no nested syntax (like a `Promise.then()`) to disrupt the flow of control.\n-->\n<p><code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 함수를 사용하면 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a> 테스트 존</code>이 구성되기 때문에, 이 테스트 존 안에서는 코드를 콜백 스타일로 작성하지 않고 일렬로 작성해도 비동기 흐름을 처리할 수 있습니다.\n테스트 코드를 보면 동기 흐름인 것처럼 보입니다.\n더이상 코드 흐름을 제어하기 위해 <code>Promise.then()</code>과 같이 복잡한 문법을 사용할 필요가 없습니다.</p>\n<a id=\"tick\"></a>\n<!--\n#### The _tick()_ function\n-->\n<h4 id=\"tick-함수\"><em>tick()</em> 함수<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#tick-함수\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nYou do have to call `tick()` to advance the (virtual) clock.\n\nCalling `tick()` simulates the passage of time until all pending asynchronous activities finish.\nIn this case, it waits for the error handler's `setTimeout()`;\n\nThe `tick()` function accepts milliseconds as parameter (defaults to 0 if not provided). The parameter represents how much the virtual clock advances. For example, if you have a `setTimeout(fn, 100)` in a `fakeAsync()` test, you need to use tick(100) to trigger the fn callback.\n-->\n<p><code><a href=\"api/core/ApplicationRef#tick\" class=\"code-anchor\">tick()</a></code> 함수는 테스트 환경에서 동작하는 가상의 시계를 빠르게 돌리기 위해 사용합니다.</p>\n<p><code><a href=\"api/core/ApplicationRef#tick\" class=\"code-anchor\">tick()</a></code> 함수를 실행하면 그동안 대기중이던 비동기 작업들이 종료되는 시점까지 시간을 빠르게 돌립니다.\n그래서 이 함수를 사용하면 <code>TwainComponent.getQuote()</code> 메소드 안에 있는 <code>setTimeout()</code>이 종료된 이후에 실행되는 로직을 테스트하는 코드도 작성할 수 있습니다.</p>\n<p><code><a href=\"api/core/ApplicationRef#tick\" class=\"code-anchor\">tick()</a></code> 함수에 인자를 전달하면 밀리초 단위로 시간을 빠르게 돌릴 수 있으며, 이 인자의 기본값은 0입니다.\n그래서 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 테스트 존 안에서 <code>setTimeout(fn, 100)</code>이라는 타이머를 정의하고 <code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(100)</code>을 실행하면 이 타이머가 종료된 시점의 상태를 확인할 수 있습니다.</p>\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-tick\">\nit('should run timeout callback with delay after call <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a> with millis', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() => {\n     let called = false;\n     setTimeout(() => { called = true; }, 100);\n     <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(100);\n     expect(called).toBe(true);\n   }));\n\n</code-example>\n<!--\nThe `tick()` function is one of the Angular testing utilities that you import with `TestBed`.\nIt's a companion to `fakeAsync()` and you can only call it within a `fakeAsync()` body.\n-->\n<p><code><a href=\"api/core/ApplicationRef#tick\" class=\"code-anchor\">tick()</a></code> 함수는 Angular가 제공하는 테스트 유틸리티 중 하나이며, <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>가 제공되는 <code>@angular/core/testing</code> 패키지로 제공됩니다.\n그리고 <code><a href=\"api/core/ApplicationRef#tick\" class=\"code-anchor\">tick()</a></code> 함수는 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 함수와 함께 사용해야 제대로 동작하며, <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 테스트 존 안에서 필요할 때마다 한번씩 실행해주기만 하면 됩니다.</p>\n<!--\n#### Comparing dates inside fakeAsync()\n-->\n<h4 id=\"fakeasync-안에서-서로-다른-시점-비교하기\">fakeAsync() 안에서 서로 다른 시점 비교하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#fakeasync-안에서-서로-다른-시점-비교하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\n`fakeAsync()` simulates passage of time, which allows you to calculate the difference between dates inside `fakeAsync()`.\n-->\n<p><code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 안에서는 시간이 지난 것을 조작할 수 있기 때문에 서로 다른 시점을 비교하는 것도 가능합니다.</p>\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-date\">\nit('should get Date diff correctly in <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() => {\n     const start = Date.now();\n     <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(100);\n     const end = Date.now();\n     expect(end - start).toBe(100);\n   }));\n\n</code-example>\n<!--\n#### jasmine.clock with fakeAsync()\n-->\n<h4 id=\"fakeasync-안에서-jasmineclock-사용하기\">fakeAsync() 안에서 jasmine.clock 사용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#fakeasync-안에서-jasmineclock-사용하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nJasmine also provides a `clock` feature to mock dates. Angular automatically runs tests that are run after\n`jasmine.clock().install()` is called inside a `fakeAsync()` method until `jasmine.clock().uninstall()` is called. `fakeAsync()` is not needed and throws an error if nested.\n\nBy default, this feature is disabled. To enable it, set a global flag before import `zone-testing`.\n\nIf you use the Angular CLI, configure this flag in `src/test.ts`.\n-->\n<p>시간을 빠르게 감는 것은 Jasmine이 제공하는 <code>clock</code>을 사용해도 됩니다.\nAngular는 <code>jasmine.clock().install()</code>이 실행되고 <code>jasmine.clock().uninstall()</code>이 실행될 때까지 실행되는 테스트 스펙을 자동으로 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 메소드 안에서 처리합니다.\n그래서 이 경우에는 따로 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 함수를 사용하지 않아도 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 함수를 사용한 것과 똑같은 효과를 낼 수 있으며, 이 로직에 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 함수를 사용하면 오히려 에러가 발생합니다.</p>\n<p>기본적으로 이 기능은 비활성화되어 있습니다.\n그래서 이 기능을 사용하려면 <code>zone-testing</code> 패키지를 로드하기 전에 전역 변수로 이 기능을 활성화해야 합니다.</p>\n<p>Angular CLI를 사용한다면 이 기능은 <code>src/test.ts</code>에서 활성화할 수도 있습니다.</p>\n<code-example>\n(window as any)['__zone_symbol__fakeAsyncPatchLock'] = true;\nimport 'zone.js/dist/zone-testing';\n</code-example>\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-clock\">\ndescribe('use jasmine.clock()', () => {\n  // zone.js/dist/zone-testing 패키지를 로드하기 전에 __zone_symbol_fakeAsyncPatchLock 플래그 설정이 필요합니다.\n  beforeEach(() => { jasmine.clock().install(); });\n  afterEach(() => { jasmine.clock().uninstall(); });\n  it('should auto enter <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>', () => {\n    // 이 코드는 <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a> 테스트 존 안에서 실행됩니다.\n    // 이 때 <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()를 명시적으로 실행할 필요는 없습니다.\n    let called = false;\n    setTimeout(() => { called = true; }, 100);\n    jasmine.clock().tick(100);\n    expect(called).toBe(true);\n  });\n});\n\n</code-example>\n<!--\n#### Using the RxJS scheduler inside fakeAsync()\n-->\n<h4 id=\"fakeasync-안에서-rxjs-스케쥴러-사용하기\">fakeAsync() 안에서 RxJS 스케쥴러 사용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#fakeasync-안에서-rxjs-스케쥴러-사용하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nYou can also use RxJS scheduler in `fakeAsync()` just like using `setTimeout()` or `setInterval()`, but you need to import `zone.js/dist/zone-patch-rxjs-fake-async` to patch RxJS scheduler.\n-->\n<p><code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 안에서는 <code>setTimeout()</code>이나 <code>setInterval()</code>을 사용하는 것처럼 RxJS 스케쥴러를 사용할 수도 있습니다.\n하지만 이 경우에는 RxJS 스케쥴러에 패치를 적용하기 위해 <code>zone.js/dist/zone-patch-rxjs-fake-async</code> 패키지를 로드해야 합니다.</p>\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-rxjs\">\nit('should get Date diff correctly in <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a> with rxjs scheduler', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() => {\n     // rxjs 스케쥴러를 사용하기 위해 `import 'zone.js/dist/zone-patch-rxjs-fake-async'를 추가해야 합니다.\n     let result = null;\n     of ('hello').pipe(delay(1000)).subscribe(v => { result = v; });\n     expect(result).toBeNull();\n     <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(1000);\n     expect(result).toBe('hello');\n\n     const start = new Date().getTime();\n     let dateDiff = 0;\n     interval(1000).pipe(take(2)).subscribe(() => dateDiff = (new Date().getTime() - start));\n\n     <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(1000);\n     expect(dateDiff).toBe(1000);\n     <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(1000);\n     expect(dateDiff).toBe(2000);\n   }));\n\n</code-example>\n<!--\n#### Support more macroTasks\n-->\n<h4 id=\"매크로태스크macrotasks-활용하기\">매크로태스크(macroTasks) 활용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#매크로태스크macrotasks-활용하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nBy default `fakeAsync()` supports the following `macroTasks`.\n\n- setTimeout\n- setInterval\n- requestAnimationFrame\n- webkitRequestAnimationFrame\n- mozRequestAnimationFrame\n\nIf you run other `macroTask` such as `HTMLCanvasElement.toBlob()`, `Unknown macroTask scheduled in fake async test` error will be thrown.\n-->\n<p>기본적으로 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>는 다음과 같은 매크로태스크를 지원합니다.</p>\n<ul>\n<li>setTimeout</li>\n<li>setInterval</li>\n<li>requestAnimationFrame</li>\n<li>webkitRequestAnimationFrame</li>\n<li>mozRequestAnimationFrame</li>\n</ul>\n<p>이 목록 외에 <code>HTMLCanvasElement.toBlob()</code>과 같은 매크로태스크를 사용하면 <code>Unknown macroTask scheduled in fake <a href=\"api/core/testing/async\" class=\"code-anchor\">async</a> test</code> 에러가 발생합니다.</p>\n<code-tabs>\n  <code-pane path=\"testing/src/app/shared/canvas.component.spec.ts\" header=\"src/app/shared/canvas.component.spec.ts\" linenums=\"false\">\nimport { <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>, <a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>, <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>, <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a> } from '@angular/core/testing';\nimport { CanvasComponent } from './canvas.component';\ndescribe('CanvasComponent', () => {\n  beforeEach(<a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>(() => {\n    TestBed.configureTestingModule({\n      <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [\n        CanvasComponent\n      ],\n    }).compileComponents();\n  }));\n  beforeEach(() => {\n    window['__zone_symbol__FakeAsyncTestMacroTask'] = [\n      {\n        source: 'HTMLCanvasElement.toBlob',\n        callbackArgs: [{ size: 200 }]\n      }\n    ];\n  });\n  it('should be able to generate blob data from canvas', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() => {\n    const fixture = TestBed.createComponent(CanvasComponent);\n    fixture.detectChanges();\n    <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>();\n    const app = fixture.debugElement.componentInstance;\n    expect(app.blobSize).toBeGreaterThan(0);\n  }));\n});\n\n\n\n</code-pane>\n  <code-pane path=\"testing/src/app/shared/canvas.component.ts\" header=\"src/app/shared/canvas.component.ts\" linenums=\"false\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a>, <a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'sample-canvas',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: '&#x3C;canvas #sampleCanvas width=\"200\" height=\"200\">&#x3C;/canvas>'\n})\nexport class CanvasComponent implements <a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a> {\n  blobSize: number;\n  @<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>('sampleCanvas') sampleCanvas;\n\n  constructor() { }\n\n  ngAfterViewInit() {\n    const canvas = this.sampleCanvas.nativeElement;\n    const context = canvas.getContext('2d');\n    if (context) {\n      context.clearRect(0, 0, 200, 200);\n      context.fillStyle = '#FF1122';\n      context.fillRect(0, 0, 200, 200);\n      canvas.toBlob((blob: any) => {\n        this.blobSize = blob.size;\n      });\n    }\n  }\n}\n\n\n</code-pane>\n</code-tabs>\n<!--\nIf you want to support such case, you need to define the `macroTask` you want to support in `beforeEach()`.\nFor example:\n-->\n<p>그래서 Angular가 기본으로 지원하지 않는 매크로태스크를 사용하려면 <code>beforeEach()</code> 안에 해당 매크로태스크를 직접 정의해야 합니다.</p>\n<code-example language=\"javascript\">\nbeforeEach(() => {\n  window['__zone_symbol__FakeAsyncTestMacroTask'] = [\n    {\n      source: 'HTMLCanvasElement.toBlob',\n      callbackArgs: [{ size: 200 }]\n    }\n  ];\n});\n\nit('toBlob should be able to run in <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() => {\n    const canvas: HTMLCanvasElement = document.getElementById('canvas') as HTMLCanvasElement;\n    let blob = null;\n    canvas.toBlob(function(b) {\n      blob = b;\n    });\n    <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>();\n    expect(blob.size).toBe(200);\n  })\n);\n</code-example>\n<!--\n#### Async observables\n-->\n<h4 id=\"비동기-옵저버블\">비동기 옵저버블<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#비동기-옵저버블\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nYou might be satisfied with the test coverage of these tests.\n\nBut you might be troubled by the fact that the real service doesn't quite behave this way.\nThe real service sends requests to a remote server.\nA server takes time to respond and the response certainly won't be available immediately\nas in the previous two tests.\n\nYour tests will reflect the real world more faithfully if you return an _asynchronous_ observable\nfrom the `getQuote()` spy like this.\n-->\n<p>지금까지 다룬 내용만으로도 테스트 코드를 작성하는 데에는 큰 문제가 없습니다.</p>\n<p>하지만 실제 서비스 클래스를 사용하다보면 지금까지 다루지 않았던 부분에서 에러가 발생할 수 있습니다.\n그리고 실제 서비스가 리모트 서버로 HTTP 요청을 보낸다면 이런 에러가 발생할 가능성이 더 높습니다.\n서버는 요청을 받고 응답을 보낼때까지 시간이 걸리기 때문에 지금까지 살펴봤던 것처럼 즉시 처리되는 로직으로는 이 응답을 처리할 수 없습니다.</p>\n<p>그래서 실제 운영 환경을 좀 더 충실하게 반영하고 싶다면, <code>getQuote()</code> 스파이 함수를 다음과 같이 정의해야 합니다.</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"async-setup\">\n// `asyncData()` 헬퍼 함수를 사용해서 옵저버블을 비동기로 처리합니다.\ngetQuoteSpy.and.returnValue(asyncData(testQuote));\n\n</code-example>\n<!--\n#### Async observable helpers\n-->\n<h4 id=\"비동기-옵저버블-헬퍼\">비동기 옵저버블 헬퍼<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#비동기-옵저버블-헬퍼\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe async observable was produced by an `asyncData` helper\nThe `asyncData` helper is a utility function that you'll have to write yourself.\nOr you can copy this one from the sample code.\n-->\n<p>위 코드에서는 옵저버블을 비동기로 생성하기 위해 <code>asyncData</code> 헬퍼 함수를 사용했습니다.\n이 때 <code>asyncData</code>는 유틸리티 함수인데, 필요한 용도에 맞게 직접 정의하거나 예제 코드를 복사해서 사용하면 됩니다.</p>\n<code-example path=\"testing/src/testing/async-observable-helpers.ts\" region=\"async-data\" header=\"testing/async-observable-helpers.ts\">\n/** JS 실행 싸이클이 한 번 실행된 뒤에 Observable을 보내고 바로 종료합니다. */\nexport function asyncData&#x3C;T>(data: T) {\n  return defer(() => Promise.resolve(data));\n}\n\n</code-example>\n<!--\nThis helper's observable emits the `data` value in the next turn of the JavaScript engine.\n\nThe [RxJS `defer()` operator](http://reactivex.io/documentation/operators/defer.html) returns an observable.\nIt takes a factory function that returns either a promise or an observable.\nWhen something subscribes to _defer_'s observable,\nit adds the subscriber to a new observable created with that factory.\n\nThe `defer()` operator transforms the `Promise.resolve()` into a new observable that,\nlike `HttpClient`, emits once and completes.\nSubscribers are unsubscribed after they receive the data value.\n\nThere's a similar helper for producing an async error.\n-->\n<p>이 헬퍼 함수는 JavaScript 실행 싸이클이 한 번 실행된 뒤에 <code>data</code>로 받은 값을 옵저버블로 보내는 함수입니다.</p>\n<p>그리고 이 때 <a href=\"http://reactivex.io/documentation/operators/defer.html\">RxJS <code>defer()</code> 연산자</a>가 사용되었는데, 이 연산자는 Promise나 Observable이 종료되는 것을 기다리는 연산자입니다.\n이제 <em>defer</em> 옵저버블을 누군가가 구독하면 새로운 옵저버블이 생성되면서 팩토리 함수가 실행됩니다.</p>\n<p>이 코드에서 <code>defer()</code> 연산자는 <code>Promise.resolve()</code>를 옵저버블로 변환하는데, 이 동작은 Angular <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>와 비슷하게 한 번 데이터를 보낸 뒤에 바로 종료됩니다.\n그래서 <code>asyncData()</code>를 구독한 쪽에서는 데이터를 받은 후에 바로 옵저버블 구독을 해지해도 됩니다.</p>\n<p>비동기 에러 옵저버블도 비슷하게 처리할 수 있습니다.</p>\n<code-example path=\"testing/src/testing/async-observable-helpers.ts\" region=\"async-error\">\n/** JS 실행 싸이클이 한 번 실행된 뒤에 에러 Observable을 보내고 바로 종료합니다. */\nexport function asyncError&#x3C;T>(errorObject: any) {\n  return defer(() => Promise.reject(errorObject));\n}\n\n</code-example>\n<!--\n#### More async tests\n-->\n<h4 id=\"비동기-테스트-활용-예제\">비동기 테스트 활용 예제<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#비동기-테스트-활용-예제\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nNow that the `getQuote()` spy is returning async observables,\nmost of your tests will have to be async as well.\n\nHere's a `fakeAsync()` test that demonstrates the data flow you'd expect\nin the real world.\n-->\n<p>이제 <code>getQuote()</code> 스파이 함수가 실행되면 옵저버블을 비동기로 반환하기 때문에 테스트하는 코드가 비동기로 동작해도 잘 실행됩니다.</p>\n<p>그리고 실제 동작 환경을 좀 더 반영해서 데이터 흐름을 테스트하려면 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>를 다음과 같이 활용할 수도 있습니다.</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"fake-async-test\">\nit('should show quote after getQuote (<a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>)', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() => {\n  fixture.detectChanges(); // ngOnInit()\n  expect(quoteEl.textContent).toBe('...', 'should show placeholder');\n\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(); // 옵저버블을 실행합니다.\n  fixture.detectChanges(); // 화면을 갱신합니다.\n\n  expect(quoteEl.textContent).toBe(testQuote, 'should show quote');\n  expect(errorMessage()).toBeNull('should not show error');\n}));\n\n</code-example>\n<!--\nNotice that the quote element displays the placeholder value (`'...'`) after `ngOnInit()`.\nThe first quote hasn't arrived yet.\n\nTo flush the first quote from the observable, you call `tick()`.\nThen call `detectChanges()` to tell Angular to update the screen.\n\nThen you can assert that the quote element displays the expected text.\n-->\n<p><code>ngOnInit()</code>이 실행된 직후에 화면에 표시되는 문자열은 <code>'...'</code>입니다.\n왜냐하면 첫번째 요청이 아직 처리되지 않았기 때문입니다.</p>\n<p><code>ngOnInit()</code>에서 보낸 요청을 처리하려면 <code><a href=\"api/core/ApplicationRef#tick\" class=\"code-anchor\">tick()</a></code>을 실행하면 됩니다.\n그리고 화면을 갱신하기 위해 <code><a href=\"api/core/testing/ComponentFixture#detectChanges\" class=\"code-anchor\">detectChanges()</a></code> 함수도 실행했습니다.</p>\n<p>이제 옵저버블로 받은 데이터가 화면에 제대로 표시되었는지 확인하기만 하면 됩니다.</p>\n<a id=\"async\"></a>\n<!--\n#### Async test with _async()_\n-->\n<h4 id=\"async-로-비동기-테스트하기\"><em>async()</em> 로 비동기 테스트하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#async-로-비동기-테스트하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nTo use `async()` functionality, you need to import `zone-testing`, for details, please read [setup guide](guide/setup#appendix-test-using-fakeasyncasync).\n\nThe `fakeAsync()` utility function has a few limitations.\nIn particular, it won't work if the test body makes an `XHR` call.\n\n`XHR` calls within a test are rare so you can generally stick with `fakeAsync()`.\nBut if you ever do need to call `XHR`, you'll want to know about `async()`.\n-->\n<p><code><a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>()</code> 기능을 사용하려면 <code>zone-testing</code> 패키지를 로드해야 합니다.\n자세한 내용은 <a href=\"guide/setup#%EB%B6%80%EB%A1%9D-fakeasyncasync-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0\">환경설정 가이드</a>를 참고하세요.</p>\n<p><code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 유틸리티 함수는 몇가지 제약이 있습니다.\n예를 들어, 테스트 코드에서 <code>XHR</code> 요청을 보낸다면 이 테스트 스펙은 제대로 실행되지 않습니다.</p>\n<p>테스트 코드에서 <code>XHR</code> 요청을 보내는 경우는 거의 없기 때문에 웬만하면 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>만 사용해도 테스트 코드를 작성할 수 있습니다.\n하지만 실제로 <code>XHR</code> 요청을 보내야 한다면 <code><a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>()</code>를 사용해야 합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nThe `TestBed.compileComponents()` method (see [below](#compile-components)) calls `XHR`\nto read external template and css files during \"just-in-time\" compilation.\nWrite tests that call `compileComponents()` with the `async()` utility.\n-->\n<p><a href=\"guide/testing#compile-components\">아래</a>에서 다루는 <code>TestBed.compileComponents()</code> 메소드는 JiT 컴파일러로 처리되기 때문에 외부 템플릿 파일과 외부 CSS 파일을 읽기 위해 <code>XHR</code> 요청을 보냅니다.\n그래서 테스트 코드에서 <code>compileComponents()</code>를 사용한다면 <code><a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>()</code>를 꼭 사용해야 합니다.</p>\n</div>\n<!--\nHere's the previous `fakeAsync()` test, re-written with the `async()` utility.\n-->\n<p>이전에 작성했던 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 예제를 <code><a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>()</code> 방식으로 작성하면 이렇습니다.</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"async-test\">\nit('should show quote after getQuote (<a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>)', <a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>(() => {\n  fixture.detectChanges(); // ngOnInit()\n  expect(quoteEl.textContent).toBe('...', 'should show placeholder');\n\n  fixture.whenStable().then(() => { // 비동기 getQuote를 기다립니다.\n    fixture.detectChanges();        // 화면을 갱신합니다.\n    expect(quoteEl.textContent).toBe(testQuote);\n    expect(errorMessage()).toBeNull('should not show error');\n  });\n}));\n\n</code-example>\n<!--\nThe `async()` utility hides some asynchronous boilerplate by arranging for the tester's code\nto run in a special _async test zone_.\nYou don't need to pass Jasmine's `done()` into the test and call `done()` because it is `undefined` in promise or observable callbacks.\n\nBut the test's asynchronous nature is revealed by the call to `fixture.whenStable()`,\nwhich breaks the linear flow of control.\n\nWhen using an `intervalTimer()` such as `setInterval()` in `async()`, remember to cancel the timer with `clearInterval()` after the test, otherwise the `async()` never ends.\n-->\n<p><code><a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>()</code> 함수를 사용하면 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>를 사용하면서 <em>비동기 테스트 존(async test zone)</em> 에 사용했던 비동기 처리 관련 함수들을 일부 생략할 수 있습니다.\n그리고 Jasmine이 제공하는 <code><a href=\"api/core/ApplicationInitStatus#done\" class=\"code-anchor\">done</a>()</code> 함수를 실행할 필요도 없습니다.</p>\n<p>대신 테스트를 정상적으로 종료할 수 있도록 <code>fixture.whenStable()</code>이 비동기 흐름을 처리합니다.</p>\n<p>다만, <code><a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>()</code> 안에서 <code>intervalTimer()</code>나 <code>setInterval()</code>을 사용한다면 이 타이머를 종료하거나 <code>clearInterval()</code>을 실행해야 합니다.\n타이머를 종료하지 않으면 <code><a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>()</code>도 종료되지 않습니다.</p>\n<a id=\"when-stable\"></a>\n<h4 id=\"whenstable\"><em>whenStable</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#whenstable\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe test must wait for the `getQuote()` observable to emit the next quote.\nInstead of calling `tick()`, it calls `fixture.whenStable()`.\n\nThe `fixture.whenStable()` returns a promise that resolves when the JavaScript engine's\ntask queue becomes empty.\nIn this example, the task queue becomes empty when the observable emits the first quote.\n\nThe test resumes within the promise callback, which calls `detectChanges()` to\nupdate the quote element with the expected text.\n-->\n<p>이 테스트 스펙은 <code>getQuote()</code>로 받은 옵저버블이 다음 스트림을 전달할 때까지 기다려야 합니다.\n이 때 이 코드에서는 <code><a href=\"api/core/ApplicationRef#tick\" class=\"code-anchor\">tick()</a></code>을 실행하는 대신 <code>fixture.whenStable()</code>을 실행했습니다.</p>\n<p><code>fixture.whenStable()</code>은 JavaScript 엔진의 태스크 큐가 비어있을 때 Promise를 반환합니다.\n이 예제에서는 옵저버블이 첫번째 문장을 전달한 뒤에 태스크 큐가 비어있게 됩니다.</p>\n<p>그러면 Promise 콜백으로 테스트가 이어집니다.\n이 콜백에서는 화면을 갱신하기 위해 <code><a href=\"api/core/testing/ComponentFixture#detectChanges\" class=\"code-anchor\">detectChanges()</a></code>를 실행하고, 그 이후에 화면에 표시된 메시지가 예상한 값이 맞는지 확인합니다.</p>\n<a id=\"jasmine-done\"></a>\n<h4 id=\"jasmine-done\">Jasmine <em>done()</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#jasmine-done\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nWhile the `async()` and `fakeAsync()` functions greatly\nsimplify Angular asynchronous testing,\nyou can still fall back to the traditional technique\nand pass `it` a function that takes a\n[`done` callback](https://jasmine.github.io/2.0/introduction.html#section-Asynchronous_Support).\n\nYou can't call `done()` in `async()` or `fakeAsync()` functions, because the `done parameter`\nis `undefined`.\n\nNow you are responsible for chaining promises, handling errors, and calling `done()` at the appropriate moments.\n\nWriting test functions with `done()`, is more cumbersome than `async()`and `fakeAsync()`.\nBut it is occasionally necessary when code involves the `intervalTimer()` like `setInterval`.\n\nHere are two more versions of the previous test, written with `done()`.\nThe first one subscribes to the `Observable` exposed to the template by the component's `quote` property.\n-->\n<p>Angular가 제공하는 <code><a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>()</code>와 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>를 활용하면 비동기 로직을 아주 간단하게 테스트할 수 있습니다.\n하지만 이 함수들을 사용해도 실패하는 로직이 있다면 <code>it</code> 함수에 <a href=\"https://jasmine.github.io/2.0/introduction.html#section-Asynchronous_Support\"><code>done</code> 콜백</a>을 사용하는 방법을 검토할 수 있습니다.</p>\n<p>다만, <code><a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>()</code>와 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 기능을 사용하면서 <code><a href=\"api/core/ApplicationInitStatus#done\" class=\"code-anchor\">done</a>()</code>를 함께 사용할 수는 없습니다.\n두 함수를 사용하면 <code><a href=\"api/core/ApplicationInitStatus#done\" class=\"code-anchor\">done</a></code> 이 <code>undefined</code>로 전달됩니다.</p>\n<p><code><a href=\"api/core/ApplicationInitStatus#done\" class=\"code-anchor\">done</a>()</code>을 사용하면 직접 Promise를 체이닝하거나 에러를 처리해야하고, 적절한 시점에 <code><a href=\"api/core/ApplicationInitStatus#done\" class=\"code-anchor\">done</a>()</code>을 실행해야 합니다.</p>\n<p>그래서 <code><a href=\"api/core/ApplicationInitStatus#done\" class=\"code-anchor\">done</a>()</code>을 사용해서 테스트하는 것은 <code><a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>()</code>나 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>를 사용했던 것보다 조금 더 번거롭습니다.\n하지만 <code>setInterval</code>이나 <code>intervalTimer()</code>을 활용하는 로직은 <code><a href=\"api/core/ApplicationInitStatus#done\" class=\"code-anchor\">done</a>()</code>을 사용해야만 합니다.</p>\n<p>위에서 작성했던 테스트를 <code><a href=\"api/core/ApplicationInitStatus#done\" class=\"code-anchor\">done</a>()</code>을 사용하는 방식으로 변경하면 다음과 같이 작성할 수 있습니다.\n이 코드에서는 <code>Observable</code>을 구독한 뒤에 실행되는 콜백에서 컴포넌트를 테스트하고 <code><a href=\"api/core/ApplicationInitStatus#done\" class=\"code-anchor\">done</a>()</code>을 실행합니다.</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"quote-done-test\" linenums=\"false\">\nit('should show last quote (quote <a href=\"api/core/ApplicationInitStatus#done\" class=\"code-anchor\">done</a>)', (<a href=\"api/core/ApplicationInitStatus#done\" class=\"code-anchor\">done</a>: DoneFn) => {\n  fixture.detectChanges();\n\n  component.quote.pipe( last() ).subscribe(() => {\n    fixture.detectChanges(); // 화면을 갱신합니다.\n    expect(quoteEl.textContent).toBe(testQuote);\n    expect(errorMessage()).toBeNull('should not show error');\n    <a href=\"api/core/ApplicationInitStatus#done\" class=\"code-anchor\">done</a>();\n  });\n});\n\n</code-example>\n<!--\nThe RxJS `last()` operator emits the observable's last value before completing, which will be the test quote.\nThe `subscribe` callback calls `detectChanges()` to\nupdate the quote element with the test quote, in the same manner as the earlier tests.\n\nIn some tests, you're more interested in how an injected service method was called and what values it returned,\nthan what appears on screen.\n\nA service spy, such as the `qetQuote()` spy of the fake `TwainService`,\ncan give you that information and make assertions about the state of the view.\n-->\n<p>RxJS <code>last()</code> 연산자는 옵저버블이 종료되는 시점에 마지막으로 전달된 데이터를 반환하기 때문에 옵저버블 콜백은 테스트 문장을 받아온 이후에 실행됩니다.\n그리고 <code>subscribe</code> 콜백에서는 <code><a href=\"api/core/testing/ComponentFixture#detectChanges\" class=\"code-anchor\">detectChanges()</a></code>를 실행해서 이 문장으로 화면을 갱신합니다.\n이 내용은 이전에 작성했던 내용과 같습니다.</p>\n<p>조금 더 자세히 들어가면 컴포넌트로 주입되는 서비스가 어떻게 실행되는지, 어떤 값을 반환해서 이 내용이 화면에 반영되는지 궁금해질 수도 있습니다.</p>\n<p><code>TwainService</code>에 만든 <code>getQuote()</code> 함수는 스파이로 만든 함수입니다.\n그래서 이 스파이를 직접 활용하면 다음과 같은 테스트 코드를 작성할 수도 있습니다.</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"spy-done-test\" linenums=\"false\">\nit('should show quote after getQuote (spy <a href=\"api/core/ApplicationInitStatus#done\" class=\"code-anchor\">done</a>)', (<a href=\"api/core/ApplicationInitStatus#done\" class=\"code-anchor\">done</a>: DoneFn) => {\n  fixture.detectChanges();\n\n  // 컴포넌트가 받는 문자열은 스파이가 마지막으로 실행되었을 때 반환하는 값으로 참조할 수도 있습니다.\n  getQuoteSpy.calls.mostRecent().returnValue.subscribe(() => {\n    fixture.detectChanges(); // 화면을 갱신합니다.\n    expect(quoteEl.textContent).toBe(testQuote);\n    expect(errorMessage()).toBeNull('should not show error');\n    <a href=\"api/core/ApplicationInitStatus#done\" class=\"code-anchor\">done</a>();\n  });\n});\n\n</code-example>\n<hr>\n<a id=\"marble-testing\"></a>\n<!--\n### Component marble tests\n-->\n<h3 id=\"컴포넌트-마블marble-테스트\">컴포넌트 마블(marble) 테스트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#컴포넌트-마블marble-테스트\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe previous `TwainComponent` tests simulated an asynchronous observable response\nfrom the `TwainService` with the `asyncData` and `asyncError` utilities.\n\nThese are short, simple functions that you can write yourself.\nUnfortunately, they're too simple for many common scenarios.\nAn observable often emits multiple times, perhaps after a significant delay.\nA component may coordinate multiple observables\nwith overlapping sequences of values and errors.\n\n**RxJS marble testing** is a great way to test observable scenarios,\nboth simple and complex.\nYou've likely seen the [marble diagrams](http://rxmarbles.com/)\nthat illustrate how observables work.\nMarble testing uses a similar marble language to\nspecify the observable streams and expectations in your tests.\n\nThe following examples revisit two of the `TwainComponent` tests\nwith marble testing.\n\nStart by installing the `jasmine-marbles` npm package.\nThen import the symbols you need.\n-->\n<p>위에서 살펴본 <code>TwainComponent</code> 테스트 코드는 <code>TwainService</code>가 전달하는 옵저버블을 처리하기 위해 <code>asyncData</code>와 <code>asyncError</code> 기능을 활용했습니다.</p>\n<p>이 코드는 아주 간단하기 때문에 조금만 익숙해지면 금방 작성할 수 있습니다.\n하지만 이런 방식으로 모든 시나리오를 처리할 수는 없습니다.\n옵저버블은 여러번 데이터를 보내기도 하는데, 이 때 약간 딜레이가 있을 수도 있습니다.\n그리고 컴포넌트가 옵저버블 여러개를 복잡한 순서로 조작하면서 이 옵저버블들이 전달하는 값과 에러를 모두 처리해야 할 수도 있습니다.</p>\n<p><strong>RxJS 마블 테스트는</strong> 옵저버블을 시나리오 방식으로 테스트하는 방법입니다.\n옵저버블이 복잡하거나 단순한 것과는 관계없이, 일관된 방법으로 옵저버블이 실행되는 시나리오를 검증할 수 있습니다.\n<a href=\"http://rxmarbles.com/\">마블 다이어그램</a>도 RxJS 마블 테스트 방법을 활용한 것 중 하나입니다.\n마블 테스트 로직은 기존에 옵저버블 스트림을 처리하고 검사했던 로직과 비슷합니다.</p>\n<p>이제부터는 <code>TwainComponent</code>에 마블 테스트를 적용하는 방법에 대해 알아봅시다.</p>\n<p>마블 테스트 로직을 작성하려면 <code>jasmine-marbles</code> npm 패키지를 설치해야 합니다.\n그리고 이 패키지에서 다음 심볼들을 로드합니다.</p>\n<!--\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"import-marbles\" header=\"app/twain/twain.component.marbles.spec.ts (import marbles)\" linenums=\"false\">\nimport { cold, getTestScheduler } from &#39;jasmine-marbles&#39;;\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"import-marbles\" header=\"app/twain/twain.component.marbles.spec.ts (심볼 로드하기)\" linenums=\"false\">\nimport { cold, getTestScheduler } from 'jasmine-marbles';\n\n</code-example>\n<!--\nHere's the complete test for getting a quote:\n-->\n<p>그리고 테스트 코드는 이렇게 작성합니다:</p>\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"get-quote-test\" linenums=\"false\">\nit('should show quote after getQuote (marbles)', () => {\n  // 옵저버블은 약간 지연된 후 테스트 문장을 전달하고 종료됩니다.\n  const q$ = cold('---x|', { x: testQuote });\n  getQuoteSpy.and.returnValue( q$ );\n\n  fixture.detectChanges(); // ngOnInit()\n  expect(quoteEl.textContent).toBe('...', 'should show placeholder');\n\n  getTestScheduler().flush(); // 옵저버블을 실행합니다.\n\n  fixture.detectChanges(); // 화면을 갱신합니다.\n\n  expect(quoteEl.textContent).toBe(testQuote, 'should show quote');\n  expect(errorMessage()).toBeNull('should not show error');\n});\n\n</code-example>\n<!--\nNotice that the Jasmine test is synchronous. There's no `fakeAsync()`.\nMarble testing uses a test scheduler to simulate the passage of time\nin a synchronous test.\n\nThe beauty of marble testing is in the visual definition of the observable streams.\nThis test defines a [_cold_ observable](#cold-observable) that waits\nthree [frames](#marble-frame) (`---`),\nemits a value (`x`), and completes (`|`).\nIn the second argument you map the value marker (`x`) to the emitted value (`testQuote`).\n-->\n<p>Jasmine 테스트 로직은 동기 방식으로 실행됩니다.\n<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>와 같은 것은 없습니다.\n대신 마블 테스트는 비동기 로직을 실행하기 위해 시간을 조작할 때 테스트 스케쥴러(test scheduler)를 사용합니다.</p>\n<p>마블 테스트는 옵저버블 스트림을 시각적으로 정의할 수 있다는 점이 가장 좋습니다.\n이 테스트에서는 <a href=\"guide/testing#cold-observable\"><em>콜드(cold)</em> 옵저버블</a>을 사용하며, 이 옵저버블은 3 <a href=\"guide/testing#marble-frame\">프레임</a>을 기다린 후에(<code>---</code>) 데이터를 보내고(<code>x</code>) 종료합니다(<code>|</code>).\n이 때 <code>cold</code> 옵저버블의 두 번째로 전달하는 인자는 실제 값(<code>testQuote</code>)과 데이터 스트림을 연결하는 값 마커(value marker, <code>x</code>)입니다.</p>\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"test-quote-marbles\" linenums=\"false\">\nconst q$ = cold('---x|', { x: testQuote });\n\n</code-example>\n<!--\nThe marble library constructs the corresponding observable, which the\ntest sets as the `getQuote` spy's return value.\n\nWhen you're ready to activate the marble observables,\nyou tell the `TestScheduler` to _flush_ its queue of prepared tasks like this.\n-->\n<p>그 다음에는 이 옵저버블이 <code>getQuote</code> 스파이와 연결되어 값을 반환할 수 있도록 설정합니다.</p>\n<p>마블 옵저버블을 준비한 후에 <code>TestScheduler</code>의 <code><a href=\"api/core/testing/flush\" class=\"code-anchor\">flush</a></code>를 실행하면 미리 정의한 대로 옵저버블이 실행됩니다.</p>\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"test-scheduler-flush\" linenums=\"false\">\ngetTestScheduler().flush(); // 옵저버블을 실행합니다.\n\n</code-example>\n<!--\nThis step serves a purpose analogous to `tick()` and `whenStable()` in the\nearlier `fakeAsync()` and `async()` examples.\nThe balance of the test is the same as those examples.\n-->\n<p>이 코드는 이전에 다뤘던 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>와 <code><a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>()</code> 예제에서 <code><a href=\"api/core/ApplicationRef#tick\" class=\"code-anchor\">tick()</a></code>과 <code>whenStable()</code>을 사용했던 것과 비슷하게 동작합니다.</p>\n<p>나머지 코드는 이전에 살펴봤던 내용과 같습니다.</p>\n<!--\n#### Marble error testing\n-->\n<h4 id=\"마블-테스트에서-에러-처리하기\">마블 테스트에서 에러 처리하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#마블-테스트에서-에러-처리하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nHere's the marble testing version of the `getQuote()` error test.\n-->\n<p>아래 코드는 <code>getQuote</code> 에러 테스트 코드를 마블 테스트 방식으로 작성한 코드입니다.</p>\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"error-test\" linenums=\"false\">\nit('should display error when TwainService fails', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() => {\n  // 옵저버블은 약간 지연된 후 에러를 전달하고 종료됩니다.\n  const q$ = cold('---#|', null, new Error('TwainService test failure'));\n  getQuoteSpy.and.returnValue( q$ );\n\n  fixture.detectChanges(); // ngOnInit()\n  expect(quoteEl.textContent).toBe('...', 'should show placeholder');\n\n  getTestScheduler().flush(); // 옵저버블을 실행합니다.\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>();                     // 컴포넌트가 사용하는 setTimeout()을 처리합니다.\n  fixture.detectChanges();    // 화면을 갱신합니다.\n\n  expect(errorMessage()).toMatch(/test failure/, 'should display error');\n  expect(quoteEl.textContent).toBe('...', 'should show placeholder');\n}));\n\n</code-example>\n<!--\nIt's still an async test, calling `fakeAsync()` and `tick()`, because the component itself\ncalls `setTimeout()` when processing errors.\n\nLook at the marble observable definition.\n-->\n<p>컴포넌트는 에러를 처리할 때 <code>setTimeout()</code>을 사용하기 때문에 이 코드는 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>와 <code><a href=\"api/core/ApplicationRef#tick\" class=\"code-anchor\">tick()</a></code>를 사용해서 비동기로 처리되어야 합니다.</p>\n<p>이 때 마블 옵저버블은 어떻게 선언하는지 봅시다.</p>\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"error-marbles\" linenums=\"false\">\nconst q$ = cold('---#|', null, new Error('TwainService test failure'));\n\n</code-example>\n<!--\nThis is a _cold_ observable that waits three frames and then emits an error,\nThe hash (`#`) indicates the timing of the error that is specified in the third argument.\nThe second argument is null because the observable never emits a value.\n-->\n<p>이 코드에서 정의하는 <em>콜드</em> 옵저버블은 3 프레임을 기다린 후 에러를 보내는데, 에러는 세번째 인자로 전달하며, 이 에러는 해시(<code>#</code>)가 사용된 시점에 전달됩니다.\n이 옵저버블은 데이터를 전달하지 않기 때문에 두번째 인자를 null로 지정했습니다.</p>\n<!--\n#### Learn about marble testing\n-->\n<h4 id=\"마블-테스트-더-알아보기\">마블 테스트 더 알아보기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#마블-테스트-더-알아보기\"><i class=\"material-icons\">link</i></a></h4>\n<a id=\"marble-frame\"></a>\n<!--\nA _marble frame_ is a virtual unit of testing time.\nEach symbol (`-`, `x`, `|`, `#`) marks the passing of one frame.\n-->\n<p>마블 테스트에서 시간을 표현하는 단위를 <em>마블 프레임(marble frame)</em> 이라고 하며, 각 심볼(<code>-</code>, <code>x</code>, <code>|</code>, <code>#</code>) 하나는 한 프레임을 의미합니다.</p>\n<a id=\"cold-observable\"></a>\n<!--\nA _cold_ observable doesn't produce values until you subscribe to it.\nMost of your application observables are cold.\nAll [_HttpClient_](guide/http) methods return cold observables.\n\nA _hot_ observable is already producing values _before_ you subscribe to it.\nThe [_Router.events_](api/router/Router#events) observable,\nwhich reports router activity, is a _hot_ observable.\n\nRxJS marble testing is a rich subject, beyond the scope of this guide.\nLearn about it on the web, starting with the\n[official documentation](https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md).\n-->\n<p><em>콜드(cold)</em> 옵저버블은 누군가가 구독하기 전까지는 데이터를 생성하지 않습니다.\n일반적으로 사용하는 옵저버블이 콜드 옵저버블이며, <a href=\"guide/http\"><em>HttpClient</em></a> 메소드가 반환하는 옵저버블도 모두 콜드 옵저버블입니다.</p>\n<p>반면에, <em>핫(hot)</em> 옵저버블은 누군가가 구독하지 <em>않아도</em> 데이터를 생성합니다.\n라우터의 동작을 확인할 때 사용하는 <a href=\"api/router/Router#events\"><em>Router 이벤트</em></a>가 <em>핫</em> 옵저버블입니다.</p>\n<p>RxJS 마블 테스트는 더 다양하게 활용할 수 있지만, 이 내용은 이 가이드 문서가 다루는 범위를 넘어서는 내용입니다.\nRxJS 마블 테스트에 대해 더 자세하게 알아보려면 <a href=\"https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md\">해당 문서</a>를 참고하세요.</p>\n<hr>\n<a id=\"component-with-input-output\"></a>\n<!--\n### Component with inputs and outputs\n-->\n<h3 id=\"입력출력-프로퍼티가-있는-컴포넌트\">입력/출력 프로퍼티가 있는 컴포넌트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#입력출력-프로퍼티가-있는-컴포넌트\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nA component with inputs and outputs typically appears inside the view template of a host component.\nThe host uses a property binding to set the input property and an event binding to\nlisten to events raised by the output property.\n\nThe testing goal is to verify that such bindings work as expected.\nThe tests should set input values and listen for output events.\n\nThe `DashboardHeroComponent` is a tiny example of a component in this role.\nIt displays an individual hero provided by the `DashboardComponent`.\nClicking that hero tells the `DashboardComponent` that the user has selected the hero.\n\nThe `DashboardHeroComponent` is embedded in the `DashboardComponent` template like this:\n-->\n<p>입력/출력 프로퍼티가 있는 컴포넌트는 일반적으로 호스트 컴포넌트의 템플릿 안에 존재합니다.\n이런 컴포넌트는 보통 호스트 컴포넌트가 프로퍼티 바인딩해서 입력 프로퍼티 값을 지정하며, 이벤트 바인딩해서 출력 프로퍼티에서 발생하는 이벤트를 감지합니다.</p>\n<p>이번에 진행하는 테스트의 목표는 프로퍼티 바인딩과 이벤트 바인딩이 제대로 동작하는지 확인하는 것입니다.\n입력 프로퍼티 값을 지정하고 출력 프로퍼티로 발생되는 이벤트를 감지해봅시다.</p>\n<p>이 내용은 <code>DashboardHeroComponent</code>를 통해 간단하게 알아봅니다.\n이 컴포넌트는 <code>DashboardComponent</code>에서 받은 히어로의 정보를 화면에 표시하는 컴포넌트입니다.\n그리고 컴포넌트를 클릭하면 해당 히어로가 선택되었다고 <code>DashboardComponent</code>에게 알리는 역할을 합니다.</p>\n<p>그래서 <code>DashboardHeroComponent</code>는 <code>DashboardComponent</code> 템플릿에 다음과 같이 사용됩니다:</p>\n<!--\n<code-example path=\"testing/src/app/dashboard/dashboard.component.html\" region=\"dashboard-hero\" header=\"app/dashboard/dashboard.component.html (excerpt)\" linenums=\"false\">\n&lt;dashboard-hero *ngFor=&quot;let hero of heroes&quot;  class=&quot;col-1-4&quot;\n  [hero]=hero  (selected)=&quot;gotoDetail($event)&quot; &gt;\n&lt;/dashboard-hero&gt;\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/dashboard/dashboard.component.html\" region=\"dashboard-hero\" header=\"app/dashboard/dashboard.component.html (일부)\" linenums=\"false\">\n&#x3C;dashboard-hero *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"  class=\"col-1-4\"\n  [hero]=hero  (selected)=\"gotoDetail($event)\" >\n&#x3C;/dashboard-hero>\n\n</code-example>\n<!--\nThe `DashboardHeroComponent` appears in an `*ngFor` repeater, which sets each component's `hero` input property\nto the looping value and listens for the component's `selected` event.\n\nHere's the component's full definition:\n-->\n<p><code>DashboardHeroComponent</code>는 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 리피터와 함께 사용되어 각 루프마다 컴포넌트의 입력 프로퍼티를 <code>hero</code> 값으로 할당하고, 각 컴포넌트에서 발생하는 <code>selected</code> 이벤트를 감지합니다.</p>\n<p>컴포넌트 전체 코드는 이렇습니다:</p>\n<a id=\"dashboard-hero-component\"></a>\n<!--\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.ts\" region=\"component\" header=\"app/dashboard/dashboard-hero.component.ts (component)\" linenums=\"false\">\n@Component({\n  selector: &#39;dashboard-hero&#39;,\n  template: `\n    &lt;div (click)=&quot;click()&quot; class=&quot;hero&quot;&gt;\n      {{hero.name | uppercase}}\n    &lt;/div&gt;`,\n  styleUrls: [ &#39;./dashboard-hero.component.css&#39; ]\n})\nexport class DashboardHeroComponent {\n  @Input() hero: Hero;\n  @Output() selected = new EventEmitter&lt;Hero&gt;();\n  click() { this.selected.emit(this.hero); }\n}\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.ts\" region=\"component\" header=\"app/dashboard/dashboard-hero.component.ts (컴포넌트)\" linenums=\"false\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'dashboard-hero',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n    &#x3C;div (click)=\"click()\" class=\"hero\">\n      {{hero.name | <a href=\"api/common/UpperCasePipe\" class=\"code-anchor\">uppercase</a>}}\n    &#x3C;/div>`,\n  <a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a>: [ './dashboard-hero.component.css' ]\n})\nexport class DashboardHeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() selected = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;Hero>();\n  click() { this.selected.emit(this.hero); }\n}\n\n</code-example>\n<!--\nWhile testing a component this simple has little intrinsic value, it's worth knowing how.\nYou can use one of these approaches:\n\n- Test it as used by `DashboardComponent`.\n- Test it as a stand-alone component.\n- Test it as used by a substitute for `DashboardComponent`.\n\nA quick look at the `DashboardComponent` constructor discourages the first approach:\n-->\n<p>이 컴포넌트를 바로 테스트하기 전에, 이 컴포넌트를 어떻게 테스트할 수 있을지 생각해보는 것이 좋습니다.\n테스트 접근 방식은 다음 중 하나를 선택할 수 있습니다:</p>\n<ul>\n<li><code>DashboardComponent</code>와 함께 사용되는 시나리오 테스트하기</li>\n<li>컴포넌트 단독으로 테스트하기</li>\n<li>단순화한 <code>DashboardComponent</code>로 테스트하기</li>\n</ul>\n<p>먼저, <code>DashboardComponent</code>의 생성자를 보면 첫번째 접근 방식은 사용하기 어렵다는 것을 예상할 수 있습니다:</p>\n<!--\n<code-example path=\"testing/src/app/dashboard/dashboard.component.ts\" region=\"ctor\" header=\"app/dashboard/dashboard.component.ts (constructor)\" linenums=\"false\">\nconstructor(\n  private router: Router,\n  private heroService: HeroService) {\n}\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/dashboard/dashboard.component.ts\" region=\"ctor\" header=\"app/dashboard/dashboard.component.ts (생성자)\" linenums=\"false\">\nconstructor(\n  private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,\n  private heroService: HeroService) {\n}\n\n</code-example>\n<!--\nThe `DashboardComponent` depends on the Angular router and the `HeroService`.\nYou'd probably have to replace them both with test doubles, which is a lot of work.\nThe router seems particularly challenging.\n-->\n<p><code>DashboardComponent</code>는 Angular 라우터와 <code>HeroService</code>를 의존성으로 주입받습니다.\n그러면 두 의존성에 대해 목 클래스를 정의해야 하는데, 이 작업이 쉽지 않습니다.\n라우터를 모킹하는 것은 험난한 과정이 될 것입니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nThe [discussion below](#routing-component) covers testing components that require the router.\n-->\n<p>라우터가 필요한 컴포넌트를 테스트하는 경우는 <a href=\"guide/testing#routing-component\">아래</a>에서 다룹니다.</p>\n</div>\n<!--\nThe immediate goal is to test the `DashboardHeroComponent`, not the `DashboardComponent`,\nso, try the second and third options.\n-->\n<p>이번 섹션에서 하려는 것은 <code>DashboardHeroComponent</code>를 테스트하는 것이지 <code>DashboardComponent</code>를 테스트하는 것이 아닙니다.\n다른 방식을 생각해 봅시다.</p>\n<a id=\"dashboard-standalone\"></a>\n<!--\n#### Test _DashboardHeroComponent_ stand-alone\n-->\n<h4 id=\"dashboardherocomponent-단독으로-테스트하기\"><em>DashboardHeroComponent</em> 단독으로 테스트하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#dashboardherocomponent-단독으로-테스트하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nHere's the meat of the spec file setup.\n-->\n<p>테스트 환경을 준비하는 코드는 다음과 같습니다.</p>\n<!--\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"setup\" header=\"app/dashboard/dashboard-hero.component.spec.ts (setup)\" linenums=\"false\">\nTestBed.configureTestingModule({\n  declarations: [ DashboardHeroComponent ]\n})\nfixture = TestBed.createComponent(DashboardHeroComponent);\ncomp    = fixture.componentInstance;\n\n// 컴포넌트의 DebugElement와 HTMLElement를 참조합니다.\nheroDe  = fixture.debugElement.query(By.css(&#39;.hero&#39;));\nheroEl = heroDe.nativeElement;\n\n// 컴포넌트에 사용할 히어로 정보를 선언합니다.\nexpectedHero = { id: 42, name: &#39;Test Name&#39; };\n\n// 부모 컴포넌트에서 입력 프로퍼티로 받는 과정을 처리합니다.\ncomp.hero = expectedHero;\n\n// 초기 데이터 바인딩을 실행합니다.\nfixture.detectChanges();\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"setup\" header=\"app/dashboard/dashboard-hero.component.spec.ts (테스트 환경설정)\" linenums=\"false\">\nTestBed.configureTestingModule({\n  <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [ DashboardHeroComponent ]\n})\nfixture = TestBed.createComponent(DashboardHeroComponent);\ncomp    = fixture.componentInstance;\n\n// 컴포넌트의 <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>와 HTMLElement를 참조합니다.\nheroDe  = fixture.debugElement.query(By.css('.hero'));\nheroEl = heroDe.nativeElement;\n\n// 컴포넌트에 사용할 히어로 정보를 선언합니다.\nexpectedHero = { id: 42, name: 'Test Name' };\n\n// 부모 컴포넌트에서 입력 프로퍼티로 받는 과정을 처리합니다.\ncomp.hero = expectedHero;\n\n// 초기 데이터 바인딩을 실행합니다.\nfixture.detectChanges();\n\n</code-example>\n<!--\nNote how the setup code assigns a test hero (`expectedHero`) to the component's `hero` property,\nemulating the way the `DashboardComponent` would set it\nvia the property binding in its repeater.\n\nThe following test verifies that the hero name is propagated to the template via a binding.\n-->\n<p>원래 <code>hero</code> 프로퍼티는 <code>DashboardComponent</code>의 리피터 안에서 프로퍼티 바인딩되지만, 이 과정을 간단하게 처리하기 위해 테스트 객체(<code>expectedHero</code>)를 선언하고 이 객체를 컴포넌트의 <code>hero</code> 프로퍼티에 직접 할당했습니다.</p>\n<p>그러면 이렇게 할당된 프로퍼티가 템플릿에 바인딩되어 이름을 제대로 표시하는지 검사할 수 있습니다.</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"name-test\">\nit('should display hero name in uppercase', () => {\n  const expectedPipedName = expectedHero.name.toUpperCase();\n  expect(heroEl.textContent).toContain(expectedPipedName);\n});\n\n</code-example>\n<!--\nBecause the [template](#dashboard-hero-component) passes the hero name through the Angular `UpperCasePipe`,\nthe test must match the element value with the upper-cased name.\n-->\n<p>히어로의 이름은 <a href=\"guide/testing#dashboard-hero-component\">템플릿</a>에서 Angular <code><a href=\"api/common/UpperCasePipe\" class=\"code-anchor\">UpperCasePipe</a></code>로 처리되기 때문에, 엘리먼트 값을 검사하는 로직도 대문자로 변환된 이름을 사용해야 합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nThis small test demonstrates how Angular tests can verify a component's visual\nrepresentation&mdash;something not possible with\n[component class tests](#component-class-testing)&mdash;at\nlow cost and without resorting to much slower and more complicated end-to-end tests.\n-->\n<p><a href=\"guide/testing#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%ED%81%B4%EB%9E%98%EC%8A%A4-%ED%85%8C%EC%8A%A4%ED%8A%B8\">컴포넌트 클래스 테스트</a>로 확인할 수 없는 컴포넌트의 시각적인 부분은 이렇게 검사할 수 있습니다.\n엔드-투-엔드 테스트에서 컴포넌트를 테스트하는 것보다 더 간단하기 때문에 실행 속도도 훨씬 빠릅니다.</p>\n</div>\n<!--\n#### Clicking\n-->\n<h4 id=\"클릭-테스트하기\">클릭 테스트하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#클릭-테스트하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nClicking the hero should raise a `selected` event that\nthe host component (`DashboardComponent` presumably) can hear:\n-->\n<p>화면에서 히어로를 클릭하면 <code>selected</code> 이벤트가 호스트 컴포넌트 <code>DashboardComponent</code>로 전달되어야 합니다.\n이 내용은 이렇게 테스트할 수 있습니다:</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"click-test\">\nit('should raise selected event when clicked (triggerEventHandler)', () => {\n  let selectedHero: Hero;\n  comp.selected.subscribe((hero: Hero) => selectedHero = hero);\n\n  heroDe.triggerEventHandler('click', null);\n  expect(selectedHero).toBe(expectedHero);\n});\n\n</code-example>\n<!--\nThe component's `selected` property returns an `EventEmitter`,\nwhich looks like an RxJS synchronous `Observable` to consumers.\nThe test subscribes to it _explicitly_ just as the host component does _implicitly_.\n\nIf the component behaves as expected, clicking the hero's element\nshould tell the component's `selected` property to emit the `hero` object.\n\nThe test detects that event through its subscription to `selected`.\n-->\n<p>컴포넌트의 <code>selected</code> 프로퍼티는 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 객체를 반환하며, 이 객체는 RxJS의 동기 <code>Observable</code>과 비슷한 객체입니다.\n원래 이 프로퍼티는 호스트 컴포넌트가 템플릿에서 <em>자동으로</em> 구독하지만, 이 테스트에서는 <em>명시적으로</em> 구독해야 이벤트가 발생하는 것을 확인할 수 있습니다.</p>\n<p>컴포넌트가 제대로 구현되었다면 히어로 엘리먼트를 클릭했을 때 컴포넌트의 <code>selected</code> 프로퍼티로 <code>hero</code> 객체가 전달되어야 합니다.</p>\n<p>이 내용은 <code>selected</code> 프로퍼티를 구독하면 확인할 수 있습니다.</p>\n<a id=\"trigger-event-handler\"></a>\n<h4 id=\"triggereventhandler\"><em>triggerEventHandler</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#triggereventhandler\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe `heroDe` in the previous test is a `DebugElement` that represents the hero `<div>`.\n\nIt has Angular properties and methods that abstract interaction with the native element.\nThis test calls the `DebugElement.triggerEventHandler` with the \"click\" event name.\nThe \"click\" event binding responds by calling `DashboardHeroComponent.click()`.\n\nThe Angular `DebugElement.triggerEventHandler` can raise _any data-bound event_ by its _event name_.\nThe second parameter is the event object passed to the handler.\n\nThe test triggered a \"click\" event with a `null` event object.\n-->\n<p>이 테스트에서 사용하는 변수 <code>heroDe</code>는 히어로 <code>&#x3C;div></code>를 표현하는 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 클래스입니다.</p>\n<p>이 클래스는 네이티브 엘리먼트와 추상적으로 상호 작용할 수 있는 프로퍼티와 메소드를 제공하는데, 그 중 <code>DebugElement.triggerEventHandler</code>를 사용하면 \"click\" 이벤트를 발생시킬 수 있습니다.\n그리고 <code>DashboardHeroComponent.click()</code> 메소드를 직접 사용해도 \"click\" 이벤트를 발생시킬 수 있습니다.</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"trigger-event-handler\">\nheroDe.triggerEventHandler('click', null);\n\n</code-example>\n<!--\nThe test assumes (correctly in this case) that the runtime\nevent handler&mdash;the component's `click()` method&mdash;doesn't\ncare about the event object.\n-->\n<p>이 테스트 코드는 실행 시점에 사용되는 컴포넌트의 <code>click()</code> 메소드가 이벤트 객체의 내용은 신경쓰지 않는다는 것을 전제로 했기 때문에, <code>triggerEventHadler</code>로 전달하는 이벤트 객체를 <code>null</code>로 지정했습니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nOther handlers are less forgiving. For example, the `RouterLink`\ndirective expects an object with a `button` property\nthat identifies which mouse button (if any) was pressed during the click.\nThe `RouterLink` directive throws an error if the event object is missing.\n-->\n<p>다른 핸들러는 조금 더 번거롭습니다.\n예를 들어 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 디렉티브는 어떤 엘리먼트에서 클릭 이벤트가 발생했는지 확인하기 위해 이벤트 객체에 <code>button</code> 프로퍼티가 있어야 합니다.\n이 프로퍼티가 없으면 에러가 발생합니다.</p>\n</div>\n<!--\n#### Click the element\n-->\n<h4 id=\"엘리먼트-클릭하기\">엘리먼트 클릭하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#엘리먼트-클릭하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe following test alternative calls the native element's own `click()` method,\nwhich is perfectly fine for _this component_.\n-->\n<p>엘리먼트를 클릭하는 동작은 네이티브 엘리먼트가 제공하는 <code>click()</code> 메소드를 사용해도 됩니다.\n이렇게 사용해도 컴포넌트는 이전과 같이 동작합니다.</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"click-test-2\">\nit('should raise selected event when clicked (element.click)', () => {\n  let selectedHero: Hero;\n  comp.selected.subscribe((hero: Hero) => selectedHero = hero);\n\n  heroEl.click();\n  expect(selectedHero).toBe(expectedHero);\n});\n\n</code-example>\n<a id=\"click-helper\"></a>\n<!--\n#### _click()_ helper\n-->\n<h4 id=\"click-헬퍼\"><em>click()</em> 헬퍼<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#click-헬퍼\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nClicking a button, an anchor, or an arbitrary HTML element is a common test task.\n\nMake that consistent and easy by encapsulating the _click-triggering_ process\nin a helper such as the `click()` function below:\n-->\n<p>테스트를 작성하다보면 버튼(<code>&#x3C;button></code>)이나 앵커(<code>&#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>></code>)와 같은 HTML 엘리먼트를 동작시키는 일이 자주 있습니다.</p>\n<p>이 동작을 캡슐화해서 항상 같은 방식으로 편하게 사용하려면 다음과 같이 <em>클릭을 처리하는</em> 헬퍼를 정의하는 것도 좋습니다:</p>\n<!--\n<code-example path=\"testing/src/testing/index.ts\" region=\"click-event\" header=\"testing/index.ts (click helper)\" linenums=\"false\">\n/** RouterLink 이벤트 핸들러를 위해 버튼 이벤트 객체의 일부를 다시 선언합니다. */\nexport const ButtonClickEvents = {\n   left:  { button: 0 },\n   right: { button: 2 }\n};\n\n/** 엘리먼트 클릭을 처리합니다. 이벤트 객체의 기본값은 마우스 왼쪽 버튼 클릭 이벤트입니다. */\nexport function click(el: DebugElement | HTMLElement, eventObj: any = ButtonClickEvents.left): void {\n  if (el instanceof HTMLElement) {\n    el.click();\n  } else {\n    el.triggerEventHandler(&#39;click&#39;, eventObj);\n  }\n}\n\n</code-example>\n-->\n<code-example path=\"testing/src/testing/index.ts\" region=\"click-event\" header=\"testing/index.ts (클릭 헬퍼)\" linenums=\"false\">\n/** <a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a> 이벤트 핸들러를 위해 버튼 이벤트 객체의 일부를 다시 선언합니다. */\nexport const ButtonClickEvents = {\n   left:  { button: 0 },\n   right: { button: 2 }\n};\n\n/** 엘리먼트 클릭을 처리합니다. 이벤트 객체의 기본값은 마우스 왼쪽 버튼 클릭 이벤트입니다. */\nexport function click(el: <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> | HTMLElement, eventObj: any = ButtonClickEvents.left): void {\n  if (el instanceof HTMLElement) {\n    el.click();\n  } else {\n    el.triggerEventHandler('click', eventObj);\n  }\n}\n\n</code-example>\n<!--\nThe first parameter is the _element-to-click_. If you wish, you can pass a\ncustom event object as the second parameter. The default is a (partial)\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\">left-button mouse event object</a>\naccepted by many handlers including the `RouterLink` directive.\n-->\n<p>첫번째 인자는 <em>클릭할 엘리먼트</em> 입니다.\n그리고 두 번째 인자로 이벤트 객체를 전달할 수도 있습니다.\n<code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 디렉티브와 같이 인자가 필요한 핸들러를 위해, 이 이벤트 객체의 기본값은 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\">마우스 왼쪽 버튼 이벤트 객체</a> 일부로 지정했습니다.</p>\n<div class=\"alert is-important\">\n<!--\nThe `click()` helper function is **not** one of the Angular testing utilities.\nIt's a function defined in _this guide's sample code_.\nAll of the sample tests use it.\nIf you like it, add it to your own collection of helpers.\n-->\n<p><code>click()</code> 헬퍼 함수는 Angular가 제공하는 테스트 기능이 <em>아닙니다</em>.\n이 함수는 <em>이 가이드 문서에서 사용하기 위해</em> 선언한 함수일 뿐입니다.\n이번 문서에서는 이 함수를 계속 사용하며, 필요하다면 다른 헬퍼 함수를 정의해서 사용하는 것도 물론 가능합니다.</p>\n</div>\n<!--\nHere's the previous test, rewritten using the click helper.\n-->\n<p>이제 이전에 작성했던 테스트 코드는 클릭 헬퍼를 사용해서 다음과 같이 작성할 수 있습니다.</p>\n<!--\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"click-test-3\" header=\"app/dashboard/dashboard-hero.component.spec.ts (test with click helper)\">\nit(&#39;should raise selected event when clicked (click helper)&#39;, () =&gt; {\n  let selectedHero: Hero;\n  comp.selected.subscribe(hero =&gt; selectedHero = hero);\n\n  click(heroDe); // DebugElement로 클릭 헬퍼를 실행합니다.\n  click(heroEl); // 네이티브 엘리먼트로 클릭 헬퍼를 실행합니다.\n\n  expect(selectedHero).toBe(expectedHero);\n});\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"click-test-3\" header=\"app/dashboard/dashboard-hero.component.spec.ts (클릭 헬퍼를 사용하는 테스트 코드)\">\nit('should raise selected event when clicked (click helper)', () => {\n  let selectedHero: Hero;\n  comp.selected.subscribe(hero => selectedHero = hero);\n\n  click(heroDe); // <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>로 클릭 헬퍼를 실행합니다.\n  click(heroEl); // 네이티브 엘리먼트로 클릭 헬퍼를 실행합니다.\n\n  expect(selectedHero).toBe(expectedHero);\n});\n\n</code-example>\n<hr>\n<a id=\"component-inside-test-host\"></a>\n<!--\n### Component inside a test host\n-->\n<h3 id=\"테스트-호스트-안에서-테스트하기\">테스트 호스트 안에서 테스트하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#테스트-호스트-안에서-테스트하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe previous tests played the role of the host `DashboardComponent` themselves.\nBut does the `DashboardHeroComponent` work correctly when properly data-bound to a host component?\n\nYou could test with the actual `DashboardComponent`.\nBut doing so could require a lot of setup,\nespecially when its template features an `*ngFor` repeater,\nother components, layout HTML, additional bindings,\na constructor that injects multiple services,\nand it starts interacting with those services right away.\n\nImagine the effort to disable these distractions, just to prove a point\nthat can be made satisfactorily with a _test host_ like this one:\n-->\n<p>위에서 살펴본 테스트 코드는 테스트 코드 자체가 호스트 컴포넌트 <code>DashboardComponent</code>의 역할을 대신합니다.\n그런데 호스트 컴포넌트와 직접 데이터 바인딩 되는 경우에도 <code>DashboardHeroComponent</code>가 제대로 동작한다고 수 있을까요?</p>\n<p>이 의문점을 확인하려면 실제 <code>DashboardComponent</code>로 <code>DashboardHeroComponent</code>를 테스트해야 합니다.\n하지만 <code>DashboardComponent</code>를 사용해서 테스트하는 과정이 쉽지만은 않습니다.\n템플릿에는 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 리피터가 사용되었고, 다른 컴포넌트가 존재할 수도 있습니다.\nHTML 레이아웃이나 바인딩을 처리해야 할 수도 있고 생성자로 여러개의 서비스가 주입될 수도 있으며, 컴포넌트가 시작된 직후에 이 서비스들과 상호작용이 시작될 수도 있습니다.</p>\n<p>이 내용을 모두 준비하기 보다는, 다음과 같이 딱 필요한 기능만 구현한 <em>테스트 호스트</em> 를 사용하는 편이 더 좋습니다:</p>\n<!--\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"test-host\" header=\"app/dashboard/dashboard-hero.component.spec.ts (test host)\" linenums=\"false\">\n@Component({\n  template: `\n    &lt;dashboard-hero\n      [hero]=&quot;hero&quot; (selected)=&quot;onSelected($event)&quot;&gt;\n    &lt;/dashboard-hero&gt;`\n})\nclass TestHostComponent {\n  hero: Hero = {id: 42, name: &#39;Test Name&#39; };\n  selectedHero: Hero;\n  onSelected(hero: Hero) { this.selectedHero = hero; }\n}\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"test-host\" header=\"app/dashboard/dashboard-hero.component.spec.ts (테스트 호스트)\" linenums=\"false\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n    &#x3C;dashboard-hero\n      [hero]=\"hero\" (selected)=\"onSelected($event)\">\n    &#x3C;/dashboard-hero>`\n})\nclass TestHostComponent {\n  hero: Hero = {id: 42, name: 'Test Name' };\n  selectedHero: Hero;\n  onSelected(hero: Hero) { this.selectedHero = hero; }\n}\n\n</code-example>\n<!--\nThis test host binds to `DashboardHeroComponent` as the `DashboardComponent` would\nbut without the noise of the `Router`, the `HeroService`, or the `*ngFor` repeater.\n\nThe test host sets the component's `hero` input property with its test hero.\nIt binds the component's `selected` event with its `onSelected` handler,\nwhich records the emitted hero in its `selectedHero` property.\n\nLater, the tests will be able to easily check `selectedHero` to verify that the\n`DashboardHeroComponent.selected` event emitted the expected hero.\n\nThe setup for the _test-host_ tests is similar to the setup for the stand-alone tests:\n-->\n<p>이 테스트 호스트는 <code>DashboardComponent</code>가 하는 역할처럼 <code>DashboardHeroComponent</code>의 프로퍼티를 바인딩하지만, <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>나 <code>HeroService</code>, <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 리피터의 영향을 받지 않는 컴포넌트입니다.</p>\n<p>테스트 호스트는 자식 컴포넌트의 <code>hero</code> 입력 프로퍼티로 테스트 히어로 객체를 바인딩합니다.\n그리고 자식 컴포넌트의 <code>selected</code> 이벤트를 바인딩해서 <code>onSelected</code> 핸들러와 연결하기 때문에, 이 핸들러로 받은 이벤트 객체를 <code>selectedHero</code> 프로퍼티에 할당해서 확인할 수 있습니다.</p>\n<p><em>테스트 호스트</em> 로 컴포넌트를 테스트하는 환경은 컴포넌트를 단독으로 테스트하는 환경과 비슷합니다:</p>\n<!--\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"test-host-setup\" header=\"app/dashboard/dashboard-hero.component.spec.ts (test host setup)\" linenums=\"false\">\nTestBed.configureTestingModule({\n  declarations: [ DashboardHeroComponent, TestHostComponent ]\n})\n// DashboardHeroComponent 대신 TestHostComponent를 생성합니다.\nfixture  = TestBed.createComponent(TestHostComponent);\ntestHost = fixture.componentInstance;\nheroEl   = fixture.nativeElement.querySelector(&#39;.hero&#39;);\nfixture.detectChanges(); // 초기 데이터 바인딩을 실행합니다.\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"test-host-setup\" header=\"app/dashboard/dashboard-hero.component.spec.ts (테스트 호스트 환경설정)\" linenums=\"false\">\nTestBed.configureTestingModule({\n  <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [ DashboardHeroComponent, TestHostComponent ]\n})\n// DashboardHeroComponent 대신 TestHostComponent를 생성합니다.\nfixture  = TestBed.createComponent(TestHostComponent);\ntestHost = fixture.componentInstance;\nheroEl   = fixture.nativeElement.querySelector('.hero');\nfixture.detectChanges(); // 초기 데이터 바인딩을 실행합니다.\n\n</code-example>\n<!--\nThis testing module configuration shows three important differences:\n\n1. It _declares_ both the `DashboardHeroComponent` and the `TestHostComponent`.\n1. It _creates_ the `TestHostComponent` instead of the `DashboardHeroComponent`.\n1. The `TestHostComponent` sets the `DashboardHeroComponent.hero` with a binding.\n\nThe `createComponent` returns a `fixture` that holds an instance of `TestHostComponent` instead of an instance of `DashboardHeroComponent`.\n\nCreating the `TestHostComponent` has the side-effect of creating a `DashboardHeroComponent`\nbecause the latter appears within the template of the former.\nThe query for the hero element (`heroEl`) still finds it in the test DOM,\nalbeit at greater depth in the element tree than before.\n\nThe tests themselves are almost identical to the stand-alone version:\n-->\n<p>이 모듈 설정 중에 이전과 다른 부분이 세 군데 있습니다:</p>\n<ol>\n<li><code>DashboardHeroComponent</code>를 등록하면서 <code>TestHostComponent</code>도 함께 등록합니다.</li>\n<li><code>DashboardHeroComponent</code> 대신 <code>TestHostComponent</code>를 생성합니다.</li>\n<li><code>DashboardHeroComponent.hero</code> 프로퍼티는 <code>TestHostComponent</code>가 바인딩해서 할당합니다.</li>\n</ol>\n<p>이제 <code>createComponent</code>를 실행하면 <code>DashboardHeroComponent</code> 대신 <code>TestHostComponent</code>의 <code>fixture</code>를 반환합니다.</p>\n<p>그러면 <code>TestHostComponent</code>의 템플릿 안에 <code>DashboardHeroComponent</code>가 사용되었기 때문에 <code>DashboardHeroComponent</code>의 인스턴스도 함께 생성됩니다.\n그래서 히어로 엘리먼트를 쿼리한 변수 <code>heroEl</code>도 여전히 테스트 DOM에 존재합니다.\n다만, 엘리먼트 트리 계층으로 보면 이전보다 조금 더 깊은 곳에 있습니다.</p>\n<p>테스트 호스트와 <code>DashboardHeroComponent</code>를 테스트하는 로직은 <code>DashboardHeroComponent</code>를 단독으로 테스트할 때와 거의 비슷합니다:</p>\n<!--\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"test-host-tests\" header=\"app/dashboard/dashboard-hero.component.spec.ts (test-host)\" linenums=\"false\">\nit(&#39;should display hero name&#39;, () =&gt; {\n  const expectedPipedName = testHost.hero.name.toUpperCase();\n  expect(heroEl.textContent).toContain(expectedPipedName);\n});\n\nit(&#39;should raise selected event when clicked&#39;, () =&gt; {\n  click(heroEl);\n  // 선택된 히어로는 데이터 바인딩한 히어로와 같아야 합니다.\n  expect(testHost.selectedHero).toBe(testHost.hero);\n});\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"test-host-tests\" header=\"app/dashboard/dashboard-hero.component.spec.ts (테스트 호스트)\" linenums=\"false\">\nit('should display hero name', () => {\n  const expectedPipedName = testHost.hero.name.toUpperCase();\n  expect(heroEl.textContent).toContain(expectedPipedName);\n});\n\nit('should raise selected event when clicked', () => {\n  click(heroEl);\n  // 선택된 히어로는 데이터 바인딩한 히어로와 같아야 합니다.\n  expect(testHost.selectedHero).toBe(testHost.hero);\n});\n\n</code-example>\n<!--\nOnly the selected event test differs. It confirms that the selected `DashboardHeroComponent` hero\nreally does find its way up through the event binding to the host component.\n-->\n<p>이전과 비교하면 히어로 선택 이벤트를 검사하는 부분만 다릅니다.\n이 테스트 코드에서는 <code>DashboardHeroComponent</code>에서 사용자가 선택해서 이벤트로 전달된 히어로 객체와 호스트 컴포넌트가 데이터 바인딩하면서 전달했던 히어로 객체가 같은지 검사하도록 작성했습니다.</p>\n<hr>\n<a id=\"routing-component\"></a>\n<!--\n### Routing component\n-->\n<h3 id=\"라우팅하는-컴포넌트\">라우팅하는 컴포넌트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#라우팅하는-컴포넌트\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nA _routing component_ is a component that tells the `Router` to navigate to another component.\nThe `DashboardComponent` is a _routing component_ because the user can\nnavigate to the `HeroDetailComponent` by clicking on one of the _hero buttons_ on the dashboard.\n\nRouting is pretty complicated.\nTesting the `DashboardComponent` seemed daunting in part because it involves the `Router`,\nwhich it injects together with the `HeroService`.\n-->\n<p><em>라우팅하는 컴포넌트(routing component)</em> 는 컴포넌트가 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>를 사용해서 다른 컴포넌트로 이동하는 컴포넌트입니다.\n그래서 사용자가 대시보드에 있는 <em>히어로 버튼</em> 중 하나를 클릭하면 <code>HeroDetailComponent</code>로 페이지를 전환하기 때문에 <code>DashboardComponent</code>도 라우팅하는 컴포넌트입니다.</p>\n<p>라우팅은 조금 복잡합니다.\n게다가 <code>DashboardComponent</code>처럼 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>만이 아니라 <code>HeroService</code>도 함께 주입되는 컴포넌트를 테스트해야 한다면 시작할 엄두가 나지 않을 수도 있습니다.</p>\n<!--\n<code-example path=\"testing/src/app/dashboard/dashboard.component.ts\" region=\"ctor\" header=\"app/dashboard/dashboard.component.ts (constructor)\" linenums=\"false\">\nconstructor(\n  private router: Router,\n  private heroService: HeroService) {\n}\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/dashboard/dashboard.component.ts\" region=\"ctor\" header=\"app/dashboard/dashboard.component.ts (생성자)\" linenums=\"false\">\nconstructor(\n  private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,\n  private heroService: HeroService) {\n}\n\n</code-example>\n<!--\nMocking the `HeroService` with a spy is a [familiar story](#component-with-async-service).\nBut the `Router` has a complicated API and is entwined with other services and application preconditions. Might it be difficult to mock?\n\nFortunately, not in this case because the `DashboardComponent` isn't doing much with the `Router`\n-->\n<p><code>HeroService</code>를 모킹하는 것은 <a href=\"guide/testing#component-with-async-service\">이전에 다뤘기 때문에</a> 이제 익숙할 것입니다.\n하지만 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>의 API는 더 복잡하고, 다른 서비스와도 엮여있으며, 애플리케이션의 상태에 따라 동작이 달라지기도 합니다.\n라우터를 모킹하는 것이 얼마나 어려운지 짐작할 수 있을까요?</p>\n<p>하지만 다행히도 <code>DashboardComponent</code>를 테스트하면서 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>의 기능을 모두 모킹할 필요는 없습니다.</p>\n<code-example path=\"testing/src/app/dashboard/dashboard.component.ts\" region=\"goto-detail\" header=\"app/dashboard/dashboard.component.ts (goToDetail)\">\ngotoDetail(hero: Hero) {\n  let url = `/heroes/${hero.id}`;\n  this.router.navigateByUrl(url);\n}\n\n</code-example>\n<!--\nThis is often the case with _routing components_.\nAs a rule you test the component, not the router,\nand care only if the component navigates with the right address under the given conditions.\n\nProviding a router spy for _this component_ test suite happens to be as easy\nas providing a `HeroService` spy.\n-->\n<p><em>컴포넌트의 라우팅 동작</em> 은 보통 이렇게 구현합니다.\n그리고 지금 컴포넌트를 테스트하면서 검사해야 하는 것은 라우터가 아니라 컴포넌트가 올바른 주소로 이동하는지 테스트하는 것입니다.</p>\n<p>그러면 <code>HeroService</code> 스파이를 활용했던 것처럼, <em>이 컴포넌트</em> 에 꼭 필요한 기능만 구현한 라우터 스파이를 활용하는 것이 더 편합니다.</p>\n<!--\n<code-example path=\"testing/src/app/dashboard/dashboard.component.spec.ts\" region=\"router-spy\" header=\"app/dashboard/dashboard.component.spec.ts (spies)\" linenums=\"false\">\nconst routerSpy = jasmine.createSpyObj(&#39;Router&#39;, [&#39;navigateByUrl&#39;]);\nconst heroServiceSpy = jasmine.createSpyObj(&#39;HeroService&#39;, [&#39;getHeroes&#39;]);\n\nTestBed.configureTestingModule({\n  providers: [\n    { provide: HeroService, useValue: heroServiceSpy },\n    { provide: Router,      useValue: routerSpy }\n  ]\n})\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/dashboard/dashboard.component.spec.ts\" region=\"router-spy\" header=\"app/dashboard/dashboard.component.spec.ts (테스트 스파이)\" linenums=\"false\">\nconst routerSpy = jasmine.createSpyObj('<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>', ['navigateByUrl']);\nconst heroServiceSpy = jasmine.createSpyObj('HeroService', ['getHeroes']);\n\nTestBed.configureTestingModule({\n  providers: [\n    { provide: HeroService, useValue: heroServiceSpy },\n    { provide: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,      useValue: routerSpy }\n  ]\n})\n\n</code-example>\n<!--\nThe following test clicks the displayed hero and confirms that\n`Router.navigateByUrl` is called with the expected url.\n-->\n<p>화면에 표시된 히어로를 클릭하면 원하는 주소로 이동하기 위해 <code>Router.navigateByUrl</code>을 실행하는데, 이 과정을 테스트하는 코드는 다음과 같이 작성할 수 있습니다.</p>\n<!--\n<code-example path=\"testing/src/app/dashboard/dashboard.component.spec.ts\" region=\"navigate-test\" header=\"app/dashboard/dashboard.component.spec.ts (navigate test)\" linenums=\"false\">\nit(&#39;should tell ROUTER to navigate when hero clicked&#39;, () =&gt; {\n\n  heroClick(); // &lt;div class=&quot;hero&quot;&gt; 엘리먼트 중 첫번째 엘리먼트를 클릭합니다.\n\n  // 컴포넌트가 이동하는 주소는 router.navigateByUrl() 스파이의 인자로 전달됩니다.\n  const spy = router.navigateByUrl as jasmine.Spy;\n  const navArgs = spy.calls.first().args[0];\n\n  // 이동하려는 주소가 컴포넌트의 히어로 목록 중 첫번째의 id와 같은지 검사합니다.\n  const id = comp.heroes[0].id;\n  expect(navArgs).toBe(&#39;/heroes/&#39; + id,\n    &#39;should nav to HeroDetail for first hero&#39;);\n});\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/dashboard/dashboard.component.spec.ts\" region=\"navigate-test\" header=\"app/dashboard/dashboard.component.spec.ts (네비게이션 테스트)\" linenums=\"false\">\nit('should tell ROUTER to navigate when hero clicked', () => {\n\n  heroClick(); // &#x3C;div class=\"hero\"> 엘리먼트 중 첫번째 엘리먼트를 클릭합니다.\n\n  // 컴포넌트가 이동하는 주소는 router.navigateByUrl() 스파이의 인자로 전달됩니다.\n  const spy = router.navigateByUrl as jasmine.Spy;\n  const navArgs = spy.calls.first().args[0];\n\n  // 이동하려는 주소가 컴포넌트의 히어로 목록 중 첫번째의 id와 같은지 검사합니다.\n  const id = comp.heroes[0].id;\n  expect(navArgs).toBe('/heroes/' + id,\n    'should nav to HeroDetail for first hero');\n});\n\n</code-example>\n<a id=\"routed-component-w-param\"></a>\n<!--\n### Routed components\n-->\n<h3 id=\"라우팅-대상이-되는-컴포넌트\">라우팅 대상이 되는 컴포넌트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#라우팅-대상이-되는-컴포넌트\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nA _routed component_ is the destination of a `Router` navigation.\nIt can be trickier to test, especially when the route to the component _includes parameters_.\nThe `HeroDetailComponent` is a _routed component_ that is the destination of such a route.\n\nWhen a user clicks a _Dashboard_ hero, the `DashboardComponent` tells the `Router`\nto navigate to `heroes/:id`.\nThe `:id` is a route parameter whose value is the `id` of the hero to edit.\n\nThe `Router` matches that URL to a route to the `HeroDetailComponent`.\nIt creates an `ActivatedRoute` object with the routing information and\ninjects it into a new instance of the `HeroDetailComponent`.\n\nHere's the `HeroDetailComponent` constructor:\n-->\n<p><em>라우팅 대상이 되는 컴포넌트(routed component)</em> 는 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>로 페이지를 전환할 때 대상이 되는 컴포넌트입니다.\n이런 컴포넌트는 일반 컴포넌트보다 테스트하기 조금 더 까다로운데, 라우팅하면서 변수를 전달한다면 더 그렇습니다.</p>\n<p>사용자가 <em>대시보드에서</em> 히어로를 클릭하면 <code>DashboardComponent</code>는 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>를 사용해서 <code>heroes/:id</code> 주소로 페이지를 전환합니다.\n이 때 <code>:id</code>는 라우팅 변수이며, 이 변수는 전환되는 페이지에서 <code>id</code>로 받아서 수정할 히어로 인스턴스를 가져올 때 사용합니다.</p>\n<p><code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>는 URL을 기준으로 <code>HeroDetailComponent</code>로 이동할지 판단합니다.\n이 때 라우팅 정보를 담는 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 객체를 생성하는데, 이 객체는 새로 생성되는 <code>HeroDetailComponent</code>의 인스턴스에 주입됩니다.</p>\n<p><code>HeroDetailComponent</code>의 생성자는 이렇습니다:</p>\n<!--\n<code-example path=\"testing/src/app/hero/hero-detail.component.ts\" region=\"ctor\" header=\"app/hero/hero-detail.component.ts (constructor)\" linenums=\"false\">\nconstructor(\n  private heroDetailService: HeroDetailService,\n  private route:  ActivatedRoute,\n  private router: Router) {\n}\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/hero/hero-detail.component.ts\" region=\"ctor\" header=\"app/hero/hero-detail.component.ts (생성자)\" linenums=\"false\">\nconstructor(\n  private heroDetailService: HeroDetailService,\n  private route:  <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>,\n  private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {\n}\n\n</code-example>\n<!--\nThe `HeroDetail` component needs the `id` parameter so it can fetch\nthe corresponding hero via the `HeroDetailService`.\nThe component has to get the `id` from the `ActivatedRoute.paramMap` property\nwhich is an `Observable`.\n\nIt can't just reference the `id` property of the `ActivatedRoute.paramMap`.\nThe component has to _subscribe_ to the `ActivatedRoute.paramMap` observable and be prepared\nfor the `id` to change during its lifetime.\n-->\n<p><code>HeroDetail</code> 컴포넌트는 <code>HeroDetailService</code>를 사용해서 히어로의 정보를 가져와야 하는데, 이 때 히어로를 구분할 <code>id</code>가 필요합니다.\n그래서 컴포넌트는 <code>Observable</code> 타입으로 제공되는 <code><a href=\"api/router/ActivatedRoute#paramMap\" class=\"code-anchor\">ActivatedRoute.paramMap</a></code> 프로퍼티에서 <code>id</code>를 참조해야 합니다.</p>\n<p>하지만 <code><a href=\"api/router/ActivatedRoute#paramMap\" class=\"code-anchor\">ActivatedRoute.paramMap</a></code>에 <code>id</code> 프로퍼티가 바로 존재하는 것은 아닙니다.\n<code><a href=\"api/router/ActivatedRoute#paramMap\" class=\"code-anchor\">ActivatedRoute.paramMap</a></code>은 옵저버블 타입으로 제공되기 때문에 이 프로퍼티를 <em>구독</em> 해야 <code>id</code>를 참조할 수 있으며, 옵저버블이기 때문에 이 프로퍼티를 구독하면 값이 변경되는 것도 감지할 수 있습니다.</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.ts\" region=\"ng-on-init\" header=\"app/hero/hero-detail.component.ts (ngOnInit)\" linenums=\"false\">\nngOnInit(): void {\n  // `id` 인자가 바뀔때마다 히어로 객체를 가져옵니다.\n  this.route.paramMap.subscribe(pmap => this.getHero(pmap.get('id')));\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\nThe [Router](guide/router#route-parameters) guide covers `ActivatedRoute.paramMap` in more detail.\n-->\n<p><code><a href=\"api/router/ActivatedRoute#paramMap\" class=\"code-anchor\">ActivatedRoute.paramMap</a></code>은 <a href=\"guide/router#route-parameters\">Router</a> 문서에서 자세하게 다룹니다.</p>\n</div>\n<!--\nTests can explore how the `HeroDetailComponent` responds to different `id` parameter values\nby manipulating the `ActivatedRoute` injected into the component's constructor.\n\nYou know how to spy on the `Router` and a data service.\n\nYou'll take a different approach with `ActivatedRoute` because\n\n- `paramMap` returns an `Observable` that can emit more than one value\n  during a test.\n- You need the router helper function, `convertToParamMap()`, to create a `ParamMap`.\n- Other _routed components_ tests need a test double for `ActivatedRoute`.\n\nThese differences argue for a re-usable stub class.\n-->\n<p>컴포넌트의 생성자로 주입되는 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>를 조작하면 <code>id</code> 변수가 변경되었을 때 <code>HeroDetailComponent</code>가 어떻게 반응하는지 테스트할 수 있습니다.</p>\n<p><code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>와 데이터 서비스를 스파이로 대체하는 방법은 이전 예제에서 이미 알아봤습니다.</p>\n<p>하지만 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>는 조금 다르게 사용해야 합니다. 왜냐하면,</p>\n<ul>\n<li><code>paramMap</code>은 테스트 중에 여러번 값을 변경할 수 있도록 <code>Observable</code> 타입이어야 합니다.</li>\n<li><code><a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a></code> 타입을 생성하기 위해 라우터 헬퍼 함수 <code><a href=\"api/router/convertToParamMap\" class=\"code-anchor\">convertToParamMap</a>()</code>이 필요합니다.</li>\n<li><em>라우팅 대상이 되는 컴포넌트</em> 의 로직을 테스트하려면 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>에 대한 목 객체가 필요합니다.</li>\n</ul>\n<p>이 요건을 만족시키기 위해 재사용할 수 있는 클래스를 정의하는 것부터 시작합시다.</p>\n<h4 id=\"activatedroutestub\"><em>ActivatedRouteStub</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#activatedroutestub\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe following `ActivatedRouteStub` class serves as a test double for `ActivatedRoute`.\n-->\n<p>아래 <code>ActivatedRouteStub</code> 클래스는 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 클래스를 대체하는 목 클래스입니다.</p>\n<code-example path=\"testing/src/testing/activated-route-stub.ts\" region=\"activated-route-stub\" header=\"testing/activated-route-stub.ts (ActivatedRouteStub)\" linenums=\"false\">\nimport { <a href=\"api/router/convertToParamMap\" class=\"code-anchor\">convertToParamMap</a>, <a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a>, <a href=\"api/router/Params\" class=\"code-anchor\">Params</a> } from '@angular/router';\nimport { ReplaySubject } from 'rxjs';\n\n/**\n * `paramMap` 옵저버블을 제공하는 <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> 클래스의 목 클래스를 정의합니다.\n * `paramMap`으로 데이터를 보낼 때는 `setParamMap()` 메소드를 활용합니다.\n */\nexport class ActivatedRouteStub {\n  // 구독자가 이전 값을 참조할 수 있도록 ReplaySubject를 사용합니다.\n  // `paramMap` 옵저버블로 제공되는 데이터도 이 객체로 전달됩니다.\n  private subject = new ReplaySubject&#x3C;<a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a>>();\n\n  constructor(initialParams?: <a href=\"api/router/Params\" class=\"code-anchor\">Params</a>) {\n    this.setParamMap(initialParams);\n  }\n\n  /** 목 paramMap 옵저버블 */\n  readonly paramMap = this.subject.asObservable();\n\n  /** paramMap 옵저버블로 데이터를 전달합니다. */\n  setParamMap(params?: <a href=\"api/router/Params\" class=\"code-anchor\">Params</a>) {\n    this.subject.next(<a href=\"api/router/convertToParamMap\" class=\"code-anchor\">convertToParamMap</a>(params));\n  };\n}\n\n</code-example>\n<!--\nConsider placing such helpers in a `testing` folder sibling to the `app` folder.\nThis sample puts `ActivatedRouteStub` in `testing/activated-route-stub.ts`.\n-->\n<p>이런 종류의 헬퍼는 <code>app</code> 폴더와 같은 계층에 <code>testing</code> 폴더를 만들고 이 폴더 안에 두는 것이 좋습니다.\n그래서 <code>ActivatedRouteStub</code> 클래스도 <code>testing/activated-route-stub.ts</code> 파일에 존재합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nConsider writing a more capable version of this stub class with\nthe [_marble testing library_](#marble-testing).\n-->\n<p><a href=\"guide/testing#marble-testing\"><em>마블 테스트 라이브러리</em></a>를 활용하면 더 다양하게 활용할 수 있는 목 클래스를 정의할 수 있습니다.</p>\n</div>\n<a id=\"tests-w-test-double\"></a>\n<!--\n#### Testing with _ActivatedRouteStub_\n-->\n<h4 id=\"activatedroutestub-로-테스트하기\"><em>ActivatedRouteStub</em> 로 테스트하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#activatedroutestub-로-테스트하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nHere's a test demonstrating the component's behavior when the observed `id` refers to an existing hero:\n-->\n<p><code>HeroDetailComponent</code>가 히어로 중 한 명의 <code>id</code>를 받았을 때 실행해야 하는 동작은 다음 테스트 코드로 검사할 수 있습니다.</p>\n<!--\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"route-good-id\" header=\"app/hero/hero-detail.component.spec.ts (existing id)\" linenums=\"false\">\ndescribe(&#39;when navigate to existing hero&#39;, () =&gt; {\n  let expectedHero: Hero;\n\n  beforeEach(async(() =&gt; {\n    expectedHero = firstHero;\n    activatedRoute.setParamMap({ id: expectedHero.id });\n    createComponent();\n  }));\n\n  it(&#39;should display that hero\\&#39;s name&#39;, () =&gt; {\n    expect(page.nameDisplay.textContent).toBe(expectedHero.name);\n  });\n});\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"route-good-id\" header=\"app/hero/hero-detail.component.spec.ts (id가 존재할 때)\" linenums=\"false\">\ndescribe('when navigate to existing hero', () => {\n  let expectedHero: Hero;\n\n  beforeEach(<a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>(() => {\n    expectedHero = firstHero;\n    activatedRoute.setParamMap({ id: expectedHero.id });\n    createComponent();\n  }));\n\n  it('should display that hero\\'s name', () => {\n    expect(page.nameDisplay.textContent).toBe(expectedHero.name);\n  });\n});\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\nThe `createComponent()` method and `page` object are discussed [below](#page-object).\nRely on your intuition for now.\n-->\n<p><code>createComponent()</code> 메소드와 <code>page</code> 객체는 <a href=\"guide/testing#page-object\">아래</a>에서 자세하게 다룹니다.\n지금은 이 메소드와 객체가 어떤 것인지 짐작하는 것만으로 충분합니다.</p>\n</div>\n<!--\nWhen the `id` cannot be found, the component should re-route to the `HeroListComponent`.\n\nThe test suite setup provided the same router spy [described above](#routing-component) which spies on the router without actually navigating.\n\nThis test expects the component to try to navigate to the `HeroListComponent`.\n-->\n<p><code>HeroDetailComponent</code>는 히어로의 목록에 <code>id</code> 값에 해당되는 히어로가 없으면 <code>HeroListComponent</code>로 다시 페이지를 전환해야 합니다.</p>\n<p>이 테스트 스윗은 <a href=\"guide/testing#routing-component\">위에서 설명한</a> 라우터 스파이를 사용하기 때문에 실제 네비게이션 동작이 실행되지는 않습니다.</p>\n<p>다만, 이 테스트 스펙은 <code>HeroListComponent</code>로 전환하려고 시도하는 동작 자체를 검사합니다.</p>\n<!--\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"route-bad-id\" header=\"app/hero/hero-detail.component.spec.ts (bad id)\" linenums=\"false\">\ndescribe(&#39;when navigate to non-existent hero id&#39;, () =&gt; {\n  beforeEach(async(() =&gt; {\n    activatedRoute.setParamMap({ id: 99999 });\n    createComponent();\n  }));\n\n  it(&#39;should try to navigate back to hero list&#39;, () =&gt; {\n    expect(page.gotoListSpy.calls.any()).toBe(true, &#39;comp.gotoList called&#39;);\n    expect(page.navigateSpy.calls.any()).toBe(true, &#39;router.navigate called&#39;);\n  });\n});\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"route-bad-id\" header=\"app/hero/hero-detail.component.spec.ts (id가 존재하지 않을 때)\" linenums=\"false\">\ndescribe('when navigate to non-existent hero id', () => {\n  beforeEach(<a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>(() => {\n    activatedRoute.setParamMap({ id: 99999 });\n    createComponent();\n  }));\n\n  it('should try to navigate back to hero list', () => {\n    expect(page.gotoListSpy.calls.any()).toBe(true, 'comp.gotoList called');\n    expect(page.navigateSpy.calls.any()).toBe(true, 'router.navigate called');\n  });\n});\n\n</code-example>\n<!--\nWhile this app doesn't have a route to the `HeroDetailComponent` that omits the `id` parameter, it might add such a route someday.\nThe component should do something reasonable when there is no `id`.\n\nIn this implementation, the component should create and display a new hero.\nNew heroes have `id=0` and a blank `name`. This test confirms that the component behaves as expected:\n-->\n<p>아직까지는 <code>HeroDetailComponent</code>로 라우팅할 때 잘못된 <code>id</code>가 전달되어도 애플리케이션에서 처리하는 로직은 없지만, 이런 경우를 처리하는 로직이 조만간 들어가야 한다고 합시다.\n그러면 결국 <code>id</code>에 해당하는 히어로가 없을 때 컴포넌트가 뭔가 의미있는 동작을 해야 합니다.</p>\n<p>지금 구현하는 테스트 코드에서는 라우팅 변수로 전달된 <code>id</code>에 해당하는 히어로를 찾지 못했을 때 새로운 히어로를 만들도록 합시다.\n새로운 히어로의 <code>id</code>는 <code>0</code>이며, <code>name</code>은 빈 값으로 시작합니다.\n그러면 테스트 코드를 다음과 같이 작성할 수 있습니다:</p>\n<!--\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"route-no-id\" header=\"app/hero/hero-detail.component.spec.ts (no id)\" linenums=\"false\">\ndescribe(&#39;when navigate with no hero id&#39;, () =&gt; {\n  beforeEach(async( createComponent ));\n\n  it(&#39;should have hero.id === 0&#39;, () =&gt; {\n    expect(component.hero.id).toBe(0);\n  });\n\n  it(&#39;should display empty hero name&#39;, () =&gt; {\n    expect(page.nameDisplay.textContent).toBe(&#39;&#39;);\n  });\n});\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"route-no-id\" header=\"app/hero/hero-detail.component.spec.ts (id가 존재하지 않을 때)\" linenums=\"false\">\ndescribe('when navigate with no hero id', () => {\n  beforeEach(<a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>( createComponent ));\n\n  it('should have hero.id === 0', () => {\n    expect(component.hero.id).toBe(0);\n  });\n\n  it('should display empty hero name', () => {\n    expect(page.nameDisplay.textContent).toBe('');\n  });\n});\n\n</code-example>\n<hr>\n<!--\n### Nested component tests\n-->\n<h3 id=\"중첩된-컴포넌트-테스트\">중첩된 컴포넌트 테스트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#중첩된-컴포넌트-테스트\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nComponent templates often have nested components, whose templates\nmay contain more components.\n\nThe component tree can be very deep and, most of the time, the nested components\nplay no role in testing the component at the top of the tree.\n\nThe `AppComponent`, for example, displays a navigation bar with anchors and their `RouterLink` directives.\n-->\n<p>컴포넌트 템플릿에는 자식 컴포넌트가 존재할 수 있으며, 그 컴포넌트에는 또 다른 자식 컴포넌트가 존재할 수 있습니다.</p>\n<p>컴포넌트 트리는 얼마든지 복잡해질 수 있는데, 컴포넌트를 테스트하는 상황에서 중첩된 자식 컴포넌트들은 별로 중요하지 않은 경우가 많습니다.</p>\n<p><code>AppComponent</code>의 경우를 생각해보면, 이 컴포넌트에는 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 디렉티브가 사용된 앵커가 여러개 있습니다.</p>\n<code-example path=\"testing/src/app/app.component.html\" header=\"app/app.component.html\" linenums=\"false\">\n&#x3C;app-banner>&#x3C;/app-banner>\n&#x3C;app-welcome>&#x3C;/app-welcome>\n&#x3C;nav>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/dashboard\">Dashboard&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/heroes\">Heroes&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/about\">About&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n&#x3C;/nav>\n&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n\n\n</code-example>\n<!--\nWhile the `AppComponent` _class_ is empty,\nyou may want to write unit tests to confirm that the links are wired properly\nto the `RouterLink` directives, perhaps for the reasons [explained below](#why-stubbed-routerlink-tests).\n\nTo validate the links, you don't need the `Router` to navigate and you don't\nneed the `<router-outlet>` to mark where the `Router` inserts _routed components_.\n\nThe `BannerComponent` and `WelcomeComponent`\n(indicated by `<app-banner>` and `<app-welcome>`) are also irrelevant.\n\nYet any test that creates the `AppComponent` in the DOM will also create instances of\nthese three components and, if you let that happen,\nyou'll have to configure the `TestBed` to create them.\n\nIf you neglect to declare them, the Angular compiler won't recognize the\n`<app-banner>`, `<app-welcome>`, and `<router-outlet>` tags in the `AppComponent` template\nand will throw an error.\n\nIf you declare the real components, you'll also have to declare _their_ nested components\nand provide for _all_ services injected in _any_ component in the tree.\n\nThat's too much effort just to answer a few simple questions about links.\n\nThis section describes two techniques for minimizing the setup.\nUse them, alone or in combination, to stay focused on the testing the primary component.\n-->\n<p><code>AppComponent</code>의 <em>클래스</em> 에는 아무 내용이 없지만, 이 컴포넌트를 대상으로 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 디렉티브가 사용된 링크가 제대로 동작하는지 유닛 테스트를 작성하고 싶을 수 있습니다.\n구체적인 이유는 <a href=\"guide/testing#why-stubbed-routerlink-tests\">아래</a>에서 설명합니다.</p>\n<p>하지만 링크가 제대로 동작하는지 확인하기 위해 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 객체를 그대로 사용할 필요는 없으며, <em>라우팅 대상이 되는 컴포넌트</em> 가 들어갈 <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code>을 사용해야 할 필요도 없습니다.</p>\n<p>그리고 <code>AppComponent</code>를 테스트하면서 <code>BannerComponent</code>(<code>&#x3C;app-banner></code>)와 <code>WelcomeComponent</code>(<code>&#x3C;app-welcome></code>)를 신경쓸 필요도 없습니다.</p>\n<p>하지만 테스트 모듈에 <code>AppComponent</code>를 생성하려고 하면 의도하지 않았다고 해도 라우팅 대상이 되는 컴포넌트와 <code>BannerComponent</code>, <code>WelcomeComponent</code>를 모두 생성해야 합니다.</p>\n<p>이 과정이 필요없다고 생각해서 이 컴포넌트들을 <code><a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a></code> 배열에서 제거하면 Angular 컴파일러가 <code>&#x3C;app-banner></code>, <code>&#x3C;app-welcome></code>, <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code> 태그를 인식할 수 없기 때문에 <code>AppComponent</code> 템플릿을 컴파일 할 수 없어서 에러가 발생합니다.</p>\n<p>이 때 실제로 사용되는 컴포넌트를 등록한다면 이 컴포넌트 안에 존재하는 자식 컴포넌트와 <code>AppComponent</code>의 자식 컴포넌트 트리에 존재하는 <em>모든</em> 의존성 서비스를 프로바이더로 등록해야 하는 문제가 생깁니다.</p>\n<p>우리가 테스트하려고 하는 것은 <code>AppComponent</code>의 링크가 제대로 동작하는지 여부인데, 이렇게까지 해야 하는 것은 너무 번거로운 일이 아닐 수 없습니다.</p>\n<p>이번 섹션에서는 이런 환경을 설정할 때 필요한 노력을 최소화하는 방법에 대해 다룹니다.\n이번 섹션에서 다루는 내용을 활용하면 컴포넌트가 단독으로 존재하거나 자식 컴포넌트가 있는 것과 관계없이 테스트하려는 컴포넌트에만 집중할 수 있습니다.</p>\n<a id=\"stub-component\"></a>\n<!--\n##### Stubbing unneeded components\n-->\n<h5 id=\"필요없는-컴포넌트-목으로-대체하기\">필요없는 컴포넌트 목으로 대체하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#필요없는-컴포넌트-목으로-대체하기\"><i class=\"material-icons\">link</i></a></h5>\n<!--\nIn the first technique, you create and declare stub versions of the components\nand directive that play little or no role in the tests.\n-->\n<p>첫번째 방법은 테스트에 영향을 주지 않는 컴포넌트와 디렉티브를 목으로 만들어서 원래 컴포넌트나 디렉티브를 대체하는 방법입니다.</p>\n<!--\n<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"component-stubs\" header=\"app/app.component.spec.ts (stub declaration)\" linenums=\"false\">\n@Component({selector: &#39;app-banner&#39;, template: &#39;&#39;})\nclass BannerStubComponent {}\n\n@Component({selector: &#39;router-outlet&#39;, template: &#39;&#39;})\nclass RouterOutletStubComponent { }\n\n@Component({selector: &#39;app-welcome&#39;, template: &#39;&#39;})\nclass WelcomeStubComponent {}\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"component-stubs\" header=\"app/app.component.spec.ts (목 클래스 선언)\" linenums=\"false\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({selector: 'app-banner', <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: ''})\nclass BannerStubComponent {}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({selector: '<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>', <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: ''})\nclass RouterOutletStubComponent { }\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({selector: 'app-welcome', <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: ''})\nclass WelcomeStubComponent {}\n\n</code-example>\n<!--\nThe stub selectors match the selectors for the corresponding real components.\nBut their templates and classes are empty.\n\nThen declare them in the `TestBed` configuration next to the\ncomponents, directives, and pipes that need to be real.\n-->\n<p>이 때 목 컴포넌트의 셀렉터는 실제 컴포넌트의 셀렉터와 같지만, 템플릿과 클래스는 비어있습니다.</p>\n<p>이 컴포넌트들은 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 환경 설정에 등록해서 실제로 사용하는 컴포넌트를 대체합니다.\n디렉티브와 파이프도 모두 같은 방식으로 대체합니다.</p>\n<!--\n<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"testbed-stubs\" header=\"app/app.component.spec.ts (TestBed stubs)\" linenums=\"false\">\nTestBed.configureTestingModule({\n  declarations: [\n    AppComponent,\n    RouterLinkDirectiveStub,\n    BannerStubComponent,\n    RouterOutletStubComponent,\n    WelcomeStubComponent\n  ]\n})\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"testbed-stubs\" header=\"app/app.component.spec.ts (TestBed 설정)\" linenums=\"false\">\nTestBed.configureTestingModule({\n  <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [\n    AppComponent,\n    RouterLinkDirectiveStub,\n    BannerStubComponent,\n    RouterOutletStubComponent,\n    WelcomeStubComponent\n  ]\n})\n\n</code-example>\n<!--\nThe `AppComponent` is the test subject, so of course you declare the real version.\n\nThe `RouterLinkDirectiveStub`, [described later](#routerlink), is a test version\nof the real `RouterLink` that helps with the link tests.\n\nThe rest are stubs.\n-->\n<p>물론 <code>AppComponent</code>는 테스트해야 하는 대상이기 때문에 이 컴포넌트는 실제 컴포넌트를 등록해야 합니다.</p>\n<p>이 코드에 사용된 <code>RouterLinkDirectiveStub</code>는 링크에 사용된 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>를 대체하는 클래스입니다. 이 클래스는 <a href=\"guide/testing#routerlink\">아래</a>에서 자세하게 다룹니다.</p>\n<p>이제 <code>AppComponent</code>를 제외한 모든 컴포넌트와 디렉티브는 목 클래스로 대체되었습니다.</p>\n<a id=\"no-errors-schema\"></a>\n<h4 id=\"no_errors_schema\"><em>NO_ERRORS_SCHEMA</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#no_errors_schema\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nIn the second approach, add `NO_ERRORS_SCHEMA` to the `TestBed.schemas` metadata.\n-->\n<p>또 다른 방법은 <code>TestBed.schemas</code> 메타데이터에 <code><a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a></code>를 추가하는 것입니다.</p>\n<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"no-errors-schema\" header=\"app/app.component.spec.ts (NO_ERRORS_SCHEMA)\" linenums=\"false\">\nTestBed.configureTestingModule({\n  <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [\n    AppComponent,\n    RouterLinkDirectiveStub\n  ],\n  <a href=\"api/core/NgModule#schemas\" class=\"code-anchor\">schemas</a>: [ <a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a> ]\n})\n\n</code-example>\n<!--\nThe `NO_ERRORS_SCHEMA` tells the Angular compiler to ignore unrecognized elements and attributes.\n\nThe compiler will recognize the `<app-root>` element and the `routerLink` attribute\nbecause you declared a corresponding `AppComponent` and `RouterLinkDirectiveStub`\nin the `TestBed` configuration.\n\nBut the compiler won't throw an error when it encounters `<app-banner>`, `<app-welcome>`, or `<router-outlet>`.\nIt simply renders them as empty tags and the browser ignores them.\n\nYou no longer need the stub components.\n-->\n<p><code><a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a></code>를 사용하면 확인되지 않은 엘리먼트와 어트리뷰트가 있더라도 Angular 컴파일러가 이것을 에러로 처리하지 않습니다.</p>\n<p>템플릿에 사용된 <code>&#x3C;app-root></code> 엘리먼트에는 <code>AppComponent</code>가 매칭되어야 하며, <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> 어트리뷰트에는 <code>RouterLinkDirectiveStub</code>가 매칭됩니다.\n이것은 모두 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>에 <code>AppComponent</code>와 <code>RouterLinkDirectiveStub</code>를 등록했기 때문입니다.</p>\n<p>그리고 이제는 <code><a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a></code>를 사용했기 때문에 Angular 컴파일러가 <code>&#x3C;app-banner></code>와 <code>&#x3C;app-welcome></code>, <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code> 엘리먼트에 해당하는 컴포넌트를 찾지 못해도 에러가 발생하지 않습니다.\n이 엘리먼트들은 모두 빈 태그로 대체되며 아무 역할도 하지 않습니다.</p>\n<p>이제는 목 컴포넌트들을 신경쓰지 않아도 됩니다.</p>\n<!--\n#### Use both techniques together\n-->\n<h4 id=\"두-가지-방법-함께-사용하기\">두 가지 방법 함께 사용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#두-가지-방법-함께-사용하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThese are techniques for _Shallow Component Testing_ ,\nso-named because they reduce the visual surface of the component to just those elements\nin the component's template that matter for tests.\n\nThe `NO_ERRORS_SCHEMA` approach is the easier of the two but don't overuse it.\n\nThe `NO_ERRORS_SCHEMA` also prevents the compiler from telling you about the missing\ncomponents and attributes that you omitted inadvertently or misspelled.\nYou could waste hours chasing phantom bugs that the compiler would have caught in an instant.\n\nThe _stub component_ approach has another advantage.\nWhile the stubs in _this_ example were empty,\nyou could give them stripped-down templates and classes if your tests\nneed to interact with them in some way.\n\nIn practice you will combine the two techniques in the same setup,\nas seen in this example.\n-->\n<p>위에서 설명한 두 테크닉은 모두 테스트하려는 컴포넌트 외의 구성요소를 모두 다른 것으로 대체해서 테스트 코드를 간단하게 만드는 테크닉입니다.\n그래서 이런 테스트 방식을 <em>얕은 컴포넌트 테스트(Shallow Component Testing)</em> 라고 합니다.</p>\n<p>두 방법 중에서는 <code><a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a></code>를 사용하는 방법이 좀 더 간단하지만, 이 방법을 남용하면 안됩니다.</p>\n<p><code><a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a></code>를 사용하면 Angular 컴포넌트가 검사해야 하는 많은 과정을 생략합니다.\n그리고 의도하지 않은 오타가 있어서 컴포넌트나 어트리뷰트가 누락되더라도 에러로 처리하지 않습니다.\n이런 문제가 발생하면 버그를 해결하기 위해 꽤 많은 시간을 들여야 할 수도 있습니다.</p>\n<p>그리고 <em>컴포넌트를 목으로 대체</em> 할 때 좋은 점이 하나 더 있습니다.\n이 예제에서 다룬 목 클래스들의 템플릿과 클래스 코드는 모두 비어있지만, 테스트하는 컴포넌트가 자식 컴포넌트와 상호작용해야 하는 부분이 있으면 필요한 내용을 추가로 구현해서 처리할 수 있습니다.</p>\n<p>실제로 테스트 스펙을 작성하다보면 다음과 같이 두 가지 방식을 모두 사용하는 경우가 많습니다.</p>\n<!--\n<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"mixed-setup\" header=\"app/app.component.spec.ts (mixed setup)\" linenums=\"false\">\nTestBed.configureTestingModule({\n  declarations: [\n    AppComponent,\n    BannerStubComponent,\n    RouterLinkDirectiveStub\n  ],\n  schemas: [ NO_ERRORS_SCHEMA ]\n})\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"mixed-setup\" header=\"app/app.component.spec.ts (두가지 방식을 모두 적용한 환경 설정)\" linenums=\"false\">\nTestBed.configureTestingModule({\n  <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [\n    AppComponent,\n    BannerStubComponent,\n    RouterLinkDirectiveStub\n  ],\n  <a href=\"api/core/NgModule#schemas\" class=\"code-anchor\">schemas</a>: [ <a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a> ]\n})\n\n</code-example>\n<!--\nThe Angular compiler creates the `BannerComponentStub` for the `<app-banner>` element\nand applies the `RouterLinkStubDirective` to the anchors with the `routerLink` attribute,\nbut it ignores the `<app-welcome>` and `<router-outlet>` tags.\n-->\n<p>테스트 환경을 이렇게 구성하면 <code>&#x3C;app-banner></code> 엘리먼트에는 <code>BannerComponentStub</code>이 사용되며 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> 어트리뷰트가 사용된 앵커에는 <code>RouterLinkStubDirective</code>가 사용됩니다.\n<code>&#x3C;app-welcome></code>과 <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code> 태그는 무시됩니다.</p>\n<hr>\n<a id=\"routerlink\"></a>\n<!--\n### Components with _RouterLink_\n-->\n<h3 id=\"routerlink-를-사용하는-컴포넌트\"><em>RouterLink</em> 를 사용하는 컴포넌트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#routerlink-를-사용하는-컴포넌트\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe real `RouterLinkDirective` is quite complicated and entangled with other components\nand directives of the `RouterModule`.\nIt requires challenging setup to mock and use in tests.\n\nThe `RouterLinkDirectiveStub` in this sample code replaces the real directive\nwith an alternative version designed to validate the kind of anchor tag wiring\nseen in the `AppComponent` template.\n-->\n<p><code>RouterLinkDirective</code>는 디렉티브 자체도 많이 복잡하지만 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>에 있는 다른 컴포넌트나 디렉티브와 긴밀하게 연결되어 있기도 합니다.\n그래서 이 디렉티브를 테스트 환경에서 모킹하는 것은 아주 어렵습니다.</p>\n<p><code>AppComponent</code>의 템플릿에 있는 앵커 태그에도 이 디렉티브가 사용되었는데, 이번 테스트 코드에서는 실제 디렉티브 대신 <code>RouterLinkDirectiveStub</code>를 사용해서 테스트에 필요한 로직만 검증해 봅시다.</p>\n<code-example path=\"testing/src/testing/router-link-directive-stub.ts\" region=\"router-link\" header=\"testing/router-link-directive-stub.ts (RouterLinkDirectiveStub)\" linenums=\"false\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: '[<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]',\n  <a href=\"api/core/Directive#host\" class=\"code-anchor\">host</a>: { '(click)': 'onClick()' }\n})\nexport class RouterLinkDirectiveStub {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>') linkParams: any;\n  navigatedTo: any = null;\n\n  onClick() {\n    this.navigatedTo = this.linkParams;\n  }\n}\n\n</code-example>\n<!--\nThe URL bound to the `[routerLink]` attribute flows in to the directive's `linkParams` property.\n\nThe `host` metadata property wires the click event of the host element\n(the `<a>` anchor elements in `AppComponent`) to the stub directive's `onClick` method.\n\nClicking the anchor should trigger the `onClick()` method,\nwhich sets the stub's telltale `navigatedTo` property.\nTests inspect `navigatedTo` to confirm that clicking the anchor\nset the expected route definition.\n-->\n<p><code>[<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]</code> 어트리뷰트로 전달된 URL은 디렉티브의 <code>linkParams</code> 프로퍼티로 바인딩됩니다.</p>\n<p>그리고 호스트 엘리먼트(<code>AppComponent</code>에 있는 <code>&#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>></code> 앵커 엘리먼트)에서 발생하는 클릭 이벤트는 <code><a href=\"api/core/Directive#host\" class=\"code-anchor\">host</a></code> 메타데이터 프로퍼티를 사용해서 디렉티브의 <code>onClick</code> 메소드와 연결합니다.</p>\n<p>이제 앵커 태그를 클릭하면 디렉티브에 정의된 <code>onClick()</code> 메소드가 실행되는데, 클릭 동작 이후에 디렉티브의 <code>navigateTo</code> 프로퍼티를 확인하면 원하는 주소로 이동하려고 하는 것인지 확인할 수 있습니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nWhether the router is configured properly to navigate with that route definition is a\nquestion for a separate set of tests.\n-->\n<p>라우터가 해당 주소로 이동할 수 있도록 라우팅 규칙을 올바르게 구성했는지 여부는 이 테스트 코드에서 확인하지 않습니다.</p>\n</div>\n<a id=\"by-directive\"></a>\n<a id=\"inject-directive\"></a>\n<!--\n#### _By.directive_ and injected directives\n-->\n<h4 id=\"bydirective-와-의존성으로-주입되는-디렉티브\"><em>By.directive</em> 와 의존성으로 주입되는 디렉티브<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#bydirective-와-의존성으로-주입되는-디렉티브\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nA little more setup triggers the initial data binding and gets references to the navigation links:\n-->\n<p>네비게이션 링크에 초기 데이터를 바인딩하려면 설정해야 할 것이 조금 더 있습니다:</p>\n<!--\n<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"test-setup\" header=\"app/app.component.spec.ts (test setup)\" linenums=\"false\">\nbeforeEach(() =&gt; {\n  fixture.detectChanges(); //초기 데이터 바인딩을 실행합니다.\n\n  // RouterLinkStubDirective가 사용된 DebugElement를 쿼리합니다.\n  linkDes = fixture.debugElement\n    .queryAll(By.directive(RouterLinkDirectiveStub));\n\n  // DebugElement의 인젝터를 사용해서 개별 디렉티브 인스턴스를 참조합니다.\n  routerLinks = linkDes.map(de =&gt; de.injector.get(RouterLinkDirectiveStub));\n});\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"test-setup\" header=\"app/app.component.spec.ts (테스트환경 설정)\" linenums=\"false\">\nbeforeEach(() => {\n  fixture.detectChanges(); //초기 데이터 바인딩을 실행합니다.\n\n  // RouterLinkStubDirective가 사용된 <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>를 쿼리합니다.\n  linkDes = fixture.debugElement\n    .queryAll(By.directive(RouterLinkDirectiveStub));\n\n  // <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>의 인젝터를 사용해서 개별 디렉티브 인스턴스를 참조합니다.\n  routerLinks = linkDes.map(de => de.injector.get(RouterLinkDirectiveStub));\n});\n\n</code-example>\n<!--\nThree points of special interest:\n\n1.  You can locate the anchor elements with an attached directive using `By.directive`.\n\n1.  The query returns `DebugElement` wrappers around the matching elements.\n\n1.  Each `DebugElement` exposes a dependency injector with the\n    specific instance of the directive attached to that element.\n\nThe `AppComponent` links to validate are as follows:\n-->\n<p>이 코드에서 세 부분이 중요합니다:</p>\n<ol>\n<li>\n<p><code>By.directive</code>를 사용하면 특정 디렉티브가 사용된 앵커 엘리먼트를 가져올 수 있습니다.</p>\n</li>\n<li>\n<p>엘리먼트는 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 래퍼(wrapper) 타입으로 반환됩니다.</p>\n</li>\n<li>\n<p>엘리먼트에 의존성으로 주입된 디렉티브 인스턴스를 참조하려면 각 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>의 인젝터를 사용하면 됩니다.</p>\n</li>\n</ol>\n<p><code>AppComponent</code>에 사용된 링크를 다시 한 번 봅시다:</p>\n<!--\n<code-example path=\"testing/src/app/app.component.html\" region=\"links\" header=\"app/app.component.html (navigation links)\" linenums=\"false\">\n&lt;nav&gt;\n  &lt;a routerLink=&quot;/dashboard&quot;&gt;Dashboard&lt;/a&gt;\n  &lt;a routerLink=&quot;/heroes&quot;&gt;Heroes&lt;/a&gt;\n  &lt;a routerLink=&quot;/about&quot;&gt;About&lt;/a&gt;\n&lt;/nav&gt;\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/app.component.html\" region=\"links\" header=\"app/app.component.html (네비게이션 링크)\" linenums=\"false\">\n&#x3C;nav>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/dashboard\">Dashboard&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/heroes\">Heroes&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/about\">About&#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n&#x3C;/nav>\n\n</code-example>\n<a id=\"app-component-tests\"></a>\n<!--\nHere are some tests that confirm those links are wired to the `routerLink` directives\nas expected:\n-->\n<p>이 링크들이 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> 디렉티브와 제대로 연결되었는지 확인하는 테스트 코드는 다음과 같이 작성합니다:</p>\n<!--\n<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"tests\" header=\"app/app.component.spec.ts (selected tests)\" linenums=\"false\">\nit(&#39;can get RouterLinks from template&#39;, () =&gt; {\n  expect(routerLinks.length).toBe(3, &#39;should have 3 routerLinks&#39;);\n  expect(routerLinks[0].linkParams).toBe(&#39;/dashboard&#39;);\n  expect(routerLinks[1].linkParams).toBe(&#39;/heroes&#39;);\n  expect(routerLinks[2].linkParams).toBe(&#39;/about&#39;);\n});\n\nit(&#39;can click Heroes link in template&#39;, () =&gt; {\n  const heroesLinkDe = linkDes[1];   // 히어로 목록으로 가는 링크를 표현하는 DebugElement\n  const heroesLink = routerLinks[1]; // 히어로 목록으로 가는 링크와 연결된 디렉티브\n\n  expect(heroesLink.navigatedTo).toBeNull(&#39;should not have navigated yet&#39;);\n\n  heroesLinkDe.triggerEventHandler(&#39;click&#39;, null);\n  fixture.detectChanges();\n\n  expect(heroesLink.navigatedTo).toBe(&#39;/heroes&#39;);\n});\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"tests\" header=\"app/app.component.spec.ts (테스트 코드)\" linenums=\"false\">\nit('can get RouterLinks from <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>', () => {\n  expect(routerLinks.length).toBe(3, 'should have 3 routerLinks');\n  expect(routerLinks[0].linkParams).toBe('/dashboard');\n  expect(routerLinks[1].linkParams).toBe('/heroes');\n  expect(routerLinks[2].linkParams).toBe('/about');\n});\n\nit('can click Heroes link in <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>', () => {\n  const heroesLinkDe = linkDes[1];   // 히어로 목록으로 가는 링크를 표현하는 <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>\n  const heroesLink = routerLinks[1]; // 히어로 목록으로 가는 링크와 연결된 디렉티브\n\n  expect(heroesLink.navigatedTo).toBeNull('should not have <a href=\"api/router/Router#navigated\" class=\"code-anchor\">navigated</a> yet');\n\n  heroesLinkDe.triggerEventHandler('click', null);\n  fixture.detectChanges();\n\n  expect(heroesLink.navigatedTo).toBe('/heroes');\n});\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\nThe \"click\" test _in this example_ is misleading.\nIt tests the `RouterLinkDirectiveStub` rather than the _component_.\nThis is a common failing of directive stubs.\n\nIt has a legitimate purpose in this guide.\nIt demonstrates how to find a `RouterLink` element, click it, and inspect a result,\nwithout engaging the full router machinery.\nThis is a skill you may need to test a more sophisticated component, one that changes the display,\nre-calculates parameters, or re-arranges navigation options when the user clicks the link.\n-->\n<p><em>이 테스트 코드</em> 중에 \"click\" 부분은 어울리지 않는 코드라고 생각할 수도 있습니다.\n해당 코드는 <em>컴포넌트</em> 를 테스트하는 것이 아니라 <code>RouterLinkDirectiveStub</code>을 테스트하는 코드이기 때문입니다.\n하지만 디렉티브를 대체하는 경우에는 이런 테크닉을 사용해야만 하는 경우가 종종 있습니다.</p>\n<p>이 테스트 코드는 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>가 사용된 엘리먼트를 찾아서, 이 엘리먼트를 클릭하고, 결과를 확인하는 과정에 실제 라우터의 기능은 하나도 활용하지 않습니다.\n그래서 이후에도 사용자가 링크를 클릭했을 때 컴포넌트가 화면의 내용을 바꾸거나, 인자를 다시 계산하고, 네비게이션 옵션을 수정하는 동작을 테스트할 때도 이와 비슷한 방식을 사용하면 테스트 코드를 조금 더 간단하게 작성할 수 있습니다.</p>\n</div>\n<a id=\"why-stubbed-routerlink-tests\"></a>\n<!--\n#### What good are these tests?\n-->\n<h4 id=\"왜-routerlink-를-목-클래스로-사용하나요\">왜 <em>RouterLink</em> 를 목 클래스로 사용하나요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#왜-routerlink-를-목-클래스로-사용하나요\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nStubbed `RouterLink` tests can confirm that a component with links and an outlet is setup properly,\nthat the component has the links it should have, and that they are all pointing in the expected direction.\nThese tests do not concern whether the app will succeed in navigating to the target component when the user clicks a link.\n\nStubbing the RouterLink and RouterOutlet is the best option for such limited testing goals.\nRelying on the real router would make them brittle.\nThey could fail for reasons unrelated to the component.\nFor example, a navigation guard could prevent an unauthorized user from visiting the `HeroListComponent`.\nThat's not the fault of the `AppComponent` and no change to that component could cure the failed test.\n\nA _different_ battery of tests can explore whether the application navigates as expected\nin the presence of conditions that influence guards such as whether the user is authenticated and authorized.\n-->\n<p><code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>를 목 클래스로 테스트하면 컴포넌트에 존재하는 링크와 라우팅 영역이 제대로 설정되었는지, 미리 지정된 주소로 제대로 이동하는지 확인할 수 있습니다.\n그리고 이 테스트 코드는 사용자가 링크를 클릭했을 때 실제로 페이지를 전환하는지는 신경쓰지 않습니다.</p>\n<p><code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>와 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>를 목 클래스로 대체하는 것은 테스트 범위를 제한하기 위해서입니다.\n이 테스트에서 실제 라우터를 사용한다면 테스트 코드는 훨씬 더 복잡해집니다.\n그리고 테스트하려는 컴포넌트 외부에서 발생한 어떤 이유 때문에 테스트가 실패할 수도 잇습니다.\n예를 들면 로그인하지 않은 사용자가 <code>HeroListComponent</code>를 방문하는 것을 막는 라우터 가드가 동작할 수도 있습니다.\n이런 문제는 <code>AppComponent</code>의 문제가 아니면서도, 테스트를 정상적으로 실행하기 위해 <code>AppComponent</code>가 할 수 있는 일은 없습니다.</p>\n<p>사용자가 로그인했거나 로그인하지 않은 상태에 따라 애플리케이션의 네비게이션 동작이 다르게 실행되어야 한다면, 지금까지 설명한 방법이 아닌 다른 방법을 활용해야 합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nA future guide update will explain how to write such\ntests with the `RouterTestingModule`.\n-->\n<p>이 섹션에서 다룬 테스트 코드는 <code><a href=\"api/router/testing/RouterTestingModule\" class=\"code-anchor\">RouterTestingModule</a></code>에 대해 다룰 때 다시 한 번 언급합니다.</p>\n</div>\n<hr>\n<a id=\"page-object\"></a>\n<!--\n### Use a _page_ object\n-->\n<h3 id=\"page-객체-사용하기\"><em>page</em> 객체 사용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#page-객체-사용하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe `HeroDetailComponent` is a simple view with a title, two hero fields, and two buttons.\n-->\n<p><code>HeroDetailComponent</code>는 페이지 제목과 필드 2개, 버튼이 2개 있는 간단한 컴포넌트입니다.</p>\n<figure>\n  <img src=\"generated/images/guide/testing/hero-detail.component.png\" alt=\"HeroDetailComponent in action\" width=\"269\" height=\"170\">\n</figure>\n<!--\nBut there's plenty of template complexity even in this simple form.\n-->\n<p>하지만 이렇게 간단한 폼을 구성하더라도 컴포넌트 템플릿이 간단하지만은 않습니다.</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.html\" header=\"app/hero/hero-detail.component.html\" linenums=\"false\">\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero\">\n  &#x3C;h2>&#x3C;span>{{hero.name | <a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">titlecase</a>}}&#x3C;/span> Details&#x3C;/h2>\n  &#x3C;div>\n    &#x3C;label>id: &#x3C;/label>{{hero.id}}&#x3C;/div>\n  &#x3C;div>\n    &#x3C;label for=\"name\">name: &#x3C;/label>\n    &#x3C;input id=\"name\" [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.name\" placeholder=\"name\" />\n  &#x3C;/div>\n  &#x3C;button (click)=\"save()\">Save&#x3C;/button>\n  &#x3C;button (click)=\"cancel()\">Cancel&#x3C;/button>\n&#x3C;/div>\n\n\n</code-example>\n<!--\nTests that exercise the component need ...\n\n- to wait until a hero arrives before elements appear in the DOM.\n- a reference to the title text.\n- a reference to the name input box to inspect and set it.\n- references to the two buttons so they can click them.\n- spies for some of the component and router methods.\n\nEven a small form such as this one can produce a mess of tortured conditional setup and CSS element selection.\n\nTame the complexity with a `Page` class that handles access to component properties\nand encapsulates the logic that sets them.\n\nHere is such a `Page` class for the `hero-detail.component.spec.ts`\n-->\n<p>이 컴포넌트를 테스트하려면 ...</p>\n<ul>\n<li><code>hero</code> 프로퍼티가 준비되기 전까지 엘리먼트들은 DOM에 표시되지 않아야 합니다.</li>\n<li>컴포넌트 제목 엘리먼트를 참조해야 합니다.</li>\n<li>히어로의 이름이 표시되는 입력 필드를 찾아서 이 필드의 값을 설정해야 합니다.</li>\n<li>두 개의 버튼을 참조해야 하며, 이 버튼들은 클릭할 수 있어야 합니다.</li>\n<li>컴포넌트 메소드나 라우터 메소드에 스파이를 적용해야 합니다.</li>\n</ul>\n<p>이렇게 간단한 폼에서도 수많은 테스트를 실행할 수 있기 때문에, 이 컴포넌트를 테스트하는 환경과 CSS 엘리먼트는 준비하는 것은 아주 괴로운 일이 될 수 있습니다.</p>\n<p>이런 경우에는 컴포넌트를 준비하는 로직을 캡슐화하고 컴포넌트의 프로퍼티를 효율적으로 조작하기 위해 <code>Page</code> 클래스를 도입하는 것이 좋습니다.</p>\n<p><code>hero-detail.component.spec.ts</code> 파일에 정의된 <code>Page</code> 클래스는 다음과 같습니다:</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"page\" header=\"app/hero/hero-detail.component.spec.ts (Page)\" linenums=\"false\">\nclass Page {\n  // DOM에서 원하는 엘리먼트를 참조하는 게터 함수를 정의합니다.\n  get buttons()     { return this.queryAll&#x3C;HTMLButtonElement>('button'); }\n  get saveBtn()     { return this.buttons[0]; }\n  get cancelBtn()   { return this.buttons[1]; }\n  get nameDisplay() { return this.query&#x3C;HTMLElement>('span'); }\n  get nameInput()   { return this.query&#x3C;HTMLInputElement>('input'); }\n\n  gotoListSpy: jasmine.Spy;\n  navigateSpy:  jasmine.Spy;\n\n  constructor(fixture: <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>&#x3C;HeroDetailComponent>) {\n    // 의존성 객체로 주입된 라우터 스파이 객체를 참조합니다.\n    const routerSpy = &#x3C;any> fixture.debugElement.injector.get(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>);\n    this.navigateSpy = routerSpy.navigate;\n\n    // 컴포넌트의 `gotoList()` 메소드에 스파이를 적용합니다.\n    const component = fixture.componentInstance;\n    this.gotoListSpy = spyOn(component, 'gotoList').and.callThrough();\n  }\n\n  //// 쿼리 헬퍼 ////\n  private <a href=\"api/animations/query\" class=\"code-anchor\">query</a>&#x3C;T>(selector: string): T {\n    return fixture.nativeElement.querySelector(selector);\n  }\n\n  private queryAll&#x3C;T>(selector: string): T[] {\n    return fixture.nativeElement.querySelectorAll(selector);\n  }\n}\n\n</code-example>\n<!--\nNow the important hooks for component manipulation and inspection are neatly organized and accessible from an instance of `Page`.\n\nA `createComponent` method creates a `page` object and fills in the blanks once the `hero` arrives.\n-->\n<p>이제 컴포넌트를 조작하거나 검사하는 로직은 모두 <code>Page</code> 인스턴스를 통해서 처리할 수 있습니다.</p>\n<p>그리고 <code>createComponent</code> 메소드는 <code>page</code> 객체의 인스턴스를 생성한 이후에 <code>hero</code> 데이터를 받아와서 화면을 갱신하는 동작까지 실행합니다.</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"create-component\" header=\"app/hero/hero-detail.component.spec.ts (createComponent)\" linenums=\"false\">\n/** HeroDetailComponent의 인스턴스를 생성하고, 초기화하며, 테스트 변수를 할당합니다. */\nfunction createComponent() {\n  fixture = TestBed.createComponent(HeroDetailComponent);\n  component = fixture.componentInstance;\n  page = new Page(fixture);\n\n  // 첫번째 변화 감지 로직이 동작하면 히어로 데이터를 가져오는 ngOnInit이 실행됩니다.\n  fixture.detectChanges();\n  return fixture.whenStable().then(() => {\n    // 두번째 변화 감지 로직이 동작하면 비동기로 가져온 히어로 데이터가 화면에 표시됩니다.\n    fixture.detectChanges();\n  });\n}\n\n</code-example>\n<!--\nThe [_HeroDetailComponent_ tests](#tests-w-test-double) in an earlier section demonstrate how `createComponent` and `page`\nkeep the tests short and _on message_.\nThere are no distractions: no waiting for promises to resolve and no searching the DOM for element values to compare.\n\nHere are a few more `HeroDetailComponent` tests to reinforce the point.\n-->\n<p>이전 섹션에서 살펴봤던 <a href=\"guide/testing#tests-w-test-double\"><em>HeroDetailComponent</em> 테스트</a>는 <code>createComponent</code> 메소드와 <code>page</code> 객체를 사용했기 때문에, 간단하지만 <em>이해하기 쉽게</em> 테스트 코드를 작성할 수 있었습니다.\n테스트 코드를 복잡하게 할 수 있는 것은 아무것도 없습니다: 해결해야 할 Promise도 없고 DOM에서 엘리먼트를 쿼리하는 코드도 없습니다.</p>\n<p>이 내용을 확실하게 확인하기 위해 <code>HeroDetailComponent</code>를 다양하게 테스트하는 코드를 살펴봅시다.</p>\n<!--\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"selected-tests\" header=\"app/hero/hero-detail.component.spec.ts (selected tests)\" linenums=\"false\">\nit(&#39;should display that hero\\&#39;s name&#39;, () =&gt; {\n  expect(page.nameDisplay.textContent).toBe(expectedHero.name);\n});\n\nit(&#39;should navigate when click cancel&#39;, () =&gt; {\n  click(page.cancelBtn);\n  expect(page.navigateSpy.calls.any()).toBe(true, &#39;router.navigate called&#39;);\n});\n\nit(&#39;should save when click save but not navigate immediately&#39;, () =&gt; {\n  // 컴포넌트로 의존성 주입된 서비스를 참조하고, `saveHero` 메소드에 스파이를 연결합니다.\n  // 테스트 코드를 안전하게 실행하기 위해, `HeroDetailService.saveHero` 메소드는 목 클래스에 만든 `HeroService.updateHero`를 사용합니다.\n  const hds = fixture.debugElement.injector.get(HeroDetailService);\n  const saveSpy = spyOn(hds, &#39;saveHero&#39;).and.callThrough();\n\n  click(page.saveBtn);\n  expect(saveSpy.calls.any()).toBe(true, &#39;HeroDetailService.save called&#39;);\n  expect(page.navigateSpy.calls.any()).toBe(false, &#39;router.navigate not called&#39;);\n});\n\nit(&#39;should navigate when click save and save resolves&#39;, fakeAsync(() =&gt; {\n  click(page.saveBtn);\n  tick(); // 비동기 저장 작업이 종료될 때까지 기다립니다.\n  expect(page.navigateSpy.calls.any()).toBe(true, &#39;router.navigate called&#39;);\n}));\n\nit(&#39;should convert hero name to Title Case&#39;, () =&gt; {\n  // 이름에 해당하는 input 엘리먼트와 이 이름을 화면에 표시하는 span 엘리먼트를 DOM에서 참조합니다.\n  const hostElement = fixture.nativeElement;\n  const nameInput: HTMLInputElement = hostElement.querySelector(&#39;input&#39;);\n  const nameDisplay: HTMLElement = hostElement.querySelector(&#39;span&#39;);\n\n  // 사용자가 입력한 것처럼 입력 필드의 내용을 변경합니다.\n  nameInput.value = &#39;quick BROWN  fOx&#39;;\n\n  // 엘리먼트의 값이 변경되었다는 것을 Angular에게 알리기 위해 DOM 이벤트를 생성합니다.\n  nameInput.dispatchEvent(newEvent(&#39;input&#39;));\n\n  // Angular가 화면을 갱신하도록 detectChanges() 함수를 실행합니다.\n  fixture.detectChanges();\n\n  expect(nameDisplay.textContent).toBe(&#39;Quick Brown  Fox&#39;);\n});\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"selected-tests\" header=\"app/hero/hero-detail.component.spec.ts (테스트 일부)\" linenums=\"false\">\nit('should display that hero\\'s name', () => {\n  expect(page.nameDisplay.textContent).toBe(expectedHero.name);\n});\n\nit('should navigate when click cancel', () => {\n  click(page.cancelBtn);\n  expect(page.navigateSpy.calls.any()).toBe(true, 'router.navigate called');\n});\n\nit('should save when click save but not navigate immediately', () => {\n  // 컴포넌트로 의존성 주입된 서비스를 참조하고, `saveHero` 메소드에 스파이를 연결합니다.\n  // 테스트 코드를 안전하게 실행하기 위해, `HeroDetailService.saveHero` 메소드는 목 클래스에 만든 `HeroService.updateHero`를 사용합니다.\n  const hds = fixture.debugElement.injector.get(HeroDetailService);\n  const saveSpy = spyOn(hds, 'saveHero').and.callThrough();\n\n  click(page.saveBtn);\n  expect(saveSpy.calls.any()).toBe(true, 'HeroDetailService.save called');\n  expect(page.navigateSpy.calls.any()).toBe(false, 'router.navigate not called');\n});\n\nit('should navigate when click save and save resolves', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() => {\n  click(page.saveBtn);\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(); // 비동기 저장 작업이 종료될 때까지 기다립니다.\n  expect(page.navigateSpy.calls.any()).toBe(true, 'router.navigate called');\n}));\n\nit('should convert hero name to <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a> Case', () => {\n  // 이름에 해당하는 input 엘리먼트와 이 이름을 화면에 표시하는 span 엘리먼트를 DOM에서 참조합니다.\n  const hostElement = fixture.nativeElement;\n  const nameInput: HTMLInputElement = hostElement.querySelector('input');\n  const nameDisplay: HTMLElement = hostElement.querySelector('span');\n\n  // 사용자가 입력한 것처럼 입력 필드의 내용을 변경합니다.\n  nameInput.value = 'quick BROWN  fOx';\n\n  // 엘리먼트의 값이 변경되었다는 것을 Angular에게 알리기 위해 DOM 이벤트를 생성합니다.\n  nameInput.dispatchEvent(newEvent('input'));\n\n  // Angular가 화면을 갱신하도록 detectChanges() 함수를 실행합니다.\n  fixture.detectChanges();\n\n  expect(nameDisplay.textContent).toBe('Quick Brown  Fox');\n});\n\n</code-example>\n<hr>\n<a id=\"compile-components\"></a>\n<!--\n### Calling _compileComponents()_\n-->\n<h3 id=\"compilecomponents-실행하기\"><em>compileComponents()</em> 실행하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#compilecomponents-실행하기\"><i class=\"material-icons\">link</i></a></h3>\n<div class=\"alert is-helpful\">\n<!--\nYou can ignore this section if you _only_ run tests with the CLI `ng test` command\nbecause the CLI compiles the application before running the tests.\n-->\n<p><code>ng test</code> <em>명령을</em> 사용해서 테스트를 실행한다면 이 섹션은 건너뛰어도 됩니다.\nAngular CLI는 테스트를 실행하기 전에 애플리케이션을 자동으로 컴파일합니다.</p>\n</div>\n<!--\nIf you run tests in a **non-CLI environment**, the tests may fail with a message like this one:\n-->\n<p><strong>Angular CLI가 아닌 환경으로</strong> 테스트를 실행한다면 다음과 같은 메시지가 출력되면서 테스트가 실패하는 경우가 있습니다:</p>\n<code-example language=\"sh\" class=\"code-shell\" hidecopy=\"\">\nError: This test module uses the component BannerComponent\nwhich is using <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> \"templateUrl\" or \"<a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a>\", but they were never compiled.\nPlease call \"TestBed.compileComponents\" before your test.\n</code-example>\n<!--\nThe root of the problem is at least one of the components involved in the test\nspecifies an external template or CSS file as\nthe following version of the `BannerComponent` does.\n-->\n<p>이 에러가 발생한 원인은, 테스트에 사용된 컴포넌트 중 하나에 외부 템플릿이나 외부 CSS 파일이 사용되었기 때문입니다.\n<code>BannerComponent</code>를 다음과 같이 선언한 경우가 그렇습니다:</p>\n<!--\n<code-example path=\"testing/src/app/banner/banner-external.component.ts\" header=\"app/banner/banner-external.component.ts (external template & css)\" linenums=\"false\">\nimport { Component } from &#39;@angular/core&#39;;\n\n@Component({\n  selector: &#39;app-banner&#39;,\n  templateUrl: &#39;./banner-external.component.html&#39;,\n  styleUrls:  [&#39;./banner-external.component.css&#39;]\n})\nexport class BannerComponent {\n  title = &#39;Test Tour of Heroes&#39;;\n}\n\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/banner/banner-external.component.ts\" header=\"app/banner/banner-external.component.ts (외부 템플릿 &#x26; css)\" linenums=\"false\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-banner',\n  templateUrl: './banner-external.component.html',\n  <a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a>:  ['./banner-external.component.css']\n})\nexport class BannerComponent {\n  title = 'Test Tour of Heroes';\n}\n\n\n</code-example>\n<!--\nThe test fails when the `TestBed` tries to create the component.\n-->\n<p>이 테스트 코드는 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>가 컴포넌트를 생성하려고 하는 시점에 실패합니다.</p>\n<!--\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"configure-and-create\" header=\"app/banner/banner.component.spec.ts (setup that fails)\" avoid linenums=\"false\">\nbeforeEach(() =&gt; {\n  TestBed.configureTestingModule({\n    declarations: [ BannerComponent ],\n  });\n  fixture = TestBed.createComponent(BannerComponent);\n});\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"configure-and-create\" header=\"app/banner/banner.component.spec.ts (테스트에 실패하는 환경 설정)\" avoid=\"\" linenums=\"false\">\nbeforeEach(() => {\n  TestBed.configureTestingModule({\n    <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [ BannerComponent ],\n  });\n  fixture = TestBed.createComponent(BannerComponent);\n});\n\n</code-example>\n<!--\nRecall that the app hasn't been compiled.\nSo when you call `createComponent()`, the `TestBed` compiles implicitly.\n\nThat's not a problem when the source code is in memory.\nBut the `BannerComponent` requires external files\nthat the compile must read from the file system,\nan inherently _asynchronous_ operation.\n\nIf the `TestBed` were allowed to continue, the tests would run and fail mysteriously\nbefore the compiler could finished.\n\nThe preemptive error message tells you to compile explicitly with `compileComponents()`.\n-->\n<p>애플리케이션이 아직 컴파일되지 않았다는 것을 명심하세요.\n그렇다면 테스트할 컴포넌트를 생성하기 위해 <code>TestBed.createComponent()</code>를 실행하면 될 것이라 생각할 수 있습니다.</p>\n<p>하지만 이렇게 해도 테스트는 실패합니다.\n<code>BannerComponent</code>를 컴파일하려면 컴포넌트에 사용하는 외부 파일을 읽기 위해 파일 시스템을 읽어야 하는데, 이 동작은 <em>비동기</em> 로 실행됩니다.</p>\n<p>그래서 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>로 이후 작업을 계속하려고 하면, 컴파일러의 동작이 아직 끝나지 않은 상태에서 테스트를 실행했기 때문에 해당 테스트는 실패합니다.</p>\n<p>위에서 출력된 에러메시지에서 확인할 수 있듯이, 외부 파일이 사용된 컴포넌트를 제대로 컴파일하려면 <code>createComponent()</code> 를 실행하기 전에 <code>compileComponents()</code>를 먼저 실행해야 합니다.</p>\n<!--\n#### _compileComponents()_ is async\n-->\n<h4 id=\"compilecomponents-는-비동기로-실행됩니다\"><em>compileComponents()</em> 는 비동기로 실행됩니다.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#compilecomponents-는-비동기로-실행됩니다\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nYou must call `compileComponents()` within an asynchronous test function.\n-->\n<p>이 문제를 해결하려면 비동기 테스트 로직에서 <code>compileComponents()</code>를 실행해야 합니다.</p>\n<div class=\"alert is-critical\">\n<!--\nIf you neglect to make the test function async\n(e.g., forget to use `async()` as described below),\nyou'll see this error message\n-->\n<p>이 예제에서 <code><a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>()</code>와 같은 비동기 테스트 함수를 명시적으로 사용하지 않으면 다음과 같은 에러가 발생합니다.</p>\n<code-example language=\"sh\" class=\"code-shell\" hidecopy=\"\">\nError: ViewDestroyedError: Attempt to use <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> destroyed view\n</code-example>\n</div>\n<!--\nA typical approach is to divide the setup logic into two separate `beforeEach()` functions:\n\n1.  An async `beforeEach()` that compiles the components\n1.  A synchronous `beforeEach()` that performs the remaining setup.\n\nTo follow this pattern, import the `async()` helper with the other testing symbols.\n-->\n<p>서로 다른 환경설정 로직이 있다면 이 로직은 각각 <code>beforeEach()</code> 함수로 나눠서 정의하는 것이 일반적입니다. 이 방식을 사용해 봅시다:</p>\n<ol>\n<li>컴포넌트를 컴파일하는 로직은 비동기 <code>beforeEach()</code>에 작성합니다.</li>\n<li>나머지 환경설정은 동기 <code>beforeEach()</code>에 작성합니다.</li>\n</ol>\n<p>이렇게 작성하려면 먼저 테스트 패키지에서 <code><a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>()</code> 헬퍼를 로드해야 합니다.</p>\n<code-example path=\"testing/src/app/banner/banner-external.component.spec.ts\" region=\"import-async\">\nimport { <a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>, <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>, <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a> } from '@angular/core/testing';\n\n</code-example>\n<!--\n#### The async _beforeEach_\n-->\n<h4 id=\"비동기async-beforeeach\">비동기(async) <em>beforeEach</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#비동기async-beforeeach\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nWrite the first async `beforeEach` like this.\n-->\n<p>첫번째 비동기 <code>beforeEach</code>는 다음과 같이 작성합니다.</p>\n<!--\n<code-example path=\"testing/src/app/banner/banner-external.component.spec.ts\" region=\"async-before-each\" header=\"app/banner/banner-external.component.spec.ts (async beforeEach)\" linenums=\"false\">\nbeforeEach(async(() =&gt; {\n  TestBed.configureTestingModule({\n    declarations: [ BannerComponent ],\n  })\n  .compileComponents();  // 템플릿과 CSS를 컴파일합니다.\n}));\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/banner/banner-external.component.spec.ts\" region=\"async-before-each\" header=\"app/banner/banner-external.component.spec.ts (비동기 beforeEach)\" linenums=\"false\">\nbeforeEach(<a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>(() => {\n  TestBed.configureTestingModule({\n    <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [ BannerComponent ],\n  })\n  .compileComponents();  // 템플릿과 CSS를 컴파일합니다.\n}));\n\n</code-example>\n<!--\nThe `async()` helper function takes a parameterless function with the body of the setup.\n\nThe `TestBed.configureTestingModule()` method returns the `TestBed` class so you can chain\ncalls to other `TestBed` static methods such as `compileComponents()`.\n\nIn this example, the `BannerComponent` is the only component to compile.\nOther examples configure the testing module with multiple components\nand may import application modules that hold yet more components.\nAny of them could be require external files.\n\nThe `TestBed.compileComponents` method asynchronously compiles all components configured in the testing module.\n-->\n<p><code><a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>()</code> 헬퍼 함수는 인자가 없는 함수를 받아서 실행합니다.</p>\n<p>그리고 <code>TestBed.configureTestingModule()</code> 메소드는 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 클래스를 반환하기 때문에, 이 메소드를 체이닝하면서 바로 <code>compileComponents()</code> 메소드를 실행할 수 있습니다.</p>\n<p>이 예제에서 컴파일 대상이 되는 컴포넌트는 <code>BannerComponent</code> 하나뿐입니다.\n다른 예제에서는 컴포넌트 여러개를 테스트 모듈에 등록할 수도 있으며, 컴포넌트가 등록된 다른 모듈을 로드해야 할 수도 있습니다.\n그리고 이 때 불러오는 컴포넌트들이 외부 파일을 참조하는 경우도 있을 수 있습니다.</p>\n<p>이제 <code>TestBed.compileComponents</code> 메소드를 실행하면 테스트 모듈에 있는 모든 컴포넌트를 비동기로 컴파일합니다.</p>\n<div class=\"alert is-important\">\n<!--\nDo not re-configure the `TestBed` after calling `compileComponents()`.\n-->\n<p><code>compileComponents()</code>를 실행한 후에 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 설정을 변경하지 마세요.</p>\n</div>\n<!--\nCalling `compileComponents()` closes the current `TestBed` instance to further configuration.\nYou cannot call any more `TestBed` configuration methods, not `configureTestingModule()`\nnor any of the `override...` methods. The `TestBed` throws an error if you try.\n\nMake `compileComponents()` the last step\nbefore calling `TestBed.createComponent()`.\n-->\n<p><code>compileComponents()</code>를 실행하면 현재 설정중인 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 인스턴스 설정을 확정하며, 더이상 설정을 변경할 수 없습니다.\n그래서 이 메소드를 실행한 이후부터 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>에서 환경을 설정하는 메소드를 실행할 수 없습니다.\n<code>configureTestingModule()</code>이나 <code>override...</code> 메소드들이 모두 해당됩니다.\n<code>compileComponents()</code>를 실행한 뒤에 이 메소드들을 실행하면 에러가 발생합니다.</p>\n<p>그래서 <code>compileComponents()</code>는 <code>TestBed.createComponent()</code>를 실행하기 전 마지막 단계로 실행해야 합니다.</p>\n<!--\n#### The synchronous _beforeEach_\n-->\n<h4 id=\"동기synchronous-beforeeach\">동기(synchronous) <em>beforeEach</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#동기synchronous-beforeeach\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe second, synchronous `beforeEach()` contains the remaining setup steps,\nwhich include creating the component and querying for elements to inspect.\n-->\n<p>그 다음에는 아직 남은 환경설정을 위해 동기로 동작하는 <code>beforeEach()</code>를 정의해야 합니다.\n이 함수에는 컴포넌트를 생성하고 엘리먼트를 쿼리하는 로직이 들어갈 것입니다.</p>\n<!--\n<code-example path=\"testing/src/app/banner/banner-external.component.spec.ts\" region=\"sync-before-each\" header=\"app/banner/banner-external.component.spec.ts (synchronous beforeEach)\" linenums=\"false\">\nbeforeEach(() =&gt; {\n  fixture = TestBed.createComponent(BannerComponent);\n  component = fixture.componentInstance; // BannerComponent 인스턴스를 참조합니다.\n  h1 = fixture.nativeElement.querySelector(&#39;h1&#39;);\n});\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/banner/banner-external.component.spec.ts\" region=\"sync-before-each\" header=\"app/banner/banner-external.component.spec.ts (동기 beforeEach)\" linenums=\"false\">\nbeforeEach(() => {\n  fixture = TestBed.createComponent(BannerComponent);\n  component = fixture.componentInstance; // BannerComponent 인스턴스를 참조합니다.\n  h1 = fixture.nativeElement.querySelector('h1');\n});\n\n</code-example>\n<!--\nYou can count on the test runner to wait for the first asynchronous `beforeEach` to finish before calling the second.\n-->\n<p>하지만 이 <code>beforeEach()</code>는 위에서 살펴본 비동기 <code>beforeEach()</code>가 끝난 후에 실행되어야 하기 때문에, 이렇게 작성할 수 없습니다.</p>\n<!--\n#### Consolidated setup\n-->\n<h4 id=\"통합-환경설정\">통합 환경설정<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#통합-환경설정\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nYou can consolidate the two `beforeEach()` functions into a single, async `beforeEach()`.\n\nThe `compileComponents()` method returns a promise so you can perform the\nsynchronous setup tasks _after_ compilation by moving the synchronous code\ninto a `then(...)` callback.\n-->\n<p>두 <code>beforeEach()</code> 함수는 비동기 <code>beforeEach()</code> 하나로 통합할 수 있습니다.</p>\n<p><code>compileComponents()</code> 메소드는 <code>Promise</code>를 반환하기 때문에, 테스트 모듈을 컴파일한 <em>이후에</em> 필요한 로직을 <code>then(...)</code> 콜백으로 연결할 수 있습니다.</p>\n<!--\n<code-example path=\"testing/src/app/banner/banner-external.component.spec.ts\" region=\"one-before-each\" header=\"app/banner/banner-external.component.spec.ts (one beforeEach)\" linenums=\"false\">\nbeforeEach(async(() =&gt; {\n  TestBed.configureTestingModule({\n    declarations: [ BannerComponent ],\n  })\n  .compileComponents()\n  .then(() =&gt; {\n    fixture = TestBed.createComponent(BannerComponent);\n    component = fixture.componentInstance;\n    h1 = fixture.nativeElement.querySelector(&#39;h1&#39;);\n  });\n}));\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/banner/banner-external.component.spec.ts\" region=\"one-before-each\" header=\"app/banner/banner-external.component.spec.ts (통합된 beforeEach)\" linenums=\"false\">\nbeforeEach(<a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>(() => {\n  TestBed.configureTestingModule({\n    <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [ BannerComponent ],\n  })\n  .compileComponents()\n  .then(() => {\n    fixture = TestBed.createComponent(BannerComponent);\n    component = fixture.componentInstance;\n    h1 = fixture.nativeElement.querySelector('h1');\n  });\n}));\n\n</code-example>\n<!--\n#### _compileComponents()_ is harmless\n-->\n<h4 id=\"compilecomponents-는-잘못-사용해도-에러가-발생하지-않습니다\"><em>compileComponents()</em> 는 잘못 사용해도 에러가 발생하지 않습니다.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#compilecomponents-는-잘못-사용해도-에러가-발생하지-않습니다\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThere's no harm in calling `compileComponents()` when it's not required.\n\nThe component test file generated by the CLI calls `compileComponents()`\neven though it is never required when running `ng test`.\n\nThe tests in this guide only call `compileComponents` when necessary.\n-->\n<p><code>compileComponents()</code>는 이 함수가 필요하지 않을 때 실행하더라도 에러가 발생하지 않습니다.</p>\n<p>심지어 Angular CLI가 자동으로 생성한 컴포넌트 테스트 파일은 <code>ng test</code>를 실행할 때 전혀 필요하지 않은데도 <code>compileComponents()</code>를 실행합니다.</p>\n<p>하지만 <code>compileComponents</code>는 꼭 필요할 때만 실행하는 것을 권장합니다.</p>\n<hr>\n<a id=\"import-module\"></a>\n<!--\n### Setup with module imports\n-->\n<h3 id=\"모듈-로드-설정\">모듈 로드 설정<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#모듈-로드-설정\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nEarlier component tests configured the testing module with a few `declarations` like this:\n-->\n<p>이전에 다뤘던 컴포넌트 테스트 코드에서 테스트 모듈의 <code><a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a></code>는 이렇게 선언했습니다:</p>\n<!--\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"config-testbed\" header=\"app/dashboard/dashboard-hero.component.spec.ts (configure TestBed)\">\nTestBed.configureTestingModule({\n  declarations: [ DashboardHeroComponent ]\n})\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"config-testbed\" header=\"app/dashboard/dashboard-hero.component.spec.ts (TestBed 설정)\">\nTestBed.configureTestingModule({\n  <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [ DashboardHeroComponent ]\n})\n\n</code-example>\n<!--\nThe `DashboardComponent` is simple. It needs no help.\nBut more complex components often depend on other components, directives, pipes, and providers\nand these must be added to the testing module too.\n\nFortunately, the `TestBed.configureTestingModule` parameter parallels\nthe metadata passed to the `@NgModule` decorator\nwhich means you can also specify `providers` and `imports`.\n\nThe `HeroDetailComponent` requires a lot of help despite its small size and simple construction.\nIn addition to the support it receives from the default testing module `CommonModule`, it needs:\n\n- `NgModel` and friends in the `FormsModule` to enable two-way data binding.\n- The `TitleCasePipe` from the `shared` folder.\n- Router services (which these tests are stubbing).\n- Hero data access services (also stubbed).\n\nOne approach is to configure the testing module from the individual pieces as in this example:\n-->\n<p><code>DashboardComponent</code>는 간단합니다. 그래서 이 컴포넌트를 테스트하는 코드를 작성하는 것도 그리 어렵지 않습니다.\n하지만 컴포넌트가 다른 컴포넌트와 연동되어야 한다던지, 디렉티브나 파이프, 프로바이더를 사용해야 하면 테스팅 모듈에 이 구성요소를 모두 등록해야 합니다.</p>\n<p>하지만 다행히도 <code>TestBed.configureTestingModule</code>에 전달하는 인자는 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 데코레이터에 전달하는 메타데이터와 거의 비슷하기 때문에, <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>에도 <code>providers</code>와 <code><a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a></code> 배열을 지정할 수 있습니다.</p>\n<p><code>HeroDetailComponent</code> 자체는 아주 간단하지만 이 컴포넌트를 테스트하려면 많은 내용을 준비해야 합니다.\n준비해야 하는 항목들은 이렇습니다:</p>\n<ul>\n<li>양방향 데이터 바인딩을 연결하기 위해 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code>과 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>이 필요합니다.</li>\n<li><code>shared</code> 폴더에 있는 <code><a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a></code>가 필요합니다.</li>\n<li>(목 클래스를 사용하더라도) 라우터 서비스가 필요합니다.</li>\n<li>(이것도 목 클래스일 수 있지만) 히어로 데이터에 접근하는 서비스가 필요합니다.</li>\n</ul>\n<p>가장 단순한 방법은 이 항목들을 모두 테스트 모듈에 등록하는 것입니다:</p>\n<!--\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-forms-module\" header=\"app/hero/hero-detail.component.spec.ts (FormsModule setup)\" linenums=\"false\">\nbeforeEach(async(() =&gt; {\n  const routerSpy = createRouterSpy();\n\n  TestBed.configureTestingModule({\n    imports:      [ FormsModule ],\n    declarations: [ HeroDetailComponent, TitleCasePipe ],\n    providers: [\n      { provide: ActivatedRoute, useValue: activatedRoute },\n      { provide: HeroService,    useClass: TestHeroService },\n      { provide: Router,         useValue: routerSpy},\n    ]\n  })\n  .compileComponents();\n}));\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-forms-module\" header=\"app/hero/hero-detail.component.spec.ts (FormsModule 환경설정)\" linenums=\"false\">\nbeforeEach(<a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>(() => {\n  const routerSpy = createRouterSpy();\n\n  TestBed.configureTestingModule({\n    <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>:      [ <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> ],\n    <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [ HeroDetailComponent, <a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a> ],\n    providers: [\n      { provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: <a href=\"api/router/RouterOutlet#activatedRoute\" class=\"code-anchor\">activatedRoute</a> },\n      { provide: HeroService,    useClass: TestHeroService },\n      { provide: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,         useValue: routerSpy},\n    ]\n  })\n  .compileComponents();\n}));\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\nNotice that the `beforeEach()` is asynchronous and calls `TestBed.compileComponents`\nbecause the `HeroDetailComponent` has an external template and css file.\n\nAs explained in [_Calling compileComponents()_](#compile-components) above,\nthese tests could be run in a non-CLI environment\nwhere Angular would have to compile them in the browser.\n-->\n<p><code>HeroDetailComponent</code>는 외부 템플릿 파일과 외부 CSS 파일을 사용하기 때문에 <code>beforeEach()</code>는 비동기로 동작해야 하며 이 함수 안에서 <code>TestBed.compileComponents()</code>를 실행해야 합니다.</p>\n<p>그리고 이전에 <a href=\"guide/testing#compile-components\"><em>compileComponents() 실행하기</em></a>에서 설명했던 것처럼, Angular CLI를 사용하지 않는 환경에서도 브라우저에서 컴포넌트를 컴파일하기 위해 이 함수를 반드시 실행해야 합니다.</p>\n</div>\n<!--\n#### Import a shared module\n-->\n<h4 id=\"공통-모듈-로드하기\">공통 모듈 로드하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#공통-모듈-로드하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nBecause many app components need the `FormsModule` and the `TitleCasePipe`, the developer created\na `SharedModule` to combine these and other frequently requested parts.\n\nThe test configuration can use the `SharedModule` too as seen in this alternative setup:\n-->\n<p>애플리케이션에 존재하는 컴포넌트 중에서 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>과 <code><a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a></code>를 사용하는 컴포넌트가 많기 때문에, 개발자가 자주 사용하는 항목으로 묶어서 <code>SharedModule</code>로 만들었다고 합시다.</p>\n<p>그러면 테스트 환경설정에서도 다음과 같이 <code>SharedModule</code>을 사용할 수 있습니다:</p>\n<!--\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-shared-module\" header=\"app/hero/hero-detail.component.spec.ts (SharedModule setup)\" linenums=\"false\">\nbeforeEach(async(() =&gt; {\n  const routerSpy = createRouterSpy();\n\n  TestBed.configureTestingModule({\n    imports:      [ SharedModule ],\n    declarations: [ HeroDetailComponent ],\n    providers: [\n      { provide: ActivatedRoute, useValue: activatedRoute },\n      { provide: HeroService,    useClass: TestHeroService },\n      { provide: Router,         useValue: routerSpy},\n    ]\n  })\n  .compileComponents();\n}));\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-shared-module\" header=\"app/hero/hero-detail.component.spec.ts (SharedModule 환경설정)\" linenums=\"false\">\nbeforeEach(<a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>(() => {\n  const routerSpy = createRouterSpy();\n\n  TestBed.configureTestingModule({\n    <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>:      [ SharedModule ],\n    <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [ HeroDetailComponent ],\n    providers: [\n      { provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: <a href=\"api/router/RouterOutlet#activatedRoute\" class=\"code-anchor\">activatedRoute</a> },\n      { provide: HeroService,    useClass: TestHeroService },\n      { provide: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,         useValue: routerSpy},\n    ]\n  })\n  .compileComponents();\n}));\n\n</code-example>\n<!--\nIt's a bit tighter and smaller, with fewer import statements (not shown).\n-->\n<p>테스트 코드는 조금 간단해졌습니다.</p>\n<a id=\"feature-module-import\"></a>\n<!--\n#### Import a feature module\n-->\n<h4 id=\"기능모듈-로드하기\">기능모듈 로드하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#기능모듈-로드하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe `HeroDetailComponent` is part of the `HeroModule` [Feature Module](guide/feature-modules) that aggregates more of the interdependent pieces\nincluding the `SharedModule`.\nTry a test configuration that imports the `HeroModule` like this one:\n-->\n<p><code>HeroDetailComponent</code>는 <code>HeroModule</code> <a href=\"guide/feature-modules\">기능 모듈</a>의 구성요소이며, <code>HeroModule</code>은 <code>SharedModule</code>을 내부적으로 로드합니다.\n그러면 테스트 환경설정은 <code>HeroModule</code>을 사용해서 다음과 같이 수정할 수 있습니다:</p>\n<!--\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-hero-module\" header=\"app/hero/hero-detail.component.spec.ts (HeroModule setup)\" linenums=\"false\">\nbeforeEach(async(() =&gt; {\n  const routerSpy = createRouterSpy();\n\n  TestBed.configureTestingModule({\n    imports:   [ HeroModule ],\n    providers: [\n      { provide: ActivatedRoute, useValue: activatedRoute },\n      { provide: HeroService,    useClass: TestHeroService },\n      { provide: Router,         useValue: routerSpy},\n    ]\n  })\n  .compileComponents();\n}));\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-hero-module\" header=\"app/hero/hero-detail.component.spec.ts (HeroModule 환경설정)\" linenums=\"false\">\nbeforeEach(<a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>(() => {\n  const routerSpy = createRouterSpy();\n\n  TestBed.configureTestingModule({\n    <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>:   [ HeroModule ],\n    providers: [\n      { provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: <a href=\"api/router/RouterOutlet#activatedRoute\" class=\"code-anchor\">activatedRoute</a> },\n      { provide: HeroService,    useClass: TestHeroService },\n      { provide: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,         useValue: routerSpy},\n    ]\n  })\n  .compileComponents();\n}));\n\n</code-example>\n<!--\nThat's _really_ crisp. Only the _test doubles_ in the `providers` remain. Even the `HeroDetailComponent` declaration is gone.\n\nIn fact, if you try to declare it, Angular will throw an error because\n`HeroDetailComponent` is declared in both the `HeroModule` and the `DynamicTestModule`\ncreated by the `TestBed`.\n-->\n<p>좀 더 간결해졌습니다. 이제는 <code>providers</code>에 있는 <em>목 클래스</em> 들만 처리하면 됩니다.\n<code>HeroDetailComponent</code>를 등록하는 코드도 없어졌습니다.</p>\n<p>만약 <code>HeroDetailComponent</code>를 테스트 모듈에 등록하면, 이 컴포넌트는 <code>HeroModule</code>과 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>가 생성하는 <code>DynamicTestModule</code> 양쪽에 동시에 등록되기 때문에 에러가 발생합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nImporting the component's feature module can be the easiest way to configure tests\nwhen there are many mutual dependencies within the module and\nthe module is small, as feature modules tend to be.\n-->\n<p>컴포넌트를 직접 등록하는 대신 기능 모듈을 등록하는 방법을 사용하면 이 컴포넌트와 복잡하게 연결된 의존성 객체들을 기능 모듈이 대신 처리하기 때문에 테스트 코드가 훨씬 간단해 집니다.</p>\n</div>\n<hr>\n<a id=\"component-override\"></a>\n<!--\n### Override component providers\n-->\n<h3 id=\"컴포넌트-프로바이더-오버라이드하기\">컴포넌트 프로바이더 오버라이드하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#컴포넌트-프로바이더-오버라이드하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe `HeroDetailComponent` provides its own `HeroDetailService`.\n-->\n<p><code>HeroDetailComponent</code>에는 <code>HeroDetailService</code>가 직접 등록되어 있습니다.</p>\n<!--\n<code-example path=\"testing/src/app/hero/hero-detail.component.ts\" region=\"prototype\" header=\"app/hero/hero-detail.component.ts (prototype)\" linenums=\"false\">\n@Component({\n  selector:    &#39;app-hero-detail&#39;,\n  templateUrl: &#39;./hero-detail.component.html&#39;,\n  styleUrls:  [&#39;./hero-detail.component.css&#39; ],\n  providers:  [ HeroDetailService ]\n})\nexport class HeroDetailComponent implements OnInit {\n  constructor(\n    private heroDetailService: HeroDetailService,\n    private route:  ActivatedRoute,\n    private router: Router) {\n  }\n}\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/hero/hero-detail.component.ts\" region=\"prototype\" header=\"app/hero/hero-detail.component.ts (프로토타입)\" linenums=\"false\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector:    'app-hero-detail',\n  templateUrl: './hero-detail.component.html',\n  <a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a>:  ['./hero-detail.component.css' ],\n  providers:  [ HeroDetailService ]\n})\nexport class HeroDetailComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  constructor(\n    private heroDetailService: HeroDetailService,\n    private route:  <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>,\n    private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {\n  }\n}\n\n</code-example>\n<!--\nIt's not possible to stub the component's `HeroDetailService` in the `providers` of the `TestBed.configureTestingModule`.\nThose are providers for the _testing module_, not the component. They prepare the dependency injector at the _fixture level_.\n\nAngular creates the component with its _own_ injector, which is a _child_ of the fixture injector.\nIt registers the component's providers (the `HeroDetailService` in this case) with the child injector.\n\nA test cannot get to child injector services from the fixture injector.\nAnd `TestBed.configureTestingModule` can't configure them either.\n\nAngular has been creating new instances of the real `HeroDetailService` all along!\n-->\n<p>이런 경우에는 <code>TestBed.configureTestingModule</code>의 <code>providers</code>에서 <code>HeroDetailService</code>에 대한 목 클래스를 등록할 수 없습니다.\n<em>테스트 모듈</em> 에 등록하는 프로바이더는 모듈 계층에 등록되는 것이지 컴포넌트에 등록되는 것이 아니기 때문입니다.\n그래서 이 경우에는 <em>픽스쳐 계층(fixture level)</em> 에 있는 의존성 주입기를 활용해야 합니다.</p>\n<p>Angular는 컴포넌트 계층에 인젝터를 생성하는데, 이 인젝터는 픽스쳐 인젝터의 <em>자식</em> 인젝터입니다.\n그래서 컴포넌트의 프로바이더에 등록된 서비스(이 경우에는 <code>HeroDetailService</code>)는 컴포넌트 자식 인젝터에 등록됩니다.</p>\n<p>하지만 픽스쳐 인젝터로는 자식 인젝터를 직접 참조할 수 없습니다.\n<code>TestBed.configureTestingModule</code>로도 픽스쳐 인젝터와 컴포넌트 인젝터에 접근할 수 없습니다.</p>\n<p>그래서 Angular는 테스트 환경에 실제 <code>HeroDetailService</code> 인스턴스를 생성하게 될 것입니다!</p>\n<div class=\"alert is-helpful\">\n<!--\nThese tests could fail or timeout if the `HeroDetailService` made its own XHR calls to a remote server.\nThere might not be a remote server to call.\n\nFortunately, the `HeroDetailService` delegates responsibility for remote data access to an injected `HeroService`.\n-->\n<p><code>HeroDetailService</code>가 리모트 서버로 XHR 요청을 보낸다면 테스트가 실패하거나 타임아웃이 발생할 수 있습니다.\n리모트 서버로 요청을 보내는 코드는 없어야 합니다.</p>\n<p>다행히 <code>HeroDetailService</code>에서 데이터를 가져오는 로직은 <code>HeroService</code>를 활용하기 때문에, 리모트 서버로 보내는 요청은 <code>HeroService</code>에서 처리할 수 있습니다.</p>\n<!--\n<code-example path=\"testing/src/app/hero/hero-detail.service.ts\" region=\"prototype\" header=\"app/hero/hero-detail.service.ts (prototype)\" linenums=\"false\">\n@Injectable()\nexport class HeroDetailService {\n  constructor(private heroService: HeroService) {  }\n/* . . . */\n}\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/hero/hero-detail.service.ts\" region=\"prototype\" header=\"app/hero/hero-detail.service.ts (프로토타입)\" linenums=\"false\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class HeroDetailService {\n  constructor(private heroService: HeroService) {  }\n/* . . . */\n}\n\n</code-example>\n<!--\nThe [previous test configuration](#feature-module-import) replaces the real `HeroService` with a `TestHeroService`\nthat intercepts server requests and fakes their responses.\n-->\n<p><a href=\"guide/testing#feature-module-import\">이전에 살펴봤던 테스트 환경설정</a>에서 <code>HeroService</code>는 <code>TestHeroService</code>로 교체했기 때문에, 서버로 보내는 요청을 가로채서 원하는 응답을 대신 보낼 수 있습니다.</p>\n</div>\n<!--\nWhat if you aren't so lucky. What if faking the `HeroService` is hard?\nWhat if `HeroDetailService` makes its own server requests?\n\nThe `TestBed.overrideComponent` method can replace the component's `providers` with easy-to-manage _test doubles_\nas seen in the following setup variation:\n-->\n<p>이런 방식을 사용할 수 없는 경우를 생각해 봅시다.\n<code>HeroService</code>를 모킹하는 것이 어렵다면 어떻게 해야 할까요?\n<code>HeroDetailService</code>가 직접 서버로 요청을 보낸다면 또 어떻게 해야 할까요?</p>\n<p><code>TestBed.overrideComponent</code> 메소드를 사용하면 컴포넌트의 <code>providers</code>에 등록된 서비스를 좀 더 관리하기 쉬운 <em>목 클래스</em> 로 대체할 수 있습니다.\n이 함수는 다음과 같이 사용합니다:</p>\n<!--\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-override\" header=\"app/hero/hero-detail.component.spec.ts (Override setup)\" linenums=\"false\">\nbeforeEach(async(() =&gt; {\n  const routerSpy = createRouterSpy();\n\n  TestBed.configureTestingModule({\n    imports:   [ HeroModule ],\n    providers: [\n      { provide: ActivatedRoute, useValue: activatedRoute },\n      { provide: Router,         useValue: routerSpy},\n    ]\n  })\n\n  // 컴포넌트에 등록된 프로바이더를 오버라이드합니다.\n  .overrideComponent(HeroDetailComponent, {\n    set: {\n      providers: [\n        { provide: HeroDetailService, useClass: HeroDetailServiceSpy }\n      ]\n    }\n  })\n\n  .compileComponents();\n}));\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-override\" header=\"app/hero/hero-detail.component.spec.ts (오버라이드 환경설정)\" linenums=\"false\">\nbeforeEach(<a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>(() => {\n  const routerSpy = createRouterSpy();\n\n  TestBed.configureTestingModule({\n    <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>:   [ HeroModule ],\n    providers: [\n      { provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: <a href=\"api/router/RouterOutlet#activatedRoute\" class=\"code-anchor\">activatedRoute</a> },\n      { provide: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,         useValue: routerSpy},\n    ]\n  })\n\n  // 컴포넌트에 등록된 프로바이더를 오버라이드합니다.\n  .overrideComponent(HeroDetailComponent, {\n    set: {\n      providers: [\n        { provide: HeroDetailService, useClass: HeroDetailServiceSpy }\n      ]\n    }\n  })\n\n  .compileComponents();\n}));\n\n</code-example>\n<!--\nNotice that `TestBed.configureTestingModule` no longer provides a (fake) `HeroService` because it's [not needed](#spy-stub).\n-->\n<p><code>TestBed.configureTestingModule</code>에는 더이상 목 <code>HeroService</code>를 등록할 필요가 없습니다.</p>\n<a id=\"override-component-method\"></a>\n<!--\n#### The _overrideComponent_ method\n-->\n<h4 id=\"overridecomponent-메소드\"><em>overrideComponent</em> 메소드<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#overridecomponent-메소드\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nFocus on the `overrideComponent` method.\n-->\n<p><code>overrideComponent</code> 메소드를 자세히 봅시다.</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"override-component-method\" header=\"app/hero/hero-detail.component.spec.ts (overrideComponent)\" linenums=\"false\">\n.overrideComponent(HeroDetailComponent, {\n  set: {\n    providers: [\n      { provide: HeroDetailService, useClass: HeroDetailServiceSpy }\n    ]\n  }\n})\n\n</code-example>\n<!--\nIt takes two arguments: the component type to override (`HeroDetailComponent`) and an override metadata object.\nThe [override metadata object](#metadata-override-object) is a generic defined as follows:\n-->\n<p>이 메소드는 프로바이더가 등록된 컴포넌트 타입(<code>HeroDetailComponent</code>)과 오버라이드 메타데이터 객체, 총 2개의 인자를 받습니다.\n이 때 <a href=\"guide/testing#metadata-override-object\">메타데이터 오버라이드 객체(metadata override object)</a>는 다음과 같이 제네릭으로 정의되어 있습니다:</p>\n<!--\n<code-example format=\".\" language=\"javascript\">\n  type MetadataOverride<T> = {\n    add?: Partial<T>;\n    remove?: Partial<T>;\n    set?: Partial<T>;\n  };\n</code-example>\n-->\n<code-example format=\".\" language=\"javascript\">\n  type <a href=\"api/core/testing/MetadataOverride\" class=\"code-anchor\">MetadataOverride</a>&#x3C;T> = {\n    add?: Partial&#x3C;T>;\n    remove?: Partial&#x3C;T>;\n    set?: Partial&#x3C;T>;\n  };\n</code-example>\n<!--\nA metadata override object can either add-and-remove elements in metadata properties or completely reset those properties.\nThis example resets the component's `providers` metadata.\n\nThe type parameter, `T`, is the kind of metadata you'd pass to the `@Component` decorator:\n-->\n<p>메타데이터 오버라이드 객체는 컴포넌트에 적용된 메타데이터 프로퍼티를 추가하거나 제거할 수도 있고, 완전히 새로운 값으로 교체할 수도 있습니다.\n위에서 사용한 예제 코드는 컴포넌트의 <code>providers</code> 메타데이터를 새로운 값으로 교체하는 코드입니다.</p>\n<p>그리고 타입 인자 <code>T</code>는 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 데코레이터에 전달하는 메타데이터 중 하나를 사용할 수 있습니다:</p>\n<code-example format=\".\" language=\"javascript\">\n  selector?: string;\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>?: string;\n  templateUrl?: string;\n  providers?: any[];\n  ...\n</code-example>\n<a id=\"spy-stub\"></a>\n<!--\n#### Provide a _spy stub_ (_HeroDetailServiceSpy_)\n-->\n<h4 id=\"스파이-객체-등록하기-herodetailservicespy\"><em>스파이 객체</em> 등록하기 (<em>HeroDetailServiceSpy</em>)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#스파이-객체-등록하기-herodetailservicespy\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThis example completely replaces the component's `providers` array with a new array containing a `HeroDetailServiceSpy`.\n\nThe `HeroDetailServiceSpy` is a stubbed version of the real `HeroDetailService`\nthat fakes all necessary features of that service.\nIt neither injects nor delegates to the lower level `HeroService`\nso there's no need to provide a test double for that.\n\nThe related `HeroDetailComponent` tests will assert that methods of the `HeroDetailService`\nwere called by spying on the service methods.\nAccordingly, the stub implements its methods as spies:\n-->\n<p>위에서 살펴본 예제는 컴포넌트의 <code>providers</code> 배열을 완전히 새로운 배열로 교체하는 코드이며, 이 때 새로운 배열에는 <code>HeroDetailServiceSpy</code>가 사용되었습니다.</p>\n<p><code>HeroDetailServiceSpy</code>는 실제 <code>HeroDetailService</code>의 기능을 모두 대신하는 목 클래스입니다.\n그리고 목 클래스의 모든 메소드는 스파이 메소드로 구현할 것이기 때문에 <code>HeroService</code>를 주입할 필요도 없습니다.</p>\n<p>이렇게 <code>providers</code> 배열을 오버라이드하고 나면 <code>HeroDetailComponent</code>가 <code>HeroDetailService</code>를 활용하는 로직이 모두 스파이 메소드를 실행하게 됩니다.\n<code>HeroDetailService</code>는 다음과 같이 구현합니다:</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"hds-spy\" header=\"app/hero/hero-detail.component.spec.ts (HeroDetailServiceSpy)\" linenums=\"false\">\nclass HeroDetailServiceSpy {\n  testHero: Hero = {id: 42, name: 'Test Hero' };\n\n  /* 히어로 객체를 복사해서 보냅니다. */\n  getHero = jasmine.createSpy('getHero').and.callFake(\n    () => asyncData(Object.assign({}, this.testHero))\n  );\n\n  /* 복사한 히어로 객체에 변경사항을 반영해서 보냅니다. */\n  saveHero = jasmine.createSpy('saveHero').and.callFake(\n    (hero: Hero) => asyncData(Object.assign(this.testHero, hero))\n  );\n}\n\n\n</code-example>\n<a id=\"override-tests\"></a>\n<!--\n#### The override tests\n-->\n<h4 id=\"오버라이드-테스트\">오버라이드 테스트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#오버라이드-테스트\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nNow the tests can control the component's hero directly by manipulating the spy-stub's `testHero`\nand confirm that service methods were called.\n-->\n<p>이제 컴포넌트를 테스트하면서 사용하는 히어로 객체는 스파이 클래스의 <code>testHero</code> 프로퍼티로 직접 조작할 수 있습니다.\n그리고 서비스 메소드를 실행하는 것도 확인할 수 있습니다.</p>\n<!--\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"override-tests\" header=\"app/hero/hero-detail.component.spec.ts (override tests)\" linenums=\"false\">\nlet hdsSpy: HeroDetailServiceSpy;\n\nbeforeEach(async(() =&gt; {\n  createComponent();\n  // 컴포넌트에 주입된 HeroDetailServiceSpy를 참조합니다.\n  hdsSpy = fixture.debugElement.injector.get(HeroDetailService) as any;\n}));\n\nit(&#39;should have called `getHero`&#39;, () =&gt; {\n  expect(hdsSpy.getHero.calls.count()).toBe(1, &#39;getHero called once&#39;);\n});\n\nit(&#39;should display stub hero\\&#39;s name&#39;, () =&gt; {\n  expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name);\n});\n\nit(&#39;should save stub hero change&#39;, fakeAsync(() =&gt; {\n  const origName = hdsSpy.testHero.name;\n  const newName = &#39;New Name&#39;;\n\n  page.nameInput.value = newName;\n  page.nameInput.dispatchEvent(newEvent(&#39;input&#39;)); // 값이 변경되었다는 이벤트를 보냅니다.\n\n  expect(component.hero.name).toBe(newName, &#39;component hero has new name&#39;);\n  expect(hdsSpy.testHero.name).toBe(origName, &#39;service hero unchanged before save&#39;);\n\n  click(page.saveBtn);\n  expect(hdsSpy.saveHero.calls.count()).toBe(1, &#39;saveHero called once&#39;);\n\n  tick(); // 비동기 저장 로직이 끝나는 것을 기다립니다.\n  expect(hdsSpy.testHero.name).toBe(newName, &#39;service hero has new name after save&#39;);\n  expect(page.navigateSpy.calls.any()).toBe(true, &#39;router.navigate called&#39;);\n}));\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"override-tests\" header=\"app/hero/hero-detail.component.spec.ts (오버라이드 테스트)\" linenums=\"false\">\nlet hdsSpy: HeroDetailServiceSpy;\n\nbeforeEach(<a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>(() => {\n  createComponent();\n  // 컴포넌트에 주입된 HeroDetailServiceSpy를 참조합니다.\n  hdsSpy = fixture.debugElement.injector.get(HeroDetailService) as any;\n}));\n\nit('should have called `getHero`', () => {\n  expect(hdsSpy.getHero.calls.count()).toBe(1, 'getHero called once');\n});\n\nit('should display stub hero\\'s name', () => {\n  expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name);\n});\n\nit('should save stub hero change', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() => {\n  const origName = hdsSpy.testHero.name;\n  const newName = 'New Name';\n\n  page.nameInput.value = newName;\n  page.nameInput.dispatchEvent(newEvent('input')); // 값이 변경되었다는 이벤트를 보냅니다.\n\n  expect(component.hero.name).toBe(newName, 'component hero has new name');\n  expect(hdsSpy.testHero.name).toBe(origName, 'service hero unchanged before save');\n\n  click(page.saveBtn);\n  expect(hdsSpy.saveHero.calls.count()).toBe(1, 'saveHero called once');\n\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(); // 비동기 저장 로직이 끝나는 것을 기다립니다.\n  expect(hdsSpy.testHero.name).toBe(newName, 'service hero has new name after save');\n  expect(page.navigateSpy.calls.any()).toBe(true, 'router.navigate called');\n}));\n\n</code-example>\n<a id=\"more-overrides\"></a>\n<!--\n#### More overrides\n-->\n<h4 id=\"오버라이드-활용하기\">오버라이드 활용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#오버라이드-활용하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe `TestBed.overrideComponent` method can be called multiple times for the same or different components.\nThe `TestBed` offers similar `overrideDirective`, `overrideModule`, and `overridePipe` methods\nfor digging into and replacing parts of these other classes.\n\nExplore the options and combinations on your own.\n-->\n<p><code>TestBed.overrideComponent</code> 메소드는 특정 컴포넌트나 여러 컴포넌트를 대상으로 여러번 실행할 수 있습니다.\n그리고 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>는 <code>overrideComponent</code>와 비슷하게 동작하는 <code>overrideDirective</code>나 <code>overrideModule</code>, <code>overridePipe</code> 메소드도 제공합니다.\n컴포넌트가 아닌 다른 Angular 구성요소도 얼마든지 조작할 수 있습니다.</p>\n<p>다양한 옵션과 함께 테스트에 활용하는 방법에 대해 자유롭게 연구해 보세요.</p>\n<hr>\n<a id=\"attribute-directive\"></a>\n<!--\n## Attribute Directive Testing\n-->\n<h2 id=\"어트리뷰트-디렉티브-테스트\">어트리뷰트 디렉티브 테스트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#어트리뷰트-디렉티브-테스트\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAn _attribute directive_ modifies the behavior of an element, component or another directive.\nIts name reflects the way the directive is applied: as an attribute on a host element.\n\nThe sample application's `HighlightDirective` sets the background color of an element\nbased on either a data bound color or a default color (lightgray).\nIt also sets a custom property of the element (`customProperty`) to `true`\nfor no reason other than to show that it can.\n-->\n<p><em>어트리뷰트 디렉티브(attribute directive)</em> 는 엘리먼트나 컴포넌트, 다른 디렉티브의 행동을 조작합니다.\n그리고 이름에서 알 수 있듯이, 이 디렉티브는 호스트 엘리먼트에 어트리뷰트처럼 사용합니다.</p>\n<p>예제 애플리케이션에서 <code>HighlightDirective</code>는 엘리먼트의 배경을 변경하는데, 이 때 바인딩 받거나 기본값(lightgray)으로 지정된 색상을 사용합니다.\n그리고 설명하기 위해서만 사용하지만, 이 디렉티브는 엘리먼트의 커스텀 프로퍼티(<code>customProperty</code>)를 <code>true</code> 값으로 설정하는 역할도 합니다.</p>\n<code-example path=\"testing/src/app/shared/highlight.directive.ts\" header=\"app/shared/highlight.directive.ts\" linenums=\"false\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a> } from '@angular/core';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({ selector: '[highlight]' })\n/** 엘리먼트의 배경색을 변경하고 customProperty를 true로 설정합니다. */\nexport class HighlightDirective implements <a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a> {\n\n  defaultColor =  'rgb(211, 211, 211)'; // lightgray\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('highlight') bgColor: string;\n\n  constructor(private el: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>) {\n    el.nativeElement.style.customProperty = true;\n  }\n\n  ngOnChanges() {\n    this.el.nativeElement.style.backgroundColor = this.bgColor || this.defaultColor;\n  }\n}\n\n\n</code-example>\n<!--\nIt's used throughout the application, perhaps most simply in the `AboutComponent`:\n-->\n<p>이 디렉티브를 <code>AboutComponent</code>에 사용한다면 다음과 같이 사용할 수 있습니다:</p>\n<code-example path=\"testing/src/app/about/about.component.ts\" header=\"app/about/about.component.ts\" linenums=\"false\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n  &#x3C;h2 highlight=\"skyblue\">About&#x3C;/h2>\n  &#x3C;h3>Quote of the day:&#x3C;/h3>\n  &#x3C;twain-quote>&#x3C;/twain-quote>\n  `\n})\nexport class AboutComponent { }\n\n\n</code-example>\n<!--\nTesting the specific use of the `HighlightDirective` within the `AboutComponent` requires only the\ntechniques explored above (in particular the [\"Shallow test\"](#nested-component-tests) approach).\n-->\n<p><code>HighlightDirective</code>를 <code>AboutComponent</code>에 사용하는 것을 테스트하는 것은 위에서 살펴본 것으로 충분합니다.\n더 자세한 내용은 <a href=\"guide/testing#%EC%A4%91%EC%B2%A9%EB%90%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%ED%85%8C%EC%8A%A4%ED%8A%B8\">중첩된 컴포넌트 테스트</a> 섹션을 참고하세요.</p>\n<code-example path=\"testing/src/app/about/about.component.spec.ts\" region=\"tests\" header=\"app/about/about.component.spec.ts\" linenums=\"false\">\nbeforeEach(() => {\n  fixture = TestBed.configureTestingModule({\n    <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [ AboutComponent, HighlightDirective],\n    <a href=\"api/core/NgModule#schemas\" class=\"code-anchor\">schemas</a>:      [ <a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a> ]\n  })\n  .createComponent(AboutComponent);\n  fixture.detectChanges(); // 초기 바인딩\n});\n\nit('should have skyblue &#x3C;h2>', () => {\n  const h2: HTMLElement = fixture.nativeElement.querySelector('h2');\n  const bgColor = h2.style.backgroundColor;\n  expect(bgColor).toBe('skyblue');\n});\n\n</code-example>\n<!--\nHowever, testing a single use case is unlikely to explore the full range of a directive's capabilities.\nFinding and testing all components that use the directive is tedious, brittle, and almost as unlikely to afford full coverage.\n\n_Class-only tests_ might be helpful,\nbut attribute directives like this one tend to manipulate the DOM.\nIsolated unit tests don't touch the DOM and, therefore,\ndo not inspire confidence in the directive's efficacy.\n\nA better solution is to create an artificial test component that demonstrates all ways to apply the directive.\n-->\n<p>그런데 한가지 사용방법을 테스트했다고 해서 이 디렉티브의 모든 내용을 확인했다고 하기는 어렵습니다.\n하지만 그렇다고 해서 이 디렉티브를 사용하는 모든 컴포넌트를 찾아서 테스트하는 것은 번거롭고 귀찮은 일이며, 꼭 그렇게 할 필요도 없습니다.</p>\n<p><em>클래스만 테스트하는 것</em> 은 간단하지만 어트리뷰트 디렉티브는 DOM을 조작하기 위해 만들어진 것입니다.\n그래서 DOM을 배제한 상태로 유닛 테스트를 진행하는 것은 디렉티브를 제대로 테스트했다고 할 수 없습니다.</p>\n<p>이런 경우에는 테스트 컴포넌트를 따로 정의해서 이 컴포넌트를 대상으로 디렉티브를 다양하게 적용해보는 것이 더 좋습니다.</p>\n<code-example path=\"testing/src/app/shared/highlight.directive.spec.ts\" region=\"test-component\" header=\"app/shared/highlight.directive.spec.ts (TestComponent)\" linenums=\"false\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n  &#x3C;h2 highlight=\"yellow\">Something Yellow&#x3C;/h2>\n  &#x3C;h2 highlight>The Default (Gray)&#x3C;/h2>\n  &#x3C;h2>No Highlight&#x3C;/h2>\n  &#x3C;input #box [highlight]=\"box.value\" value=\"cyan\"/>`\n})\nclass TestComponent { }\n\n</code-example>\n<figure>\n  <img src=\"generated/images/guide/testing/highlight-directive-spec.png\" alt=\"HighlightDirective spec in action\" width=\"200\" height=\"159\">\n</figure>\n<div class=\"alert is-helpful\">\n<!--\nThe `<input>` case binds the `HighlightDirective` to the name of a color value in the input box.\nThe initial value is the word \"cyan\" which should be the background color of the input box.\n-->\n<p><code>&#x3C;input></code>는 <code>HighlightDirective</code>와 입력 필드에 입력된 색상을 바인딩합니다.\n이 때 초기값은 \"cyan\"으로 지정했습니다.</p>\n</div>\n<!--\nHere are some tests of this component:\n-->\n<p>이 디렉티브는 다음과 같이 테스트할 수 있습니다:</p>\n<!--\n<code-example path=\"testing/src/app/shared/highlight.directive.spec.ts\" region=\"selected-tests\" header=\"app/shared/highlight.directive.spec.ts (selected tests)\">\nbeforeEach(() =&gt; {\n  fixture = TestBed.configureTestingModule({\n    declarations: [ HighlightDirective, TestComponent ]\n  })\n  .createComponent(TestComponent);\n\n  fixture.detectChanges(); // 초기 바인딩\n\n  // HighlightDirective를 사용한 엘리먼트를 모두 쿼리합니다.\n  des = fixture.debugElement.queryAll(By.directive(HighlightDirective));\n\n  // HighlightDirective를 사용하지 않은 h2를 쿼리합니다.\n  bareH2 = fixture.debugElement.query(By.css(&#39;h2:not([highlight])&#39;));\n});\n\n// 색상 테스트\nit(&#39;should have three highlighted elements&#39;, () =&gt; {\n  expect(des.length).toBe(3);\n});\n\nit(&#39;should color 1st &lt;h2&gt; background &quot;yellow&quot;&#39;, () =&gt; {\n  const bgColor = des[0].nativeElement.style.backgroundColor;\n  expect(bgColor).toBe(&#39;yellow&#39;);\n});\n\nit(&#39;should color 2nd &lt;h2&gt; background w/ default color&#39;, () =&gt; {\n  const dir = des[1].injector.get(HighlightDirective) as HighlightDirective;\n  const bgColor = des[1].nativeElement.style.backgroundColor;\n  expect(bgColor).toBe(dir.defaultColor);\n});\n\nit(&#39;should bind &lt;input&gt; background to value color&#39;, () =&gt; {\n  // nativeElement를 사용하면 편합니다.\n  const input = des[2].nativeElement as HTMLInputElement;\n  expect(input.style.backgroundColor).toBe(&#39;cyan&#39;, &#39;initial backgroundColor&#39;);\n\n  // 입력 필드의 값을 변경하고 DOM 이벤트를 보내면 Angular가 이 이벤트에 반응합니다.\n  input.value = &#39;green&#39;;\n  input.dispatchEvent(newEvent(&#39;input&#39;));\n  fixture.detectChanges();\n\n  expect(input.style.backgroundColor).toBe(&#39;green&#39;, &#39;changed backgroundColor&#39;);\n});\n\n\nit(&#39;bare &lt;h2&gt; should not have a customProperty&#39;, () =&gt; {\n  expect(bareH2.properties[&#39;customProperty&#39;]).toBeUndefined();\n});\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/shared/highlight.directive.spec.ts\" region=\"selected-tests\" header=\"app/shared/highlight.directive.spec.ts (테스트 일부)\">\nbeforeEach(() => {\n  fixture = TestBed.configureTestingModule({\n    <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [ HighlightDirective, TestComponent ]\n  })\n  .createComponent(TestComponent);\n\n  fixture.detectChanges(); // 초기 바인딩\n\n  // HighlightDirective를 사용한 엘리먼트를 모두 쿼리합니다.\n  des = fixture.debugElement.queryAll(By.directive(HighlightDirective));\n\n  // HighlightDirective를 사용하지 않은 h2를 쿼리합니다.\n  bareH2 = fixture.debugElement.query(By.css('h2:not([highlight])'));\n});\n\n// 색상 테스트\nit('should have three highlighted elements', () => {\n  expect(des.length).toBe(3);\n});\n\nit('should color 1st &#x3C;h2> background \"yellow\"', () => {\n  const bgColor = des[0].nativeElement.style.backgroundColor;\n  expect(bgColor).toBe('yellow');\n});\n\nit('should color 2nd &#x3C;h2> background w/ default color', () => {\n  const dir = des[1].injector.get(HighlightDirective) as HighlightDirective;\n  const bgColor = des[1].nativeElement.style.backgroundColor;\n  expect(bgColor).toBe(dir.defaultColor);\n});\n\nit('should bind &#x3C;input> background to value color', () => {\n  // nativeElement를 사용하면 편합니다.\n  const input = des[2].nativeElement as HTMLInputElement;\n  expect(input.style.backgroundColor).toBe('cyan', 'initial backgroundColor');\n\n  // 입력 필드의 값을 변경하고 DOM 이벤트를 보내면 Angular가 이 이벤트에 반응합니다.\n  input.value = 'green';\n  input.dispatchEvent(newEvent('input'));\n  fixture.detectChanges();\n\n  expect(input.style.backgroundColor).toBe('green', 'changed backgroundColor');\n});\n\n\nit('bare &#x3C;h2> should not have <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> customProperty', () => {\n  expect(bareH2.properties['customProperty']).toBeUndefined();\n});\n\n</code-example>\n<!--\nA few techniques are noteworthy:\n\n- The `By.directive` predicate is a great way to get the elements that have this directive _when their element types are unknown_.\n\n- The <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/:not\">`:not` pseudo-class</a>\n  in `By.css('h2:not([highlight])')` helps find `<h2>` elements that _do not_ have the directive.\n  `By.css('*:not([highlight])')` finds _any_ element that does not have the directive.\n\n- `DebugElement.styles` affords access to element styles even in the absence of a real browser, thanks to the `DebugElement` abstraction.\n  But feel free to exploit the `nativeElement` when that seems easier or more clear than the abstraction.\n\n- Angular adds a directive to the injector of the element to which it is applied.\n  The test for the default color uses the injector of the second `<h2>` to get its `HighlightDirective` instance\n  and its `defaultColor`.\n\n- `DebugElement.properties` affords access to the artificial custom property that is set by the directive.\n-->\n<p>이 테스트 코드에서 이런 내용이 중요합니다:</p>\n<ul>\n<li>\n<p><code>By.directive</code>를 사용하면 <em>엘리먼트의 타입을 알지 못하더라도</em> 원하는 디렉티브가 적용된 엘리먼트를 간단하게 쿼리할 수 있습니다.</p>\n</li>\n<li>\n<p><code>By.css('h2:not([highlight])')</code>라고 사용할 때 <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/:not\">가상 클래스(pseudo-class) <code>:not</code></a>을 사용했기 때문에 이 디렉티브가 <em>사용되지 않은</em> <code>&#x3C;h2></code> 엘리먼트를 가져왔습니다.\n<code>By.css('*:not([highlight])')</code>라고 사용하면 이 디렉티브가 사용되지 않은 <em>모든</em> 엘리먼트를 쿼리합니다.</p>\n</li>\n<li>\n<p><code><a href=\"api/core/DebugElement#styles\" class=\"code-anchor\">DebugElement.styles</a></code>를 사용하면 실제 브라우저에 없는 엘리먼트 스타일에도 접근할 수 있습니다. 이것은 모두 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>가 추상화된 객체이기 때문입니다.\n하지만 추상화된 클래스보다는 실제 엘리먼트 클래스인 <code>nativeElement</code>를 사용하는 것이 더 간단하고 명확하긴 합니다.</p>\n</li>\n<li>\n<p>Angular는 디렉티브가 적용된 엘리먼트의 인젝터에 이 디렉티브를 등록합니다.\n그래서 두번째 <code>&#x3C;h2></code> 엘리먼트를 테스트할 때는 엘리먼트 인젝터로 <code>HighlightDirective</code>의 인스턴스를 가져온 후에 이 디렉티브의 <code>defaultColor</code> 프로퍼티에 직접 접근하는 방법을 사용했습니다.</p>\n</li>\n<li>\n<p><code><a href=\"api/core/DebugElement#properties\" class=\"code-anchor\">DebugElement.properties</a></code>를 사용하면 디렉티브가 엘리먼트에 설정한 커스텀 프로퍼티를 참조할 수 있습니다.</p>\n</li>\n</ul>\n<hr>\n<!--\n## Pipe Testing\n-->\n<h2 id=\"파이프-테스트\">파이프 테스트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#파이프-테스트\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nPipes are easy to test without the Angular testing utilities.\n\nA pipe class has one method, `transform`, that manipulates the input\nvalue into a transformed output value.\nThe `transform` implementation rarely interacts with the DOM.\nMost pipes have no dependence on Angular other than the `@Pipe`\nmetadata and an interface.\n\nConsider a `TitleCasePipe` that capitalizes the first letter of each word.\nHere's a naive implementation with a regular expression.\n-->\n<p>파이프는 Angular의 테스트 유틸리티를 사용하지 않더라도 테스트하기 쉽습니다.</p>\n<p>파이프는 입력으로 받은 값을 어떤 형태로 변환하는 역할만 하기 때문에 파이프에는 <code>transform</code> 메소드 하나만 정의되어 있습니다.\n그리고 <code>transform</code> 메소드는 DOM과 상호작용하는 일도 거의 없습니다.\n게다가 파이프는 <code>@<a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a></code> 메타데이터와 인터페이스 외에 또 다른 Angular 구성요소를 의존성으로 주입받는 일도 거의 없습니다.</p>\n<p>각 단어의 첫 글자를 대문자로 변환하는 <code><a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a></code>를 살펴봅시다.\n이 파이프는 정규 표현식을 사용해서 간단하게 구현된 파이프입니다.</p>\n<code-example path=\"testing/src/app/shared/title-case.pipe.ts\" header=\"app/shared/title-case.pipe.ts\" linenums=\"false\">\nimport { <a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a>, <a href=\"api/core/PipeTransform\" class=\"code-anchor\">PipeTransform</a> } from '@angular/core';\n\n@<a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a>({name: 'titlecase', <a href=\"api/core/Pipe#pure\" class=\"code-anchor\">pure</a>: true})\n/** 문자열의 각 단어 중 첫글자를 대문자로 변환합니다. */\nexport class <a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a> implements <a href=\"api/core/PipeTransform\" class=\"code-anchor\">PipeTransform</a> {\n  transform(input: string): string {\n    return input.length === 0 ? '' :\n      input.replace(/\\w\\S*/g, (txt => txt[0].toUpperCase() + txt.substr(1).toLowerCase() ));\n  }\n}\n\n\n</code-example>\n<!--\nAnything that uses a regular expression is worth testing thoroughly.\nUse simple Jasmine to explore the expected cases and the edge cases.\n-->\n<p>정규표현식을 사용하는 로직은 충분히 테스트할 필요가 있습니다.\n그래서 경계 조건을 포함해서 다양한 시나리오를 검토해보는 것이 좋습니다.\n이 테스트 스펙들은 Jasmine을 사용해서 다음과 같이 작성할 수 있습니다.</p>\n<code-example path=\"testing/src/app/shared/title-case.pipe.spec.ts\" region=\"excerpt\" header=\"app/shared/title-case.pipe.spec.ts\">\ndescribe('<a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a>', () => {\n  // 파이프는 순수 함수이며 스테이트도 없습니다. 따라서 BeforeEach는 필요 없습니다.\n  let pipe = new <a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a>();\n\n  it('transforms \"abc\" to \"Abc\"', () => {\n    expect(pipe.transform('abc')).toBe('Abc');\n  });\n\n  it('transforms \"abc def\" to \"Abc Def\"', () => {\n    expect(pipe.transform('abc def')).toBe('Abc Def');\n  });\n\n  // ... 테스트 계속 ...\n});\n\n</code-example>\n<a id=\"write-tests\"></a>\n<!--\n#### Write DOM tests too\n-->\n<h4 id=\"dom-조작-테스트\">DOM 조작 테스트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#dom-조작-테스트\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThese are tests of the pipe _in isolation_.\nThey can't tell if the `TitleCasePipe` is working properly as applied in the application components.\n\nConsider adding component tests such as this one:\n-->\n<p>지금까지는 <em>분리된 환경에서</em> 파이프를 테스트해 봤습니다.\n그래서 이 테스트 코드들만으로는 <code><a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a></code>가 애플리케이션에 있는 컴포넌트에 적용되었을 때도 제대로 동작한다고 할 수 없습니다.</p>\n<p>그렇다면 다음과 같이 컴포넌트에 적용해서 테스트하는 코드를 작성하는 것도 좋습니다:</p>\n<!--\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"title-case-pipe\" header=\"app/hero/hero-detail.component.spec.ts (pipe test)\">\nit(&#39;should convert hero name to Title Case&#39;, () =&gt; {\n  // 이름에 해당하는 input 엘리먼트와 이 이름을 화면에 표시하는 span 엘리먼트를 DOM에서 참조합니다.\n  const hostElement = fixture.nativeElement;\n  const nameInput: HTMLInputElement = hostElement.querySelector(&#39;input&#39;);\n  const nameDisplay: HTMLElement = hostElement.querySelector(&#39;span&#39;);\n\n  // 사용자가 입력한 것처럼 입력 필드의 내용을 변경합니다.\n  nameInput.value = &#39;quick BROWN  fOx&#39;;\n\n  // 엘리먼트의 값이 변경되었다는 것을 Angular에게 알리기 위해 DOM 이벤트를 생성합니다.\n  nameInput.dispatchEvent(newEvent(&#39;input&#39;));\n\n  // Angular가 화면을 갱신하도록 detectChanges() 함수를 실행합니다.\n  fixture.detectChanges();\n\n  expect(nameDisplay.textContent).toBe(&#39;Quick Brown  Fox&#39;);\n});\n\n</code-example>\n-->\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"title-case-pipe\" header=\"app/hero/hero-detail.component.spec.ts (파이프 테스트)\">\nit('should convert hero name to <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a> Case', () => {\n  // 이름에 해당하는 input 엘리먼트와 이 이름을 화면에 표시하는 span 엘리먼트를 DOM에서 참조합니다.\n  const hostElement = fixture.nativeElement;\n  const nameInput: HTMLInputElement = hostElement.querySelector('input');\n  const nameDisplay: HTMLElement = hostElement.querySelector('span');\n\n  // 사용자가 입력한 것처럼 입력 필드의 내용을 변경합니다.\n  nameInput.value = 'quick BROWN  fOx';\n\n  // 엘리먼트의 값이 변경되었다는 것을 Angular에게 알리기 위해 DOM 이벤트를 생성합니다.\n  nameInput.dispatchEvent(newEvent('input'));\n\n  // Angular가 화면을 갱신하도록 detectChanges() 함수를 실행합니다.\n  fixture.detectChanges();\n\n  expect(nameDisplay.textContent).toBe('Quick Brown  Fox');\n});\n\n</code-example>\n<hr>\n<a id=\"test-debugging\"></a>\n<!--\n## Test debugging\n-->\n<h2 id=\"테스트-디버깅하기\">테스트 디버깅하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#테스트-디버깅하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nDebug specs in the browser in the same way that you debug an application.\n\n1. Reveal the karma browser window (hidden earlier).\n1. Click the **DEBUG** button; it opens a new browser tab and re-runs the tests.\n1. Open the browser's “Developer Tools” (`Ctrl-Shift-I` on windows; `Command-Option-I` in OSX).\n1. Pick the \"sources\" section.\n1. Open the `1st.spec.ts` test file (Control/Command-P, then start typing the name of the file).\n1. Set a breakpoint in the test.\n1. Refresh the browser, and it stops at the breakpoint.\n-->\n<p>테스트 스펙을 디버깅하는 방법은 브라우저에서 애플리케이션을 디버깅하는 방법과 같습니다.</p>\n<ol>\n<li>Karma가 실행되고 있는 브라우저를 찾습니다.</li>\n<li><strong>DEBUG</strong> 버튼을 누릅니다. 그러면 새로운 브라우저 탭이 열리면서 테스트가 다시 시작됩니다.</li>\n<li>브라우저에서 \"개발자 도구\"를 엽니다. (윈도우에서는 <code>Ctrl-Shift-I</code>, OSX에서는 <code>Command-Option-I</code>)</li>\n<li>\"Sources\" 탭을 선택합니다.</li>\n<li><code>1st.spec.ts</code> 테스트 파일을 엽니다. (Control/Common-P를 누르고 파일 이름을 입력하면 됩니다.)</li>\n<li>테스트 파일에 중단점을 지정합니다.</li>\n<li>브라우저를 새로고침합니다. 그러면 중단점으로 설정했던 코드에서 코드 실행이 멈춥니다.</li>\n</ol>\n<figure>\n  <img src=\"generated/images/guide/testing/karma-1st-spec-debug.png\" alt=\"Karma debugging\" width=\"700\" height=\"150\">\n</figure>\n<hr>\n<a id=\"atu-apis\"></a>\n<!--\n## Testing Utility APIs\n-->\n<h2 id=\"테스트-유틸리티\">테스트 유틸리티<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#테스트-유틸리티\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThis section takes inventory of the most useful Angular testing features and summarizes what they do.\n\nThe Angular testing utilities include the `TestBed`, the `ComponentFixture`, and a handful of functions that control the test environment.\nThe [_TestBed_](#testbed-api-summary) and [_ComponentFixture_](#component-fixture-api-summary) classes are covered separately.\n\nHere's a summary of the stand-alone functions, in order of likely utility:\n-->\n<p>이 섹션에서는 테스트 코드를 작성하면서 자주 사용하는 Angular 테스트 유틸리티에 대해 알아봅니다.</p>\n<p><code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>나 <code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code>에서 제공하는 테스트 유틸리티를 활용하면 테스트 환경을 자유롭게 조작할 수 있습니다.\n그래서 이번 섹션에서는<a href=\"guide/testing#testbed-api-summary\"><em>TestBed</em></a>와 <a href=\"guide/testing#component-fixture-api-summary\"><em>ComponentFixture</em></a>를 하나씩 다루면서 자세하게 살펴볼 것입니다.</p>\n<p>자주 사용하는 테스트 함수 중 단독으로 사용할 수 있는 함수들은 이런 것들이 있습니다:</p>\n<table>\n  <tbody><tr>\n    <!--\n    <th>\n      Function\n    </th>\n    <th>\n      Description\n    </th>\n    -->\n    <th>\n      함수\n    </th>\n    <th>\n      설명\n    </th>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code><a href=\"api/core/testing/async\" class=\"code-anchor\">async</a></code>\n    </td>\n    <td>\n      <!--\n      Runs the body of a test (`it`) or setup (`beforeEach`) function within a special _async test zone_.\n      See [discussion above](#async).\n      -->\n<p>      테스트 스펙의 몸체(<code>it</code>)나 환경설정 로직(<code>beforeEach</code>)를 <em>async 테스트 존</em> 에서 실행합니다.\n자세한 내용은 <a href=\"guide/testing#async\">위에서 설명한 것</a>을 참고하세요.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a></code>\n    </td>\n    <td>\n      <!--\n      Runs the body of a test (`it`) within a special _fakeAsync test zone_, enabling\n      a linear control flow coding style. See [discussion above](#fake-async).\n      -->\n<p>      테스트 스펙의 몸체(<code>it</code>)를 <em>fakeAsync 테스트 존</em> 에서 실행하며, 비동기 로직을 선형으로 제어할 수 있습니다.\n자세한 내용은 <a href=\"guide/testing#fake-async\">위에서 설명한 것</a>을 참고하세요.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a></code>\n    </td>\n    <td>\n      <!--\n      Simulates the passage of time and the completion of pending asynchronous activities\n      by flushing both _timer_ and _micro-task_ queues within the _fakeAsync test zone_.\n      -->\n<p>      테스트가 실행되는 환경의 시간을 빠르게 돌려서 <em>fakeAsync 테스트 존</em> 에서 아직 처리되지 않은 <em>타이머</em> 나 <em>마이크로 태스크</em> 를 처리합니다.</p>\n      <div class=\"alert is-helpful\">\n      <!--\n      The curious, dedicated reader might enjoy this lengthy blog post,\n      [\"_Tasks, microtasks, queues and schedules_\"](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/).\n      -->\n<p>      <a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\">\"<em>Tasks, microtasks, queues and schedules</em>\"</a> 블로그 글도 한 번 읽어보세요.</p>\n      </div>\n      <!--\n      Accepts an optional argument that moves the virtual clock forward\n      by the specified number of milliseconds,\n      clearing asynchronous activities scheduled within that timeframe.\n      See [discussion above](#tick).\n      -->\n<p>      숫자를 밀리초 단위로 전달하면 시간이 해당 시간만큼 지난 것을 처리할 수 있으며, 이 시간동안 실행되는 비동기 작업도 모두 완료됩니다.\n자세한 내용은 <a href=\"guide/testing#tick\">위에서 설명한 것</a>을 참고하세요.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n       <code>inject</code>\n    </td>\n    <td>\n      <!--\n      Injects one or more services from the current `TestBed` injector into a test function.\n      It cannot inject a service provided by the component itself.\n      See discussion of the [debugElement.injector](#get-injected-services).\n      -->\n<p>      <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 인젝터를 사용해서 테스트 스펙에 서비스를 의존성으로 주입합니다.\n컴포넌트에 프로바이더로 등록된 서비스는 주입할 수 없습니다.\n자세한 내용은 <a href=\"guide/testing#%EC%9D%98%EC%A1%B4%EC%84%B1%EC%9C%BC%EB%A1%9C-%EC%A3%BC%EC%9E%85%ED%95%9C-%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0\">debugElement.injector</a>을 참고하세요.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code><a href=\"api/core/testing/discardPeriodicTasks\" class=\"code-anchor\">discardPeriodicTasks</a></code>\n    </td>\n    <td>\n      <!--\n      When a `fakeAsync()` test ends with pending timer event _tasks_ (queued `setTimeOut` and `setInterval` callbacks),\n      the test fails with a clear error message.\n\n      In general, a test should end with no queued tasks.\n      When pending timer tasks are expected, call `discardPeriodicTasks` to flush the _task_ queue\n      and avoid the error.\n      -->\n<p>      기본 상태에서 아직 처리되지 않은 타이머 이벤트 <em>태스크</em> (<code>setTimeout</code>, <code>setInterval</code> 콜백)가 있는 상태로 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 테스트가 끝나면 에러가 발생합니다.</p>\n<p>      일반적으로 테스트 스펙은 태스크 큐에 아무 태스크가 없는 상태에서 끝나야 합니다.\n하지만 <code><a href=\"api/core/testing/discardPeriodicTasks\" class=\"code-anchor\">discardPeriodicTasks</a></code> 함수를 사용하면 아직 처리되지 않은 타이머가 있다는 것을 의도한 것으로 처리하기 때문에, 바로 <em>태스크</em> 큐를 비우면서 테스트를 종료합니다.\n에러도 발생하지 않습니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code><a href=\"api/core/testing/flushMicrotasks\" class=\"code-anchor\">flushMicrotasks</a></code>\n    </td>\n    <td>\n      <!--\n      When a `fakeAsync()` test ends with pending _micro-tasks_ such as unresolved promises,\n      the test fails with a clear error message.\n\n      In general, a test should wait for micro-tasks to finish.\n      When pending microtasks are expected, call `flushMicrotasks` to flush the  _micro-task_ queue\n      and avoid the error.\n      -->\n<p>      기본 상태에서 아직 처리되지 않은 <em>마이크로 태스크</em> (끝나지 않은 Promise 등)가 있는 상태로 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 테스트가 끝나면 에러가 발생합니다.</p>\n<p>      일반적으로 테스트 스펙은 마이크로 태스크들이 모두 종료된 이후에 끝나야 합니다.\n하지만 <code>flushMicroTasks</code>를 사용하면 아직 처리되지 않은 마이크로 태스크가 있다는 것을 의도한 것으로 처리하기 때문에, 바로 <em>마이크로 태스크</em> 큐를 비우면서 테스트를 종료합니다.\n에러도 발생하지 않습니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code><a href=\"api/core/testing/ComponentFixtureAutoDetect\" class=\"code-anchor\">ComponentFixtureAutoDetect</a></code>\n    </td>\n    <td>\n      <!--\n      A provider token for a service that turns on [automatic change detection](#automatic-change-detection).\n      -->\n<p>      <a href=\"guide/testing#%EB%B3%80%ED%99%94%EA%B0%90%EC%A7%80-%EC%9E%90%EB%8F%99%EC%9C%BC%EB%A1%9C-%EC%8B%A4%ED%96%89%ED%95%98%EA%B8%B0\">변화감지를 자동으로 실행할 때</a> 사용하는 서비스 프로바이더 토큰입니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code><a href=\"api/core/testing/getTestBed\" class=\"code-anchor\">getTestBed</a></code>\n    </td>\n    <td>\n      <!--\n      Gets the current instance of the `TestBed`.\n      Usually unnecessary because the static class methods of the `TestBed` class are typically sufficient.\n      The `TestBed` instance exposes a few rarely used members that are not available as\n      static methods.\n      -->\n<p>      현재 사용하고 있는 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 인스턴스를 참조합니다.\n일반적으로 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 클래스는 정적 클래스 메소드로 제공되는 기능을 활용하는 것만으로도 충분합니다.\n하지만 정적 메소드로 제공되지 않는 일부 멤버를 참조해야하는 일이 생기면 이 때 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 인스턴스를 참조할 수 있습니다.</p>\n    </td>\n  </tr>\n</tbody></table>\n<hr>\n<a id=\"testbed-class-summary\"></a>\n<!--\n#### _TestBed_ class summary\n-->\n<h4 id=\"testbed-클래스\"><em>TestBed</em> 클래스<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#testbed-클래스\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe `TestBed` class is one of the principal Angular testing utilities.\nIts API is quite large and can be overwhelming until you've explored it,\na little at a time. Read the early part of this guide first\nto get the basics before trying to absorb the full API.\n\nThe module definition passed to `configureTestingModule`\nis a subset of the `@NgModule` metadata properties.\n-->\n<p><code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 클래스는 Angular가 제공하는 테스트 유틸리티 중에서도 가장 중요한 클래스입니다.\n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>가 제공하는 API는 상당히 방대하기 때문에 이 클래스를 훑어보는 것만으로도 부담이 될 수 있습니다.\n하지만 처음부터 모든 API를 알아야 하는 것은 아니기 때문에 이 문서에서 다룬 것처럼 필요한 것을 하나씩 찾아서 활용하는 것이 좋습니다.</p>\n<p><code>configureTestingModule</code> 메소드에 전달하는 모듈 정의는 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 메타데이터 프로퍼티의 서브셋입니다.</p>\n<code-example format=\".\" language=\"javascript\">\n  type <a href=\"api/core/testing/TestModuleMetadata\" class=\"code-anchor\">TestModuleMetadata</a> = {\n    providers?: any[];\n    <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>?: any[];\n    <a href=\"api/core/NgModule#imports\" class=\"code-anchor\">imports</a>?: any[];\n    <a href=\"api/core/NgModule#schemas\" class=\"code-anchor\">schemas</a>?: Array&#x3C;<a href=\"api/core/SchemaMetadata\" class=\"code-anchor\">SchemaMetadata</a> | any[]>;\n  };\n</code-example>\n<a id=\"metadata-override-object\"></a>\n<!--\nEach override method takes a `MetadataOverride<T>` where `T` is the kind of metadata\nappropriate to the method, that is, the parameter of an `@NgModule`,\n`@Component`, `@Directive`, or `@Pipe`.\n-->\n<p>이와 비슷하게 오버라이드 메소드가 인자로 받는 객체는 <code><a href=\"api/core/testing/MetadataOverride\" class=\"code-anchor\">MetadataOverride</a>&#x3C;T></code> 타입인데, 이 때 <code>T</code>는 메소드에 해당하는 메타데이터 타입을 의미합니다.\n그래서 메소드 인자는 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>이나 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code>, <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code>, <code>@<a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a></code>에 사용하는 메타데이터와 비슷하게 사용합니다.</p>\n<!--\n<code-example format=\".\" language=\"javascript\">\n  type MetadataOverride<T> = {\n    add?: Partial<T>;\n    remove?: Partial<T>;\n    set?: Partial<T>;\n  };\n</code-example>\n-->\n<code-example format=\".\" language=\"javascript\">\n  type <a href=\"api/core/testing/MetadataOverride\" class=\"code-anchor\">MetadataOverride</a>&#x3C;T> = {\n    add?: Partial&#x3C;T>;\n    remove?: Partial&#x3C;T>;\n    set?: Partial&#x3C;T>;\n  };\n</code-example>\n<a id=\"testbed-methods\"></a>\n<a id=\"testbed-api-summary\"></a>\n<!--\nThe `TestBed` API consists of static class methods that either update or reference a _global_ instance of the`TestBed`.\n\nInternally, all static methods cover methods of the current runtime `TestBed` instance,\nwhich is also returned by the `getTestBed()` function.\n\nCall `TestBed` methods _within_ a `beforeEach()` to ensure a fresh start before each individual test.\n\nHere are the most important static methods, in order of likely utility.\n-->\n<p><code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>가 제공하는 API 중 정적 클래스 메소드로 제공되는 것들은 <em>전역</em> 에 존재하는 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 인스턴스를 조작하거나 참조하는 것들입니다.</p>\n<p>내부적으로 정적 메소드들은 현재 테스트 환경에서 사용되고 있는 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 인스턴스가 실행하는 메소드에 모두 관여합니다.\n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 인스턴스를 반환하는 <code><a href=\"api/core/testing/getTestBed\" class=\"code-anchor\">getTestBed</a>()</code> 함수도 마찬가지입니다.</p>\n<p><code>beforeEach()</code> 안에서 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 메소드를 실행하면 환경설정이 깔끔하게 된 상태로 개별 테스트를 실행할 수 있습니다.</p>\n<p>정적 메소드 중에서 가장 중요하고 자주 사용하는 메소드들에 대해 알아봅시다.</p>\n<table>\n  <tbody><tr>\n    <th>\n      <!--\n      Methods\n      -->\n      메소드\n    </th>\n    <th>\n      <!--\n      Description\n      -->\n      설명\n    </th>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>configureTestingModule</code>\n    </td>\n    <td>\n      <!--\n      The testing shims (`karma-test-shim`, `browser-test-shim`)\n      establish the [initial test environment](guide/testing) and a default testing module.\n      The default testing module is configured with basic declaratives and some Angular service substitutes that every tester needs.\n\n      Call `configureTestingModule` to refine the testing module configuration for a particular set of tests\n      by adding and removing imports, declarations (of components, directives, and pipes), and providers.\n      -->\n<p>      <code>karma-test-shim</code>과 <code>browser-test-shim</code>을 사용해서 <a href=\"guide/testing\">기본 테스트 환경</a>과 테스트 모듈을 구성합니다.\n기본 테스트 모듈은 테스트 스펙에 필요한 Angular 구성요소와 서비스를 등록해서 구성합니다.</p>\n<p>      <code>configureTestingModule</code>를 실행하면 특정 테스트 스펙에 필요한 설정으로 테스트 모듈을 다시 설정할 수 있습니다.\n테스트 모듈이 로드하는 모듈 목록에 새로운 항목을 추가하거나 뺄 수 있고 컴포넌트, 디렉티브, 파이프 목록을 변경할 수 있으며, 프로바이더도 변경할 수 있습니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>compileComponents</code>\n    </td>\n    <td>\n      <!--\n      Compile the testing module asynchronously after you've finished configuring it.\n      You **must** call this method if _any_ of the testing module components have a `templateUrl`\n      or `styleUrls` because fetching component template and style files is necessarily asynchronous.\n      See [above](#compile-components).\n\n      After calling `compileComponents`, the `TestBed` configuration is frozen for the duration of the current spec.\n      -->\n<p>      설정을 끝낸 테스트 모듈을 비동기로 컴파일할 때 사용합니다.\n테스트 모듈에 포함된 컴포넌트 중에서 <code>templateUrl</code>과 <code><a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a></code>를 사용하는 컴포넌트가 있다면, 이 컴포넌트 템플릿 파일과 스타일 파일이 비동기로 로드되어야 하기 때문에 <strong>반드시</strong> 이 함수를 실행해야 합니다.\n<a href=\"guide/testing#compile-components\">위에서 설명한 내용</a>을 참고하세요.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <!--\n      <code>createComponent<T></code>\n      -->\n      <code>createComponent&#x3C;T></code>\n    </td>\n    <td>\n      <!--\n      Create an instance of a component of type `T` based on the current `TestBed` configuration.\n      After calling `compileComponent`, the `TestBed` configuration is frozen for the duration of the current spec.\n      -->\n<p>      현재 설정된 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 환경으로 <code>T</code> 타입의 컴포넌트 인스턴스를 생성합니다.\n<code>compileComponent</code>를 실행하고 나면 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 환경 설정이 확정되기 때문에 해당 블럭에서 동작하는 테스트 스펙이 끝날 때까지 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 설정을 변경할 수 없습니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>overrideModule</code>\n    </td>\n    <td>\n      <!--\n      Replace metadata for the given `NgModule`. Recall that modules can import other modules.\n      The `overrideModule` method can reach deeply into the current testing module to\n      modify one of these inner modules.\n      -->\n<p>      <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>에 설정된 메타데이터를 변경합니다.\n모듈은 다른 모듈을 로드할 수 있다는 것을 기억하세요.\n<code>overrideModule</code> 메소드를 사용하면 현재 사용하는 테스트 모듈은 물론 테스트 모듈이 로드하는 다른 모듈 설정도 변경할 수 있습니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>overrideComponent</code>\n    </td>\n    <td>\n      <!--\n      Replace metadata for the given component class, which could be nested deeply\n      within an inner module.\n      -->\n<p>      컴포넌트 클래스에 설정된 메타데이터를 변경합니다.\n테스트 모듈이 로드하는 다른 모듈의 컴포넌트 메타데이터도 변경할 수 있습니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>overrideDirective</code>\n    </td>\n    <td>\n      <!--\n      Replace metadata for the given directive class, which could be nested deeply\n      within an inner module.\n      -->\n<p>      디렉티브 클래스에 설정된 메타데이터를 변경합니다.\n테스트 모듈이 로드하는 다른 모듈의 디렉티브 메타데이터도 변경할 수 있습니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>overridePipe</code>\n    </td>\n    <td>\n      <!--\n      Replace metadata for the given pipe class, which could be nested deeply\n      within an inner module.\n      -->\n<p>      파이프 클래스에 설정된 메타데이터를 변경합니다.\n테스트 모듈이 로드하는 다른 모듈의 파이프 메타데이터도 변경할 수 있습니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <a id=\"testbed-get\"></a>\n      <code>get</code>\n    </td>\n    <td>\n      <!--\n      Retrieve a service from the current `TestBed` injector.\n\n      The `inject` function is often adequate for this purpose.\n      But `inject` throws an error if it can't provide the service.\n\n      What if the service is optional?\n\n      The `TestBed.get()` method takes an optional second parameter,\n      the object to return if Angular can't find the provider\n      (`null` in this example):\n      -->\n<p>      현재 사용하는 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 인젝터를 사용해서 서비스를 참조합니다.</p>\n<p>      이런 용도라면 <code>get</code> 대신 <code>inject</code> 함수를 사용해도 됩니다.\n하지만 프로바이더로 등록되지 않은 서비스는 <code>inject</code>로 참조할 때 에러가 발생합니다.</p>\n<p>      만약 서비스가 옵션 항목이라면 어떻게 해야 할까요?</p>\n<p>      <code>TestBed.get()</code> 메소드의 두번째 인자는 옵션항목인데, 이 옵션을 지정하면 Angular가 서비스 프로바이더를 찾을 수 없을 때 옵션으로 지정된 객체를 사용합니다(이 예제에서는 <code>null</code>을 대신 사용합니다):</p>\n<p>      <code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"testbed-get-w-null\" header=\"app/demo/demo.testbed.spec.ts\" linenums=\"false\">\nservice = TestBed.get(NotProvided, null); // service에는 null이 할당됩니다.\n\n</code-example></p>\n      <!--\n      After calling `get`, the `TestBed` configuration is frozen for the duration of the current spec.\n      -->\n<p>      <code>get</code>을 실행하고 나면 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 환경 설정이 확정되기 때문에 해당 블럭에서 동작하는 테스트 스펙이 끝날 때까지 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 설정을 변경할 수 없습니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <a id=\"testbed-initTestEnvironment\"></a>\n      <code>initTestEnvironment</code>\n    </td>\n    <td>\n      <!--\n      Initialize the testing environment for the entire test run.\n\n      The testing shims (`karma-test-shim`, `browser-test-shim`) call it for you\n      so there is rarely a reason for you to call it yourself.\n\n      You may call this method _exactly once_. If you must change\n      this default in the middle of your test run, call `resetTestEnvironment` first.\n\n      Specify the Angular compiler factory, a `PlatformRef`, and a default Angular testing module.\n      Alternatives for non-browser platforms are available in the general form\n      `@angular/platform-<platform_name>/testing/<platform_name>`.\n      -->\n<p>      모든 테스트 스펙에 적용되는 테스트 환경을 초기화합니다.</p>\n<p>      이 메소드는 <code>karma-test-shim</code>과 <code>browser-test-shim</code>이 자동으로 실행하기 때문에 이 메소드를 직접 실행할 일은 별로 없습니다.</p>\n<p>      하지만 이 메소드를 직접 실행해야 하는 경우가 <em>딱 하나</em> 있습니다.\n테스트를 실행하는 도중에 테스트 환경 설정의 기본값을 바꾸게 되면 먼저 <code>resetTestEnvironment</code>를 실행해야 합니다.</p>\n<p>      그리고 <code><a href=\"api/core/PlatformRef\" class=\"code-anchor\">PlatformRef</a></code>과 같은 Angular 컴파일러 팩토리나 기본 Angular 테스트 모듈을 지정합니다.\n브라우저를 사용하지 않는 플랫폼은 일반적으로 <code>@angular/platform-&#x3C;platform_name>/testing/&#x3C;platform_name></code> 패키지로 제공됩니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>resetTestEnvironment</code>\n    </td>\n    <td>\n      <!--\n      Reset the initial test environment, including the default testing module.\n      -->\n<p>      테스트 환경을 초기화합니다. 이 메소드를 실행하면 기본 테스트 모듈도 함께 초기화됩니다.</p>\n    </td>\n  </tr>\n</tbody></table>\n<!--\nA few of the `TestBed` instance methods are not covered by static `TestBed` _class_ methods.\nThese are rarely needed.\n-->\n<p><code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> <em>클래스</em> 의 메소드 중에는 정적 메소드가 처리하지 않는 함수도 있습니다.\n이 메소드들은 거의 사용하지 않습니다.</p>\n<a id=\"component-fixture-api-summary\"></a>\n<!--\n#### The _ComponentFixture_\n-->\n<h4 id=\"componentfixture-1\"><em>ComponentFixture</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#componentfixture-1\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe `TestBed.createComponent<T>`\ncreates an instance of the component `T`\nand returns a strongly typed `ComponentFixture` for that component.\n\nThe `ComponentFixture` properties and methods provide access to the component,\nits DOM representation, and aspects of its Angular environment.\n-->\n<p><code>TestBed.createComponent&#x3C;T></code>를 실행하면 컴포넌트 <code>T</code>의 인스턴스를 생성하며, 이렇게 생성된 인스턴스를 <code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code> 타입으로 반환합니다.</p>\n<p>그러면 <code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code>의 프로퍼티와 메소드를 사용해서 컴포넌트에 직접 접근할 수 있으며, DOM에도 접근할 수 있고 이 컴포넌트가 사용하는 Angular 구성요소에도 접근할 수 있습니다.</p>\n<a id=\"component-fixture-properties\"></a>\n<!--\n#### _ComponentFixture_ properties\n-->\n<h4 id=\"componentfixture-의-프로퍼티\"><em>ComponentFixture</em> 의 프로퍼티<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#componentfixture-의-프로퍼티\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nHere are the most important properties for testers, in order of likely utility.\n-->\n<p>테스트 스펙을 작성하면서 가장 중요하고 자주 사용하는 프로퍼티에 대해 알아봅시다.</p>\n<table>\n  <tbody><tr>\n    <th>\n      <!--\n      Properties\n      -->\n      프로퍼티\n    </th>\n    <th>\n      <!--\n      Description\n      -->\n      설명\n    </th>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>componentInstance</code>\n    </td>\n    <td>\n      <!--\n      The instance of the component class created by `TestBed.createComponent`.\n      -->\n<p>      <code>TestBed.createComponent</code>로 생성한 컴포넌트 클래스의 인스턴스가 할당됩니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code><a href=\"api/core/testing/ComponentFixture#debugElement\" class=\"code-anchor\">debugElement</a></code>\n    </td>\n    <td>\n      <!--\n      The `DebugElement` associated with the root element of the component.\n\n      The `debugElement` provides insight into the component and its DOM element during test and debugging.\n      It's a critical property for testers. The most interesting members are covered [below](#debug-element-details).\n      -->\n<p>      <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>는 컴포넌트의 루트 엘리먼트와 관련이 있습니다.</p>\n<p>      <code><a href=\"api/core/testing/ComponentFixture#debugElement\" class=\"code-anchor\">debugElement</a></code>는 테스트를 실행하거나 디버깅할 때 컴포넌트 내부를 직접 참조하거나 DOM 엘리먼트를 참조하는 용도로 사용할 수 있습니다.\n그리고 테스트 스펙을 작성할 때 가장 중요한 프로퍼티이기도 합니다.\n이 클래스의 멤버중 가장 흥미로운 멤버는 <a href=\"guide/testing#debug-element-details\">아래</a>에서 자세하게 다룹니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>nativeElement</code>\n    </td>\n    <td>\n      <!--\n      The native DOM element at the root of the component.\n      -->\n<p>      컴포넌트의 최상위 네이티브 DOM 엘리먼트가 할당됩니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>changeDetectorRef</code>\n    </td>\n    <td>\n      <!--\n      The `ChangeDetectorRef` for the component.\n\n      The `ChangeDetectorRef` is most valuable when testing a\n      component that has the `ChangeDetectionStrategy.OnPush` method\n      or the component's change detection is under your programmatic control.\n      -->\n<p>      컴포넌트의 <code><a href=\"api/core/ChangeDetectorRef\" class=\"code-anchor\">ChangeDetectorRef</a></code>가 할당됩니다.</p>\n<p>      <code><a href=\"api/core/ChangeDetectorRef\" class=\"code-anchor\">ChangeDetectorRef</a></code>는 컴포넌트를 테스트할 때 가장 중요한 클래스입니다.\n컴포넌트를 조작하고 나면 컴포넌트의 변화 감지 로직을 실행하기 위해 <code><a href=\"api/core/ChangeDetectionStrategy#OnPush\" class=\"code-anchor\">ChangeDetectionStrategy.OnPush</a></code> 메소드나 컴포넌트 픽스쳐의 <code>detectChange</code> 메소드를 실행할 수 있습니다.</p>\n    </td>\n  </tr>\n</tbody></table>\n<a id=\"component-fixture-methods\"></a>\n<!--\n#### _ComponentFixture_ methods\n-->\n<h4 id=\"componentfixture-의-메소드\"><em>ComponentFixture</em> 의 메소드<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#componentfixture-의-메소드\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe _fixture_ methods cause Angular to perform certain tasks on the component tree.\nCall these method to trigger Angular behavior in response to simulated user action.\n\nHere are the most useful methods for testers.\n-->\n<p><em>픽스쳐</em> 가 제공하는 메소드는 모두 컴포넌트 트리에 어떤 작업을 하는 것들입니다.\n이 메소드를 활용하면 사용자가 어떤 동작을 했을 때 반응하는 Angular 동작을 실행할 수 있습니다.</p>\n<p>테스트 코드를 작성할 때 가장 많이 사용하는 메소드에 대해 알아봅시다.</p>\n<table>\n  <tbody><tr>\n    <th>\n      <!--\n      Methods\n      -->\n      메소드\n    </th>\n    <th>\n      <!--\n      Description\n      -->\n      설명\n    </th>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>detectChanges</code>\n    </td>\n    <td>\n      <!--\n      Trigger a change detection cycle for the component.\n\n      Call it to initialize the component (it calls `ngOnInit`) and after your\n      test code, change the component's data bound property values.\n      Angular can't see that you've changed `personComponent.name` and won't update the `name`\n      binding until you call `detectChanges`.\n\n      Runs `checkNoChanges`afterwards to confirm that there are no circular updates unless\n      called as `detectChanges(false)`;\n      -->\n<p>      컴포넌트의 변화 감지 싸이클을 시작합니다.</p>\n<p>      이 함수는 컴포넌트를 초기화하기 위해서(<code>ngOnInit</code>)나 컴포넌트 프로퍼티에 바인딩한 데이터를 변경한 후에 실행합니다.\nAngular는 이 함수가 실행되기 전까지는 <code>personComponent.name</code> 프로퍼티가 변경된 것을 알지 못하며, <code>name</code> 프로퍼티와 바인딩된 항목도 갱신하지 않습니다.</p>\n<p>      그리고 이 메소드를 실행한 후에 <code>checksNoChanges</code>를 실행하면 이후에 <code>detectChanges(false)</code>를 실행하기 전까지 변화감지를 실행하지 않습니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>autoDetectChanges</code>\n    </td>\n    <td>\n      <!--\n      Set this to `true` when you want the fixture to detect changes automatically.\n\n      When autodetect is `true`, the test fixture calls `detectChanges` immediately\n      after creating the component. Then it listens for pertinent zone events\n      and calls `detectChanges` accordingly.\n      When your test code modifies component property values directly,\n      you probably still have to call `fixture.detectChanges` to trigger data binding updates.\n\n      The default is `false`. Testers who prefer fine control over test behavior\n      tend to keep it `false`.\n      -->\n<p>      <code>true</code> 인자와 함께 이 메소드를 실행하면 픽스쳐가 변화감지 싸이클을 자동으로 실행하게 할 수 있습니다.</p>\n<p>      <code>true</code> 인자로 실행하면 컴포넌트가 생성된 뒤에 테스트 픽스쳐가 <code>detectChanges</code>를 즉시 실행합니다.\n그리고 이벤트 존을 감지하면서 필요한 경우에 <code>detectChanges</code>를 자동으로 실행합니다.\n하지만 테스트 코드에서 컴포넌트 프로퍼티 값을 직접 변경했다면, 이 내용을 반영해서 데이터 바인딩을 갱신하기 위해 <code>fixture.detectChanges</code> 메소드를 직접 실행해야 합니다.</p>\n<p>      이 메소드 인자의 기본값은 <code>false</code>입니다.\n테스트 코드의 동작을 모두 직접 조작하는 것을 선호한다면 <code>false</code> 상태로 두고 테스트 코드를 작성하는 것이 좋습니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>checkNoChanges</code>\n    </td>\n    <td>\n      <!--\n      Do a change detection run to make sure there are no pending changes.\n      Throws an exceptions if there are.\n      -->\n<p>      반영되지 않은 변경사항이 없는지 검사합니다.\n아직 반영되지 않은 내용이 있다면 에러가 발생합니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>isStable</code>\n    </td>\n    <td>\n      <!--\n      If the fixture is currently _stable_, returns `true`.\n      If there are async tasks that have not completed, returns `false`.\n      -->\n<p>      픽스쳐의 현재 상태가 <em>stable</em> 이면 <code>true</code>를 반환합니다.\n그리고 종료되지 않은 비동기 태스크가 남아있다면 <code>false</code>를 반환합니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>whenStable</code>\n    </td>\n    <td>\n      <!--\n      Returns a promise that resolves when the fixture is stable.\n\n      To resume testing after completion of asynchronous activity or\n      asynchronous change detection, hook that promise.\n      See [above](#when-stable).\n      -->\n<p>      픽스쳐가 stable 상태일 때 처리되는 Promise를 반환합니다.</p>\n<p>      이 메소드는 비동기 작업을 처리한 후에 다른 테스트 코드를 실행해야 할 때 사용합니다.\n자세한 내용은 <a href=\"guide/testing#when-stable\">위에서 설명한 내용</a>을 참고하세요.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>destroy</code>\n    </td>\n    <td>\n      <!--\n      Trigger component destruction.\n      -->\n<p>      컴포넌트를 종료합니다.</p>\n    </td>\n  </tr>\n</tbody></table>\n<a id=\"debug-element-details\"></a>\n<h4 id=\"debugelement-1\"><em>DebugElement</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#debugelement-1\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe `DebugElement` provides crucial insights into the component's DOM representation.\n\nFrom the test root component's `DebugElement` returned by `fixture.debugElement`,\nyou can walk (and query) the fixture's entire element and component subtrees.\n\nHere are the most useful `DebugElement` members for testers, in approximate order of utility:\n-->\n<p><code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>는 컴포넌트의 DOM과 관련된 내용을 표현합니다.</p>\n<p>그리고 테스트하는 컴포넌트의 <code>fixture.debugElement</code>를 참조하면 해당 컴포넌트부터 컴포넌트 트리를 따라 존재하는 모든 컴포넌트를 참조할 수 있습니다.</p>\n<p><code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>가 제공하는 멤버 중 테스트할 때 가장 자주 사용하는 멤버들에 대해 알아봅시다:</p>\n<table>\n  <tbody><tr>\n    <th>\n      <!--\n      Member\n      -->\n      멤버\n    </th>\n    <th>\n      <!--\n      Description\n      -->\n      설명\n    </th>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>nativeElement</code>\n    </td>\n    <td>\n      <!--\n      The corresponding DOM element in the browser (null for WebWorkers).\n      -->\n<p>      브라우저에 렌더링되는 DOM 엘리먼트가 할당됩니다. WebWorker를 사용하면 null이 할당됩니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code>\n    </td>\n    <td>\n      <!--\n      Calling `query(predicate: Predicate<DebugElement>)` returns the first `DebugElement`\n      that matches the [predicate](#query-predicate) at any depth in the subtree.\n      -->\n<p>      <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a>(predicate: <a href=\"api/core/Predicate\" class=\"code-anchor\">Predicate</a>&#x3C;<a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>>)</code>를 실행하면 전체 컴포넌트 트리 안에 있는 컴포넌트 중 <a href=\"guide/testing#query-predicate\">쿼리 조건(predicate)</a>에 맞는 첫번째 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>를 반환합니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>queryAll</code>\n    </td>\n    <td>\n      <!--\n      Calling `queryAll(predicate: Predicate<DebugElement>)` returns all `DebugElements`\n      that matches the [predicate](#query-predicate) at any depth in subtree.\n      -->\n<p>      <code>queryAll(predicate: <a href=\"api/core/Predicate\" class=\"code-anchor\">Predicate</a>&#x3C;<a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>>)</code>를 실행하면 전체 컴포넌트 트리 안에 있는 컴포넌트 중 <a href=\"guide/testing#query-predicate\">쿼리 조건(predicate)</a>에 맞는 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 모두를 반환합니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>injector</code>\n    </td>\n    <td>\n      <!--\n      The host dependency injector.\n      For example, the root element's component instance injector.\n      -->\n<p>      호스트 의존성 주입기(injector)가 할당됩니다.\n그래서 이 멤버에 할당되는 객체는 최상위 엘리먼트로 존재하는 컴포넌트의 인젝터일 수도 있습니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>componentInstance</code>\n    </td>\n    <td>\n      <!--\n      The element's own component instance, if it has one.\n      -->\n<p>      엘리먼트에 연결된 컴포넌트가 존재하는 경우에 이 컴포넌트의 인스턴스가 할당됩니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>context</code>\n    </td>\n    <td>\n      <!--\n      An object that provides parent context for this element.\n      Often an ancestor component instance that governs this element.\n\n      When an element is repeated within `*ngFor`, the context is an `NgForRow` whose `$implicit`\n      property is the value of the row instance value.\n      For example, the `hero` in `*ngFor=\"let hero of heroes\"`.\n      -->\n<p>      해당 엘리먼트에 적용되는 부모 컨텍스트가 할당됩니다.\n때로는 부모 컴포넌트 인스턴스가 자식 엘리먼트에 영향을 줄 수도 있습니다.</p>\n<p>      예를 들어 엘리먼트가 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>로 반복된다면 이 때 컨텍스트는 <code>NgForRow</code> 디렉티브가 제공하며, 이 컨텍스트 안에 있는 <code>$implicit</code>를 확인하면 각 루프마다 반복되는 정보를 확인할 수 있습니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>children</code>\n    </td>\n    <td>\n      <!--\n      The immediate `DebugElement` children. Walk the tree by descending through `children`.\n\n      <div class=\"alert is-helpful\">\n\n      `DebugElement` also has `childNodes`, a list of `DebugNode` objects.\n      `DebugElement` derives from `DebugNode` objects and there are often\n      more nodes than elements. Testers can usually ignore plain nodes.\n      -->\n<p>      <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>의 바로 밑 자식 엘리먼트들이 할당됩니다.\n<code>children</code> 멤버를 활용하면 컴포넌트 트리를 따라 탐색을 계속할 수도 있습니다.</p>\n      \n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>parent</code>\n    </td>\n    <td>\n      <!--\n      The `DebugElement` parent. Null if this is the root element.\n      -->\n<p>      <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>의 부모 엘리먼트가 할당됩니다.\n해당 엘리먼트가 최상위 엘리먼트라면 null이 할당됩니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>name</code>\n    </td>\n    <td>\n      <!--\n      The element tag name, if it is an element.\n      -->\n<p>      엘리먼트의 태그 이름이 할당됩니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>triggerEventHandler</code>\n    </td>\n    <td>\n      <!--\n      Triggers the event by its name if there is a corresponding listener\n      in the element's `listeners` collection.\n      The second parameter is the _event object_ expected by the handler.\n      See [above](#trigger-event-handler).\n\n      If the event lacks a listener or there's some other problem,\n      consider calling `nativeElement.dispatchEvent(eventObject)`.\n      -->\n<p>      엘리먼트의 <code><a href=\"api/core/DebugNode#listeners\" class=\"code-anchor\">listeners</a></code> 콜렉션에 해당되는 이벤트 이름으로 등록된 이벤트 핸들러가 있으면, 이 이벤트 핸들러를 실행합니다.\n이 메소드의 두 번째 인자에는 핸들러가 처리해야 할 <em>이벤트 객체</em> 를 전달합니다.\n자세한 내용은 <a href=\"guide/testing#trigger-event-handler\">위에서 설명한 내용</a>을 참고하세요.</p>\n<p>      이벤트 리스너에 이벤트 핸들러를 등록하지 않았거나 등록할 수 없는 상황이라면, 이 메소드 대신 <code>nativeElement.dispatchEvent(이벤트 객체)</code>를 사용할 수도 있습니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code><a href=\"api/core/DebugNode#listeners\" class=\"code-anchor\">listeners</a></code>\n    </td>\n    <td>\n      <!--\n      The callbacks attached to the component's `@Output` properties and/or the element's event properties.\n      -->\n<p>      컴포넌트의 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code> 프로퍼티에 연결된 콜백 함수들과 엘리먼트에 연결된 이벤트 핸들러가 할당됩니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code><a href=\"api/core/DebugNode#providerTokens\" class=\"code-anchor\">providerTokens</a></code>\n    </td>\n    <td>\n      <!--\n      This component's injector lookup tokens.\n      Includes the component itself plus the tokens that the component lists in its `providers` metadata.\n      -->\n<p>      컴포넌트의 인젝터에 등록된 토큰들이 할당됩니다.\n이 프로퍼티에는 컴포넌트 자체를 가리키는 토큰과 이 컴포넌트의 <code>providers</code> 메타데이터에 등록된 토큰들이 모두 포함됩니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>source</code>\n    </td>\n    <td>\n      <!--\n      Where to find this element in the source component template.\n      -->\n<p>      호스트 컴포넌트 템플릿에서 이 엘리먼트가 존재하는 위치가 어디인지 표시합니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code><a href=\"api/core/DebugNode#references\" class=\"code-anchor\">references</a></code>\n    </td>\n    <td>\n      <!--\n      Dictionary of objects associated with template local variables (e.g. `#foo`),\n      keyed by the local variable name.\n      -->\n<p>      템플릿 변수(ex. <code>#foo</code>)와 해당 템플릿 변수에 연결된 객체들이 존재하는 객체입니다.\n이 객체의 키는 템플릿 지역 변수의 이름이 그대로 사용됩니다.</p>\n    </td>\n  </tr>\n</tbody></table>\n<a id=\"query-predicate\"></a>\n<!--\nThe `DebugElement.query(predicate)` and `DebugElement.queryAll(predicate)` methods take a\npredicate that filters the source element's subtree for matching `DebugElement`.\n\nThe predicate is any method that takes a `DebugElement` and returns a _truthy_ value.\nThe following example finds all `DebugElements` with a reference to a template local variable named \"content\":\n-->\n<p><code>DebugElement.query(predicate)</code> 메소드와 <code>DebugElement.queryAll(predicate)</code> 메소드는 엘리먼트 트리에서 원하는 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>를 찾기 위해 쿼리 조건(predicate)을 인자로 받습니다.</p>\n<p>이 때 쿼리 조건은 함수 형태로 정의하며, 이 함수가 <em>true로 평가하는</em> <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>가 메소드의 결과로 반환됩니다.\n아래 예제는 템플릿 변수 이름이 \"content\"인 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 전체를 찾는 예제 코드입니다:</p>\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"custom-predicate\" header=\"app/demo/demo.testbed.spec.ts\" linenums=\"false\">\n// #content 라는 템플릿 변수가 존재하는 DbugElement들을 쿼리합니다.\nconst contentRefs = el.queryAll( de => de.references['content']);\n\n</code-example>\n<!--\nThe Angular `By` class has three static methods for common predicates:\n\n- `By.all` - return all elements.\n- `By.css(selector)` - return elements with matching CSS selectors.\n- `By.directive(directive)` - return elements that Angular matched to an instance of the directive class.\n-->\n<p>그리고 Angular <code><a href=\"api/platform-browser/By\" class=\"code-anchor\">By</a></code> 클래스에 있는 정적 메소드 3개도 이 쿼리 조건을 사용합니다:</p>\n<ul>\n<li><code>By.all</code> - 모든 엘리먼트를 반환합니다.</li>\n<li><code>By.css(selector)</code> - 해당 CSS 셀렉터와 매칭되는 엘리먼트를 반환합니다.</li>\n<li><code>By.directive(directive)</code> - 해당 디렉티브 클래스가 사용된 엘리먼트를 반환합니다.</li>\n</ul>\n<code-example path=\"testing/src/app/hero/hero-list.component.spec.ts\" region=\"by\" header=\"app/hero/hero-list.component.spec.ts\" linenums=\"false\">\n// CSS 셀렉터나 디렉티브 토큰을 사용해서 <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>를 쿼리할 수 있습니다.\nconst h2        = fixture.debugElement.query(By.css('h2'));\nconst directive = fixture.debugElement.query(By.directive(HighlightDirective));\n\n</code-example>\n<hr>\n<a id=\"faq\"></a>\n<!--\n## Frequently Asked Questions\n-->\n<h2 id=\"자주-묻는-질문\">자주 묻는 질문<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#자주-묻는-질문\"><i class=\"material-icons\">link</i></a></h2>\n<a id=\"q-spec-file-location\"></a>\n<!--\n#### Why put spec file next to the file it tests?\n-->\n<h4 id=\"스펙-파일은-왜-테스트하는-파일과-함께-둬야-하나요\">스펙 파일은 왜 테스트하는 파일과 함께 둬야 하나요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#스펙-파일은-왜-테스트하는-파일과-함께-둬야-하나요\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nIt's a good idea to put unit test spec files in the same folder\nas the application source code files that they test:\n\n- Such tests are easy to find.\n- You see at a glance if a part of your application lacks tests.\n- Nearby tests can reveal how a part works in context.\n- When you move the source (inevitable), you remember to move the test.\n- When you rename the source file (inevitable), you remember to rename the test file.\n-->\n<p>유닛 테스트 파일은 테스트하려는 소스 코드 파일과 같은 폴더에 두는 것이 좋습니다.\n이렇게 작성했을 때 장점은:</p>\n<ul>\n<li>해당 파일을 테스트하는 파일을 찾기 쉽습니다.</li>\n<li>애플리케이션 구성요소 중에서 어떤것을 테스트하지 않았는지 쉽게 파악할 수 있습니다.</li>\n<li>같은 폴더에 있는 테스트가 전체 애플리케이션에서 어떤 역할을 하는지 파악할 수 있습니다.</li>\n<li>(불가피하게) 소스 파일의 위치를 옮겨야 한다면, 테스트 파일도 잊지 않고 함께 옮길 수 있습니다.</li>\n<li>(불가피하게) 소스 파일의 이름을 바꿔야 한다면, 테스트 파일의 이름도 잊지 않고 바꿀 수 있습니다.</li>\n</ul>\n<hr>\n<a id=\"q-specs-in-test-folder\"></a>\n<!--\n#### When would I put specs in a test folder?\n-->\n<h4 id=\"테스트-파일을-한-폴더에-둬야-하는-경우는-어떤-경우인가요\">테스트 파일을 한 폴더에 둬야 하는 경우는 어떤 경우인가요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#테스트-파일을-한-폴더에-둬야-하는-경우는-어떤-경우인가요\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nApplication integration specs can test the interactions of multiple parts\nspread across folders and modules.\nThey don't really belong to any part in particular, so they don't have a\nnatural home next to any one file.\n\nIt's often better to create an appropriate folder for them in the `tests` directory.\n\nOf course specs that test the test helpers belong in the `test` folder,\nnext to their corresponding helper files.\n-->\n<p>여러 폴더와 여러 모듈에 있는 구성요소가 잘 연동되는지 확인하는 애플리케이션 통합 테스트 스펙을 작성하는 경우에는 테스트하는 구성요소가 애플리케이션의 어느 부분인지 신경쓸 필요가 별로 없습니다.\n그래서 이런 경우에는 특정 소스 파일과 같은 폴더에 둘 필요가 없습니다.</p>\n<p>그보다는 <code>tests</code>라는 폴더를 만들고 이 폴더에 테스트 파일을 두는 것이 더 좋습니다.</p>\n<p>그러면 자연스럽게 이 테스트 스펙이 사용하는 테스트 헬퍼도 <code>test</code> 폴더에 함께 두는 것이 좋습니다.</p>\n<a id=\"q-e2e\"></a>\n<!--\n#### Why not rely on E2E tests of DOM integration?\n\n#### 컴포넌트의 DOM을 테스트할 때 왜 E2E 테스트는 하지 않나요?\n\nThe component DOM tests described in this guide often require extensive setup and\nadvanced techniques whereas the [unit tests](#component-class-testing)\nare comparatively simple.\n\n#### Why not defer DOM integration tests to end-to-end (E2E) testing?\n-->\n<h4 id=\"엔드-투-엔드e2e-테스트할-때-왜-dom은-테스트하지-않나요\">엔드-투-엔드(E2E) 테스트할 때 왜 DOM은 테스트하지 않나요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#엔드-투-엔드e2e-테스트할-때-왜-dom은-테스트하지-않나요\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nE2E tests are great for high-level validation of the entire system.\nBut they can't give you the comprehensive test coverage that you'd expect from unit tests.\n\nE2E tests are difficult to write and perform poorly compared to unit tests.\nThey break easily, often due to changes or misbehavior far removed from the site of breakage.\n\nE2E tests can't easily reveal how your components behave when things go wrong,\nsuch as missing or bad data, lost connectivity, and remote service failures.\n\nE2E tests for apps that update a database,\nsend an invoice, or charge a credit card require special tricks and back-doors to prevent\naccidental corruption of remote resources.\nIt can even be hard to navigate to the component you want to test.\n\nBecause of these many obstacles, you should test DOM interaction\nwith unit testing techniques as much as possible.\n-->\n<p>컴포넌트 DOM을 E2E 테스트하는 것은 컴포넌트를 <a href=\"guide/testing#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%ED%81%B4%EB%9E%98%EC%8A%A4-%ED%85%8C%EC%8A%A4%ED%8A%B8\">유닛 테스트</a>하는 것보다 더 복잡한 환경설정이 필요하며, 테스트 코드를 작성할 때도 좀 더 복잡한 테크닉이 필요합니다.\n컴포넌트는 유닛 테스트로 간단하게 테스트하는 것이 좋습니다.</p>\n<p>E2E 테스트는 애플리케이션 계층의 동작을 검증하는 테스트입니다.\n하지만 E2E 테스트 스펙을 작성할 때는 유닛 테스트에서 했던 것처럼 최대한 많은 내용을 테스트하지 않습니다.</p>\n<p>E2E 테스트는 유닛 테스트에 비해 작성하기 어려우며, 실행할 때 성능도 유닛 테스트보다 약간 느립니다.\n그리고 E2E 테스트에 연관된 Angular 구성요소가 변경되거나 오동작해서 E2E 테스트 자체가 실패할 가능성도 높습니다.</p>\n<p>심지어 테스트가 실패했을 때 컴포넌트가 잘못된 데이터를 사용해서 실패했는지, 연결이 중간에 끊어졌는지, 리모트 서비스가 실패했는지 원인을 찾는 것도 쉽지 않습니다.</p>\n<p>그리고 E2E 테스트 스펙 중 DB의 내용을 바꾸거나 영수증을 발행하는 동작, 신용카드에 요금을 청구하는 동작들은 실제로 요청이 발생하지 않도록 트릭을 사용하거나 백도어를 뚫어놔야 합니다.\n어떤 경우에는 테스트하지 않는 다른 컴포넌트로 페이지를 전환할 수도 있습니다.</p>\n<p>이렇듯 E2E 테스트에는 유닛 테스트에서 겪어보지 않았던 수많은 장애물이 존재할 수 있습니다.\n그래서 DOM과 상호작용하는 로직을 검증하는 테스트 스펙은 유닛테스트에 작성하는 것이 좋습니다.</p>\n\n</div>\n\n<!-- links to this doc:\n - guide/architecture-next-steps\n - guide/dependency-injection\n - guide/setup\n-->\n<!-- links from this doc:\n - api/animations/browser\n - api/animations/browser/testing/MockAnimationDriver#log\n - api/animations/query\n - api/common/AsyncPipe\n - api/common/NgForOf\n - api/common/NgIf\n - api/common/TitleCasePipe\n - api/common/UpperCasePipe\n - api/common/http\n - api/common/http/HttpClient\n - api/common/http/HttpErrorResponse\n - api/common/http/HttpErrorResponse#message\n - api/common/http/HttpEventType#User\n - api/common/http/testing/HttpClientTestingModule\n - api/core/AfterViewInit\n - api/core/ApplicationInitStatus#done\n - api/core/ApplicationRef#tick\n - api/core/ChangeDetectionStrategy#OnPush\n - api/core/ChangeDetectorRef\n - api/core/Component\n - api/core/Component#styleUrls\n - api/core/Component#styles\n - api/core/Component#template\n - api/core/Component#templateUrl\n - api/core/DebugElement\n - api/core/DebugElement#nativeElement\n - api/core/DebugElement#properties\n - api/core/DebugElement#styles\n - api/core/DebugNode#listeners\n - api/core/DebugNode#providerTokens\n - api/core/DebugNode#references\n - api/core/Directive\n - api/core/Directive#host\n - api/core/ElementRef\n - api/core/EventEmitter\n - api/core/Injectable\n - api/core/Input\n - api/core/NO_ERRORS_SCHEMA\n - api/core/NgModule\n - api/core/NgModule#declarations\n - api/core/NgModule#imports\n - api/core/NgModule#schemas\n - api/core/OnChanges\n - api/core/OnInit\n - api/core/Output\n - api/core/Pipe\n - api/core/Pipe#pure\n - api/core/PipeTransform\n - api/core/PlatformRef\n - api/core/Predicate\n - api/core/SchemaMetadata\n - api/core/ViewChild\n - api/core/testing/ComponentFixture\n - api/core/testing/ComponentFixture#debugElement\n - api/core/testing/ComponentFixture#detectChanges\n - api/core/testing/ComponentFixture#nativeElement\n - api/core/testing/ComponentFixtureAutoDetect\n - api/core/testing/MetadataOverride\n - api/core/testing/TestBed\n - api/core/testing/TestModuleMetadata\n - api/core/testing/async\n - api/core/testing/discardPeriodicTasks\n - api/core/testing/fakeAsync\n - api/core/testing/flush\n - api/core/testing/flushMicrotasks\n - api/core/testing/getTestBed\n - api/core/testing/tick\n - api/forms/FormsModule\n - api/forms/NgModel\n - api/forms/NgModel#model\n - api/http/HttpModule\n - api/platform-browser/BrowserModule\n - api/platform-browser/By\n - api/platform-browser/By#css\n - api/platform-browser/Title\n - api/router/ActivatedRoute\n - api/router/ActivatedRoute#paramMap\n - api/router/ParamMap\n - api/router/Params\n - api/router/Router\n - api/router/Router#config\n - api/router/Router#events\n - api/router/Router#navigated\n - api/router/RouterLink\n - api/router/RouterLinkWithHref\n - api/router/RouterModule\n - api/router/RouterOutlet\n - api/router/RouterOutlet#activatedRoute\n - api/router/convertToParamMap\n - api/router/testing/RouterTestingModule\n - cli\n - cli/test\n - guide/dependency-injection\n - guide/feature-modules\n - guide/http\n - guide/http#http-%EC%9A%94%EC%B2%AD-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EA%B8%B0\n - guide/lifecycle-hooks\n - guide/ngmodules\n - guide/router#route-parameters\n - guide/setup#%EB%B6%80%EB%A1%9D-fakeasyncasync-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0\n - guide/testing#%EB%B3%80%ED%99%94%EA%B0%90%EC%A7%80-%EC%9E%90%EB%8F%99%EC%9C%BC%EB%A1%9C-%EC%8B%A4%ED%96%89%ED%95%98%EA%B8%B0\n - guide/testing#%EC%9D%98%EC%A1%B4%EC%84%B1%EC%9C%BC%EB%A1%9C-%EC%A3%BC%EC%9E%85%ED%95%9C-%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0\n - guide/testing#%EC%A4%91%EC%B2%A9%EB%90%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%ED%85%8C%EC%8A%A4%ED%8A%B8\n - guide/testing#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%ED%81%B4%EB%9E%98%EC%8A%A4-%ED%85%8C%EC%8A%A4%ED%8A%B8\n - guide/testing#activatedroutestub\n - guide/testing#activatedroutestub-로-테스트하기\n - guide/testing#angular-cli가-생성한-테스트-코드\n - guide/testing#angular-testbed\n - guide/testing#async\n - guide/testing#async-로-비동기-테스트하기\n - guide/testing#beforeeach\n - guide/testing#beforeeach-없이-테스트하기\n - guide/testing#bycss\n - guide/testing#bydirective-와-의존성으로-주입되는-디렉티브\n - guide/testing#ci-환경에서-chrome으로-테스트하기\n - guide/testing#circle-ci-환경-설정하기\n - guide/testing#click-헬퍼\n - guide/testing#cold-observable\n - guide/testing#compile-components\n - guide/testing#compilecomponents-는-비동기로-실행됩니다\n - guide/testing#compilecomponents-는-잘못-사용해도-에러가-발생하지-않습니다\n - guide/testing#compilecomponents-실행하기\n - guide/testing#component-fixture\n - guide/testing#component-fixture-api-summary\n - guide/testing#component-override\n - guide/testing#component-with-async-service\n - guide/testing#componentfixture\n - guide/testing#componentfixture-1\n - guide/testing#componentfixture-의-메소드\n - guide/testing#componentfixture-의-프로퍼티\n - guide/testing#createcomponent\n - guide/testing#createcomponent-는-데이터를-바인딩하지-않습니다\n - guide/testing#dashboard-hero-component\n - guide/testing#dashboardherocomponent-단독으로-테스트하기\n - guide/testing#debug-element-details\n - guide/testing#debugelement\n - guide/testing#debugelement-1\n - guide/testing#detectchanges\n - guide/testing#dispatchevent-입력값-변경하기\n - guide/testing#dom-조작-테스트\n - guide/testing#fake-async\n - guide/testing#fakeasync-안에서-jasmineclock-사용하기\n - guide/testing#fakeasync-안에서-rxjs-스케쥴러-사용하기\n - guide/testing#fakeasync-안에서-서로-다른-시점-비교하기\n - guide/testing#feature-module-import\n - guide/testing#h1-쿼리하기\n - guide/testing#http-서비스-테스트하기\n - guide/testing#httpclienttestingmodule\n - guide/testing#jasmine-done\n - guide/testing#marble-frame\n - guide/testing#marble-testing\n - guide/testing#metadata-override-object\n - guide/testing#nativeelement\n - guide/testing#no_errors_schema\n - guide/testing#overridecomponent-메소드\n - guide/testing#page-object\n - guide/testing#page-객체-사용하기\n - guide/testing#query-predicate\n - guide/testing#routerlink\n - guide/testing#routerlink-를-사용하는-컴포넌트\n - guide/testing#routing-component\n - guide/testing#testbed-api-summary\n - guide/testing#testbed-로-서비스-테스트하기\n - guide/testing#testbed-클래스\n - guide/testing#testbedget\n - guide/testing#tests-w-test-double\n - guide/testing#tick\n - guide/testing#tick-함수\n - guide/testing#travis-ci-환경-설정하기\n - guide/testing#trigger-event-handler\n - guide/testing#triggereventhandler\n - guide/testing#when-stable\n - guide/testing#whenstable\n - guide/testing#why-stubbed-routerlink-tests\n - guide/testing#간단하게-줄이기\n - guide/testing#공통-모듈-로드하기\n - guide/testing#기능모듈-로드하기\n - guide/testing#다른-테스트-프레임워크\n - guide/testing#동기-테스트\n - guide/testing#동기synchronous-beforeeach\n - guide/testing#두-가지-방법-함께-사용하기\n - guide/testing#라우팅-대상이-되는-컴포넌트\n - guide/testing#라우팅하는-컴포넌트\n - guide/testing#마블-테스트-더-알아보기\n - guide/testing#마블-테스트에서-에러-처리하기\n - guide/testing#마지막-환경설정-테스트\n - guide/testing#매크로태스크macrotasks-활용하기\n - guide/testing#모듈-로드-설정\n - guide/testing#목-서비스-사용하기\n - guide/testing#바인딩\n - guide/testing#변화감지-자동으로-실행하기\n - guide/testing#비동기-서비스를-사용하는-컴포넌트\n - guide/testing#비동기-옵저버블\n - guide/testing#비동기-옵저버블-헬퍼\n - guide/testing#비동기-테스트-활용-예제\n - guide/testing#비동기async-beforeeach\n - guide/testing#비동기로-테스트하기-fakeasync\n - guide/testing#서비스-인스턴스는-반드시-인젝터에서-가져오세요\n - guide/testing#서비스-테스트하기\n - guide/testing#스파이-객체-등록하기-herodetailservicespy\n - guide/testing#스파이로-테스트하기\n - guide/testing#스펙-파일은-왜-테스트하는-파일과-함께-둬야-하나요\n - guide/testing#어트리뷰트-디렉티브-테스트\n - guide/testing#엔드-투-엔드e2e-테스트할-때-왜-dom은-테스트하지-않나요\n - guide/testing#엘리먼트-클릭하기\n - guide/testing#오버라이드-테스트\n - guide/testing#오버라이드-활용하기\n - guide/testing#왜-routerlink-를-목-클래스로-사용하나요\n - guide/testing#외부-파일로-구성된-컴포넌트\n - guide/testing#의존성-객체가-존재하는-서비스\n - guide/testing#의존성-주입이-필요한-컴포넌트\n - guide/testing#의존성으로-주입한-서비스-가져오기\n - guide/testing#입력출력-프로퍼티가-있는-컴포넌트\n - guide/testing#자주-묻는-질문\n - guide/testing#중첩된-컴포넌트-테스트\n - guide/testing#지속적인-통합환경-구성하기\n - guide/testing#컴포넌트-dom-테스트\n - guide/testing#컴포넌트-마블marble-테스트\n - guide/testing#컴포넌트-클래스-테스트\n - guide/testing#컴포넌트-테스트\n - guide/testing#컴포넌트-테스트-시나리오\n - guide/testing#컴포넌트-프로바이더-오버라이드하기\n - guide/testing#코드-커버리지-강제하기\n - guide/testing#코드-커버리지-리포트-활성화하기\n - guide/testing#클릭-테스트하기\n - guide/testing#테스트\n - guide/testing#테스트-디버깅하기\n - guide/testing#테스트-설정\n - guide/testing#테스트-유틸리티\n - guide/testing#테스트-파일을-한-폴더에-둬야-하는-경우는-어떤-경우인가요\n - guide/testing#테스트-파일의-이름과-위치\n - guide/testing#테스트-호스트-안에서-테스트하기\n - guide/testing#통합-환경설정\n - guide/testing#파이프-테스트\n - guide/testing#필요없는-컴포넌트-목으로-대체하기\n - guide/testing#환경-설정\n - tutorial\n - http://reactivex.io/documentation/operators/defer.html\n - http://rxmarbles.com/\n - https://circleci.com/add-projects\n - https://circleci.com/docs/2.0/\n - https://circleci.com/docs/2.0/first-steps/\n - https://crbug.com/737678\n - https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n - https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API\n - https://developer.mozilla.org/en-US/docs/Web/CSS/:not\n - https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started/Selectors\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\n - https://developers.google.com/web/updates/2017/04/headless-chrome#cli\n - https://docs.npmjs.com/cli/run-script\n - https://docs.travis-ci.com/\n - https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md\n - https://github.com/angular/angular-cli\n - https://github.com/angular/angular/edit/master/aio/content/guide/testing.md?message=docs%3A%20describe%20your%20change...\n - https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n - https://jasmine.github.io/\n - https://jasmine.github.io/2.0/introduction.html#section-Asynchronous_Support\n - https://jasmine.github.io/2.0/introduction.html#section-Spies\n - https://karma-runner.github.io\n - https://karma-runner.github.io/latest/config/configuration-file.html\n - https://plnkr.co/\n - https://travis-ci.org/auth\n - https://www.protractortest.org/#/api-overview\n-->"
}