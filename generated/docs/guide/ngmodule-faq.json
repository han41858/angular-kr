{
  "id": "guide/ngmodule-faq",
  "title": "NgModule FAQ",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/ngmodule-faq.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"ngmodule-faq\">NgModule FAQ<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#ngmodule-faq\"><i class=\"material-icons\">link</i></a></h1>\n<!--\nNgModules help organize an application into cohesive blocks of functionality.\n\nThis page answers the questions many developers ask about NgModule design and implementation.\n-->\n<p>NgModule은 애플리케이션 코드를 기능별로 분리해서 효율적으로 구성할 수 있는 단위입니다.</p>\n<p>이 문서는 NgModule의 개발 의도와 구현방법에 대해 많은 개발자들이 물어본 내용을 소개합니다.</p>\n<!--\n## What classes should I add to the `declarations` array?\n-->\n<h2 id=\"declarations-배열에는-어떤-클래스를-추가해야-하나요\"><code>declarations</code> 배열에는 어떤 클래스를 추가해야 하나요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#declarations-배열에는-어떤-클래스를-추가해야-하나요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAdd [declarable](guide/bootstrapping#the-declarations-array) classes&mdash;components, directives, and pipes&mdash;to a `declarations` list.\n\nDeclare these classes in _exactly one_ module of the application.\nDeclare them in a module if they belong to that particular module.\n-->\n<p>이 배열에는 모듈에 포함되는 컴포넌트나 디렉티브, 파이프를 등록하며, 이 Angular 구성요소들을 <a href=\"guide/bootstrapping#declarations-%EB%B0%B0%EC%97%B4\">declarable</a>이라고도 합니다.\n대상 클래스는 <em>딱 하나의</em> 모듈에만 등록해야 합니다.</p>\n<hr>\n<a id=\"q-declarable\"></a>\n<!--\n## What is a _declarable_?\n-->\n<h2 id=\"declarable-이-뭔가요\"><em>declarable</em> 이 뭔가요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#declarable-이-뭔가요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nDeclarables are the class types&mdash;components, directives, and pipes&mdash;that\nyou can add to a module's `declarations` list.\nThey're the only classes that you can add to `declarations`.\n-->\n<p>Declarable은 컴포넌트나 디렉티브, 파이프와 같이 모듈의 <code>declarations</code> 배열에 등록하는 클래스입니다.\nDeclarable은 Angular 구성요소이면서, JavaScript 클래스이기도 합니다.</p>\n<hr>\n<!--\n## What classes should I _not_ add to `declarations`?\n-->\n<h2 id=\"declarations-배열에-추가하지-말아야-할-클래스는-어떤-것이-있나요\"><code>declarations</code> 배열에 추가하지 <em>말아야</em> 할 클래스는 어떤 것이 있나요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#declarations-배열에-추가하지-말아야-할-클래스는-어떤-것이-있나요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAdd only [declarable](guide/bootstrapping#the-declarations-array) classes to an NgModule's `declarations` list.\n\nDo *not* declare the following:\n\n* A class that's already declared in another module, whether an app module, @NgModule, or third-party module.\n* An array of directives imported from another module.\nFor example, don't declare `FORMS_DIRECTIVES` from `@angular/forms` because the `FormsModule` already declares it.\n\n* Module classes.\n* Service classes.\n* Non-Angular classes and objects, such as\nstrings, numbers, functions, entity models, configurations, business logic, and helper classes.\n-->\n<p>NgModule의 <code>declarations</code> 배열에는 <a href=\"guide/bootstrapping#declarations-%EB%B0%B0%EC%97%B4\">declarable</a> 클래스만 추가해야 합니다.</p>\n<p>그래서 다음과 같은 항목은 추가하면 <em>안됩니다</em>:</p>\n<ul>\n<li>\n<p>다른 모듈, 서드파티 모듈에 이미 추가된 클래스</p>\n</li>\n<li>\n<p>다른 모듈에서 가져온 디렉티브.\n예를 들어 <code>@angular/forms</code> 라이브러리에서 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 모듈을 로드했다면, 이 모듈에 있는 <code>FORMS_DIRECTIVES</code>는 추가하면 안됩니다.</p>\n</li>\n<li>\n<p>모듈 클래스</p>\n</li>\n<li>\n<p>서비스 클래스</p>\n</li>\n<li>\n<p>Angular 구성요소가 아닌 클래스나 객체 : 문자열, 숫자, 함수, 데이터 모델, config 설정, 업무 로직 클래스, 헬퍼 클래스</p>\n</li>\n</ul>\n<hr>\n<!--\n## Why list the same component in multiple `NgModule` properties?\n-->\n<h2 id=\"ngmodule-프로퍼티에-컴포넌트가-여러번-사용되는-경우도-있나요\"><code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 프로퍼티에 컴포넌트가 여러번 사용되는 경우도 있나요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#ngmodule-프로퍼티에-컴포넌트가-여러번-사용되는-경우도-있나요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\n`AppComponent` is often listed in both `declarations` and `bootstrap`.\nYou might see the same component listed in `declarations`, `exports`, and `entryComponents`.\n\nWhile that seems redundant, these properties have different functions.\nMembership in one list doesn't imply membership in another list.\n\n* `AppComponent` could be declared in this module but not bootstrapped.\n* `AppComponent` could be bootstrapped in this module but declared in a different feature module.\n* A component could be imported from another app module (so you can't declare it) and re-exported by this module.\n* A component could be exported for inclusion in an external component's template\nas well as dynamically loaded in a pop-up dialog.\n-->\n<p><code>AppComponent</code>는 <code>declarations</code> 배열에 추가되기도 하지만 <code>bootstrap</code> 배열에 추가되기도 합니다.\n어떤 경우에는 <code>declarations</code>, <code>exports</code>, <code>entryComponents</code>에 모두 등록되어 있는 컴포넌트도 있습니다.</p>\n<p>이런 문법은 조금 귀찮을 수 있지만 각각의 프로퍼티는 다른 역할을 하기 때문에 프로퍼티마다 따로 등록하는 작업이 필요합니다.\n프로퍼티는 서로 다른 프로퍼티에 영향을 주지 않습니다.</p>\n<ul>\n<li><code>AppComponent</code>는 모듈에 등록되어 있지만 부트스트랩되지 않을 수도 있습니다.</li>\n<li>다른 기능 모듈에서 불러온 <code>AppComponent</code>가 부트스트랩 될 수도 있습니다.</li>\n<li>다른 앱 모듈에서 가져온 컴포넌트를 <code>exports</code>로 다시 추가하는 경우도 있습니다.</li>\n<li>팝업과 같이 동적으로 로딩되는 컴포넌트가 있을 수도 있습니다.</li>\n</ul>\n<hr>\n<!--\n## What does \"Can't bind to 'x' since it isn't a known property of 'y'\" mean?\n-->\n<h2 id=\"cant-bind-to-x-since-it-isnt-a-known-property-of-y-에러가-발생하는-이유는-뭔가요\">\"Can't bind to 'x' since it isn't a known property of 'y'\" 에러가 발생하는 이유는 뭔가요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#cant-bind-to-x-since-it-isnt-a-known-property-of-y-에러가-발생하는-이유는-뭔가요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThis error often means that you haven't declared the directive \"x\"\nor haven't imported the NgModule to which \"x\" belongs.\n\n<div class=\"alert is-helpful\">\n\nPerhaps you declared \"x\" in an application sub-module but forgot to export it.\nThe \"x\" class isn't visible to other modules until you add it to the `exports` list.\n\n</div>\n-->\n<p>이 에러는 디렉티브 \"x\"를 모듈에 등록하지 않았거나 디렉티브 \"x\"가 등록된 모듈을 로드하지 않았을 때 발생합니다.</p>\n<div class=\"alert is-helpful\">\n<p>어쩌면 어딘가에 디렉티브 \"x\"를 등록했지만 모듈 외부로 공개하지 않은 경우일 수도 있습니다.\n모듈의 <code>exports</code> 배열에 등록되지 않은 Angular 구성요소는 다른 모듈에서 참조할 수 없습니다.</p>\n</div>\n<hr>\n<!--\n## What should I import?\n-->\n<h2 id=\"어떤-모듈을-로드import해야-하나요\">어떤 모듈을 로드(import)해야 하나요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#어떤-모듈을-로드import해야-하나요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nImport NgModules whose public (exported) [declarable classes](guide/bootstrapping#the-declarations-array)\nyou need to reference in this module's component templates.\n\nThis always means importing `CommonModule` from `@angular/common` for access to\nthe Angular directives such as `NgIf` and `NgFor`.\nYou can import it directly or from another NgModule that [re-exports](guide/ngmodule-faq#q-reexport) it.\n\nImport `FormsModule` from `@angular/forms`\nif your components have `[(ngModel)]` two-way binding expressions.\n\nImport _shared_ and _feature_ modules when this module's components incorporate their\ncomponents, directives, and pipes.\n\nImport [BrowserModule](guide/ngmodule-faq#q-browser-vs-common-module) only in the root `AppModule`.\n-->\n<p>이 모듈의 컴포넌트 템플릿에서 사용하려는 <a href=\"guide/bootstrapping#declarations-%EB%B0%B0%EC%97%B4\">Angular 구성요소의 클래스</a>를 제공하는 NgModule을 로드하면 됩니다.</p>\n<p>그래서 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>나 <code>NgFor</code>와 같은 Angular 기본 디렉티브를 사용하려면 <code>@angular/common</code> 라이브러리에서 <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>을 불러오면 됩니다.\n이 때 디렉티브가 선언된 모듈을 불러와도 되고, 다른 모듈이 불러 와서 <a href=\"guide/ngmodule-faq#q-reexport\">다시 모듈 외부로 공개</a>하는 모듈을 불러와도 됩니다.</p>\n<p>컴포넌트에서 <code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code>로 양방향 바인딩하려면 <code>@angular/forms</code> 라이브러리에서 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>을 불러오면 됩니다.</p>\n<p>그리고 현재 모듈에 등록된 컴포넌트나 디렉티브, 파이프가 다른 모듈과 연관되어 있다면 그 모듈을 로드하는 것이 좋습니다.</p>\n<p><a href=\"guide/ngmodule-faq#q-browser-vs-common-module\">BrowserModule</a>은 애플리케이션의 최상위 <code>AppModule</code>에서만 로드합니다.</p>\n<hr>\n<a id=\"q-browser-vs-common-module\"></a>\n<!--\n## Should I import `BrowserModule` or `CommonModule`?\n-->\n<h2 id=\"browsermodule을-로드해야-하나요-commonmodule을-로드해야-하나요\"><code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>을 로드해야 하나요, <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>을 로드해야 하나요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#browsermodule을-로드해야-하나요-commonmodule을-로드해야-하나요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe root application module, `AppModule`, of almost every browser application\nshould import `BrowserModule` from `@angular/platform-browser`.\n\n`BrowserModule` provides services that are essential to launch and run a browser app.\n\n`BrowserModule` also re-exports `CommonModule` from `@angular/common`,\nwhich means that components in the `AppModule` also have access to\nthe Angular directives every app needs, such as `NgIf` and `NgFor`.\n\nDo not import `BrowserModule` in any other module.\n*Feature modules* and *lazy-loaded modules* should import `CommonModule` instead.\nThey need the common directives. They don't need to re-install the app-wide providers.\n\nImporting `CommonModule` also frees feature modules for use on _any_ target platform, not just browsers.\n-->\n<p>브라우저에서 실행되는 애플리케이션의 최상위 모듈인 <code>AppModule</code>은 <code>@angular/platform-browser</code>에서 제공하는 <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>을 로드해야 하는데, <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>에는 브라우저에서 앱을 실행하는 데 필요한 서비스들이 정의되어 있습니다.</p>\n<p><code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>은 <code>@angular/commoon</code>에서 제공하는 <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>을 확장하는 모듈이기도 한데, 이것은 <code>AppModule</code> 안에 있는 모든 컴포넌트에서 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>나 <code>NgFor</code>와 같은 Angular 기본 디렉티브를 사용할 수 있다는 것을 의미하기도 합니다.</p>\n<p>하지만 앱 모듈이 아닌 모듈에서 <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>을 로드하면 안됩니다.\n<em>기능 모듈</em>이나 <em>지연 로딩되는 모듈</em>은 <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> 대신 <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>을 로드해야 합니다.\n앱 모듈이 아닌 경우에도 Angular 기본 디렉티브는 사용할 수 있지만, 앱 전역에 설정되는 프로바이더를 다시 초기화할 필요는 없습니다.</p>\n<p>브라우저에서 동작하지 않는 Angular 애플리케이션이라면 <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> 없이 <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>을 사용하는 경우도 있습니다.</p>\n<hr>\n<a id=\"q-reimport\"></a>\n<!--\n## What if I import the same module twice?\n-->\n<h2 id=\"모듈을-두-번-로드하면-어떻게-되나요\">모듈을 두 번 로드하면 어떻게 되나요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#모듈을-두-번-로드하면-어떻게-되나요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThat's not a problem. When three modules all import Module 'A',\nAngular evaluates Module 'A' once, the first time it encounters it, and doesn't do so again.\n\nThat's true at whatever level `A` appears in a hierarchy of imported NgModules.\nWhen Module 'B' imports Module 'A', Module 'C' imports 'B', and Module 'D' imports `[C, B, A]`,\nthen 'D' triggers the evaluation of 'C', which triggers the evaluation of 'B', which evaluates 'A'.\nWhen Angular gets to the 'B' and 'A' in 'D', they're already cached and ready to go.\n\nAngular doesn't like NgModules with circular references, so don't let Module 'A' import Module 'B', which imports Module 'A'.\n-->\n<p>문제되지 않습니다.\n만약 3개의 모듈에서 모듈 'A'를 각각 로드한다고 해도 Angular는 모듈 'A'를 한 번만 초기화합니다. </p>\n<p>이 때 모듈이 초기화되는 순서는 모듈이 로드되는 순서에 따라 달라집니다.\n만약 모듈 'B'가 모듈 'A'를 로드하고, 모듈 'C'가 모듈 'B'를 참조하고, 마지막으로 모듈 'D'가 모듈 <code>[C, B, A]</code>를 로드한다고 합시다.\n그러면 모듈 'D'가 로드될 때 모듈 'C'를 초기화하는데, 이 때 모듈 'C'에서 참조하는 모듈 'B'가 먼저 초기화되고, 모듈 'B'에서 참조하는 모듈 'A'가 가장 먼저 초기화됩니다.\n그리고 모듈 'D'에서 모듈 'B'와 'A'를 참조할 때는 캐시된 객체를 사용합니다.</p>\n<p>Angular는 순환 참조를 지원하지 않습니다. 모듈 'A'가 모듈 'B'를 참조하는 상태에서 모듈 'B'가 모듈 'A'를 다시 참조하면 안됩니다.</p>\n<hr>\n<a id=\"q-reexport\"></a>\n<!--\n## What should I export?\n-->\n<h2 id=\"무엇을-모듈-외부로-공개해야-하나요\">무엇을 모듈 외부로 공개해야 하나요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#무엇을-모듈-외부로-공개해야-하나요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nExport [declarable](guide/bootstrapping#the-declarations-array) classes that components in _other_ NgModules\nare able to reference in their templates. These are your _public_ classes.\nIf you don't export a declarable class, it stays _private_, visible only to other components\ndeclared in this NgModule.\n\nYou _can_ export any declarable class&mdash;components, directives, and pipes&mdash;whether\nit's declared in this NgModule or in an imported NgModule.\n\nYou _can_ re-export entire imported NgModules, which effectively re-export all of their exported classes.\nAn NgModule can even export a module that it doesn't import.\n-->\n<p>다른 모듈의 템플릿에서 사용되어야 할 <a href=\"guide/bootstrapping#declarations-%EB%B0%B0%EC%97%B4\">컴포넌트나 디렉티브, 파이프</a> 클래스를 모듈 외부로 공개해야 합니다.\n이렇게 지정하는 클래스들이 이 모듈의 <em>public</em> 클래스입니다.\n모듈 외부로 지정하지 않은 Angular 구성요소는 기본적으로 <em>private</em> 이며, 해당 모듈 안에서만 사용할 수 있습니다.</p>\n<p>이 때 <code>exports</code> 배열로 지정하는 클래스는 해당 모듈의 <code>declarations</code> 배열에 추가된 클래스이거나 다른 모듈에서 가져온 클래스일 수 있습니다.</p>\n<p>불러온 모듈에 등록된 Angular 구성요소 전체를 다시 공개할 수도 있고, 아무것도 추가하지 않고 그대로 다시 공개할 수도 있습니다.</p>\n<hr>\n<!--\n## What should I *not* export?\n-->\n<h2 id=\"모듈-외부로-공개하지-말아야-하는-것은-어떤-것이-있나요\">모듈 외부로 공개하지 <em>말아야</em> 하는 것은 어떤 것이 있나요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#모듈-외부로-공개하지-말아야-하는-것은-어떤-것이-있나요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nDon't export the following:\n\n* Private components, directives, and pipes that you need only within components declared in this NgModule.\nIf you don't want another NgModule to see it, don't export it.\n* Non-declarable objects such as services, functions, configurations, and entity models.\n* Components that are only loaded dynamically by the router or by bootstrapping.\nSuch [entry components](guide/ngmodule-faq#q-entry-component-defined) can never be selected in another component's template.\nWhile there's no harm in exporting them, there's also no benefit.\n* Pure service modules that don't have public (exported) declarations.\nFor example, there's no point in re-exporting `HttpClientModule` because it doesn't export anything.\nIts only purpose is to add http service providers to the application as a whole.\n-->\n<p>다음 항목은 모듈 외부로 공개하면 안됩니다:</p>\n<ul>\n<li>해당 모듈에서만 사용하는 private 컴포넌트, 디렉티브, 파이프\n다른 모듈에 사용되는 것을 원하지 않는다면 모듈 외부로 공개하지 않으면 됩니다.</li>\n<li>컴포넌트, 디렉티브, 파이프가 아닌 객체 : 서비스, 함수, config 설정, 데이터 모델</li>\n<li>라우터나 부트스트랩 대상으로 지정되어 동적으로 로딩되는 컴포넌트.\n<a href=\"guide/ngmodule-faq#q-entry-component-defined\">진입 컴포넌트</a>는 다른 컴포넌트 템플릿에 사용될 필요가 없습니다.\n진입 컴포넌트를 모듈 외부로 공개해도 별 문제는 없지만, 아무 이득없이 모듈 외부로 공개할 필요도 없습니다.</li>\n<li>public <code>declarations</code> 배열이 없는 서비스 모듈.\n<code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>과 같은 모듈은 불러와서 다시 공개할 이유가 없습니다. 왜냐하면 이 모듈은 아무것도 모듈 외부로 공개하지 않으며, 앱 전역에서 사용하는 http 서비스 프로바이더만 제공하기 때문입니다.</li>\n</ul>\n<hr>\n<!--\n## Can I re-export classes and modules?\n-->\n<h2 id=\"다른-곳에서-불러온-클래스나-모듈을-다시-exports로-지정해도-되나요\">다른 곳에서 불러온 클래스나 모듈을 다시 <code>exports</code>로 지정해도 되나요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#다른-곳에서-불러온-클래스나-모듈을-다시-exports로-지정해도-되나요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAbsolutely.\n\nNgModules are a great way to selectively aggregate classes from other NgModules and\nre-export them in a consolidated, convenience module.\n\nAn NgModule can re-export entire NgModules, which effectively re-exports all of their exported classes.\nAngular's own `BrowserModule` exports a couple of NgModules like this:\n\n```typescript\n  exports: [CommonModule, ApplicationModule]\n```\n\nAn NgModule can export a combination of its own declarations, selected imported classes, and imported NgModules.\n\nDon't bother re-exporting pure service modules.\nPure service modules don't export [declarable](guide/bootstrapping#the-declarations-array) classes that another NgModule could use.\nFor example, there's no point in re-exporting `HttpClientModule` because it doesn't export anything.\nIts only purpose is to add http service providers to the application as a whole.\n-->\n<p>물론 가능합니다.</p>\n<p>그리고 다른 모듈에 있는 클래스를 조합해서 새로운 모듈로 만드는 것도 가능합니다.</p>\n<p>이 때 <code>exports</code> 배열에 모듈을 지정하면 해당 모듈에서 모듈 외부로 공개하도록 지정된 모든 구성요소를 다시 공개하는 선언이 됩니다.\nAngular 라이브러리 중 <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>을 보면 다음과 같이 사용된 부분이 있습니다:</p>\n<code-example language=\"typescript\">\n  exports: [<a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>, <a href=\"api/core/ApplicationModule\" class=\"code-anchor\">ApplicationModule</a>]\n</code-example>\n<p>모듈은 모듈 안에 선언된 컴포넌트나 디렉티브, 파이프는 물론이고 다른 모듈에서 불러온 구성요소를 조합해서 모듈 외부로 공개할 수도 있습니다.</p>\n<p>다만 서비스 모듈은 모듈 외부로 다시 공개하면 안됩니다.\n왜냐하면 서비스 모듈에는 모듈 외부로 공개된 <a href=\"guide/bootstrapping#declarations-%EB%B0%B0%EC%97%B4\">declarable</a> 클래스가 없기 때문에 이 모듈을 다시 <code>exports</code>로 지정하는 것은 의미가 없습니다.\n예를 들어 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>은 아무것도 모듈 외부로 공개하지 않습니다.\n이 모듈의 목적은 앱 전역에 http 서비스 프로바이더를 제공하는 것 뿐입니다.</p>\n<hr>\n<!--\n## What is the `forRoot()` method?\n-->\n<h2 id=\"forroot-메소드가-뭔가요\"><code>forRoot()</code> 메소드가 뭔가요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#forroot-메소드가-뭔가요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe `forRoot()` static method is a convention that makes it easy for developers to configure services and providers that are intended to be singletons. A good example of `forRoot()` is the `RouterModule.forRoot()` method.\n\nApps pass a `Routes` array to `RouterModule.forRoot()` in order to configure the app-wide `Router` service with routes.\n`RouterModule.forRoot()` returns a [ModuleWithProviders](api/core/ModuleWithProviders).\nYou add that result to the `imports` list of the root `AppModule`.\n\nOnly call and import a `forRoot()` result in the root application module, `AppModule`.\nAvoid importing it in any other module, particularly in a lazy-loaded module. For more\ninformation on `forRoot()` see [the `forRoot()` pattern](guide/singleton-services#the-forroot-pattern) section of the [Singleton Services](guide/singleton-services) guide.\n\nFor a service, instead of using `forRoot()`,  specify `providedIn: 'root'` on the service's `@Injectable()` decorator, which\nmakes the service automatically available to the whole application and thus singleton by default.\n\n`RouterModule` also offers a `forChild()` static method for configuring the routes of lazy-loaded modules.\n\n`forRoot()` and `forChild()` are conventional names for methods that\nconfigure services in root and feature modules respectively.\n\nFollow this convention when you write similar modules with configurable service providers.\n-->\n<p>정적 메소드 <code>forRoot()</code>는 싱글턴으로 사용하는 서비스와 프로바이더를 좀 더 쉽게 사용할 수 있도록 제공하는 함수입니다.\n<code>forRoot()</code> 메소드는 많은 모듈에서 제공하며, <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 메소드도 이 중 하나입니다.</p>\n<p><code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code>에 <code><a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a></code> 객체를 전달하면 앱 전역에서 사용할 수 있는 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 서비스를 설정하고 <a href=\"api/core/ModuleWithProviders\">ModuleWithProviders</a> 객체를 반환합니다.\n그리고 이 모듈을 <code>AppModule</code>의 <code>imports</code> 배열에 추가하면 라우터를 사용할 수 있습니다.</p>\n<p><code>forRoot()</code> 메소드는 애플리케이션의 최상위 모듈인 <code>AppModule</code>에서만 사용해야 합니다.\n앱 모듈이 아닌 기능 모듈, 특히 지연로딩 되는 다른 모듈에서 이 함수를 사용하면 런타임 에러가 발생할 수 있습니다.\n<code>forRoot()</code> 함수에 대해 더 알아보려면 <a href=\"guide/singleton-services\">싱글턴 서비스</a> 가이드 문서의 <a href=\"guide/singleton-services#the-forroot-pattern\"><code>forRoot()</code> 패턴</a> 섹션을 참고하세요.</p>\n<p>서비스를 싱글턴으로 만드는 것이라면 <code>forRoot()</code> 메소드 대신 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 데코레이터 안에 <code>providedIn: 'root'</code>를 지정해도 됩니다.\n이렇게 지정된 서비스는 앱 전역으로 사용할 수 있는 싱글턴 서비스로 생성됩니다.</p>\n<p>정적 모듈에서 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>을 사용하려면 <code>forRoot()</code> 메소드 대신 <code>forChild()</code> 메소드를 사용해야 합니다.</p>\n<p><code>forRoot()</code> 메소드와 <code>forChild()</code> 메소드는 모두 앱 모듈이나 기능 모듈에 서비스를 편하게 등록하기 위한 용도로 제공되는 함수입니다.</p>\n<p>서비스 프로바이더의 설정을 외부에서 지정하는 모듈이라면 이 패턴을 도입할 수 있는지 검토해 보세요.</p>\n<hr>\n<!--\n## Why is a service provided in a feature module visible everywhere?\n-->\n<h2 id=\"기능-모듈에-등록된-서비스는-왜-외부에서도-접근할-수-있나요\">기능 모듈에 등록된 서비스는 왜 외부에서도 접근할 수 있나요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#기능-모듈에-등록된-서비스는-왜-외부에서도-접근할-수-있나요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nProviders listed in the `@NgModule.providers` of a bootstrapped module have application scope.\nAdding a service provider to `@NgModule.providers` effectively publishes the service to the entire application.\n\nWhen you import an NgModule,\nAngular adds the module's service providers (the contents of its `providers` list)\nto the application root injector.\n\nThis makes the provider visible to every class in the application that knows the provider's lookup token, or name.\n\nExtensibility through NgModule imports is a primary goal of the NgModule system.\nMerging NgModule providers into the application injector\nmakes it easy for a module library to enrich the entire application with new services.\nBy adding the `HttpClientModule` once, every application component can make HTTP requests.\n\nHowever, this might feel like an unwelcome surprise if you expect the module's services\nto be visible only to the components declared by that feature module.\nIf the `HeroModule` provides the `HeroService` and the root `AppModule` imports `HeroModule`,\nany class that knows the `HeroService` _type_ can inject that service,\nnot just the classes declared in the `HeroModule`.\n\nTo limit access to a service, consider lazy loading the NgModule that provides that service. See [How do I restrict service scope to a module?](guide/ngmodule-faq#service-scope) for more information.\n-->\n<p>부트스트랩되는 모듈의 <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code>에 선언된 프로바이더 목록은 애플리케이션 전체 범위에 유효합니다.\n그리고 이 목록에 등록된 프로바이더로 생성하는 서비스도 앱 전체 범위에서 접근할 수 있습니다.</p>\n<p>모듈이 로드되면 이 모듈에 등록된 서비스 프로바이더가 애플리케이션 최상위 인젝터에도 등록됩니다.</p>\n<p>그래서 프로바이더의 토큰이나 이름을 알면 애플리케이션의 모든 클래스에 자유롭게 사용할 수 있습니다.</p>\n<p>이것은 Angular가 의도한 디자인입니다.\nNgModule 체계에서 가장 중요한 것은 확장성입니다.\n그리고 앱 모듈에 NgModule을 추가로 로드할 때마다 인젝터가 합쳐지는 것은 애플리케이션 전체에 새로운 기능을 추가하기 위한 것입니다.\n<code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>을 로드한 이후로는 애플리케이션 전체에서 HTTP 요청을 보낼 수 있는 것을 생각해 보세요.</p>\n<p>하지만 기능 모듈 밖으로 서비스가 노출되지 않는 것이 좋다고 생각하는 관점에서는 이 방식이 어색할 수 있습니다.\n확실하게 이해해야 하는 것은, <code>HeroModule</code>에 <code>heroService</code>가 등록되어 있고 <code>AppModule</code>이 <code>HeroModule</code>을 로드한다면 <code>HeroModule</code> 안에서만이 아니라 앱 전체에서 <code>HeroService</code>를 주입받아 사용할 수 있습니다.</p>\n<p>서비스에 접근하는 것을 제한하려면 이 서비스가 등록된 NgModule을 지연로딩하는 것도 검토해볼 수 있습니다.\n좀 더 자세한 내용을 확인하려면 <a href=\"guide/ngmodule-faq#service-scope\">서비스를 모듈 범위로 제한하고 싶으면 어떻게 하면 되나요?</a> 섹션을 참고하세요.</p>\n<hr>\n<a id=\"q-lazy-loaded-module-provider-visibility\"></a>\n<!--\n## Why is a service provided in a lazy-loaded module visible only to that module?\n-->\n<h2 id=\"지연로딩-되는-모듈에-등록된-서비스는-왜-그-모듈에서만-접근할-수-있나요\">지연로딩 되는 모듈에 등록된 서비스는 왜 그 모듈에서만 접근할 수 있나요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#지연로딩-되는-모듈에-등록된-서비스는-왜-그-모듈에서만-접근할-수-있나요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nUnlike providers of the modules loaded at launch,\nproviders of lazy-loaded modules are *module-scoped*.\n\nWhen the Angular router lazy-loads a module, it creates a new execution context.\nThat [context has its own injector](guide/ngmodule-faq#q-why-child-injector \"Why Angular creates a child injector\"),\nwhich is a direct child of the application injector.\n\nThe router adds the lazy module's providers and the providers of its imported NgModules to this child injector.\n\nThese providers are insulated from changes to application providers with the same lookup token.\nWhen the router creates a component within the lazy-loaded context,\nAngular prefers service instances created from these providers to the service instances of the application root injector.\n-->\n<p>애플리케이션이 실행될 때 모두 로드되는 프로바이더와는 다르게, 지연로딩 되는 모듈에 등록된 프로바이더는 그 <em>모듈 범위 안에서만 유효</em>합니다.</p>\n<p>Angular 라우터가 모듈을 지연로딩하면, 이 모듈은 새로운 실행 컨텍스트에서 동작합니다.\n그리고 애플리케이션 인젝터와는 독립적인 <a href=\"guide/ngmodule-faq#q-why-child-injector\" title=\"Why Angular creates a child injector\">인젝터</a>를 구성합니다.</p>\n<p>이 인젝터는 상위 모듈의 자식 인젝터이며, 지연로딩된 모듈과 이 모듈의 자식 모듈에 등록된 프로바이더는 모두 이 인젝터에 등록됩니다.</p>\n<p>하지만 이 때 등록되는 프로바이더의 토큰이 같더라도 모두 상위 모듈의 프로바이더와는 분리됩니다.\n그래서 지연로딩되는 컴포넌트로 라우팅 될 때도 애플리케이션 전역에 있는 인젝터 대신 해당 모듈에 등록된 서비스 프로바이더로 서비스 인스턴스가 생성됩니다.</p>\n<hr>\n<!--\n## What if two modules provide the same service?\n-->\n<h2 id=\"같은-서비스가-다른-모듈로-두-번-등록되면-어떻게-되나요\">같은 서비스가 다른 모듈로 두 번 등록되면 어떻게 되나요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#같은-서비스가-다른-모듈로-두-번-등록되면-어떻게-되나요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nWhen two imported modules, loaded at the same time, list a provider with the same token,\nthe second module's provider \"wins\". That's because both providers are added to the same injector.\n\nWhen Angular looks to inject a service for that token,\nit creates and delivers the instance created by the second provider.\n\n_Every_ class that injects this service gets the instance created by the second provider.\nEven classes declared within the first module get the instance created by the second provider.\n\nIf NgModule A provides a service for token 'X' and imports an NgModule B\nthat also provides a service for token 'X', then NgModule A's service definition \"wins\".\n\nThe service provided by the root `AppModule` takes precedence over services provided by imported NgModules.\nThe `AppModule` always wins.\n-->\n<p>동시에 로드되는 모듈에 같은 프로바이더 토큰이 동시에 로드되면, 두 번째 실행되는 모듈의 프로바이더가 앞쪽 토큰을 덮어씁니다.\n왜냐하면 두 번 모두 같은 인젝터를 사용하기 때문입니다.</p>\n<p>Angular는 주입하는 서비스를 찾을 때 토큰으로 구분하기 때문에, 서비스 인스턴스를 찾거나 생성할 때도 두 번째 등록된 프로바이더를 사용합니다.</p>\n<p>그래서 의존성으로 주입되는 서비스의 인스턴스도 모두 두 번째 등록하는 프로바이더에서 만든 인스턴스입니다.\n심지어 첫 번째 모듈에서도 두 번째 등록한 프로바이더가 사용됩니다.</p>\n<p>만약 모듈 B에 서비스 토큰 'X'에 대한 프로바이더를 등록되어 있는데 모듈 A가 모듈 B 로드하면서 이 서비스 프로바이더를 다시 등록하면, 이 때도 모듈 A 프로바이더가 우선됩니다.</p>\n<p>하지만, 최상위 <code>AppModule</code>에 등록된 서비스 프로바이더는 모든 NgModule에 등록된 서비스 프로바이더보다 우선 처리됩니다.\n토큰이 중복되는 상황이라면 <code>AppModule</code>에 지정된 서비스 프로바이더가 최우선으로 동작합니다.</p>\n<hr>\n<a id=\"service-scope\"></a>\n<!--\n## How do I restrict service scope to a module?\n-->\n<h2 id=\"서비스를-모듈-범위로-제한하고-싶으면-어떻게-하면-되나요\">서비스를 모듈 범위로 제한하고 싶으면 어떻게 하면 되나요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#서비스를-모듈-범위로-제한하고-싶으면-어떻게-하면-되나요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nWhen a module is loaded at application launch,\nits `@NgModule.providers` have *application-wide scope*;\nthat is, they are available for injection throughout the application.\n\nImported providers are easily replaced by providers from another imported NgModule.\nSuch replacement might be by design. It could be unintentional and have adverse consequences.\n\nAs a general rule, import modules with providers _exactly once_, preferably in the application's _root module_.\nThat's also usually the best place to configure, wrap, and override them.\n\nSuppose a module requires a customized `HttpBackend` that adds a special header for all Http requests.\nIf another module elsewhere in the application also customizes `HttpBackend`\nor merely imports the `HttpClientModule`, it could override this module's `HttpBackend` provider,\nlosing the special header. The server will reject http requests from this module.\n\nTo avoid this problem, import the `HttpClientModule` only in the `AppModule`, the application _root module_.\n\nIf you must guard against this kind of \"provider corruption\", *don't rely on a launch-time module's `providers`.*\n\nLoad the module lazily if you can.\nAngular gives a [lazy-loaded module](guide/ngmodule-faq#q-lazy-loaded-module-provider-visibility) its own child injector.\nThe module's providers are visible only within the component tree created with this injector.\n\nIf you must load the module eagerly, when the application starts,\n*provide the service in a component instead.*\n\nContinuing with the same example, suppose the components of a module truly require a private, custom `HttpBackend`.\n\nCreate a \"top component\" that acts as the root for all of the module's components.\nAdd the custom `HttpBackend` provider to the top component's `providers` list rather than the module's `providers`.\nRecall that Angular creates a child injector for each component instance and populates the injector\nwith the component's own providers.\n\nWhen a child of this component asks for the `HttpBackend` service,\nAngular provides the local `HttpBackend` service,\nnot the version provided in the application root injector.\nChild components make proper HTTP requests no matter what other modules do to `HttpBackend`.\n\nBe sure to create module components as children of this module's top component.\n\nYou can embed the child components in the top component's template.\nAlternatively, make the top component a routing host by giving it a `<router-outlet>`.\nDefine child routes and let the router load module components into that outlet.\n\nThough you can limit access to a service by providing it in a lazy loaded module or providing it in a component, providing services in a component can lead to multiple instances of those services. Thus, the lazy loading is preferable.\n-->\n<p>모듈은 애플리케이션이 실행될 때 로드되고, 이 때 <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code>에 등록된 프로바이더들은 <em>애플리케이션 전역 스코프</em>를 갖습니다.\n그래서 의존성으로 주입하는 객체는 이 프로바이더 목록 중에 찾게 됩니다.</p>\n<p>그리고 모듈이 추가로 로드되면 이 모듈에 등록된 프로바이더가 이전 프로바이더를 대체합니다.\n이것은 새로 추가된 모듈이 새로운 프로바이더를 사용하게 하려는 Angular의 디자인 컨셉입니다.</p>\n<p>일반적으로 모듈은 애플리케이션의 <em>최상위 모듈</em> 에 <em>한 번만</em> 로드되는 것이 좋습니다.\n모듈이 다른 모듈로 랩핑(wrap)되거나 오버라이드 되더라도 일반적으로는 그렇습니다.</p>\n<p>모든 Http 요청에 대해 헤더를 추가하기 위해 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code>를 커스터마이징하는 모듈이 있다고 합시다.\n그런데 다른 모듈에서 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code>를 커스터마이징하거나 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>을 직접 불러와서 사용하는 모듈이 이 모듈의 프로바이더를 덮어쓸 수도 있습니다.\n그러면 커스터마이징 한 헤더가 추가되지 않으니, 이 모듈에서 서버로 보낸 요청은 모두 실패할 것입니다.</p>\n<p>이 문제를 해결하려면 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>을 애플리케이션의 <em>최상위 모듈</em> 인 <code>AppModule</code>에서 딱 한 번만 로드해야 합니다.</p>\n<p>그리고 프로바이더가 바뀌는 것을 방지하려면 런타임에 로드되는 모듈의 프로바이더도 신경을 써야 합니다.</p>\n<p>가능하다면 모듈을 지연로딩하는 것이 좋습니다.\nAngular가 <a href=\"guide/ngmodule-faq#q-lazy-loaded-module-provider-visibility\">모듈을 지연로딩하면</a> 모듈에 자식 인젝터가 생성되면서, 모듈 안에 있는 프로바이더는 그 모듈 안에서만 사용할 수 있기 때문입니다.</p>\n<p>하지만 모듈을 지연로딩할 수 없다면 <em>컴포넌트 안에 서비스 프로바이더를 등록하는 방법도 있습니다.</em></p>\n<p>위에서 언급한 예제를 다시 한 번 생각해봅시다.</p>\n<p>모듈 안에 있는 모든 컴포넌트의 최상위 역할을 하는 <em>최상위 컴포넌트</em> 를 만듭니다.\n그리고 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> 커스텀 프로바이더를 모듈의 <code>providers</code>에 등록하지 않고 컴포넌트에 <code>providers</code>에 등록합니다.\n컴포넌트에 프로바이더가 등록되어 있으면, 이 컴포넌트의 자식 인젝터들은 모두 이 프로바이더를 사용한다는 것을 생각하면 됩니다.</p>\n<p>실제로 이 컴포넌트의 자식 컴포넌트에서 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> 서비스를 의존성으로 주입받으면, 애플리케이션 최상위 인젝터가 제공하는 인스턴스가 아니라 컴포넌트에 정의된 프로바이더에서 인스턴스를 찾습니다.\n이제 모듈 안에서 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code>로 보내는 HTTP 요청은 의도한 대로 동작합니다.</p>\n<p>이 컴포넌트는 물론 모듈의 최상위 컴포넌트로 지정해야 하는 것을 잊지 마세요.</p>\n<p>자식 컴포넌트는 일반적으로 최상위 컴포넌트의 템플릿 안에 사용될 것입니다.\n아니면 <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code>으로 라우팅되는 컴포넌트를 활용할 수도 있습니다.\n모듈에 자식 라우터를 설정하면 라우팅 영역 안에 컴포넌트가 표시될 것입니다.</p>\n<p>서비스에 접근할 수 있는 범위를 제한할 때는 서비스가 등록된 모듈을 지연로딩하거나 서비스를 컴포넌트에 등록하는 방법을 사용할 수 있습니다.\n하지만 서비스를 컴포넌트에 등록하면 컴포넌트의 인스턴스마다 새로운 서비스 인스턴스가 계속 생성되기 때문에, 서비스가 등록된 모듈을 지연로딩하는 방법이 더 효율적입니다.</p>\n<hr>\n<a id=\"q-root-component-or-module\"></a>\n<!--\n## Should I add application-wide providers to the root `AppModule` or the root `AppComponent`?\n-->\n<h2 id=\"애플리케이션-전역에-사용하는-프로바이더는-appmodule이나-appcomponent에-등록해야-하나요\">애플리케이션 전역에 사용하는 프로바이더는 <code>AppModule</code>이나 <code>AppComponent</code>에 등록해야 하나요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#애플리케이션-전역에-사용하는-프로바이더는-appmodule이나-appcomponent에-등록해야-하나요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\n Define application-wide providers by specifying `providedIn: 'root'` on its `@Injectable()` decorator (in the case of services) or at `InjectionToken` construction (in the case where tokens are provided). Providers that are created this way automatically are made available to the entire application and don't need to be listed in any module.\n\nIf a provider cannot be configured in this way (perhaps because it has no sensible default value), then register application-wide providers in the root `AppModule`, not in the `AppComponent`.\n\nLazy-loaded modules and their components can inject `AppModule` services;\nthey can't inject `AppComponent` services.\n\nRegister a service in `AppComponent` providers _only_ if the service must be hidden\nfrom components outside the `AppComponent` tree. This is a rare use case.\n\nMore generally, [prefer registering providers in NgModules](guide/ngmodule-faq#q-component-or-module) to registering in components.\n\n<h3 class=\"no-toc\">Discussion</h3>\n\nAngular registers all startup module providers with the application root injector.\nThe services that root injector providers create have application scope, which\nmeans they are available to the entire application.\n\nCertain services, such as the `Router`, only work when you register them in the application root injector.\n\nBy contrast, Angular registers `AppComponent` providers with the `AppComponent`'s own injector.\n`AppComponent` services are available only to that component and its component tree.\nThey have component scope.\n\nThe `AppComponent`'s injector is a child of the root injector, one down in the injector hierarchy.\nFor applications that don't use the router, that's almost the entire application.\nBut in routed applications, routing operates at the root level\nwhere `AppComponent` services don't exist.\nThis means that lazy-loaded modules can't reach them.\n-->\n<p>애플리케이션 전역에 등록되는 프로바이더는 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code>에 <code>providedIn: 'root'</code>를 지정하거나 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code>를 사용해서 정의할 수 있습니다.\n이 때 전자는 서비스에 대한 프로바이더이며, 후자는 토큰에 대한 프로바이더입니다.\n이렇게 등록된 프로바이더는 자동으로 애플리케이션 전역에 등록되며, 모듈에서 따로 로드하지 않아도 자유롭게 사용할 수 있습니다.</p>\n<p>이전에 사용하는 프로바이더와 충돌이 걱정되어 이 방법을 사용할 수 없다면, <code>AppComponent</code>에 프로바이더를 등록하지 않고 <code>AppModule</code>에 프로바이더를 등록하는 방법도 있습니다.</p>\n<p>그러면 이 프로바이더들은 <code>AppModule</code>에는 등록되지만 <code>AppComponent</code>에는 등록되지 않습니다.</p>\n<p>서비스 프로바이더를 <code>AppComponent</code>에 등록하는 것은 이 서비스가 반드시 <code>AppComponent</code> 트리 안에서만 사용하도록 지정할 때 사용합니다.\n자주 사용하는 방식은 아닙니다.</p>\n<p>이보다 좀 더 일반적인 경우에는, <a href=\"guide/ngmodule-faq#q-component-or-module\">프로바이더는 모듈에 등록</a>하는 것이 좋습니다.\n이렇게 사용하면 모듈 안에 있는 컴포넌트들은 등록된 프로바이더를 사용할 수 있습니다.</p>\n<h3 class=\"no-toc\" id=\"주의\">주의<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#주의\"><i class=\"material-icons\">link</i></a></h3>\n<p>Angular는 애플리케이션이 시작될 때 로드되는 모듈에 있는 모든 프로바이더를 애플리케이션 최상위 인젝터에 등록합니다.\n그러면 이 인젝터로 참조하는 프로바이더는 애플리케이션 전체 범위에 유효합니다.</p>\n<p>하지만 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>와 같이 애플리케이션 최상위 인젝터에 등록해야만 동작하는 서비스도 있습니다.</p>\n<p>이와는 다르게, <code>AppComponent</code>에 등록하는 프로바이더는 <code>AppComponent</code>에 존재하는 인젝터에만 등록됩니다.\n그래서 <code>AppComponent</code>에 등록된 서비스는 컴포넌트 범위로 제한되며, 이 컴포넌트의 하위 트리에서만 사용할 수 있습니다.</p>\n<p><code>AppComponent</code>에 존재하는 인젝터는 최상위 인젝터의 자식 인젝터이며, 라우터를 사용하지 않는 애플리케이션이라면 <code>AppComponent</code>의 범위는 애플리케이션 전체 범위와 비슷할 수도 있습니다.\n하지만 라우터를 사용하는 애플리케이션이라면 <code>AppComponent</code>보다 상위 계층에서 라우팅이 동작합니다.\n따라서 지연로딩되는 모듈은 <code>AppComponent</code>의 인젝터에 접근할 수 없습니다.</p>\n<hr>\n<a id=\"q-component-or-module\"></a>\n<!--\n## Should I add other providers to a module or a component?\n-->\n<h2 id=\"프로바이더는-모듈이나-컴포넌트에-꼭-등록해야-하나요\">프로바이더는 모듈이나 컴포넌트에 꼭 등록해야 하나요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#프로바이더는-모듈이나-컴포넌트에-꼭-등록해야-하나요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nProviders should be configured using `@Injectable` syntax. If possible, they should be provided in the application root (`providedIn: 'root'`). Services that are configured this way are lazily loaded if they are only used from a lazily loaded context.\n\nIf it's the consumer's decision whether a provider is available application-wide or not,\nthen register providers in modules (`@NgModule.providers`) instead of registering in components (`@Component.providers`).\n\nRegister a provider with a component when you _must_ limit the scope of a service instance\nto that component and its component tree.\nApply the same reasoning to registering a provider with a directive.\n\nFor example, an editing component that needs a private copy of a caching service should register\nthe service with the component.\nThen each new instance of the component gets its own cached service instance.\nThe changes that editor makes in its service don't touch the instances elsewhere in the application.\n\n[Always register _application-wide_ services with the root `AppModule`](guide/ngmodule-faq#q-root-component-or-module),\nnot the root `AppComponent`.\n-->\n<p>프로바이더는 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> 문법으로 등록되어야 하며, 가능하다면 애플리케이션 최상위 계층에 존재하도록 <code>providedIn: 'root'</code>을 지정해야 합니다.\n지연로딩되는 모듈에 등록된 프로바이더는 모듈과 함께 필요할 때 로딩됩니다.</p>\n<p>그리고 이 프로바이더가 애플리케이션 전역에 사용되는지 일부 범위에만 사용되는지에 따라 달라지지만, 프로바이더는 되도록 컴포넌트(<code>@Component.providers</code>)에 등록하는 것보다 모듈(<code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code>)에 등록하는 것이 좋습니다.</p>\n<p>프로바이더를 컴포넌트에 등록하는 것은 이 프로바이더의 범위가 특정 컴포넌트 트리 안쪽으로 <em>제한되어야만 할 때만</em> 사용합니다.\n프로바이더를 디렉티브에 등록하는 것도 마찬가지입니다.</p>\n<p>예를 들어, 어떤 에디터 컴포넌트는 외부와 분리된 캐시를 유지하기 위해 컴포넌트에 프로바이더를 등록해서 사용한다고 합시다.\n그러면 이 컴포넌트가 생성될 때마다 독립적인 서비스 인스턴스가 계속 생성됩니다.\n그리고 이 컴포넌트에서 서비스에 접근해서 작업하는 모든 내용은 컴포넌트 밖에 아무 영향도 미치지 않을 것입니다.</p>\n<p><a href=\"guide/ngmodule-faq#q-root-component-or-module\"><em>애플리케이션 전역에 동작하는 서비스</em> 는</a> 최상위 컴포넌트 <code>AppComponent</code>가 아니라 최상위 모듈 <code>AppModule</code>에 등록하는 것이 좋다는 것도 꼭 기억하세요.</p>\n<hr>\n<a id=\"q-why-bad\"></a>\n<!--\n## Why is it bad if a shared module provides a service to a lazy-loaded module?\n-->\n<h2 id=\"지연로딩-모듈에서-공유모듈에-있는-프로바이더를-사용하는-것은-안-좋은가요\">지연로딩 모듈에서 공유모듈에 있는 프로바이더를 사용하는 것은 안 좋은가요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#지연로딩-모듈에서-공유모듈에-있는-프로바이더를-사용하는-것은-안-좋은가요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\n### The eagerly loaded scenario\nWhen an eagerly loaded module provides a service, for example a `UserService`, that service is available application-wide. If the root module provides `UserService` and\nimports another module that provides the same `UserService`, Angular registers one of\nthem in the root app injector (see [What if I import the same module twice?](guide/ngmodule-faq#q-reimport)).\n\nThen, when some component injects `UserService`, Angular finds it in the app root injector,\nand delivers the app-wide singleton service. No problem.\n-->\n<h3 id=\"즉시-로드되는-모듈의-경우\">즉시 로드되는 모듈의 경우<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#즉시-로드되는-모듈의-경우\"><i class=\"material-icons\">link</i></a></h3>\n<p>애플리케이션이 시작되면서 즉시 로드되는 모듈에서 제공하는 서비스, 예를 들어 <code>UserService</code>가 있다면 이 서비스는 애플리케이션 전역에 자유롭게 사용할 수 있습니다.\n그리고 최상위 모듈에 <code>UserService</code>가 등록되어 있는데 다른 모듈에서 <code>UserService</code>가 한 번 더 등록한다고 해도 이 프로바이더는 중복 등록되지 않습니다. <a href=\"guide/ngmodule-faq#q-reimport\">모듈을 두 번 로드하면 어떻게 되나요?</a> 문단을 참고하세요.</p>\n<p>그래서 어떤 컴포넌트가 <code>UserService</code>를 의존성으로 주입받는다고 할 때, Angular는 이 서비스의 프로바이더를 애플리케이션 최상위 인젝터에서 찾으며, 앱 전역에 사용하는 싱글턴 서비스 인스턴스를 주입합니다. 문제될 것은 전혀 없습니다.</p>\n<!--\n### The lazy loaded scenario\n\nNow consider a lazy loaded module that also provides a service called `UserService`.\n\nWhen the router lazy loads a module, it creates a child injector and registers the `UserService`\nprovider with that child injector. The child injector is _not_ the root injector.\n\nWhen Angular creates a lazy component for that module and injects `UserService`,\nit finds a `UserService` provider in the lazy module's _child injector_\nand creates a _new_ instance of the `UserService`.\nThis is an entirely different `UserService` instance\nthan the app-wide singleton version that Angular injected in one of the eagerly loaded components.\n\nThis scenario causes your app to create a new instance every time, instead of using the singleton.\n-->\n<!--KW--What does this cause? I wasn't able to get the suggestion of this to work from\nthe current FAQ:\nTo demonstrate, run the <live-example name=\"ngmodule\">live example</live-example>.\nModify the `SharedModule` so that it provides the `UserService` rather than the `CoreModule`.\nThen toggle between the \"Contact\" and \"Heroes\" links a few times.\nThe username goes bonkers as the Angular creates a new `UserService` instance each time.\nI'd like to see the error so I can include it.-->\n<h3 id=\"지연로딩되는-모듈의-경우\">지연로딩되는 모듈의 경우<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#지연로딩되는-모듈의-경우\"><i class=\"material-icons\">link</i></a></h3>\n<p>이번에는 지연로딩되는 모듈에서 <code>UserService</code>를 사용하는 경우를 생각해 봅시다.</p>\n<p>라우터가 모듈을 지연로딩하면 이 모듈에 생성한 자식 인젝터에 <code>UserService</code> 프로바이더를 등록합니다. 이 때 생성되는 자식 인젝터는 애플리케이션 최상위 인젝터와는 <em>다릅니다</em>.</p>\n<p>그리고 이 모듈에 있는 컴포넌트에서 <code>UserService</code>를 주입하려고 하면, 지연로딩된 모듈에 생성된 <em>자식 인젝터</em> 에서 <code>UserService</code> 인스턴스를 찾고, 인스턴스가 없으면 새로운 인스턴스를 생성합니다.\n하지만 이 인스턴스는 애플리케이션 전역에 만든 싱글턴 서비스의 인스턴스와는 다릅니다.</p>\n<p>모듈이 지연로딩될 때마다 서비스의 인스턴스는 계속 생성되며, 애플리케이션 전역에 싱글턴으로 사용하기 위해 프로바이더를 등록했던 의도와는 달라집니다.</p>\n<hr>\n<a id=\"q-why-child-injector\"></a>\n<!--\n## Why does lazy loading create a child injector?\n-->\n<h2 id=\"지연로딩되는-모듈은-왜-자식-인젝터를-만드나요\">지연로딩되는 모듈은 왜 자식 인젝터를 만드나요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#지연로딩되는-모듈은-왜-자식-인젝터를-만드나요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAngular adds `@NgModule.providers` to the application root injector, unless the NgModule is lazy-loaded.\nFor a lazy-loaded NgModule, Angular creates a _child injector_ and adds the module's providers to the child injector.\n\nThis means that an NgModule behaves differently depending on whether it's loaded during application start\nor lazy-loaded later. Neglecting that difference can lead to [adverse consequences](guide/ngmodule-faq#q-why-bad).\n\nWhy doesn't Angular add lazy-loaded providers to the app root injector as it does for eagerly loaded NgModules?\n\nThe answer is grounded in a fundamental characteristic of the Angular dependency-injection system.\nAn injector can add providers _until it's first used_.\nOnce an injector starts creating and delivering services, its provider list is frozen; no new providers are allowed.\n\nWhen an applications starts, Angular first configures the root injector with the providers of all eagerly loaded NgModules\n_before_ creating its first component and injecting any of the provided services.\nOnce the application begins, the app root injector is closed to new providers.\n\nTime passes and application logic triggers lazy loading of an NgModule.\nAngular must add the lazy-loaded module's providers to an injector somewhere.\nIt can't add them to the app root injector because that injector is closed to new providers.\nSo Angular creates a new child injector for the lazy-loaded module context.\n-->\n<p>Angular는 즉시 로딩되는 모듈의 <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code>에 등록된 프로바이더를 애플리케이션 최상위 인젝터에 모두 등록합니다.\n그리고 지연로딩 되는 모듈에는 <em>자식 인젝터</em> 를 생성하며, 이 모듈에 등록된 프로바이더는 이 자식 인젝터에 등록합니다.</p>\n<p>따라서 즉시 로딩되는 모듈과 지연로딩되는 모듈의 동작은 다릅니다.\n자세한 설명은 <a href=\"guide/ngmodule-faq#q-why-bad\">위에서 언급한 내용</a>을 참고하세요.</p>\n<p>그러면 왜 지연로딩된 모듈에 등록된 프로바이더는 애플리케이션 최상위 인젝터에 등록되지 않을까요?</p>\n<p>그 이유는 Angular 의존성 주입 방식 때문입니다.\n인젝터는 <em>처음 사용되기 전에</em> 프로바이더 목록을 준비합니다.\n그리고 인젝터가 생성되고 프로바이더가 모두 준비되면 프로바이더 목록을 더이상 수정할 수 없으며, 새로운 프로바이더도 등록할 수 없습니다.</p>\n<p>애플리케이션이 시작되면 Angular는 먼저 최상위 인젝터를 생성하면서 즉시 로딩되는 모듈에 있는 모든 프로바이더를 준비합니다.\n그리고 이 준비가 모두 끝난 후에야 첫 컴포넌트를 생성하고 의존성을 주입합니다.\n애플리케이션이 한 번 시작된 후에는 최상위 인젝터가 관리하는 프로바이더 목록이 변경되지 않으며, 새로운 프로바이더도 추가할 수 없습니다.</p>\n<p>애플리케이션이 동작하다가 모듈을 지연로딩하는 경우를 생각해 봅시다.\n그러면 지연로딩되는 모듈에 있는 프로바이더는 어딘가의 인젝터에 등록되어야 사용할 수 있습니다.\n하지만 애플리케이션의 최상위 인젝터는 이미 닫혔고 새로운 프로바이더도 추가할 수 없기 때문에, 지연로딩된 모듈 컨텍스트에 새로운 자식 인젝터를 생성합니다.</p>\n<hr>\n<a id=\"q-is-it-loaded\"></a>\n<!--\n## How can I tell if an NgModule or service was previously loaded?\n-->\n<h2 id=\"모듈이나-서비스가-로드되었는지-어떻게-확인하나요\">모듈이나 서비스가 로드되었는지 어떻게 확인하나요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#모듈이나-서비스가-로드되었는지-어떻게-확인하나요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nSome NgModules and their services should be loaded only once by the root `AppModule`.\nImporting the module a second time by lazy loading a module could [produce errant behavior](guide/ngmodule-faq#q-why-bad)\nthat may be difficult to detect and diagnose.\n\nTo prevent this issue, write a constructor that attempts to inject the module or service\nfrom the root app injector. If the injection succeeds, the class has been loaded a second time.\nYou can throw an error or take other remedial action.\n\nCertain NgModules, such as `BrowserModule`, implement such a guard.\nHere is a custom constructor for an NgModule called `GreetingModule`.\n\n<code-example path=\"ngmodules/src/app/greeting/greeting.module.ts\" region=\"ctor\" header=\"src/app/greeting/greeting.module.ts (Constructor)\">\nconstructor(@Optional() @SkipSelf() parentModule?: GreetingModule) {\n  if (parentModule) {\n    throw new Error(\n      &#39;GreetingModule is already loaded. Import it in the AppModule only&#39;);\n  }\n}\n\n</code-example>\n-->\n<p>모듈과 서비스는 최상위 <code>AppModule</code>에 한 번은 로딩되어야 사용할 수 있습니다.\n지연로딩되는 경우와 같이 모듈이 여러번 로딩되면 <a href=\"guide/ngmodule-faq#q-why-bad\">비정상적인 동작</a>을 할 수도 있지만, 이런 에러는 발견하기 힘들고 수정하기는 더 힘듭니다.</p>\n<p>이 문제를 피하기 위해 Angular에서는 생성자에서 의존성을 주입받으며, 이렇게 지정된 의존성 객체는 애플리케이션 최상위 인젝터가 인식합니다.\n그리고 의존성 주입이 성공한 이후에 클래스가 로딩됩니다.\n에러가 발생하면 생성자에서 에러를 확인하고 처리할 수 있습니다.</p>\n<p>그리고 <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>과 같은 모듈은 이 문제를 방지하는 로직을 따로 마련하기도 했습니다.\n<code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>이 로드되기 전에 <code>GreetingModule</code>이 이미 로드되었다면, 이 모듈은 다음과 같은 로직으로 에러를 발생시킵니다.</p>\n<code-example path=\"ngmodules/src/app/greeting/greeting.module.ts\" region=\"ctor\" header=\"src/app/greeting/greeting.module.ts (Constructor)\">\nconstructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() parentModule?: GreetingModule) {\n  if (parentModule) {\n    throw new Error(\n      'GreetingModule is already loaded. Import it in the AppModule only');\n  }\n}\n\n</code-example>\n<hr>\n<a id=\"q-entry-component-defined\"></a>\n<!--\n## What is an `entry component`?\n-->\n<h2 id=\"진입-컴포넌트entry-component가-뭔가요\">진입 컴포넌트(entry component)가 뭔가요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#진입-컴포넌트entry-component가-뭔가요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAn entry component is any component that Angular loads _imperatively_ by type.\n\nA component loaded _declaratively_ via its selector is _not_ an entry component.\n\nAngular loads a component declaratively when\nusing the component's selector to locate the element in the template.\nAngular then creates the HTML representation of the component and inserts it into the DOM at the selected element. These aren't entry components.\n\nThe bootstrapped root `AppComponent` is an _entry component_.\nTrue, its selector matches an element tag in `index.html`.\nBut `index.html` isn't a component template and the `AppComponent`\nselector doesn't match an element in any component template.\n\nComponents in route definitions are also _entry components_.\nA route definition refers to a component by its _type_.\nThe router ignores a routed component's selector, if it even has one, and\nloads the component dynamically into a `RouterOutlet`.\n\nFor more information, see [Entry Components](guide/entry-components).\n-->\n<p>진입 컴포넌트는 Angular가 <em>직접</em> 로드하는 컴포넌트입니다.</p>\n<p>반대로 일반 컴포넌트는 템플릿에 셀렉터를 사용되었을 때 로드됩니다.</p>\n<p>템플릿에 컴포넌트의 셀렉터가 사용되면 Angular가 컴포넌트를 로드합니다.\n그리고 컴포넌트의 템플릿을 생성하고 DOM에 추가합니다.\n이런 컴포넌트는 진입 컴포넌트가 아닙니다.</p>\n<p>애플리케이션이 부트스트랩될 때 로드되는 <code>AppComponent</code>는 <em>진입 컴포넌트</em> 입니다.\n사실 <code>index.html</code>에는 <code>AppComponent</code> 셀렉터가 지정되어 있긴 하지만, <code>index.html</code> 파일은 컴포넌트의 템플릿이 아니며, <code>AppComponent</code>의 셀렉터는 컴포넌트 템플릿 어디에도 사용되지 않습니다.</p>\n<p>라우팅 대상이 되는 컴포넌트도 <em>진입 컴포넌트</em> 입니다.\n라우팅 룰을 정의할 때 주소에 해당하는 컴포넌트를 지정하는데, 이렇게 사용되는 컴포넌트는 셀렉터가 지정되어 있다고 해도 무시되며, 지정된 주소로 이동할 때 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>에 동적으로 로드됩니다.</p>\n<p>좀 더 자세한 내용을 확인하려면 <a href=\"guide/entry-components\">진입 컴포넌트</a> 문서를 참고하세요.</p>\n<hr>\n<!--\n## What's the difference between a _bootstrap_ component and an _entry component_?\n-->\n<h2 id=\"부트스트랩-컴포넌트와-진입-컴포넌트-의-차이는-뭔가요\"><em>부트스트랩</em> 컴포넌트와 <em>진입 컴포넌트</em> 의 차이는 뭔가요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#부트스트랩-컴포넌트와-진입-컴포넌트-의-차이는-뭔가요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nA bootstrapped component _is_ an [entry component](guide/ngmodule-faq#q-entry-component-defined)\nthat Angular loads into the DOM during the bootstrap process (application launch).\nOther entry components are loaded dynamically by other means, such as with the router.\n\nThe `@NgModule.bootstrap` property tells the compiler that this is an entry component _and_\nit should generate code to bootstrap the application with this component.\n\nThere's no need to list a component in both the `bootstrap` and `entryComponents` lists,\nalthough doing so is harmless.\n\nFor more information, see [Entry Components](guide/entry-components).\n-->\n<p>부트스트랩 컴포넌트는 Angular가 애플리케이션을 시작하면서 부트스트랩 단계에서 DOM에 추가하기 때문에 <a href=\"guide/ngmodule-faq#q-entry-component-defined\">진입 컴포넌트</a>의 하나라고 볼 수 있습니다.\n일반적으로 진입 컴포넌트는 라우터에 의해 동적으로 로드되는 컴포넌트를 의미합니다.</p>\n<p><code>@<a href=\"api/core/NgModule#bootstrap\" class=\"code-anchor\">NgModule.bootstrap</a></code> 프로퍼티를 지정하면 어떤 컴포넌트가 부트스트랩 컴포넌트인지 컴파일러가 알도록 지정할 수 있으며, 이 컴포넌트는 애플리케이션이 부트스트랩될 때 같이 로드됩니다.</p>\n<p>하지만 컴포넌트를 <code>bootstrap</code> 배열과 <code>entryComponents</code> 배열에 동시에 추가할 필요는 없습니다.\n이렇게 지정해도 문제가 발생하지는 않지만, 지정하는 의미도 없습니다.</p>\n<p>좀 더 자세한 내용을 확인하려면 <a href=\"guide/entry-components\">진입 컴포넌트</a> 문서를 참고하세요.</p>\n<hr>\n<!--\n## When do I add components to _entryComponents_?\n-->\n<h2 id=\"어떤-컴포넌트를-entrycomponents-에-등록해야-하나요\">어떤 컴포넌트를 <em>entryComponents</em> 에 등록해야 하나요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#어떤-컴포넌트를-entrycomponents-에-등록해야-하나요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nMost application developers won't need to add components to the `entryComponents`.\n\nAngular adds certain components to _entry components_ automatically.\nComponents listed in `@NgModule.bootstrap` are added automatically.\nComponents referenced in router configuration are added automatically.\nThese two mechanisms account for almost all entry components.\n\nIf your app happens to bootstrap or dynamically load a component _by type_ in some other manner,\nyou must add it to `entryComponents` explicitly.\n\nAlthough it's harmless to add components to this list,\nit's best to add only the components that are truly _entry components_.\nDon't include components that [are referenced](guide/ngmodule-faq#q-template-reference)\nin the templates of other components.\n\nFor more information, see [Entry Components](guide/entry-components).\n-->\n<p>대부분의 경우에 <code>entryComponents</code> 배열을 직접 지정할 필요는 없습니다.</p>\n<p><em>진입 컴포넌트</em> 로 지정할 필요가 있는 컴포넌트는 Angular가 자동으로 판단하고 진입 컴포넌트 목록에 추가합니다.\n<code>@<a href=\"api/core/NgModule#bootstrap\" class=\"code-anchor\">NgModule.bootstrap</a></code> 배열에 있는 컴포넌트도 마찬가지입니다.\n라우팅 규칙에 정의된 컴포넌트들도 자동으로 진입 컴포넌트로 추가됩니다.\n이 두 가지 경우라면 진입 컴포넌트로 지정되어야 할 컴포넌트를 모두 처리할 수 있습니다.</p>\n<p>하지만 컴포넌트를 동적으로 로드하는 경우라면 <code>entryCompoennts</code>를 명시적으로 지정해야 합니다.</p>\n<p><code>entryComponents</code> 배열에 컴포넌트를 아무것이나 추가해도 별 문제는 없지만, 이 배열에는 진짜 <em>진입 컴포넌트</em> 만 추가하는 것이 가장 좋습니다.\n<a href=\"guide/ngmodule-faq#q-template-reference\">템플릿에 셀렉터로 사용되는 컴포넌트</a>라면 진입 컴포넌트로 지정하면 안됩니다.</p>\n<p>좀 더 자세한 내용을 확인하려면 <a href=\"guide/entry-components\">진입 컴포넌트</a> 문서를 참고하세요.</p>\n<hr>\n<!--\n## Why does Angular need _entryComponents_?\n-->\n<h2 id=\"진입-컴포넌트는-왜-필요하죠\">진입 컴포넌트는 왜 필요하죠?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#진입-컴포넌트는-왜-필요하죠\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe reason is _tree shaking_. For production apps you want to load the smallest, fastest code possible. The code should contain only the classes that you actually need.\nIt should exclude a component that's never used, whether or not that component is declared.\n\nIn fact, many libraries declare and export components you'll never use.\nIf you don't reference them, the tree shaker drops these components from the final code package.\n\nIf the [Angular compiler](guide/ngmodule-faq#q-angular-compiler) generated code for every declared component, it would defeat the purpose of the tree shaker.\n\nInstead, the compiler adopts a recursive strategy that generates code only for the components you use.\n\nThe compiler starts with the entry components,\nthen it generates code for the declared components it [finds](guide/ngmodule-faq#q-template-reference) in an entry component's template,\nthen for the declared components it discovers in the templates of previously compiled components,\nand so on. At the end of the process, the compiler has generated code for every entry component\nand every component reachable from an entry component.\n\nIf a component isn't an _entry component_ or wasn't found in a template,\nthe compiler omits it.\n-->\n<p>진입 컴포넌트는 <em>트리 셰이킹</em> 때문에 필요합니다.\n배포되는 앱 코드는 최대한 작고 빠르게 동작하는 것이 중요합니다.\n그래서 배포되는 코드에도 실제로 사용되는 클래스만 포함되는 것이 좋으며, 사용되지 않는 컴포넌트는 최종 코드에서 빠지는 것이 좋습니다.</p>\n<p>사실 라이브러리에서 제공하는 많은 코드 중에 실제로 사용되는 것은 많지 않습니다.\n그래서 사용되지 않는 코드들은 트리 셰이킹 과정을 거치면 최종 코드에서 모두 제거됩니다.</p>\n<p>컴포넌트가 정의되었다고 해서 <a href=\"guide/ngmodule-faq#q-angular-compiler\">Angular 컴파일러</a>가 이 코드를 모두 생성하면, 이것은 트리 셰이킹의 목적과 어울리지 않습닌다.</p>\n<p>그래서 컴파일러는 실제로 사용하는 컴포넌트를 찾기 위해 재귀적으로 탐색하는 방식을 사용합니다.</p>\n<p>실제로 사용하는 컴포넌트는 진입 컴포넌트를 기준으로 찾기 시작하며, 템플릿에 사용된 컴포넌트를 <a href=\"guide/ngmodule-faq#q-template-reference\">찾으면</a> 이 컴포넌트도 사용되는 것으로 판단합니다.\n이 과정을 모두 마치고 나면, 최종 코드에는 진입 컴포넌트부터 시작해서 접근할 수 있는 모든 컴포넌트에 대한 코드만 생성됩니다.</p>\n<p>컴포넌트가 <em>진입 컴포넌트</em> 가 아니고, 템플릿에도 사용되지 않으면 이 컴포넌트는 컴파일러가 처리하지 않습니다.</p>\n<hr>\n<!--\n## What kinds of modules should I have and how should I use them?\n-->\n<h2 id=\"모듈의-종류는-어떤-것이-있으며-어떻게-사용해야-하나요\">모듈의 종류는 어떤 것이 있으며, 어떻게 사용해야 하나요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#모듈의-종류는-어떤-것이-있으며-어떻게-사용해야-하나요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nEvery app is different. Developers have various levels of experience and comfort with the available choices.\nSome suggestions and guidelines appear to have wide appeal.\n-->\n<p>앱은 모두 다릅니다. 앱을 개발하는 개발자의 경험도 모두 다르고, 정책을 정하는 기준도 다릅니다.\n이 문단에서는 모듈에 대한 대략적인 가이드를 안내합니다.</p>\n<!--\n### `SharedModule`\n-->\n<h3 id=\"공유-모듈-sharedmodule\">공유 모듈 (<code>SharedModule</code>)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#공유-모듈-sharedmodule\"><i class=\"material-icons\">link</i></a></h3>\n<!--\n`SharedModule` is a conventional name for an `NgModule` with the components, directives, and pipes that you use\neverywhere in your app. This module should consist entirely of `declarations`,\nmost of them exported.\n\nThe `SharedModule` may re-export other widget modules, such as `CommonModule`,\n`FormsModule`, and NgModules with the UI controls that you use most widely.\n\nThe `SharedModule` should not have `providers` for reasons [explained previously](guide/ngmodule-faq#q-why-bad).\nNor should any of its imported or re-exported modules have `providers`.\n\nImport the `SharedModule` in your _feature_ modules,\nboth those loaded when the app starts and those you lazy load later.\n-->\n<p>공유 모듈은 앱 전역에서 자유롭게 사용하는 컴포넌트와 디렉티브, 파이프를 정의하는 모듈을 의미합니다.\n이 모듈은 <code>declarations</code> 구성이 가장 중요하며, 모듈에 정의된 Angular 구성요소 대부분을 모듈 외부로 공개합니다.</p>\n<p>이 모듈은 <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>이나 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 등 모듈의 UI 컨트롤에 필요한 다른 모듈을 가져와서 다시 모듈 외부로 공개하기도 합니다.</p>\n<p>그리고 이 모듈은 <a href=\"guide/ngmodule-faq#q-why-bad\">위에서 설명한 이유</a> 때문에 <code>providers</code>를 지정하지 않는 것이 좋습니다.\n그리고 같은 이유로 다른 모듈에 있는 <code>providers</code>를 모듈 외부로 다시 공개하지 않는 것이 좋습니다.</p>\n<p>공유 모듈은 기능 모듈이 로드해서 사용합니다.\n이 때 기능 모듈은 앱이 실행되면서 즉시 로드되는 모듈이던지, 지연 로딩되는 모듈이던지 상관없습니다.</p>\n<!--\n### Feature Modules\n-->\n<h3 id=\"기능-모듈-feature-modules\">기능 모듈 (Feature Modules)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#기능-모듈-feature-modules\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nFeature modules are modules you create around specific application business domains, user workflows, and utility collections. They support your app by containing a particular feature,\nsuch as routes, services, widgets, etc. To conceptualize what a feature module might be in your\napp, consider that if you would put the files related to a certain functionality, like a search,\nin one folder, that the contents of that folder would be a feature module that you might call\nyour `SearchModule`. It would contain all of the components, routing, and templates that\nwould make up the search functionality.\n\nFor more information, see [Feature Modules](guide/feature-modules) and\n[Module Types](guide/module-types)\n-->\n<p>기능 모듈은 애플리케이션의 업무 로직과 관련된 모듈을 의미하며, 사용자의 동작 흐름이나 도메인에 필요한 기능을 담당합니다.\n이 모듈은 라우팅이나 서비스, 위젯 등 애플리케이션에 필요한 기능을 제공합니다.\n기능 모듈에 대한 개념을 확실하게 잡으려면 특정 기능을 담당하는 파일을 모두 모은 폴더를 생각하면 되는데, 예를 들어 검색 기능을 담당하는 폴더라면 이 모듈을 <code>SearchModule</code>이라고 생각할 수 있습니다.\n검색 기능에 필요한 컴포넌트와 라우팅, 템플릿은 모두 이 폴더 안에 포함됩니다.</p>\n<!--\nFor more information, see [Feature Modules](guide/feature-modules) and\n[Module Types](guide/module-types)\n-->\n<p>좀 더 자세한 내용은 <a href=\"guide/feature-modules\">기능 모듈</a>과 <a href=\"guide/module-types\">모듈의 종류</a> 문서를 참고하세요.</p>\n<!--\n## What's the difference between NgModules and JavaScript Modules?\n-->\n<h2 id=\"ngmodule과-javascript-모듈은-어떻게-다른가요\">NgModule과 JavaScript 모듈은 어떻게 다른가요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#ngmodule과-javascript-모듈은-어떻게-다른가요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nIn an Angular app, NgModules and JavaScript modules work together.\n\nIn modern JavaScript, every file is a module\n(see the [Modules](http://exploringjs.com/es6/ch_modules.html) page of the Exploring ES6 website).\nWithin each file you write an `export` statement to make parts of the module public.\n\nAn Angular NgModule is a class with the `@NgModule` decorator&mdash;JavaScript modules\ndon't have to have the `@NgModule` decorator. Angular's `NgModule` has `imports` and `exports` and they serve a similar purpose.\n\nYou _import_ other NgModules so you can use their exported classes in component templates.\nYou _export_ this NgModule's classes so they can be imported and used by components of _other_ NgModules.\n\nFor more information, see [JavaScript Modules vs. NgModules](guide/ngmodule-vs-jsmodule).\n-->\n<p>Angular 앱에서는 NgModule과 JavaScript 모듈을 함께 사용합니다.</p>\n<p>ES6를 사용하는 최근 JavaScript는 각각의 파일을 모듈로 볼 수 있습니다.\n(<a href=\"http://exploringjs.com/es6/ch_modules.html\">모듈</a> 문서를 참고하세요.)\n그리고 각각의 파일에서 <code>export</code> 키워드로 지정한 객체가 모듈 외부로 공개됩니다.</p>\n<p>Angular의 모듈은 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 데코레이터가 지정된 JavaScript 클래스입니다.\nNgModule에서 모듈을 조합할 때는 JavaScript와 비슷하게 <code>imports</code> 프로퍼티와 <code>exports</code> 프로퍼티를 사용합니다.</p>\n<p>NgModule을 로드하면 이 모듈이 모듈 외부로 공개한 클래스들을 컴포넌트 템플릿에 사용할 수 있습니다.\n그리고 모듈에 정의된 클래스들은 다른 모듈에 사용할 수 있도록 모듈 외부로 공개할 수도 있습니다.</p>\n<p>좀 더 자세한 내용은 <a href=\"guide/ngmodule-vs-jsmodule\">JavaScript 모듈 vs. NgModules</a> 문서를 참고하세요.</p>\n<hr>\n<a id=\"q-template-reference\"></a>\n<!--\n## How does Angular find components, directives, and pipes in a template?<br>What is a <i><b>template reference</b></i>?\n-->\n<h2 id=\"angular는-템플릿에-사용된-컴포넌트나-디렉티브-파이프를-어떻게-찾나요\">Angular는 템플릿에 사용된 컴포넌트나 디렉티브, 파이프를 어떻게 찾나요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#angular는-템플릿에-사용된-컴포넌트나-디렉티브-파이프를-어떻게-찾나요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe [Angular compiler](guide/ngmodule-faq#q-angular-compiler) looks inside component templates\nfor other components, directives, and pipes. When it finds one, that's a template reference.\n\nThe Angular compiler finds a component or directive in a template when it can match the *selector* of that component or directive to some HTML in that template.\n\nThe compiler finds a pipe if the pipe's *name* appears within the pipe syntax of the template HTML.\n\nAngular only matches selectors and pipe names for classes that are declared by this module\nor exported by a module that this module imports.\n-->\n<p><a href=\"guide/ngmodule-faq#q-angular-compiler\">Angular 컴파일러</a>는 컴포넌트 템플릿에 다른 컴포넌트나 디렉티브, 파이프가 사용된 것을 감지할 수 있습니다.</p>\n<p>템플릿에 사용된 컴포넌트나 디렉티브를 Angular 컴파일러가 확인하면, 이 컴포넌트가 어떤 컴포넌트인지 컴포넌트의 <em>셀렉터</em> 로 구분합니다.</p>\n<p>그리고 템플릿에 사용된 파이프는 파이프의 <em>이름</em> 을 기준으로 구분합니다.</p>\n<p>이 때 적용되는 컴포넌트 셀렉터와 파이프 이름은 현재 모듈에 정의된 클래스이거나, 다른 모듈에서 가져온 클래스만 유효합니다.</p>\n<hr>\n<a id=\"q-angular-compiler\"></a>\n<!--\n## What is the Angular compiler?\n-->\n<h2 id=\"angular-컴파일러가-뭔가요\">Angular 컴파일러가 뭔가요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#angular-컴파일러가-뭔가요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe Angular compiler converts the application code you write into highly performant JavaScript code.\nThe `@NgModule` metadata plays an important role in guiding the compilation process.\n\nThe code you write isn't immediately executable. For example, components have templates that contain custom elements, attribute directives, Angular binding declarations,\nand some peculiar syntax that clearly isn't native HTML.\n\nThe Angular compiler reads the template markup,\ncombines it with the corresponding component class code, and emits _component factories_.\n\nA component factory creates a pure, 100% JavaScript representation\nof the component that incorporates everything described in its `@Component` metadata:\nthe HTML, the binding instructions, the attached styles.\n\nBecause directives and pipes appear in component templates,\nthe Angular compiler incorporates them into compiled component code too.\n\n`@NgModule` metadata tells the Angular compiler what components to compile for this module and\nhow to link this module with other modules.\n-->\n<p>Angular 컴파일러는 애플리케이션 코드를 JavaScript 코드로 변환하는 툴입니다.\n그리고 이 컴파일 과정에는 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 메타데이터의 내용이 중요합니다.</p>\n<p>TypeScript로 작성한 Angular 코드는 그 자체로 실행할 수 없습니다.\n컴포넌트를 생각해봐도 컴포넌트에는 커스텀 엘리먼트와 어트리뷰트 디렉티브, Angular 바인딩 문법 등 네이티브 HTML에는 없는 문법이 많이 사용됩니다.</p>\n<p>Angular 컴파일러는 이 템플릿을 읽고 관련된 컴포넌트를 연결하며 <em>컴포넌트 팩토리(component factories)</em> 를 생성합니다.</p>\n<p>컴포넌트 팩토리는 컴포넌트를 표현하는 100% JavaScript 코드를 생성하는데, 이 때 컴포넌트의 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 메타데이터에 지정하는 내용으로 HTML 템플릿과 바인딩 방식, 스타일을 연결합니다.</p>\n<p>그리고 컴포넌트 템플릿에 사용된 디렉티브와 파이프도 Angular 컴파일러가 컴포넌트 코드에 연결합니다.</p>\n<p>Angular 컴파일러가 컴파일 할 컴포넌트를 지정하고, 이 모듈이 다른 모듈과 어떻게 연결되는지를 설정하는 것은 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 설정에 따라 달라집니다.</p>\n\n</div>\n\n<!-- links to this doc:\n - guide/entry-components\n - guide/ngmodule-api\n - guide/providers\n - guide/singleton-services\n-->\n<!-- links from this doc:\n - api/common/CommonModule\n - api/common/NgIf\n - api/common/http/HttpBackend\n - api/common/http/HttpClientModule\n - api/core/ApplicationModule\n - api/core/Component\n - api/core/Injectable\n - api/core/InjectionToken\n - api/core/ModuleWithProviders\n - api/core/NgModule\n - api/core/NgModule#bootstrap\n - api/core/NgModule#providers\n - api/core/Optional\n - api/core/SkipSelf\n - api/forms/FormsModule\n - api/forms/NgModel\n - api/platform-browser/BrowserModule\n - api/router/Router\n - api/router/RouterModule\n - api/router/RouterModule#forRoot\n - api/router/RouterOutlet\n - api/router/Routes\n - guide/bootstrapping#declarations-%EB%B0%B0%EC%97%B4\n - guide/entry-components\n - guide/feature-modules\n - guide/module-types\n - guide/ngmodule-faq#angular-컴파일러가-뭔가요\n - guide/ngmodule-faq#angular는-템플릿에-사용된-컴포넌트나-디렉티브-파이프를-어떻게-찾나요\n - guide/ngmodule-faq#browsermodule을-로드해야-하나요-commonmodule을-로드해야-하나요\n - guide/ngmodule-faq#cant-bind-to-x-since-it-isnt-a-known-property-of-y-에러가-발생하는-이유는-뭔가요\n - guide/ngmodule-faq#declarable-이-뭔가요\n - guide/ngmodule-faq#declarations-배열에-추가하지-말아야-할-클래스는-어떤-것이-있나요\n - guide/ngmodule-faq#declarations-배열에는-어떤-클래스를-추가해야-하나요\n - guide/ngmodule-faq#forroot-메소드가-뭔가요\n - guide/ngmodule-faq#ngmodule-faq\n - guide/ngmodule-faq#ngmodule-프로퍼티에-컴포넌트가-여러번-사용되는-경우도-있나요\n - guide/ngmodule-faq#ngmodule과-javascript-모듈은-어떻게-다른가요\n - guide/ngmodule-faq#q-angular-compiler\n - guide/ngmodule-faq#q-browser-vs-common-module\n - guide/ngmodule-faq#q-component-or-module\n - guide/ngmodule-faq#q-entry-component-defined\n - guide/ngmodule-faq#q-lazy-loaded-module-provider-visibility\n - guide/ngmodule-faq#q-reexport\n - guide/ngmodule-faq#q-reimport\n - guide/ngmodule-faq#q-root-component-or-module\n - guide/ngmodule-faq#q-template-reference\n - guide/ngmodule-faq#q-why-bad\n - guide/ngmodule-faq#q-why-child-injector\n - guide/ngmodule-faq#service-scope\n - guide/ngmodule-faq#같은-서비스가-다른-모듈로-두-번-등록되면-어떻게-되나요\n - guide/ngmodule-faq#공유-모듈-sharedmodule\n - guide/ngmodule-faq#기능-모듈-feature-modules\n - guide/ngmodule-faq#기능-모듈에-등록된-서비스는-왜-외부에서도-접근할-수-있나요\n - guide/ngmodule-faq#다른-곳에서-불러온-클래스나-모듈을-다시-exports로-지정해도-되나요\n - guide/ngmodule-faq#모듈-외부로-공개하지-말아야-하는-것은-어떤-것이-있나요\n - guide/ngmodule-faq#모듈을-두-번-로드하면-어떻게-되나요\n - guide/ngmodule-faq#모듈의-종류는-어떤-것이-있으며-어떻게-사용해야-하나요\n - guide/ngmodule-faq#모듈이나-서비스가-로드되었는지-어떻게-확인하나요\n - guide/ngmodule-faq#무엇을-모듈-외부로-공개해야-하나요\n - guide/ngmodule-faq#부트스트랩-컴포넌트와-진입-컴포넌트-의-차이는-뭔가요\n - guide/ngmodule-faq#서비스를-모듈-범위로-제한하고-싶으면-어떻게-하면-되나요\n - guide/ngmodule-faq#애플리케이션-전역에-사용하는-프로바이더는-appmodule이나-appcomponent에-등록해야-하나요\n - guide/ngmodule-faq#어떤-모듈을-로드import해야-하나요\n - guide/ngmodule-faq#어떤-컴포넌트를-entrycomponents-에-등록해야-하나요\n - guide/ngmodule-faq#주의\n - guide/ngmodule-faq#즉시-로드되는-모듈의-경우\n - guide/ngmodule-faq#지연로딩-되는-모듈에-등록된-서비스는-왜-그-모듈에서만-접근할-수-있나요\n - guide/ngmodule-faq#지연로딩-모듈에서-공유모듈에-있는-프로바이더를-사용하는-것은-안-좋은가요\n - guide/ngmodule-faq#지연로딩되는-모듈은-왜-자식-인젝터를-만드나요\n - guide/ngmodule-faq#지연로딩되는-모듈의-경우\n - guide/ngmodule-faq#진입-컴포넌트entry-component가-뭔가요\n - guide/ngmodule-faq#진입-컴포넌트는-왜-필요하죠\n - guide/ngmodule-faq#프로바이더는-모듈이나-컴포넌트에-꼭-등록해야-하나요\n - guide/ngmodule-vs-jsmodule\n - guide/singleton-services\n - guide/singleton-services#the-forroot-pattern\n - http://exploringjs.com/es6/ch_modules.html\n - https://github.com/angular/angular/edit/master/aio/content/guide/ngmodule-faq.md?message=docs%3A%20describe%20your%20change...\n-->"
}