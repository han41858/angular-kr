{
  "id": "guide/practical-observable-usage",
  "title": "옵저버블 실전 예제",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/practical-observable-usage.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Practical observable usage\n-->\n<h1 id=\"옵저버블-실전-예제\">옵저버블 실전 예제<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/practical-observable-usage#옵저버블-실전-예제\"><i class=\"material-icons\">link</i></a></h1>\n<!--\nHere are some examples of domains in which observables are particularly useful.\n-->\n<p>이 문서는 옵저버블을 사용하는 것이 좀 더 효율적인 분야를 소개합니다.</p>\n<!--\n## Type-ahead suggestions\n-->\n<h2 id=\"코드-자동완성\">코드 자동완성<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/practical-observable-usage#코드-자동완성\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nObservables can simplify the implementation of type-ahead suggestions. Typically, a type-ahead has to do a series of separate tasks:\n-->\n<p>옵저버블을 사용하면 코드 자동완성 기능을 간단하게 구현할 수 있습니다. 일반적으로 이 기능은 다음 순서로 구현합니다:</p>\n<!--\n* Listen for data from an input.\n* Trim the value (remove whitespace) and make sure it’s a minimum length.\n* Debounce (so as not to send off API requests for every keystroke, but instead wait for a break in keystrokes).\n* Don’t send a request if the value stays the same (rapidly hit a character, then backspace, for instance).\n* Cancel ongoing AJAX requests if their results will be invalidated by the updated results.\n-->\n<ul>\n<li>입력 필드의 데이터가 변하는 것를 감지합니다.</li>\n<li>공백문자를 제거한 후에 최소 길이 조건을 만족하는지 확인합니다.</li>\n<li>딜레이를 줍니다. 모든 키 입력마다 API를 요청하는 것보다 키 입력을 지연시키는 것이 나은 경우도 있습니다.</li>\n<li>입력된 값이 변하지 않았으면 요청을 보내지 않습니다. 한 글자를 계속 눌렀거나, 백스페이스를 누른 경우도 감지할 수 있습니다.</li>\n<li>이전 요청 결과와 다르면 AJAX 요청을 취소하고 새로운 요청을 보냅니다.</li>\n</ul>\n<!--\nWriting this in full JavaScript can be quite involved. With observables, you can use a simple series of RxJS operators:\n-->\n<p>이 내용을 모두 JavaScript로 구현하는 것은 상당히 번거로운 일입니다. 하지만 옵저버블과 RxJS 연산자를 활용하면 다음과 같이 간단하게 구현할 수 있습니다:</p>\n<!--\n<code-example path=\"practical-observable-usage/src/typeahead.ts\" header=\"Typeahead\">\nimport { fromEvent } from &#39;rxjs&#39;;\nimport { ajax } from &#39;rxjs/ajax&#39;;\nimport { debounceTime, distinctUntilChanged, filter, map, switchMap } from &#39;rxjs/operators&#39;;\n\n\nconst searchBox = document.getElementById(&#39;search-box&#39;);\n\nconst typeahead = fromEvent(searchBox, &#39;input&#39;).pipe(\n  map((e: KeyboardEvent) =&gt; (e.target as HTMLInputElement).value),\n  filter(text =&gt; text.length &gt; 2),\n  debounceTime(10),\n  distinctUntilChanged(),\n  switchMap(() =&gt; ajax(&#39;/api/endpoint&#39;))\n);\n\ntypeahead.subscribe(data =&gt; {\n // 서버 요청으로 받은 데이터를 처리합니다.\n});\n\n\n</code-example>\n-->\n<code-example path=\"practical-observable-usage/src/typeahead.ts\" header=\"코드 자동완성\">\nimport { fromEvent } from 'rxjs';\nimport { ajax } from 'rxjs/ajax';\nimport { debounceTime, distinctUntilChanged, filter, map, switchMap } from 'rxjs/operators';\n\n\nconst searchBox = document.getElementById('search-box');\n\nconst typeahead = fromEvent(searchBox, 'input').pipe(\n  map((e: KeyboardEvent) => (e.target as HTMLInputElement).value),\n  filter(text => text.length > 2),\n  debounceTime(10),\n  distinctUntilChanged(),\n  switchMap(() => ajax('/api/endpoint'))\n);\n\ntypeahead.subscribe(data => {\n // 서버 요청으로 받은 데이터를 처리합니다.\n});\n\n\n</code-example>\n<h2 id=\"지수-백오프exponential-backoff\">지수 백오프(Exponential backoff)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/practical-observable-usage#지수-백오프exponential-backoff\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nExponential backoff is a technique in which you retry an API after failure, making the time in between retries longer after each consecutive failure, with a maximum number of retries after which the request is considered to have failed. This can be quite complex to implement with promises and other methods of tracking AJAX calls. With observables, it is very easy:\n\n<code-example path=\"practical-observable-usage/src/backoff.ts\" header=\"Exponential backoff\">\n\nimport { pipe, range, timer, zip } from &#39;rxjs&#39;;\nimport { ajax } from &#39;rxjs/ajax&#39;;\nimport { retryWhen, map, mergeMap } from &#39;rxjs/operators&#39;;\n\nfunction backoff(maxTries, ms) {\n return pipe(\n   retryWhen(attempts =&gt; zip(range(1, maxTries), attempts)\n     .pipe(\n       map(([i]) =&gt; i * i),\n       mergeMap(i =&gt;  timer(i * ms))\n     )\n   )\n );\n}\n\najax(&#39;/api/endpoint&#39;)\n  .pipe(backoff(3, 250))\n  .subscribe(data =&gt; handleData(data));\n\nfunction handleData(data) {\n  // ...\n}\n\n\n</code-example>\n-->\n<p>지수 백오프는 API 요청을 실패했을 때 사용하는 테크닉입니다. 이 테크닉은 요청이 계속 실패할 때마다 점점 긴 시간 간격을 두고 재시도하며, 정해진 재시도 횟수를 넘어가면 최종 실패한 것으로 판단합니다. 이 기능은 AJAX 요청을 계속 추적해야 하기 때문에 Promise나 JavaScript로 구현하기는 조금 복잡합니다. 하지만 옵저버블을 사용하면 아주 간단합니다:</p>\n<code-example path=\"practical-observable-usage/src/backoff.ts\" header=\"지수 백오프\">\n\nimport { pipe, range, timer, zip } from 'rxjs';\nimport { ajax } from 'rxjs/ajax';\nimport { retryWhen, map, mergeMap } from 'rxjs/operators';\n\nfunction backoff(maxTries, ms) {\n return pipe(\n   retryWhen(attempts => zip(range(1, maxTries), attempts)\n     .pipe(\n       map(([i]) => i * i),\n       mergeMap(i =>  timer(i * ms))\n     )\n   )\n );\n}\n\najax('/api/endpoint')\n  .pipe(backoff(3, 250))\n  .subscribe(data => handleData(data));\n\nfunction handleData(data) {\n  // ...\n}\n\n\n</code-example>\n\n</div>\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - guide/practical-observable-usage#옵저버블-실전-예제\n - guide/practical-observable-usage#지수-백오프exponential-backoff\n - guide/practical-observable-usage#코드-자동완성\n - https://github.com/angular/angular/edit/master/aio/content/guide/practical-observable-usage.md?message=docs%3A%20describe%20your%20change...\n-->"
}