{
  "id": "guide/attribute-directives",
  "title": "어트리뷰트 디렉티브",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/attribute-directives.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Attribute Directives\n-->\n<h1 id=\"어트리뷰트-디렉티브\">어트리뷰트 디렉티브<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/attribute-directives#어트리뷰트-디렉티브\"><i class=\"material-icons\">link</i></a></h1>\n<!--\nAn **Attribute** directive changes the appearance or behavior of a DOM element.\n-->\n<p><strong>어트리뷰트</strong> 디렉티브는 DOM 엘리먼트의 모습이나 동작을 변경합니다.</p>\n<!--\nTry the <live-example title=\"Attribute Directive example\"></live-example>.\n-->\n<p>이 문서에서 설명하는 예제는 <live-example title=\"Attribute Directive example\"></live-example>에서 직접 확인하거나 다운 받을 수 있습니다.</p>\n<!--\n<a id=\"directive-overview\"></a>\n-->\n<a id=\"디렉티브-개요\"></a>\n<!--\n## Directives overview\n-->\n<h2 id=\"디렉티브-개요\">디렉티브 개요<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/attribute-directives#디렉티브-개요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThere are three kinds of directives in Angular:\n-->\n<p>Angular 디렉티브는 3종류가 있습니다:</p>\n<!--\n1. Components&mdash;directives with a template.\n1. Structural directives&mdash;change the DOM layout by adding and removing DOM elements.\n1. Attribute directives&mdash;change the appearance or behavior of an element, component, or another directive.\n-->\n<ol>\n<li>컴포넌트—템플릿이 있는 디렉티브</li>\n<li>구조 디렉티브—DOM 엘리먼트를 추가하거나 제거해서 DOM 레이아웃을 변경합니다.</li>\n<li>어트리뷰트 디렉티브—엘리먼트나 컴포넌트, 다른 디렉티브의 모습이나 동작을 변경합니다.</li>\n</ol>\n<!--\n*Components* are the most common of the three directives.\nYou saw a component for the first time in the [Getting Started](start \"Getting Started with Angular\") tutorial.\n-->\n<p>디렉티브 중에서는 <em>컴포넌트</em>를 가장 많이 사용합니다.\n처음 확인하는 가이드 문서인 <a href=\"start\" title=\"Getting Started with Angular\">시작하기</a>에서도 확인할 수 있습니다.</p>\n<!--\n*Structural Directives* change the structure of the view.\nTwo examples are [NgFor](guide/template-syntax#ngFor) and [NgIf](guide/template-syntax#ngIf).\nLearn about them in the [Structural Directives](guide/structural-directives) guide.\n-->\n<p><em>구조 디렉티브</em>는 뷰의 구조를 변경합니다.\n구조 디렉티브 중에서 가장 많이 사용하는 <a href=\"guide/template-syntax#ngFor\">NgFor</a>나 <a href=\"guide/template-syntax#ngIf\">NgIf</a> 예제를 확인해 보세요.\n구조 디렉티브의 개념은 <a href=\"guide/structural-directives\">구조 디렉티브</a>에서도 확인할 수 있습니다.</p>\n<!--\n*Attribute directives* are used as attributes of elements.\nThe built-in [NgStyle](guide/template-syntax#ngStyle) directive in the\n[Template Syntax](guide/template-syntax) guide, for example,\ncan change several element styles at the same time.\n-->\n<p><em>어트리뷰트 디렉티브</em>는 엘리먼트의 어트리뷰트처럼 사용합니다.\n<a href=\"guide/template-syntax\">템플릿 문법</a> 가이드 문서에서 활용하는 <a href=\"guide/template-syntax#ngStyle\">NgStyle</a>을 확인해 보세요. 이 디렉티브는 Angular에서 제공하는 기본 디렉티브이며, 여러 엘리먼트 스타일을 한 번에 지정할 수 있습니다.</p>\n<!--\n## Build a simple attribute directive\n-->\n<h2 id=\"간단한-어트리뷰트-디렉티브-만들어보기\">간단한 어트리뷰트 디렉티브 만들어보기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/attribute-directives#간단한-어트리뷰트-디렉티브-만들어보기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAn attribute directive minimally requires building a controller class annotated with\n`@Directive`, which specifies the selector that identifies\nthe attribute.\nThe controller class implements the desired directive behavior.\n-->\n<p>어트리뷰트 디렉티브는 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code> 데코레이터가 붙은 클래스 코드만으로 간단하게 만들 수 있습니다. 이 데코레이터의 메타데이터에는 디렉티브가 적용될 셀렉터를 지정합니다.\n클래스 코드에는 디렉티브가 어떻게 동작할지 정의하는 로직을 작성합니다.</p>\n<!--\nThis page demonstrates building a simple _appHighlight_ attribute\ndirective to set an element's background color\nwhen the user hovers over that element. You can apply it like this:\n-->\n<p>이 문서에서는 사용자가 엘리먼트 위로 마우스를 올렸을 때 엘리먼트의 배경 색상을 변경하는 <em>appHighlight</em> 어트리뷰트 디렉티브를 간단하게 만들어 봅니다.\n이 디렉티브는 다음과 같이 적용합니다:</p>\n<code-example path=\"attribute-directives/src/app/app.component.1.html\" linenums=\"false\" header=\"src/app/app.component.html (applied)\" region=\"applied\">\n&#x3C;p appHighlight>Highlight me!&#x3C;/p>\n\n</code-example>\n<!--\n<a id=\"write-directive\"></a>\n-->\n<a id=\"디렉티브-코드-작성하기\"></a>\n<!--\nPlease note that directives _do not_ support namespaces.\n-->\n<p>디렉티브는 네임스페이스를 지원하지 <em>않는다는 것을</em> 명심하세요.</p>\n<!--\n<code-example path=\"attribute-directives/src/app/app.component.avoid.html\" linenums=\"false\" header=\"src/app/app.component.avoid.html (unsupported)\" region=\"unsupported\">\n&lt;p app:Highlight&gt;This is invalid&lt;/p&gt;\n\n</code-example>\n-->\n<code-example path=\"attribute-directives/src/app/app.component.avoid.html\" linenums=\"false\" header=\"src/app/app.component.avoid.html (지원하지 않는 문법)\" region=\"unsupported\">\n&#x3C;p app:Highlight>This is invalid&#x3C;/p>\n\n</code-example>\n<!--\n### Write the directive code\n-->\n<h3 id=\"디렉티브-코드-작성하기\">디렉티브 코드 작성하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/attribute-directives#디렉티브-코드-작성하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nCreate the directive class file in a terminal window with the CLI command [`ng generate directive`](cli/generate).\n-->\n<p>터미널에서 CLI 명령 <a href=\"cli/generate\"><code>ng generate directive</code></a>를 사용하면 디렉티브 클래스 파일을 간단하게 만들 수 있습니다.</p>\n<code-example language=\"sh\" class=\"code-shell\">\nng generate directive highlight\n</code-example>\n<!--\nThe CLI creates `src/app/highlight.directive.ts`, a corresponding test file `src/app/highlight.directive.spec.ts`, and _declares_ the directive class in the root `AppModule`.\n-->\n<p>이 명령을 실행하면 CLI가 <code>src/app/highlight.directive.ts</code> 파일과 테스트 파일인 <code>src/app/highlight.directive.spec.ts</code> 파일을 함께 생성하고 최상위 모듈 <code>AppModule</code>에 이 디렉티브 클래스를 자동으로 추가합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\n_Directives_ must be declared in [Angular Modules](guide/ngmodules) in the same manner as _components_.\n-->\n<p><em>디렉티브</em> 는 <em>컴포넌트</em> 와 마찬가지로 <a href=\"guide/ngmodules\">Angular 모듈</a>에 반드시 정의되어야 합니다.</p>\n</div>\n<!--\nThe generated `src/app/highlight.directive.ts` is as follows:\n-->\n<p>이렇게 생성된 <code>src/app/highlight.directive.ts</code> 파일의 내용은 다음과 같습니다:</p>\n<code-example path=\"attribute-directives/src/app/highlight.directive.0.ts\" header=\"src/app/highlight.directive.ts\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a> } from '@angular/core';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: '[appHighlight]'\n})\nexport class HighlightDirective {\n  constructor() { }\n}\n\n\n</code-example>\n<!--\nThe imported `Directive` symbol provides Angular the `@Directive` decorator.\n-->\n<p>먼저, Angular 데코레이터 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code>를 사용하기 위해 <code><a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code> 심볼을 로드합니다.</p>\n<!--\nThe `@Directive` decorator's lone configuration property specifies the directive's\n[CSS attribute selector](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors), `[appHighlight]`.\n-->\n<p><code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code>에는 <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors\">CSS 어트리뷰트 셀렉터</a>로 디렉티브 셀렉터를 지정하며, 이 코드의 경우에는 <code>[appHighlight]</code>로 지정했습니다.</p>\n<!--\nIt's the brackets (`[]`) that make it an attribute selector.\nAngular locates each element in the template that has an attribute named `appHighlight` and applies the logic of this directive to that element.\n-->\n<p>어트리뷰트 셀렉터는 HTML 문서에 대괄호(<code>[]</code>)를 사용해서 지정합니다.\n그러면 Angular가 템플릿을 처리할 때 <code>appHighlight</code> 어트리뷰트가 지정된 엘리먼트에 이 디렉티브를 적용합니다.</p>\n<!--\nThe _attribute selector_ pattern explains the name of this kind of directive.\n-->\n<p>따라서 <em>어트리뷰트 셀렉터</em> 는 디렉티브의 동작을 적절하게 표현할 수 있는 이름으로 지정하는 것이 좋습니다.</p>\n<div class=\"alert is-helpful\">\n<!--\n#### Why not \"highlight\"?\n-->\n<h3 id=\"highlight를-사용하면-왜-안될까\"><code>highlight</code>를 사용하면 왜 안될까?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/attribute-directives#highlight를-사용하면-왜-안될까\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThough *highlight* would be a more concise selector than *appHighlight* and it would work,\nthe best practice is to prefix selector names to ensure\nthey don't conflict with standard HTML attributes.\nThis also reduces the risk of colliding with third-party directive names.\nThe CLI added the `app` prefix for you.\n-->\n<p>디렉티브 셀렉터를 <em>appHighlight</em>라고 정의하는 것보다 <em>highlight</em>라고 정의하는 것이 더 간단하고 이렇게 정의해도 디렉티브가 동작하는 데에는 문제가 없지만, 표준 HTML 어트리뷰트와 충돌하는 것을 방지하기 위해 셀렉터에는 접두사를 붙이는 것을 권장합니다.\n이 방법은 서드파티 디렉티브의 셀렉터와 충돌하는 것을 막는 방법이기도 합니다.\nCLI가 기본으로 붙이는 접두사는 <code>app</code>입니다.</p>\n<!--\nMake sure you do **not** prefix the `highlight` directive name with **`ng`** because\nthat prefix is reserved for Angular and using it could cause bugs that are difficult to diagnose.\n-->\n<p>이 때 접두사로 <strong><code>ng</code></strong>는 사용하지 마세요. 이 접두사는 Angular가 이미 사용하고 있기 때문에 <code>ng</code> 접두사를 사용하면 확인하기 어려운 버그를 발생시킬 수도 있습니다.</p>\n</div>\n<!--\nAfter the `@Directive` metadata comes the directive's controller class,\ncalled `HighlightDirective`, which contains the (currently empty) logic for the directive.\nExporting `HighlightDirective` makes the directive accessible.\n-->\n<p><code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code> 데코레이터 뒤에는 디렉티브의 컨트롤러 클래스가 위치하는데, 이 예제의 경우에는 <code>HighlightDirective</code>이며 디렉티브가 동작하는 로직을 이 클래스에 정의합니다.\n그리고 이 디렉티브를 다른 파일에서 사용하기 위해 <code>export</code> 키워드를 사용해서 외부로 공개했습니다.</p>\n<!--\nNow edit the generated `src/app/highlight.directive.ts` to look as follows:\n-->\n<p>이제 <code>src/app/highlight.directive.ts</code> 코드를 다음과 같이 수정합니다:</p>\n<code-example path=\"attribute-directives/src/app/highlight.directive.1.ts\" header=\"src/app/highlight.directive.ts\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a> } from '@angular/core';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: '[appHighlight]'\n})\nexport class HighlightDirective {\n    constructor(el: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>) {\n       el.nativeElement.style.backgroundColor = 'yellow';\n    }\n}\n\n\n</code-example>\n<!--\nThe `import` statement specifies an additional `ElementRef` symbol from the Angular `core` library:\n-->\n<p>이 때 <code><a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a></code> 심볼을 의존성으로 주입받기 위해 <code>import</code> 키워드를 사용해서 Angular <code>core</code> 라이브러리를 불러왔습니다:</p>\n<!--\nYou use the `ElementRef` in the directive's constructor\nto [inject](guide/dependency-injection) a reference to the host DOM element, \nthe element to which you applied `appHighlight`.\n-->\n<p>이 디렉티브는 디렉티브가 적용되는 DOM 엘리먼트를 참조하기 위해 <code><a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a></code>를 디렉티브 생성자로 <a href=\"guide/dependency-injection\">주입</a>받습니다.</p>\n<!--\n`ElementRef` grants direct access to the host DOM element\nthrough its `nativeElement` property.\n-->\n<p>그리고 <code><a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a></code>의 <code>nativeElement</code> 프로퍼티를 참조하면 호스트 DOM 엘리먼트에 직접 접근할 수 있습니다.</p>\n<!--\nThis first implementation sets the background color of the host element to yellow.\n-->\n<p>처음 작성하는 코드에서는 호스트 엘리먼트의 배경 색을 노란색으로 변경하도록 구현했습니다.</p>\n<!--\n<a id=\"apply-directive\"></a>\n-->\n<a id=\"디렉티브-적용하기\"></a>\n<!--\n## Apply the attribute directive\n-->\n<h2 id=\"어트리뷰트-디렉티브-적용하기\">어트리뷰트 디렉티브 적용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/attribute-directives#어트리뷰트-디렉티브-적용하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nTo use the new `HighlightDirective`, add a paragraph (`<p>`) element to the template of the root `AppComponent` and apply the directive as an attribute.\n-->\n<p>이렇게 만든 <code>HighlightDirective</code>를 적용하려면 <code>AppComponent</code>의 템플릿에 문단(<code>&#x3C;p></code>) 엘리먼트를 추가하고 이 엘리먼트에 어트리뷰트를 다음과 같이 지정합니다.</p>\n<code-example path=\"attribute-directives/src/app/app.component.1.html\" header=\"src/app/app.component.html\" region=\"applied\">\n&#x3C;p appHighlight>Highlight me!&#x3C;/p>\n\n</code-example>\n<!--\nNow run the application to see the `HighlightDirective` in action.\n-->\n<p>그리고 애플리케이션을 실행하면 <code>HighlightDirective</code>가 동작하는 것을 확인할 수 있습니다.</p>\n<code-example language=\"sh\" class=\"code-shell\">\nng serve\n</code-example>\n<!--\nTo summarize, Angular found the `appHighlight` attribute on the **host** `<p>` element.\nIt created an instance of the `HighlightDirective` class and\ninjected a reference to the `<p>` element into the directive's constructor\nwhich sets the `<p>` element's background style to yellow.\n-->\n<p>애플리케이션이 실행되는 과정을 간단하게 설명하면, Angular는 <strong>호스트 엘리먼트</strong>인 <code>&#x3C;p></code> 태그에 <code>appHighlight</code> 어트리뷰트가 지정된 것을 확인하면 이 엘리먼트에 <code>HighlightDirective</code> 클래스의 인스턴스를 생성하는데, 이 때 호스트 엘리먼트 <code>&#x3C;p></code>의 배경색을 변경하기 위해 <code><a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a></code>를 의존성으로 주입합니다.</p>\n<!--\n<a id=\"respond-to-user\"></a>\n-->\n<a id=\"사용자-동작에-반응하기\"></a>\n<!--\n## Respond to user-initiated events\n-->\n<h2 id=\"사용자-동작에-반응하기\">사용자 동작에 반응하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/attribute-directives#사용자-동작에-반응하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nCurrently, `appHighlight` simply sets an element color.\nThe directive could be more dynamic.\nIt could detect when the user mouses into or out of the element\nand respond by setting or clearing the highlight color.\n-->\n<p>지금까지 구현한 디렉티브는 엘리먼트의 배경색을 변경하는 간단한 로직만 작성했지만, 디렉티브의 동작은 좀 더 역동적이어야 합니다.\n이 디렉티브는 사용자가 마우스를 엘리먼트 위에 올리는 것에 반응해서 배경색을 지정하고, 사용자가 마우스를 엘리먼트 밖으로 옮기면 지정된 배경색을 해제해야 하기 때문입니다.</p>\n<!--\nBegin by adding `HostListener` to the list of imported symbols.\n-->\n<p>이 동작을 구현하기 위해 <code><a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a></code> 심볼을 로드합니다.</p>\n<code-example path=\"attribute-directives/src/app/highlight.directive.2.ts\" linenums=\"false\" header=\"src/app/highlight.directive.ts (imports)\" region=\"imports\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, <a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a> } from '@angular/core';\n\n</code-example>\n<!--\nThen add two eventhandlers that respond when the mouse enters or leaves,\neach adorned by the `HostListener` decorator.\n-->\n<p>그리고 이렇게 불러온 <code><a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a></code> 데코레이터를 사용해서 마우스가 들어오고 나가는 두 이벤트 핸들러를 추가합니다.</p>\n<code-example path=\"attribute-directives/src/app/highlight.directive.2.ts\" linenums=\"false\" header=\"src/app/highlight.directive.ts (mouse-methods)\" region=\"mouse-methods\">\n@<a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>('mouseenter') onMouseEnter() {\n  this.highlight('yellow');\n}\n\n@<a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>('mouseleave') onMouseLeave() {\n  this.highlight(null);\n}\n\nprivate highlight(color: string) {\n  this.el.nativeElement.style.backgroundColor = color;\n}\n\n</code-example>\n<!--\nThe `@HostListener` decorator lets you subscribe to events of the DOM\nelement that hosts an attribute directive, the `<p>` in this case.\n-->\n<p><code>@<a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a></code> 데코레이터를 사용하면 DOM 엘리먼트에서 발생하는 이벤트를 구독할 수 있습니다. 이 예제 코드의 경우에는 <code>&#x3C;p></code> 엘리먼트가 해당됩니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nOf course you could reach into the DOM with standard JavaScript and attach event listeners manually.\nThere are at least three problems with _that_ approach:\n-->\n<p>표준 JavaScript를 사용해도 DOM 엘리먼트에 접근할 수 있고, 이벤트 리스너를 수동으로 적용할 수도 있습니다.\n하지만 이 방식은 몇가지 문제가 있습니다:</p>\n<!--\n1. You have to write the listeners correctly.\n1. The code must *detach* the listener when the directive is destroyed to avoid memory leaks.\n1. Talking to DOM API directly isn't a best practice.\n-->\n<ol>\n<li>이벤트 리스너 코드가 잘못 구현되면 동작하지 않습니다.</li>\n<li>디렉티브가 종료되면 메모리 누수를 방지하기 위해 이벤트 리스너도 반드시 <em>제거되어야</em> 합니다.</li>\n<li>Angular를 사용하면서 DOM API를 직접 활용하는 것은 권장하지 않습니다.</li>\n</ol>\n</div>\n<!--\nThe handlers delegate to a helper method that sets the color on the host DOM element, `el`.\n-->\n<p>호스트 DOM 엘리먼트는 <code>el</code>이라는 이름으로 참조하고 <code>highlight</code> 메소드가 이 엘리먼트를 조작하도록 구현하겠습니다.</p>\n<!--\nThe helper method, `highlight`, was extracted from the constructor.\nThe revised constructor simply declares the injected `el: ElementRef`.\n-->\n<p>이전에 생성자에서 구현했던 로직을 <code>highlight</code> 메소드로 옮겼습니다.\n이제 생성자에는 <code>el: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a></code>를 주입하기 위한 코드만 남아 있습니다.</p>\n<code-example path=\"attribute-directives/src/app/highlight.directive.2.ts\" linenums=\"false\" header=\"src/app/highlight.directive.ts (constructor)\" region=\"ctor\">\nconstructor(private el: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>) { }\n\n</code-example>\n<!--\nHere's the updated directive in full:\n-->\n<p>이렇게 수정한 디렉티브는 다음과 같습니다:</p>\n<code-example path=\"attribute-directives/src/app/highlight.directive.2.ts\" header=\"src/app/highlight.directive.ts\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, <a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a> } from '@angular/core';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: '[appHighlight]'\n})\nexport class HighlightDirective {\n  constructor(private el: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>) { }\n\n  @<a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>('mouseenter') onMouseEnter() {\n    this.highlight('yellow');\n  }\n\n  @<a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>('mouseleave') onMouseLeave() {\n    this.highlight(null);\n  }\n\n  private highlight(color: string) {\n    this.el.nativeElement.style.backgroundColor = color;\n  }\n}\n\n</code-example>\n<!--\nRun the app and confirm that the background color appears when\nthe mouse hovers over the `p` and disappears as it moves out.\n-->\n<p>이제 애플리케이션을 실행한 후에 마우스가 <code>&#x3C;p></code> 엘리먼트 위에 올라가면 배경색이 지정되고, 마우스를 밖으로 옮기면 배경색이 해제되는지 확인해 보세요.</p>\n<figure>\n  <img src=\"generated/images/guide/attribute-directives/highlight-directive-anim.gif\" alt=\"Second Highlight\" width=\"204\" height=\"72\">\n</figure>\n<!--\n<a id=\"bindings\"></a>\n-->\n<a id=\"바인딩\"></a>\n<!--\n## Pass values into the directive with an _@Input_ data binding\n-->\n<h2 id=\"디렉티브에-데이터-전달하기--input-바인딩\">디렉티브에 데이터 전달하기 : <em>@Input</em> 바인딩<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/attribute-directives#디렉티브에-데이터-전달하기--input-바인딩\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nCurrently the highlight color is hard-coded _within_ the directive. That's inflexible.\nIn this section, you give the developer the power to set the highlight color while applying the directive.\n-->\n<p>지금까지 작성한 코드는 배경색을 디렉티브 <em>안에</em> 하드코딩 했습니다. 그래서 이 값은 고정되어 있습니다.\n이번 예제에서는 이 배경색을 디렉티브 밖에서 지정하고 디렉티브에 어떻게 반영할 수 있는지 알아봅니다.</p>\n<!--\nBegin by adding `Input` to the list of symbols imported from `@angular/core`.\n-->\n<p>먼저, <code>@angular/core</code> 라이브러리에서 <code><a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 심볼을 불러옵니다.\n<code-example path=\"attribute-directives/src/app/highlight.directive.3.ts\" linenums=\"false\" header=\"src/app/highlight.directive.ts (imports)\" region=\"imports\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, <a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a> } from '@angular/core';\n\n</code-example></p>\n<!--\nAdd a `highlightColor` property to the directive class like this:\n-->\n<p>그리고 디렉티브 클래스에 <code>highlightColor</code> 프로퍼티를 다음과 같이 추가합니다:</p>\n<code-example path=\"attribute-directives/src/app/highlight.directive.2.ts\" linenums=\"false\" header=\"src/app/highlight.directive.ts (highlightColor)\" region=\"color\">\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() highlightColor: string;\n\n</code-example>\n<!--\n<a id=\"input\"></a>\n-->\n<a id=\"입력-프로퍼티\"></a>\n<!--\n### Binding to an _@Input_ property\n-->\n<h3 id=\"input-프로퍼티-바인딩\"><em>@Input</em> 프로퍼티 바인딩<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/attribute-directives#input-프로퍼티-바인딩\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nNotice the `@Input` decorator. It adds metadata to the class that makes the directive's `highlightColor` property available for binding.\n-->\n<p><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 데코레이터를 확인해 보세요. 이 데코레이터는 컴포넌트 클래스에 선언된 <code>highlightColor</code> 프로퍼티로 데이터를 입력받을 수 있도록 합니다.</p>\n<!--\nIt's called an *input* property because data flows from the binding expression _into_ the directive.\nWithout that input metadata, Angular rejects the binding; see [below](guide/attribute-directives#why-input \"Why add @Input?\") for more about that.\n-->\n<p>그래서 디렉티브 <em>밖에서</em> 데이터를 받아 오는 프로퍼티를 <em>입력</em> 프로퍼티라고 합니다.\n이 데코레이터가 없으면 바인딩이 연결되지 않으며, 더 자세한 내용은 <a href=\"guide/attribute-directives#%EC%99%9C-input\" title=\"왜 @input을 사용할까?\">아래 내용</a>을 참고하세요.</p>\n<!--\nTry it by adding the following directive binding variations to the `AppComponent` template:\n-->\n<p><code>AppComponent</code> 템플릿은 이 디렉티브를 적용딩하기 위해 다음과 같이 작성합니다:</p>\n<code-example path=\"attribute-directives/src/app/app.component.1.html\" linenums=\"false\" header=\"src/app/app.component.html (excerpt)\" region=\"color-1\">\n&#x3C;p appHighlight highlightColor=\"yellow\">Highlighted in yellow&#x3C;/p>\n&#x3C;p appHighlight [highlightColor]=\"'orange'\">Highlighted in orange&#x3C;/p>\n\n</code-example>\n<!--\nAdd a `color` property to the `AppComponent`.\n-->\n<p>그리고 <code>AppComponent</code>에 <code>color</code> 프로퍼티를 추가합니다.</p>\n<code-example path=\"attribute-directives/src/app/app.component.1.ts\" linenums=\"false\" header=\"src/app/app.component.ts (class)\" region=\"class\">\nexport class AppComponent {\n  color = 'yellow';\n}\n\n\n</code-example>\n<!--\nLet it control the highlight color with a property binding.\n-->\n<p>그러면 디렉티브에 적용되는 배경색을 프로퍼티 바인딩으로 연결할 수 있습니다.</p>\n<code-example path=\"attribute-directives/src/app/app.component.1.html\" linenums=\"false\" header=\"src/app/app.component.html (excerpt)\" region=\"color-2\">\n&#x3C;p appHighlight [highlightColor]=\"color\">Highlighted with parent component's color&#x3C;/p>\n\n</code-example>\n<!--\nThat's good, but it would be nice to _simultaneously_ apply the directive and set the color _in the same attribute_ like this.\n-->\n<p>이렇게만 작성해도 동작은 되지만, 어트리뷰트 디렉티브를 적용하면서 <em>이 디렉티브 이름으로</em> 배경색도 <em>함께</em> 지정하는 것이 더 좋습니다.</p>\n<code-example path=\"attribute-directives/src/app/app.component.html\" linenums=\"false\" header=\"src/app/app.component.html (color)\" region=\"color\">\n&#x3C;p [appHighlight]=\"color\">Highlight me!&#x3C;/p>\n\n</code-example>\n<!--\nThe `[appHighlight]` attribute binding both applies the highlighting directive to the `<p>` element\nand sets the directive's highlight color with a property binding.\nYou're re-using the directive's attribute selector (`[appHighlight]`) to do both jobs.\nThat's a crisp, compact syntax.\n-->\n<p><code>[appHighlight]</code> 처럼 어트리뷰트 바인딩하면 배경색을 지정하는 디렉티브를 <code>&#x3C;p></code> 엘리먼트에 적용하면서 이 디렉티브에 적용될 배경색도 함께 프로퍼티 바인딩합니다.\n번거롭게 디렉티브와 입력 프로퍼티를 따로 지정할 필요가 없습니다.</p>\n<!--\nYou'll have to rename the directive's `highlightColor` property to `appHighlight` because that's now the color property binding name.\n-->\n<p>이렇게 사용하려면 바인딩하는 프로퍼티 이름이 바뀌기 때문에 디렉티브에 선언된 <code>highlightColor</code> 프로퍼티를 <code>appHighlight</code>로 바꿔줘야 합니다.</p>\n<code-example path=\"attribute-directives/src/app/highlight.directive.2.ts\" linenums=\"false\" header=\"src/app/highlight.directive.ts (renamed to match directive selector)\" region=\"color-2\">\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() appHighlight: string;\n\n</code-example>\n<!--\nThis is disagreeable. The word, `appHighlight`, is a terrible property name and it doesn't convey the property's intent.\n-->\n<p>하지만 <code>appHighlight</code>라는 이름으로 프로퍼티를 선언하는 것은 별로 좋은 방법이 아닙니다. 좀 더 좋은 방법을 찾아봅시다.</p>\n<!--\n<a id=\"input-alias\"></a>\n-->\n<a id=\"입력-별칭\"></a>\n<!--\n### Bind to an _@Input_ alias\n-->\n<h3 id=\"input-에-별칭-사용하기\"><em>@Input</em> 에 별칭 사용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/attribute-directives#input-에-별칭-사용하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nFortunately you can name the directive property whatever you want _and_ **_alias it_** for binding purposes.\n-->\n<p>다행히도, 입력 프로퍼티 이름은 그대로 두고 이 프로퍼티에 <strong><em>별칭</em></strong>을 지정할 수 있습니다.</p>\n<!--\nRestore the original property name and specify the selector as the alias in the argument to `@Input`.\n-->\n<p>이 별칭은 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 데코레이터 안에 문자열로 지정합니다.</p>\n<code-example path=\"attribute-directives/src/app/highlight.directive.ts\" linenums=\"false\" header=\"src/app/highlight.directive.ts (color property with alias)\" region=\"color\">\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('appHighlight') highlightColor: string;\n\n</code-example>\n<!--\n_Inside_ the directive the property is known as `highlightColor`.\n_Outside_ the directive, where you bind to it, it's known as `appHighlight`.\n-->\n<p>이렇게 작성하면 디렉티브 <em>안에서는</em> <code>highlightColor</code> 프로퍼티를 사용합니다.\n그리고 디렉티브 <em>밖에서는</em> <code>appHighlight</code> 프로퍼티로 입력 프로퍼티를 바인딩할 수 있습니다.</p>\n<!--\nYou get the best of both worlds: the property name you want and the binding syntax you want:\n-->\n<p>디렉티브 안과 밖, 각 상황에 어울리는 프로퍼티 이름을 사용해 보세요:</p>\n<code-example path=\"attribute-directives/src/app/app.component.html\" linenums=\"false\" header=\"src/app/app.component.html (color)\" region=\"color\">\n&#x3C;p [appHighlight]=\"color\">Highlight me!&#x3C;/p>\n\n</code-example>\n<!--\nNow that you're binding via the alias to the `highlightColor`, modify the `onMouseEnter()` method to use that property.\nIf someone neglects to bind to `appHighlightColor`, highlight the host element in red:\n-->\n<p>이제 디렉티브 안에서는 <code>highlightColor</code> 프로퍼티를 사용하기 때문에 <code>onMouseEvent()</code> 메소드가 이 프로퍼티를 사용하도록 수정합니다.\n<code>appHighlightColor</code>에 바인딩 하는 값이 없으면 빨간색을 기본값으로 지정하도록 작성했습니다:</p>\n<code-example path=\"attribute-directives/src/app/highlight.directive.3.ts\" linenums=\"false\" header=\"src/app/highlight.directive.ts (mouse enter)\" region=\"mouse-enter\">\n@<a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>('mouseenter') onMouseEnter() {\n  this.highlight(this.highlightColor || 'red');\n}\n\n</code-example>\n<!--\nHere's the latest version of the directive class.\n-->\n<p>이렇게 만든 디렉티브 클래스의 최종 코드는 다음과 같습니다.</p>\n<code-example path=\"attribute-directives/src/app/highlight.directive.3.ts\" linenums=\"false\" header=\"src/app/highlight.directive.ts (excerpt)\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, <a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a> } from '@angular/core';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: '[appHighlight]'\n})\nexport class HighlightDirective {\n\n  constructor(private el: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>) { }\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('appHighlight') highlightColor: string;\n\n  @<a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>('mouseenter') onMouseEnter() {\n    this.highlight(this.highlightColor || 'red');\n  }\n\n  @<a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>('mouseleave') onMouseLeave() {\n    this.highlight(null);\n  }\n\n  private highlight(color: string) {\n    this.el.nativeElement.style.backgroundColor = color;\n  }\n}\n\n\n</code-example>\n<!--\n## Write a harness to try it\n-->\n<h2 id=\"input-바인딩-응용하기\"><em>@Input</em> 바인딩 응용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/attribute-directives#input-바인딩-응용하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nIt may be difficult to imagine how this directive actually works.\nIn this section, you'll turn `AppComponent` into a harness that\nlets you pick the highlight color with a radio button and bind your color choice to the directive.\n-->\n<p>디렉티브가 어떻게 동작하는지 설명만으로는 이해하기 어려울 수 있습니다.\n그래서 이번 문서에서는 <code>AppComponent</code>에서 라디오 버튼으로 배경을 선택하고, 이렇게 선택한 색상을 디렉티브에 받아 배경색으로 지정하도록 구현해 봅시다.</p>\n<!--\nUpdate <code>app.component.html</code> as follows:\n-->\n<p><code>app.component.html</code> 파일을 다음과 같이 수정합니다:</p>\n<code-example path=\"attribute-directives/src/app/app.component.html\" linenums=\"false\" header=\"src/app/app.component.html (v2)\" region=\"v2\">\n&#x3C;h1>My <a href=\"\" class=\"code-anchor\">First</a> <a href=\"api/core/Attribute\" class=\"code-anchor\">Attribute</a> <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>&#x3C;/h1>\n\n&#x3C;h4>Pick <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> highlight color&#x3C;/h4>\n&#x3C;div>\n  &#x3C;input type=\"radio\" name=\"colors\" (click)=\"color='lightgreen'\">Green\n  &#x3C;input type=\"radio\" name=\"colors\" (click)=\"color='yellow'\">Yellow\n  &#x3C;input type=\"radio\" name=\"colors\" (click)=\"color='cyan'\">Cyan\n&#x3C;/div>\n&#x3C;p [appHighlight]=\"color\">Highlight me!&#x3C;/p>\n\n</code-example>\n<!--\nRevise the `AppComponent.color` so that it has no initial value.\n-->\n<p>그리고 초기값 할당 없이 <code>AppComponent.color</code> 프로퍼티를 선언합니다.</p>\n<code-example path=\"attribute-directives/src/app/app.component.ts\" linenums=\"false\" header=\"src/app/app.component.ts (class)\" region=\"class\">\nexport class AppComponent {\n  color: string;\n}\n\n\n</code-example>\n<!--\nHere are the harness and directive in action.\n-->\n<p>이렇게 구현하면 애플리케이션은 다음과 같이 동작합니다.</p>\n<figure>\n  <img src=\"generated/images/guide/attribute-directives/highlight-directive-v2-anim.gif\" alt=\"Highlight v.2\" width=\"432\" height=\"172\">\n</figure>\n<!--\n<a id=\"second-property\"></a>\n-->\n<a id=\"입력-프로퍼티-추가하기\"></a>\n<!--\n## Bind to a second property\n-->\n<h2 id=\"입력-프로퍼티-추가하기\">입력 프로퍼티 추가하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/attribute-directives#입력-프로퍼티-추가하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThis highlight directive has a single customizable property. In a real app, it may need more.\n-->\n<p>지금까지 만든 하이라이트 디렉티브에는 프로퍼티가 하나 있습니다. 하지만 애플리케이션을 실제로 개발하다보면 여러 입력 프로퍼티가 활용하는 경우가 더 많습니다.</p>\n<!--\nAt the moment, the default color&mdash;the color that prevails until\nthe user picks a highlight color&mdash;is hard-coded as \"red\".\nLet the template developer set the default color.\n-->\n<p>사용자가 하이라이트 색상을 정하기 전에는 빨간색을 기본 배경으로 사용하도록 하드코딩 해봅시다.\n그리고 이 기본 배경색도 템플릿에서 지정할 수 있도록 만들어 봅시다.</p>\n<!--\nAdd a second **input** property to `HighlightDirective` called `defaultColor`:\n-->\n<p><code>HighlightDirective</code>에 <code>defaultColor</code> 프로퍼티를 <strong>입력</strong> 프로퍼티로 추가합니다:</p>\n<code-example path=\"attribute-directives/src/app/highlight.directive.ts\" linenums=\"false\" header=\"src/app/highlight.directive.ts (defaultColor)\" region=\"defaultColor\">\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() defaultColor: string;\n\n</code-example>\n<!--\nRevise the directive's `onMouseEnter` so that it first tries to highlight with the `highlightColor`,\nthen with the `defaultColor`, and falls back to \"red\" if both properties are undefined.\n-->\n<p>그리고 디렉티브에 선언한 <code>onMouseEnter()</code> 메소드를 수정하는데, <code>highlightColor</code> 프로퍼티에 색상이 지정되면 이 값을 사용하고, 아니라면 <code>defaultColor</code> 프로퍼티를 사용하도록 합니다. 두 프로퍼티 모두 지정되지 않으면 빨간색을 기본값으로 사용하도록 작성합니다.</p>\n<code-example path=\"attribute-directives/src/app/highlight.directive.ts\" linenums=\"false\" header=\"src/app/highlight.directive.ts (mouse-enter)\" region=\"mouse-enter\">\n@<a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>('mouseenter') onMouseEnter() {\n  this.highlight(this.highlightColor || this.defaultColor || 'red');\n}\n\n</code-example>\n<!--\nHow do you bind to a second property when you're already binding to the `appHighlight` attribute name?\n-->\n<p><code>appHighlight</code> 어트리뷰트 이름을 그대로 사용하면서 추가 프로퍼티는 어떻게 바인딩할 수 있을까요?</p>\n<!--\nAs with components, you can add as many directive property bindings as you need by stringing them along in the template.\nThe developer should be able to write the following template HTML to both bind to the `AppComponent.color`\nand fall back to \"violet\" as the default color.\n-->\n<p>컴포넌트와 마찬가지로, 디렉티브도 템플릿에서 원하는 만큼 프로퍼티 바인딩을 연결할 수 있습니다.\n예를 들어 <code>AppComponent.color</code>를 지금까지와 마찬가지로 지정하면서 기본 배경색은 \"violet\"으로 지정하도록 하려면 다음과 같이 작성할 수 있습니다.</p>\n<code-example path=\"attribute-directives/src/app/app.component.html\" linenums=\"false\" header=\"src/app/app.component.html (defaultColor)\" region=\"defaultColor\">\n&#x3C;p [appHighlight]=\"color\" defaultColor=\"violet\">\n  Highlight me too!\n&#x3C;/p>\n\n</code-example>\n<!--\nAngular knows that the `defaultColor` binding belongs to the `HighlightDirective`\nbecause you made it _public_ with the `@Input` decorator.\n-->\n<p>그러면 <code>HighlightDirective</code>는 Angular가 <code>defaultColor</code> 프로퍼티를 찾아서 바인딩 하는데, 이미 이 프로퍼티에 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 데코레이터를 사용하면서 <em>public</em> 으로 지정했기 때문입니다.</p>\n<!--\nHere's how the harness should work when you're done coding.\n-->\n<p>이렇게 작성하면 이제 애플리케이션은 다음 그림과 같이 동작합니다.</p>\n<figure>\n  <img src=\"generated/images/guide/attribute-directives/highlight-directive-final-anim.gif\" alt=\"Final Highlight\" width=\"440\" height=\"212\">\n</figure>\n<!--\n## Summary\n-->\n<h2 id=\"정리\">정리<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/attribute-directives#정리\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThis page covered how to:\n-->\n<p>이 문서에서는 다음과 같은 내용을 다뤘습니다:</p>\n<!--\n* [Build an **attribute directive**](guide/attribute-directives#write-directive) that modifies the behavior of an element.\n* [Apply the directive](guide/attribute-directives#apply-directive) to an element in a template.\n* [Respond to **events**](guide/attribute-directives#respond-to-user) that change the directive's behavior.\n* [**Bind** values to the directive](guide/attribute-directives#bindings).\n-->\n<ul>\n<li>엘리먼트의 동작을 변경하는 <a href=\"guide/attribute-directives#%EB%94%94%EB%A0%89%ED%8B%B0%EB%B8%8C-%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0\"><strong>어트리뷰트 디렉티브</strong></a>를 만들어 봤습니다.</li>\n<li>이렇게 만든 <a href=\"guide/attribute-directives#%EB%94%94%EB%A0%89%ED%8B%B0%EB%B8%8C-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0\">디렉티브</a>를 템플릿에 있는 엘리먼트에 적용해 봤습니다.</li>\n<li>디렉티브의 추가 동작을 구현하기 위해 <a href=\"guide/attribute-directives#%EC%82%AC%EC%9A%A9%EC%9E%90-%EB%8F%99%EC%9E%91%EC%97%90-%EB%B0%98%EC%9D%91%ED%95%98%EA%B8%B0\"><strong>이벤트</strong>에 반응하는 방법</a>을 알아봤습니다.</li>\n<li><a href=\"guide/attribute-directives#%EB%B0%94%EC%9D%B8%EB%94%A9\">디렉티브에 프로퍼티를 <strong>바인딩</strong></a>하는 방법에 대해 알아봤습니다.</li>\n</ul>\n<!--\nThe final source code follows:\n-->\n<p>그리고 이렇게 만든 최종 코드는 다음과 같습니다:</p>\n<code-tabs>\n  <code-pane header=\"app/app.component.ts\" path=\"attribute-directives/src/app/app.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  templateUrl: './app.component.html'\n})\nexport class AppComponent {\n  color: string;\n}\n\n\n</code-pane>\n  <code-pane header=\"app/app.component.html\" path=\"attribute-directives/src/app/app.component.html\">\n&#x3C;h1>My <a href=\"\" class=\"code-anchor\">First</a> <a href=\"api/core/Attribute\" class=\"code-anchor\">Attribute</a> <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>&#x3C;/h1>\n\n&#x3C;h4>Pick <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> highlight color&#x3C;/h4>\n&#x3C;div>\n  &#x3C;input type=\"radio\" name=\"colors\" (click)=\"color='lightgreen'\">Green\n  &#x3C;input type=\"radio\" name=\"colors\" (click)=\"color='yellow'\">Yellow\n  &#x3C;input type=\"radio\" name=\"colors\" (click)=\"color='cyan'\">Cyan\n&#x3C;/div>\n&#x3C;p [appHighlight]=\"color\">Highlight me!&#x3C;/p>\n\n&#x3C;p [appHighlight]=\"color\" defaultColor=\"violet\">\n  Highlight me too!\n&#x3C;/p>\n\n</code-pane>\n  <code-pane header=\"app/highlight.directive.ts\" path=\"attribute-directives/src/app/highlight.directive.ts\">\n/* tslint:disable:member-ordering */\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, <a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a> } from '@angular/core';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: '[appHighlight]'\n})\nexport class HighlightDirective {\n\n  constructor(private el: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>) { }\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() defaultColor: string;\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('appHighlight') highlightColor: string;\n\n  @<a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>('mouseenter') onMouseEnter() {\n    this.highlight(this.highlightColor || this.defaultColor || 'red');\n  }\n\n  @<a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>('mouseleave') onMouseLeave() {\n    this.highlight(null);\n  }\n\n  private highlight(color: string) {\n    this.el.nativeElement.style.backgroundColor = color;\n  }\n}\n\n\n</code-pane>\n  <code-pane header=\"app/app.module.ts\" path=\"attribute-directives/src/app/app.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\n\nimport { AppComponent } from './app.component';\nimport { HighlightDirective } from './highlight.directive';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [ <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> ],\n  declarations: [\n    AppComponent,\n    HighlightDirective\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n\n</code-pane>\n  <code-pane header=\"main.ts\" path=\"attribute-directives/src/main.ts\">\nimport { <a href=\"api/core/enableProdMode\" class=\"code-anchor\">enableProdMode</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a> } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  <a href=\"api/core/enableProdMode\" class=\"code-anchor\">enableProdMode</a>();\n}\n\n<a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>().bootstrapModule(AppModule);\n\n\n</code-pane>\n  <code-pane header=\"index.html\" path=\"attribute-directives/src/index.html\">\n&#x3C;!DOCTYPE html>\n&#x3C;html lang=\"en\">\n  &#x3C;head>\n    &#x3C;meta charset=\"UTF-8\">\n    &#x3C;title><a href=\"api/core/Attribute\" class=\"code-anchor\">Attribute</a> Directives&#x3C;/title>\n    &#x3C;base href=\"/\">\n    &#x3C;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  &#x3C;/head>\n  &#x3C;body>\n    &#x3C;app-root>&#x3C;/app-root>\n  &#x3C;/body>\n&#x3C;/html>\n\n\n</code-pane>\n</code-tabs>\n<!--\nYou can also experience and download the <live-example title=\"Attribute Directive example\"></live-example>.\n-->\n<p>이 코드는 <live-example title=\"Attribute Directive example\"></live-example>에서 직접 실행해보거나 다운받아서 확인할 수도 있습니다.</p>\n<!--\n<a id=\"why-input\"></a>\n-->\n<a id=\"왜-input\"></a>\n<!--\n### Appendix: Why add _@Input_?\n-->\n<h3 id=\"부록-왜-input-가-필요할까\">부록: 왜 <em>@Input</em> 가 필요할까?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/attribute-directives#부록-왜-input-가-필요할까\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn this demo, the `highlightColor` property is an ***input*** property of\nthe `HighlightDirective`. You've seen it applied without an alias:\n-->\n<p>이번 예제에서 <code>highlightColor</code> 프로퍼티는 <code>HighlightDirective</code>의 <strong><em>입력</em></strong> 프로퍼티입니다.\n입력 프로퍼티에 별칭을 지정하지 않는 경우라몀ㄴ 다음과 같이 사용했습니다:</p>\n<code-example path=\"attribute-directives/src/app/highlight.directive.2.ts\" linenums=\"false\" header=\"src/app/highlight.directive.ts (color)\" region=\"color\">\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() highlightColor: string;\n\n</code-example>\n<!--\nYou've seen it with an alias:\n-->\n<p>그리고 별칭을 지정하는 경우는 다음과 같이 사용했습니다:</p>\n<code-example path=\"attribute-directives/src/app/highlight.directive.ts\" linenums=\"false\" header=\"src/app/highlight.directive.ts (color)\" region=\"color\">\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('appHighlight') highlightColor: string;\n\n</code-example>\n<!--\nEither way, the `@Input` decorator tells Angular that this property is\n_public_ and available for binding by a parent component.\nWithout  `@Input`, Angular refuses to bind to the property.\n-->\n<p><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 데코레이터를 사용하면 Angular는 이 프로퍼티를 <em>public</em> 으로 지정하면서 부모 컴포넌트와 바인딩할 준비를 합니다.\n그래서 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 데코레이터가 없으면 프로퍼티 바인딩 자체가 성립하지 않습니다.</p>\n<!--\nYou've bound template HTML to component properties before and never used `@Input`.\nWhat's different?\n-->\n<p>그런데 컴포넌트의 템플릿 HTML에서 해당 컴포넌트의 프로퍼티를 바인딩 할 때는 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 데코레이터를 사용하지 않았습니다.\n어떤 점이 다를까요?</p>\n<!--\nThe difference is a matter of trust.\nAngular treats a component's template as _belonging_ to the component.\nThe component and its template trust each other implicitly.\nTherefore, the component's own template may bind to _any_ property of that component,\nwith or without the `@Input` decorator.\n-->\n<p>이것은 Angular가 컴포넌트를 어떻게 취급하는지의 문제입니다.\nAngular는 컴포넌트 템플릿을 컴포넌트에 <em>속하는</em> 것으로 취급합니다.\n그래서 컴포넌트와 템플릿은 각각 존재하지만 서로를 보장합니다.\n그래서 컴포넌트의 템플릿에서는 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 데코레이터를 사용하는 지 여부에 관계없이 컴포넌트의 프로퍼티를 <em>자유롭게</em> 바인딩 할 수 있습니다.</p>\n<!--\nBut a component or directive shouldn't blindly trust _other_ components and directives.\nThe properties of a component or directive are hidden from binding by default.\nThey are _private_ from an Angular binding perspective.\nWhen adorned with the `@Input` decorator, the property becomes _public_ from an Angular binding perspective.\nOnly then can it be bound by some other component or directive.\n-->\n<p>하지만 <em>다른</em> 컴포넌트나 디렉티브라면 문제가 다릅니다.\n컴포넌트의 프로퍼티나 디렉티브는 기본적으로 감춰져 있으며, Angular가 바인딩하는 관점에서도 이 프로퍼티는 <em>private</em> 으로 취급됩니다.\n그래서 프로퍼티를 바인딩하려면 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 데코레이터를 붙여서 <em>public</em> 으로 만들어야 합니다.\n다른 컴포넌트와 디렉티브와 프로퍼티 바인딩하려면 이 데코레이터를 꼭 사용해야 합니다.</p>\n<!--\nYou can tell if `@Input` is needed by the position of the property name in a binding.\n-->\n<p>어떤 경우에 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 데코레이터가 꼭 사용되어야 하는 경우가 알아봅시다.</p>\n<!--\n* When it appears in the template expression to the ***right*** of the equals (=),\n  it belongs to the template's component and does not require the `@Input` decorator.\n-->\n<ul>\n<li>템플릿에서 등호(<code>=</code>) <strong><em>오른쪽</em></strong>에 템플릿 표현식이 있으면 이 평가식에 연결되는 프로퍼티는 해당 컴포넌트 안에 있으며 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 데코레이터가 필요하지 않습니다.</li>\n</ul>\n<!--\n* When it appears in **square brackets** ([ ]) to the **left** of the equals (=),\n  the property belongs to some _other_ component or directive;\n  that property must be adorned with the `@Input` decorator.\n-->\n<ul>\n<li>템플릿에서 등호(<code>=</code>) 왼쪽에 <strong>대괄호(<code>[</code>, <code>]</code>)</strong>가 있으면 이 대괄호 안에 있는 프로퍼티는 <em>다른</em> 컴포넌트나 디렉티브에 선언된 프로퍼티입니다. 이 프로퍼티에는 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 데코레이터가 꼭 지정되어야 합니다.</li>\n</ul>\n<!--\nNow apply that reasoning to the following example:\n-->\n<p>예제를 보면서 이 내용을 확인해 봅시다:</p>\n<code-example path=\"attribute-directives/src/app/app.component.html\" linenums=\"false\" header=\"src/app/app.component.html (color)\" region=\"color\">\n&#x3C;p [appHighlight]=\"color\">Highlight me!&#x3C;/p>\n\n</code-example>\n<!--\n* The `color` property in the expression on the right belongs to the template's component.\n  The template and its component trust each other.\n  The `color` property doesn't require the `@Input` decorator.\n-->\n<ul>\n<li>표현식에서 등호 오른쪽에 사용된 <code>color</code> 프로퍼티는 이 컴포넌트에 있는 프로퍼티입니다. 템플릿과 컴포넌트는 서로를 보장하기 때문에 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 데코레이터가 필요하지 않습니다.</li>\n</ul>\n<!--\n* The `appHighlight` property on the left refers to an _aliased_ property of the `HighlightDirective`,\n  not a property of the template's component. There are trust issues.\n  Therefore, the directive property must carry the `@Input` decorator.\n-->\n<ul>\n<li>등호 왼쪽에 사용된 <code>appHighlight</code> 프로퍼티는 <code>HighlightDirective</code>에 <em>별칭으로 지정된</em> 프로퍼티를 가리키며, 이 템플릿의 컴포넌트 클래스에 있는 프로퍼티는 아닙니다. 그래서 이 프로퍼티를 바인딩하려면 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 데코레이터를 꼭 사용해야 합니다.</li>\n</ul>\n\n</div>\n\n<!-- links to this doc:\n - guide/architecture-components\n - guide/bootstrapping\n - guide/dependency-injection-in-action\n - guide/glossary\n - guide/structural-directives\n - guide/template-syntax\n-->\n<!-- links from this doc:\n - api/core/Attribute\n - api/core/Component\n - api/core/Directive\n - api/core/ElementRef\n - api/core/HostListener\n - api/core/Input\n - api/core/NgModule\n - api/core/enableProdMode\n - api/platform-browser-dynamic/platformBrowserDynamic\n - api/platform-browser/BrowserModule\n - api/router/RouterLinkWithHref\n - cli/generate\n - guide/attribute-directives#%EB%94%94%EB%A0%89%ED%8B%B0%EB%B8%8C-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0\n - guide/attribute-directives#%EB%94%94%EB%A0%89%ED%8B%B0%EB%B8%8C-%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0\n - guide/attribute-directives#%EB%B0%94%EC%9D%B8%EB%94%A9\n - guide/attribute-directives#%EC%82%AC%EC%9A%A9%EC%9E%90-%EB%8F%99%EC%9E%91%EC%97%90-%EB%B0%98%EC%9D%91%ED%95%98%EA%B8%B0\n - guide/attribute-directives#%EC%99%9C-input\n - guide/attribute-directives#highlight를-사용하면-왜-안될까\n - guide/attribute-directives#input-바인딩-응용하기\n - guide/attribute-directives#input-에-별칭-사용하기\n - guide/attribute-directives#input-프로퍼티-바인딩\n - guide/attribute-directives#간단한-어트리뷰트-디렉티브-만들어보기\n - guide/attribute-directives#디렉티브-개요\n - guide/attribute-directives#디렉티브-코드-작성하기\n - guide/attribute-directives#디렉티브에-데이터-전달하기--input-바인딩\n - guide/attribute-directives#부록-왜-input-가-필요할까\n - guide/attribute-directives#사용자-동작에-반응하기\n - guide/attribute-directives#어트리뷰트-디렉티브\n - guide/attribute-directives#어트리뷰트-디렉티브-적용하기\n - guide/attribute-directives#입력-프로퍼티-추가하기\n - guide/attribute-directives#정리\n - guide/dependency-injection\n - guide/ngmodules\n - guide/structural-directives\n - guide/template-syntax\n - guide/template-syntax#ngFor\n - guide/template-syntax#ngIf\n - guide/template-syntax#ngStyle\n - start\n - https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors\n - https://github.com/angular/angular/edit/master/aio/content/guide/attribute-directives.md?message=docs%3A%20describe%20your%20change...\n-->"
}