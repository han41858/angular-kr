{
  "id": "guide/upgrade",
  "title": "AngularJS 앱을 Angular 앱으로 업그레이드하기",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/upgrade.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Upgrading from AngularJS to Angular\n-->\n<h1 id=\"angularjs-앱을-angular-앱으로-업그레이드하기\">AngularJS 앱을 Angular 앱으로 업그레이드하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#angularjs-앱을-angular-앱으로-업그레이드하기\"><i class=\"material-icons\">link</i></a></h1>\n<!--\n_Angular_ is the name for the Angular of today and tomorrow.<br />\n_AngularJS_ is the name for all 1.x versions of Angular.\n\nAngularJS apps are great.\nAlways consider the business case before moving to Angular.\nAn important part of that case is the time and effort to get there.\nThis guide describes the built-in tools for efficiently migrating AngularJS projects over to the\nAngular platform, a piece at a time.\n\nSome applications will be easier to upgrade than others, and there are\nmany ways to make it easier for yourself. It is possible to\nprepare and align AngularJS applications with Angular even before beginning\nthe upgrade process. These preparation steps are all about making the code\nmore decoupled, more maintainable, and better aligned with modern development\ntools. That means in addition to making the upgrade easier,\nyou will also improve the existing AngularJS applications.\n\nOne of the keys to a successful upgrade is to do it incrementally,\nby running the two frameworks side by side in the same application, and\nporting AngularJS components to Angular one by one. This makes it possible\nto upgrade even large and complex applications without disrupting other\nbusiness, because the work can be done collaboratively and spread over\na period of time. The `upgrade` module in Angular has been designed to\nmake incremental upgrading seamless.\n-->\n<p><em>Angular</em> 는 지금부터 Angular를 부를때 사용하는 이름입니다.<br>\n그리고 <em>AngularJS</em> 는 1.x 버전대의 Angular를 부를때 사용하는 이름입니다.</p>\n<p>AngularJS 앱도 훌륭합니다.\nAngularJS 앱을 Angular로 꼭 전환하는 것이 좋을지 충분히 검토해 보세요.\n전환하는 데에 들어가는 시간과 노력을 생각해 보는 것이 가장 중요합니다.\n이 문서에서는 Angular가 제공하는 툴을 사용해서 AngularJS 프로젝트를 Angular 프로젝트를 단계적으로 적용하는 방법에 대해 설명합니다.</p>\n<p>AngularJS 애플리케이션이 그 자체로 간결하고 최신 개발 툴을 적용하면서 유지보수하기 편하게 관리되고 있었다면 아닌 경우와 비교했을 때 Angular로 전환하는 작업이 더 수월합니다.\n따라서 AngularJS 앱을 Angular로 전환하기 전에 AngularJS 앱 자체를 잘 관리하는 것도 중요합니다.</p>\n<p>업그레이드를 할 때 가장 권장하는 방법은 한 애플리케이션에 AngularJS와 Angular를 모두 띄워두고 AngualrJS 컴포넌트를 Angular 컴포넌트로 하나씩 바꿔가면서 점진적으로 전환하는 것입니다.\n이렇게하면 아무리 크고 복잡한 애플리케이션이라도 시간만 충분히 들이면 비즈니스 로직이 틀어지는 일 없이 애플리케이션을 재구성할 수 있습니다.\n이렇게 점진적으로 업그레이드하는 작업을 위해 Angular는 <code>upgrade</code> 모듈을 제공합니다.</p>\n<a id=\"preparation\"></a>\n<!--\n## Preparation\n-->\n<h2 id=\"사전준비\">사전준비<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#사전준비\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThere are many ways to structure AngularJS applications. When you begin\nto upgrade these applications to Angular, some will turn out to be\nmuch more easy to work with than others. There are a few key techniques\nand patterns that you can apply to future proof apps even before you\nbegin the migration.\n-->\n<p>AngularJS 애플리케이션을 구성하는 방식은 다양하지만 이 중에서 Angular로 전환하기 쉬운 구조도 있습니다.\n이 섹션에서는 앱을 마이그레이션하기 전에 알아두면 좋을 테크닉을 소개합니다.</p>\n<a id=\"follow-the-angular-styleguide\"></a>\n<!--\n### Follow the AngularJS Style Guide\n-->\n<h3 id=\"angularjs-스타일-가이드를-따르세요\">AngularJS 스타일 가이드를 따르세요.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#angularjs-스타일-가이드를-따르세요\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe [AngularJS Style Guide](https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md)\ncollects patterns and practices that have been proven to result in\ncleaner and more maintainable AngularJS applications. It contains a wealth\nof information about how to write and organize AngularJS code - and equally\nimportantly - how **not** to write and organize AngularJS code.\n\nAngular is a reimagined version of the best parts of AngularJS. In that\nsense, its goals are the same as the AngularJS Style Guide's: To preserve\nthe good parts of AngularJS, and to avoid the bad parts. There's a lot\nmore to Angular than just that of course, but this does mean that\n*following the style guide helps make your AngularJS app more closely\naligned with Angular*.\n\nThere are a few rules in particular that will make it much easier to do\n*an incremental upgrade* using the Angular `upgrade/static` module:\n\n* The [Rule of 1](https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility)\n  states that there should be one component per file. This not only makes\n  components easy to navigate and find, but will also allow us to migrate\n  them between languages and frameworks one at a time. In this example application,\n  each controller, component, service, and filter is in its own source file.\n\n* The [Folders-by-Feature Structure](https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#folders-by-feature-structure)\n  and [Modularity](https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity)\n  rules define similar principles on a higher level of abstraction: Different parts of the\n  application should reside in different directories and NgModules.\n\nWhen an application is laid out feature per feature in this way, it can also be\nmigrated one feature at a time. For applications that don't already look like\nthis, applying the rules in the AngularJS style guide is a highly recommended\npreparation step. And this is not just for the sake of the upgrade - it is just\nsolid advice in general!\n-->\n<p><a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md\">AngularJS 스타일 가이드</a> 문서는 AngularJS 애플리케이션을 깔끔하고 유지보수하기 쉽게 구현하기 위해 사용되는 패턴과 예제들을 다루고 있습니다.\nAngularJS 코드를 어떻게 작성하고 관리해야 하는지, 어떤 방식으로는 작성하면 <strong>안되는지</strong> 에 대해 방대하게 안내하는 문서입니다.</p>\n<p>Angular는 이 중에서도 가장 효율적인 내용을 모아서 새롭게 설계되었습니다.\n그래서 AngularJS 스타일 가이드에서 안내한 대로 최대한 좋은 방식으로 구현하면서 안좋은 방식은 최소화하는 방향도 그대로입니다.\n물론 Angular는 여기에서 더 많은 것을 제공하지만 결국 <em>Angular 스타일 가이드를 충실하게 따르는 것이 Angular 앱을 구현하는 방향과 같다는 것은 마찬가지 입니다.</em></p>\n<p>Angular가 제공하는 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> 모듈을 사용해서 점진적으로 업그레이드할 때는 명심해야 할 내용이 몇가지 있습니다:</p>\n<ul>\n<li>\n<p><a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility\">하나만 구현하는 규칙</a>은 파일 하나에 한 컴포넌트만 구현하는 것이 좋다는 것을 설명하고 있습니다.\n그리고 이렇게 구현하면 컴포넌트를 찾기 쉽다는 장점 외에도 AngularJS에서 Angular로 점진적으로 업그레이드하는 데에 도움이 됩니다.\n이 문서에서 설명하는 예제 애플리케이션은 컨트롤러, 컴포넌트, 서비스, 필터는 모두 한 파일에 하나씩 정의되어 있습니다.</p>\n</li>\n<li>\n<p><a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#folders-by-feature-structure\">폴더를 기능별로 구분하는 구조</a>와 <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity\">모듈화(Modularity)</a>는 이 규칙을 좀 더 확장한 것으로 볼 수 있습니다.\n애플리케이션에서 서로 연관되지 않은 기능은 서로 다른 폴더나 NgModule로 구분되는 것이 좋습니다.</p>\n</li>\n</ul>\n<p>애플리케이션이 기능별로 구성되어 있다면 앱을 마이그레이션할 때도 기능단위로 작업할 수 있습니다.\n지금은 이렇게 구현되어 있지 않다고 해도 AngularJS 스타일 가이드는 최대한 따르는 것을 권장하며, 애플리케이션을 Angular 버전으로 업그레이드하는 것 뿐만 아니라 좋은 애플리케이션을 만드는 관점에서도 강력하게 권장합니다!</p>\n<!--\n### Using a Module Loader\n-->\n<h3 id=\"모듈-로더-사용하기\">모듈 로더 사용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#모듈-로더-사용하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nWhen you break application code down into one component per file, you often end\nup with a project structure with a large number of relatively small files. This is\na much neater way to organize things than a small number of large files, but it\ndoesn't work that well if you have to load all those files to the HTML page with\n&lt;script&gt; tags. Especially when you also have to maintain those tags in the correct\norder. That's why it's a good idea to start using a *module loader*.\n\nUsing a module loader such as [SystemJS](https://github.com/systemjs/systemjs),\n[Webpack](http://webpack.github.io/), or [Browserify](http://browserify.org/)\nallows us to use the built-in module systems of TypeScript or ES2015.\nYou can use the `import` and `export` features that explicitly specify what code can\nand will be shared between different parts of the application. For ES5 applications\nyou can use CommonJS style `require` and `module.exports` features. In both cases,\nthe module loader will then take care of loading all the code the application needs\nin the correct order.\n\nWhen moving applications into production, module loaders also make it easier\nto package them all up into production bundles with batteries included.\n-->\n<p>파일 하나에 컴포넌트를 하나씩만 구현한다는 것은 애플리케이션을 세분화한다는 것을 의미하며, 결국 프로젝트는 작은 파일들이 많이 존재하는 구조가 됩니다.\n하지만 반대로 큰 파일 몇개로만 이루어진 애플리케이션은 이 파일들을 모두 내려받아 HTML 페이지의 <code>&#x3C;script></code> 태그에 로드되기 전까지는 동작하지 않아서 문제가 됩니다.\n게다가 이 파일들은 <code>&#x3C;script></code>에 올바른 순서로 로드되어야 합니다.\n이 방식보다는 <em>모듈 로더</em>를 사용하는 것이 더 좋습니다.</p>\n<p><a href=\"https://github.com/systemjs/systemjs\">SystemJS</a>나 <a href=\"http://webpack.github.io/\">Webpack</a>, <a href=\"http://browserify.org/\">Browserify</a>와 같은 모듈 로더를 사용하면 TypeScript나 ES2015로 작성한 코드도 내장 모듈 시스템에 로드할 수 있습니다.\n그리고 <code>import</code>, <code>export</code> 키워드를 사용하면 애플리케이션의 다른 모듈에 있는 코드를 가져다 활용할 수도 있습니다.\n애플리케이션 코드가 ES5로 작성되었다면 CommonJS 스타일로 <code>require</code>와 <code>module.exports</code>를 사용하면 됩니다.\n두 방식 모두 모듈을 로드할 때 자동으로 순서를 맞춰서 에러 없이 로드할 수 있습니다.</p>\n<p>모듈 로더는 애플리케이션을 운영용으로 빌드할 때도 활용됩니다.\n모듈 로더를 사용하면 운영용 빌드 파일과 라이브러리를 패키지 하나로 간단하게 빌드할 수 있습니다.</p>\n<!--\n### Migrating to TypeScript\n-->\n<h3 id=\"typescript-도입하기\">TypeScript 도입하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#typescript-도입하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIf part of the Angular upgrade plan is to also take TypeScript into use, it makes\nsense to bring in the TypeScript compiler even before the upgrade itself begins.\nThis means there's one less thing to learn and think about during the actual upgrade.\nIt also means you can start using TypeScript features in your AngularJS code.\n\nSince TypeScript is a superset of ECMAScript 2015, which in turn is a superset\nof ECMAScript 5, \"switching\" to TypeScript doesn't necessarily require anything\nmore than installing the TypeScript compiler and renaming files from\n`*.js` to `*.ts`. But just doing that is not hugely useful or exciting, of course.\nAdditional steps like the following can give us much more bang for the buck:\n\n* For applications that use a module loader, TypeScript imports and exports\n  (which are really ECMAScript 2015 imports and exports) can be used to organize\n  code into modules.\n\n* Type annotations can be gradually added to existing functions and variables\n  to pin down their types and get benefits like build-time error checking,\n  great autocompletion support and inline documentation.\n\n* JavaScript features new to ES2015, like arrow functions, `let`s and `const`s,\n  default function parameters, and destructuring assignments can also be gradually\n  added to make the code more expressive.\n\n* Services and controllers can be turned into *classes*. That way they'll be a step\n  closer to becoming Angular service and component classes, which will make\n  life easier after the upgrade.\n-->\n<p>Angular로 업그레이드하면서 TypeScript도 사용하기로 정했다면 Angular보다 TypeScript 컴파일러를 먼저 도입하는 것이 좋습니다.\n그러면 이후에 Angular로 업그레이드 했을 때는 물론이고 AngularJS 코드에도 TypeScript 기능을 활용할 수 있습니다.</p>\n<p>TypeScript는 ECMAScript 201의 상위 집합(superset)이기 때문에 ECMAScript 5의 상위 집합이기도 합니다.\n그래서 TypeScript 컴파일러를 설치하고 <code>*.js</code> 파일을 <code>*.ts</code> 파일로 바꾸면 그 자체로도 애플리케이션은 동작합니다.\n물론 아직까지 TypeScript 스타일로 작성한 것처럼 효율적이진 않습니다.\nTypeScript 컴파일러를 도입하고 나면 다음 과정을 진행하면 됩니다:</p>\n<ul>\n<li>\n<p>TypeScript가 제공하는 <code>import</code>, <code>export</code>를 활용하면 코드를 모듈 단위로 구성할 수 있습니다. 이 기능은 ECMAScript 2015 스펙입니다.</p>\n</li>\n<li>\n<p>타입 어노테이션을 활용하면 기존에 있던 함수나 변수에 타입을 추가할 수 있고 빌드 시점에 발생하는 에러를 찾아내는 데에도 도움이 됩니다.\n코드 자동완성 기능도 이에 맞게 확장됩니다.</p>\n</li>\n<li>\n<p>ES2015에 추가된 화살표 함수나 <code>let</code>, <code>const</code>, 함수 인자 기본값 지정, 분해연산자를 활용하면 코드를 더 간결하게 작성할 수 있습니다.</p>\n</li>\n<li>\n<p>서비스나 컨트롤러는 <em>클래스</em>로 변경할 수 있습니다.\n클래스로 변경하고 나면 이후에 Angular 서비스나 컴포넌트 클래스로 변환하는 작업도 수월해집니다.</p>\n</li>\n</ul>\n<a id=\"using-component-directives\"></a>\n<!--\n### Using Component Directives\n-->\n<h3 id=\"컴포넌트-디렉티브-사용하기\">컴포넌트 디렉티브 사용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#컴포넌트-디렉티브-사용하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn Angular, components are the main primitive from which user interfaces\nare built. You define the different portions of the UI as components and\ncompose them into a full user experience.\n\nYou can also do this in AngularJS, using *component directives*. These are\ndirectives that define their own templates, controllers, and input/output bindings -\nthe same things that Angular components define. Applications built with\ncomponent directives are much easier to migrate to Angular than applications\nbuilt with lower-level features like `ng-controller`,  `ng-include`, and scope\ninheritance.\n\nTo be Angular compatible, an AngularJS component directive should configure\nthese attributes:\n\n* `restrict: 'E'`. Components are usually used as elements.\n* `scope: {}` - an isolate scope. In Angular, components are always isolated\n  from their surroundings, and you should do this in AngularJS too.\n* `bindToController: {}`. Component inputs and outputs should be bound\n  to the controller instead of using the `$scope`.\n* `controller` and `controllerAs`. Components have their own controllers.\n* `template` or `templateUrl`. Components have their own templates.\n\nComponent directives may also use the following attributes:\n\n* `transclude: true/{}`, if the component needs to transclude content from elsewhere.\n* `require`, if the component needs to communicate with some parent component's\n  controller.\n\nComponent directives **should not** use the following attributes:\n\n* `compile`. This will not be supported in Angular.\n* `replace: true`. Angular never replaces a component element with the\n  component template. This attribute is also deprecated in AngularJS.\n* `priority` and `terminal`. While AngularJS components may use these,\n  they are not used in Angular and it is better not to write code\n  that relies on them.\n\nAn AngularJS component directive that is fully aligned with the Angular\narchitecture may look something like this:\n-->\n<p>Angular에서 사용자가 보는 화면을 구성하는 기본 단위는 컴포넌트입니다.\n그래서 화면은 컴포넌트를 조합하는 방식으로 구성하며 이 컴포넌트가 모여 모든 UX를 완성합니다.</p>\n<p>이 방식은 AngularJS에서 <em>컴포넌트 디렉티브</em>를 사용해서 구현할 수 있습니다.\n템플릿을 구성하거나 컨트롤러 클래스를 구현하고 입출력 프로퍼티를 바인딩하는 방식도 Angular의 컴포넌트와 같습니다.\n그래서 컴포넌트 디렉티브를 기반으로 작성된 AngularJS 애플리케이션은 Angular 애플리케이션으로 업그레이드하기 쉽습니다.</p>\n<p>Angular로 업그레이드하는 것을 대비하기 위해 AngularJS에는 컴포넌트 디렉티브 어트리뷰트를 이렇게 구성합니다:</p>\n<ul>\n<li><code>restrict: 'E'</code> - 컴포넌트는 일반적으로 엘리먼트입니다.</li>\n<li><code>scope: {}</code> - 독립된 스코프를 구성합니다. Angular에서 컴포넌트는 그 자체로 독립적인 스코프를 구성하기 때문에 AngularJS에서도 이렇게 지정하는 것이 좋습니다.</li>\n<li><code>bindToController: {}</code> - 컴포넌트의 입출력 프로퍼티는 <code>$scope</code>가 아니라 컨트롤러에 직접 바인딩하는 것이 좋습니다.</li>\n<li><code>controller</code>, <code>controllerAs</code> - 컴포넌트 컨트롤러 클래스를 구성합니다.</li>\n<li><code>template</code>, <code>templateUrl</code> - 컴포넌트 템플릿을 구성합니다.</li>\n</ul>\n<p>그리고 컴포넌트 디렉티브에는 이런 어트리뷰트를 활용할 수도 있습니다:</p>\n<ul>\n<li><code>transclude: true/{}</code> - 컴포넌트에 들어갈 내용물이 다른 컴포넌트에서 올 때 사용합니다.</li>\n<li><code>require</code> - 부모 컴포넌트의 컨트롤러를 활용할 때 사용합니다.</li>\n</ul>\n<p>그리고 컴포넌트 디렉티브에는 이런 어트리뷰트가 들어가면 <strong>안됩니다</strong>:</p>\n<ul>\n<li><code>compile</code> - Angular에서 지원하지 않습니다.</li>\n<li><code>replace: true</code> - Angular에서는 템플릿에 사용된 컴포넌트의 호스트 엘리먼트가 사라지지 않습니다.\n이 어트리뷰트는 AngularJS에서도 지원이 중단되었습니다.</li>\n<li><code>priority</code>, <code>teminal</code> - Angular에서 지원하지 않습니다. 이 어트리뷰트를 사용하는 코드는 작성하지 않는 것이 좋습니다.</li>\n</ul>\n<p>이 내용대로 AngularJS 컴포넌트를 구현하면 이런 모습이 됩니다:</p>\n<code-example path=\"upgrade-module/src/app/hero-detail.directive.ts\" header=\"hero-detail.directive.ts\">\nexport function heroDetailDirective() {\n  return {\n    restrict: 'E',\n    scope: {},\n    bindToController: {\n      hero: '=',\n      deleted: '&#x26;'\n    },\n    template: `\n      &#x3C;h2>{{$ctrl.hero.name}} details!&#x3C;/h2>\n      &#x3C;div>&#x3C;label>id: &#x3C;/label>{{$ctrl.hero.id}}&#x3C;/div>\n      &#x3C;button ng-click=\"$ctrl.onDelete()\">Delete&#x3C;/button>\n    `,\n    controller: function HeroDetailController() {\n      this.onDelete = () => {\n        this.deleted({hero: this.hero});\n      };\n    },\n    controllerAs: '$ctrl'\n  };\n}\n\n\n</code-example>\n<!--\nAngularJS 1.5 introduces the [component API](https://docs.angularjs.org/api/ng/type/angular.Module#component)\nthat makes it easier to define component directives like these. It is a good idea to use\nthis API for component directives for several reasons:\n\n* It requires less boilerplate code.\n* It enforces the use of component best practices like `controllerAs`.\n* It has good default values for directive attributes like `scope` and `restrict`.\n\nThe component directive example from above looks like this when expressed\nusing the component API:\n-->\n<p><a href=\"https://docs.angularjs.org/api/ng/type/angular.Module#component\">컴포넌트 API</a>는 AngularJS 1.5 버전부터 지원합니다.\n이 API는 AngularJS 컴포넌트를 Angular 스타일로 구현하기 위해 도입되었으며 이런 장점이 있습니다:</p>\n<ul>\n<li>기본 코드가 더 단순합니다.</li>\n<li>AngularJS 컴포넌트를 Angular 스타일로 작성하도록 강제합니다.</li>\n<li><code>scope</code>나 <code>restrict</code>를 활용해서 디렉티브 어트리뷰트의 기본값을 지정할 수 있습니다.</li>\n</ul>\n<p>위에서 살펴본 AngularJS 컴포넌트 코드에 컴포넌트 API를 적용하면 이렇게 작성할 수 있습니다:</p>\n<code-example path=\"upgrade-module/src/app/upgrade-io/hero-detail.component.ts\" region=\"hero-detail-io\" header=\"hero-detail.component.ts\">\nexport const heroDetail = {\n  bindings: {\n    hero: '&#x3C;',\n    deleted: '&#x26;'\n  },\n  template: `\n    &#x3C;h2>{{$ctrl.hero.name}} details!&#x3C;/h2>\n    &#x3C;div>&#x3C;label>id: &#x3C;/label>{{$ctrl.hero.id}}&#x3C;/div>\n    &#x3C;button ng-click=\"$ctrl.onDelete()\">Delete&#x3C;/button>\n  `,\n  controller: function HeroDetailController() {\n    this.onDelete = () => {\n      this.deleted(this.hero);\n    };\n  }\n};\n\n</code-example>\n<!--\nController lifecycle hook methods `$onInit()`, `$onDestroy()`, and `$onChanges()`\nare another convenient feature that AngularJS 1.5 introduces. They all have nearly\nexact [equivalents in Angular](guide/lifecycle-hooks), so organizing component lifecycle\nlogic around them will ease the eventual Angular upgrade process.\n-->\n<p>AngularJS 1.5 버전에는 컴포넌트 라이프싸이클 후킹 함수 <code>$onInit()</code>, <code>$onDestroy()</code>, <code>$onChanges()</code>도 도입되었습니다.\n이 메소드들은 <a href=\"guide/lifecycle-hooks\">Angular에도 정확히 동일한 역할을 하는 함수</a>가 존재합니다.\n그래서 AngularJS에서 활용하는 컴포넌트 라이프싸이클 관련 로직은 Angular에도 그대로 활용할 수 있습니다.</p>\n<a id=\"upgrading-with-ngupgrade\"></a>\n<!--\n## Upgrading with ngUpgrade\n-->\n<h2 id=\"ngupgrade로-업그레이드하기\">ngUpgrade로 업그레이드하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#ngupgrade로-업그레이드하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe ngUpgrade library in Angular is a very useful tool for upgrading\nanything but the smallest of applications. With it you can mix and match\nAngularJS and Angular components in the same application and have them interoperate\nseamlessly. That means you don't have to do the upgrade work all at once,\nsince there's a natural coexistence between the two frameworks during the\ntransition period.\n-->\n<p>애플리케이션의 규모가 그렇게 크지 않다면 Angular가 제공하는 ngUpgrade 라이브러리만 사용해도 업그레이드하는 데에는 문제가 없습니다.\n애플리케이션에 AngularJS 컴포넌트와 Angular 컴포넌트를 함께 사용하면서 상호작용하는 것도 물론 가능합니다.\n업그레이드는 한번에 끝내는 것이 아니라 시간을 충분히 들여 전환하는 것이 좋습니다.</p>\n<a id=\"how-ngupgrade-works\"></a>\n<!--\n### How ngUpgrade Works\n-->\n<h3 id=\"ngupgrade가-동작하는-방식\">ngUpgrade가 동작하는 방식<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#ngupgrade가-동작하는-방식\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nOne of the primary tools provided by ngUpgrade is called the `UpgradeModule`.\nThis is a module that contains utilities for bootstrapping and managing hybrid\napplications that support both Angular and AngularJS code.\n\nWhen you use ngUpgrade, what you're really doing is *running both AngularJS and\nAngular at the same time*. All Angular code is running in the Angular\nframework, and AngularJS code in the AngularJS framework. Both of these are the\nactual, fully featured versions of the frameworks. There is no emulation going on,\nso you can expect to have all the features and natural behavior of both frameworks.\n\nWhat happens on top of this is that components and services managed by one\nframework can interoperate with those from the other framework. This happens\nin three main areas: Dependency injection, the DOM, and change detection.\n-->\n<p>ngUpgrade의 중심이 되는 툴은 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>입니다.\n이 모듈은 Angular와 AngularJS 코드가 동시에 존재하는 애플리케이션을 부트스트랩하고 관리하는 도구를 제공합니다.</p>\n<p>ngUpgrade를 사용할 때 개발자가 해야하는 것은 <em>AngularJS와 Angular를 동시에 실행하는 것</em>뿐입니다.\n이 때 Angular 코드는 Angular 프레임워크 환경에서 동작하고 AngularJS 코드는 AngularJS 프레임워크 환경에서 동작합니다.\n두 프레임워크는 동시에 존재할 수 있으며 각 프레임워크의 기능도 모두 활용할 수 있습니다.\n프레임워크를 중개하기 위한 에뮬레이터 기능은 필요없습니다.</p>\n<p>각 프레임워크에 속한 컴포넌트와 서비스는 다른 프레임워크에 속한 것들과 상호작용할 수 있습니다.\n의존성 주입, DOM 관리, 변화 감지 측면에서 그렇습니다.</p>\n<!--\n#### Dependency Injection\n-->\n<h4 id=\"의존성-주입\">의존성 주입<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#의존성-주입\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nDependency injection is front and center in both AngularJS and\nAngular, but there are some key differences between the two\nframeworks in how it actually works.\n-->\n<p>의존성 주입은 AngularJS와 Angular에 모두 중요한 기능이지만, 두 프레임워크에서 동작하는 방식은 조금 다릅니다.</p>\n<table>\n  <tbody><tr>\n    <th>\n      AngularJS\n    </th>\n    <th>\n      Angular\n    </th>\n  </tr>\n  <tr>\n    <td>\n      <!--\n      Dependency injection tokens are always strings\n      -->\n      의존성 객체 토큰은 언제나 문자열입니다.\n    </td>\n    <td>\n      <!--\n      Tokens [can have different types](guide/dependency-injection).\n      They are often classes. They may also be strings.\n      -->\n<p>      의존성 객체 토큰은 일반적으로 클래스를 사용하지만 문자열을 사용할 수도 있습니다.\n<a href=\"guide/dependency-injection\">이 문서</a>를 참고하세요.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <!--\n      There is exactly one injector. Even in multi-module applications,\n      everything is poured into one big namespace.\n      -->\n<p>      인젝터는 하나만 존재합니다. 애플리케이션에 모듈이 여러개 존재하더라도 의존성 토큰은 모두 한 네임스페이스에 존재합니다.</p>\n    </td>\n    <td>\n      <!--\n      There is a [tree hierarchy of injectors](guide/hierarchical-dependency-injection),\n      with a root injector and an additional injector for each component.\n      -->\n<p>      인젝터는 <a href=\"guide/hierarchical-dependency-injection\">트리 계층</a>으로 구성됩니다.\n최상위 인젝터를 시작으로 각 컴포넌트마다 인젝터가 구성될 수 있습니다.</p>\n    </td>\n  </tr>\n</tbody></table>\n<!--\nEven accounting for these differences you can still have dependency injection\ninteroperability. `upgrade/static` resolves the differences and makes\neverything work seamlessly:\n\n* You can make AngularJS services available for injection to Angular code\n  by *upgrading* them. The same singleton instance of each service is shared\n  between the frameworks. In Angular these services will always be in the\n  *root injector* and available to all components.\n\n* You can also make Angular services available for injection to AngularJS code\n  by *downgrading* them. Only services from the Angular root injector can\n  be downgraded. Again, the same singleton instances are shared between the frameworks.\n  When you register a downgraded service, you must explicitly specify a *string token* that you want to\n  use in AngularJS.\n-->\n<p>두 프레임워크에서 동작하는 의존성 주입 객체는 이렇게 다르지만 두 체계가 상호작용할 수 있다는 것은 여전히 유효합니다.\n두 프레임워크의 차이는 <code>upgrad/estatic</code>이 다음과 같이 처리합니다:</p>\n<ul>\n<li>\n<p>AngularJS 서비스를 <em>업그레이드해서</em> Angular에 의존성으로 주입할 수 있게 만들어 줍니다.\n그러면 프레임워크와 무관하게 서비스의 인스턴스는 싱글턴으로 존재합니다.\nAngular의 관점에서 보면 이렇게 변환된 서비스는 <em>루트 인젝터</em>에 존재하기 때문에 모든 컴포넌트에 사용할 수 있습니다.</p>\n</li>\n<li>\n<p>Angular 서비스를 <em>다운그레이드해서</em> AngularJS에 의존성으로 주입할 수 있게 만들어 줍니다.\n이 때 Angular의 루트 인젝터에 존재하는 서비스만 다운그레이드할 수 있으며, 이 경우에도 서비스 인스턴스는 프레임워크와 관계없이 싱글턴으로 존재합니다.\n다운그레이드한 Angular 서비스는 AngularJS 의존성 주입 체계에 맞게 <em>문자열 토큰</em>으로 로 주입합니다.</p>\n</li>\n</ul>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/upgrade/injectors.png\" alt=\"The two injectors in a hybrid application\" width=\"700\" height=\"262\">\n</div>\n<!--\n#### Components and the DOM\n-->\n<h4 id=\"컴포넌트와-dom\">컴포넌트와 DOM<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#컴포넌트와-dom\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nIn the DOM of a hybrid ngUpgrade application are components and\ndirectives from both AngularJS and Angular. These components\ncommunicate with each other by using the input and output bindings\nof their respective frameworks, which ngUpgrade bridges together. They may also\ncommunicate through shared injected dependencies, as described above.\n\nThe key thing to understand about a hybrid application is that every element in the DOM is owned by exactly one of the two frameworks.\nThe other framework ignores it. If an element is\nowned by AngularJS, Angular treats it as if it didn't exist,\nand vice versa.\n\nSo normally a hybrid application begins life as an AngularJS application,\nand it is AngularJS that processes the root template, e.g. the index.html.\nAngular then steps into the picture when an Angular component is used somewhere\nin an AngularJS template. That component's template will then be managed\nby Angular, and it may contain any number of Angular components and\ndirectives.\n\nBeyond that, you may interleave the two frameworks.\nYou always cross the boundary between the two frameworks by one of two\nways:\n\n1. By using a component from the other framework: An AngularJS template\n   using an Angular component, or an Angular template using an\n   AngularJS component.\n\n2. By transcluding or projecting content from the other framework. ngUpgrade\n    bridges the related concepts of AngularJS transclusion and Angular content\n    projection together.\n\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/upgrade/dom.png\" alt=\"DOM element ownership in a hybrid application\">\n</div>\n\nWhenever you use a component that belongs to the other framework, a\nswitch between framework boundaries occurs. However, that switch only\nhappens to the elements in the template of that component. Consider a situation\nwhere you use an Angular component from AngularJS like this:\n\n<code-example language=\"html\" escape=\"html\">\n  &lt;a-component&gt;&lt;/a-component&gt;\n</code-example>\n\nThe DOM element `<a-component>` will remain to be an AngularJS managed\nelement, because it's defined in an AngularJS template. That also\nmeans you can apply additional AngularJS directives to it, but *not*\nAngular directives. It is only in the template of the `<a-component>`\nwhere Angular steps in. This same rule also applies when you\nuse AngularJS component directives from Angular.\n-->\n<p>ngUpgrade가 적용된 하이브리으 애플리케이션에는 AngularJS 스타일과 Angular 스타일의 컴포넌트/디렉티브가 존재합니다.\n이 컴포넌트는 입출력 프로퍼티로 상호작용할 수 있으며 각 프레임워크가 제대로 동작하도록 ngUpgrade가 중개합니다.\n위에서 설명한 것처럼 컴포넌트는 의존성으로 주입받은 서비스도 활용할 수 있습니다.</p>\n<p>하이브리드 애플리케이션에서 중요한 것은 DOM에 존재하는 컴포넌트는 반드시 두 프레임워크 중 하나에만 속한다는 것입니다.\n속하지 않은 프레임워크는 영향을 주지 않습니다.\nAngularJS 위에서 동작하는 컴포넌트는 Angular의 영향을 받지 않으며, 반대 경우도 마찬가지입니다.</p>\n<p>일반적으로 하이브리드 애플리케이션은 AngularJS 애플리케이션이 기본틀을 구성하기 때문에 <code>index.html</code> 파일에서 루트 컴포넌트가 되는 것은 AngularJS 컴포넌트일 것입니다.\n그리고 Angular 컴포넌트는 AngularJS 템플릿에 추가되는 방식으로 동작합니다.\nAngular 컴포넌트의 템플릿은 Angular가 관리하며 템플릿 안에서는 Angular 컴포넌트나 디렉티브를 자유롭게 사용할 수 있습니다.</p>\n<p>두 프레임워크는 서로 호환되기 때문에 이런 방식으로 사용할 수 있습니다.</p>\n<ol>\n<li>\n<p>다릍 프레임워크에 있는 컴포넌트를 사용할 수 있습니다:\nAngularJS 템플릿에 Angular 컴포넌트를 사용할 수 있으며, Angular 템플릿에 AngularJS 컴포넌트를 사용할 수도 있습니다.</p>\n</li>\n<li>\n<p>다른 프레임워크의 컴포넌트에 HTML 조각을 프로젝션할 수 있습니다.\nngUpgrade는 AngularJS 트랜스클루전(transclusion)과 Angular 프로젝션(projection)을 중개합니다.</p>\n</li>\n</ol>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/upgrade/dom.png\" alt=\"DOM element ownership in a hybrid application\" width=\"500\" height=\"294\">\n</div>\n<p>컴포넌트를 다른 프레임워크 영역에 사용하면 프레임워크의 경계를 넘어서는 동작이 발생합니다.\n그런데 이 작업은 컴포넌트의 템플릿에서만 발생합니다.\nAngularJS 템플릿에 Angular 컴포넌트를 사용하는 경우를 생각해 봅시다:</p>\n<code-example language=\"html\" escape=\"html\">\n  &#x3C;a-component>&#x3C;/a-component>\n</code-example>\n<p>DOM 엘리먼트 <code>&#x3C;a-component></code>는 AngularJS 템플릿에 사용되었기 때문에 AngularJS가 관리하는 엘리먼트입니다.\n따라서 이 엘리먼트에는 AngularJS 디렉티브를 자유롭게 사용할 수 있지만 Angular 디렉티브는 <em>사용할 수 없습니다</em>.\nAngular가 동작하는 영역은 <code>&#x3C;a-component></code> 템플릿 내부입니다.\n이 동작 방식은 Angular 템플릿에 사용하느느 AngularJS 컴포넌트 디렉티브에서도 마찬가지입니다.</p>\n<a id=\"change-detection\"></a>\n<!--\n#### Change Detection\n-->\n<h4 id=\"변화-감지\">변화 감지<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#변화-감지\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe `scope.$apply()` is how AngularJS detects changes and updates data bindings.\nAfter every event that occurs, `scope.$apply()` gets called. This is done either\nautomatically by the framework, or manually by you.\n\nIn Angular things are different. While change detection still\noccurs after every event, no one needs to call `scope.$apply()` for\nthat to happen. This is because all Angular code runs inside something\ncalled the [Angular zone](api/core/NgZone). Angular always\nknows when the code finishes, so it also knows when it should kick off\nchange detection. The code itself doesn't have to call `scope.$apply()`\nor anything like it.\n\nIn the case of hybrid applications, the `UpgradeModule` bridges the\nAngularJS and Angular approaches. Here's what happens:\n\n* Everything that happens in the application runs inside the Angular zone.\n  This is true whether the event originated in AngularJS or Angular code.\n  The zone triggers Angular change detection after every event.\n\n* The `UpgradeModule` will invoke the AngularJS `$rootScope.$apply()` after\n  every turn of the Angular zone. This also triggers AngularJS change\n  detection after every event.\n-->\n<p>AngularJS에서 변화 감지를 시작하고 바인딩된 데이터를 갱신하는 것은 <code>scope.$apply()</code>입니다.\n그리고 이 메소드는 이벤트가 발생할 때마다 프레임워크가 자동으로 실행하며, 필요하면 개발자가 직접 실행할 수도 있습니다.</p>\n<p>Angular에서는 조금 다릅니다.\n이벤트가 발생할 때마다 변화 감지 로직이 시작되는 것은 동일하지만, 이 때 <code>scope.$apply()</code>는 실행되지 않습니다.\n이 현상은 Angular 코드가 <a href=\"api/core/NgZone\">Angular 존</a> 안에서 실행되기 때문입니다.\nAngular는 실행된 코드가 종료되는 것을 감지하고 있으며 필요할 때만 변화 감지 로직을 시작합니다.\n코드 자체는 <code>scope.$apply()</code>를 실행하지 않습니다.</p>\n<p>하이브리드 애플리케이션에서는 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>이 AngularJS와 Angular를 이렇게 중개합니다:</p>\n<ul>\n<li>\n<p>애플리케이션에서 발생하는 모든 이벤트는 Angular 존 안에서 동작합니다.\n이벤트가 AngularJS 코드에서 발생했더라도 그렇습니다.\n그래서 이벤트를 처리하는 변화 감지 로직은 Angular 존에서 시작됩니다.</p>\n</li>\n<li>\n<p>Angular 존에서 작업이 종료된 이후에 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>이 AngularJS <code>$rootScope.$apply()</code>를 실행합니다.\n그래서 모든 이벤트가 발애한 후에는 AngularJS의 변화 감지 로직도 시작됩니다.</p>\n</li>\n</ul>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/upgrade/change_detection.png\" alt=\"Change detection in a hybrid application\" width=\"600\" height=\"163\">\n</div>\n<!--\nIn practice, you do not need to call `$apply()`,\nregardless of whether it is in AngularJS or Angular. The\n`UpgradeModule` does it for us. You *can* still call `$apply()` so there\nis no need to remove such calls from existing code. Those calls just trigger\nadditional AngularJS change detection checks in a hybrid application.\n\nWhen you downgrade an Angular component and then use it from AngularJS,\nthe component's inputs will be watched using AngularJS change detection.\nWhen those inputs change, the corresponding properties in the component\nare set. You can also hook into the changes by implementing the\n[OnChanges](api/core/OnChanges) interface in the component,\njust like you could if it hadn't been downgraded.\n\nCorrespondingly, when you upgrade an AngularJS component and use it from Angular,\nall the bindings defined for the component directive's `scope` (or `bindToController`)\nwill be hooked into Angular change detection. They will be treated\nas regular Angular inputs. Their values will be written to the upgraded component's\nscope (or controller) when they change.\n-->\n<p>실제로는 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>이 <code>$apply()</code>를 자동으로 실행하기 때문에 AngularJS 코드나 Angular 코드에서 이 함수를 직접 실행할 필요가 없습니다.\n그래서 기존에 있던 코드에 <code>$apply()</code>를 사용하던 코드는 모두 제거해도 됩니다.\n이 코드를 제거해도 하이브리드 애플리케이션에 필요한 AngularJS 변화 감지 로직은 자동으로 실행됩니다.</p>\n<p>Angular 컴포넌트를 AngularJS 용으로 다운그레이드해서 사용하면 AngularJS 변화 감지 로직이 컴포넌트의 입력 프로퍼티를 감시합니다.\n그래서 입력값이 변경되면 컴포넌트의 프로퍼티 값도 변경됩니다.\n그리고 이 변경시점은 <a href=\"api/core/OnChanges\">OnChanges</a>로 받아서 확장할 수 있습니다.</p>\n<p>이와 비슷하게 AngularJS 컴포넌트를 업그레이드해서 Angular에 사용하면 Angular 변화 감지 로직이 컴포넌트 디렉티브의 <code>scope</code>나 <code>bindToController</code>에 바인딩된 항목들을 감시합니다.\n그래서 이 항목들은 Angular의 입력 프로퍼티와 동일하게 처리됩니다.\n입력값이 변경될 때 입력 프로퍼티의 값이 변경되는 것도 같은 방식으로 이루어집니다.</p>\n<!--\n### Using UpgradeModule with Angular _NgModules_\n-->\n<h3 id=\"angular-ngmodule-과-upgrademodule-사용하기\">Angular <em>NgModule</em> 과 UpgradeModule 사용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#angular-ngmodule-과-upgrademodule-사용하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nBoth AngularJS and Angular have their own concept of modules\nto help organize an application into cohesive blocks of functionality.\n\nTheir details are quite different in architecture and implementation.\nIn AngularJS, you add Angular assets to the `angular.module` property.\nIn Angular, you create one or more classes adorned with an `NgModule` decorator\nthat describes Angular assets in metadata. The differences blossom from there.\n\nIn a hybrid application you run both versions of Angular at the same time.\nThat means that you need at least one module each from both AngularJS and Angular.\nYou will import `UpgradeModule` inside the NgModule, and then use it for\nbootstrapping the AngularJS module.\n-->\n<p>AngularJS와 Angular는 애플리케이션을 모듈 단위로 구성합니다.</p>\n<p>그런데 두 프레임워크가 모듈을 구성하는 방식은 설계 구조나 구현 코드의 관점에서 볼 때 상당히 다릅니다.\nAngularJS에서는 Angular 구성요소를 <code>angular.module</code> 프로퍼티에 등록하며, Angular에서는 클래스에 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 데코레이터를 사용해서 등록합니다.\n두 방식의 차이는 여기에서 시작됩니다.</p>\n<p>하이브리드 앱에서는 두 버전의 Angular가 동시에 실행됩니다.\n따라서 AngularJS와 Angular 양쪽에 각각 모듈 하나씩은 반드시 존재해야 합니다.\nAngular의 NgModule 안에서 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 심볼을 사용하면 AngularJS 모듈을 부트스트랩할 수 있습니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nFor more information, see [NgModules](guide/ngmodules).\n-->\n<p>더 자세한 내용은 <a href=\"guide/ngmodules\">NgModules</a> 문서를 참고하세요.</p>\n</div>\n<a id=\"bootstrapping-hybrid-applications\"></a>\n<!--\n### Bootstrapping hybrid applications\n-->\n<h3 id=\"하이브리드-앱-부트스트랩하기\">하이브리드 앱 부트스트랩하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#하이브리드-앱-부트스트랩하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nTo bootstrap a hybrid application, you must bootstrap each of the Angular and\nAngularJS parts of the application. You must bootstrap the Angular bits first and\nthen ask the `UpgradeModule` to bootstrap the AngularJS bits next.\n\nIn an AngularJS application you have a root AngularJS module, which will also\nbe used to bootstrap the AngularJS application.\n\n<code-example path=\"upgrade-module/src/app/ajs-bootstrap/app.module.ts\" region=\"ng1module\" header=\"app.module.ts\">\nangular.module(&#39;heroApp&#39;, [])\n  .controller(&#39;MainCtrl&#39;, function() {\n    this.message = &#39;Hello world&#39;;\n  });\n\n</code-example>\n\nPure AngularJS applications can be automatically bootstrapped by using an `ng-app`\ndirective somewhere on the HTML page. But for hybrid applications, you manually bootstrap via the\n`UpgradeModule`. Therefore, it is a good preliminary step to switch AngularJS applications to use the\nmanual JavaScript [`angular.bootstrap`](https://docs.angularjs.org/api/ng/function/angular.bootstrap)\nmethod even before switching them to hybrid mode.\n\nSay you have an `ng-app` driven bootstrap such as this one:\n\n<code-example path=\"upgrade-module/src/index-ng-app.html\">\n&lt;!DOCTYPE HTML&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;base href=&quot;/&quot;&gt;\n    &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/angularjs/1.5.3/angular.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;app/ajs-ng-app/app.module.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n\n  &lt;body ng-app=&quot;heroApp&quot; ng-strict-di&gt;\n    &lt;div id=&quot;message&quot; ng-controller=&quot;MainCtrl as mainCtrl&quot;&gt;\n      {{ mainCtrl.message }}\n    &lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n\n</code-example>\n\nYou can remove the `ng-app` and `ng-strict-di` directives from the HTML\nand instead switch to calling `angular.bootstrap` from JavaScript, which\nwill result in the same thing:\n\n<code-example path=\"upgrade-module/src/app/ajs-bootstrap/app.module.ts\" region=\"bootstrap\" header=\"app.module.ts\">\nangular.bootstrap(document.body, [&#39;heroApp&#39;], { strictDi: true });\n\n</code-example>\n\nTo begin converting your AngularJS application to a hybrid, you need to load the Angular framework.\nYou can see how this can be done with SystemJS by following the instructions in [Setup for Upgrading to AngularJS](guide/upgrade-setup) for selectively copying code from the [QuickStart github repository](https://github.com/angular/quickstart).\n\nYou also need to install the `@angular/upgrade` package via `npm install @angular/upgrade --save`\nand add a mapping for the `@angular/upgrade/static` package:\n\n<code-example path=\"upgrade-module/src/systemjs.config.1.js\" region=\"upgrade-static-umd\" header=\"systemjs.config.js (map)\">\n&#39;@angular/upgrade/static&#39;: &#39;npm:@angular/upgrade/bundles/upgrade-static.umd.js&#39;,\n\n</code-example>\n\nNext, create an `app.module.ts` file and add the following `NgModule` class:\n\n<code-example path=\"upgrade-module/src/app/ajs-a-hybrid-bootstrap/app.module.ts\" region=\"ngmodule\" header=\"app.module.ts\">\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { BrowserModule } from &#39;@angular/platform-browser&#39;;\nimport { UpgradeModule } from &#39;@angular/upgrade/static&#39;;\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    UpgradeModule\n  ]\n})\nexport class AppModule {\n  constructor(private upgrade: UpgradeModule) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, [&#39;heroApp&#39;], { strictDi: true });\n  }\n}\n\n</code-example>\n\nThis bare minimum `NgModule` imports `BrowserModule`, the module every Angular browser-based app must have.\nIt also imports `UpgradeModule` from `@angular/upgrade/static`, which exports providers that will be used\nfor upgrading and downgrading services and components.\n\nIn the constructor of the `AppModule`, use dependency injection to get a hold of the `UpgradeModule` instance,\nand use it to bootstrap the AngularJS app in the `AppModule.ngDoBootstrap` method.\nThe `upgrade.bootstrap` method takes the exact same arguments as [angular.bootstrap](https://docs.angularjs.org/api/ng/function/angular.bootstrap):\n\n<div class=\"alert is-helpful\">\n\nNote that you do not add a `bootstrap` declaration to the `@NgModule` decorator, since\nAngularJS will own the root template of the application.\n\n</div>\n\nNow you can bootstrap `AppModule` using the `platformBrowserDynamic.bootstrapModule` method.\n\n<code-example path=\"upgrade-module/src/app/ajs-a-hybrid-bootstrap/app.module.ts\" region=\"bootstrap\" header=\"app.module.ts'\">\nimport { platformBrowserDynamic } from &#39;@angular/platform-browser-dynamic&#39;;\n\nplatformBrowserDynamic().bootstrapModule(AppModule);\n\n</code-example>\n\nCongratulations! You're running a hybrid application! The\nexisting AngularJS code works as before _and_ you're ready to start adding Angular code.\n-->\n<p>하이브리드 애플리케이션을 부트스트랩하려면 Angular 부분과 AngularJS 부분을 따로 부트스트랩해야 합니다.\n그리고 이 때 Angular 부분을 먼저 부트스트랩해야 하며 그 다음에 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>을 사용해서 AngularJS를 부트스트랩해야 합니다.</p>\n<p>하이브리드 애플리케이션의 AngularJS 부분은 원래 AngularJS 애플리케이션을 부트스트랩 하듯이 최상위 AngularJS 모듈을 대상으로 합니다.</p>\n<code-example path=\"upgrade-module/src/app/ajs-bootstrap/app.module.ts\" region=\"ng1module\" header=\"app.module.ts\">\nangular.module('heroApp', [])\n  .controller('MainCtrl', function() {\n    this.message = 'Hello world';\n  });\n\n</code-example>\n<p>AngularJS 애플리케이션은 HTML 페이지에 있는 <code>ng-app</code> 디렉티브를 자동으로 찾아서 부트스트랩 하지만, 하이브리드 애플리케이션에서는 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>로 대상을 직접 찾아서 부트스트랩해야 합니다.\n그래서 AngularJS 애플리케이션을 하이브리드 모드로 실행하기 위해 JavaScript 메소드 <a href=\"https://docs.angularjs.org/api/ng/function/angular.bootstrap\"><code>angular.bootstrap</code></a>를 사용합니다.</p>\n<p>이런 애플리케이션 코드가 있다고 합시다:</p>\n<code-example path=\"upgrade-module/src/index-ng-app.html\">\n&#x3C;!DOCTYPE HTML>\n&#x3C;html lang=\"en\">\n  &#x3C;head>\n    &#x3C;base href=\"/\">\n    &#x3C;script src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.5.3/angular.js\">&#x3C;/script>\n    &#x3C;script src=\"app/ajs-ng-app/app.module.js\">&#x3C;/script>\n  &#x3C;/head>\n\n  &#x3C;body ng-app=\"heroApp\" ng-strict-di>\n    &#x3C;div id=\"message\" ng-controller=\"MainCtrl as mainCtrl\">\n      {{ mainCtrl.message }}\n    &#x3C;/div>\n  &#x3C;/body>\n&#x3C;/html>\n\n\n</code-example>\n<p>이 코드에서 <code>ng-app</code>과 <code>ng-strict-di</code> 디렉티브를 HTML 문서에서 제거하고 <code>angular.bootstrap</code> 메소드를 실행하는 방식으로 대체해도 이 애플리케이션은 이전처럼 동작합니다:</p>\n<code-example path=\"upgrade-module/src/app/ajs-bootstrap/app.module.ts\" region=\"bootstrap\" header=\"app.module.ts\">\nangular.bootstrap(document.body, ['heroApp'], { strictDi: true });\n\n</code-example>\n<p>그리고 AngularJS 애플리케이션을 하이브리드 모드로 시작하려면 Angular 프레임워크를 로드해야 합니다.\n이 작업은 SystemJS를 활용하며 자세한 과정은 <a href=\"guide/upgrade-setup\">Setup for Upgrading to AngularJS</a>에서 확인할 수 있으며, <a href=\"https://github.com/angular/quickstart\">QuickStart github 저장소</a>에서 코드를 내려받아 필요한 부분만 적용할 수도 있습니다.</p>\n<p>그 다음에는 <code>npm install @angular/upgrade --save</code> 명령을 실행해서 <code>@angular/upgrade</code> 패키지를 설치해야 합니다.\n패키지를 설치한 후에는 SystemJS 환경설정 파일에 다음과 같이 로드합니다:</p>\n<code-example path=\"upgrade-module/src/systemjs.config.1.js\" region=\"upgrade-static-umd\" header=\"systemjs.config.js (map)\">\n'@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>': 'npm:@angular/upgrade/bundles/upgrade-static.umd.js',\n\n</code-example>\n<p>그리고 <code>app.module.ts</code> 파일을 만들어서 다음과 같은 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 클래스를 정의합니다:</p>\n<code-example path=\"upgrade-module/src/app/ajs-a-hybrid-bootstrap/app.module.ts\" region=\"ngmodule\" header=\"app.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>\n  ]\n})\nexport class AppModule {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<p>이 코드는 모듈에 필요한 설정을 최소한으로 구현한 코드입니다.\n이 모듈은 Angular를 브라우저에서 실행하기 위해 <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>을 로드하고 있으며, <code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code>이 제공하는 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>도 로드하고 있습니다.\n그리고 서비스와 컴포넌트를 업그레이드하거나 다운그레이드하는 서비스 프로바이더도 등록했습니다.</p>\n<p><code>AppModule</code>의 생성자에는 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 인스턴스를 의존성으로 주입하는데, 이 인스턴스는 <code>AppModule.ngDoBootstrap()</code> 메소드에서 <code>UpgradeModule.bootstrap</code> 메소드로 AngularJS 애플리케이션을 부트스트랩합니다.\n이 메소드의 사용방법은 <a href=\"https://docs.angularjs.org/api/ng/function/angular.bootstrap\">angular.bootstrap</a>과 같습니다:</p>\n<div class=\"alert is-helpful\">\n<p><code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 데코레이터의 <code>bootstrap</code> 항목은 사용하지 않았습니다.\nAngularJS는 독립적인 최상위 템플릿을 구성합니다.</p>\n</div>\n<p>이제 <code>platformBrowserDynamic.bootstrapModule</code> 메소드를 사용하면 <code>AppModule</code>을 부트스트랩할 수 있습니다.</p>\n<code-example path=\"upgrade-module/src/app/ajs-a-hybrid-bootstrap/app.module.ts\" region=\"bootstrap\" header=\"app.module.ts&#x27;\">\nimport { <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a> } from '@angular/platform-browser-dynamic';\n\n<a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>().bootstrapModule(AppModule);\n\n</code-example>\n<p>축하합니다! 이제 하이브리드 애플리케이션이 동작합니다!\n이제 AngularJS 코드로 작성한 애플리케이션에 Angular 코드를 추가할 준비는 끝났습니다.</p>\n<a id=\"using-angular-components-from-angularjs-code\"></a>\n<!--\n### Using Angular Components from AngularJS Code\n-->\n<h3 id=\"angularjs-영역에-angular-컴포넌트-사용하기\">AngularJS 영역에 Angular 컴포넌트 사용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#angularjs-영역에-angular-컴포넌트-사용하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\n<img src=\"generated/images/guide/upgrade/ajs-to-a.png\" alt=\"Using an Angular component from AngularJS code\" class=\"left\">\n\nOnce you're running a hybrid app, you can start the gradual process of upgrading\ncode. One of the more common patterns for doing that is to use an Angular component\nin an AngularJS context. This could be a completely new component or one that was\npreviously AngularJS but has been rewritten for Angular.\n\nSay you have a simple Angular component that shows information about a hero:\n\n<code-example path=\"upgrade-module/src/app/downgrade-static/hero-detail.component.ts\" header=\"hero-detail.component.ts\">\nimport { Component } from &#39;@angular/core&#39;;\n\n@Component({\n  selector: &#39;hero-detail&#39;,\n  template: `\n    &lt;h2&gt;Windstorm details!&lt;/h2&gt;\n    &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;1&lt;/div&gt;\n  `\n})\nexport class HeroDetailComponent { }\n\n\n</code-example>\n\nIf you want to use this component from AngularJS, you need to *downgrade* it\nusing the `downgradeComponent()` method. The result is an AngularJS\n*directive*, which you can then register in the AngularJS module:\n\n<code-example path=\"upgrade-module/src/app/downgrade-static/app.module.ts\" region=\"downgradecomponent\" header=\"app.module.ts\">\nimport { HeroDetailComponent } from &#39;./hero-detail.component&#39;;\n\n/* . . . */\n\nimport { downgradeComponent } from &#39;@angular/upgrade/static&#39;;\n\nangular.module(&#39;heroApp&#39;, [])\n  .directive(\n    &#39;heroDetail&#39;,\n    downgradeComponent({ component: HeroDetailComponent }) as angular.IDirectiveFactory\n  );\n\n\n</code-example>\n\n<div class=\"alert is-helpful\">\n\nBy default, Angular change detection will also run on the component for every\nAngularJS `$digest` cycle. If you wish to only have change detection run when\nthe inputs change, you can set `propagateDigest` to `false` when calling\n`downgradeComponent()`.\n\n</div>\n\nBecause `HeroDetailComponent` is an Angular component, you must also add it to the\n`declarations` in the `AppModule`.\n\nAnd because this component is being used from the AngularJS module, and is an entry point into\nthe Angular application, you must add it to the `entryComponents` for the\nNgModule.\n\n<code-example path=\"upgrade-module/src/app/downgrade-static/app.module.ts\" region=\"ngmodule\" header=\"app.module.ts\">\nimport { HeroDetailComponent } from &#39;./hero-detail.component&#39;;\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    UpgradeModule\n  ],\n  declarations: [\n    HeroDetailComponent\n  ],\n  entryComponents: [\n    HeroDetailComponent\n  ]\n})\nexport class AppModule {\n  constructor(private upgrade: UpgradeModule) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, [&#39;heroApp&#39;], { strictDi: true });\n  }\n}\n\n</code-example>\n\n<div class=\"alert is-helpful\">\n\nAll Angular components, directives and pipes must be declared in an NgModule.\n\n</div>\n\nThe net result is an AngularJS directive called `heroDetail`, that you can\nuse like any other directive in AngularJS templates.\n\n<code-example path=\"upgrade-module/src/index-downgrade-static.html\" region=\"usecomponent\">\n&lt;hero-detail&gt;&lt;/hero-detail&gt;\n\n</code-example>\n\n<div class=\"alert is-helpful\">\n\nNote that this AngularJS is an element directive (`restrict: 'E'`) called `heroDetail`.\nAn AngularJS element directive is matched based on its _name_.\n*The `selector` metadata of the downgraded Angular component is ignored.*\n\n</div>\n\nMost components are not quite this simple, of course. Many of them\nhave *inputs and outputs* that connect them to the outside world. An\nAngular hero detail component with inputs and outputs might look\nlike this:\n\n<code-example path=\"upgrade-module/src/app/downgrade-io/hero-detail.component.ts\" header=\"hero-detail.component.ts\">\nimport { Component, EventEmitter, Input, Output } from &#39;@angular/core&#39;;\nimport { Hero } from &#39;../hero&#39;;\n\n@Component({\n  selector: &#39;hero-detail&#39;,\n  template: `\n    &lt;h2&gt;{{hero.name}} details!&lt;/h2&gt;\n    &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;{{hero.id}}&lt;/div&gt;\n    &lt;button (click)=&quot;onDelete()&quot;&gt;Delete&lt;/button&gt;\n  `\n})\nexport class HeroDetailComponent {\n  @Input() hero: Hero;\n  @Output() deleted = new EventEmitter&lt;Hero&gt;();\n  onDelete() {\n    this.deleted.emit(this.hero);\n  }\n}\n\n\n</code-example>\n\nThese inputs and outputs can be supplied from the AngularJS template, and the\n`downgradeComponent()` method takes care of wiring them up:\n\n<code-example path=\"upgrade-module/src/index-downgrade-io.html\" region=\"usecomponent\">\n&lt;div ng-controller=&quot;MainController as mainCtrl&quot;&gt;\n  &lt;hero-detail [hero]=&quot;mainCtrl.hero&quot;\n               (deleted)=&quot;mainCtrl.onDelete($event)&quot;&gt;\n  &lt;/hero-detail&gt;\n&lt;/div&gt;\n\n</code-example>\n\nNote that even though you are in an AngularJS template, **you're using Angular\nattribute syntax to bind the inputs and outputs**. This is a requirement for downgraded\ncomponents. The expressions themselves are still regular AngularJS expressions.\n\n<div class=\"callout is-important\">\n\n<header>\n  Use kebab-case for downgraded component attributes\n</header>\n\nThere's one notable exception to the rule of using Angular attribute syntax\nfor downgraded components. It has to do with input or output names that consist\nof multiple words. In Angular, you would bind these attributes using camelCase:\n\n<code-example format=\"\">\n  [myHero]=\"hero\"\n  (heroDeleted)=\"handleHeroDeleted($event)\"\n</code-example>\n\nBut when using them from AngularJS templates, you must use kebab-case:\n\n<code-example format=\"\">\n  [my-hero]=\"hero\"\n  (hero-deleted)=\"handleHeroDeleted($event)\"\n</code-example>\n\n</div>\n\nThe `$event` variable can be used in outputs to gain access to the\nobject that was emitted. In this case it will be the `Hero` object, because\nthat is what was passed to `this.deleted.emit()`.\n\nSince this is an AngularJS template, you can still use other AngularJS\ndirectives on the element, even though it has Angular binding attributes on it.\nFor example, you can easily make multiple copies of the component using `ng-repeat`:\n\n<code-example path=\"upgrade-module/src/index-downgrade-io.html\" region=\"userepeatedcomponent\">\n&lt;div ng-controller=&quot;MainController as mainCtrl&quot;&gt;\n  &lt;hero-detail [hero]=&quot;hero&quot;\n               (deleted)=&quot;mainCtrl.onDelete($event)&quot;\n               ng-repeat=&quot;hero in mainCtrl.heroes&quot;&gt;\n  &lt;/hero-detail&gt;\n&lt;/div&gt;\n\n</code-example>\n-->\n<img src=\"generated/images/guide/upgrade/ajs-to-a.png\" alt=\"Using an Angular component from AngularJS code\" class=\"left\" width=\"250\" height=\"44\">\n<p>하이브리드 앱을 실행했다면 이제 코드를 업그레이드 할 시간입니다.\n그 중 가장 먼저 할 수 있는 것은 AngularJS 컨텍스트에 Angular 컴포넌트를 사용하는 것입니다.\nAngularJS로 작성된 컴포넌트를 Angular로 재작성하면 됩니다.</p>\n<p>히어로의 정보를 표시하는 Angular 컴포넌트 코드가 다음과 같다고 합시다:</p>\n<code-example path=\"upgrade-module/src/app/downgrade-static/hero-detail.component.ts\" header=\"hero-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'hero-detail',\n  template: `\n    &#x3C;h2>Windstorm details!&#x3C;/h2>\n    &#x3C;div>&#x3C;label>id: &#x3C;/label>1&#x3C;/div>\n  `\n})\nexport class HeroDetailComponent { }\n\n\n</code-example>\n<p>이 컴포넌트를 AngularJS 템플릿에 사용하려면 <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> 메소드를 사용해서 컴포넌트를 <em>다운그레이드</em>해야 하는데, 이 메소드는 AngularJS <em>디렉티브</em>를 반환하기 때문에 AngularJS 모듈에 등록할 수 있습니다:</p>\n<code-example path=\"upgrade-module/src/app/downgrade-static/app.module.ts\" region=\"downgradecomponent\" header=\"app.module.ts\">\nimport { HeroDetailComponent } from './hero-detail.component';\n\n/* . . . */\n\nimport { <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nangular.module('heroApp', [])\n  .directive(\n    'heroDetail',\n    <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>({ component: HeroDetailComponent }) as angular.IDirectiveFactory\n  );\n\n\n</code-example>\n<p><code>HeroDetailComponent</code>는 Angulara 컴포넌트이기 때문에 <code>AppModule</code>의 <code>declarations</code> 배열에도 등록해야 합니다.</p>\n<p>그리고 이 컴포넌트는 AngularJS 모듈에 사용될 것이기 때문에 Angular 애플리케이션의 진입 포인트로 지정되어야 합니다.\nNgModule의 <code>entryComponents</code>에 다음과 같이 등록합니다.</p>\n<code-example path=\"upgrade-module/src/app/downgrade-static/app.module.ts\" region=\"ngmodule\" header=\"app.module.ts\">\nimport { HeroDetailComponent } from './hero-detail.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>\n  ],\n  declarations: [\n    HeroDetailComponent\n  ],\n  entryComponents: [\n    HeroDetailComponent\n  ]\n})\nexport class AppModule {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>Angular 컴포넌트와 디렉티브, 파이프는 반드시 NgModule에 등록해야 합니다.</p>\n</div>\n<p>이렇게 구현하고 나면 AngularJS에서 사용할 수 있는 <code>heroDetail</code> 디렉티브가 만들어지기 때문에 이제 AngularJS 템플릿에 보통 디렉티브처럼 사용할 수 있습니다.</p>\n<code-example path=\"upgrade-module/src/index-downgrade-static.html\" region=\"usecomponent\">\n&#x3C;hero-detail>&#x3C;/hero-detail>\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>이 컴포넌트는 이제 Angular 엘리먼트 디렉티브(<code>restrict: 'E'</code>)이며 셀렉터는 <code>heroDetail</code>입니다.\n이제 AngularJS 디렉티브는 HTML 페이지에 사용된 엘리먼트의 <em>이름</em> 과 매칭되며, <em>Angular 컴포넌트에서 지정한 <code>selector</code> 메타데이터는 무시됩니다.</em></p>\n</div>\n<p>당연히 모든 컴포넌트가 이렇게 간단하지만은 않습니다.\n컴포넌트에 <em>입출력</em> 프로퍼티가 있어서 외부와 연결되었을 수도 있습니다.\n이런 컴포넌트 코드를 생각해 봅시다:</p>\n<code-example path=\"upgrade-module/src/app/downgrade-io/hero-detail.component.ts\" header=\"hero-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/Output\" class=\"code-anchor\">Output</a> } from '@angular/core';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'hero-detail',\n  template: `\n    &#x3C;h2>{{hero.name}} details!&#x3C;/h2>\n    &#x3C;div>&#x3C;label>id: &#x3C;/label>{{hero.id}}&#x3C;/div>\n    &#x3C;button (click)=\"onDelete()\">Delete&#x3C;/button>\n  `\n})\nexport class HeroDetailComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() deleted = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;Hero>();\n  onDelete() {\n    this.deleted.emit(this.hero);\n  }\n}\n\n\n</code-example>\n<p>입출력 프로퍼티는 AngularJS 템플릿에서도 사용할 수 있습니다.\nAngularJS에서 다음과 같이 작성하면 <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> 메소드가 Angular 컴포넌트의 입출력 프로퍼티를 연결할 수 있습니다::</p>\n<code-example path=\"upgrade-module/src/index-downgrade-io.html\" region=\"usecomponent\">\n&#x3C;div ng-controller=\"MainController as mainCtrl\">\n  &#x3C;hero-detail [hero]=\"mainCtrl.hero\"\n               (deleted)=\"mainCtrl.onDelete($event)\">\n  &#x3C;/hero-detail>\n&#x3C;/div>\n\n</code-example>\n<p>이 때 작업하는 것은 분명히 AngularJS 템플릿이지만 <strong>입출력 프로퍼티를 바인딩할 때는 Angular 어트리뷰트 바인딩 문법을 사용합니다</strong>.\nAngular 컴포넌트를 다운그레이드할 때 이 규칙은 꼭 지켜야 합니다.\n다만 어트리뷰트에 바인딩되는 표현식은 AngularJS 문법입니다.</p>\n<div class=\"callout is-important\">\n<header>\n  다운그레이드한 컴포넌트 어트리뷰트에는 케밥 케이스(kebab-case)를 사용합니다.\n</header>\n<p>Angular 컴포넌트를 다운그레이드해서 사용할 때 어트리뷰트 문법에 주의해야 할 점이 있습니다.\n입출력 프로퍼티의 이름이 여러 단어로 구성되었다면 Angular에서는 캐멀 케이스(camelCase)로 지정했습니다:</p>\n<code-example format=\"\">\n  [myHero]=\"hero\"\n  (heroDeleted)=\"handleHeroDeleted($event)\"\n</code-example>\n<p>하지만 AngularJS 템플릿에서는 케밥 케이스를 사용해야 합니다:</p>\n<code-example format=\"\">\n  [my-hero]=\"hero\"\n  (hero-deleted)=\"handleHeroDeleted($event)\"\n</code-example>\n</div>\n<p>컴포넌트 안에서 외부로 보내는 객체는 <code>$event</code> 변수에 담겨 전달됩니다.\n위에서 살펴본 코드로 보면 <code>this.deleted.emit()</code>을 실행했을 때 전달되는 객체는 <code>Hero</code> 객체입니다.</p>\n<p>그런데 지금 작업하고 있는 것은 AngularJS 템플릿이기 때문에 다른 AngularJS 디렉티브처럼 Angular 어트리뷰트도 바인딩할 수 있습니다.\n그래서 <code>ng-repeat</code>로 배열을 순회할 때도 다음과 같이 사용할 수 있습니다:</p>\n<code-example path=\"upgrade-module/src/index-downgrade-io.html\" region=\"userepeatedcomponent\">\n&#x3C;div ng-controller=\"MainController as mainCtrl\">\n  &#x3C;hero-detail [hero]=\"hero\"\n               (deleted)=\"mainCtrl.onDelete($event)\"\n               ng-repeat=\"hero in mainCtrl.heroes\">\n  &#x3C;/hero-detail>\n&#x3C;/div>\n\n</code-example>\n<a id=\"using-angularjs-component-directives-from-angular-code\"></a>\n<!--\n### Using AngularJS Component Directives from Angular Code\n-->\n<h3 id=\"angular-영역에-angularjs-컴포넌트-사용하기\">Angular 영역에 AngularJS 컴포넌트 사용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#angular-영역에-angularjs-컴포넌트-사용하기\"><i class=\"material-icons\">link</i></a></h3>\n<img src=\"generated/images/guide/upgrade/a-to-ajs.png\" alt=\"Using an AngularJS component from Angular code\" class=\"left\" width=\"250\" height=\"44\">\n<!--\nSo, you can write an Angular component and then use it from AngularJS\ncode. This is useful when you start to migrate from lower-level\ncomponents and work your way up. But in some cases it is more convenient\nto do things in the opposite order: To start with higher-level components\nand work your way down. This too can be done using the `upgrade/static`.\nYou can *upgrade* AngularJS component directives and then use them from\nAngular.\n\nNot all kinds of AngularJS directives can be upgraded. The directive\nreally has to be a *component directive*, with the characteristics\n[described in the preparation guide above](guide/upgrade#using-component-directives).\nThe safest bet for ensuring compatibility is using the\n[component API](https://docs.angularjs.org/api/ng/type/angular.Module)\nintroduced in AngularJS 1.5.\n\nA simple example of an upgradable component is one that just has a template\nand a controller:\n-->\n<p>이제는 Angular 컴포넌트를 정의할 수 있고 이 컴포넌트를 AngularJS 영역에 사용할 수 있습니다.\nAngularJS 애플리케이션을 가장 안쪽 컴포넌트부터 작업할 때에도 이 방식을 활용할 수 있습니다.\n하지만 반대 방향으로 작업하는 것이 편할 때도 있습니다.\n가장 바깥쪽에 있는 컴포넌트부터 시작해서 안쪽 컴포넌트로 나아가는 방향인데, 이 경우에도 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> 패키지를 사용합니다.\nAngularJS 컴포넌트 디렉티브는 Angular 컴포넌트로 <em>업그레이드</em>할 수 있습니다.</p>\n<p>AngularJS에 있는 모든 디렉티브를 업그레이드할 수 있는 것은 아닙니다.\n업그레이드할 수 있는 것은 <em>컴포넌트 디렉티브</em> 이며, <a href=\"guide/upgrade#using-component-directives\">위에서 설명한 조건</a>을 갖추고 있어야 합니다.\n좀 더 자세하게 이야기하면 AngularJS 1.5에 도입된 <a href=\"https://docs.angularjs.org/api/ng/type/angular.Module\">컴포넌트 API</a>를 사용한 컴포넌트가 업그레이드하기 쉽습니다.</p>\n<p>다음과 같이 <code>template</code>과 <code>controller</code>로 구성된 AngularJS 컴포넌트가 있다고 합시다:</p>\n<code-example path=\"upgrade-module/src/app/upgrade-static/hero-detail.component.ts\" region=\"hero-detail\" header=\"hero-detail.component.ts\">\nexport const heroDetail = {\n  template: `\n    &#x3C;h2>Windstorm details!&#x3C;/h2>\n    &#x3C;div>&#x3C;label>id: &#x3C;/label>1&#x3C;/div>\n  `,\n  controller: function HeroDetailController() {\n  }\n};\n\n</code-example>\n<!--\nYou can *upgrade* this component to Angular using the `UpgradeComponent` class.\nBy creating a new Angular **directive** that extends `UpgradeComponent` and doing a `super` call\ninside its constructor, you have a fully upgraded AngularJS component to be used inside Angular.\nAll that is left is to add it to `AppModule`'s `declarations` array.\n-->\n<p>이 컴포넌트는 <code><a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a></code>를 상속받은 클래스의 생성자에서 <code>super</code> 함수를 실행하면 <strong>업그레이드 된</strong> Angular <strong>디렉티브</strong> 를 정의할 수 있으며, Angular 영역에서도 AngularJS의 모든 기능을 활용할 수 있습니다.\n이제는 업그레이드한 AngularJS 컴포넌트를 <code>AppModule</code>의 <code>declarations</code>에 등록하면 됩니다.</p>\n<code-example path=\"upgrade-module/src/app/upgrade-static/hero-detail.component.ts\" region=\"hero-detail-upgrade\" header=\"hero-detail.component.ts\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>, <a href=\"api/core/SimpleChanges\" class=\"code-anchor\">SimpleChanges</a> } from '@angular/core';\nimport { <a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: 'hero-detail'\n})\nexport class HeroDetailDirective extends <a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a> {\n  constructor(elementRef: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, injector: <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>) {\n    super('heroDetail', elementRef, injector);\n  }\n}\n\n</code-example>\n<code-example path=\"upgrade-module/src/app/upgrade-static/app.module.ts\" region=\"hero-detail-upgrade\" header=\"app.module.ts\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>\n  ],\n  declarations: [\n    HeroDetailDirective,\n/* . . . */\n  ]\n})\nexport class AppModule {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\nUpgraded components are Angular **directives**, instead of **components**, because Angular\nis unaware that AngularJS will create elements under it. As far as Angular knows, the upgraded\ncomponent is just a directive - a tag - and Angular doesn't have to concern itself with\nits children.\n-->\n<p>이렇게 업그레이드한 AngularJS 컴포넌트는 Angular <strong>컴포넌트</strong>가 아니라 <strong>디렉티브</strong>입니다.\nAngular와는 다르게 AngularJS는 호스트 엘리먼트 안쪽으로 컴포넌트를 구성하기 때문이며, 이런 방식 때문에 Angular는 컴포넌트 안쪽을 신경쓸 필요가 없습니다.</p>\n</div>\n<!--\nAn upgraded component may also have inputs and outputs, as defined by\nthe scope/controller bindings of the original AngularJS component\ndirective. When you use the component from an Angular template,\nprovide the inputs and outputs using **Angular template syntax**,\nobserving the following rules:\n-->\n<p>AngularJS 컴포넌트에는 <code>scope</code>나 <code>controller</code>에 정의된 입출력 프로퍼티가 있을 수 있습니다.\n이 프로퍼티들은 Angular 템플릿에서도 <strong>Angular 템플릿 문법</strong>을 사용해서 연결할 수 있습니다:</p>\n<table>\n  <tbody><tr>\n    <th>\n    </th>\n    <th>\n      <!--\n      Binding definition\n      -->\n      바인딩 방법\n    </th>\n    <th>\n      <!--\n      Template syntax\n      -->\n      템플릿 문법\n    </th>\n  </tr>\n  <tr>\n    <th>\n      <!--\n      Attribute binding\n      -->\n      어트리뷰트 바인딩\n    </th>\n    <td>\n<p>      <code>myAttribute: '@myAttribute'</code></p>\n    </td>\n    <td>\n<p>      <code>&#x3C;my-component myAttribute=\"value\"></code></p>\n    </td>\n  </tr>\n  <tr>\n    <th>\n      <!--\n      Expression binding\n      -->\n      표현식 바인딩\n    </th>\n    <td>\n<p>      <code>myOutput: '&#x26;myOutput'</code></p>\n    </td>\n    <td>\n<p>      <code>&#x3C;my-component (myOutput)=\"action()\"></code></p>\n    </td>\n  </tr>\n  <tr>\n    <th>\n      <!--\n      One-way binding\n      -->\n      단방향 바인딩\n    </th>\n    <td>\n<p>      <code>myValue: '&#x3C;myValue'</code></p>\n    </td>\n    <td>\n<p>      <code>&#x3C;my-component [myValue]=\"anExpression\"></code></p>\n    </td>\n  </tr>\n  <tr>\n    <th>\n      <!--\n      Two-way binding\n      -->\n      양방향 바인딩\n    </th>\n    <td>\n<p>      <code>myValue: '=myValue'</code></p>\n    </td>\n    <td>\n      <!--\n      As a two-way binding: `<my-component [(myValue)]=\"anExpression\">`.\n      Since most AngularJS two-way bindings actually only need a one-way binding\n      in practice, `<my-component [myValue]=\"anExpression\">` is often enough.\n      -->\n<p>      양방향 바인딩 문법은 <code>&#x3C;my-component [(myValue)]=\"anExpression\"></code>와 같은 형식입니다.\n그런데 AngularJS에서 사용하는 양방향 바인딩은 일반적으로 단방향 바인딩만으로도 처리할 수 있기 때문에 <code>&#x3C;my-component [myValue]=\"anExpression\"></code>라고만 사용해도 충분합니다.</p>\n    </td>\n  </tr>\n</tbody></table>\n<!--\nFor example, imagine a hero detail AngularJS component directive\nwith one input and one output:\n-->\n<p>히어로의 정보를 표시하는 AngularJS 컴포넌트 디렉티브에 다음과 같은 입출력 프로퍼티가 있다고 합시다:</p>\n<code-example path=\"upgrade-module/src/app/upgrade-io/hero-detail.component.ts\" region=\"hero-detail-io\" header=\"hero-detail.component.ts\">\nexport const heroDetail = {\n  bindings: {\n    hero: '&#x3C;',\n    deleted: '&#x26;'\n  },\n  template: `\n    &#x3C;h2>{{$ctrl.hero.name}} details!&#x3C;/h2>\n    &#x3C;div>&#x3C;label>id: &#x3C;/label>{{$ctrl.hero.id}}&#x3C;/div>\n    &#x3C;button ng-click=\"$ctrl.onDelete()\">Delete&#x3C;/button>\n  `,\n  controller: function HeroDetailController() {\n    this.onDelete = () => {\n      this.deleted(this.hero);\n    };\n  }\n};\n\n</code-example>\n<!--\nYou can upgrade this component to Angular, annotate inputs and outputs in the upgrade directive,\nand then provide the input and output using Angular template syntax:\n-->\n<p>이 컴포넌트는 Angular가 제공하는 <code><a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code>/<code><a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code> 데코레이터와 템플릿 문법을 사용해서 다음과 같이 연결할 수 있습니다:</p>\n<code-example path=\"upgrade-module/src/app/upgrade-io/hero-detail.component.ts\" region=\"hero-detail-io-upgrade\" header=\"hero-detail.component.ts\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/Output\" class=\"code-anchor\">Output</a>, <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a> } from '@angular/core';\nimport { <a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: 'hero-detail'\n})\nexport class HeroDetailDirective extends <a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a> {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() deleted: <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;Hero>;\n\n  constructor(elementRef: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, injector: <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>) {\n    super('heroDetail', elementRef, injector);\n  }\n}\n\n</code-example>\n<code-example path=\"upgrade-module/src/app/upgrade-io/container.component.ts\" header=\"container.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-container',\n  template: `\n    &#x3C;h1>Tour of Heroes&#x3C;/h1>\n    &#x3C;hero-detail [hero]=\"hero\"\n                 (deleted)=\"heroDeleted($event)\">\n    &#x3C;/hero-detail>\n  `\n})\nexport class ContainerComponent {\n  hero = new Hero(1, 'Windstorm');\n  heroDeleted(hero: Hero) {\n    hero.name = 'Ex-' + hero.name;\n  }\n}\n\n\n</code-example>\n<a id=\"projecting-angularjs-content-into-angular-components\"></a>\n<!--\n### Projecting AngularJS Content into Angular Components\n-->\n<h3 id=\"angular-컴포넌트에-angularjs-내용-프로젝션하기\">Angular 컴포넌트에 AngularJS 내용 프로젝션하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#angular-컴포넌트에-angularjs-내용-프로젝션하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\n<img src=\"generated/images/guide/upgrade/ajs-to-a-with-projection.png\" alt=\"Projecting AngularJS content into Angular\" class=\"left\">\n\nWhen you are using a downgraded Angular component from an AngularJS\ntemplate, the need may arise to *transclude* some content into it. This\nis also possible. While there is no such thing as transclusion in Angular,\nthere is a very similar concept called *content projection*. `upgrade/static`\nis able to make these two features interoperate.\n\nAngular components that support content projection make use of an `<ng-content>`\ntag within them. Here's an example of such a component:\n\n<code-example path=\"upgrade-module/src/app/ajs-to-a-projection/hero-detail.component.ts\" header=\"hero-detail.component.ts\">\nimport { Component, Input } from &#39;@angular/core&#39;;\nimport { Hero } from &#39;../hero&#39;;\n\n@Component({\n  selector: &#39;hero-detail&#39;,\n  template: `\n    &lt;h2&gt;{{hero.name}}&lt;/h2&gt;\n    &lt;div&gt;\n      &lt;ng-content&gt;&lt;/ng-content&gt;\n    &lt;/div&gt;\n  `\n})\nexport class HeroDetailComponent {\n  @Input() hero: Hero;\n}\n\n\n</code-example>\n\nWhen using the component from AngularJS, you can supply contents for it. Just\nlike they would be transcluded in AngularJS, they get projected to the location\nof the `<ng-content>` tag in Angular:\n\n<code-example path=\"upgrade-module/src/index-ajs-to-a-projection.html\" region=\"usecomponent\">\n&lt;div ng-controller=&quot;MainController as mainCtrl&quot;&gt;\n  &lt;hero-detail [hero]=&quot;mainCtrl.hero&quot;&gt;\n    &lt;!-- 이 부분에 있는 엘리먼트들이 프로젝션 됩니다. --&gt;\n    &lt;p&gt;{{mainCtrl.hero.description}}&lt;/p&gt;\n  &lt;/hero-detail&gt;\n&lt;/div&gt;\n\n</code-example>\n\n<div class=\"alert is-helpful\">\n\nWhen AngularJS content gets projected inside an Angular component, it still\nremains in \"AngularJS land\" and is managed by the AngularJS framework.\n\n</div>\n-->\n<img src=\"generated/images/guide/upgrade/ajs-to-a-with-projection.png\" alt=\"Projecting AngularJS content into Angular\" class=\"left\" width=\"250\" height=\"48\">\n<p>Angular 컴포넌트를 AngularJS 템플릿에 사용하기 위해 다운그레이드하면서 HTML 조각 일부를 전달해야 하는 경우가 있습니다.\nAngularJS에서는 이 동작을 트랜스클루전(transclusion)이라고 하며 Angular에서는 컨텐츠 프로젝션(content projection)이라고 하는데, <code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code>을 사용하면 두 방식의 호환성을 맞출 수 있습니다.</p>\n<p>Angular에서 프로젝션을 사용하려면 <code>&#x3C;ng-content></code> 태그를 사용합니다.\n이런 컴포넌트가 있다고 합시다:</p>\n<code-example path=\"upgrade-module/src/app/ajs-to-a-projection/hero-detail.component.ts\" header=\"hero-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a> } from '@angular/core';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'hero-detail',\n  template: `\n    &#x3C;h2>{{hero.name}}&#x3C;/h2>\n    &#x3C;div>\n      &#x3C;ng-content>&#x3C;/ng-content>\n    &#x3C;/div>\n  `\n})\nexport class HeroDetailComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n\n\n</code-example>\n<p>이 컴포넌트는 이대로 AngularJS 영역에 사용해도 그대로 동작합니다.</p>\n<code-example path=\"upgrade-module/src/index-ajs-to-a-projection.html\" region=\"usecomponent\">\n&#x3C;div ng-controller=\"MainController as mainCtrl\">\n  &#x3C;hero-detail [hero]=\"mainCtrl.hero\">\n    &#x3C;!-- 이 부분에 있는 엘리먼트들이 프로젝션 됩니다. -->\n    &#x3C;p>{{mainCtrl.hero.description}}&#x3C;/p>\n  &#x3C;/hero-detail>\n&#x3C;/div>\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>Angular 컴포넌트에 프로젝션 된 AngularJS의 내용물은 여전히 \"AngularJS 세계\"에 존재하며 AngularJS 프레임워크가 관리합니다.</p>\n</div>\n<a id=\"transcluding-angular-content-into-angularjs-component-directives\"></a>\n<!--\n### Transcluding Angular Content into AngularJS Component Directives\n-->\n<h3 id=\"angularjs-컴포넌트-디렉티브에-angular-내용-트랜스클루전하기\">AngularJS 컴포넌트 디렉티브에 Angular 내용 트랜스클루전하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#angularjs-컴포넌트-디렉티브에-angular-내용-트랜스클루전하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\n<img src=\"generated/images/guide/upgrade/a-to-ajs-with-transclusion.png\" alt=\"Projecting Angular content into AngularJS\" class=\"left\">\n\nJust as you can project AngularJS content into Angular components,\nyou can *transclude* Angular content into AngularJS components, whenever\nyou are using upgraded versions from them.\n\nWhen an AngularJS component directive supports transclusion, it may use\nthe `ng-transclude` directive in its template to mark the transclusion\npoint:\n\n<code-example path=\"upgrade-module/src/app/a-to-ajs-transclusion/hero-detail.component.ts\" header=\"hero-detail.component.ts\">\nexport const heroDetail = {\n  bindings: {\n    hero: &#39;=&#39;\n  },\n  template: `\n    &lt;h2&gt;{{$ctrl.hero.name}}&lt;/h2&gt;\n    &lt;div&gt;\n      &lt;ng-transclude&gt;&lt;/ng-transclude&gt;\n    &lt;/div&gt;\n  `,\n  transclude: true\n};\n\n</code-example>\n\nIf you upgrade this component and use it from Angular, you can populate\nthe component tag with contents that will then get transcluded:\n\n<code-example path=\"upgrade-module/src/app/a-to-ajs-transclusion/container.component.ts\" header=\"container.component.ts\">\nimport { Component } from &#39;@angular/core&#39;;\nimport { Hero } from &#39;../hero&#39;;\n\n@Component({\n  selector: &#39;my-container&#39;,\n  template: `\n    &lt;hero-detail [hero]=&quot;hero&quot;&gt;\n      &lt;!-- 이 부분에 있는 엘리먼트들이 트랜스클루전 됩니다. --&gt;\n      &lt;p&gt;{{hero.description}}&lt;/p&gt;\n    &lt;/hero-detail&gt;\n  `\n})\nexport class ContainerComponent {\n  hero = new Hero(1, &#39;Windstorm&#39;, &#39;Specific powers of controlling winds&#39;);\n}\n\n\n</code-example>\n-->\n<img src=\"generated/images/guide/upgrade/a-to-ajs-with-transclusion.png\" alt=\"Projecting Angular content into AngularJS\" class=\"left\" width=\"250\" height=\"48\">\n<p>AngularJS의 내용을 Angular 컴포넌트에 프로젝션하듯이 Angular 내용도 AngularJS 컴포넌트 디렉티브로 <em>트랜스클루전(transclude)</em> 할 수 있습니다.\n이 때 AngularJS 컴포넌트 디렉티브는 업그레이드된 것이어야 합니다.</p>\n<p>AngularJS 컴포넌트 디렉티브에 트랜스클루전하려면 컨텐츠가 표시될 위치를 지정하기 위해 다음과 같이 <code>ng-transclude</code> 디렉티브를 사용해야 합니다:</p>\n<code-example path=\"upgrade-module/src/app/a-to-ajs-transclusion/hero-detail.component.ts\" header=\"hero-detail.component.ts\">\nexport const heroDetail = {\n  bindings: {\n    hero: '='\n  },\n  template: `\n    &#x3C;h2>{{$ctrl.hero.name}}&#x3C;/h2>\n    &#x3C;div>\n      &#x3C;ng-transclude>&#x3C;/ng-transclude>\n    &#x3C;/div>\n  `,\n  transclude: true\n};\n\n</code-example>\n<p>그러면 이 컴포넌트를 업그레이드한 후에 Angular 영역에서 다음과 같이 사용할 수 있습니다:</p>\n<code-example path=\"upgrade-module/src/app/a-to-ajs-transclusion/container.component.ts\" header=\"container.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-container',\n  template: `\n    &#x3C;hero-detail [hero]=\"hero\">\n      &#x3C;!-- 이 부분에 있는 엘리먼트들이 트랜스클루전 됩니다. -->\n      &#x3C;p>{{hero.description}}&#x3C;/p>\n    &#x3C;/hero-detail>\n  `\n})\nexport class ContainerComponent {\n  hero = new Hero(1, 'Windstorm', 'Specific powers of controlling winds');\n}\n\n\n</code-example>\n<a id=\"making-angularjs-dependencies-injectable-to-angular\"></a>\n<!--\n### Making AngularJS Dependencies Injectable to Angular\n-->\n<h3 id=\"angularjs-의존성-객체를-angular에-등록하기\">AngularJS 의존성 객체를 Angular에 등록하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#angularjs-의존성-객체를-angular에-등록하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nWhen running a hybrid app, you may encounter situations where you need to inject\nsome AngularJS dependencies into your Angular code.\nMaybe you have some business logic still in AngularJS services.\nMaybe you want access to AngularJS's built-in services like `$location` or `$timeout`.\n\nIn these situations, it is possible to *upgrade* an AngularJS provider to\nAngular. This makes it possible to then inject it somewhere in Angular\ncode. For example, you might have a service called `HeroesService` in AngularJS:\n\n<code-example path=\"upgrade-module/src/app/ajs-to-a-providers/heroes.service.ts\" header=\"heroes.service.ts\">\nimport { Hero } from &#39;../hero&#39;;\n\nexport class HeroesService {\n  get() {\n    return [\n      new Hero(1, &#39;Windstorm&#39;),\n      new Hero(2, &#39;Spiderman&#39;)\n    ];\n  }\n}\n\n\n</code-example>\n\nYou can upgrade the service using a Angular [factory provider](guide/dependency-injection-providers#factory-providers)\nthat requests the service from the AngularJS `$injector`.\n\nMany developers prefer to declare the factory provider in a separate `ajs-upgraded-providers.ts` file\nso that they are all together, making it easier to reference them, create new ones and\ndelete them once the upgrade is over.\n\nIt's also recommended to export the `heroesServiceFactory` function so that Ahead-of-Time\ncompilation can pick it up.\n\n<div class=\"alert is-helpful\">\n\n**Note:** The 'heroes' string inside the factory refers to the AngularJS `HeroesService`.\nIt is common in AngularJS apps to choose a service name for the token, for example \"heroes\",\nand append the \"Service\" suffix to create the class name.\n\n</div>\n\n<code-example path=\"upgrade-module/src/app/ajs-to-a-providers/ajs-upgraded-providers.ts\" header=\"ajs-upgraded-providers.ts\">\nimport { HeroesService } from &#39;./heroes.service&#39;;\n\nexport function heroesServiceFactory(i: any) {\n  return i.get(&#39;heroes&#39;);\n}\n\nexport const heroesServiceProvider = {\n  provide: HeroesService,\n  useFactory: heroesServiceFactory,\n  deps: [&#39;$injector&#39;]\n};\n\n\n</code-example>\n\nYou can then provide the service to Angular by adding it to the `@NgModule`:\n\n<code-example path=\"upgrade-module/src/app/ajs-to-a-providers/app.module.ts\" region=\"register\" header=\"app.module.ts\">\nimport { heroesServiceProvider } from &#39;./ajs-upgraded-providers&#39;;\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    UpgradeModule\n  ],\n  providers: [\n    heroesServiceProvider\n  ],\n/* . . . */\n})\nexport class AppModule {\n  constructor(private upgrade: UpgradeModule) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, [&#39;heroApp&#39;], { strictDi: true });\n  }\n}\n\n</code-example>\n\nThen use the service inside your component by injecting it in the component constructor using its class as a type annotation:\n\n<code-example path=\"upgrade-module/src/app/ajs-to-a-providers/hero-detail.component.ts\" header=\"hero-detail.component.ts\">\nimport { Component } from &#39;@angular/core&#39;;\nimport { HeroesService } from &#39;./heroes.service&#39;;\nimport { Hero } from &#39;../hero&#39;;\n\n@Component({\n  selector: &#39;hero-detail&#39;,\n  template: `\n    &lt;h2&gt;{{hero.id}}: {{hero.name}}&lt;/h2&gt;\n  `\n})\nexport class HeroDetailComponent {\n  hero: Hero;\n  constructor(heroes: HeroesService) {\n    this.hero = heroes.get()[0];\n  }\n}\n\n\n</code-example>\n\n<div class=\"alert is-helpful\">\n\nIn this example you upgraded a service class.\nYou can use a TypeScript type annotation when you inject it. While it doesn't\naffect how the dependency is handled, it enables the benefits of static type\nchecking. This is not required though, and any AngularJS service, factory, or\nprovider can be upgraded.\n\n</div>\n-->\n<p>하이브리드 앱을 실행하다보면 AngularJS의 의존성 객체를 Angular에 의존성으로 주입해야 하는 경우가 있습니다.\nAngularJS에 비즈니스 로직을 작성했거나 AngularJS의 내장 서비스인 <code>$location</code>이나 <code>$timeout</code>을 사용하는 경우가 그렇습니다.</p>\n<p>이런 경우에는 AngularJS 프로바이더를 Angular용으로 <em>업그레이드</em> 하면 Angular 코드에 의존성으로 주입할 수 있습니다.\nAngularJS로 작성한 <code>HeroesService</code>가 있다고 합시다:</p>\n<code-example path=\"upgrade-module/src/app/ajs-to-a-providers/heroes.service.ts\" header=\"heroes.service.ts\">\nimport { Hero } from '../hero';\n\nexport class HeroesService {\n  get() {\n    return [\n      new Hero(1, 'Windstorm'),\n      new Hero(2, 'Spiderman')\n    ];\n  }\n}\n\n\n</code-example>\n<p>이 서비스를 업그레이드 하려면 AngularJS <code>$injector</code>로 서비스 인스턴스를 가져와서 Angular <a href=\"guide/dependency-injection-providers#factory-providers\">팩토리 프로바이더</a>로 등록하면 됩니다.</p>\n<p>일반적으로 AngularJS 서비스 프로바이더는 <code>ajs-upgraded-providers.ts</code> 파일에 모두 모아서 선언하는 것이 좋습니다.\n이렇게 구현하면 서비스를 참조하기 더 편하며 업그레이드가 진행될 때마다 하나씩 제거하기도 수월합니다.</p>\n<p>그리고 이렇게 작성한 팩토리 프로바이더는 AOT 컴파일러가 접근할 수 있도록 <code>heroesServiceFactory</code> 함수도 파일 외부로 공개하는 것을 권장합니다.</p>\n<div class=\"alert is-helpful\">\n<p><strong>참고:</strong> 팩토리 함수 안에서 사용한 <code>heroes</code> 문자열은 AngularJS <code>HeroesService</code>를 가리키기 위한 것입니다.\n일반적으로 AngularJS 앱에서는 서비스 토큰을 문자열로 사용하며, 클래스 이름에 \"Service\" 접미사를 붙입니다.</p>\n</div>\n<code-example path=\"upgrade-module/src/app/ajs-to-a-providers/ajs-upgraded-providers.ts\" header=\"ajs-upgraded-providers.ts\">\nimport { HeroesService } from './heroes.service';\n\nexport function heroesServiceFactory(i: any) {\n  return i.get('heroes');\n}\n\nexport const heroesServiceProvider = {\n  provide: HeroesService,\n  useFactory: heroesServiceFactory,\n  deps: ['$injector']\n};\n\n\n</code-example>\n<p>이렇게 업그레이드한 서비스는 Angular <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>에 다음과 같이 등록합니다:</p>\n<code-example path=\"upgrade-module/src/app/ajs-to-a-providers/app.module.ts\" region=\"register\" header=\"app.module.ts\">\nimport { heroesServiceProvider } from './ajs-upgraded-providers';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>\n  ],\n  providers: [\n    heroesServiceProvider\n  ],\n/* . . . */\n})\nexport class AppModule {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<p>이제 컴포넌트 생성자에 원하는 서비스의 타입을 지정하면 해당 서비스의 인스턴스를 주입받을 수 있습니다:</p>\n<code-example path=\"upgrade-module/src/app/ajs-to-a-providers/hero-detail.component.ts\" header=\"hero-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { HeroesService } from './heroes.service';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'hero-detail',\n  template: `\n    &#x3C;h2>{{hero.id}}: {{hero.name}}&#x3C;/h2>\n  `\n})\nexport class HeroDetailComponent {\n  hero: Hero;\n  constructor(heroes: HeroesService) {\n    this.hero = heroes.get()[0];\n  }\n}\n\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>이 섹션에서는 AngularJS 서비스 클래스를 업그레이드하는 방법에 대해 알아봤습니다.\n이 때 TypeScript 타입 어노테이션을 사용할 수도 있는데 이 방식은 의존성 객체를 직접 조작하지 않지만 정적 타입을 체크할 수 있기 때문에 도움이 될 수 있습니다.\n타입 어노테이션은 옵션 사항이며 AngularJS 서비스, 팩토리는 어떤 것이든 업그레이드할 수 있습니다.</p>\n</div>\n<a id=\"making-angular-dependencies-injectable-to-angularjs\"></a>\n<!--\n### Making Angular Dependencies Injectable to AngularJS\n-->\n<h3 id=\"angular-의존성-객체를-angularjs에-등록하기\">Angular 의존성 객체를 AngularJS에 등록하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#angular-의존성-객체를-angularjs에-등록하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn addition to upgrading AngularJS dependencies, you can also *downgrade*\nAngular dependencies, so that you can use them from AngularJS. This can be\nuseful when you start migrating services to Angular or creating new services\nin Angular while retaining components written in AngularJS.\n\nFor example, you might have an Angular service called `Heroes`:\n\n<code-example path=\"upgrade-module/src/app/a-to-ajs-providers/heroes.ts\" header=\"heroes.ts\">\nimport { Injectable } from &#39;@angular/core&#39;;\nimport { Hero } from &#39;../hero&#39;;\n\n@Injectable()\nexport class Heroes {\n  get() {\n    return [\n      new Hero(1, &#39;Windstorm&#39;),\n      new Hero(2, &#39;Spiderman&#39;)\n    ];\n  }\n}\n\n\n</code-example>\n\nAgain, as with Angular components, register the provider with the `NgModule` by adding it to the module's `providers` list.\n\n<code-example path=\"upgrade-module/src/app/a-to-ajs-providers/app.module.ts\" region=\"ngmodule\" header=\"app.module.ts\">\nimport { Heroes } from &#39;./heroes&#39;;\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    UpgradeModule\n  ],\n  providers: [ Heroes ]\n})\nexport class AppModule {\n  constructor(private upgrade: UpgradeModule) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, [&#39;heroApp&#39;], { strictDi: true });\n  }\n}\n\n</code-example>\n\nNow wrap the Angular `Heroes` in an *AngularJS factory function* using `downgradeInjectable()`\nand plug the factory into an AngularJS module.\nThe name of the AngularJS dependency is up to you:\n\n<code-example path=\"upgrade-module/src/app/a-to-ajs-providers/app.module.ts\" region=\"register\" header=\"app.module.ts\">\nimport { Heroes } from &#39;./heroes&#39;;\n/* . . . */\nimport { downgradeInjectable } from &#39;@angular/upgrade/static&#39;;\n\nangular.module(&#39;heroApp&#39;, [])\n  .factory(&#39;heroes&#39;, downgradeInjectable(Heroes))\n  .component(&#39;heroDetail&#39;, heroDetailComponent);\n\n</code-example>\n\nAfter this, the service is injectable anywhere in AngularJS code:\n\n<code-example path=\"upgrade-module/src/app/a-to-ajs-providers/hero-detail.component.ts\" header=\"hero-detail.component.ts\">\nexport const heroDetailComponent = {\n  template: `\n    &lt;h2&gt;{{$ctrl.hero.id}}: {{$ctrl.hero.name}}&lt;/h2&gt;\n  `,\n  controller: [&#39;heroes&#39;, function(heroes: Heroes) {\n    this.hero = heroes.get()[0];\n  }]\n};\n\n\n</code-example>\n-->\n<p>AngularJS 의존성 객체를 업그레이드하는 것과 비슷하게 Angular 의존성 객체도 <em>다운그레이드해서</em> AngularJS에 주입할 수 있습니다.\n이 과정은 AngularJS 서비스를 Angular로 전환할 때나 Angular 쪽에 새로 만든 서비스를 AngularJS 컴포넌트에 적용할 때 활용할 수 있습니다.</p>\n<p>다음과 같은 <code>Heroes</code> Angular 서비스가 있다고 합시다:</p>\n<code-example path=\"upgrade-module/src/app/a-to-ajs-providers/heroes.ts\" header=\"heroes.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Heroes {\n  get() {\n    return [\n      new Hero(1, 'Windstorm'),\n      new Hero(2, 'Spiderman')\n    ];\n  }\n}\n\n\n</code-example>\n<p>이 서비스는 Angular 컴포넌트에 주입하기 위해 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>의 <code>providers</code> 배열에 등록할 수 있습니다.</p>\n<code-example path=\"upgrade-module/src/app/a-to-ajs-providers/app.module.ts\" region=\"ngmodule\" header=\"app.module.ts\">\nimport { Heroes } from './heroes';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>\n  ],\n  providers: [ Heroes ]\n})\nexport class AppModule {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<p>Angular <code>Heroes</code> 서비스는 <code><a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>()</code> 함수를 사용해서 <em>AngularJS 팩토리 함수</em>로 전환해서 AngularJS 모듈에 등록할 수 있습니다.\n이 때 AngularJS에서 어떤 이름을 사용할지는 개발자가 결정하면 됩니다:</p>\n<code-example path=\"upgrade-module/src/app/a-to-ajs-providers/app.module.ts\" region=\"register\" header=\"app.module.ts\">\nimport { Heroes } from './heroes';\n/* . . . */\nimport { <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nangular.module('heroApp', [])\n  .factory('heroes', <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>(Heroes))\n  .component('heroDetail', heroDetailComponent);\n\n</code-example>\n<p>이렇게 작성하고 나면 이 서비스는 AngularJS 코드에 다음과 같이 의존성으로 주입할 수 있습니다:</p>\n<code-example path=\"upgrade-module/src/app/a-to-ajs-providers/hero-detail.component.ts\" header=\"hero-detail.component.ts\">\nexport const heroDetailComponent = {\n  template: `\n    &#x3C;h2>{{$ctrl.hero.id}}: {{$ctrl.hero.name}}&#x3C;/h2>\n  `,\n  controller: ['heroes', function(heroes: Heroes) {\n    this.hero = heroes.get()[0];\n  }]\n};\n\n\n</code-example>\n<!--\n## Lazy Loading AngularJS\n-->\n<h2 id=\"angularjs의-지연-로딩\">AngularJS의 지연 로딩<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#angularjs의-지연-로딩\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nWhen building applications, you want to ensure that only the required resources are loaded when necessary. Whether that be loading of assets or code, making sure everything that can be deferred until needed keeps your application running efficiently. This is especially true when running different frameworks in the same application.\n\n[Lazy loading](guide/glossary#lazy-loading) is a technique that defers the loading of required assets and code resources until they are actually used. This reduces startup time and increases efficiency, especially when running different frameworks in the same application.\n\nWhen migrating large applications from AngularJS to Angular using a hybrid approach, you want to migrate some of the most commonly used features first, and only use the less commonly used features if needed. Doing so helps you ensure that the application is still providing a seamless experience for your users while you are migrating.\n\nIn most environments where both Angular and AngularJS are used to render the application, both frameworks are loaded in the initial bundle being sent to the client. This results in both increased bundle size and possible reduced performance.\n\nOverall application performance is affected in cases where the user stays on Angular-rendered pages because the AngularJS framework and application are still loaded and running, even if they are never accessed.\n\nYou can take steps to mitigate both bundle size and performance issues. By isolating your AngularJS app to a separate bundle, you can take advantage of [lazy loading](guide/glossary#lazy-loading) to load, bootstrap, and render the AngularJS application only when needed. This strategy reduces your initial bundle size, defers any potential impact from loading both frameworks until absolutely necessary, and keeps your application running as efficiently as possible.\n\nThe steps below show you how to do the following:\n\n* Setup a callback function for your AngularJS bundle.\n* Create a service that lazy loads and bootstraps your AngularJS app.\n* Create a routable component for AngularJS content\n* Create a custom `matcher` function for AngularJS-specific URLs and configure the Angular `Router` with the custom matcher for AngularJS routes.\n-->\n<p>애플리케이션을 개발하다보면 애플리케이션 리소스를 필요한 경우에만 불러오고 싶은 경우가 있습니다.\n이 리소스가 정적 파일일 수도 있고 코드일 수도 있지만, 이와 관계없이 애플리케이션 리소스는 꼭 필요한 경우가 되기 전까지는 내려받지 않는 것이 애플리케이션에도 효율적입니다.\n한 애플리케이션 안에 실행되는 프레임워크가 여러개라면 더욱 그렇습니다.</p>\n<p><a href=\"guide/glossary#lazy-loading\">지연 로딩(lazy loading)</a>은 애플리케이션 리소스가 실제로 필요할 때까지 로딩 시점을 지연시키는 테크닉입니다.\n이 테크닉을 활용하면 애플리케이션의 초기 실행시간을 줄일 수 있으며 애플리케이션을 효율적으로 관리할 수 있습니다.</p>\n<p>대규모 AngularJS 애플리케이션을 하이브리드로 실행하면서 Angular 버전으로 업그레이드할 때는, 가장 많이 사용되는 공통기능을 먼저 작업하고 일부에만 사용되는 로직은 가장 나중에 작업하는 것이 일반적입니다.\n이 작업을 진행되는 동안에도 애플리케이션 사용자는 앱이 이전과 동일하게 동작한다고 느낄 것입니다.</p>\n<p>Angular와 AngularJS가 함께 실행되는 환경은 애플리케이션을 렌더링하기 위해 두 프레임워크가 모두 번들 결과물에 포함되어 클라이언트로 전달되어야 합니다.\n따라서 번들 결과물의 크기도 커지고 애플리케이션 실행 성능도 저하될 수 있습니다.</p>\n<p>하이브리드 앱에서는 Angular로 렌더링한 페이지에 사용자가 머물러 있더라도 AngularJS 프레임워크와 애플리케이션이 여전히 로드되고 실행되기 때문에 앱 전체 성능에 영향을 줍니다.</p>\n<p>번들 결과물의 크기나 성능 저하를 줄일 수 있는 방법이 있습니다.\nAngularJS 애플리케이션을 따로 빌드하고 필요할 때 <a href=\"guide/glossary#lazy-loading\">지연 로딩</a>하면 되는데, 이 방식을 활요하면 초기 실행에 필요한 빌드 결과물의 크기가 작아지며 두 프레임워크가 함께 실행되기 때문에 발생할 수 있는 충돌 가능성도 줄일 수 있습니다.\n애플리케이션을 좀 더 효율적으로 관리할 수 있다고도 볼 수 있습니다.</p>\n<p>이렇게 구현하려면 다음 과정대로 진행하면 됩니다:</p>\n<ul>\n<li>AngularJS 번들용 콜백 함수를 추가합니다.</li>\n<li>지연로딩용 서비스를 정의합니다.</li>\n<li>라우팅 컴포넌트를 정의합니다.</li>\n<li>AngularJS용 URL에 사용할 커스텀 <code>matcher</code> 함수를 정의하고 이 매처를 Angular <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>에서 AngularJS 라우팅 규칙과 연결합니다.</li>\n</ul>\n<!--\n### Create a service to lazy load AngularJS\n-->\n<h3 id=\"angularjs-애플리케이션을-지연-로딩하는-서비스-정의하기\">AngularJS 애플리케이션을 지연 로딩하는 서비스 정의하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#angularjs-애플리케이션을-지연-로딩하는-서비스-정의하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAs of Angular version 8, lazy loading code can be accomplished simply by using the dynamic import syntax `import('...')`. In your application, you create a new service that uses dynamic imports to lazy load AngularJS.\n\n<code-example path=\"upgrade-lazy-load-ajs/src/app/lazy-loader.service.ts\" header=\"src/app/lazy-loader.service.ts\">\nimport { Injectable } from &#39;@angular/core&#39;;\nimport * as angular from &#39;angular&#39;;\n\n@Injectable({\n  providedIn: &#39;root&#39;\n})\nexport class LazyLoaderService {\n  private app: angular.auto.IInjectorService;\n\n  load(el: HTMLElement): void {\n    import(&#39;./angularjs-app&#39;).then(app =&gt; {\n      try {\n        this.app = app.bootstrap(el);\n      } catch (e) {\n        console.error(e);\n      }\n    });\n  }\n\n  destroy() {\n    if (this.app) {\n      this.app.get(&#39;$rootScope&#39;).$destroy();\n    }\n  }\n}\n\n\n</code-example>\n\nThe service uses the `import()` method to load your bundled AngularJS application lazily. This decreases the initial bundle size of your application as you're not loading code your user doesn't need yet. You also need to provide a way to _bootstrap_ the application manually after it has been loaded. AngularJS provides a way to manually bootstrap an application using the [angular.bootstrap()](https://docs.angularjs.org/api/ng/function/angular.bootstrap) method with a provided HTML element. Your AngularJS app should also expose a `bootstrap` method that bootstraps the AngularJS app.\n\nTo ensure any necessary teardown is triggered in the AngularJS app, such as removal of global listeners, you also implement a method to call the `$rootScope.destroy()` method.\n\n<code-example path=\"upgrade-lazy-load-ajs/src/app/angularjs-app/index.ts\" header=\"angularjs-app\">\nimport * as angular from &#39;angular&#39;;\nimport &#39;angular-route&#39;;\n\nconst appModule = angular.module(&#39;myApp&#39;, [\n  &#39;ngRoute&#39;\n])\n.config([&#39;$routeProvider&#39;, &#39;$locationProvider&#39;,\n  function config($routeProvider, $locationProvider) {\n    $locationProvider.html5Mode(true);\n\n    $routeProvider.\n      when(&#39;/users&#39;, {\n        template: `\n          &lt;p&gt;\n            Users Page\n          &lt;/p&gt;\n        `\n      }).\n      otherwise({\n        template: &#39;&#39;\n      });\n  }]\n);\n\nexport function bootstrap(el: HTMLElement) {\n  return angular.bootstrap(el,  [appModule.name]);\n}\n\n\n</code-example>\n\nYour AngularJS application is configured with only the routes it needs to render content. The remaining routes in your application are handled by the Angular Router. The exposed `bootstrap` method is called in your Angular app to bootstrap the AngularJS application after the bundle is loaded.\n\n<div class=\"alert is-important\">\n\n**Note:** After AngularJS is loaded and bootstrapped, listeners such as those wired up in your route configuration will continue to listen for route changes. To ensure listeners are shut down when AngularJS isn't being displayed, configure an `otherwise` option with the [$routeProvider](https://docs.angularjs.org/api/ngRoute/provider/$routeProvider) that renders an empty template. This assumes all other routes will be handled by Angular.\n\n</div>\n-->\n<p>Angular 8 버전부터는 지연 로딩을 지원하는 코드가 동적 로딩을 사용하도록 <code>import('...')</code>와 같은 형태로 단순해졌습니다.\nAngularJS 애플리케이션을 지연 로딩하는 Angular 서비스는 다음과 같이 정의합니다.</p>\n<code-example path=\"upgrade-lazy-load-ajs/src/app/lazy-loader.service.ts\" header=\"src/app/lazy-loader.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport * as angular from 'angular';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root'\n})\nexport class LazyLoaderService {\n  private app: angular.auto.IInjectorService;\n\n  load(el: HTMLElement): void {\n    import('./angularjs-app').then(app => {\n      try {\n        this.app = app.bootstrap(el);\n      } catch (e) {\n        console.error(e);\n      }\n    });\n  }\n\n  destroy() {\n    if (this.app) {\n      this.app.get('$rootScope').$destroy();\n    }\n  }\n}\n\n\n</code-example>\n<p>이 서비스는 <code>import()</code> 메소드를 활용해서 AngularJS 애플리케이션을 지연로딩합니다.\n따라서 AngularJS 앱은 이제 초기 실행에 필요한 빌드 결과물에 포함되지 않으며, 그만큼 첫 실행할 때 받아야 할 빌드 결과물의 크기도 작아집니다.\nAngularJS 앱을 지연 로딩한 후에는 이 앱을 수동으로 <em>부트스트랩</em> 해야 하는데, 이 과정은 <a href=\"https://docs.angularjs.org/api/ng/function/angular.bootstrap\">angular.bootstrap()</a> 메소드로 처리할 수 있습니다.</p>\n<p>그리고 이 서비스에는 AngularJS 앱이 종료될 때 필요한 로직을 실행하기 위해 <code>$rootScope.destroy()</code> 메소드를 실행하는 <code>destroy()</code> 함수를 정의했습니다.</p>\n<code-example path=\"upgrade-lazy-load-ajs/src/app/angularjs-app/index.ts\" header=\"angularjs-app\">\nimport * as angular from 'angular';\nimport 'angular-route';\n\nconst appModule = angular.module('myApp', [\n  'ngRoute'\n])\n.config(['$routeProvider', '$locationProvider',\n  function config($routeProvider, $locationProvider) {\n    $locationProvider.html5Mode(true);\n\n    $routeProvider.\n      when('/users', {\n        template: `\n          &#x3C;p>\n            Users Page\n          &#x3C;/p>\n        `\n      }).\n      otherwise({\n        template: ''\n      });\n  }]\n);\n\nexport function bootstrap(el: HTMLElement) {\n  return angular.bootstrap(el,  [appModule.name]);\n}\n\n\n</code-example>\n<p>아직 AngularJS 앱에 정의된 라우팅 규칙들은 화면을 표시하기 위한 용도로만 구성되었습니다.\n그리고 애플리케이션의 전체 라우팅은 Angular 라우터가 처리합니다.\nAngular 앱이 AngularJS 애플리케이션을 로딩한 후에 실행할 수 있도록 <code>bootstrap</code> 메소드를 다음과 같이 정의했습니다.</p>\n<div class=\"alert is-important\">\n<p><strong>참고:</strong> AngularJS 앱을 로드하고 부트스트랩한 후에는 AngularJS 라우팅 설정에서도 라우팅 규칙이 변경되는 것을 감지합니다.\n그러면 AngularJS 쪽의 리스너를 제거하기 위해 AngularJS 라우팅 규칙에 <code>otherwise</code> 옵션을 추가하고 <a href=\"https://docs.angularjs.org/api/ngRoute/provider/$routeProvider\">$routeProvider</a>을 연결해야 합니다.\n이 라우팅 규칙은 Angular가 관리합니다.</p>\n</div>\n<!--\n### Create a component to render AngularJS content\n-->\n<h3 id=\"angularjs-앱을-렌더링하는-컴포넌트-생성하기\">AngularJS 앱을 렌더링하는 컴포넌트 생성하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#angularjs-앱을-렌더링하는-컴포넌트-생성하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn your Angular application, you need a component as a placeholder for your AngularJS content. This component uses the service you create to load and bootstrap your AngularJS app after the component is initialized.\n\n<code-example path=\"upgrade-lazy-load-ajs/src/app/angular-js/angular-js.component.ts\" header=\"src/app/angular-js/angular-js.component.ts\">\nimport { Component, OnInit, OnDestroy, ElementRef } from &#39;@angular/core&#39;;\nimport { LazyLoaderService } from &#39;../lazy-loader.service&#39;;\n\n@Component({\n  selector: &#39;app-angular-js&#39;,\n  template: &#39;&lt;div ng-view&gt;&lt;/div&gt;&#39;\n})\nexport class AngularJSComponent implements OnInit, OnDestroy {\n  constructor(\n    private lazyLoader: LazyLoaderService,\n    private elRef: ElementRef\n  ) {}\n\n  ngOnInit() {\n    this.lazyLoader.load(this.elRef.nativeElement);\n  }\n\n\n  ngOnDestroy() {\n    this.lazyLoader.destroy();\n  }\n}\n\n\n</code-example>\n\nWhen the Angular Router matches a route that uses AngularJS, the `AngularJSComponent` is rendered, and the content is rendered within the AngularJS [`ng-view`](https://docs.angularjs.org/api/ngRoute/directive/ngView) directive. When the user navigates away from the route, the `$rootScope` is destroyed on the AngularJS application.\n-->\n<p>Angular 애플리케이션에는 AngularJS 앱을 렌더링하는 컴포넌트가 필요할 수도 있습니다.\n이 컴포넌트는 초기화된 직후에 지연로딩 서비스를 사용해서 AngularJS 앱을 로드하는 역할을 합니다.</p>\n<code-example path=\"upgrade-lazy-load-ajs/src/app/angular-js/angular-js.component.ts\" header=\"src/app/angular-js/angular-js.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>, <a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a> } from '@angular/core';\nimport { LazyLoaderService } from '../lazy-loader.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-angular-js',\n  template: '&#x3C;div ng-view>&#x3C;/div>'\n})\nexport class AngularJSComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>, <a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a> {\n  constructor(\n    private lazyLoader: LazyLoaderService,\n    private elRef: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>\n  ) {}\n\n  ngOnInit() {\n    this.lazyLoader.load(this.elRef.nativeElement);\n  }\n\n\n  ngOnDestroy() {\n    this.lazyLoader.destroy();\n  }\n}\n\n\n</code-example>\n<p>이제 Angular 라우터가 AngularJS와 연관된 라우팅 규칙을 찾으면 <code>AngularJSComponent</code>가 렌더링 되면서 AngularJS <a href=\"https://docs.angularjs.org/api/ngRoute/directive/ngView\"><code>ng-view</code></a> 디렉티브에 AngularJS 앱이 렌더링됩니다.\n그리고 사용자가 이 화면에서 벗어나면 <code>$rooteScope.destroy()</code>를 실행하는 AngularJS 애플리케이션 정리 로직이 실행됩니다.</p>\n<!--\n### Configure a custom route matcher for AngularJS routes\n-->\n<h3 id=\"angularjs용-커스텀-라우팅-규칙-매처-구성하기\">AngularJS용 커스텀 라우팅 규칙 매처 구성하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#angularjs용-커스텀-라우팅-규칙-매처-구성하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nTo configure the Angular Router, you must define a route for AngularJS URLs. To match those URLs, you add a route configuration that uses the `matcher` property. The `matcher` allows you to use custom pattern matching for URL paths. The Angular Router tries to match on more specific routes such as static and variable routes first. When it doesn't find a match, it then looks at custom matchers defined in your route configuration. If the custom matchers don't match a route, it then goes to catch-all routes, such as a 404 page.\n\nThe following example defines a custom matcher function for AngularJS routes.\n\n<code-example path=\"upgrade-lazy-load-ajs/src/app/app-routing.module.ts\" header=\"src/app/app-routing.module.ts\" region=\"matcher\">\nexport function isAngularJSUrl(url: UrlSegment[]) {\n  return url.length &gt; 0 &amp;&amp; url[0].path.startsWith(&#39;users&#39;) ? ({consumed: url}) : null;\n}\n\n</code-example>\n\nThe following code adds a route object to your routing configuration using the `matcher` property and custom matcher, and the `component` property with `AngularJSComponent`.\n\n<code-example path=\"upgrade-lazy-load-ajs/src/app/app-routing.module.ts\" header=\"src/app/app-routing.module.ts\">\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { Routes, RouterModule, UrlSegment } from &#39;@angular/router&#39;;\nimport { AngularJSComponent } from &#39;./angular-js/angular-js.component&#39;;\nimport { HomeComponent } from &#39;./home/home.component&#39;;\nimport { App404Component } from &#39;./app404/app404.component&#39;;\n\n// Match any URL that starts with `users`\nexport function isAngularJSUrl(url: UrlSegment[]) {\n  return url.length &gt; 0 &amp;&amp; url[0].path.startsWith(&#39;users&#39;) ? ({consumed: url}) : null;\n}\n\nexport const routes: Routes = [\n  // Angular가 처리하는 라우팅 규칙\n  { path: &#39;&#39;, component: HomeComponent },\n\n  // AngularJS가 처리하는 라우팅 규칙\n  { matcher: isAngularJSUrl, component: AngularJSComponent },\n\n  // Catch-all 라우팅 규칙\n  { path: &#39;**&#39;, component: App404Component }\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n\n\n</code-example>\n\nWhen your application matches a route that needs AngularJS, the AngularJS app is loaded and bootstrapped, the AngularJS routes match the necessary URL to render their content, and your application continues to run with both AngularJS and Angular frameworks.\n-->\n<p>하이브리드 앱에서 Angular 라우터를 구성하려면 AngularJS URL과 연결된 라우팅 규칙을 정의해야 합니다.\n그리고 이 라우팅 규칙은 <code>matcher</code> 프로퍼티로 연결해야 하는데, <code>matcher</code>를 사용하면 URL 경로를 커스텀 패턴으로 매칭할 때 사용하는 프로퍼티입니다.\nAngular 라우터는 URL이 변경되었을 때 정적 라우팅 규칙을 먼저 탐색합니다.\n그리고 이 안에서 적절한 라우팅 규칙을 찾지 못하면 커스텀 매처를 탐색합니다.\n커스텀 매처에서도 적절한 라웉이 규칙을 찾지 못하면 catch-all(<code>**</code>) 라우팅 규칙으로 떨어지며, 404 화면이 표시될 것입니다.</p>\n<p>AngularJS 라우팅 규칙에 사용할 커스텀 매처는 다음과 같이 정의합니다.</p>\n<code-example path=\"upgrade-lazy-load-ajs/src/app/app-routing.module.ts\" header=\"src/app/app-routing.module.ts\" region=\"matcher\">\nexport function isAngularJSUrl(url: <a href=\"api/router/UrlSegment\" class=\"code-anchor\">UrlSegment</a>[]) {\n  return url.length > 0 &#x26;&#x26; url[0].path.startsWith('users') ? ({consumed: url}) : null;\n}\n\n</code-example>\n<p>그리고 이 커스텀 매처는 <code>matcher</code> 프로퍼티를 사용해서 다음과 같이 라우팅 규칙으로 등록합니다.\n이 때 <code>component</code> 프로퍼티에는 <code>AngularJSComponent</code>를 연결했습니다.</p>\n<code-example path=\"upgrade-lazy-load-ajs/src/app/app-routing.module.ts\" header=\"src/app/app-routing.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a>, <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/UrlSegment\" class=\"code-anchor\">UrlSegment</a> } from '@angular/router';\nimport { AngularJSComponent } from './angular-js/angular-js.component';\nimport { HomeComponent } from './home/home.component';\nimport { App404Component } from './app404/app404.component';\n\n// Match any URL that starts with `users`\nexport function isAngularJSUrl(url: <a href=\"api/router/UrlSegment\" class=\"code-anchor\">UrlSegment</a>[]) {\n  return url.length > 0 &#x26;&#x26; url[0].path.startsWith('users') ? ({consumed: url}) : null;\n}\n\nexport const routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  // Angular가 처리하는 라우팅 규칙\n  { path: '', component: HomeComponent },\n\n  // AngularJS가 처리하는 라우팅 규칙\n  { matcher: isAngularJSUrl, component: AngularJSComponent },\n\n  // Catch-all 라우팅 규칙\n  { path: '**', component: App404Component }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [<a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>]\n})\nexport class AppRoutingModule { }\n\n\n</code-example>\n<p>이제 AngularJS와 연결된 라우팅 규칙을 만나면 AngularJS 앱이 로드되고 부트스트랩된 이후에 AngularJS 라우팅 규칙이 다시 선택되어 앱을 화면에 표시합니다.\n결국 Angular와 Angular 프레임워크는 동시에 동작하는 모양이 됩니다.</p>\n<a id=\"using-the-unified-angular-location-service\"></a>\n<!--\n## Using the Unified Angular Location Service\n-->\n<h2 id=\"angular-location-서비스-통합하기\">Angular Location 서비스 통합하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#angular-location-서비스-통합하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nIn AngularJS, the [$location service](https://docs.angularjs.org/api/ng/service/$location) handles all routing configuration and navigation, encoding and decoding of URLS, redirects, and interactions with browser APIs. Angular uses its own underlying `Location` service for all of these tasks.\n\nWhen you migrate from AngularJS to Angular you will want to move as much responsibility as possible to Angular, so that you can take advantage of new APIs. To help with the transition, Angular provides the `LocationUpgradeModule`. This module enables a _unified_ location service that shifts responsibilities from the AngularJS `$location` service to the Angular `Location` service.\n\nTo use the `LocationUpgradeModule`, import the symbol from `@angular/common/upgrade` and add it to your `AppModule` imports using the static `LocationUpgradeModule.config()` method.\n\n```ts\n// Other imports ...\nimport { LocationUpgradeModule } from '@angular/common/upgrade';\n\n@NgModule({\n  imports: [\n    // Other NgModule imports...\n    LocationUpgradeModule.config()\n  ]\n})\nexport class AppModule {}\n```\n\nThe `LocationUpgradeModule.config()` method accepts a configuration object that allows you to configure options including the `LocationStrategy` with the `useHash` property, and the URL prefix with the `hashPrefix` property.\n\nThe `useHash` property defaults to `false`, and the `hashPrefix` defaults to an empty `string`. Pass the configuration object to override the defaults.\n\n```ts\nLocationUpgradeModule.config({\n  useHash: true,\n  hashPrefix: '!'\n})\n```\n\n<div class=\"alert is-important\">\n\n**Note:** See the `LocationUpgradeConfig` for more configuration options available to the `LocationUpgradeModule.config()` method.\n\n</div>\n\nThis registers a drop-in replacement for the `$location` provider in AngularJS. Once registered, all navigation, routing broadcast messages, and any necessary digest cycles in AngularJS triggered during navigation are handled by Angular. This gives you a single way to navigate within both sides of your hybrid application consistently.\n\nFor usage of the `$location` service as a provider in AngularJS, you need to downgrade the `$locationShim` using a factory provider.\n\n```ts\n// Other imports ...\nimport { $locationShim } from '@angular/common/upgrade';\nimport { downgradeInjectable } from '@angular/upgrade/static';\n\nangular.module('myHybridApp', [...])\n  .factory('$location', downgradeInjectable($locationShim));\n```\n\nOnce you introduce the Angular Router, using the Angular Router triggers navigations through the unified location service, still providing a single source for navigating with AngularJS and Angular.\n-->\n<p>AngularJS에서 사용했던 <a href=\"https://docs.angularjs.org/api/ng/service/$location\">$location 서비스</a>는 모든 라우팅 규칙과 네비게이션 동작을 관리하며, URL을 인코딩/디코딩하고 리다이렉션을 수행하면서 브라우저 API와 상호작용합니다.\n그리고 이 작업들은 Angular에서 <code><a href=\"api/common/Location\" class=\"code-anchor\">Location</a></code> 서비스가 그대로 담당하고 있습니다.</p>\n<p>AngularJS 애플리케이션을 Angular로 옮기다보면 이 서비스와 관련된 기능도 함께 수정해야 할 수 있습니다.\n그리고 이 과정에서 새로운 API를 도입하면서 더 나은 코드를 작성할 수도 있습니다.\nAngularJS <code>$location</code>를 Angular <code><a href=\"api/common/Location\" class=\"code-anchor\">Location</a></code>로 변환하는 작업을 돕기 위해 Angular는 <code><a href=\"api/common/upgrade/LocationUpgradeModule\" class=\"code-anchor\">LocationUpgradeModule</a></code>을 제공합니다.\n이 모듈은 두 서비스를 <em>통합하는</em> Location 서비스를 제공합니다.</p>\n<p><code><a href=\"api/common/upgrade/LocationUpgradeModule\" class=\"code-anchor\">LocationUpgradeModule</a></code>을 사용하려면 <code>@angular/common/upgrade</code> 패키지에서 이 모듈을 로드하고 <code>AppModule</code> 메타데이터에 <code><a href=\"api/common/upgrade/LocationUpgradeModule#config\" class=\"code-anchor\">LocationUpgradeModule.config()</a></code> 메소드를 실행한 결과를 로드하면 됩니다.</p>\n<code-example language=\"ts\">\n// 로드 구문들 ...\nimport { <a href=\"api/common/upgrade/LocationUpgradeModule\" class=\"code-anchor\">LocationUpgradeModule</a> } from '@angular/common/upgrade';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    // <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> 로드 ...\n    LocationUpgradeModule.config()\n  ]\n})\nexport class AppModule {}\n</code-example>\n<p><code><a href=\"api/common/upgrade/LocationUpgradeModule#config\" class=\"code-anchor\">LocationUpgradeModule.config()</a></code> 메소드에 옵션을 전달하면서 실행하면 <code><a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a></code>나 URL 접두사에 대한 정책을 지정할 수 있습니다.</p>\n<p><code><a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a></code>에 사용하는 <code>useHash</code> 프로퍼티 기본값은 <code>false</code>이며 URL 접두사를 지정하는 <code>hashPrefix</code> 프로퍼티 기본값은 빈 문자열인데, 이 정책을 변경하려면 다음과 같이 구현하면 됩니다.</p>\n<code-example language=\"ts\">\nLocationUpgradeModule.config({\n  useHash: true,\n  hashPrefix: '!'\n})\n</code-example>\n<div class=\"alert is-important\">\n<p><strong>참고:</strong> <code><a href=\"api/common/upgrade/LocationUpgradeModule#config\" class=\"code-anchor\">LocationUpgradeModule.config()</a></code> 메소드에 사용할 수 있는 옵션 목록은 <code><a href=\"api/common/upgrade/LocationUpgradeConfig\" class=\"code-anchor\">LocationUpgradeConfig</a></code> 문서를 참고하세요.</p>\n</div>\n<p>이렇게 구현하면 AngularJS에서 등록한 <code>$location</code> 프로바이더를 교체합니다.\n그래서 이전에 AngularJS가 관여했던 네비게이션 동작, 라우팅 브로드캐스팅 메시지, 그리고 네비게이션 과정 중에 발생하는 모든 이벤트는 이제 Angular가 처리하게 됩니다.\n이제는 하이브리드 애플리케이션의 모든 라우팅 과정을 Angular가 처리하기 때문에 애플리케이션을 관리하기 편해집니다.</p>\n<p>그리고 AngularJS 쪽에서 Location 서비스를 다운그레이드해서 사용하려면 <code><a href=\"api/common/upgrade/$locationShim\" class=\"code-anchor\">$locationShim</a></code> 팩토리 프로바이더를 사용해서 다음과 같이 등록하면 됩니다.</p>\n<code-example language=\"ts\">\n// 로드 구문들 ...\nimport { $locationShim } from '@angular/common/upgrade';\nimport { <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nangular.module('myHybridApp', [...])\n  .factory('$location', <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>($locationShim));\n</code-example>\n<p>이렇게 구현하고 나면 AngularJS와 Angular의 Location 서비스를 Angular 라우터가 통합해서 처리합니다.\n그러면서 Angular와 AngularJS 각 영역에서 이 서비스를 단일 소스로 활용할 수 있습니다.</p>\n<!--\nTODO:\nCorrectly document how to use AOT with SystemJS-based `ngUpgrade` apps (or better yet update the\n`ngUpgrade` examples/guides to use `@angular/cli`).\nSee https://github.com/angular/angular/issues/35989.\n\n## Using Ahead-of-time compilation with hybrid apps\n\nYou can take advantage of Ahead-of-time (AOT) compilation on hybrid apps just like on any other\nAngular application.\nThe setup for a hybrid app is mostly the same as described in\n[the Ahead-of-time Compilation chapter](guide/aot-compiler)\nsave for differences in `index.html` and `main-aot.ts`\n\nThe `index.html` will likely have script tags loading AngularJS files, so the `index.html`\nfor AOT must also load those files.\nAn easy way to copy them is by adding each to the `copy-dist-files.js` file.\n\nYou'll need to use the generated `AppModuleFactory`, instead of the original `AppModule` to\nbootstrap the hybrid app:\n\n<code-example path=\"upgrade-phonecat-2-hybrid/app/main-aot.ts\" header=\"app/main-aot.ts\">\nimport { platformBrowser } from &#39;@angular/platform-browser&#39;;\n\nimport { AppModuleNgFactory } from &#39;./app.module.ngfactory&#39;;\n\nplatformBrowser().bootstrapModuleFactory(AppModuleNgFactory);\n\n\n</code-example>\n\nAnd that's all you need do to get the full benefit of AOT for Angular apps!\n-->\n<!--\n## PhoneCat Upgrade Tutorial\n-->\n<h2 id=\"phonecat-업그레이드-튜토리얼\">PhoneCat 업그레이드 튜토리얼<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#phonecat-업그레이드-튜토리얼\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nIn this section, you'll learn to prepare and upgrade an application with `ngUpgrade`.\nThe example app is [Angular PhoneCat](https://github.com/angular/angular-phonecat)\nfrom [the original AngularJS tutorial](https://docs.angularjs.org/tutorial),\nwhich is where many of us began our Angular adventures. Now you'll see how to\nbring that application to the brave new world of Angular.\n\nDuring the process you'll learn how to apply the steps outlined in the\n[preparation guide](guide/upgrade#preparation). You'll align the application\nwith Angular and also start writing in TypeScript.\n\nTo follow along with the tutorial, clone the\n[angular-phonecat](https://github.com/angular/angular-phonecat) repository\nand apply the steps as you go.\n\nIn terms of project structure, this is where the work begins:\n-->\n<p>이번 섹션에서는 <code>ngUpgrade</code>로 AngularJS 애플리케이션을 업그레이드하는 방법에 대해 알아봅시다.\n예제로 다뤄볼 앱은 <a href=\"https://docs.angularjs.org/tutorial\">AngularJS 튜토리얼</a> 앱이며 완성본은 <a href=\"https://github.com/angular/angular-phonecat\">Angular PhoneCat 저장소</a>에 있습니다.\n이제 이 앱을 Angular 세계로 어떻게 옮겨갈 수 있는지 알아봅시다.</p>\n<p>이 과정은 <a href=\"guide/upgrade#preparation\">사전 준비 가이드 섹션</a>에서 다룬 내용을 그대로 따라갑니다.\n그래서 애플리케이션에 Angular와 TypeScript를 도입하는 것부터 시작해 봅시다.</p>\n<p>앱을 직접 수정해 보려면 <a href=\"https://github.com/angular/angular-phonecat\">angular-phonecat</a> 저장소를 복제해서 그대로 따라해보는 것도 좋습니다.</p>\n<p>작업을 시작하기 전에는 프로젝트가 이런 구조일 것입니다:</p>\n<div class=\"filetree\">\n  <div class=\"file\">\n    angular-phonecat\n  </div>\n  <div class=\"children\">\n    <div class=\"file\">\n      bower.json\n    </div>\n    <div class=\"file\">\n      karma.conf.js\n    </div>\n    <div class=\"file\">\n      package.json\n    </div>\n    <div class=\"file\">\n      app\n    </div>\n    <div class=\"children\">\n      <div class=\"file\">\n        core\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          checkmark\n        </div>\n        <div class=\"children\">\n          <div class=\"file\">\n            checkmark.filter.js\n          </div>\n          <div class=\"file\">\n            checkmark.filter.spec.js\n          </div>\n        </div>\n        <div class=\"file\">\n          phone\n        </div>\n        <div class=\"children\">\n          <div class=\"file\">\n            phone.module.js\n          </div>\n          <div class=\"file\">\n            phone.service.js\n          </div>\n          <div class=\"file\">\n            phone.service.spec.js\n          </div>\n        </div>\n        <div class=\"file\">\n          core.module.js\n        </div>\n      </div>\n      <div class=\"file\">\n        phone-detail\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          phone-detail.component.js\n        </div>\n        <div class=\"file\">\n          phone-detail.component.spec.js\n        </div>\n        <div class=\"file\">\n          phone-detail.module.js\n        </div>\n        <div class=\"file\">\n          phone-detail.template.html\n        </div>\n      </div>\n      <div class=\"file\">\n        phone-list\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          phone-list.component.js\n        </div>\n        <div class=\"file\">\n          phone-list.component.spec.js\n        </div>\n        <div class=\"file\">\n          phone-list.module.js\n        </div>\n        <div class=\"file\">\n          phone-list.template.html\n        </div>\n      </div>\n      <div class=\"file\">\n        img\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n           ...\n        </div>\n      </div>\n      <div class=\"file\">\n        phones\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n           ...\n        </div>\n      </div>\n      <div class=\"file\">\n        app.animations.js\n      </div>\n      <div class=\"file\">\n        app.config.js\n      </div>\n      <div class=\"file\">\n        app.css\n      </div>\n      <div class=\"file\">\n        app.module.js\n      </div>\n      <div class=\"file\">\n        index.html\n      </div>\n    </div>\n    <div class=\"file\">\n      e2e-tests\n    </div>\n    <div class=\"children\">\n      <div class=\"file\">\n        protractor-conf.js\n      </div>\n      <div class=\"file\">\n        scenarios.js\n      </div>\n    </div>\n  </div>\n</div>\n<!--\nThis is actually a pretty good starting point. The code uses the AngularJS 1.5\ncomponent API and the organization follows the\n[AngularJS Style Guide](https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md),\nwhich is an important [preparation step](guide/upgrade#follow-the-angular-styleguide) before\na successful upgrade.\n\n* Each component, service, and filter is in its own source file, as per the\n  [Rule of 1](https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility).\n\n* The `core`, `phone-detail`, and `phone-list` modules are each in their\n  own subdirectory. Those subdirectories contain the JavaScript code as well as\n  the HTML templates that go with each particular feature. This is in line with the\n  [Folders-by-Feature Structure](https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#folders-by-feature-structure)\n  and [Modularity](https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity)\n  rules.\n\n* Unit tests are located side-by-side with application code where they are easily\n  found, as described in the rules for\n  [Organizing Tests](https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#organizing-tests).\n-->\n<p>시작점으로는 아주 좋은 구조입니다.\n이 예제 코드는 AngularJS 1.5 컴포넌트 API를 사용하고 있으며 <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md\">AngularJS 스타일 가이드</a>를 준수하며 작성되었기 때문에 <a href=\"guide/upgrade#follow-the-angular-styleguide\">기본적인 준비</a>는 이미 마쳤다고 봐도 됩니다.</p>\n<ul>\n<li>\n<p>컴포넌트, 서비스, 필터는 개별 파일에 구현되어 있습니다. <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility\">하나만 구현하는 규칙</a>을 준수하고 있습니다.</p>\n</li>\n<li>\n<p><code>core</code>, <code>phone-detail</code>, <code>phone-list</code> 모듈은 각각 폴더로 구분되어 있습니다. 그리고 각 폴더에는 해당 모듈에만 필요한 코드가 모여 있습니다. <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#folders-by-feature-structure\">폴더를 기능별로 구분하는 구조</a>와 <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity\">모듈화</a> 규칙도 지키고 있습니다.</p>\n</li>\n<li>\n<p>유닛 테스트 파일은 애플리케이션 코드와 같은 위치에 있기 때문에 찾기 쉽습니다. <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#organizing-tests\">테스트를 최적화</a>하는 규칙도 잘 적용되었습니다.</p>\n</li>\n</ul>\n<!--\n### Switching to TypeScript\n-->\n<h3 id=\"typescript로-전환하기\">TypeScript로 전환하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#typescript로-전환하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nSince you're going to be writing Angular code in TypeScript, it makes sense to\nbring in the TypeScript compiler even before you begin upgrading.\n\nYou'll also start to gradually phase out the Bower package manager in favor\nof NPM, installing all new dependencies using NPM, and eventually removing Bower from the project.\n\nBegin by installing TypeScript to the project.\n\n<code-example format=\"\">\n  npm i typescript --save-dev\n</code-example>\n\nInstall type definitions for the existing libraries that\nyou're using but that don't come with prepackaged types: AngularJS, AngularJS Material, and the\nJasmine unit test framework.\n\nFor the PhoneCat app, we can install the necessary type definitions by running the following command:\n\n<code-example format=\"\">\n  npm install @types/jasmine @types/angular @types/angular-animate @types/angular-aria @types/angular-cookies @types/angular-mocks @types/angular-resource @types/angular-route @types/angular-sanitize --save-dev\n</code-example>\n\nIf you are using AngularJS Material, you can install the type definitions via:\n\n<code-example format=\"\">\n  npm install @types/angular-material --save-dev\n</code-example>\n\nYou should also configure the TypeScript compiler with a `tsconfig.json` in the project directory\nas described in the [TypeScript Configuration](guide/typescript-configuration) guide.\nThe `tsconfig.json` file tells the TypeScript compiler how to turn your TypeScript files\ninto ES5 code bundled into CommonJS modules.\n\nFinally, you should add some npm scripts in `package.json` to compile the TypeScript files to\nJavaScript (based on the `tsconfig.json` configuration file):\n\n<code-example format=\"\">\n  \"scripts\": {\n    \"tsc\": \"tsc\",\n    \"tsc:w\": \"tsc -w\",\n    ...\n</code-example>\n\nNow launch the TypeScript compiler from the command line in watch mode:\n\n<code-example format=\"\">\n  npm run tsc:w\n</code-example>\n\nKeep this process running in the background, watching and recompiling as you make changes.\n\nNext, convert your current JavaScript files into TypeScript. Since\nTypeScript is a super-set of ECMAScript 2015, which in turn is a super-set\nof ECMAScript 5, you can simply switch the file extensions from `.js` to `.ts`\nand everything will work just like it did before. As the TypeScript compiler\nruns, it emits the corresponding `.js` file for every `.ts` file and the\ncompiled JavaScript is what actually gets executed. If you start\nthe project HTTP server with `npm start`, you should see the fully functional\napplication in your browser.\n\nNow that you have TypeScript though, you can start benefiting from some of its\nfeatures. There's a lot of value the language can provide to AngularJS applications.\n\nFor one thing, TypeScript is a superset of ES2015. Any app that has previously\nbeen written in ES5 - like the PhoneCat example has - can with TypeScript\nstart incorporating all of the JavaScript features that are new to ES2015.\nThese include things like `let`s and `const`s, arrow functions, default function\nparameters, and destructuring assignments.\n\nAnother thing you can do is start adding *type safety* to your code. This has\nactually partially already happened because of the AngularJS typings you installed.\nTypeScript are checking that you are calling AngularJS APIs correctly when you do\nthings like register components to Angular modules.\n\nBut you can also start adding *type annotations* to get even more\nout of TypeScript's type system. For instance, you can annotate the checkmark\nfilter so that it explicitly expects booleans as arguments. This makes it clearer\nwhat the filter is supposed to do.\n\n<code-example path=\"upgrade-phonecat-1-typescript/app/core/checkmark/checkmark.filter.ts\" header=\"app/core/checkmark/checkmark.filter.ts\">\nangular.\n  module(&#39;core&#39;).\n  filter(&#39;checkmark&#39;, () =&gt; {\n    return (input: boolean) =&gt; input ? &#39;\\u2713&#39; : &#39;\\u2718&#39;;\n  });\n\n\n</code-example>\n\nIn the `Phone` service, you can explicitly annotate the `$resource` service dependency\nas an `angular.resource.IResourceService` - a type defined by the AngularJS typings.\n\n<code-example path=\"upgrade-phonecat-1-typescript/app/core/phone/phone.service.ts\" header=\"app/core/phone/phone.service.ts\">\nangular.\n  module(&#39;core.phone&#39;).\n  factory(&#39;Phone&#39;, [&#39;$resource&#39;,\n    ($resource: angular.resource.IResourceService) =&gt; {\n      return $resource(&#39;phones/:phoneId.json&#39;, {}, {\n        query: {\n          method: &#39;GET&#39;,\n          params: {phoneId: &#39;phones&#39;},\n          isArray: true\n        }\n      });\n    }\n  ]);\n\n\n</code-example>\n\nYou can apply the same trick to the application's route configuration file in `app.config.ts`,\nwhere you are using the location and route services. By annotating them accordingly TypeScript\ncan verify you're calling their APIs with the correct kinds of arguments.\n\n<code-example path=\"upgrade-phonecat-1-typescript/app/app.config.ts\" header=\"app/app.config.ts\">\nangular.\n  module(&#39;phonecatApp&#39;).\n  config([&#39;$locationProvider&#39;, &#39;$routeProvider&#39;,\n    function config($locationProvider: angular.ILocationProvider,\n                    $routeProvider: angular.route.IRouteProvider) {\n      $locationProvider.hashPrefix(&#39;!&#39;);\n\n      $routeProvider.\n        when(&#39;/phones&#39;, {\n          template: &#39;&lt;phone-list&gt;&lt;/phone-list&gt;&#39;\n        }).\n        when(&#39;/phones/:phoneId&#39;, {\n          template: &#39;&lt;phone-detail&gt;&lt;/phone-detail&gt;&#39;\n        }).\n        otherwise(&#39;/phones&#39;);\n    }\n  ]);\n\n\n</code-example>\n-->\n<p>Angular는 TypeScript로 구현하기 때문에 AngularJS 앱을 업그레이드하기 전에 TypeScript 컴파일러를 먼저 도입하는 방법도 고려할 수 있습니다.</p>\n<p>그리고 의존성 패키지를 설치할 때 Bower 패키지 매니저를 사용했다면 이제는 모든 의존성 패키지를 npm으로 설치하기 때문에 최종적으로 Bower는 프로젝트에서 제거될 것입니다.</p>\n<p>프로젝트에 TypeScript를 설치하는 것부터 시작해 봅시다.</p>\n<code-example format=\"\">\n  npm i typescript --save-dev\n</code-example>\n<p>Install type definitions for the existing libraries that\nyou're using but that don't come with prepackaged types: AngularJS, AngularJS Material, and the\nJasmine unit test framework.</p>\n<p>For the PhoneCat app, we can install the necessary type definitions by running the following command:</p>\n<code-example format=\"\">\n  npm install @types/jasmine @types/angular @types/angular-animate @types/angular-aria @types/angular-cookies @types/angular-mocks @types/angular-resource @types/angular-route @types/angular-sanitize --save-dev\n</code-example>\n<p>If you are using AngularJS Material, you can install the type definitions via:</p>\n<code-example format=\"\">\n  npm install @types/angular-material --save-dev\n</code-example>\n<p>필요한 패키지를 설치하고 나면 <a href=\"guide/typescript-configuration\">TypeScript 환경 설정</a> 가이드 문서에 따라 <code>tsconfig.json</code> TypeScript 컴파일러 환경 설정 파일을 프로젝트에 생성해야 합니다.\n<code>tsconfig.json</code> 파일을 정의하면 TypeScript 문법으로 작성한 파일을 CommonJS 모듈 형식로 구성되는 ES5 코드로 변환할 수 있습니다.</p>\n<p>그리고 <code>package.json</code> 파일에 TypeScript 파일들을 JavaScript로 변환하는 npm 스크립트를 추가합니다. 설정 파일을 지정하지 않으면 <code>tsconfig.json</code> 파일이 기본값으로 사용됩니다.:</p>\n<code-example format=\"\">\n  \"scripts\": {\n    \"tsc\": \"tsc\",\n    \"tsc:w\": \"tsc -w\",\n    ...\n</code-example>\n<p>그리고 커맨드창에서 다음 명령을 실행하면 TypeScript 컴파일러를 워치 모드로 실행할 수 있습니다:</p>\n<code-example format=\"\">\n  npm run tsc:w\n</code-example>\n<p>이제 이 프로세스를 백그라운드에서 실행되도록 두면 소스 코드가 저장될 때마다 감지하고 다시 컴파일합니다.</p>\n<p>다음으로 해야할 것은 JavaScript 파일을 TypeScript 문법으로 바꾸는 것입니다.\n그런데 TypeScript는 ECMAScript 2015의 상위 집합(super-set)이기 때문에 파일의 확장자를 <code>.js</code>에서 <code>.ts</code>로 바꾸기만 해도 모든 코드는 이전과 동일하게 동작합니다.\n그리고 위에서 실행한 TypeScript 컴파일러가 백그라운드에서 돌고 있기 때문에 <code>.js</code> 파일을 <code>.ts</code> 확장자로 바꾸는대로 다시 실행용 <code>.js</code> 파일로 컴파일됩니다.\n<code>npm start</code> 명령으로 HTTP 서버를 실행하고 있다면 브라우저로 빌드 결과를 확인할 수도 있습니다.</p>\n<p>이제 프로젝트에 TypeScript를 적용했기 때문에 이제 TypeScript 기능을 자유롭게 활용할 수 있습니다.\nAngularJS 애플리케이션의 활용도는 크게 넓어질 것입니다.</p>\n<p>다시 한 번 언급하지만 TypeScript는 ES2015의 상위집합입니다.\n그래서 ES5로 작성된 앱(PhoneCat 예제 포함)을 TypeScript로 전환하면 ES2015에 새로 도입된 기능을 포함해서 JavaScript 기능을 모두 통합할 수 있습니다.\n<code>let</code>이나 <code>const</code>는 물론이고 화살표 함수, 함수 인자 기본값, 비구조화 할당과 같은 문법이 이런 내용에 포함됩니다.</p>\n<p>다른 장점은 <em>안전한 타입으로</em> 코드를 작성할 수 있다는 것입니다.\n사실 이 기능은 AngularJS 타입 정의 패키지를 설치했을 때부터 이미 동작하고 있습니다.\nTypeScript는 Angular 모듈에 컴포넌트가 등록될 때와 같이 AngularJS API를 사용할 때마다 이 API가 올바르게 사용되었는지 계속 검사합니다.</p>\n<p><em>타입 어노테이션(type annotation)</em>을 추가하면 TypeScript 타입 시스템에서 지원하는 기능 외에도 더 많은 기능을 추가할 수 있습니다.\n예를 들면 체크표시 필터의 인자는 반드시 불리언 타입이라는 것을 명시하는 식입니다.\n이런 정보를 추가하면 필터가 어떤 역할을 하는지 좀 더 명확하게 지정할 수 있습니다.</p>\n<code-example path=\"upgrade-phonecat-1-typescript/app/core/checkmark/checkmark.filter.ts\" header=\"app/core/checkmark/checkmark.filter.ts\">\nangular.\n  module('core').\n  filter('checkmark', () => {\n    return (input: boolean) => input ? '\\u2713' : '\\u2718';\n  });\n\n\n</code-example>\n<p><code>Phone</code> 서비스에서 <code>$resource</code> 의존성 패키지는 <code>angular.resource.IResourceService</code>라는 타입으로 지정되어 있습니다.\nAngularJS를 위한 타입을 정의한 것입니다.</p>\n<code-example path=\"upgrade-phonecat-1-typescript/app/core/phone/phone.service.ts\" header=\"app/core/phone/phone.service.ts\">\nangular.\n  module('core.phone').\n  factory('Phone', ['$resource',\n    ($resource: angular.resource.IResourceService) => {\n      return $resource('phones/:phoneId.json', {}, {\n        <a href=\"api/animations/query\" class=\"code-anchor\">query</a>: {\n          method: 'GET',\n          params: {phoneId: 'phones'},\n          isArray: true\n        }\n      });\n    }\n  ]);\n\n\n</code-example>\n<p>이 방식은 애플리케이션의 라우팅 규칙을 설정하는 <code>app.config.ts</code> 파일에도 적용할 수 있습니다.\n이 파일에 타입을 지정하면 API에 사용된 인자가 올바른지 검사할 수 있습니다.</p>\n<code-example path=\"upgrade-phonecat-1-typescript/app/app.config.ts\" header=\"app/app.config.ts\">\nangular.\n  module('phonecatApp').\n  config(['$locationProvider', '$routeProvider',\n    function config($locationProvider: angular.ILocationProvider,\n                    $routeProvider: angular.route.IRouteProvider) {\n      $locationProvider.hashPrefix('!');\n\n      $routeProvider.\n        when('/phones', {\n          template: '&#x3C;phone-list>&#x3C;/phone-list>'\n        }).\n        when('/phones/:phoneId', {\n          template: '&#x3C;phone-detail>&#x3C;/phone-detail>'\n        }).\n        otherwise('/phones');\n    }\n  ]);\n\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\nThe [AngularJS 1.x type definitions](https://www.npmjs.com/package/@types/angular)\nyou installed are not officially maintained by the Angular team,\nbut are quite comprehensive. It is possible to make an AngularJS 1.x application\nfully type-annotated with the help of these definitions.\n\nIf this is something you wanted to do, it would be a good idea to enable\nthe `noImplicitAny` configuration option in `tsconfig.json`. This would\ncause the TypeScript compiler to display a warning when there's any code that\ndoes not yet have type annotations. You could use it as a guide to inform\nus about how close you are to having a fully annotated project.\n-->\n<p><a href=\"https://www.npmjs.com/package/@types/angular\">AngularJS 1.x 타입 정의 파일</a>은 Angular 팀이 관리하는 공식 패키지가 아닙니다.\n하지만 이 패키지를 활용하면 AngularJS 1.x 애플리케이션에 모든 타입을 지정할 수 있습니다.</p>\n<p><code>tsconfig.json</code> 옵션에 <code>noImplicitAny</code>를 사용하는 것도 좋습니다.\n이 옵션을 설정하면 타입이 지정되지 않은 코드를 TypeScript 컴파일러가 발견했을 때 경고 메시지를 표시합니다.\n그래서 이렇게 설정해두면 프로젝트 전체에 타입을 지정하는 작업에 가이드로 활용할 수 있습니다.</p>\n</div>\n<!--\nAnother TypeScript feature you can make use of is *classes*. In particular, you\ncan turn component controllers into classes. That way they'll be a step\ncloser to becoming Angular component classes, which will make life\neasier once you upgrade.\n\nAngularJS expects controllers to be constructor functions. That's exactly what\nES2015/TypeScript classes are under the hood, so that means you can just plug in a\nclass as a component controller and AngularJS will happily use it.\n\nHere's what the new class for the phone list component controller looks like:\n\n<code-example path=\"upgrade-phonecat-1-typescript/app/phone-list/phone-list.component.ts\" header=\"app/phone-list/phone-list.component.ts\">\nclass PhoneListController {\n  phones: any[];\n  orderProp: string;\n  query: string;\n\n  static $inject = [&#39;Phone&#39;];\n  constructor(Phone: any) {\n    this.phones = Phone.query();\n    this.orderProp = &#39;age&#39;;\n  }\n\n}\n\nangular.\n  module(&#39;phoneList&#39;).\n  component(&#39;phoneList&#39;, {\n    templateUrl: &#39;phone-list/phone-list.template.html&#39;,\n    controller: PhoneListController\n  });\n\n\n</code-example>\n\nWhat was previously done in the controller function is now done in the class\nconstructor function. The dependency injection annotations are attached\nto the class using a static property `$inject`. At runtime this becomes the\n`PhoneListController.$inject` property.\n\nThe class additionally declares three members: The array of phones, the name of\nthe current sort key, and the search query. These are all things you have already\nbeen attaching to the controller but that weren't explicitly declared anywhere.\nThe last one of these isn't actually used in the TypeScript code since it's only\nreferred to in the template, but for the sake of clarity you should define all of the\ncontroller members.\n\nIn the Phone detail controller, you'll have two members: One for the phone\nthat the user is looking at and another for the URL of the currently displayed image:\n\n<code-example path=\"upgrade-phonecat-1-typescript/app/phone-detail/phone-detail.component.ts\" header=\"app/phone-detail/phone-detail.component.ts\">\nclass PhoneDetailController {\n  phone: any;\n  mainImageUrl: string;\n\n  static $inject = [&#39;$routeParams&#39;, &#39;Phone&#39;];\n  constructor($routeParams: angular.route.IRouteParamsService, Phone: any) {\n    const phoneId = $routeParams.phoneId;\n    this.phone = Phone.get({phoneId}, (phone: any) =&gt; {\n      this.setImage(phone.images[0]);\n    });\n  }\n\n  setImage(imageUrl: string) {\n    this.mainImageUrl = imageUrl;\n  }\n}\n\nangular.\n  module(&#39;phoneDetail&#39;).\n  component(&#39;phoneDetail&#39;, {\n    templateUrl: &#39;phone-detail/phone-detail.template.html&#39;,\n    controller: PhoneDetailController\n  });\n\n\n</code-example>\n\nThis makes the controller code look a lot more like Angular already. You're\nall set to actually introduce Angular into the project.\n\nIf you had any AngularJS services in the project, those would also be\na good candidate for converting to classes, since like controllers,\nthey're also constructor functions. But you only have the `Phone` factory\nin this project, and that's a bit special since it's an `ngResource`\nfactory. So you won't be doing anything to it in the preparation stage.\nYou'll instead turn it directly into an Angular service.\n-->\n<p>TypeScript 기능 중에서는 <em>클래스</em>도 활용해볼만 합니다.\n컴포넌트 컨트롤러를 클래스로 전환하면 좀 더 Angular 컴포넌트 클래스에 가깝게 구현할 수 있으며, 이후에 Angular로 업그레이드하는 데에도 도움이 됩니다.</p>\n<p>AngularJS는 컨트롤러를 생성자 함수처럼 간주하는데 이것은 ES2015/TypeScript에서 클래스가 맡는 역할과 정확히 동일하기 때문에 AngularJS에서도 클래스를 사용하는 것은 문제되지 않습니다.</p>\n<p>이 방식으로 컴포넌트 컨트롤러를 클래스로 구현하면 다음과 같은 코드가 됩니다:</p>\n<code-example path=\"upgrade-phonecat-1-typescript/app/phone-list/phone-list.component.ts\" header=\"app/phone-list/phone-list.component.ts\">\nclass PhoneListController {\n  phones: any[];\n  orderProp: string;\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>: string;\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> $inject = ['Phone'];\n  constructor(Phone: any) {\n    this.phones = Phone.query();\n    this.orderProp = 'age';\n  }\n\n}\n\nangular.\n  module('phoneList').\n  component('phoneList', {\n    templateUrl: 'phone-list/phone-list.template.html',\n    controller: PhoneListController\n  });\n\n\n</code-example>\n<p>이전에 컨트롤러 함수에 작성했던 로직을 클래스 생성자 함수에 작성해도 이전과 동일하게 동작합니다.\n의존성을 주입하기 위해 <code>$inject</code>는 정적 프로퍼티로 선언했기 때문에 실행시점에는 <code>PhoneListController.$inject</code>로 접근할 수 있습니다.</p>\n<p>그리고 이 클래스는 전화번호 목록, 정렬키 이름, 검색 쿼리 이렇게 3개의 멤버가 더 정의되어 있습니다.\n이 멤버들도 이전에는 컨트롤러에 정의했던 것이지만 어디에 정의했는지는 확실하지 않을 수 있습니다.\n이 때 마지막 멤버는 TypeScript 코드 중에는 아무곳에서도 사용되지 않고 템플릿에서만 사용하기 때문에 그대로 옮겨주었습니다.</p>\n<p>Phone 상세정보 컨트롤러에는 2개의 멤버가 있습니다.\n하나는 사용자가 찾으려고 하는 핸드폰 객체이며, 다른 하나는 화면에 표시될 이미지 파일의 URL입니다:</p>\n<code-example path=\"upgrade-phonecat-1-typescript/app/phone-detail/phone-detail.component.ts\" header=\"app/phone-detail/phone-detail.component.ts\">\nclass PhoneDetailController {\n  phone: any;\n  mainImageUrl: string;\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> $inject = ['$routeParams', 'Phone'];\n  constructor($routeParams: angular.route.IRouteParamsService, Phone: any) {\n    const phoneId = $routeParams.phoneId;\n    this.phone = Phone.get({phoneId}, (phone: any) => {\n      this.setImage(phone.images[0]);\n    });\n  }\n\n  setImage(imageUrl: string) {\n    this.mainImageUrl = imageUrl;\n  }\n}\n\nangular.\n  module('phoneDetail').\n  component('phoneDetail', {\n    templateUrl: 'phone-detail/phone-detail.template.html',\n    controller: PhoneDetailController\n  });\n\n\n</code-example>\n<p>이렇게만 작성해도 컨트롤러 코드는 좀 더 Angular처럼 보입니다.\n그리고 프로젝트에 Angular를 도입하기 위한 준비도 모두 끝났습니다.</p>\n<p>AngularJS 프로젝트에 서비스가 있다면 이 서비스도 컨트롤러와 마찬가지로 클래스로 전환할만 합니다.\n서비스도 생성자 함수이기 때문입니다.\n다만 지금 다루는 예제 앱에서는 <code>Phone</code> 팩토리만 존재하기 때문에 준비단계에서 해야할 것은 끝났습니다.\n이제부터 추가되는 서비스는 Angular로 직접 구현하면 됩니다.</p>\n<!--\n### Installing Angular\n-->\n<h3 id=\"angular-설치하기\">Angular 설치하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#angular-설치하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nHaving completed the preparation work, get going with the Angular\nupgrade of PhoneCat. You'll do this incrementally with the help of\n[ngUpgrade](#upgrading-with-ngupgrade) that comes with Angular.\nBy the time you're done, you'll be able to remove AngularJS from the project\ncompletely, but the key is to do this piece by piece without breaking the application.\n\n<div class=\"alert is-important\">\n\nThe project also contains some animations.\nYou won't upgrade them in this version of the guide.\nTurn to the [Angular animations](guide/animations) guide to learn about that.\n\n</div>\n\nInstall Angular into the project, along with the SystemJS module loader.\nTake a look at the results of the [upgrade setup instructions](guide/upgrade-setup)\nand get the following configurations from there:\n\n* Add Angular and the other new dependencies to `package.json`\n* The SystemJS configuration file `systemjs.config.js` to the project root directory.\n\nOnce these are done, run:\n\n<code-example format=\"\">\n  npm install\n</code-example>\n\nSoon you can load Angular dependencies into the application via `index.html`,\nbut first you need to do some directory path adjustments.\nYou'll need to load files from `node_modules` and the project root instead of\nfrom the `/app` directory as you've been doing to this point.\n\nMove the `app/index.html` file to the project root directory. Then change the\ndevelopment server root path in `package.json` to also point to the project root\ninstead of `app`:\n\n<code-example format=\"\">\n  \"start\": \"http-server ./ -a localhost -p 8000 -c-1\",\n</code-example>\n\nNow you're able to serve everything from the project root to the web browser. But you do *not*\nwant to have to change all the image and data paths used in the application code to match\nthe development setup. For that reason, you'll add a `<base>` tag to `index.html`, which will\ncause relative URLs to be resolved back to the `/app` directory:\n\n<code-example path=\"upgrade-phonecat-2-hybrid/index.html\" region=\"base\" header=\"index.html\">\n&lt;base href=&quot;/app/&quot;&gt;\n\n</code-example>\n\nNow you can load Angular via SystemJS. You'll add the Angular polyfills and the\nSystemJS config to the end of the `<head>` section, and then you'll use `System.import`\nto load the actual application:\n\n<code-example path=\"upgrade-phonecat-2-hybrid/index.html\" region=\"angular\" header=\"index.html\">\n&lt;script src=&quot;/node_modules/core-js/client/shim.min.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;/node_modules/zone.js/bundles/zone.umd.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;/node_modules/systemjs/dist/system.src.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;/systemjs.config.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n  System.import(&#39;/app&#39;);\n&lt;/script&gt;\n\n</code-example>\n\nYou also need to make a couple of adjustments\nto the `systemjs.config.js` file installed during [upgrade setup](guide/upgrade-setup).\n\nPoint the browser to the project root when loading things through SystemJS,\ninstead of using the `<base>` URL.\n\nInstall the `upgrade` package via `npm install @angular/upgrade --save`\nand add a mapping for the `@angular/upgrade/static` package.\n\n<code-example path=\"upgrade-phonecat-2-hybrid/systemjs.config.1.js\" region=\"paths\" header=\"systemjs.config.js\">\n  System.config({\n    paths: {\n      // alias 설정\n      &#39;npm:&#39;: &#39;/node_modules/&#39;\n    },\n    map: {\n      &#39;ng-loader&#39;: &#39;../src/systemjs-angular-loader.js&#39;,\n      app: &#39;/app&#39;,\n/* . . . */\n      &#39;@angular/upgrade/static&#39;: &#39;npm:@angular/upgrade/bundles/upgrade-static.umd.js&#39;,\n/* . . . */\n    },\n\n</code-example>\n-->\n<p>사전작업을 마치고 나면 이제 PhoneCat 프로젝트를 Angular 버전으로 업그레이드 해봅시다.\n이 과정은 <a href=\"guide/upgrade#upgrading-with-ngupgrade\">ngUpgrade</a>를 활용해서 단계별로 작업하며, 이 과정을 끝내고 나면 프로젝트에서 AngularJS를 완전히 제거해도 됩니다.\n과정을 진행하는 동안 애플리케이션이 계속 동작하도록 하나씩 전환하는 것이 가장 중요합니다.</p>\n<div class=\"alert is-important\">\n<p>프로젝트에 애니메이션을 활용했다면 지금 당장 이 코드를 Angular 버전으로 전환하지 않아도 됩니다.\n자세한 내용은 <a href=\"guide/animations\">Angular 애니메이션</a> 문서를 참고하세요.</p>\n</div>\n<p>프로젝트에 Angular를 설치하고 SystemJS 모듈 로더로 프로젝트에 로드해 봅시다.\n작업을 끝낸 결과는 <a href=\"guide/upgrade-setup\">업그레이드 환경 설정</a> 문서에서 확인할 수 있으며, 이 문서에서는 이렇게 작업합니다:</p>\n<ul>\n<li><code>package.json</code> 파일의 의존성 패키지 목록에 Angular를 추가합니다.</li>\n<li>프로젝트 최상위 폴더에 SystemJS 환경설정 파일 <code>systemjs.config.js</code>를 생성합니다.</li>\n</ul>\n<p>그리고 다음 명령을 실행해 봅시다:</p>\n<code-example format=\"\">\n  npm install\n</code-example>\n<p>이제 Angular 패키지가 설치되었으니 <code>index.html</code> 파일로 앱을 로드할 수 있지만, 일부 폴더의 위치를 먼저 변경해두는 것이 좋습니다.\n지금까지는 애플리케이션에 필요한 패키지와 파일들을 <code>/app</code> 폴더에서 로드했습니다.\n이제는 <code>node_modules</code>와 프로젝트 최상위 폴더에서 로드해야 합니다.</p>\n<p><code>app/index.html</code> 파일을 프로젝트 루트 폴더로 옮깁니다.\n그리고 <code>package.json</code>의 <code>start</code> 스크립트를 다음과 같이 수정합니다:</p>\n<code-example format=\"\">\n  \"start\": \"http-server ./ -a localhost -p 8000 -c-1\",\n</code-example>\n<p>이제 프로젝트 최상위 폴더에 있는 모든 파일은 웹 브라우저로 보낼 수 있습니다.\n하지만 이 작업때문에 애플리케이션 코드에 사용한 이미지 파일이나 데이터를 가리키는 경로가 변경되는 것은 아무도 원하지 <em>않습니다</em>.\n그래서 <code>index.html</code> 파일에 <code>&#x3C;base></code> 태그를 추가해서 이전에 참조했던 <code>/app</code> 폴더를 그대로 가리키도록 다음 내용을 추가합니다:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/index.html\" region=\"base\" header=\"index.html\">\n&#x3C;base href=\"/app/\">\n\n</code-example>\n<p>이번에는 SystemJS로 Angular를 로드해 봅시다.\n<code>&#x3C;head></code> 마지막에 Angular 폴리필과 SystemJS 환경설정 파일을 로드하고 <code>System.import</code>를 사용해서 애플리케이션을 로드합니다:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/index.html\" region=\"angular\" header=\"index.html\">\n&#x3C;script src=\"/node_modules/core-js/client/shim.min.js\">&#x3C;/script>\n&#x3C;script src=\"/node_modules/zone.js/bundles/zone.umd.js\">&#x3C;/script>\n&#x3C;script src=\"/node_modules/systemjs/dist/system.src.js\">&#x3C;/script>\n&#x3C;script src=\"/systemjs.config.js\">&#x3C;/script>\n&#x3C;script>\n  System.import('/app');\n&#x3C;/script>\n\n</code-example>\n<p>필요하다면 <a href=\"guide/upgrade-setup\">환경 설정</a> 문서에서 설명하는 대로 <code>systemjs.config.js</code> 파일을 수정해서 원하는 환경을 지정할 수도 있습니다.</p>\n<p>예를 들면 <code>&#x3C;base></code>를 사용하지 않고 SystemJS 설정으로 프로젝트 루트를 지정할 수 있습니다.</p>\n<p>여기까지 작업하고 나면 <code>npm install @angular/upgrade --save</code> 명령을 실행해서 <code>upgrade</code> 새키지를 설치하고 이 패키지를 <code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code>으로 맵핑합니다.</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/systemjs.config.1.js\" region=\"paths\" header=\"systemjs.config.js\">\n  System.config({\n    paths: {\n      // alias 설정\n      'npm:': '/node_modules/'\n    },\n    map: {\n      'ng-loader': '../src/systemjs-angular-loader.js',\n      app: '/app',\n/* . . . */\n      '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>': 'npm:@angular/upgrade/bundles/upgrade-static.umd.js',\n/* . . . */\n    },\n\n</code-example>\n<!--\n### Creating the _AppModule_\n-->\n<h3 id=\"appmodule-생성하기\"><em>AppModule</em> 생성하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#appmodule-생성하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nNow create the root `NgModule` class called `AppModule`.\nThere is already a file named `app.module.ts` that holds the AngularJS module.\nRename it to `app.module.ajs.ts` and update the corresponding script name in the `index.html` as well.\nThe file contents remain:\n\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ajs.ts\" header=\"app.module.ajs.ts\">\n// `phonecatApp` AngularJS 모듈을 정의합니다.\nangular.module(&#39;phonecatApp&#39;, [\n  &#39;ngAnimate&#39;,\n  &#39;ngRoute&#39;,\n  &#39;core&#39;,\n  &#39;phoneDetail&#39;,\n  &#39;phoneList&#39;,\n]);\n\n\n</code-example>\n\nNow create a new `app.module.ts` with the minimum `NgModule` class:\n\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"bare\" header=\"app.module.ts\">\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { BrowserModule } from &#39;@angular/platform-browser&#39;;\n\n@NgModule({\n  imports: [\n    BrowserModule,\n  ],\n})\nexport class AppModule {\n}\n\n</code-example>\n-->\n<p>이제 최상위 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>인 <code>AppModule</code> 클래스를 생성해 봅시다.\n지금 작업하고 있는 앱에는 <code>app.module.ts</code> 파일에 모듈이 정의되어 있습니다.\n이 파일의 이름을 <code>app.module.ajs.ts</code>로 변경하고 이 파일을 로드하는 <code>index.html</code> 파일도 수정합니다.\n이 파일은 이렇게 작성되어 있습니다:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ajs.ts\" header=\"app.module.ajs.ts\">\n// `phonecatApp` AngularJS 모듈을 정의합니다.\nangular.module('phonecatApp', [\n  'ngAnimate',\n  'ngRoute',\n  'core',\n  'phoneDetail',\n  'phoneList',\n]);\n\n\n</code-example>\n<p>이제 새로운 <code>app.module.ts</code> 파일을 만들고 최소한의 코드로 다음과 같은 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 클래스를 정의합니다:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"bare\" header=\"app.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n  ],\n})\nexport class AppModule {\n}\n\n</code-example>\n<!--\n### Bootstrapping a hybrid PhoneCat\n-->\n<h3 id=\"하이브리드-프로젝트-부트스트랩하기\">하이브리드 프로젝트 부트스트랩하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#하이브리드-프로젝트-부트스트랩하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nNext, you'll bootstrap the application as a *hybrid application*\nthat supports both AngularJS and Angular components. After that,\nyou can start converting the individual pieces to Angular.\n\nThe application is currently bootstrapped using the AngularJS `ng-app` directive\nattached to the `<html>` element of the host page. This will no longer work in the hybrid\napp. Switch to the [ngUpgrade bootstrap](#bootstrapping-hybrid-applications) method\ninstead.\n\nFirst, remove the `ng-app` attribute from `index.html`.\nThen import `UpgradeModule` in the `AppModule`, and override its `ngDoBootstrap` method:\n\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"upgrademodule\" header=\"app/app.module.ts\">\nimport { UpgradeModule } from &#39;@angular/upgrade/static&#39;;\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    UpgradeModule,\n  ],\n})\nexport class AppModule {\n  constructor(private upgrade: UpgradeModule) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, [&#39;phonecatApp&#39;]);\n  }\n}\n\n</code-example>\n\nNote that you are bootstrapping the AngularJS module from inside `ngDoBootstrap`.\nThe arguments are the same as you would pass to `angular.bootstrap` if you were manually\nbootstrapping AngularJS: the root element of the application; and an array of the\nAngularJS 1.x modules that you want to load.\n\nFinally, bootstrap the `AppModule` in `app/main.ts`.\nThis file has been configured as the application entrypoint in `systemjs.config.js`,\nso it is already being loaded by the browser.\n\n<code-example path=\"upgrade-phonecat-2-hybrid/app/main.ts\" region=\"bootstrap\" header=\"app/main.ts\">\nimport { platformBrowserDynamic } from &#39;@angular/platform-browser-dynamic&#39;;\nimport { AppModule } from &#39;./app.module&#39;;\n\nplatformBrowserDynamic().bootstrapModule(AppModule);\n\n</code-example>\n\nNow you're running both AngularJS and Angular at the same time. That's pretty\nexciting! You're not running any actual Angular components yet. That's next.\n-->\n<p>이번에는 AngularJS 컴포넌트와 Angular 컴포넌트가 모두 동작하는 <em>하이브리드 애플리케이션</em> 을 부트스트랩 해 봅시다.\n이 과정을 끝내고 나면 AngularJS 컴포넌트를 하나씩 Angular로 전환할 준비는 모두 끝납니다.</p>\n<p>지금까지는 AngularJS <code>ng-app</code> 디렉티브를 <code>&#x3C;html></code> 엘리먼트에 붙이는 방식으로 앱을 부트스트랩했지만 하이브리드 앱은 이제 이 방식을 사용하지 않습니다.\n<a href=\"guide/upgrade#bootstrapping-hybrid-applications\">ngUpgrade bootstrap</a> 메소드를 사용하는 방식으로 바꿔봅시다.</p>\n<p>먼저 <code>index.html</code> 파일에서 <code>ng-app</code> 어트리뷰트를 제거합니다.\n그리고 <code>AppModule</code>에 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>을 로드하고 <code>ngDoBootstrap</code> 메소드를 다음과 같이 오버라이드합니다:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"upgrademodule\" header=\"app/app.module.ts\">\nimport { <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n  ],\n})\nexport class AppModule {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p><code>ngDoBootstrap</code> 메소드 안에서 부트스트랩 하는 것은 AngularJS 모듈이라는 것을 명심하세요.\n그리고 <code>upgrade.bootstrap</code> 메소드에 전달하는 인자는 AngularJS 앱을 수동으로 부트스트랩할 때 사용했던 <code>angular.bootstrap</code> 메소드의 인자와 같습니다.\n첫번째 인자는 애플리케이션이 들어갈 엘리먼트이며, 두번째 인자는 로드하려는 AngularJS 1.x 모듈을 배열로 전달합니다.</p>\n<p>그리고 이제 <code>app/main.ts</code> 파일에서 <code>AppModule</code>을 부트스트랩합니다.\n이 파일은 <code>systemjs.config.js</code>에서 애플리케이션의 진입점으로 브라우저가 로드하는 파일입니다.</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/main.ts\" region=\"bootstrap\" header=\"app/main.ts\">\nimport { <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a> } from '@angular/platform-browser-dynamic';\nimport { AppModule } from './app.module';\n\n<a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>().bootstrapModule(AppModule);\n\n</code-example>\n<p>이제 AngularJS와 Angular가 동시에 실행됩니다.\n대단하네요!\n이제 Angular 컴포넌트를 만들어 봅시다.</p>\n<div class=\"alert is-helpful\">\n<!--\n#### Why declare _angular_ as _angular.IAngularStatic_?\n-->\n<h4 id=\"왜-angular-를-angulariangularstatic-으로-선언할까요\">왜 <em>angular</em> 를 <em>angular.IAngularStatic</em> 으로 선언할까요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#왜-angular-를-angulariangularstatic-으로-선언할까요\"><i class=\"material-icons\">link</i></a></h4>\n<!--\n`@types/angular` is declared as a UMD module, and due to the way\n<a href=\"https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#support-for-umd-module-definitions\">UMD typings</a>\nwork, once you have an ES6 `import` statement in a file all UMD typed modules must also be\nimported via `import` statements instead of being globally available.\n\nAngularJS is currently loaded by a script tag in `index.html`, which means that the whole app\nhas access to it as a global and uses the same instance of the `angular` variable.\nIf you used `import * as angular from 'angular'` instead, you'd also have to\nload every file in the AngularJS app to use ES2015 modules in order to ensure AngularJS was being\nloaded correctly.\n\nThis is a considerable effort and it often isn't worth it, especially since you are in the\nprocess of moving your code to Angular.\nInstead, declare `angular` as `angular.IAngularStatic` to indicate it is a global variable\nand still have full typing support.\n-->\n<p><code>@types/angular</code>는 UMD 모듈 포맷으로 선언되어 있으며 <a href=\"https://github.com/Microsoft/TypeScript/wiki/What&#x27;s-new-in-TypeScript#support-for-umd-module-definitions\">UMD 모듈 스펙</a>에 따라 ES6 <code>import</code> 구문을 쓰는 파일이 있으면 모든 UMD 타입의 모듈은 <code>import</code> 구문으로 로드됩니다.</p>\n<p>그리고 지금까지 작업한 앱에서 AngularJS는 <code>index.html</code> 파일에서 스크립트 태그로 로드되고 있기 때문에 앱 전역에서 <code>angular</code>라는 변수로 AngularJS에 접근할 수 있습니다.\n그래서 <code>import * as angular from 'angular'</code>라고 구현하면 AngularJS 앱에 있는 모든 파일을 ES2015 모듈 방식으로 순서대로 로드해야 합니다.</p>\n<p>이 작업은 수고가 많이 들지만 그에 비해 얻는 것이 없습니다.\n중요한 것은 AngularJS로 작성한 코드를 Angular로 옮기는 것이지 모듈을 로드하는 올바른 순서를 따지는 것이 아닙니다.\n<code>angular</code>를 <code>angular.IAngularStatic</code>으로 선언하면 이 과정을 간단하게 처리할 수 있습니다.</p>\n</div>\n<!--\n### Upgrading the Phone service\n-->\n<h3 id=\"phone-서비스-업그레이드하기\">Phone 서비스 업그레이드하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#phone-서비스-업그레이드하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe first piece you'll port over to Angular is the `Phone` service, which\nresides in `app/core/phone/phone.service.ts` and makes it possible for components\nto load phone information from the server. Right now it's implemented with\nngResource and you're using it for two things:\n\n* For loading the list of all phones into the phone list component.\n* For loading the details of a single phone into the phone detail component.\n\nYou can replace this implementation with an Angular service class, while\nkeeping the controllers in AngularJS land.\n\nIn the new version, you import the Angular HTTP module and call its `HttpClient` service instead of `ngResource`.\n\nRe-open the `app.module.ts` file, import and add `HttpClientModule` to the `imports` array of the `AppModule`:\n\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"httpclientmodule\" header=\"app.module.ts\">\nimport { HttpClientModule } from &#39;@angular/common/http&#39;;\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    UpgradeModule,\n    HttpClientModule,\n  ],\n})\nexport class AppModule {\n  constructor(private upgrade: UpgradeModule) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, [&#39;phonecatApp&#39;]);\n  }\n}\n\n</code-example>\n\nNow you're ready to upgrade the Phone service itself. Replace the ngResource-based\nservice in `phone.service.ts` with a TypeScript class decorated as `@Injectable`:\n\n<code-example path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" region=\"classdef\" header=\"app/core/phone/phone.service.ts (skeleton)\">\n@Injectable()\nexport class Phone {\n/* . . . */\n}\n\n</code-example>\n\nThe `@Injectable` decorator will attach some dependency injection metadata\nto the class, letting Angular know about its dependencies. As described\nby the [Dependency Injection Guide](guide/dependency-injection),\nthis is a marker decorator you need to use for classes that have no other\nAngular decorators but still need to have their dependencies injected.\n\nIn its constructor the class expects to get the `HttpClient` service. It will\nbe injected to it and it is stored as a private field. The service is then\nused in the two instance methods, one of which loads the list of all phones,\nand the other loads the details of a specified phone:\n\n<code-example path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" region=\"fullclass\" header=\"app/core/phone/phone.service.ts\">\n@Injectable()\nexport class Phone {\n  constructor(private http: HttpClient) { }\n  query(): Observable&lt;PhoneData[]&gt; {\n    return this.http.get&lt;PhoneData[]&gt;(`phones/phones.json`);\n  }\n  get(id: string): Observable&lt;PhoneData&gt; {\n    return this.http.get&lt;PhoneData&gt;(`phones/${id}.json`);\n  }\n}\n\n</code-example>\n\nThe methods now return observables of type `PhoneData` and `PhoneData[]`. This is\na type you don't have yet. Add a simple interface for it:\n\n<code-example path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" region=\"phonedata-interface\" header=\"app/core/phone/phone.service.ts (interface)\">\nexport interface PhoneData {\n  name: string;\n  snippet: string;\n  images: string[];\n}\n\n</code-example>\n\n`@angular/upgrade/static` has a `downgradeInjectable` method for the purpose of making\nAngular services available to AngularJS code. Use it to plug in the `Phone` service:\n\n<code-example path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" region=\"downgrade-injectable\" header=\"app/core/phone/phone.service.ts (downgrade)\">\ndeclare var angular: angular.IAngularStatic;\nimport { downgradeInjectable } from &#39;@angular/upgrade/static&#39;;\n/* . . . */\n@Injectable()\nexport class Phone {\n/* . . . */\n}\n\nangular.module(&#39;core.phone&#39;)\n  .factory(&#39;phone&#39;, downgradeInjectable(Phone));\n\n</code-example>\n\nHere's the full, final code for the service:\n\n<code-example path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" header=\"app/core/phone/phone.service.ts\">\nimport { Injectable } from &#39;@angular/core&#39;;\nimport { HttpClient } from &#39;@angular/common/http&#39;;\nimport { Observable } from &#39;rxjs&#39;;\n\ndeclare var angular: angular.IAngularStatic;\nimport { downgradeInjectable } from &#39;@angular/upgrade/static&#39;;\n\nexport interface PhoneData {\n  name: string;\n  snippet: string;\n  images: string[];\n}\n\n@Injectable()\nexport class Phone {\n  constructor(private http: HttpClient) { }\n  query(): Observable&lt;PhoneData[]&gt; {\n    return this.http.get&lt;PhoneData[]&gt;(`phones/phones.json`);\n  }\n  get(id: string): Observable&lt;PhoneData&gt; {\n    return this.http.get&lt;PhoneData&gt;(`phones/${id}.json`);\n  }\n}\n\nangular.module(&#39;core.phone&#39;)\n  .factory(&#39;phone&#39;, downgradeInjectable(Phone));\n\n\n</code-example>\n\nNotice that you're importing the `map` operator of the RxJS `Observable` separately.\nDo this for every RxJS operator.\n\nThe new `Phone` service has the same features as the original, `ngResource`-based service.\nBecause it's an Angular service, you register it with the `NgModule` providers:\n\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"phone\" header=\"app.module.ts\">\nimport { Phone } from &#39;./core/phone/phone.service&#39;;\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    UpgradeModule,\n    HttpClientModule,\n  ],\n  providers: [\n    Phone,\n  ]\n})\nexport class AppModule {\n  constructor(private upgrade: UpgradeModule) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, [&#39;phonecatApp&#39;]);\n  }\n}\n\n</code-example>\n\nNow that you are loading `phone.service.ts` through an import that is resolved\nby SystemJS, you should **remove the &lt;script&gt; tag** for the service from `index.html`.\nThis is something you'll do to all components as you upgrade them. Simultaneously\nwith the AngularJS to Angular upgrade you're also migrating code from scripts to modules.\n\nAt this point, you can switch the two components to use the new service\ninstead of the old one. While you `$inject` it as the downgraded `phone` factory,\nit's really an instance of the `Phone` class and you annotate its type accordingly:\n\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ajs.ts\" header=\"app/phone-list/phone-list.component.ts\">\ndeclare var angular: angular.IAngularStatic;\nimport { Phone, PhoneData } from &#39;../core/phone/phone.service&#39;;\n\nclass PhoneListController {\n  phones: PhoneData[];\n  orderProp: string;\n\n  static $inject = [&#39;phone&#39;];\n  constructor(phone: Phone) {\n    phone.query().subscribe(phones =&gt; {\n      this.phones = phones;\n    });\n    this.orderProp = &#39;age&#39;;\n  }\n\n}\n\nangular.\n  module(&#39;phoneList&#39;).\n  component(&#39;phoneList&#39;, {\n    templateUrl: &#39;app/phone-list/phone-list.template.html&#39;,\n    controller: PhoneListController\n  });\n\n\n</code-example>\n\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.component.ajs.ts\" header=\"app/phone-detail/phone-detail.component.ts\">\ndeclare var angular: angular.IAngularStatic;\nimport { Phone, PhoneData } from &#39;../core/phone/phone.service&#39;;\n\nclass PhoneDetailController {\n  phone: PhoneData;\n  mainImageUrl: string;\n\n  static $inject = [&#39;$routeParams&#39;, &#39;phone&#39;];\n  constructor($routeParams: angular.route.IRouteParamsService, phone: Phone) {\n    const phoneId = $routeParams.phoneId;\n    phone.get(phoneId).subscribe(data =&gt; {\n      this.phone = data;\n      this.setImage(data.images[0]);\n    });\n  }\n\n  setImage(imageUrl: string) {\n    this.mainImageUrl = imageUrl;\n  }\n}\n\nangular.\n  module(&#39;phoneDetail&#39;).\n  component(&#39;phoneDetail&#39;, {\n    templateUrl: &#39;phone-detail/phone-detail.template.html&#39;,\n    controller: PhoneDetailController\n  });\n\n\n</code-example>\n\nNow there are two AngularJS components using an Angular service!\nThe components don't need to be aware of this, though the fact that the\nservice returns observables and not promises is a bit of a giveaway.\nIn any case, what you've achieved is a migration of a service to Angular\nwithout having to yet migrate the components that use it.\n\n<div class=\"alert is-helpful\">\n\nYou could use the `toPromise` method of `Observable` to turn those\nobservables into promises in the service. In many cases that reduce\nthe number of changes to the component controllers.\n\n</div>\n-->\n<p>AngularJS 구성요소 중에 가장 먼저 Angular로 전환할 것은 <code>Phone</code> 서비스입니다.\n이 서비스는 <code>app/core/phone/phone.service.ts</code> 파일에 정의되어 있으며 컴포넌트가 서버에서 스마트폰 정보를 가져올 때 사용합니다.\n그리고 AngularJS 버전에서 이 서비스는 ngResource를 사용하는 방식으로 구현되어 있으며 다음 두가지 기능을 제공합니다:</p>\n<ul>\n<li>스마트폰 목록을 제공합니다. 이 데이터는 스마트폰 목록을 표시하는 컴포넌트에서 사용합니다.</li>\n<li>스마트폰의 상세정보를 제공합니다. 이 데이터는 스마트폰 상세정보를 표시하는 컴포넌트에서 사용합니다.</li>\n</ul>\n<p>이 기능을 Angular 서비스로 대체해 봅시다.\n일단 AngularJS에는 컨트롤러를 그대로 남겨둔 채로 Angular 서비스 클래스를 정의합니다.</p>\n<p>새로 만드는 Angular 서비스에서는 <code>ngResource</code> 대신 Angular HTTP 모듈이 제공하는 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 서비스를 사용합니다.</p>\n<p><code>app.module.ts</code> 파일을 열고 <code>AppModule</code>의 <code>imports</code> 배열에 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>을 추가합니다:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"httpclientmodule\" header=\"app.module.ts\">\nimport { <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n  ],\n})\nexport class AppModule {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p>이제는 Phone 서비스를 업그레이드할 준비가 끝났습니다.\n<code>phone.service.ts</code> 파일에 ngResource를 사용하도록 구현된 서비스를 TypeScript 클래스로 다시 정의하는데, 이 때 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> 데코레이터를 함께 사용합니다:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" region=\"classdef\" header=\"app/core/phone/phone.service.ts (기본 코드)\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Phone {\n/* . . . */\n}\n\n</code-example>\n<p>클래스에 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> 데코레이터를 붙이면 이 클래스가 의존성으로 주입되는 서비스라는 것을 Angular가 인식할 수 있습니다.\n<a href=\"guide/dependency-injection\">의존성 주입</a> 문서에서 설명한 것처럼 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> 데코레이터는 이 클래스에 의존성 객체를 주입하려는 용도가 아니라 이 클래스가 다른 곳에 의존성으로 주입된다는 것을 표시하는 데코레이터입니다.</p>\n<p>클래스에 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 서비스가 필요하다면 클래스 생성자에서 이 서비스를 요청하면 됩니다.\n그러면 Angular가 적절한 의존성 객체의 인스턴스를 찾아서 주입라며 클래스의 <code>private</code> 멤버로 할당할 수 있습니다.\n스마트폰의 목록을 불러오거나 특정 스마트폰의 상세정보를 요청하는 기능은 이전과 비슷하게 구현합니다:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" region=\"fullclass\" header=\"app/core/phone/phone.service.ts\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Phone {\n  constructor(private <a href=\"api/common/http\" class=\"code-anchor\">http</a>: <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>) { }\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(): Observable&#x3C;PhoneData[]> {\n    return this.http.get&#x3C;PhoneData[]>(`phones/phones.json`);\n  }\n  get(id: string): Observable&#x3C;PhoneData> {\n    return this.http.get&#x3C;PhoneData>(`phones/${id}.json`);\n  }\n}\n\n</code-example>\n<p>이제는 메소드가 반환하는 <code>PhoneData</code>와 <code>PhoneData[]</code>가 옵저버블 타입입니다.\n그리고 <code>PhoneData</code>는 아직 정의되지 않았기 때문에 다음과 같이 간단하게 인터페이스로 정의합니다:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" region=\"phonedata-interface\" header=\"app/core/phone/phone.service.ts (인터페이스)\">\nexport interface PhoneData {\n  name: string;\n  snippet: string;\n  images: string[];\n}\n\n</code-example>\n<p><code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 패키지가 제공하는 <code><a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a></code> 메소드를 사용하면 Angular 서비스를 AngularJS 용으로 다운그레이드 할 수 있습니다.\n이 메소드를 사용해서 <code>Phone</code> 서비스를 연결합니다:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" region=\"downgrade-injectable\" header=\"app/core/phone/phone.service.ts (다운그레이드)\">\ndeclare var angular: angular.IAngularStatic;\nimport { <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n/* . . . */\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Phone {\n/* . . . */\n}\n\nangular.module('core.phone')\n  .factory('phone', <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>(Phone));\n\n</code-example>\n<p>이제 <code>Phone</code> 서비스를 Angular 버전으로 새로 작성한 코드는 이렇습니다:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" header=\"app/core/phone/phone.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\nimport { Observable } from 'rxjs';\n\ndeclare var angular: angular.IAngularStatic;\nimport { <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nexport interface PhoneData {\n  name: string;\n  snippet: string;\n  images: string[];\n}\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Phone {\n  constructor(private <a href=\"api/common/http\" class=\"code-anchor\">http</a>: <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>) { }\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(): Observable&#x3C;PhoneData[]> {\n    return this.http.get&#x3C;PhoneData[]>(`phones/phones.json`);\n  }\n  get(id: string): Observable&#x3C;PhoneData> {\n    return this.http.get&#x3C;PhoneData>(`phones/${id}.json`);\n  }\n}\n\nangular.module('core.phone')\n  .factory('phone', <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>(Phone));\n\n\n</code-example>\n<p>새롭게 만든 <code>Phone</code> 서비스는 이전에 <code>ngResource</code>를 활용하던 서비스와 동일하게 동작합니다.\n이렇게 만든 서비스를 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 프로바이더에 등록합니다:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"phone\" header=\"app.module.ts\">\nimport { Phone } from './core/phone/phone.service';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n  ],\n  providers: [\n    Phone,\n  ]\n})\nexport class AppModule {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p>이제는 SystemJS로 <code>phone.service.ts</code> 파일을 불러오기 때문에 <code>index.html</code>에서 서비스를 <strong>&#x3C;script>로 로드하던 코드를 제거해도</strong>, Angular 버전으로 구현한 서비스를 사용할 수 있습니다.</p>\n<p>AngularJS 컴포넌트가 Angular로 구현한 서비스를 활용할 수 있도록 관련 컴포넌트 2개를 수정해 봅시다.\n컴포넌트 안쪽에서는 <code>$inject</code>를 사용해서 다운그레이드한 <code>phone</code> 팩토리를 사용하지만, 이렇게 주입되는 서비스는 새로 만든 <code>Phone</code> 클래스의 인스턴스가 될 것입니다. 생성자에 이 클래스의 타입을 명확하게 명시해 줍니다:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ajs.ts\" header=\"app/phone-list/phone-list.component.ts\">\ndeclare var angular: angular.IAngularStatic;\nimport { Phone, PhoneData } from '../core/phone/phone.service';\n\nclass PhoneListController {\n  phones: PhoneData[];\n  orderProp: string;\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> $inject = ['phone'];\n  constructor(phone: Phone) {\n    phone.query().subscribe(phones => {\n      this.phones = phones;\n    });\n    this.orderProp = 'age';\n  }\n\n}\n\nangular.\n  module('phoneList').\n  component('phoneList', {\n    templateUrl: 'app/phone-list/phone-list.template.html',\n    controller: PhoneListController\n  });\n\n\n</code-example>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.component.ajs.ts\" header=\"app/phone-detail/phone-detail.component.ts\">\ndeclare var angular: angular.IAngularStatic;\nimport { Phone, PhoneData } from '../core/phone/phone.service';\n\nclass PhoneDetailController {\n  phone: PhoneData;\n  mainImageUrl: string;\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> $inject = ['$routeParams', 'phone'];\n  constructor($routeParams: angular.route.IRouteParamsService, phone: Phone) {\n    const phoneId = $routeParams.phoneId;\n    phone.get(phoneId).subscribe(data => {\n      this.phone = data;\n      this.setImage(data.images[0]);\n    });\n  }\n\n  setImage(imageUrl: string) {\n    this.mainImageUrl = imageUrl;\n  }\n}\n\nangular.\n  module('phoneDetail').\n  component('phoneDetail', {\n    templateUrl: 'phone-detail/phone-detail.template.html',\n    controller: PhoneDetailController\n  });\n\n\n</code-example>\n<p>이제 AngularJS 컴포넌트 2개는 Angular 서비스를 사용합니다!\n그리고 컴포넌트는 이 서비스의 구현방식을 신경쓸 필요가 없으며 이 서비스가 반환하는 데이터의 타입이 이제는 프로미스가 아니라 옵저버블이라는 것만 신경쓰면 됩니다.\nAngularJS 앱을 업그레이드 할 때는 컴포넌트를 마이그레이션하기 전에 서비스부터 먼저 작업하는 것이 좋습니다.</p>\n<div class=\"alert is-helpful\">\n<p>서비스가 반환하는 옵저버블 타입을 프로미스 타입으로 변환하려면 <code>toPromise</code> 메소드를 사용하는 방법도 있습니다.\n컴포넌트 코드를 아직 수정하지 않으려면 이 메소드를 사용하는 것도 고려해볼만 합니다.</p>\n</div>\n<!--\n### Upgrading Components\n-->\n<h3 id=\"컴포넌트-업그레이드하기\">컴포넌트 업그레이드하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#컴포넌트-업그레이드하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nUpgrade the AngularJS components to Angular components next.\nDo it one component at a time while still keeping the application in hybrid mode.\nAs you make these conversions, you'll also define your first Angular *pipes*.\n\nLook at the phone list component first. Right now it contains a TypeScript\ncontroller class and a component definition object. You can morph this into\nan Angular component by just renaming the controller class and turning the\nAngularJS component definition object into an Angular `@Component` decorator.\nYou can then also remove the static `$inject` property from the class:\n\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ts\" region=\"initialclass\" header=\"app/phone-list/phone-list.component.ts\">\nimport { Component } from &#39;@angular/core&#39;;\nimport { Phone, PhoneData } from &#39;../core/phone/phone.service&#39;;\n\n@Component({\n  selector: &#39;phone-list&#39;,\n  templateUrl: &#39;./phone-list.template.html&#39;\n})\nexport class PhoneListComponent {\n  phones: PhoneData[];\n  query: string;\n  orderProp: string;\n\n  constructor(phone: Phone) {\n    phone.query().subscribe(phones =&gt; {\n      this.phones = phones;\n    });\n    this.orderProp = &#39;age&#39;;\n  }\n/* . . . */\n}\n\n</code-example>\n\nThe `selector` attribute is a CSS selector that defines where on the page the component\nshould go. In AngularJS you do matching based on component names, but in Angular you\nhave these explicit selectors. This one will match elements with the name `phone-list`,\njust like the AngularJS version did.\n\nNow convert the template of this component into Angular syntax.\nThe search controls replace the AngularJS `$ctrl` expressions\nwith Angular's two-way `[(ngModel)]` binding syntax:\n\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.template.html\" region=\"controls\" header=\"app/phone-list/phone-list.template.html (search controls)\">\n&lt;p&gt;\n  Search:\n  &lt;input [(ngModel)]=&quot;query&quot; /&gt;\n&lt;/p&gt;\n\n&lt;p&gt;\n  Sort by:\n  &lt;select [(ngModel)]=&quot;orderProp&quot;&gt;\n    &lt;option value=&quot;name&quot;&gt;Alphabetical&lt;/option&gt;\n    &lt;option value=&quot;age&quot;&gt;Newest&lt;/option&gt;\n  &lt;/select&gt;\n&lt;/p&gt;\n\n</code-example>\n\nReplace the list's `ng-repeat` with an `*ngFor` as\n[described in the Template Syntax page](guide/built-in-directives).\nReplace the image tag's `ng-src` with a binding to the native `src` property.\n\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.template.html\" region=\"list\" header=\"app/phone-list/phone-list.template.html (phones)\">\n&lt;ul class=&quot;phones&quot;&gt;\n  &lt;li *ngFor=&quot;let phone of getPhones()&quot;\n      class=&quot;thumbnail phone-list-item&quot;&gt;\n    &lt;a href=&quot;/#!/phones/{{phone.id}}&quot; class=&quot;thumb&quot;&gt;\n      &lt;img [src]=&quot;phone.imageUrl&quot; [alt]=&quot;phone.name&quot; /&gt;\n    &lt;/a&gt;\n    &lt;a href=&quot;/#!/phones/{{phone.id}}&quot; class=&quot;name&quot;&gt;{{phone.name}}&lt;/a&gt;\n    &lt;p&gt;{{phone.snippet}}&lt;/p&gt;\n  &lt;/li&gt;\n&lt;/ul&gt;\n\n</code-example>\n-->\n<p>이번에는 AngularJS 컴포넌트를 Angular 컴포넌트로 업그레이드 해봅시다.\n이 작업은 애플리케이션이 하이브리드 모드로 계속 실행되는 것을 유지하기 위해 한 번에 컴포넌트 하나씩 진행합니다.\n가장 먼저 업그레이드할 부분을 찾아봅시다.</p>\n<p>스마트폰 목록 컴포넌트를 봅시다.\n이 컴포넌트는 TypeScript 컨트롤러 클래스와 컴포넌트를 정의하는 객체로 구성되어 있는데, 이 코드에서 컨트롤러 클래스의 이름을 바꾸고 컴포넌트 정의 객체를 Angular <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 데코레이터로 바꾸기만 하면 이 컴포넌트는 Angular 컴포넌트가 됩니다.\n그리고 나서 클래스에 정적으로 선언된 <code>$inject</code> 프로퍼티를 제거하면 됩니다:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ts\" region=\"initialclass\" header=\"app/phone-list/phone-list.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { Phone, PhoneData } from '../core/phone/phone.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'phone-list',\n  templateUrl: './phone-list.template.html'\n})\nexport class PhoneListComponent {\n  phones: PhoneData[];\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>: string;\n  orderProp: string;\n\n  constructor(phone: Phone) {\n    phone.query().subscribe(phones => {\n      this.phones = phones;\n    });\n    this.orderProp = 'age';\n  }\n/* . . . */\n}\n\n</code-example>\n<p><code>selector</code> 어트리뷰트는 컴포넌트가 화면에서 어느 부분에 위치할지 지정하는 CSS 셀렉터입니다.\n이 셀렉터는 AngularJS에서 컴포넌트 이름과 매칭되는 것을 그대로 사용했지만 Angular에서는 명시적으로 지정해 줘야 합니다.\nAngularJS 버전과 동일하게 <code>phone-list</code>라는 이름을 지정해 줍시다.</p>\n<p>그리고 컴포넌트 템플릿을 Angular 문법으로 변경합니다.\nAngularJS의 <code>$ctrl</code>를 사용하는 표현식을 Angular의 양방향 바인딩 문법 <code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code>로 변경합니다:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.template.html\" region=\"controls\" header=\"app/phone-list/phone-list.template.html (검색 컨트롤)\">\n&#x3C;p>\n  Search:\n  &#x3C;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"<a href=\"api/animations/query\" class=\"code-anchor\">query</a>\" />\n&#x3C;/p>\n\n&#x3C;p>\n  Sort by:\n  &#x3C;select [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"orderProp\">\n    &#x3C;option value=\"name\">Alphabetical&#x3C;/option>\n    &#x3C;option value=\"age\">Newest&#x3C;/option>\n  &#x3C;/select>\n&#x3C;/p>\n\n</code-example>\n<p><code>ng-repeat</code>을 사용한 부분은 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>로 변경합니다.\n<code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>를 사용하는 방법은 <a href=\"guide/built-in-directives\">기본 디렉티브</a> 가이드 문서를 참고하세요.\n그리고 이미지 태그의 <code>ng-src</code>도 <code>src</code> 프로퍼티로 변경합니다.</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.template.html\" region=\"list\" header=\"app/phone-list/phone-list.template.html (스마트폰 목록 템플릿)\">\n&#x3C;ul class=\"phones\">\n  &#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let phone of getPhones()\"\n      class=\"thumbnail phone-list-item\">\n    &#x3C;a href=\"/#!/phones/{{phone.id}}\" class=\"thumb\">\n      &#x3C;img [src]=\"phone.imageUrl\" [alt]=\"phone.name\" />\n    &#x3C;/a>\n    &#x3C;a href=\"/#!/phones/{{phone.id}}\" class=\"name\">{{phone.name}}&#x3C;/a>\n    &#x3C;p>{{phone.snippet}}&#x3C;/p>\n  &#x3C;/li>\n&#x3C;/ul>\n\n</code-example>\n<!--\n#### No Angular _filter_ or _orderBy_ filters\n-->\n<h4 id=\"angular에는-filter-orderby-필터가-없습니다\">Angular에는 <em>filter</em>, <em>orderBy</em> 필터가 없습니다.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#angular에는-filter-orderby-필터가-없습니다\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe built-in AngularJS `filter` and `orderBy` filters do not exist in Angular,\nso you need to do the filtering and sorting yourself.\n\nYou replaced the `filter` and `orderBy` filters with bindings to the `getPhones()` controller method,\nwhich implements the filtering and ordering logic inside the component itself.\n\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ts\" region=\"getphones\" header=\"app/phone-list/phone-list.component.ts\">\ngetPhones(): PhoneData[] {\n  return this.sortPhones(this.filterPhones(this.phones));\n}\n\nprivate filterPhones(phones: PhoneData[]) {\n  if (phones &amp;&amp; this.query) {\n    return phones.filter(phone =&gt; {\n      const name = phone.name.toLowerCase();\n      const snippet = phone.snippet.toLowerCase();\n      return name.indexOf(this.query) &gt;= 0 || snippet.indexOf(this.query) &gt;= 0;\n    });\n  }\n  return phones;\n}\n\nprivate sortPhones(phones: PhoneData[]) {\n  if (phones &amp;&amp; this.orderProp) {\n    return phones\n      .slice(0) // Make a copy\n      .sort((a, b) =&gt; {\n        if (a[this.orderProp] &lt; b[this.orderProp]) {\n          return -1;\n        } else if ([b[this.orderProp] &lt; a[this.orderProp]]) {\n          return 1;\n        } else {\n          return 0;\n        }\n      });\n  }\n  return phones;\n}\n\n</code-example>\n\nNow you need to downgrade the Angular component so you can use it in AngularJS.\nInstead of registering a component, you register a `phoneList` *directive*,\na downgraded version of the Angular component.\n\nThe `as angular.IDirectiveFactory` cast tells the TypeScript compiler\nthat the return value of the `downgradeComponent` method is a directive factory.\n\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ts\" region=\"downgrade-component\" header=\"app/phone-list/phone-list.component.ts\">\ndeclare var angular: angular.IAngularStatic;\nimport { downgradeComponent } from &#39;@angular/upgrade/static&#39;;\n\n/* . . . */\n@Component({\n  selector: &#39;phone-list&#39;,\n  templateUrl: &#39;./phone-list.template.html&#39;\n})\nexport class PhoneListComponent {\n/* . . . */\n}\n\nangular.module(&#39;phoneList&#39;)\n  .directive(\n    &#39;phoneList&#39;,\n    downgradeComponent({component: PhoneListComponent}) as angular.IDirectiveFactory\n  );\n\n</code-example>\n\nThe new `PhoneListComponent` uses the Angular `ngModel` directive, located in the `FormsModule`.\nAdd the `FormsModule` to `NgModule` imports, declare the new `PhoneListComponent` and\nfinally add it to `entryComponents` since you downgraded it:\n\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"phonelist\" header=\"app.module.ts\">\nimport { FormsModule } from &#39;@angular/forms&#39;;\nimport { PhoneListComponent } from &#39;./phone-list/phone-list.component&#39;;\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    UpgradeModule,\n    HttpClientModule,\n    FormsModule,\n  ],\n  declarations: [\n    PhoneListComponent,\n  ],\n  entryComponents: [\n    PhoneListComponent,\n})\nexport class AppModule {\n  constructor(private upgrade: UpgradeModule) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, [&#39;phonecatApp&#39;]);\n  }\n}\n\n</code-example>\n\nRemove the &lt;script&gt; tag for the phone list component from `index.html`.\n\nNow set the remaining `phone-detail.component.ts` as follows:\n\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.component.ts\" header=\"app/phone-detail/phone-detail.component.ts\">\ndeclare var angular: angular.IAngularStatic;\nimport { downgradeComponent } from &#39;@angular/upgrade/static&#39;;\n\nimport { Component } from &#39;@angular/core&#39;;\n\nimport { Phone, PhoneData } from &#39;../core/phone/phone.service&#39;;\nimport { RouteParams } from &#39;../ajs-upgraded-providers&#39;;\n\n@Component({\n  selector: &#39;phone-detail&#39;,\n  templateUrl: &#39;./phone-detail.template.html&#39;,\n})\nexport class PhoneDetailComponent {\n  phone: PhoneData;\n  mainImageUrl: string;\n\n  constructor(routeParams: RouteParams, phone: Phone) {\n    phone.get(routeParams.phoneId).subscribe(data =&gt; {\n      this.phone = data;\n      this.setImage(data.images[0]);\n    });\n  }\n\n  setImage(imageUrl: string) {\n    this.mainImageUrl = imageUrl;\n  }\n}\n\nangular.module(&#39;phoneDetail&#39;)\n  .directive(\n    &#39;phoneDetail&#39;,\n    downgradeComponent({component: PhoneDetailComponent}) as angular.IDirectiveFactory\n  );\n\n\n</code-example>\n\nThis is similar to the phone list component.\nThe new wrinkle is the `RouteParams` type annotation that identifies the `routeParams` dependency.\n\nThe AngularJS injector has an AngularJS router dependency called `$routeParams`,\nwhich was injected into `PhoneDetails` when it was still an AngularJS controller.\nYou intend to inject it into the new `PhoneDetailsComponent`.\n\nUnfortunately, AngularJS dependencies are not automatically available to Angular components.\nYou must upgrade this service via a [factory provider](guide/upgrade#making-angularjs-dependencies-injectable-to-angular)\nto make `$routeParams` an Angular injectable.\nDo that in a new file called `ajs-upgraded-providers.ts` and import it in `app.module.ts`:\n\n<code-example path=\"upgrade-phonecat-2-hybrid/app/ajs-upgraded-providers.ts\" header=\"app/ajs-upgraded-providers.ts\">\nexport abstract class RouteParams {\n  [key: string]: string;\n}\n\nexport function routeParamsFactory(i: any) {\n  return i.get(&#39;$routeParams&#39;);\n}\n\nexport const routeParamsProvider = {\n  provide: RouteParams,\n  useFactory: routeParamsFactory,\n  deps: [&#39;$injector&#39;]\n};\n\n\n</code-example>\n\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"routeparams\" header=\"app/app.module.ts ($routeParams)\">\nimport { routeParamsProvider } from &#39;./ajs-upgraded-providers&#39;;\n  providers: [\n    Phone,\n    routeParamsProvider\n  ]\n\n</code-example>\n\nConvert the phone detail component template into Angular syntax as follows:\n\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.template.html\" header=\"app/phone-detail/phone-detail.template.html\">\n&lt;div *ngIf=&quot;phone&quot;&gt;\n  &lt;div class=&quot;phone-images&quot;&gt;\n    &lt;img [src]=&quot;img&quot; class=&quot;phone&quot;\n        [ngClass]=&quot;{&#39;selected&#39;: img === mainImageUrl}&quot;\n        *ngFor=&quot;let img of phone.images&quot; /&gt;\n  &lt;/div&gt;\n\n  &lt;h1&gt;{{phone.name}}&lt;/h1&gt;\n\n  &lt;p&gt;{{phone.description}}&lt;/p&gt;\n\n  &lt;ul class=&quot;phone-thumbs&quot;&gt;\n    &lt;li *ngFor=&quot;let img of phone.images&quot;&gt;\n      &lt;img [src]=&quot;img&quot; (click)=&quot;setImage(img)&quot; /&gt;\n    &lt;/li&gt;\n  &lt;/ul&gt;\n\n  &lt;ul class=&quot;specs&quot;&gt;\n    &lt;li&gt;\n      &lt;span&gt;Availability and Networks&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;Availability&lt;/dt&gt;\n        &lt;dd *ngFor=&quot;let availability of phone.availability&quot;&gt;{{availability}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Battery&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;Type&lt;/dt&gt;\n        &lt;dd&gt;{{phone.battery?.type}}&lt;/dd&gt;\n        &lt;dt&gt;Talk Time&lt;/dt&gt;\n        &lt;dd&gt;{{phone.battery?.talkTime}}&lt;/dd&gt;\n        &lt;dt&gt;Standby time (max)&lt;/dt&gt;\n        &lt;dd&gt;{{phone.battery?.standbyTime}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Storage and Memory&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;RAM&lt;/dt&gt;\n        &lt;dd&gt;{{phone.storage?.ram}}&lt;/dd&gt;\n        &lt;dt&gt;Internal Storage&lt;/dt&gt;\n        &lt;dd&gt;{{phone.storage?.flash}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Connectivity&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;Network Support&lt;/dt&gt;\n        &lt;dd&gt;{{phone.connectivity?.cell}}&lt;/dd&gt;\n        &lt;dt&gt;WiFi&lt;/dt&gt;\n        &lt;dd&gt;{{phone.connectivity?.wifi}}&lt;/dd&gt;\n        &lt;dt&gt;Bluetooth&lt;/dt&gt;\n        &lt;dd&gt;{{phone.connectivity?.bluetooth}}&lt;/dd&gt;\n        &lt;dt&gt;Infrared&lt;/dt&gt;\n        &lt;dd&gt;{{phone.connectivity?.infrared | checkmark}}&lt;/dd&gt;\n        &lt;dt&gt;GPS&lt;/dt&gt;\n        &lt;dd&gt;{{phone.connectivity?.gps | checkmark}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Android&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;OS Version&lt;/dt&gt;\n        &lt;dd&gt;{{phone.android?.os}}&lt;/dd&gt;\n        &lt;dt&gt;UI&lt;/dt&gt;\n        &lt;dd&gt;{{phone.android?.ui}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Size and Weight&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;Dimensions&lt;/dt&gt;\n        &lt;dd *ngFor=&quot;let dim of phone.sizeAndWeight?.dimensions&quot;&gt;{{dim}}&lt;/dd&gt;\n        &lt;dt&gt;Weight&lt;/dt&gt;\n        &lt;dd&gt;{{phone.sizeAndWeight?.weight}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Display&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;Screen size&lt;/dt&gt;\n        &lt;dd&gt;{{phone.display?.screenSize}}&lt;/dd&gt;\n        &lt;dt&gt;Screen resolution&lt;/dt&gt;\n        &lt;dd&gt;{{phone.display?.screenResolution}}&lt;/dd&gt;\n        &lt;dt&gt;Touch screen&lt;/dt&gt;\n        &lt;dd&gt;{{phone.display?.touchScreen | checkmark}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Hardware&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;CPU&lt;/dt&gt;\n        &lt;dd&gt;{{phone.hardware?.cpu}}&lt;/dd&gt;\n        &lt;dt&gt;USB&lt;/dt&gt;\n        &lt;dd&gt;{{phone.hardware?.usb}}&lt;/dd&gt;\n        &lt;dt&gt;Audio / headphone jack&lt;/dt&gt;\n        &lt;dd&gt;{{phone.hardware?.audioJack}}&lt;/dd&gt;\n        &lt;dt&gt;FM Radio&lt;/dt&gt;\n        &lt;dd&gt;{{phone.hardware?.fmRadio | checkmark}}&lt;/dd&gt;\n        &lt;dt&gt;Accelerometer&lt;/dt&gt;\n        &lt;dd&gt;{{phone.hardware?.accelerometer | checkmark}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Camera&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;Primary&lt;/dt&gt;\n        &lt;dd&gt;{{phone.camera?.primary}}&lt;/dd&gt;\n        &lt;dt&gt;Features&lt;/dt&gt;\n        &lt;dd&gt;{{phone.camera?.features?.join(&#39;, &#39;)}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Additional Features&lt;/span&gt;\n      &lt;dd&gt;{{phone.additionalFeatures}}&lt;/dd&gt;\n    &lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/div&gt;\n\n\n</code-example>\n\nThere are several notable changes here:\n\n* You've removed the `$ctrl.` prefix from all expressions.\n\n* You've replaced `ng-src` with property\n  bindings for the standard `src` property.\n\n* You're using the property binding syntax around `ng-class`. Though Angular\n  does have [a very similar `ngClass`](guide/built-in-directives)\n  as AngularJS does, its value is not magically evaluated as an expression.\n  In Angular, you always specify in the template when an attribute's value is\n  a property expression, as opposed to a literal string.\n\n* You've replaced `ng-repeat`s with `*ngFor`s.\n\n* You've replaced `ng-click` with an event binding for the standard `click`.\n\n* You've wrapped the whole template in an `ngIf` that causes it only to be\n  rendered when there is a phone present. You need this because when the component\n  first loads, you don't have `phone` yet and the expressions will refer to a\n  non-existing value. Unlike in AngularJS, Angular expressions do not fail silently\n  when you try to refer to properties on undefined objects. You need to be explicit\n  about cases where this is expected.\n\nAdd `PhoneDetailComponent` component to the `NgModule` _declarations_ and _entryComponents_:\n\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"phonedetail\" header=\"app.module.ts\">\nimport { PhoneDetailComponent } from &#39;./phone-detail/phone-detail.component&#39;;\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    UpgradeModule,\n    HttpClientModule,\n    FormsModule,\n  ],\n  declarations: [\n    PhoneListComponent,\n    PhoneDetailComponent,\n  ],\n  entryComponents: [\n    PhoneListComponent,\n    PhoneDetailComponent\n  ],\n  providers: [\n    Phone,\n    routeParamsProvider\n  ]\n})\nexport class AppModule {\n  constructor(private upgrade: UpgradeModule) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, [&#39;phonecatApp&#39;]);\n  }\n}\n\n</code-example>\n\nYou should now also remove the phone detail component &lt;script&gt; tag from `index.html`.\n-->\n<p>AngularJS가 제공하는 <code>filter</code>나 <code>orderBy</code> 필터는 Angular에 존재하지 않습니다.\n이 기능은 개발자가 직접 구현해야 합니다.</p>\n<p>이 예제에서는 두 필터의 기능을 컨트롤러 메소드 중 <code>getPhones()</code>에 구현해 봅시다.\n데이터를 필터링하고 정렬하는 로직을 컴포넌트 안에 두기 위한 의도입니다.</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ts\" region=\"getphones\" header=\"app/phone-list/phone-list.component.ts\">\ngetPhones(): PhoneData[] {\n  return this.sortPhones(this.filterPhones(this.phones));\n}\n\nprivate filterPhones(phones: PhoneData[]) {\n  if (phones &#x26;&#x26; this.query) {\n    return phones.filter(phone => {\n      const name = phone.name.toLowerCase();\n      const snippet = phone.snippet.toLowerCase();\n      return name.indexOf(this.query) >= 0 || snippet.indexOf(this.query) >= 0;\n    });\n  }\n  return phones;\n}\n\nprivate sortPhones(phones: PhoneData[]) {\n  if (phones &#x26;&#x26; this.orderProp) {\n    return phones\n      .slice(0) // Make a copy\n      .sort((a, b) => {\n        if (a[this.orderProp] &#x3C; b[this.orderProp]) {\n          return -1;\n        } else if ([b[this.orderProp] &#x3C; a[this.orderProp]]) {\n          return 1;\n        } else {\n          return 0;\n        }\n      });\n  }\n  return phones;\n}\n\n</code-example>\n<p>그러면 이제 Angular 컴포넌트를 다운그레이드 하면 AngularJS에도 사용할 수 잇습니다.\n이 문서에서는 AngularJS의 컴포넌트로 등록하지 않고 <code>phoneList</code> <em>디렉티브</em>로 등록해 봅시다.</p>\n<p><code>as angular.IDirectiveFactory</code>라는 코드는 <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a></code> 메소드가 반환한 결과물이 디렉티브 팩토리라는 것을 TypeScript 컴파일러에게 알려주기 위한 코드입니다.</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ts\" region=\"downgrade-component\" header=\"app/phone-list/phone-list.component.ts\">\ndeclare var angular: angular.IAngularStatic;\nimport { <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\n/* . . . */\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'phone-list',\n  templateUrl: './phone-list.template.html'\n})\nexport class PhoneListComponent {\n/* . . . */\n}\n\nangular.module('phoneList')\n  .directive(\n    'phoneList',\n    <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>({component: PhoneListComponent}) as angular.IDirectiveFactory\n  );\n\n</code-example>\n<p>새로 만든 <code>PhoneListComponent</code>는 Angular <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>이 제공하는 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 디렉티브를 활용합니다.\n그래서 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>을 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>의 <code>imports</code> 배열에 추가하고 <code>entryComponents</code>에 <code>PhoneListComponent</code>를 추가하면 컴포넌트 다운그레이드가 끝납니다:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"phonelist\" header=\"app.module.ts\">\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { PhoneListComponent } from './phone-list/phone-list.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n  ],\n  declarations: [\n    PhoneListComponent,\n  ],\n  entryComponents: [\n    PhoneListComponent,\n})\nexport class AppModule {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p><code>index.html</code>에서 스마트폰 목록 컴포넌트를 로드하는 &#x3C;script> 태그를 제거하세요.</p>\n<p>그리고 <code>phone-detail.component.ts</code> 파일도 같은 방식으로 처리합니다:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.component.ts\" header=\"app/phone-detail/phone-detail.component.ts\">\ndeclare var angular: angular.IAngularStatic;\nimport { <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\nimport { Phone, PhoneData } from '../core/phone/phone.service';\nimport { RouteParams } from '../ajs-upgraded-providers';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'phone-detail',\n  templateUrl: './phone-detail.template.html',\n})\nexport class PhoneDetailComponent {\n  phone: PhoneData;\n  mainImageUrl: string;\n\n  constructor(routeParams: RouteParams, phone: Phone) {\n    phone.get(routeParams.phoneId).subscribe(data => {\n      this.phone = data;\n      this.setImage(data.images[0]);\n    });\n  }\n\n  setImage(imageUrl: string) {\n    this.mainImageUrl = imageUrl;\n  }\n}\n\nangular.module('phoneDetail')\n  .directive(\n    'phoneDetail',\n    <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>({component: PhoneDetailComponent}) as angular.IDirectiveFactory\n  );\n\n\n</code-example>\n<p>이 컴포넌트는 스마트폰 목록을 표시하는 컴포넌트와 비슷합니다.\n<code>RouteParams</code> 타입으로 받은 의존성 객체를 <code>routeParams</code> 프로퍼티로 받는다는 점이 가장 큰 차이입니다.</p>\n<p>AngularJS에는 <code>routeParams</code>이라는 의존성 객체가 있는데 이 객체는 AngularJS 버전의 <code>PhoneDetails</code> 컴포넌트 컨트롤러에서 라우터와 관련된 기능을 활용하기 위해 주입받는 객체입니다.\n새로 만든 <code>PhoneDetailsComponent</code>에도 이 의존성 객체를 주입해 봅시다.</p>\n<p>하지만 AngularJS에서 활용하는 의존성 객체들을 Angular 컴포넌트에 그대로 사용할 수 있는 것은 아닙니다.\n<code>$routeParams</code>를 Angular에 의존성으로 주입하려면 <a href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\">팩토리 프로바이더</a>를 사용해서 이 서비스를 업그레이드해야 합니다.\n이 동작은 <code>ajs-upgraded-providers.ts</code>라는 파일을 새로 만들어서 구현하고, <code>app.module.ts</code>이 불러오도록 구현해 봅시다:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/ajs-upgraded-providers.ts\" header=\"app/ajs-upgraded-providers.ts\">\nexport abstract class RouteParams {\n  [key: string]: string;\n}\n\nexport function routeParamsFactory(i: any) {\n  return i.get('$routeParams');\n}\n\nexport const routeParamsProvider = {\n  provide: RouteParams,\n  useFactory: routeParamsFactory,\n  deps: ['$injector']\n};\n\n\n</code-example>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"routeparams\" header=\"app/app.module.ts ($routeParams)\">\nimport { routeParamsProvider } from './ajs-upgraded-providers';\n  providers: [\n    Phone,\n    routeParamsProvider\n  ]\n\n</code-example>\n<p>그리고 스마트폰 상세정보 컴포넌트의 템플릿을 Angular 문법으로 변환합니다:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.template.html\" header=\"app/phone-detail/phone-detail.template.html\">\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"phone\">\n  &#x3C;div class=\"phone-images\">\n    &#x3C;img [src]=\"img\" class=\"phone\"\n        [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"{'selected': img === mainImageUrl}\"\n        *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let img of phone.images\" />\n  &#x3C;/div>\n\n  &#x3C;h1>{{phone.name}}&#x3C;/h1>\n\n  &#x3C;p>{{phone.description}}&#x3C;/p>\n\n  &#x3C;ul class=\"phone-thumbs\">\n    &#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let img of phone.images\">\n      &#x3C;img [src]=\"img\" (click)=\"setImage(img)\" />\n    &#x3C;/li>\n  &#x3C;/ul>\n\n  &#x3C;ul class=\"specs\">\n    &#x3C;li>\n      &#x3C;span>Availability and Networks&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>Availability&#x3C;/dt>\n        &#x3C;dd *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let availability of phone.availability\">{{availability}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Battery&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt><a href=\"api/core/Type\" class=\"code-anchor\">Type</a>&#x3C;/dt>\n        &#x3C;dd>{{phone.battery?.type}}&#x3C;/dd>\n        &#x3C;dt>Talk <a href=\"api/common/Time\" class=\"code-anchor\">Time</a>&#x3C;/dt>\n        &#x3C;dd>{{phone.battery?.talkTime}}&#x3C;/dd>\n        &#x3C;dt>Standby time (max)&#x3C;/dt>\n        &#x3C;dd>{{phone.battery?.standbyTime}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Storage and Memory&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>RAM&#x3C;/dt>\n        &#x3C;dd>{{phone.storage?.ram}}&#x3C;/dd>\n        &#x3C;dt>Internal Storage&#x3C;/dt>\n        &#x3C;dd>{{phone.storage?.flash}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Connectivity&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>Network Support&#x3C;/dt>\n        &#x3C;dd>{{phone.connectivity?.cell}}&#x3C;/dd>\n        &#x3C;dt>WiFi&#x3C;/dt>\n        &#x3C;dd>{{phone.connectivity?.wifi}}&#x3C;/dd>\n        &#x3C;dt>Bluetooth&#x3C;/dt>\n        &#x3C;dd>{{phone.connectivity?.bluetooth}}&#x3C;/dd>\n        &#x3C;dt>Infrared&#x3C;/dt>\n        &#x3C;dd>{{phone.connectivity?.infrared | checkmark}}&#x3C;/dd>\n        &#x3C;dt>GPS&#x3C;/dt>\n        &#x3C;dd>{{phone.connectivity?.gps | checkmark}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Android&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>OS <a href=\"api/core/Version\" class=\"code-anchor\">Version</a>&#x3C;/dt>\n        &#x3C;dd>{{phone.android?.os}}&#x3C;/dd>\n        &#x3C;dt>UI&#x3C;/dt>\n        &#x3C;dd>{{phone.android?.ui}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Size and Weight&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>Dimensions&#x3C;/dt>\n        &#x3C;dd *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let dim of phone.sizeAndWeight?.dimensions\">{{dim}}&#x3C;/dd>\n        &#x3C;dt>Weight&#x3C;/dt>\n        &#x3C;dd>{{phone.sizeAndWeight?.weight}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Display&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>Screen size&#x3C;/dt>\n        &#x3C;dd>{{phone.display?.screenSize}}&#x3C;/dd>\n        &#x3C;dt>Screen resolution&#x3C;/dt>\n        &#x3C;dd>{{phone.display?.screenResolution}}&#x3C;/dd>\n        &#x3C;dt>Touch screen&#x3C;/dt>\n        &#x3C;dd>{{phone.display?.touchScreen | checkmark}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Hardware&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>CPU&#x3C;/dt>\n        &#x3C;dd>{{phone.hardware?.cpu}}&#x3C;/dd>\n        &#x3C;dt>USB&#x3C;/dt>\n        &#x3C;dd>{{phone.hardware?.usb}}&#x3C;/dd>\n        &#x3C;dt>Audio / headphone jack&#x3C;/dt>\n        &#x3C;dd>{{phone.hardware?.audioJack}}&#x3C;/dd>\n        &#x3C;dt>FM Radio&#x3C;/dt>\n        &#x3C;dd>{{phone.hardware?.fmRadio | checkmark}}&#x3C;/dd>\n        &#x3C;dt>Accelerometer&#x3C;/dt>\n        &#x3C;dd>{{phone.hardware?.accelerometer | checkmark}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Camera&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>Primary&#x3C;/dt>\n        &#x3C;dd>{{phone.camera?.primary}}&#x3C;/dd>\n        &#x3C;dt>Features&#x3C;/dt>\n        &#x3C;dd>{{phone.camera?.features?.join(', ')}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Additional Features&#x3C;/span>\n      &#x3C;dd>{{phone.additionalFeatures}}&#x3C;/dd>\n    &#x3C;/li>\n  &#x3C;/ul>\n&#x3C;/div>\n\n\n</code-example>\n<p>변경사항 중에서 이런 내용을 주의깊게 봅시다:</p>\n<ul>\n<li>\n<p>모든 표현식에서 <code>$ctrl.</code> 접두사를 제거했습니다.</p>\n</li>\n<li>\n<p>프로퍼티 바인딩에 사용된 <code>ng-src</code>는 표준 프로퍼티 <code>src</code>를 바인딩하는 방식으로 변경했습니다.</p>\n</li>\n<li>\n<p>AngularJS에서는 클래스를 바인딩하기 위해 <code>ng-class</code>를 사용했습니다.\n이 코드는 Angular에서 <a href=\"guide/built-in-directives\">거의 비슷한 동작을 하는 <code>ngClass</code></a>로 변경되었으며 사용법도 비슷합니다.\n그리고 표현식이 실행된 결과는 객체이기 때문에 프로퍼티 바인딩으로 연결했습니다.</p>\n</li>\n<li>\n<p><code>ng-repeat</code>은 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>로 변경했습니다.</p>\n</li>\n<li>\n<p><code>ng-click</code>은 표준 이벤트 <code>click</code>으로 변경되었습니다.</p>\n</li>\n<li>\n<p>스마트폰 객체가 유효할 때만 화면을 렌더링하기 위해 템플릿 전체는 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>로 감쌌습니다.\n컴포넌트가 처음 로드된 시점에는 <code>phone</code>이 존재하지 않기 때문에 빈값을 참조하는 표현식이 모두 제대로 실행되지 않습니다.\nAngularJS와는 다르게 Angular 표현식은 빈 객체를 참조할 때 에러를 출력하기 때문에, 실제로 객체가 존재할 때만 표현식을 실행하기 위해 작성했습니다.</p>\n</li>\n</ul>\n<p>그리고 <code>PhoneDetailComponent</code>를 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>의 <em>declarations</em> 와 <em>entryComponents</em> 에 추가합니다:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"phonedetail\" header=\"app.module.ts\">\nimport { PhoneDetailComponent } from './phone-detail/phone-detail.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n  ],\n  declarations: [\n    PhoneListComponent,\n    PhoneDetailComponent,\n  ],\n  entryComponents: [\n    PhoneListComponent,\n    PhoneDetailComponent\n  ],\n  providers: [\n    Phone,\n    routeParamsProvider\n  ]\n})\nexport class AppModule {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p>이제는 이전과 마찬가지로 <code>index.html</code>에서 컴포넌트 파일을 불러오던 &#x3C;script> 태그를 제거해도 됩니다.</p>\n<!--\n#### Add the _CheckmarkPipe_\n-->\n<h4 id=\"checkmarkpipe-변환하기\"><em>CheckmarkPipe</em> 변환하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#checkmarkpipe-변환하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe AngularJS directive had a `checkmark` _filter_.\nTurn that into an Angular **pipe**.\n\nThere is no upgrade method to convert filters into pipes.\nYou won't miss it.\nIt's easy to turn the filter function into an equivalent Pipe class.\nThe implementation is the same as before, repackaged in the `transform` method.\nRename the file to `checkmark.pipe.ts` to conform with Angular conventions:\n\n<code-example path=\"upgrade-phonecat-2-hybrid/app/core/checkmark/checkmark.pipe.ts\" header=\"app/core/checkmark/checkmark.pipe.ts\">\nimport { Pipe, PipeTransform } from &#39;@angular/core&#39;;\n\n@Pipe({name: &#39;checkmark&#39;})\nexport class CheckmarkPipe implements PipeTransform {\n  transform(input: boolean) {\n    return input ? &#39;\\u2713&#39; : &#39;\\u2718&#39;;\n  }\n}\n\n\n</code-example>\n\nNow import and declare the newly created pipe and\nremove the filter &lt;script&gt; tag from `index.html`:\n\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"checkmarkpipe\" header=\"app.module.ts\">\nimport { CheckmarkPipe } from &#39;./core/checkmark/checkmark.pipe&#39;;\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    UpgradeModule,\n    HttpClientModule,\n    FormsModule,\n  ],\n  declarations: [\n    PhoneListComponent,\n    PhoneDetailComponent,\n    CheckmarkPipe\n  ],\n  entryComponents: [\n    PhoneListComponent,\n    PhoneDetailComponent\n  ],\n  providers: [\n    Phone,\n    routeParamsProvider\n  ]\n})\nexport class AppModule {\n  constructor(private upgrade: UpgradeModule) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, [&#39;phonecatApp&#39;]);\n  }\n}\n\n</code-example>\n-->\n<p>AngularJS 프로젝트에 정의된 디렉티브 중에는 <code>checkmark</code>라는 <em>필터</em> 가 있습니다.\n이 필터를 Angular <strong>파이프</strong>로 변환해 봅시다.</p>\n<p>AngularJS 필터를 Angular 파이프로 변환하는 메소드는 따로 지원되지 않지만 이 과정은 간단합니다.\n필터 함수를 파이프 클래스로 새로 구현하면 됩니다.\n그리고 이 때 Angular 파이프 클래스에 <code><a href=\"api/core/PipeTransform\" class=\"code-anchor\">PipeTransform</a></code> 클래스를 확장해서 <code>transform</code> 메소드를 정의하면 됩니다.\nAngular 스타일에 맞게 파이프 파일의 이름을 <code>checkmark.pipe.ts</code>로 바꾸고 다음과 같이 수정해 봅시다:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/core/checkmark/checkmark.pipe.ts\" header=\"app/core/checkmark/checkmark.pipe.ts\">\nimport { <a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a>, <a href=\"api/core/PipeTransform\" class=\"code-anchor\">PipeTransform</a> } from '@angular/core';\n\n@<a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a>({name: 'checkmark'})\nexport class CheckmarkPipe implements <a href=\"api/core/PipeTransform\" class=\"code-anchor\">PipeTransform</a> {\n  transform(input: boolean) {\n    return input ? '\\u2713' : '\\u2718';\n  }\n}\n\n\n</code-example>\n<p>그리고 이렇게 만든 파이프는 <code>AppModule</code>에 등록해서 로드하기 때문에 <code>index.html</code> 파일에서 필터를 로드하는 &#x3C;script> 부분은 제거해도 됩니다:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"checkmarkpipe\" header=\"app.module.ts\">\nimport { CheckmarkPipe } from './core/checkmark/checkmark.pipe';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n  ],\n  declarations: [\n    PhoneListComponent,\n    PhoneDetailComponent,\n    CheckmarkPipe\n  ],\n  entryComponents: [\n    PhoneListComponent,\n    PhoneDetailComponent\n  ],\n  providers: [\n    Phone,\n    routeParamsProvider\n  ]\n})\nexport class AppModule {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<!--\n### AOT compile the hybrid app\n-->\n<h3 id=\"하이브리드-앱을-aot-컴파일하기\">하이브리드 앱을 AOT 컴파일하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#하이브리드-앱을-aot-컴파일하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nTo use AOT with a hybrid app, you have to first set it up like any other Angular application,\nas shown in [the Ahead-of-time Compilation chapter](guide/aot-compiler).\n\nThen change `main-aot.ts` to bootstrap the `AppComponentFactory` that was generated\nby the AOT compiler:\n\n<code-example path=\"upgrade-phonecat-2-hybrid/app/main-aot.ts\" header=\"app/main-aot.ts\">\nimport { platformBrowser } from &#39;@angular/platform-browser&#39;;\n\nimport { AppModuleNgFactory } from &#39;./app.module.ngfactory&#39;;\n\nplatformBrowser().bootstrapModuleFactory(AppModuleNgFactory);\n\n\n</code-example>\n\nYou need to load all the AngularJS files you already use in `index.html` in `aot/index.html`\nas well:\n\n<code-example path=\"upgrade-phonecat-2-hybrid/aot/index.html\" header=\"aot/index.html\">\n&lt;!doctype html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;utf-8&quot;&gt;\n\n    &lt;base href=&quot;/app/&quot;&gt;\n\n    &lt;title&gt;Google Phone Gallery&lt;/title&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css&quot; /&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;app.css&quot; /&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;app.animations.css&quot; /&gt;\n\n    &lt;script src=&quot;https://code.jquery.com/jquery-2.2.4.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;https://code.angularjs.org/1.5.5/angular.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;https://code.angularjs.org/1.5.5/angular-animate.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;https://code.angularjs.org/1.5.5/angular-resource.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;https://code.angularjs.org/1.5.5/angular-route.js&quot;&gt;&lt;/script&gt;\n\n    &lt;script src=&quot;app.module.ajs.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;app.config.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;app.animations.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;core/core.module.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;core/phone/phone.module.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;phone-list/phone-list.module.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;phone-detail/phone-detail.module.js&quot;&gt;&lt;/script&gt;\n\n    &lt;script src=&quot;/node_modules/core-js/client/shim.min.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;/node_modules/zone.js/bundles/zone.umd.min.js&quot;&gt;&lt;/script&gt;\n\n    &lt;script&gt;window.module = &#39;aot&#39;;&lt;/script&gt;\n  &lt;/head&gt;\n\n  &lt;body&gt;\n    &lt;div class=&quot;view-container&quot;&gt;\n      &lt;div ng-view class=&quot;view-frame&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/body&gt;\n  &lt;script src=&quot;/dist/build.js&quot;&gt;&lt;/script&gt;\n&lt;/html&gt;\n\n\n</code-example>\n\nThese files need to be copied together with the polyfills. The files the application\nneeds at runtime, like the `.json` phone lists and images, also need to be copied.\n\nInstall `fs-extra` via `npm install fs-extra --save-dev` for better file copying, and change\n`copy-dist-files.js` to the following:\n\n<code-example path=\"upgrade-phonecat-2-hybrid/copy-dist-files.js\" header=\"copy-dist-files.js\">\nvar fsExtra = require(&#39;fs-extra&#39;);\nvar resources = [\n  // polyfills\n  &#39;node_modules/core-js/client/shim.min.js&#39;,\n  &#39;node_modules/zone.js/bundles/zone.umd.min.js&#39;,\n  // css\n  &#39;app/app.css&#39;,\n  &#39;app/app.animations.css&#39;,\n  // images and json files\n  &#39;app/img/&#39;,\n  &#39;app/phones/&#39;,\n  // app files\n  &#39;app/app.module.ajs.js&#39;,\n  &#39;app/app.config.js&#39;,\n  &#39;app/app.animations.js&#39;,\n  &#39;app/core/core.module.js&#39;,\n  &#39;app/core/phone/phone.module.js&#39;,\n  &#39;app/phone-list/phone-list.module.js&#39;,\n  &#39;app/phone-detail/phone-detail.module.js&#39;\n];\nresources.map(function(sourcePath) {\n  // Need to rename zone.umd.min.js to zone.min.js\n  var destPath = `aot/${sourcePath}`.replace(&#39;.umd.min.js&#39;, &#39;.min.js&#39;);\n  fsExtra.copySync(sourcePath, destPath);\n});\n\n\n</code-example>\n\nAnd that's all you need to use AOT while upgrading your app!\n-->\n<p>하이브리드 앱을 AOT 컴파일하려면 <a href=\"guide/aot-compiler\">AOT 컴파일러 챕터</a>에서 설명한 것처럼 Angular 애플리케이션 빌드 환경을 설정해야 합니다.</p>\n<p>그리고 AOT 컴파일러가 만든 <code>ApPComponentFactory</code>를 부트스트랩하도록 <code>main-aot.ts</code> 파일을 수정합니다:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/main-aot.ts\" header=\"app/main-aot.ts\">\nimport { <a href=\"api/platform-browser/platformBrowser\" class=\"code-anchor\">platformBrowser</a> } from '@angular/platform-browser';\n\nimport { AppModuleNgFactory } from './app.module.ngfactory';\n\n<a href=\"api/platform-browser/platformBrowser\" class=\"code-anchor\">platformBrowser</a>().bootstrapModuleFactory(AppModuleNgFactory);\n\n\n</code-example>\n<p>그 다음에는 <code>index.html</code>에서 로드하던 AngularJS 파일을 모두 <code>aot/index.html</code> 파일에 추가합니다:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/aot/index.html\" header=\"aot/index.html\">\n&#x3C;!doctype html>\n&#x3C;html lang=\"en\">\n  &#x3C;head>\n    &#x3C;meta charset=\"utf-8\">\n\n    &#x3C;base href=\"/app/\">\n\n    &#x3C;title>Google Phone Gallery&#x3C;/title>\n    &#x3C;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css\" />\n    &#x3C;link rel=\"stylesheet\" href=\"app.css\" />\n    &#x3C;link rel=\"stylesheet\" href=\"app.animations.css\" />\n\n    &#x3C;script src=\"https://code.jquery.com/jquery-2.2.4.js\">&#x3C;/script>\n    &#x3C;script src=\"https://code.angularjs.org/1.5.5/angular.js\">&#x3C;/script>\n    &#x3C;script src=\"https://code.angularjs.org/1.5.5/angular-animate.js\">&#x3C;/script>\n    &#x3C;script src=\"https://code.angularjs.org/1.5.5/angular-resource.js\">&#x3C;/script>\n    &#x3C;script src=\"https://code.angularjs.org/1.5.5/angular-route.js\">&#x3C;/script>\n\n    &#x3C;script src=\"app.module.ajs.js\">&#x3C;/script>\n    &#x3C;script src=\"app.config.js\">&#x3C;/script>\n    &#x3C;script src=\"app.animations.js\">&#x3C;/script>\n    &#x3C;script src=\"core/core.module.js\">&#x3C;/script>\n    &#x3C;script src=\"core/phone/phone.module.js\">&#x3C;/script>\n    &#x3C;script src=\"phone-list/phone-list.module.js\">&#x3C;/script>\n    &#x3C;script src=\"phone-detail/phone-detail.module.js\">&#x3C;/script>\n\n    &#x3C;script src=\"/node_modules/core-js/client/shim.min.js\">&#x3C;/script>\n    &#x3C;script src=\"/node_modules/zone.js/bundles/zone.umd.min.js\">&#x3C;/script>\n\n    &#x3C;script>window.module = 'aot';&#x3C;/script>\n  &#x3C;/head>\n\n  &#x3C;body>\n    &#x3C;div class=\"view-container\">\n      &#x3C;div ng-view class=\"view-frame\">&#x3C;/div>\n    &#x3C;/div>\n  &#x3C;/body>\n  &#x3C;script src=\"/dist/build.js\">&#x3C;/script>\n&#x3C;/html>\n\n\n</code-example>\n<p>AngularJS 코드가 담긴 파일들과 폴리필을 <code>aot</code> 프로젝트 폴더에 복사합니다.\n그리고 애플리케이션이 실행되면서 필요한 스마트폰 목록이 담긴 <code>.json</code> 파일이나 이미지 파일도 함께 복사해야 합니다.</p>\n<p><code>npm install fs-extra --save-dev</code> 명령을 실행해서 <code>fs-extra</code> 패키지를 설치하면 파일 복사 과정을 쉽게 처리할 수 있습니다.\n<code>copy-dist-files.js</code> 파일을 이렇게 작성하면 됩니다:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/copy-dist-files.js\" header=\"copy-dist-files.js\">\nvar fsExtra = require('fs-extra');\nvar resources = [\n  // polyfills\n  'node_modules/core-js/client/shim.min.js',\n  'node_modules/zone.js/bundles/zone.umd.min.js',\n  // css\n  'app/app.css',\n  'app/app.animations.css',\n  // images and json files\n  'app/img/',\n  'app/phones/',\n  // app files\n  'app/app.module.ajs.js',\n  'app/app.config.js',\n  'app/app.animations.js',\n  'app/core/core.module.js',\n  'app/core/phone/phone.module.js',\n  'app/phone-list/phone-list.module.js',\n  'app/phone-detail/phone-detail.module.js'\n];\nresources.map(function(sourcePath) {\n  // Need to rename zone.umd.min.js to zone.min.js\n  var destPath = `aot/${sourcePath}`.replace('.umd.min.js', '.min.js');\n  fsExtra.copySync(sourcePath, destPath);\n});\n\n\n</code-example>\n<p>이제 애플리케이션에 AOT 컴파일러를 적용할 수 있습니다!</p>\n<!--\n### Adding The Angular Router And Bootstrap\n-->\n<h3 id=\"angular-라우터-추가하고-부트스트랩하기\">Angular 라우터 추가하고 부트스트랩하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#angular-라우터-추가하고-부트스트랩하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAt this point, you've replaced all AngularJS application components with\ntheir Angular counterparts, even though you're still serving them from the AngularJS router.\n-->\n<p>여기까지 AngularJS 애플리케이션의 모든 컴포넌트를 Angular로 변환했지만 아직 애플리케이션은 AngularJS 라우터를 사용하고 있습니다.</p>\n<!--\n#### Add the Angular router\n-->\n<h4 id=\"angular-라우터-추가하기\">Angular 라우터 추가하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#angular-라우터-추가하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nAngular has an [all-new router](guide/router).\n\nLike all routers, it needs a place in the UI to display routed views.\nFor Angular that's the `<router-outlet>` and it belongs in a *root component*\nat the top of the applications component tree.\n\nYou don't yet have such a root component, because the app is still managed as an AngularJS app.\nCreate a new `app.component.ts` file with the following `AppComponent` class:\n\n<code-example path=\"upgrade-phonecat-3-final/app/app.component.ts\" header=\"app/app.component.ts\">\nimport { Component } from &#39;@angular/core&#39;;\n\n@Component({\n  selector: &#39;phonecat-app&#39;,\n  template: &#39;&lt;router-outlet&gt;&lt;/router-outlet&gt;&#39;\n})\nexport class AppComponent { }\n\n\n</code-example>\n\nIt has a simple template that only includes the `<router-outlet>`.\nThis component just renders the contents of the active route and nothing else.\n\nThe selector tells Angular to plug this root component into the `<phonecat-app>`\nelement on the host web page when the application launches.\n\nAdd this `<phonecat-app>` element to the `index.html`.\nIt replaces the old AngularJS `ng-view` directive:\n\n<code-example path=\"upgrade-phonecat-3-final/index.html\" region=\"appcomponent\" header=\"index.html (body)\">\n&lt;body&gt;\n  &lt;phonecat-app&gt;&lt;/phonecat-app&gt;\n&lt;/body&gt;\n\n</code-example>\n-->\n<p>Angular가 제공하는 라우터는 <a href=\"guide/router\">이전과 완전히 다른 라우터</a> 입니다.</p>\n<p>그리고 다른 라우터들과 마찬가지로 Angular 라우터를 사용할 때도 화면에 라우팅된 화면을 표시할 부분을 지정해야 합니다.\nAngular에서는 이 영역을 <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code>으로 지정하는데, 최상위 라우팅 영역은 애플리케이션 컴포넌트 트리의 <em>최상위 컴포넌트</em>에 추가하는 것이 일반적입니다.</p>\n<p>하지만 아직까지는 AngularJS 애플리케이션이 화면을 전환하기 때문에 최상위 컴포넌트가 없다고 볼 수 있습니다.\n<code>app.component.ts</code> 파일을 생성하고 이 파일에 <code>AppComponent</code> 클래스를 다음과 같이 정의합니다:</p>\n<code-example path=\"upgrade-phonecat-3-final/app/app.component.ts\" header=\"app/app.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'phonecat-app',\n  template: '&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>'\n})\nexport class AppComponent { }\n\n\n</code-example>\n<p>이 컴포넌트 템플릿에는 <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code>만 간단하게 존재합니다.\n왜냐하면 이 컴포넌트는 활성화되는 라우팅 규칙과 연결되는 컴포넌트를 표시하는 것 외에 다른 역할을 하지 않기 때문입니다.</p>\n<p>그리고 셀렉터에 <code>phonecat-app</code>을 지정했기 때문에 이 최상위 컴포넌트는 애플리케이션이 실행되는 호스트 웹 페이지의 <code>&#x3C;phonecat-app></code>에 렌더링됩니다.</p>\n<p><code>index.html</code> 파일에 <code>&#x3C;phonecat-app></code> 엘리먼트를 추가하고 이전에 있던 AngularJS <code>ng-view</code> 디렉티브를 제거합니다:</p>\n<code-example path=\"upgrade-phonecat-3-final/index.html\" region=\"appcomponent\" header=\"index.html (body)\">\n&#x3C;body>\n  &#x3C;phonecat-app>&#x3C;/phonecat-app>\n&#x3C;/body>\n\n</code-example>\n<!--\n#### Create the _Routing Module_\n-->\n<h4 id=\"라우팅-모듈-생성하기\"><em>라우팅 모듈</em> 생성하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#라우팅-모듈-생성하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nA router needs configuration whether it's the AngularJS or Angular or any other router.\n\nThe details of Angular router configuration are best left to the [Routing documentation](guide/router)\nwhich recommends that you create a `NgModule` dedicated to router configuration\n(called a _Routing Module_).\n\n<code-example path=\"upgrade-phonecat-3-final/app/app-routing.module.ts\" header=\"app/app-routing.module.ts\">\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { Routes, RouterModule } from &#39;@angular/router&#39;;\nimport { APP_BASE_HREF, HashLocationStrategy, LocationStrategy } from &#39;@angular/common&#39;;\n\nimport { PhoneDetailComponent } from &#39;./phone-detail/phone-detail.component&#39;;\nimport { PhoneListComponent } from &#39;./phone-list/phone-list.component&#39;;\n\nconst routes: Routes = [\n  { path: &#39;&#39;, redirectTo: &#39;phones&#39;, pathMatch: &#39;full&#39; },\n  { path: &#39;phones&#39;,          component: PhoneListComponent },\n  { path: &#39;phones/:phoneId&#39;, component: PhoneDetailComponent }\n];\n\n@NgModule({\n  imports: [ RouterModule.forRoot(routes) ],\n  exports: [ RouterModule ],\n  providers: [\n    { provide: APP_BASE_HREF, useValue: &#39;!&#39; },\n    { provide: LocationStrategy, useClass: HashLocationStrategy },\n  ]\n})\nexport class AppRoutingModule { }\n\n\n</code-example>\n\nThis module defines a `routes` object with two routes to the two phone components\nand a default route for the empty path.\nIt passes the `routes` to the `RouterModule.forRoot` method which does the rest.\n\nA couple of extra providers enable routing with \"hash\" URLs such as `#!/phones`\ninstead of the default \"push state\" strategy.\n\nNow update the `AppModule` to import this `AppRoutingModule` and also the\ndeclare the root `AppComponent` as the bootstrap component.\nThat tells Angular that it should bootstrap the app with the _root_ `AppComponent` and\ninsert its view into the host web page.\n\nYou must also remove the bootstrap of the AngularJS module from `ngDoBootstrap()` in `app.module.ts`\nand the `UpgradeModule` import.\n\n<code-example path=\"upgrade-phonecat-3-final/app/app.module.ts\" header=\"app/app.module.ts\">\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { BrowserModule } from &#39;@angular/platform-browser&#39;;\nimport { FormsModule } from &#39;@angular/forms&#39;;\nimport { HttpClientModule } from &#39;@angular/common/http&#39;;\n\nimport { AppRoutingModule } from &#39;./app-routing.module&#39;;\nimport { AppComponent } from &#39;./app.component&#39;;\nimport { CheckmarkPipe } from &#39;./core/checkmark/checkmark.pipe&#39;;\nimport { Phone } from &#39;./core/phone/phone.service&#39;;\nimport { PhoneDetailComponent } from &#39;./phone-detail/phone-detail.component&#39;;\nimport { PhoneListComponent } from &#39;./phone-list/phone-list.component&#39;;\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    FormsModule,\n    HttpClientModule,\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    PhoneListComponent,\n    CheckmarkPipe,\n    PhoneDetailComponent\n  ],\n  providers: [\n    Phone\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule {}\n\n\n</code-example>\n\nAnd since you are routing to `PhoneListComponent` and `PhoneDetailComponent` directly rather than\nusing a route template with a `<phone-list>` or `<phone-detail>` tag, you can do away with their\nAngular selectors as well.\n-->\n<p>AngularJS, Angular에 관계없이 라우터는 환경설정이 필요합니다.</p>\n<p>그리고 Angular 라우터 설정은 <a href=\"guide/router\">라우팅 문서</a>에서 설명하는 것처럼 라우터와 관련된 설정을 따로 모아 <em>라우팅 모듈</em> 을 선언하는 방식을 권장합니다.</p>\n<code-example path=\"upgrade-phonecat-3-final/app/app-routing.module.ts\" header=\"app/app-routing.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a>, <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a> } from '@angular/router';\nimport { <a href=\"api/common/APP_BASE_HREF\" class=\"code-anchor\">APP_BASE_HREF</a>, <a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a>, <a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a> } from '@angular/common';\n\nimport { PhoneDetailComponent } from './phone-detail/phone-detail.component';\nimport { PhoneListComponent } from './phone-list/phone-list.component';\n\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: '', redirectTo: 'phones', pathMatch: 'full' },\n  { path: 'phones',          component: PhoneListComponent },\n  { path: 'phones/:phoneId', component: PhoneDetailComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [ RouterModule.forRoot(routes) ],\n  exports: [ <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a> ],\n  providers: [\n    { provide: <a href=\"api/common/APP_BASE_HREF\" class=\"code-anchor\">APP_BASE_HREF</a>, useValue: '!' },\n    { provide: <a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a>, useClass: <a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a> },\n  ]\n})\nexport class AppRoutingModule { }\n\n\n</code-example>\n<p>이 모듈에는 URL과 컴포넌트를 연결하는 라우팅 규칙 2개와 빈 주소로 접근했을 때 기본 주소로 이동하는 라우팅 규칙이 <code>routes</code> 객체에 할당되어 있습니다.\n이 객체는 <code>RouterModule.forRoot</code> 메소드에 전달되어 애플리케이션 전체 라우팅 규칙을 정의할 것입니다.</p>\n<p>이 코드에 사용된 프로바이더는 기본 로케이션 정책 대신 <code>#!/phones</code>와 같은 해시 URL을 사용하기 위해 등록한 것입니다.</p>\n<p>이제 <code>AppModule</code>에 <code>AppRoutingModule</code>을 로드하고 <em>최상위</em> 컴포넌트인 <code>AppComponent</code>를 부트스트랩하는 컴포넌트로 지정합니다.\n그러면 애플리케이션이 시작되면서 <code>AppComponent</code>가 함께 부트스트랩되고, 접근하는 주소와 연결된 컴포넌트가 호스트 웹 페이지에 표시됩니다.</p>\n<p>그 다음에는 <code>app.module.ts</code> 파일에서 AngularJS 모듈을 부트스트랩하는 <code>ngDoBootstrap()</code>과 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 부분을 제거하면 됩니다.</p>\n<code-example path=\"upgrade-phonecat-3-final/app/app.module.ts\" header=\"app/app.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\nimport { CheckmarkPipe } from './core/checkmark/checkmark.pipe';\nimport { Phone } from './core/phone/phone.service';\nimport { PhoneDetailComponent } from './phone-detail/phone-detail.component';\nimport { PhoneListComponent } from './phone-list/phone-list.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    PhoneListComponent,\n    CheckmarkPipe,\n    PhoneDetailComponent\n  ],\n  providers: [\n    Phone\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule {}\n\n\n</code-example>\n<p>이제는 <code>&#x3C;phone-list></code>나 <code>&#x3C;phone-detail></code> 태그를 사용하지 않아도 <code>PhoneListComponent</code>나 <code>PhoneDetailComponent</code>로 전환할 수 있습니다.\n이 컴포넌트들의 셀렉터는 이제 신경쓰지 않아도 됩니다.</p>\n<!--\n#### Generate links for each phone\n-->\n<h4 id=\"링크-연결하기\">링크 연결하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#링크-연결하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nYou no longer have to hardcode the links to phone details in the phone list.\nYou can generate data bindings for each phone's `id` to the `routerLink` directive\nand let that directive construct the appropriate URL to the `PhoneDetailComponent`:\n\n<code-example path=\"upgrade-phonecat-3-final/app/phone-list/phone-list.template.html\" region=\"list\" header=\"app/phone-list/phone-list.template.html (list with links)\">\n&lt;ul class=&quot;phones&quot;&gt;\n  &lt;li *ngFor=&quot;let phone of getPhones()&quot;\n      class=&quot;thumbnail phone-list-item&quot;&gt;\n    &lt;a [routerLink]=&quot;[&#39;/phones&#39;, phone.id]&quot; class=&quot;thumb&quot;&gt;\n      &lt;img [src]=&quot;phone.imageUrl&quot; [alt]=&quot;phone.name&quot; /&gt;\n    &lt;/a&gt;\n    &lt;a [routerLink]=&quot;[&#39;/phones&#39;, phone.id]&quot; class=&quot;name&quot;&gt;{{phone.name}}&lt;/a&gt;\n    &lt;p&gt;{{phone.snippet}}&lt;/p&gt;\n  &lt;/li&gt;\n&lt;/ul&gt;\n\n</code-example>\n\n<div class=\"alert is-helpful\">\n\nSee the [Routing](guide/router) page for details.\n\n</div><br>\n-->\n<p>이제는 스마트폰 목록화면에서 상세정보 화면으로 이동하는 링크를 하드코딩 할 필요가 없습니다.\n스마트폰의 <code>id</code>를 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> 디렉티브와 바인딩해서 URL을 구성하도록 다음과 같이 구현하면 됩니다:</p>\n<code-example path=\"upgrade-phonecat-3-final/app/phone-list/phone-list.template.html\" region=\"list\" header=\"app/phone-list/phone-list.template.html (링크가 수정된 목록)\">\n&#x3C;ul class=\"phones\">\n  &#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let phone of getPhones()\"\n      class=\"thumbnail phone-list-item\">\n    &#x3C;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/phones', phone.id]\" class=\"thumb\">\n      &#x3C;img [src]=\"phone.imageUrl\" [alt]=\"phone.name\" />\n    &#x3C;/a>\n    &#x3C;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/phones', phone.id]\" class=\"name\">{{phone.name}}&#x3C;/a>\n    &#x3C;p>{{phone.snippet}}&#x3C;/p>\n  &#x3C;/li>\n&#x3C;/ul>\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>자세한 내용은 <a href=\"guide/router\">라우팅</a> 문서를 참고하세요.</p>\n</div><br>\n<!--\n#### Use route parameters\n-->\n<h4 id=\"라우팅-인자-사용하기\">라우팅 인자 사용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#라우팅-인자-사용하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe Angular router passes route parameters differently.\nCorrect the `PhoneDetail` component constructor to expect an injected `ActivatedRoute` object.\nExtract the `phoneId` from the `ActivatedRoute.snapshot.params` and fetch the phone data as before:\n\n<code-example path=\"upgrade-phonecat-3-final/app/phone-detail/phone-detail.component.ts\" header=\"app/phone-detail/phone-detail.component.ts\">\nimport { Component } from &#39;@angular/core&#39;;\nimport { ActivatedRoute } from &#39;@angular/router&#39;;\n\nimport { Phone, PhoneData } from &#39;../core/phone/phone.service&#39;;\n\n@Component({\n  selector: &#39;phone-detail&#39;,\n  templateUrl: &#39;./phone-detail.template.html&#39;\n})\nexport class PhoneDetailComponent {\n  phone: PhoneData;\n  mainImageUrl: string;\n\n  constructor(activatedRoute: ActivatedRoute, phone: Phone) {\n    phone.get(activatedRoute.snapshot.paramMap.get(&#39;phoneId&#39;))\n      .subscribe((p: PhoneData) =&gt; {\n        this.phone = p;\n        this.setImage(p.images[0]);\n      });\n  }\n\n  setImage(imageUrl: string) {\n    this.mainImageUrl = imageUrl;\n  }\n}\n\n\n</code-example>\n\nYou are now running a pure Angular application!\n-->\n<p>Angular 라우터는 라우팅하면서 라우팅 인자를 함께 전달합니다.\n<code>PhoneDetail</code> 컴포넌트의 생성자에 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 객체를 의존성으로 주입하도록 수정합니다.\n그러고나면 <code>ActivatedRoute.snapshot.params</code>에서 참조하는 <code>phoneId</code>로 특정 스마트폰의 데이터를 가져올 수 있습니다:</p>\n<code-example path=\"upgrade-phonecat-3-final/app/phone-detail/phone-detail.component.ts\" header=\"app/phone-detail/phone-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\n\nimport { Phone, PhoneData } from '../core/phone/phone.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'phone-detail',\n  templateUrl: './phone-detail.template.html'\n})\nexport class PhoneDetailComponent {\n  phone: PhoneData;\n  mainImageUrl: string;\n\n  constructor(activatedRoute: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, phone: Phone) {\n    phone.get(activatedRoute.snapshot.paramMap.get('phoneId'))\n      .subscribe((p: PhoneData) => {\n        this.phone = p;\n        this.setImage(p.images[0]);\n      });\n  }\n\n  setImage(imageUrl: string) {\n    this.mainImageUrl = imageUrl;\n  }\n}\n\n\n</code-example>\n<p>이제 애플리케이션 기본 틀은 모두 Angular로 동작합니다!</p>\n<!--\n### Say Goodbye to AngularJS\n-->\n<h3 id=\"angularjs-탈출하기\">AngularJS 탈출하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#angularjs-탈출하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIt is time to take off the training wheels and let the application begin\nits new life as a pure, shiny Angular app. The remaining tasks all have to\ndo with removing code - which of course is every programmer's favorite task!\n\nThe application is still bootstrapped as a hybrid app.\nThere's no need for that anymore.\n\nSwitch the bootstrap method of the application from the `UpgradeModule` to the Angular way.\n\n<code-example path=\"upgrade-phonecat-3-final/app/main.ts\" header=\"main.ts\">\nimport { platformBrowserDynamic } from &#39;@angular/platform-browser-dynamic&#39;;\n\nimport { AppModule } from &#39;./app.module&#39;;\n\nplatformBrowserDynamic().bootstrapModule(AppModule);\n\n\n</code-example>\n\nIf you haven't already, remove all references to the `UpgradeModule` from `app.module.ts`,\nas well as any [factory provider](guide/upgrade#making-angularjs-dependencies-injectable-to-angular)\nfor AngularJS services, and the `app/ajs-upgraded-providers.ts` file.\n\nAlso remove any `downgradeInjectable()` or `downgradeComponent()` you find,\ntogether with the associated AngularJS factory or directive declarations.\nSince you no longer have downgraded components, you no longer list them\nin `entryComponents`.\n\n<code-example path=\"upgrade-phonecat-3-final/app/app.module.ts\" header=\"app.module.ts\">\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { BrowserModule } from &#39;@angular/platform-browser&#39;;\nimport { FormsModule } from &#39;@angular/forms&#39;;\nimport { HttpClientModule } from &#39;@angular/common/http&#39;;\n\nimport { AppRoutingModule } from &#39;./app-routing.module&#39;;\nimport { AppComponent } from &#39;./app.component&#39;;\nimport { CheckmarkPipe } from &#39;./core/checkmark/checkmark.pipe&#39;;\nimport { Phone } from &#39;./core/phone/phone.service&#39;;\nimport { PhoneDetailComponent } from &#39;./phone-detail/phone-detail.component&#39;;\nimport { PhoneListComponent } from &#39;./phone-list/phone-list.component&#39;;\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    FormsModule,\n    HttpClientModule,\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    PhoneListComponent,\n    CheckmarkPipe,\n    PhoneDetailComponent\n  ],\n  providers: [\n    Phone\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule {}\n\n\n</code-example>\n\nYou may also completely remove the following files. They are AngularJS\nmodule configuration files and not needed in Angular:\n\n* `app/app.module.ajs.ts`\n* `app/app.config.ts`\n* `app/core/core.module.ts`\n* `app/core/phone/phone.module.ts`\n* `app/phone-detail/phone-detail.module.ts`\n* `app/phone-list/phone-list.module.ts`\n\nThe external typings for AngularJS may be uninstalled as well. The only ones\nyou still need are for Jasmine and Angular polyfills.\nThe `@angular/upgrade` package and its mapping in `systemjs.config.js` can also go.\n\n<code-example format=\"\">\n  npm uninstall @angular/upgrade --save\n  npm uninstall @types/angular @types/angular-animate @types/angular-cookies @types/angular-mocks @types/angular-resource @types/angular-route @types/angular-sanitize --save-dev\n</code-example>\n\nFinally, from `index.html`, remove all references to AngularJS scripts and jQuery.\nWhen you're done, this is what it should look like:\n\n<code-example path=\"upgrade-phonecat-3-final/index.html\" region=\"full\" header=\"index.html\">\n&lt;!doctype html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;utf-8&quot;&gt;\n    &lt;base href=&quot;/app/&quot;&gt;\n    &lt;title&gt;Google Phone Gallery&lt;/title&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css&quot; /&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;app.css&quot; /&gt;\n\n    &lt;script src=&quot;/node_modules/core-js/client/shim.min.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;/node_modules/zone.js/bundles/zone.umd.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;/node_modules/systemjs/dist/system.src.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;/systemjs.config.js&quot;&gt;&lt;/script&gt;\n    &lt;script&gt;\n      System.import(&#39;/app&#39;);\n    &lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;phonecat-app&gt;&lt;/phonecat-app&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n</code-example>\n\nThat is the last you'll see of AngularJS! It has served us well but now\nit's time to say goodbye.\n-->\n<p>이제 준비과정은 모두 끝났고 이제부터는 순수한 Angular 앱으로 변환하는 작업을 시작하면 됩니다.\n필요없는 코드는 모두 제거해 버리세요!</p>\n<p>아직 애플리케이션은 하이브리드 앱으로 부트스트랩 됩니다.\n하지만 이제 이렇게 실행할 필요가 없습니다.</p>\n<p><code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>을 사용해서 애플리케이션을 부트스트랩하던 것을 Angular 방식으로 바꿔봅시다.</p>\n<code-example path=\"upgrade-phonecat-3-final/app/main.ts\" header=\"main.ts\">\nimport { <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a> } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app.module';\n\n<a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>().bootstrapModule(AppModule);\n\n\n</code-example>\n<p>그리고 <code>app.module.ts</code> 파일에서 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>과 관련된 코드, AngularJS 서비스를 사용하기 위해 등록한 <a href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\">팩토리 프로바이더</a>, <code>app/ajs-upgraded-providers.ts</code> 파일을 제거합니다.</p>\n<p><code><a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>()</code>이나 <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code>는 보이는 대로 제거하면 됩니다.\n이 메소드와 관련된 팩토리와 디렉티브도 물론 제거해도 됩니다.\n컴포넌트를 Angular 용으로 모두 변환하고 나면 컴포넌트를 다운그레이드할 필요도 없고 이 컴포넌트들을 <code>entryComponents</code>에 등록할 필요도 없습니다.</p>\n<code-example path=\"upgrade-phonecat-3-final/app/app.module.ts\" header=\"app.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\nimport { CheckmarkPipe } from './core/checkmark/checkmark.pipe';\nimport { Phone } from './core/phone/phone.service';\nimport { PhoneDetailComponent } from './phone-detail/phone-detail.component';\nimport { PhoneListComponent } from './phone-list/phone-list.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    PhoneListComponent,\n    CheckmarkPipe,\n    PhoneDetailComponent\n  ],\n  providers: [\n    Phone\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule {}\n\n\n</code-example>\n<p>아래 파일들도 제거해도 됩니다.\n이 파일들은 AngularJS 모듈을 구성하는 파일이며 Angular에서는 더이상 사용되지 않습니다:</p>\n<ul>\n<li><code>app/app.module.ajs.ts</code></li>\n<li><code>app/app.config.ts</code></li>\n<li><code>app/core/core.module.ts</code></li>\n<li><code>app/core/phone/phone.module.ts</code></li>\n<li><code>app/phone-detail/phone-detail.module.ts</code></li>\n<li><code>app/phone-list/phone-list.module.ts</code></li>\n</ul>\n<p>AngularJS의 타입 정보를 제공하는 패키지도 삭제합니다.\n이 때 Jasmine과 Angular 폴리필은 남겨둬야 합니다.\n<code>@angular/upgrade</code> 패키지를 제거하면 <code>systemjs.config.js</code> 파일에서 관련된 코드도 제거하면 됩니다.</p>\n<code-example format=\"\">\n  npm uninstall @angular/upgrade --save\n  npm uninstall @types/angular @types/angular-animate @types/angular-cookies @types/angular-mocks @types/angular-resource @types/angular-route @types/angular-sanitize --save-dev\n</code-example>\n<p>마지막으로 <code>index.html</code> 파일에서 AngularJS 스크립트 파일과 jQuery를 로드하는 코드를 모두 제거합니다.\n이 코드를 제거하고 나면 <code>index.html</code> 파일의 내용은 다음과 같이 남을 것입니다:</p>\n<code-example path=\"upgrade-phonecat-3-final/index.html\" region=\"full\" header=\"index.html\">\n&#x3C;!doctype html>\n&#x3C;html lang=\"en\">\n  &#x3C;head>\n    &#x3C;meta charset=\"utf-8\">\n    &#x3C;base href=\"/app/\">\n    &#x3C;title>Google Phone Gallery&#x3C;/title>\n    &#x3C;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css\" />\n    &#x3C;link rel=\"stylesheet\" href=\"app.css\" />\n\n    &#x3C;script src=\"/node_modules/core-js/client/shim.min.js\">&#x3C;/script>\n    &#x3C;script src=\"/node_modules/zone.js/bundles/zone.umd.js\">&#x3C;/script>\n    &#x3C;script src=\"/node_modules/systemjs/dist/system.src.js\">&#x3C;/script>\n    &#x3C;script src=\"/systemjs.config.js\">&#x3C;/script>\n    &#x3C;script>\n      System.import('/app');\n    &#x3C;/script>\n  &#x3C;/head>\n  &#x3C;body>\n    &#x3C;phonecat-app>&#x3C;/phonecat-app>\n  &#x3C;/body>\n&#x3C;/html>\n\n</code-example>\n<p>AngularJS를 보는 일은 이것이 마지막입니다!\n지금까지는 고마웠지만 이제 AngularJS를 놓아줍시다.</p>\n<!--\n## Appendix: Upgrading PhoneCat Tests\n-->\n<h2 id=\"부록-phonecat-테스트-업그레이드하기\">부록: PhoneCat 테스트 업그레이드하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#부록-phonecat-테스트-업그레이드하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nTests can not only be retained through an upgrade process, but they can also be\nused as a valuable safety measure when ensuring that the application does not\nbreak during the upgrade. E2E tests are especially useful for this purpose.\n-->\n<p>AngularJS 앱을 Angular로 업그레이드할 때 테스트 코드는 업그레이드하지 않아도 앱 실행에 영향을 주지 않지만, 애플리케이션이 제대로 동작하는 것을 계속 유지하려면 테스트 코드도 함께 업그레이드 하는 것이 좋습니다.\nE2E 테스트인 경우는 특히 그렇습니다.</p>\n<!--\n### E2E Tests\n-->\n<h3 id=\"e2e-테스트\">E2E 테스트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#e2e-테스트\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe PhoneCat project has both E2E Protractor tests and some Karma unit tests in it.\nOf these two, E2E tests can be dealt with much more easily: By definition,\nE2E tests access the application from the *outside* by interacting with\nthe various UI elements the app puts on the screen. E2E tests aren't really that\nconcerned with the internal structure of the application components. That\nalso means that, although you modify the project quite a bit during the upgrade, the E2E\ntest suite should keep passing with just minor modifications. You\ndidn't change how the application behaves from the user's point of view.\n\nDuring TypeScript conversion, there is nothing to do to keep E2E tests\nworking. But when you change the bootstrap to that of a Hybrid app,\nyou must make a few changes.\n\nUpdate the `protractor-conf.js` to sync with hybrid apps:\n-->\n<p>우리가 다루고 있는 PhoneCat 프로젝트에는 E2E Protractor 테스트와 Karma 유닛 테스트가 모두 구현되어 있습니다.\n그리고 둘 중에서는 E2E 테스트가 좀 더 다루기 쉽습니다.\nE2E 테스트는 애플리케이션 <em>밖에서</em> UI 엘리먼트를 조작하며 앱이 어떻게 표시되는지 검사하는 용도로 설계되었습니다.\n그래서 E2E 테스트는 애플리케이션 내부 구조와는 직접적인 관계가 없습니다.\n그렇기 때문에 오랜 시간을 들여서 프로젝트를 업그레이드 하더라도 이 변경사항에 맞게 E2E 테스트 스윗을 수정하는 것은 그리 복잡하지 않습니다.\n애플리케이션의 변경사항과 관계없이 사용자의 입장에서만 조작하면 되기 때문입니다.</p>\n<p>E2E 테스트 코드는 TypeScript를 도입한다고 해서 크게 달라지지 않지만 하이브리드 앱을 부트스트랩하는 구조가 변경되면 수정해야할 내용이 조금 있습니다.</p>\n<p>하디브리드 앱에 맞게 <code>protractor-conf.js</code> 파일을 다음과 같이 수정합니다:</p>\n<code-example format=\"\">\n  ng12Hybrid: true\n</code-example>\n<!--\nWhen you start to upgrade components and their templates to Angular, you'll make more changes\nbecause the E2E tests have matchers that are specific to AngularJS.\nFor PhoneCat you need to make the following changes in order to make things work with Angular:\n-->\n<p>컴포넌트를 업그레이드하면서 템플릿을 변경하게 되면 E2E 테스트 코드에 수정해야 하는 내용은 좀 더 많아집니다.\nAngularJS에서 사용하던 매처를 사용하기 때문입니다.\n그래서 PhoneCat 프로젝트를 Angular 버전으로 E2E 테스트하려면 다음과 같이 수정해야 합니다:</p>\n<table>\n  <tbody><tr>\n    <th>\n      <!--\n      Previous code\n      -->\n      수정 전\n    </th>\n    <th>\n      <!--\n      New code\n      -->\n      수정 후\n    </th>\n    <th>\n      <!--\n      Notes\n      -->\n      설명\n    </th>\n  </tr>\n  <tr>\n    <td>\n<p>      <code>by.repeater('phone in $ctrl.phones').column('phone.name')</code></p>\n    </td>\n    <td>\n<p>      <code>by.css('.phones .name')</code></p>\n    </td>\n    <td>\n      <!--\n      The repeater matcher relies on AngularJS `ng-repeat`\n      -->\n<p>      이전에는 AngularJS <code>ng-repeat</code>에 해당하는 매처를 사용했습니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n<p>      <code>by.repeater('phone in $ctrl.phones')</code></p>\n    </td>\n    <td>\n<p>      <code>by.css('.phones li')</code></p>\n    </td>\n    <td>\n      <!--\n      The repeater matcher relies on AngularJS `ng-repeat`\n      -->\n<p>      이전에는 AngularJS <code>ng-repeat</code>에 해당하는 매처를 사용했습니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n<p>      <code>by.model('$ctrl.query')</code></p>\n    </td>\n    <td>\n<p>      <code>by.css('input')</code></p>\n    </td>\n    <td>\n      <!--\n      The model matcher relies on AngularJS `ng-model`\n      -->\n<p>      이전에는 AngularJS <code>ng-model</code>에 해당하는 매처를 사용했습니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n<p>      <code>by.model('$ctrl.orderProp')</code></p>\n    </td>\n    <td>\n<p>      <code>by.css('select')</code></p>\n    </td>\n    <td>\n      <!--\n      The model matcher relies on AngularJS `ng-model`\n      -->\n<p>      이전에는 AngularJS <code>ng-model</code>에 해당하는 매처를 사용했습니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n<p>      <code>by.binding('$ctrl.phone.name')</code></p>\n    </td>\n    <td>\n<p>      <code>by.css('h1')</code></p>\n    </td>\n    <td>\n      <!--\n      The binding matcher relies on AngularJS data binding\n      -->\n<p>      이전에는 AngularJS 데이터 바인딩에 해당하는 매처를 사용했습니다.</p>\n    </td>\n  </tr>\n</tbody></table>\n<!--\nWhen the bootstrap method is switched from that of `UpgradeModule` to\npure Angular, AngularJS ceases to exist on the page completely.\nAt this point, you need to tell Protractor that it should not be looking for\nan AngularJS app anymore, but instead it should find *Angular apps* from\nthe page.\n\nReplace the `ng12Hybrid` previously added with the following in `protractor-conf.js`:\n-->\n<p><code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>를 사용하던 부트스트랩 메소드를 Angular 버전으로 바꾸면 이제 화면에 AngularJS는 존재하지 않습니다.\n그래서 Protractor도 AngularJS 앱 대신 Angular 앱을 탐색해야 합니다.</p>\n<p>이전에 수정했던 <code>protractor-conf.js</code> 파일에 다음 내용을 추가합니다:</p>\n<code-example format=\"\">\n  useAllAngular2AppRoots: true,\n</code-example>\n<!--\nAlso, there are a couple of Protractor API calls in the PhoneCat test code that\nare using the AngularJS `$location` service under the hood. As that\nservice is no longer present after the upgrade, replace those calls with ones\nthat use WebDriver's generic URL APIs instead. The first of these is\nthe redirection spec:\n-->\n<p>그리고 아직까지는 PhoneCat 프로젝트 테스트 코드에 AngularJS <code>$location</code> 서비스를 사용하는 부분이 있습니다.\n애플리케이션을 업그레이드한 후에는 이 서비스도 사용하지 않으며, 이제 WebDriver가 제공하는 URL API를 사용해야 합니다.\n리다이렉션을 테스트하는 코드는 다음과 같이 수정합니다:</p>\n<code-example path=\"upgrade-phonecat-3-final/e2e-spec.ts\" region=\"redirect\" header=\"e2e-tests/scenarios.ts\">\nit('should redirect `index.html` to `index.html#!/phones', () => {\n  browser.get('index.html');\n  browser.waitForAngular();\n  browser.getCurrentUrl().then((url: string) => {\n    expect(url.endsWith('/phones')).toBe(true);\n  });\n});\n\n</code-example>\n<!--\nAnd the second is the phone links spec:\n-->\n<p>그리고 스마트폰 링크를 테스트하는 코드는 다음과 같이 수정합니다:</p>\n<code-example path=\"upgrade-phonecat-3-final/e2e-spec.ts\" region=\"links\" header=\"e2e-tests/scenarios.ts\">\nit('should render phone specific links', () => {\n  const <a href=\"api/animations/query\" class=\"code-anchor\">query</a> = element(by.css('input'));\n  query.sendKeys('nexus');\n  element.all(by.css('.phones li a')).first().click();\n  browser.getCurrentUrl().then((url: string) => {\n    expect(url.endsWith('/phones/nexus-s')).toBe(true);\n  });\n});\n\n</code-example>\n<!--\n### Unit Tests\n-->\n<h3 id=\"유닛-테스트\">유닛 테스트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#유닛-테스트\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nFor unit tests, on the other hand, more conversion work is needed. Effectively\nthey need to be *upgraded* along with the production code.\n\nDuring TypeScript conversion no changes are strictly necessary. But it may be\na good idea to convert the unit test code into TypeScript as well.\n\nFor instance, in the phone detail component spec, you can use ES2015\nfeatures like arrow functions and block-scoped variables and benefit from the type\ndefinitions of the AngularJS services you're consuming:\n\n<code-example path=\"upgrade-phonecat-1-typescript/app/phone-detail/phone-detail.component.spec.ts\" header=\"app/phone-detail/phone-detail.component.spec.ts\">\ndescribe(&#39;phoneDetail&#39;, () =&gt; {\n\n  // 각 테스트 스윗 실행 전에 `phoneDetail` 컴포넌트가 있는 모듈을 로드합니다.\n  beforeEach(angular.mock.module(&#39;phoneDetail&#39;));\n\n  // 컨트롤러를 테스트합니다.\n  describe(&#39;PhoneDetailController&#39;, () =&gt; {\n    let $httpBackend: angular.IHttpBackendService;\n    let ctrl: any;\n    const xyzPhoneData = {\n      name: &#39;phone xyz&#39;,\n      images: [&#39;image/url1.png&#39;, &#39;image/url2.png&#39;]\n    };\n\n    beforeEach(inject(($componentController: any,\n                       _$httpBackend_: angular.IHttpBackendService,\n                       $routeParams: angular.route.IRouteParamsService) =&gt; {\n      $httpBackend = _$httpBackend_;\n      $httpBackend.expectGET(&#39;phones/xyz.json&#39;).respond(xyzPhoneData);\n\n      $routeParams.phoneId = &#39;xyz&#39;;\n\n      ctrl = $componentController(&#39;phoneDetail&#39;);\n    }));\n\n    it(&#39;should fetch the phone details&#39;, () =&gt; {\n      jasmine.addCustomEqualityTester(angular.equals);\n\n      expect(ctrl.phone).toEqual({});\n\n      $httpBackend.flush();\n      expect(ctrl.phone).toEqual(xyzPhoneData);\n    });\n\n  });\n\n});\n\n\n</code-example>\n\nOnce you start the upgrade process and bring in SystemJS, configuration changes\nare needed for Karma. You need to let SystemJS load all the new Angular code,\nwhich can be done with the following kind of shim file:\n\n<code-example path=\"upgrade-phonecat-2-hybrid/karma-test-shim.1.js\" header=\"karma-test-shim.js\">\n// /*global jasmine, __karma__, window*/\nError.stackTraceLimit = 0; // 앱을 테스트할 때는 보통 콜스택을 표시하지 않습니다.\n\n// 콜스택을 모두 표시하려면 주석을 제거합니다.\n// Error.stackTraceLimit = Infinity; //\n\njasmine.DEFAULT_TIMEOUT_INTERVAL = 1000;\n\nvar builtPath = &#39;/base/app/&#39;;\n\n__karma__.loaded = function () { };\n\nfunction isJsFile(path) {\n  return path.slice(-3) == &#39;.js&#39;;\n}\n\nfunction isSpecFile(path) {\n  return /\\.spec\\.(.*\\.)?js$/.test(path);\n}\n\nfunction isBuiltFile(path) {\n  return isJsFile(path) &amp;&amp; (path.substr(0, builtPath.length) == builtPath);\n}\n\nvar allSpecFiles = Object.keys(window.__karma__.files)\n  .filter(isSpecFile)\n  .filter(isBuiltFile);\n\nSystem.config({\n  baseURL: &#39;/base&#39;,\n  // 테스트 폴더에 있는 파일을 불러오도록 설정합니다.\n  packages: { &#39;testing&#39;: { main: &#39;index.js&#39;, defaultExtension: &#39;js&#39; } },\n\n  // npm:이 systemjs.config의 `paths`에 미리 정의되었다고 간주합니다.\n  // Angular 테스트 프레임워크를 맵핑합니다.\n  map: {\n    &#39;@angular/core/testing&#39;: &#39;npm:@angular/core/bundles/core-testing.umd.js&#39;,\n    &#39;@angular/common/testing&#39;: &#39;npm:@angular/common/bundles/common-testing.umd.js&#39;,\n    &#39;@angular/common/http/testing&#39;: &#39;npm:@angular/common/bundles/common-http-testing.umd.js&#39;,\n    &#39;@angular/compiler/testing&#39;: &#39;npm:@angular/compiler/bundles/compiler-testing.umd.js&#39;,\n    &#39;@angular/platform-browser/testing&#39;: &#39;npm:@angular/platform-browser/bundles/platform-browser-testing.umd.js&#39;,\n    &#39;@angular/platform-browser-dynamic/testing&#39;: &#39;npm:@angular/platform-browser-dynamic/bundles/platform-browser-dynamic-testing.umd.js&#39;,\n    &#39;@angular/router/testing&#39;: &#39;npm:@angular/router/bundles/router-testing.umd.js&#39;,\n    &#39;@angular/forms/testing&#39;: &#39;npm:@angular/forms/bundles/forms-testing.umd.js&#39;,\n  },\n});\n\nSystem.import(&#39;systemjs.config.js&#39;)\n  .then(importSystemJsExtras)\n  .then(initTestBed)\n  .then(initTesting);\n\n/** SystemJS 추가 설정. 생략해도 됩니다. */\nfunction importSystemJsExtras(){\n  return System.import(&#39;systemjs.config.extras.js&#39;)\n  .catch(function(reason) {\n    console.log(\n      &#39;Warning: System.import could not load the optional &quot;systemjs.config.extras.js&quot;. Did you omit it by accident? Continuing without it.&#39;\n    );\n    console.log(reason);\n  });\n}\n\nfunction initTestBed(){\n  return Promise.all([\n    System.import(&#39;@angular/core/testing&#39;),\n    System.import(&#39;@angular/platform-browser-dynamic/testing&#39;)\n  ])\n\n  .then(function (providers) {\n    var coreTesting    = providers[0];\n    var browserTesting = providers[1];\n\n    coreTesting.TestBed.initTestEnvironment(\n      browserTesting.BrowserDynamicTestingModule,\n      browserTesting.platformBrowserDynamicTesting());\n  })\n}\n\n// 스펙 파일을 모두 로드하고 Karma를 시작합니다.\nfunction initTesting () {\n  return Promise.all(\n    allSpecFiles.map(function (moduleName) {\n      return System.import(moduleName);\n    })\n  )\n  .then(__karma__.start, __karma__.error);\n}\n\n\n</code-example>\n\nThe shim first loads the SystemJS configuration, then Angular's test support libraries,\nand then the application's spec files themselves.\n\nKarma configuration should then be changed so that it uses the application root dir\nas the base directory, instead of `app`.\n\n<code-example path=\"upgrade-phonecat-2-hybrid/karma.conf.ajs.js\" region=\"basepath\" header=\"karma.conf.js\">\nbasePath: &#39;./&#39;,\n\n</code-example>\n\nOnce done, you can load SystemJS and other dependencies, and also switch the configuration\nfor loading application files so that they are *not* included to the page by Karma. You'll let\nthe shim and SystemJS load them.\n\n<code-example path=\"upgrade-phonecat-2-hybrid/karma.conf.ajs.js\" region=\"files\" header=\"karma.conf.js\">\n// System.js는 모듈을 로딩할 때 사용합니다.\n&#39;node_modules/systemjs/dist/system.src.js&#39;,\n\n// 폴리필 스크립트 파일\n&#39;node_modules/core-js/client/shim.js&#39;,\n\n// zone.js\n&#39;node_modules/zone.js/bundles/zone.umd.js&#39;,\n&#39;node_modules/zone.js/bundles/zone-testing.umd.js&#39;,\n\n// RxJs.\n{ pattern: &#39;node_modules/rxjs/**/*.js&#39;, included: false, watched: false },\n{ pattern: &#39;node_modules/rxjs/**/*.js.map&#39;, included: false, watched: false },\n\n// Angular와 Angular 테스트 라이브러리를 로드합니다.\n{pattern: &#39;node_modules/@angular/**/*.js&#39;, included: false, watched: false},\n{pattern: &#39;node_modules/@angular/**/*.js.map&#39;, included: false, watched: false},\n\n{pattern: &#39;systemjs.config.js&#39;, included: false, watched: false},\n&#39;karma-test-shim.js&#39;,\n\n{pattern: &#39;app/**/*.module.js&#39;, included: false, watched: true},\n{pattern: &#39;app/*!(.module|.spec).js&#39;, included: false, watched: true},\n{pattern: &#39;app/!(bower_components)/**/*!(.module|.spec).js&#39;, included: false, watched: true},\n{pattern: &#39;app/**/*.spec.js&#39;, included: false, watched: true},\n\n{pattern: &#39;**/*.html&#39;, included: false, watched: true},\n\n</code-example>\n\nSince the HTML templates of Angular components will be loaded as well, you must help\nKarma out a bit so that it can route them to the right paths:\n\n<code-example path=\"upgrade-phonecat-2-hybrid/karma.conf.ajs.js\" region=\"html\" header=\"karma.conf.js\">\n// 애셋을 로드하기 위해 기본 경로를 변경합니다.\nproxies: {\n  // Angular가 컴포넌트를 컴파일하려면 애셋 파일이 필요합니다.\n  &#39;/phone-detail&#39;: &#39;/base/app/phone-detail&#39;,\n  &#39;/phone-list&#39;: &#39;/base/app/phone-list&#39;\n},\n\n</code-example>\n\nThe unit test files themselves also need to be switched to Angular when their production\ncounterparts are switched. The specs for the checkmark pipe are probably the most straightforward,\nas the pipe has no dependencies:\n\n<code-example path=\"upgrade-phonecat-2-hybrid/app/core/checkmark/checkmark.pipe.spec.ts\" header=\"app/core/checkmark/checkmark.pipe.spec.ts\">\nimport { CheckmarkPipe } from &#39;./checkmark.pipe&#39;;\n\ndescribe(&#39;CheckmarkPipe&#39;, () =&gt; {\n\n  it(&#39;should convert boolean values to unicode checkmark or cross&#39;, () =&gt; {\n    const checkmarkPipe = new CheckmarkPipe();\n    expect(checkmarkPipe.transform(true)).toBe(&#39;\\u2713&#39;);\n    expect(checkmarkPipe.transform(false)).toBe(&#39;\\u2718&#39;);\n  });\n});\n\n\n</code-example>\n\nThe unit test for the phone service is a bit more involved. You need to switch from the mocked-out\nAngularJS `$httpBackend` to a mocked-out Angular Http backend.\n\n<code-example path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.spec.ts\" header=\"app/core/phone/phone.service.spec.ts\">\nimport { inject, TestBed } from &#39;@angular/core/testing&#39;;\nimport { HttpClientTestingModule, HttpTestingController } from &#39;@angular/common/http/testing&#39;;\nimport { Phone, PhoneData } from &#39;./phone.service&#39;;\n\ndescribe(&#39;Phone&#39;, () =&gt; {\n  let phone: Phone;\n  const phonesData: PhoneData[] = [\n    {name: &#39;Phone X&#39;, snippet: &#39;&#39;, images: []},\n    {name: &#39;Phone Y&#39;, snippet: &#39;&#39;, images: []},\n    {name: &#39;Phone Z&#39;, snippet: &#39;&#39;, images: []}\n  ];\n  let httpMock: HttpTestingController;\n\n  beforeEach(() =&gt; {\n    TestBed.configureTestingModule({\n      imports: [\n        HttpClientTestingModule\n      ],\n      providers: [\n        Phone,\n      ]\n    });\n  });\n\n  beforeEach(inject([HttpTestingController, Phone], (_httpMock_: HttpTestingController, _phone_: Phone) =&gt; {\n    httpMock = _httpMock_;\n    phone = _phone_;\n  }));\n\n  afterEach(() =&gt; {\n    httpMock.verify();\n  });\n\n  it(&#39;should fetch the phones data from `/phones/phones.json`&#39;, () =&gt; {\n    phone.query().subscribe(result =&gt; {\n      expect(result).toEqual(phonesData);\n    });\n    const req = httpMock.expectOne(`/phones/phones.json`);\n    req.flush(phonesData);\n  });\n\n});\n\n\n\n</code-example>\n\nFor the component specs, you can mock out the `Phone` service itself, and have it provide\ncanned phone data. You use Angular's component unit testing APIs for both components.\n\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.component.spec.ts\" header=\"app/phone-detail/phone-detail.component.spec.ts\">\nimport { TestBed, waitForAsync } from &#39;@angular/core/testing&#39;;\nimport { ActivatedRoute } from &#39;@angular/router&#39;;\nimport { Observable, of } from &#39;rxjs&#39;;\n\nimport { PhoneDetailComponent } from &#39;./phone-detail.component&#39;;\nimport { Phone, PhoneData } from &#39;../core/phone/phone.service&#39;;\nimport { CheckmarkPipe } from &#39;../core/checkmark/checkmark.pipe&#39;;\n\nfunction xyzPhoneData(): PhoneData {\n  return {name: &#39;phone xyz&#39;, snippet: &#39;&#39;, images: [&#39;image/url1.png&#39;, &#39;image/url2.png&#39;]};\n}\n\nclass MockPhone {\n  get(id: string): Observable&lt;PhoneData&gt; {\n    return of(xyzPhoneData());\n  }\n}\n\n\nclass ActivatedRouteMock {\n  constructor(public snapshot: any) {}\n}\n\n\ndescribe(&#39;PhoneDetailComponent&#39;, () =&gt; {\n\n  beforeEach(waitForAsync(() =&gt; {\n    TestBed.configureTestingModule({\n      declarations: [ CheckmarkPipe, PhoneDetailComponent ],\n      providers: [\n        { provide: Phone, useClass: MockPhone },\n        { provide: ActivatedRoute, useValue: new ActivatedRouteMock({ params: { phoneId: 1 } }) }\n      ]\n    })\n    .compileComponents();\n  }));\n\n  it(&#39;should fetch phone detail&#39;, () =&gt; {\n    const fixture = TestBed.createComponent(PhoneDetailComponent);\n    fixture.detectChanges();\n    const compiled = fixture.debugElement.nativeElement;\n    expect(compiled.querySelector(&#39;h1&#39;).textContent).toContain(xyzPhoneData().name);\n  });\n});\n\n\n</code-example>\n\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.spec.ts\" header=\"app/phone-list/phone-list.component.spec.ts\">\nimport {SpyLocation} from &#39;@angular/common/testing&#39;;\nimport {NO_ERRORS_SCHEMA} from &#39;@angular/core&#39;;\nimport {ComponentFixture, TestBed, waitForAsync} from &#39;@angular/core/testing&#39;;\nimport {ActivatedRoute} from &#39;@angular/router&#39;;\nimport {Observable, of} from &#39;rxjs&#39;;\n\nimport {Phone, PhoneData} from &#39;../core/phone/phone.service&#39;;\n\nimport {PhoneListComponent} from &#39;./phone-list.component&#39;;\n\nclass ActivatedRouteMock {\n  constructor(public snapshot: any) {}\n}\n\nclass MockPhone {\n  query(): Observable&lt;PhoneData[]&gt; {\n    return of([\n      {name: &#39;Nexus S&#39;, snippet: &#39;&#39;, images: []}, {name: &#39;Motorola DROID&#39;, snippet: &#39;&#39;, images: []}\n    ]);\n  }\n}\n\nlet fixture: ComponentFixture&lt;PhoneListComponent&gt;;\n\ndescribe(&#39;PhoneList&#39;, () =&gt; {\n  beforeEach(waitForAsync(() =&gt; {\n    TestBed\n        .configureTestingModule({\n          declarations: [PhoneListComponent],\n          providers: [\n            {provide: ActivatedRoute, useValue: new ActivatedRouteMock({params: {&#39;phoneId&#39;: 1}})},\n            {provide: Location, useClass: SpyLocation},\n            {provide: Phone, useClass: MockPhone},\n          ],\n          schemas: [NO_ERRORS_SCHEMA]\n        })\n        .compileComponents();\n  }));\n\n  beforeEach(() =&gt; {\n    fixture = TestBed.createComponent(PhoneListComponent);\n  });\n\n  it(&#39;should create &quot;phones&quot; model with 2 phones fetched from xhr&#39;, () =&gt; {\n    fixture.detectChanges();\n    let compiled = fixture.debugElement.nativeElement;\n    expect(compiled.querySelectorAll(&#39;.phone-list-item&#39;).length).toBe(2);\n    expect(compiled.querySelector(&#39;.phone-list-item:nth-child(1)&#39;).textContent)\n        .toContain(&#39;Motorola DROID&#39;);\n    expect(compiled.querySelector(&#39;.phone-list-item:nth-child(2)&#39;).textContent)\n        .toContain(&#39;Nexus S&#39;);\n  });\n\n  xit(&#39;should set the default value of orderProp model&#39;, () =&gt; {\n    fixture.detectChanges();\n    let compiled = fixture.debugElement.nativeElement;\n    expect(compiled.querySelector(&#39;select option:last-child&#39;).selected).toBe(true);\n  });\n});\n\n\n</code-example>\n\nFinally, revisit both of the component tests when you switch to the Angular\nrouter. For the details component, provide a mock of Angular `ActivatedRoute` object\ninstead of using the AngularJS `$routeParams`.\n\n<code-example path=\"upgrade-phonecat-3-final/app/phone-detail/phone-detail.component.spec.ts\" region=\"activatedroute\" header=\"app/phone-detail/phone-detail.component.spec.ts\">\nimport { TestBed, waitForAsync } from &#39;@angular/core/testing&#39;;\nimport { ActivatedRoute } from &#39;@angular/router&#39;;\n/* . . . */\n\nclass ActivatedRouteMock {\n  constructor(public snapshot: any) {}\n}\n\n/* . . . */\n\n  beforeEach(waitForAsync(() =&gt; {\n    TestBed.configureTestingModule({\n      declarations: [ CheckmarkPipe, PhoneDetailComponent ],\n      providers: [\n        { provide: Phone, useClass: MockPhone },\n        { provide: ActivatedRoute, useValue: new ActivatedRouteMock({ params: { phoneId: 1 } }) }\n      ]\n    })\n    .compileComponents();\n  }));\n\n</code-example>\n\nAnd for the phone list component, a few adjustments to the router make\nthe `RouteLink` directives work.\n\n<code-example path=\"upgrade-phonecat-3-final/app/phone-list/phone-list.component.spec.ts\" region=\"routestuff\" header=\"app/phone-list/phone-list.component.spec.ts\">\nimport {SpyLocation} from &#39;@angular/common/testing&#39;;\nimport {NO_ERRORS_SCHEMA} from &#39;@angular/core&#39;;\nimport {ComponentFixture, TestBed, waitForAsync} from &#39;@angular/core/testing&#39;;\nimport {ActivatedRoute} from &#39;@angular/router&#39;;\nimport {Observable, of} from &#39;rxjs&#39;;\n\nimport {Phone, PhoneData} from &#39;../core/phone/phone.service&#39;;\n\nimport {PhoneListComponent} from &#39;./phone-list.component&#39;;\n\n/* . . . */\n\n  beforeEach(waitForAsync(() =&gt; {\n    TestBed\n        .configureTestingModule({\n          declarations: [PhoneListComponent],\n          providers: [\n            {provide: ActivatedRoute, useValue: new ActivatedRouteMock({params: {&#39;phoneId&#39;: 1}})},\n            {provide: Location, useClass: SpyLocation},\n            {provide: Phone, useClass: MockPhone},\n          ],\n          schemas: [NO_ERRORS_SCHEMA]\n        })\n        .compileComponents();\n  }));\n\n  beforeEach(() =&gt; {\n    fixture = TestBed.createComponent(PhoneListComponent);\n  });\n\n</code-example>\n-->\n<p>유닛 테스트의 경우에는 작업할 내용이 좀 더 있습니다.\n유닛 테스트 코드는 애플리케이션이 <em>업그레이드</em>되는 것에 직접 영향을 받습니다.</p>\n<p>애플리케이션에 TypeScript를 적용하는 동안에는 유닛 테스트 코드를 수정하지 않아도 됩니다.\n하지만 되도록이면 테스트 코드도 TypeScript로 변환하는 것이 좋습니다.</p>\n<p>그래서 스마트폰 상세정보 컴포넌트를 테스트하는 스펙이라면 화살표 함수나 블록 안에서만 유효한 변수와 같은 ES2015 기능을 사용할 수도 있고 타입을 지정하는 기능을 활용하는 것도 좋습니다:</p>\n<code-example path=\"upgrade-phonecat-1-typescript/app/phone-detail/phone-detail.component.spec.ts\" header=\"app/phone-detail/phone-detail.component.spec.ts\">\ndescribe('phoneDetail', () => {\n\n  // 각 테스트 스윗 실행 전에 `phoneDetail` 컴포넌트가 있는 모듈을 로드합니다.\n  beforeEach(angular.mock.module('phoneDetail'));\n\n  // 컨트롤러를 테스트합니다.\n  describe('PhoneDetailController', () => {\n    let $httpBackend: angular.IHttpBackendService;\n    let ctrl: any;\n    const xyzPhoneData = {\n      name: 'phone xyz',\n      images: ['image/url1.png', 'image/url2.png']\n    };\n\n    beforeEach(inject(($componentController: any,\n                       _$httpBackend_: angular.IHttpBackendService,\n                       $routeParams: angular.route.IRouteParamsService) => {\n      $httpBackend = _$httpBackend_;\n      $httpBackend.expectGET('phones/xyz.json').respond(xyzPhoneData);\n\n      $routeParams.phoneId = 'xyz';\n\n      ctrl = $componentController('phoneDetail');\n    }));\n\n    it('should fetch the phone details', () => {\n      jasmine.addCustomEqualityTester(angular.equals);\n\n      expect(ctrl.phone).toEqual({});\n\n      $httpBackend.flush();\n      expect(ctrl.phone).toEqual(xyzPhoneData);\n    });\n\n  });\n\n});\n\n\n</code-example>\n<p>그리고 SysmsJS 환경에서 앱을 업그레이드하면 Karma를 실행하기 위한 환경 설정도 수정해야 합니다.\n다음과 같은 스크립트 파일을 사용해서 SystemJS가 새로 만든 Angular 코드를 로드하도록 합시다:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/karma-test-shim.1.js\" header=\"karma-test-shim.js\">\n// /*<a href=\"api/core/global\" class=\"code-anchor\">global</a> jasmine, __karma__, window*/\nError.stackTraceLimit = 0; // 앱을 테스트할 때는 보통 콜스택을 표시하지 않습니다.\n\n// 콜스택을 모두 표시하려면 주석을 제거합니다.\n// Error.stackTraceLimit = Infinity; //\n\njasmine.DEFAULT_TIMEOUT_INTERVAL = 1000;\n\nvar builtPath = '/base/app/';\n\n__karma__.loaded = function () { };\n\nfunction isJsFile(path) {\n  return path.slice(-3) == '.js';\n}\n\nfunction isSpecFile(path) {\n  return /\\.spec\\.(.*\\.)?js$/.test(path);\n}\n\nfunction isBuiltFile(path) {\n  return isJsFile(path) &#x26;&#x26; (path.substr(0, builtPath.length) == builtPath);\n}\n\nvar allSpecFiles = Object.keys(window.__karma__.files)\n  .filter(isSpecFile)\n  .filter(isBuiltFile);\n\nSystem.config({\n  baseURL: '/base',\n  // 테스트 폴더에 있는 파일을 불러오도록 설정합니다.\n  packages: { 'testing': { main: 'index.js', defaultExtension: 'js' } },\n\n  // npm:이 systemjs.config의 `paths`에 미리 정의되었다고 간주합니다.\n  // Angular 테스트 프레임워크를 맵핑합니다.\n  map: {\n    '@angular/core/testing': 'npm:@angular/core/bundles/core-testing.umd.js',\n    '@angular/common/testing': 'npm:@angular/common/bundles/common-testing.umd.js',\n    '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>/testing': 'npm:@angular/common/bundles/common-http-testing.umd.js',\n    '@angular/compiler/testing': 'npm:@angular/compiler/bundles/compiler-testing.umd.js',\n    '@angular/platform-browser/testing': 'npm:@angular/platform-browser/bundles/platform-browser-testing.umd.js',\n    '@angular/platform-browser-dynamic/testing': 'npm:@angular/platform-browser-dynamic/bundles/platform-browser-dynamic-testing.umd.js',\n    '@angular/router/testing': 'npm:@angular/router/bundles/router-testing.umd.js',\n    '@angular/forms/testing': 'npm:@angular/forms/bundles/forms-testing.umd.js',\n  },\n});\n\nSystem.import('systemjs.config.js')\n  .then(importSystemJsExtras)\n  .then(initTestBed)\n  .then(initTesting);\n\n/** SystemJS 추가 설정. 생략해도 됩니다. */\nfunction importSystemJsExtras(){\n  return System.import('systemjs.config.extras.js')\n  .catch(function(reason) {\n    console.log(\n      'Warning: System.import could not load the optional \"systemjs.config.extras.js\". Did you omit it by accident? Continuing without it.'\n    );\n    console.log(reason);\n  });\n}\n\nfunction initTestBed(){\n  return Promise.all([\n    System.import('@angular/core/testing'),\n    System.import('@angular/platform-browser-dynamic/testing')\n  ])\n\n  .then(function (providers) {\n    var coreTesting    = providers[0];\n    var browserTesting = providers[1];\n\n    coreTesting.TestBed.initTestEnvironment(\n      browserTesting.BrowserDynamicTestingModule,\n      browserTesting.platformBrowserDynamicTesting());\n  })\n}\n\n// 스펙 파일을 모두 로드하고 Karma를 시작합니다.\nfunction initTesting () {\n  return Promise.all(\n    allSpecFiles.map(function (moduleName) {\n      return System.import(moduleName);\n    })\n  )\n  .then(__karma__.start, __karma__.error);\n}\n\n\n</code-example>\n<p>이 스크립트 파일은 제일 먼저 SystemJS 환경 설정을 로드합니다.\n그 다음에 Angular 테스트 라이브러리를 로드하고 애플리케이션 스펙 파일을 로드합니다.</p>\n<p>Karma 설정은 <code>app</code> 대신 애플리케이션 루트 폴더를 기본 폴더로 사용하도록 변경해야 합니다.</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/karma.conf.ajs.js\" region=\"basepath\" header=\"karma.conf.js\">\nbasePath: './',\n\n</code-example>\n<p>그리고 나면 이제 Karma가 스크립트 파일과 SystemJS를 로드하도록 다음과 같이 구성합니다.</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/karma.conf.ajs.js\" region=\"files\" header=\"karma.conf.js\">\n// System.js는 모듈을 로딩할 때 사용합니다.\n'node_modules/systemjs/dist/system.src.js',\n\n// 폴리필 스크립트 파일\n'node_modules/core-js/client/shim.js',\n\n// zone.js\n'node_modules/zone.js/bundles/zone.umd.js',\n'node_modules/zone.js/bundles/zone-testing.umd.js',\n\n// RxJs.\n{ <a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'node_modules/rxjs/**/*.js', included: false, watched: false },\n{ <a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'node_modules/rxjs/**/*.js.map', included: false, watched: false },\n\n// Angular와 Angular 테스트 라이브러리를 로드합니다.\n{<a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'node_modules/@angular/**/*.js', included: false, watched: false},\n{<a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'node_modules/@angular/**/*.js.map', included: false, watched: false},\n\n{<a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'systemjs.config.js', included: false, watched: false},\n'karma-test-shim.js',\n\n{<a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'app/**/*.module.js', included: false, watched: true},\n{<a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'app/*!(.module|.spec).js', included: false, watched: true},\n{<a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'app/!(bower_components)/**/*!(.module|.spec).js', included: false, watched: true},\n{<a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'app/**/*.spec.js', included: false, watched: true},\n\n{<a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: '**/*.html', included: false, watched: true},\n\n</code-example>\n<p>아직 Angular 컴포넌트의 HTML 템플릿은 <code>basePath</code>가 변경되지 않은 경로에서 리소스를 참조하고 있습니다.\n이 파일들이 제대로 로드될 수 있도록 다음과 같이 프록시를 설정합니다:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/karma.conf.ajs.js\" region=\"html\" header=\"karma.conf.js\">\n// 애셋을 로드하기 위해 기본 경로를 변경합니다.\nproxies: {\n  // Angular가 컴포넌트를 컴파일하려면 애셋 파일이 필요합니다.\n  '/phone-detail': '/base/app/phone-detail',\n  '/phone-list': '/base/app/phone-list'\n},\n\n</code-example>\n<p>애플리케이션 코드가 Angular로 업그레이드 되면 유닛 테스트 파일도 Angular로 업그레이드하는 것이 좋습니다.\n테스트 코드 중 가장 간단한 체크마크 파이프를 Angular 버전으로 변환해 봅시다.\n이 파이프에는 의존성으로 주입되는 패키지가 아무 것도 없어서 변환하기도 쉽습니다:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/core/checkmark/checkmark.pipe.spec.ts\" header=\"app/core/checkmark/checkmark.pipe.spec.ts\">\nimport { CheckmarkPipe } from './checkmark.pipe';\n\ndescribe('CheckmarkPipe', () => {\n\n  it('should convert boolean values to unicode checkmark or cross', () => {\n    const checkmarkPipe = new CheckmarkPipe();\n    expect(checkmarkPipe.transform(true)).toBe('\\u2713');\n    expect(checkmarkPipe.transform(false)).toBe('\\u2718');\n  });\n});\n\n\n</code-example>\n<p>스마트폰 서비스와 관련된 유닛 테스트 코드는 조금 더 복잡합니다.\nAngularJS에서 사용하던 <code>$httpBackend</code>를 Angular HTTP 백엔드 모킹 함수로 대체합니다.</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.spec.ts\" header=\"app/core/phone/phone.service.spec.ts\">\nimport { inject, <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a> } from '@angular/core/testing';\nimport { <a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a>, <a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>/testing';\nimport { Phone, PhoneData } from './phone.service';\n\ndescribe('Phone', () => {\n  let phone: Phone;\n  const phonesData: PhoneData[] = [\n    {name: 'Phone X', snippet: '', images: []},\n    {name: 'Phone Y', snippet: '', images: []},\n    {name: 'Phone Z', snippet: '', images: []}\n  ];\n  let httpMock: <a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [\n        <a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a>\n      ],\n      providers: [\n        Phone,\n      ]\n    });\n  });\n\n  beforeEach(inject([<a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>, Phone], (_httpMock_: <a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>, _phone_: Phone) => {\n    httpMock = _httpMock_;\n    phone = _phone_;\n  }));\n\n  afterEach(() => {\n    httpMock.verify();\n  });\n\n  it('should fetch the phones data from `/phones/phones.json`', () => {\n    phone.query().subscribe(result => {\n      expect(result).toEqual(phonesData);\n    });\n    const req = httpMock.expectOne(`/phones/phones.json`);\n    req.flush(phonesData);\n  });\n\n});\n\n\n\n</code-example>\n<p>컴포넌트를 테스트하는 코드에서는 <code>Phone</code> 서비스 자체를 모킹하는 것이 좋습니다.\nAngular가 제공하는 컴포넌트 유닛 테스트 API를 다음과 같이 활용하면 됩니다.</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.component.spec.ts\" header=\"app/phone-detail/phone-detail.component.spec.ts\">\nimport { <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>, <a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a> } from '@angular/core/testing';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\nimport { Observable, of } from 'rxjs';\n\nimport { PhoneDetailComponent } from './phone-detail.component';\nimport { Phone, PhoneData } from '../core/phone/phone.service';\nimport { CheckmarkPipe } from '../core/checkmark/checkmark.pipe';\n\nfunction xyzPhoneData(): PhoneData {\n  return {name: 'phone xyz', snippet: '', images: ['image/url1.png', 'image/url2.png']};\n}\n\nclass MockPhone {\n  get(id: string): Observable&#x3C;PhoneData> {\n    return of(xyzPhoneData());\n  }\n}\n\n\nclass ActivatedRouteMock {\n  constructor(public snapshot: any) {}\n}\n\n\ndescribe('PhoneDetailComponent', () => {\n\n  beforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() => {\n    TestBed.configureTestingModule({\n      declarations: [ CheckmarkPipe, PhoneDetailComponent ],\n      providers: [\n        { provide: Phone, useClass: MockPhone },\n        { provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: new ActivatedRouteMock({ params: { phoneId: 1 } }) }\n      ]\n    })\n    .compileComponents();\n  }));\n\n  it('should fetch phone detail', () => {\n    const fixture = TestBed.createComponent(PhoneDetailComponent);\n    fixture.detectChanges();\n    const compiled = fixture.debugElement.nativeElement;\n    expect(compiled.querySelector('h1').textContent).toContain(xyzPhoneData().name);\n  });\n});\n\n\n</code-example>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.spec.ts\" header=\"app/phone-list/phone-list.component.spec.ts\">\nimport {<a href=\"api/common/testing/SpyLocation\" class=\"code-anchor\">SpyLocation</a>} from '@angular/common/testing';\nimport {<a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a>} from '@angular/core';\nimport {<a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>, <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>, <a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>} from '@angular/core/testing';\nimport {<a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>} from '@angular/router';\nimport {Observable, of} from 'rxjs';\n\nimport {Phone, PhoneData} from '../core/phone/phone.service';\n\nimport {PhoneListComponent} from './phone-list.component';\n\nclass ActivatedRouteMock {\n  constructor(public snapshot: any) {}\n}\n\nclass MockPhone {\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(): Observable&#x3C;PhoneData[]> {\n    return of([\n      {name: 'Nexus S', snippet: '', images: []}, {name: 'Motorola DROID', snippet: '', images: []}\n    ]);\n  }\n}\n\nlet fixture: <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>&#x3C;PhoneListComponent>;\n\ndescribe('PhoneList', () => {\n  beforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() => {\n    <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n        .configureTestingModule({\n          declarations: [PhoneListComponent],\n          providers: [\n            {provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: new ActivatedRouteMock({params: {'phoneId': 1}})},\n            {provide: <a href=\"api/common/Location\" class=\"code-anchor\">Location</a>, useClass: <a href=\"api/common/testing/SpyLocation\" class=\"code-anchor\">SpyLocation</a>},\n            {provide: Phone, useClass: MockPhone},\n          ],\n          schemas: [<a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a>]\n        })\n        .compileComponents();\n  }));\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(PhoneListComponent);\n  });\n\n  it('should create \"phones\" model with 2 phones fetched from xhr', () => {\n    fixture.detectChanges();\n    let compiled = fixture.debugElement.nativeElement;\n    expect(compiled.querySelectorAll('.phone-list-item').length).toBe(2);\n    expect(compiled.querySelector('.phone-list-item:nth-child(1)').textContent)\n        .toContain('Motorola DROID');\n    expect(compiled.querySelector('.phone-list-item:nth-child(2)').textContent)\n        .toContain('Nexus S');\n  });\n\n  xit('should set the default value of orderProp model', () => {\n    fixture.detectChanges();\n    let compiled = fixture.debugElement.nativeElement;\n    expect(compiled.querySelector('select option:last-child').selected).toBe(true);\n  });\n});\n\n\n</code-example>\n<p>마지막으로 Angular 라우터가 동작할 때 지금까지 만든 컴포넌트가 제대로 동작하도록 프로바이더를 등록합니다.\n스마트폰 상세정보 컴포넌트는 이제 AngularJS <code>$routeParams</code>에서 라우팅 인자를 받지 않고 Angular <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 객체에서 라우팅 인자를 받습니다.</p>\n<code-example path=\"upgrade-phonecat-3-final/app/phone-detail/phone-detail.component.spec.ts\" region=\"activatedroute\" header=\"app/phone-detail/phone-detail.component.spec.ts\">\nimport { <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>, <a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a> } from '@angular/core/testing';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\n/* . . . */\n\nclass ActivatedRouteMock {\n  constructor(public snapshot: any) {}\n}\n\n/* . . . */\n\n  beforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() => {\n    TestBed.configureTestingModule({\n      declarations: [ CheckmarkPipe, PhoneDetailComponent ],\n      providers: [\n        { provide: Phone, useClass: MockPhone },\n        { provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: new ActivatedRouteMock({ params: { phoneId: 1 } }) }\n      ]\n    })\n    .compileComponents();\n  }));\n\n</code-example>\n<p>그리고 스마트폰 목록 컴포넌트를 테스트하는 코드에서는 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 디렉티브가 제대로 동작하도록 다음과 같이 구성합니다.</p>\n<code-example path=\"upgrade-phonecat-3-final/app/phone-list/phone-list.component.spec.ts\" region=\"routestuff\" header=\"app/phone-list/phone-list.component.spec.ts\">\nimport {<a href=\"api/common/testing/SpyLocation\" class=\"code-anchor\">SpyLocation</a>} from '@angular/common/testing';\nimport {<a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a>} from '@angular/core';\nimport {<a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>, <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>, <a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>} from '@angular/core/testing';\nimport {<a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>} from '@angular/router';\nimport {Observable, of} from 'rxjs';\n\nimport {Phone, PhoneData} from '../core/phone/phone.service';\n\nimport {PhoneListComponent} from './phone-list.component';\n\n/* . . . */\n\n  beforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() => {\n    <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n        .configureTestingModule({\n          declarations: [PhoneListComponent],\n          providers: [\n            {provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: new ActivatedRouteMock({params: {'phoneId': 1}})},\n            {provide: <a href=\"api/common/Location\" class=\"code-anchor\">Location</a>, useClass: <a href=\"api/common/testing/SpyLocation\" class=\"code-anchor\">SpyLocation</a>},\n            {provide: Phone, useClass: MockPhone},\n          ],\n          schemas: [<a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a>]\n        })\n        .compileComponents();\n  }));\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(PhoneListComponent);\n  });\n\n</code-example>\n\n</div>\n\n<!-- links to this doc:\n - api/common\n - api/common/upgrade\n - api/common/upgrade/$locationShim\n - api/common/upgrade/LocationUpgradeModule\n - api/upgrade/static/downgradeComponent\n - guide/deprecations\n - guide/releases\n - guide/updating\n - guide/upgrade-performance\n - guide/upgrade-setup\n-->\n<!-- links from this doc:\n - api/animations/query\n - api/common/APP_BASE_HREF\n - api/common/HashLocationStrategy\n - api/common/Location\n - api/common/LocationStrategy\n - api/common/NgClass\n - api/common/NgForOf\n - api/common/NgIf\n - api/common/Time\n - api/common/http\n - api/common/http/HttpClient\n - api/common/http/HttpClientModule\n - api/common/http/testing/HttpClientTestingModule\n - api/common/http/testing/HttpTestingController\n - api/common/testing/SpyLocation\n - api/common/upgrade/$locationShim\n - api/common/upgrade/LocationUpgradeConfig\n - api/common/upgrade/LocationUpgradeModule\n - api/common/upgrade/LocationUpgradeModule#config\n - api/core/Component\n - api/core/Directive\n - api/core/ElementRef\n - api/core/EventEmitter\n - api/core/Injectable\n - api/core/Injector\n - api/core/Input\n - api/core/NO_ERRORS_SCHEMA\n - api/core/NgModule\n - api/core/NgZone\n - api/core/OnChanges\n - api/core/OnDestroy\n - api/core/OnInit\n - api/core/Output\n - api/core/Pipe\n - api/core/PipeTransform\n - api/core/SimpleChanges\n - api/core/Type\n - api/core/Version\n - api/core/global\n - api/core/testing/ComponentFixture\n - api/core/testing/TestBed\n - api/core/testing/waitForAsync\n - api/forms/FormsModule\n - api/forms/NgModel\n - api/forms/PatternValidator\n - api/platform-browser-dynamic/platformBrowserDynamic\n - api/platform-browser/BrowserModule\n - api/platform-browser/platformBrowser\n - api/router/ActivatedRoute\n - api/router/Router\n - api/router/RouterLink\n - api/router/RouterModule\n - api/router/RouterOutlet\n - api/router/Routes\n - api/router/UrlSegment\n - api/upgrade/static\n - api/upgrade/static/UpgradeComponent\n - api/upgrade/static/UpgradeModule\n - api/upgrade/static/downgradeComponent\n - api/upgrade/static/downgradeInjectable\n - guide/animations\n - guide/aot-compiler\n - guide/built-in-directives\n - guide/dependency-injection\n - guide/dependency-injection-providers#factory-providers\n - guide/glossary#lazy-loading\n - guide/hierarchical-dependency-injection\n - guide/lifecycle-hooks\n - guide/ngmodules\n - guide/router\n - guide/typescript-configuration\n - guide/upgrade#angular-location-서비스-통합하기\n - guide/upgrade#angular-ngmodule-과-upgrademodule-사용하기\n - guide/upgrade#angular-라우터-추가하고-부트스트랩하기\n - guide/upgrade#angular-라우터-추가하기\n - guide/upgrade#angular-설치하기\n - guide/upgrade#angular-영역에-angularjs-컴포넌트-사용하기\n - guide/upgrade#angular-의존성-객체를-angularjs에-등록하기\n - guide/upgrade#angular-컴포넌트에-angularjs-내용-프로젝션하기\n - guide/upgrade#angularjs-스타일-가이드를-따르세요\n - guide/upgrade#angularjs-애플리케이션을-지연-로딩하는-서비스-정의하기\n - guide/upgrade#angularjs-앱을-angular-앱으로-업그레이드하기\n - guide/upgrade#angularjs-앱을-렌더링하는-컴포넌트-생성하기\n - guide/upgrade#angularjs-영역에-angular-컴포넌트-사용하기\n - guide/upgrade#angularjs-의존성-객체를-angular에-등록하기\n - guide/upgrade#angularjs-컴포넌트-디렉티브에-angular-내용-트랜스클루전하기\n - guide/upgrade#angularjs-탈출하기\n - guide/upgrade#angularjs용-커스텀-라우팅-규칙-매처-구성하기\n - guide/upgrade#angularjs의-지연-로딩\n - guide/upgrade#angular에는-filter-orderby-필터가-없습니다\n - guide/upgrade#appmodule-생성하기\n - guide/upgrade#bootstrapping-hybrid-applications\n - guide/upgrade#checkmarkpipe-변환하기\n - guide/upgrade#e2e-테스트\n - guide/upgrade#follow-the-angular-styleguide\n - guide/upgrade#making-angularjs-dependencies-injectable-to-angular\n - guide/upgrade#ngupgrade가-동작하는-방식\n - guide/upgrade#ngupgrade로-업그레이드하기\n - guide/upgrade#phone-서비스-업그레이드하기\n - guide/upgrade#phonecat-업그레이드-튜토리얼\n - guide/upgrade#preparation\n - guide/upgrade#typescript-도입하기\n - guide/upgrade#typescript로-전환하기\n - guide/upgrade#upgrading-with-ngupgrade\n - guide/upgrade#using-component-directives\n - guide/upgrade#라우팅-모듈-생성하기\n - guide/upgrade#라우팅-인자-사용하기\n - guide/upgrade#링크-연결하기\n - guide/upgrade#모듈-로더-사용하기\n - guide/upgrade#변화-감지\n - guide/upgrade#부록-phonecat-테스트-업그레이드하기\n - guide/upgrade#사전준비\n - guide/upgrade#왜-angular-를-angulariangularstatic-으로-선언할까요\n - guide/upgrade#유닛-테스트\n - guide/upgrade#의존성-주입\n - guide/upgrade#컴포넌트-디렉티브-사용하기\n - guide/upgrade#컴포넌트-업그레이드하기\n - guide/upgrade#컴포넌트와-dom\n - guide/upgrade#하이브리드-앱-부트스트랩하기\n - guide/upgrade#하이브리드-앱을-aot-컴파일하기\n - guide/upgrade#하이브리드-프로젝트-부트스트랩하기\n - guide/upgrade-setup\n - http://browserify.org/\n - http://webpack.github.io/\n - https://docs.angularjs.org/api/ng/function/angular.bootstrap\n - https://docs.angularjs.org/api/ng/service/$location\n - https://docs.angularjs.org/api/ng/type/angular.Module\n - https://docs.angularjs.org/api/ng/type/angular.Module#component\n - https://docs.angularjs.org/api/ngRoute/directive/ngView\n - https://docs.angularjs.org/api/ngRoute/provider/$routeProvider\n - https://docs.angularjs.org/tutorial\n - https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#support-for-umd-module-definitions\n - https://github.com/angular/angular-phonecat\n - https://github.com/angular/angular/edit/master/aio/content/guide/upgrade.md?message=docs%3A%20describe%20your%20change...\n - https://github.com/angular/quickstart\n - https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md\n - https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#folders-by-feature-structure\n - https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity\n - https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#organizing-tests\n - https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility\n - https://github.com/systemjs/systemjs\n - https://www.npmjs.com/package/@types/angular\n-->"
}