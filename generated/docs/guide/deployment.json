{
  "id": "guide/deployment",
  "title": "배포",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/deployment.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Deployment\n-->\n<h1 id=\"배포\">배포<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/deployment#배포\"><i class=\"material-icons\">link</i></a></h1>\n<!--\nWhen you are ready to deploy your Angular application to a remote server, you have various options for deployment.\n-->\n<p>이 문서는 Angular 애플리케이션을 리모트 서버에 배포하는 방법에 대해 자세하게 안내합니다.</p>\n<a id=\"dev-deploy\"></a>\n<a id=\"copy-files\"></a>\n<!--\n## Simple deployment options\n-->\n<h2 id=\"간단한-배포-옵션\">간단한 배포 옵션<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/deployment#간단한-배포-옵션\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nBefore fully deploying your application, you can test the process, build configuration, and deployed behavior by using one of these interim techniques.\n-->\n<p>Angular가 제공하는 배포 도구를 활용하면 애플리케이션을 배포가 이루어지는 각 단계가 제대로 동작하는지, 빌드 설정은 올바른지, 배포 동작은 제대로 수행되는지 확인할 수 있습니다.</p>\n<!--\n### Building and serving from disk\n-->\n<h3 id=\"로컬-환경에서-빌드하고-실행해보기\">로컬 환경에서 빌드하고 실행해보기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/deployment#로컬-환경에서-빌드하고-실행해보기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nDuring development, you typically use the `ng serve` command to build, watch, and serve the application from local memory, using [webpack-dev-server](https://webpack.js.org/guides/development/#webpack-dev-server).\nWhen you are ready to deploy, however, you must use the `ng build` command to build the app and deploy the build artifacts elsewhere.\n\nBoth `ng build` and `ng serve` clear the output folder before they build the project, but only the `ng build` command writes the generated build artifacts to the output folder.\n-->\n<p>앱을 개발하는 단계에서는 보통 <code>ng serve</code> 명령을 실행해서 코드가 변경되는 것을 감지하는 모드로 앱을 빌드하는데, 이렇게 빌드한 애플리케이션은 로컬 메모리에서 실행되는 <a href=\"https://webpack.js.org/guides/development/#webpack-dev-server\">webpack-dev-server</a>로 띄워볼 수 있습니다.\n하지만 제대로 배포하려면 이 명령 대신 <code>ng build</code> 명령을 실행해서 애플리케이션 빌드 결과물을 로컬 환경에 파일로 생성해야 합니다.</p>\n<p><code>ng serve</code> 명령과 <code>ng build</code> 명령은 모두 프로젝트를 빌드하기 전에 빌드 결과물이 생성될 폴더를 깨끗하게 비웁니다. 이 때 <code>ng serve</code> 명령이 대상 폴더에 빌드 결과물을 생성하지 않는 것과 다르게, <code>ng build</code> 명령을 실행하면 대상 폴더에 빌드 결과물을 실제로 생성합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nThe output folder is  `dist/project-name/` by default.\nTo output to a different folder, change the `outputPath` in `angular.json`.\n-->\n<p>따로 수정하지 않았다면 빌드 결과물이 생성되는 위치는 <code>dist/프로젝트-이름</code> 폴더입니다.\n이 위치를 변경하려면 <code>angular.json</code> 파일에 지정된 <code>outputPath</code> 옵션을 변경하면 됩니다.</p>\n</div>\n<!--\nAs you near the end of the development process, serving the contents of your output folder from a local web server can give you a better idea of how your application will behave when it is deployed to a remote server.\nYou will need two terminals to get the live-reload experience.\n\n* On the first terminal, run the [`ng build` command](cli/build) in *watch* mode to compile the application to the `dist` folder.\n-->\n<p>개발 단계를 마무리할 때쯤 되었을 때 <code>ng build</code> 명령을 실행해서 애플리케이션을 빌드해보면, 빌드 결과물이 실제로 로컬 환경에 생성되기 때문에 리모트 서버에 이 파일들을 어떻게 둬야 하는지 생각해 볼 수 있습니다.\n이 과정은 다음과 같은 방법으로 확인할 수도 있습니다.</p>\n<ul>\n<li>\n<p>터미널에서 <a href=\"cli/build\"><code>ng build</code> 명령</a>을 실행하면서 <em>워치</em> 모드를 활성화할 수 있습니다. 이렇게 실행하면 애플리케이션 코드가 변경될 때마다 <code>dist</code> 폴더의 내용물도 다시 생성됩니다. <code>ng serve</code> 명령이 실행되는 동작과 비슷합니다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n\n ng build --watch\n\n</code-example>\n</li>\n</ul>\n<!--\n  Like the `ng serve` command, this regenerates output files when source files change.\n\n* On the second terminal, install a web server (such as [lite-server](https://github.com/johnpapa/lite-server)), and run it against the output folder. For example:\n-->\n<ul>\n<li>\n<p>아니면 <a href=\"https://github.com/johnpapa/lite-server\">lite-server</a>와 같은 웹 서버를 실행해서 빌드 결과물이 위치한 폴더를 직접 띄워볼 수도 있습니다. 보통 이렇게 실행합니다:</p>\n  <code-example language=\"none\" class=\"code-shell\">\n<p>   lite-server --baseDir=\"dist/project-name\"</p>\n  </code-example>\n<!--\n   The server will automatically reload your browser when new files are output.\n-->\n   이 방법도 이전과 마찬가지로 빌드 결과물 파일이 변경되면 브라우저에도 새로운 파일의 내용이 반영됩니다.\n</li>\n</ul>\n<div class=\"alert is-critical\">\n<!--\nThis method is for development and testing only, and is not a supported or secure way of deploying an application.\n-->\n<p>위에서 설명한 방법은 애플리케이션을 개발하거나 테스트하는 용도로만 사용하세요. 이 방법은 애플리케이션을 온전히 배포하는 방법은 아닙니다.</p>\n</div>\n<h3 id=\"automatic-deployment-with-the-cli\">Automatic deployment with the CLI<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/deployment#automatic-deployment-with-the-cli\"><i class=\"material-icons\">link</i></a></h3>\n<p>The Angular CLI command <code>ng deploy</code> (introduced in version 8.3.0) executes the <code>deploy</code> <a href=\"https://angular.io/guide/cli-builder\">CLI builder</a> associated with your project. A number of third-party builders implement deployment capabilities to different platforms. You can add any of them to your project by running <code>ng add [package name]</code>.</p>\n<p>When you add a package with deployment capability, it'll automatically update your workspace configuration (<code>angular.json</code> file) with a <code>deploy</code> section for the selected project. You can then use the <code>ng deploy</code> command to deploy that project.</p>\n<p>For example, the following command automatically deploys a project to Firebase.</p>\n<code-example language=\"none\" class=\"code-shell\">\nng add @angular/fire\nng deploy\n</code-example>\n<p>The command is interactive. In this case, you must have or create a Firebase account, and authenticate using that account. The command prompts you to select a Firebase project for deployment</p>\n<p>After the command produces an optimal build of your application (equivalent to <code>ng deploy --prod</code>), it'll upload the production assets to Firebase.</p>\n<p>In the table below, you can find a list of packages which implement deployment functionality to different platforms. The <code>deploy</code> command for each package may require different command line options. You can read more by following the links associated with the package names below:</p>\n<table>\n<thead>\n<tr>\n<th>Deployment to</th>\n<th>Package</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://firebase.google.com/docs/hosting\">Firebase hosting</a></td>\n<td><a href=\"https://npmjs.org/package/@angular/fire\"><code>@angular/fire</code></a></td>\n</tr>\n<tr>\n<td><a href=\"https://azure.microsoft.com/en-us/\">Azure</a></td>\n<td><a href=\"https://npmjs.org/package/@azure/ng-deploy\"><code>@azure/ng-deploy</code></a></td>\n</tr>\n<tr>\n<td><a href=\"https://zeit.co/now\">Now</a></td>\n<td><a href=\"https://npmjs.org/package/@zeit/ng-deploy\"><code>@zeit/ng-deploy</code></a></td>\n</tr>\n<tr>\n<td><a href=\"https://www.netlify.com/\">Netlify</a></td>\n<td><a href=\"https://npmjs.org/package/@netlify-builder/deploy\"><code>@netlify-builder/deploy</code></a></td>\n</tr>\n<tr>\n<td><a href=\"https://pages.github.com/\">GitHub pages</a></td>\n<td><a href=\"https://npmjs.org/package/angular-cli-ghpages\"><code>angular-cli-ghpages</code></a></td>\n</tr>\n<tr>\n<td><a href=\"https://npmjs.com/\">NPM</a></td>\n<td><a href=\"https://npmjs.org/package/ngx-deploy-npm\"><code>ngx-deploy-npm</code></a></td>\n</tr>\n</tbody>\n</table>\n<p>If you're deploying to a self-managed server or there's no builder for your favorite cloud platform, you can either create a builder that allows you to use the <code>ng deploy</code> command, or read through this guide to learn how to manually deploy your app.</p>\n<!--\n### Basic deployment to a remote server\n-->\n<h3 id=\"리모트-서버에-배포하기\">리모트 서버에 배포하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/deployment#리모트-서버에-배포하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nFor the simplest deployment, create a production build and copy the output directory to a web server.\n-->\n<p>애플리케이션을 배포하는 방법중 가장 간단한 것은 애플리케이션을 운영용으로 빌드한 후에 생성되는 빌드 결과물을 웹 서버로 복사하는 것입니다.</p>\n<!--\n1. Start with the production build:\n-->\n<ol>\n<li>\n<p>애플리케이션을 운영용으로 빌드합니다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n\n  ng build --prod\n\n</code-example>\n</li>\n</ol>\n<!--\n2. Copy _everything_ within the output folder (`dist/` by default) to a folder on the server.\n-->\n<ol start=\"2\">\n<li>빌드 결과물이 생성된 폴더(기본 위치는 <code>dist/</code>)에 있는 <em>모든 파일</em> 을 서버로 복사합니다.</li>\n</ol>\n<!--\n3. Configure the server to redirect requests for missing files to `index.html`.\nLearn more about server-side redirects [below](#fallback).\n\nThis is the simplest production-ready deployment of your application.\n-->\n<ol start=\"3\">\n<li>서버로 오는 요청 중에서 실제로 존재하지 않는 파일에 대한 요청은 <code>index.html</code>로 리다이렉트하도록 합니다.\n자세한 내용은 <a href=\"guide/deployment#fallback\">아래</a>에서 다룹니다.</li>\n</ol>\n<p>이 방법이 애플리케이션을 배포하는 방법 중 가장 간단한 방법입니다.</p>\n<a id=\"deploy-to-github\"></a>\n<!--\n### Deploy to GitHub pages\n-->\n<h3 id=\"github-페이지에-배포하기\">GitHub 페이지에 배포하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/deployment#github-페이지에-배포하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAnother simple way to deploy your Angular app is to use [GitHub Pages](https://help.github.com/articles/what-is-github-pages/).\n\n1. You need to [create a GitHub account](https://github.com/join) if you don't have one, and then [create a repository](https://help.github.com/articles/create-a-repo/) for your project.\nMake a note of the user name and project name in GitHub.\n\n1. Build your project using Github project name, with the Angular CLI command [`ng build`](cli/build) and the options shown here:\n-->\n<p>또 다른 방법은 Angular 앱을 <a href=\"https://help.github.com/articles/what-is-github-pages/\">GitHub Pages</a>에 배포하는 것입니다.</p>\n<ol>\n<li>\n<p>GitHub 페이지에 배포하려면 먼저 <a href=\"https://github.com/join\">GitHub 계정을 생성</a>해야 합니다. 그리고 프로젝트가 위치할 <a href=\"https://help.github.com/articles/create-a-repo/\">코드 저장소를 하나 만듭니다</a>.</p>\n</li>\n<li>\n<p>Github 프로젝트 이름을 기본 주소로 지정하면서 Angular 프로젝트를 빌드합니다. <a href=\"cli/build\"><code>ng build</code></a>를 실행할 때 옵션을 다음과 같이 사용하면 됩니다:\n<code-example language=\"none\" class=\"code-shell\"></code-example></p>\n<p>  ng build --prod --output-path docs --base-href /&#x3C;project_name>/</p>\n\n</li>\n</ol>\n<!--\n1. When the build is complete, make a copy of `docs/index.html` and name it `docs/404.html`.\n\n1. Commit your changes and push.\n\n1. On the GitHub project page, configure it to [publish from the docs folder](https://help.github.com/articles/configuring-a-publishing-source-for-github-pages/#publishing-your-github-pages-site-from-a-docs-folder-on-your-master-branch).\n\nYou can see your deployed page at `https://<user_name>.github.io/<project_name>/`.\n-->\n<ol start=\"3\">\n<li>\n<p>빌드가 끝나면 <code>docs/index.html</code> 파일을 복사해서 <code>docs/404.html</code> 파일을 생성합니다.</p>\n</li>\n<li>\n<p>변경사항을 커밋하고 레파지토리에 푸시합니다.</p>\n</li>\n<li>\n<p>GitHub 프로젝트 페이지에서 <a href=\"https://help.github.com/articles/configuring-a-publishing-source-for-github-pages/#publishing-your-github-pages-site-from-a-docs-folder-on-your-master-branch\">docs 폴더가 static으로 동작하도록 설정</a>합니다.</p>\n</li>\n</ol>\n<p>이제 <code>https://&#x3C;user_name>.github.io/&#x3C;project_name>/</code>에 접속하면 Angular 애플리케이션이 동작하는 것을 확인할 수 있습니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nCheck out [angular-cli-ghpages](https://github.com/angular-buch/angular-cli-ghpages), a full featured package that does all this for you and has extra functionality.\n-->\n<p><a href=\"https://github.com/angular-buch/angular-cli-ghpages\">angular-cli-ghpages</a>도 확인해 보세요.\n이 프로젝트를 활용하면 Angular CLI를 사용하는 환경에서 GitHub 페이지 설정을 더 간단하고 다양하게 할 수 있습니다.</p>\n</div>\n<hr>\n<a id=\"server-configuration\"></a>\n<!--\n## Server configuration\n-->\n<h2 id=\"서버-설정\">서버 설정<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/deployment#서버-설정\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThis section covers changes you may have to make to the server or to files deployed on the server.\n-->\n<p>이 섹션에서는 Angular 애플리케이션을 서버에 배포할 때 수정해야 할 수도 있는 서버 설정에 대해 다룹니다.</p>\n<a id=\"fallback\"></a>\n<!--\n### Routed apps must fallback to `index.html`\n-->\n<h3 id=\"angular-앱이-동작해야-하는-경우는-모두-indexhtml로-보내야-합니다\">Angular 앱이 동작해야 하는 경우는 모두 <code>index.html</code>로 보내야 합니다.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/deployment#angular-앱이-동작해야-하는-경우는-모두-indexhtml로-보내야-합니다\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAngular apps are perfect candidates for serving with a simple static HTML server.\nYou don't need a server-side engine to dynamically compose application pages because\nAngular does that on the client-side.\n\nIf the app uses the Angular router, you must configure the server\nto return the application's host page (`index.html`) when asked for a file that it does not have.\n-->\n<p>Angular 애플리케이션은 간단한 정적 HTML 서버로 호스팅하는 것도 아주 간단합니다.\n이 경우에는 Angular 애플리케이션이 클라이언트에서 실행되기 때문에 서버에서 동적으로 애플리케이션 페이지를 처리해야 하는 엔진도 필요 없습니다.</p>\n<p>그런데 Angular 애플리케이션을 이렇게 활용하는 경우에는 실제로 존재하는 파일을 요청하지 않는 이상 모든 GET 요청이 Angular 호스트 페이지(<code>index.html</code>)로 향하도록(fallback) 서버 설정을 조정해야 합니다.</p>\n<a id=\"deep-link\"></a>\n<!--\nA routed application should support \"deep links\".\nA _deep link_ is a URL that specifies a path to a component inside the app.\nFor example, `http://www.mysite.com/heroes/42` is a _deep link_ to the hero detail page\nthat displays the hero with `id: 42`.\n\nThere is no issue when the user navigates to that URL from within a running client.\nThe Angular router interprets the URL and routes to that page and hero.\n\nBut clicking a link in an email, entering it in the browser address bar,\nor merely refreshing the browser while on the hero detail page &mdash;\nall of these actions are handled by the browser itself, _outside_ the running application.\nThe browser makes a direct request to the server for that URL, bypassing the router.\n\nA static server routinely returns `index.html` when it receives a request for `http://www.mysite.com/`.\nBut it rejects `http://www.mysite.com/heroes/42` and returns a `404 - Not Found` error *unless* it is\nconfigured to return `index.html` instead.\n-->\n<p>Angular 라우터를 사용하는 애플리케이션은 \"딥 링크(deep links)\"를 지원해야 합니다.\nAngular에서 <em>딥 링크</em> 란 Angular 애플리케이션 안에 있는 특정 컴포넌트를 가리키는 URL을 의미합니다.\n그래서 <code>http://www.mysite.com/heroes/42</code>라는 <em>딥 링크</em> 는 <code>id: 42</code>에 해당하는 히어로의 상세 정보를 표현하는 페이지를 가리킵니다.</p>\n<p>이 주소는 클라이언트쪽에서 네비게이션하는 방식으로 이동했을 때는 전혀 문제가 없습니다.\nAngular 라우터가 이 URL을 확인하면 해당 페이지로 이동하고 원하는 히어로의 정보도 화면에 표시할 것입니다.</p>\n<p>그런데 이메일에 있는 링크를 클릭하거나 브라우저 주소표시줄에 이 주소를 직접 입력했을 때, 히어로 상세정보 페이지에서 브라우저를 새로고침한 경우에는 이 주소를 브라우저가 직접 처리하기 때문에 Angular 애플리케이션이 관여하는 영역을 <em>벗어나게</em> 됩니다.\n그래서 이 경우에는 브라우저가 Angular 라우터를 건너뛰고 해당 URL로 직접 서버 요청을 보냅니다.</p>\n<p>일반적으로 정적 서버는 <code>http://www.mysite.com</code>과 같은 요청을 받았을 때 <code>index.html</code>을 반환합니다.\n하지만 <code>http://www.mysite.com/heroes/42</code>라는 요청을 정적 서버가 받으면 <code>index.html</code>을 보내도록 따로 설정하지 않은 이상 <code>404 - Not Found</code>를 반환합니다.</p>\n<!--\n#### Fallback configuration examples\n-->\n<h4 id=\"폴백fallback-설정-예\">폴백(fallback) 설정 예<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/deployment#폴백fallback-설정-예\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThere is no single configuration that works for every server.\nThe following sections describe configurations for some of the most popular servers.\nThe list is by no means exhaustive, but should provide you with a good starting point.\n\n* [Apache](https://httpd.apache.org/): add a\n[rewrite rule](http://httpd.apache.org/docs/current/mod/mod_rewrite.html) to the `.htaccess` file as shown\n  (https://ngmilk.rocks/2015/03/09/angularjs-html5-mode-or-pretty-urls-on-apache-using-htaccess/):\n-->\n<p>모든 서버에 동일하게 적용할 수 있는 만능 설정은 없습니다.\n그래서 이제부터는 개발자들이 많이 사용하는 서버를 대상으로 폴백을 어떻게 설정할 수 있는지 알아봅시다.\n이 문서에서 모든 서버를 다루지는 않지만, 이렇게 사용한다는 것을 참고하면 설명하지 않은 서버를 설정할 때도 도움이 될 것입니다.</p>\n<ul>\n<li>\n<p><a href=\"https://httpd.apache.org/\">Apache</a>: <code>.htaccess</code> 파일에 <a href=\"http://httpd.apache.org/docs/current/mod/mod_rewrite.html\">rewrite rule</a>을 추가합니다. (<a href=\"https://ngmilk.rocks/2015/03/09/angularjs-html5-mode-or-pretty-urls-on-apache-using-htaccess/\">참고</a>)</p>\n<code-example>\n  RewriteEngine On\n  # 서버에 존재하는 리소스나 폴더를 요청하면 해당 리소스를 보냅니다.\n  RewriteCond %{DOCUMENT_ROOT}%{REQUEST_URI} -f [OR]\n  RewriteCond %{DOCUMENT_ROOT}%{REQUEST_URI} -d\n  RewriteRule ^ - [L]<br>\n  # 실제로 존재하지 않는 리소스를 요청하면 index.html을 보냅니다.\n  RewriteRule ^ /index.html\n</code-example>\n</li>\n</ul>\n<!--\n* [Nginx](http://nginx.org/): use `try_files`, as described in\n[Front Controller Pattern Web Apps](https://www.nginx.com/resources/wiki/start/topics/tutorials/config_pitfalls/#front-controller-pattern-web-apps),\nmodified to serve `index.html`:\n-->\n<ul>\n<li>\n<p><a href=\"http://nginx.org/\">Nginx</a>: <a href=\"https://www.nginx.com/resources/wiki/start/topics/tutorials/config_pitfalls/#front-controller-pattern-web-apps\">Front Controller Pattern Web Apps</a>에서 설명하는 대로 <code>try_files</code>를 사용해서 <code>index.html</code>을 보내도록 설정합니다.</p>\n<code-example>\ntry_files $uri $uri/ /index.html;\n</code-example>\n</li>\n<li>\n<p><a href=\"https://www.ruby-lang.org/\">Ruby</a>: create a Ruby server using (<a href=\"http://sinatrarb.com/\">sinatra</a>) with a basic Ruby file that configures the server <code>server.rb</code>:</p>\n<code-example language=\"ruby\">\nrequire 'sinatra'\n\n# Folder structure\n# .\n# -- server.rb\n# -- public\n#    |-- dist\n#        |-- index.html\n\nget '/' do\n    folderDir = settings.public_folder + '/dist'  # ng build output folder\n    send_file File.join(folderDir, 'index.html')\nend\n</code-example>\n</li>\n</ul>\n<!--\n* [IIS](https://www.iis.net/): add a rewrite rule to `web.config`, similar to the one shown\n[here](http://stackoverflow.com/a/26152011/2116927):\n-->\n<ul>\n<li>\n<p><a href=\"https://www.iis.net/\">IIS</a>: <a href=\"http://stackoverflow.com/a/26152011/2116927\">이 글</a>에서 설명한 것과 비슷하게 <code>web.config</code>에 rewrite rule을 추가합니다.</p>\n<code-example format=\".\" language=\"xml\">\n  &#x3C;system.webServer>\n    &#x3C;rewrite>\n      &#x3C;rules>\n        &#x3C;rule name=\"Angular <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a>\" stopProcessing=\"true\">\n          &#x3C;match url=\".*\" />\n          &#x3C;conditions logicalGrouping=\"MatchAll\">\n            &#x3C;add input=\"{REQUEST_FILENAME}\" matchType=\"IsFile\" negate=\"true\" />\n            &#x3C;add input=\"{REQUEST_FILENAME}\" matchType=\"IsDirectory\" negate=\"true\" />\n          &#x3C;/conditions>\n          &#x3C;action type=\"Rewrite\" url=\"/index.html\" />\n        &#x3C;/rule>\n      &#x3C;/rules>\n    &#x3C;/rewrite>\n  &#x3C;/system.webServer>\n</code-example>\n</li>\n</ul>\n<!--\n* [GitHub Pages](https://pages.github.com/): you can't\n[directly configure](https://github.com/isaacs/github/issues/408)\nthe GitHub Pages server, but you can add a 404 page.\nCopy `index.html` into `404.html`.\nIt will still be served as the 404 response, but the browser will process that page and load the app properly.\nIt's also a good idea to\n[serve from `docs/` on master](https://help.github.com/articles/configuring-a-publishing-source-for-github-pages/#publishing-your-github-pages-site-from-a-docs-folder-on-your-master-branch)\nand to\n[create a `.nojekyll` file](https://www.bennadel.com/blog/3181-including-node-modules-and-vendors-folders-in-your-github-pages-site.htm)\n-->\n<ul>\n<li><a href=\"https://pages.github.com/\">GitHub Pages</a>: 개발자가 GitHub Pages 서버 설정을 <a href=\"https://github.com/isaacs/github/issues/408\">직접 변경할 수는 없지만</a>, 404 페이지를 활용할 수 있습니다.\n이 방법은 아주 간단합니다.\n<code>index.html</code> 파일을 복사해서 <code>404.html</code> 파일로 만들기만 하면 됩니다.\n그러면 서버가 404 응답을 반환하더라도 브라우저는 Angular 앱을 실행하기 때문에 원하는 페이지로 접근할 수 있습니다.\n이 방법 외에도 <a href=\"https://help.github.com/articles/configuring-a-publishing-source-for-github-pages/#publishing-your-github-pages-site-from-a-docs-folder-on-your-master-branch\">master 브랜치의 <code>docs/</code> 폴더</a>에서 Angular 애플리케이션을 서비스하거나, <a href=\"https://www.bennadel.com/blog/3181-including-node-modules-and-vendors-folders-in-your-github-pages-site.htm\"><code>.nojekyll</code> 파일을 만들어서</a> 설정하는 방법도 있습니다.</li>\n</ul>\n<!--\n* [Firebase hosting](https://firebase.google.com/docs/hosting/): add a\n[rewrite rule](https://firebase.google.com/docs/hosting/url-redirects-rewrites#section-rewrites).\n-->\n<ul>\n<li>\n<p><a href=\"https://firebase.google.com/docs/hosting/\">Firebase hosting</a>: <a href=\"https://firebase.google.com/docs/hosting/url-redirects-rewrites#section-rewrites\">rewrite rule</a>을 다음과 같이 추가합니다.</p>\n<code-example language=\"json\">\n  \"rewrites\": [ {\n    \"source\": \"**\",\n    \"destination\": \"/index.html\"\n  } ]\n</code-example>\n</li>\n</ul>\n<a id=\"cors\"></a>\n<!--\n### Requesting services from a different server (CORS)\n-->\n<h3 id=\"다른-서버로-요청-보내기-cors\">다른 서버로 요청 보내기 (CORS)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/deployment#다른-서버로-요청-보내기-cors\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAngular developers may encounter a\n<a href=\"https://en.wikipedia.org/wiki/Cross-origin_resource_sharing\" title=\"Cross-origin resource sharing\">\n<i>cross-origin resource sharing</i></a> error when making a service request (typically a data service request)\nto a server other than the application's own host server.\nBrowsers forbid such requests unless the server permits them explicitly.\n\nThere isn't anything the client application can do about these errors.\nThe server must be configured to accept the application's requests.\nRead about how to enable CORS for specific servers at\n<a href=\"http://enable-cors.org/server.html\" title=\"Enabling CORS server\">enable-cors.org</a>.\n-->\n<p>Angular 애플리케이션을 개발하다보면 애플리케이션이 호스팅되는 서버와 다른 서버로 요청을 보낼 때 <a href=\"https://en.wikipedia.org/wiki/Cross-origin_resource_sharing\" title=\"Cross-origin resource sharing\">\n<i>교차 출처 리소스 공유(cross-origin resource sharing, CORS)</i></a> 에러가 발생하는 일이 종종 있습니다.\n이 에러는 서버에서 명시적으로 허용하지 않는 한 거절됩니다.</p>\n<p>이 에러가 발생할 때 클라이언트 애플리케이션 쪽에서 처리할 수 있는 것은 아무것도 없습니다.\n클라이언트 애플리케이션이 요청하는 것을 서버가 처리할 수 있도록 서버의 설정을 변경해야 합니다.\n서버 종류에 따라 CORS를 허용하는 방법은 <a href=\"http://enable-cors.org/server.html\" title=\"Enabling CORS server\">enable-cors.org</a> 문서를 참고하세요.</p>\n<hr>\n<a id=\"optimize\"></a>\n<!--\n## Production optimizations\n-->\n<h2 id=\"운영-배포-최적화\">운영 배포 최적화<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/deployment#운영-배포-최적화\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe `--prod` _meta-flag_ engages the following build optimization features.\n-->\n<p><code>--prod</code> <em>메타 플래그</em> 를 사용하면 Angular 애플리케이션을 운영용으로 최적화해서 빌드할 수 있습니다.</p>\n<!--\n* [Ahead-of-Time (AOT) Compilation](guide/aot-compiler): pre-compiles Angular component templates.\n* [Production mode](#enable-prod-mode): deploys the production environment which enables _production mode_.\n* Bundling: concatenates your many application and library files into a few bundles.\n* Minification: removes excess whitespace, comments, and optional tokens.\n* Uglification: rewrites code to use short, cryptic variable and function names.\n* Dead code elimination: removes unreferenced modules and much unused code.\n-->\n<ul>\n<li><a href=\"guide/aot-compiler\">AOT 컴파일러</a> 사용: Angular 컴포넌트의 템플릿을 미리 컴파일합니다.</li>\n<li><a href=\"guide/deployment#enable-prod-mode\">운영 모드</a> 활성화: 애플리케이션이 동작하는 환경을 <em>운영 모드</em> 로 변경합니다.</li>\n<li>번들링(Bundling): 애플리케이션 파일과 라이브러리 파일들을 묶어서 몇개의 번들링 파일로 생성합니다.</li>\n<li>코드 압축(Minification): 공백 문자, 주석, 옵션 토큰을 제거합니다.</li>\n<li>난독화(Uglification): 변수와 함수 이름을 난독화하고 길이도 짧게 줄입니다.</li>\n<li>데드 코드 제거: 사용하지 않는 모듈과 코드를 제거합니다.</li>\n</ul>\n<!--\nSee [`ng build`](cli/build) for more about CLI build options and what they do.\n-->\n<p>이 때 활용할 수 있는 Angular CLI 빌드 옵션은 <a href=\"cli/build\"><code>ng build</code></a> 문서를 참고하세요.</p>\n<a id=\"enable-prod-mode\"></a>\n<!--\n### Enable runtime production mode\n-->\n<h3 id=\"운영-모드-활성화하기\">운영 모드 활성화하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/deployment#운영-모드-활성화하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn addition to build optimizations, Angular also has a runtime production mode. Angular apps run in development mode by default, as you can see by the following message on the browser console:\n-->\n<p>빌드 최적화와 함께 Angular에도 운영 모드가 존재합니다.\nAngular 애플리케이션은 기본적으로 개발모드로 동작하며, 이 모드에서는 브라우저 콘솔에 다음과 같은 메시지가 출력됩니다:</p>\n<code-example format=\"nocode\">\n\n  Angular is running in the development mode. Call <a href=\"api/core/enableProdMode\" class=\"code-anchor\">enableProdMode</a>() to enable the production mode.\n\n</code-example>\n<!--\nSwitching to _production mode_ makes it run faster by disabling development specific checks such as the dual change detection cycles.\n-->\n<p>애플리케이션이 동작하는 환경을 <em>운영 모드</em> 로 변경하면 개발 모드에서 동작하는 이중 변화 감지 로직이 생략되기 때문에 애플리케이션 실행속도가 조금 더 빨라집니다.</p>\n<!--\nWhen you enable production builds via `--prod` command line flag, the runtime production mode is enabled as well.\n-->\n<p>Angular 애플리케이션을 빌드할 때 <code>--prod</code> 플래그를 사용하면 Angular 실행 환경이 자동으로 운영 모드로 변경됩니다.</p>\n<a id=\"lazy-loading\"></a>\n<!--\n### Lazy loading\n-->\n<h3 id=\"지연-로딩\">지연 로딩<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/deployment#지연-로딩\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou can dramatically reduce launch time by only loading the application modules that\nabsolutely must be present when the app starts.\n-->\n<p>전체 모듈 중에서 애플리케이션 초기 실행에 필요한 모듈만 로딩하면 애플리케이션 초기 실행 속도를 더 빠르게 만들 수 있습니다.</p>\n<!--\nConfigure the Angular Router to defer loading of all other modules (and their associated code), either by\n[waiting until the app has launched](guide/router#preloading  \"Preloading\")\nor by [_lazy loading_](guide/router#asynchronous-routing \"Lazy loading\")\nthem on demand.\n-->\n<p>그리고 애플리케이션 초기 실행과 관련되지 않은 모듈은 Angular 라우터로 지연로딩하거나 <a href=\"guide/router#preloading\" title=\"Preloading\">애플리케이션이 시작된 직후에</a> 로딩할 수 있습니다.</p>\n<div class=\"callout is-helpful\">\n<!--\n<header>Don't eagerly import something from a lazy-loaded module</header>\n-->\n<header>지연로딩하는 모듈에 있는 심볼을 즉시로딩하지 마세요.</header>\n<!--\nIf you mean to lazy-load a module, be careful not import it\nin a file that's eagerly loaded when the app starts (such as the root `AppModule`).\nIf you do that, the module will be loaded immediately.\n\nThe bundling configuration must take lazy loading into consideration.\nBecause lazy-loaded modules aren't imported in JavaScript, bundlers exclude them by default.\nBundlers don't know about the router configuration and can't create separate bundles for lazy-loaded modules.\nYou would have to create these bundles manually.\n-->\n<p>지연로딩하는 모듈이 있다면 애플리케이션이 시작할 때 즉시 로드되는 모듈(ex. <code>AppModule</code>)에서 지연로딩되는 모듈의 구성요소를 로드하지 않도록 주의해야 합니다.\n이런 경우에는 모듈이 지연로딩되지 않고 즉시 로드됩니다.</p>\n<p>번들링 설정에서도 지연로딩을 고려해야 합니다.\n왜냐하면 지연로딩되는 모듈은 기본 번들링 결과물에 포함되지 않고 따로 번들링되기 때문입니다.\n하지만 번들러는 라우터 설정이나 지연로딩되는 모듈을 스스로 인식해서 가장 효율적인 방법으로 번들링하지는 않습니다.\n이런 설정은 개발자가 직접 해줘야 합니다.</p>\n<!--\nThe CLI runs the\n[Angular Ahead-of-Time Webpack Plugin](https://github.com/angular/angular-cli/tree/master/packages/ngtools/webpack)\nwhich automatically recognizes lazy-loaded `NgModules` and creates separate bundles for them.\n-->\n<p>Angular CLI는 <a href=\"https://github.com/angular/angular-cli/tree/master/packages/%40ngtools/webpack\">Angular AoT Webpack 플러그인</a>을 사용하기 때문에 지연로딩되는 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>을 자동으로 인식하고 번들링 파일을 생성합니다.</p>\n</div>\n<a id=\"measure\"></a>\n<!--\n### Measure performance\n-->\n<h3 id=\"성능-측정하기\">성능 측정하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/deployment#성능-측정하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou can make better decisions about what to optimize and how when you have a clear and accurate understanding of\nwhat's making the application slow.\nThe cause may not be what you think it is.\nYou can waste a lot of time and money optimizing something that has no tangible benefit or even makes the app slower.\nYou should measure the app's actual behavior when running in the environments that are important to you.\n-->\n<p>애플리케이션의 동작 성능을 최적화하려면 애플리케이션의 어떤 부분을 어떻게 수정해야 하는지 정확하게 알고 있는 것이 좋습니다.\n하지만 애플리케이션을 잘 알고 있다고 해도 예상치 못한 결과는 언제든지 생길 수 있습니다.\n수많은 시간과 자금을 들여 애플리케이션을 최적화했는데 이전과 크게 차이나지 않거나 오히려 더 느려질 수도 있습니다.\n그래서 애플리케이션을 최적화 할 때는 실제로 동작하는 환경에서 어떻게 동작하는지 측정해야 합니다.</p>\n<!--\nThe\n<a href=\"https://developers.google.com/web/tools/chrome-devtools/network-performance/understanding-resource-timing\" title=\"Chrome DevTools Network Performance\">\nChrome DevTools Network Performance page</a> is a good place to start learning about measuring performance.\n-->\n<p>애플리케이션의 성능을 측정할 때는 <a href=\"https://developers.google.com/web/tools/chrome-devtools/network-performance/understanding-resource-timing\" title=\"Chrome DevTools Network Performance\">Chrome 개발자도구의 네트워크 퍼포먼트 페이지</a>를 사용하는 것이 좋습니다.</p>\n<!--\nThe [WebPageTest](https://www.webpagetest.org/) tool is another good choice\nthat can also help verify that your deployment was successful.\n-->\n<p>그리고 이미 배포된 애플리케이션은 <a href=\"https://www.webpagetest.org/\">WebPageTest</a>과 같은 툴로 성능을 측정할 수 있습니다.</p>\n<a id=\"inspect-bundle\"></a>\n<!--\n### Inspect the bundles\n-->\n<h3 id=\"번들파일-분석하기\">번들파일 분석하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/deployment#번들파일-분석하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe <a href=\"https://github.com/danvk/source-map-explorer/blob/master/README.md\">source-map-explorer</a>\ntool is a great way to inspect the generated JavaScript bundles after a production build.\n-->\n<p>애플리케이션을 운영용으로 빌드한 후라면 <a href=\"https://github.com/danvk/source-map-explorer/blob/master/README.md\">source-map-explorer</a>를 사용해서 JavaScript로 번들링 된 파일을 분석할 수 있습니다.</p>\n<!--\nInstall `source-map-explorer`:\n-->\n<p><code>source-map-explorer</code>는 다음 명령을 실행해서 설치합니다:</p>\n<code-example language=\"none\" class=\"code-shell\">\n\n  npm install source-map-explorer --save-dev\n\n</code-example>\n<!--\nBuild your app for production _including the source maps_\n-->\n<p>그리고 애플리케이션을 운영용으로 빌드할 때 <em>소스 맵</em> 을 함께 생성하도록 다음과 같이 실행합니다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n\n  ng build --prod --source-map\n\n</code-example>\n<!--\nList the generated bundles in the `dist/` folder.\n-->\n<p>빌드가 끝나면 <code>dist/</code> 폴더의 내용을 확인해 봅시다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n\n  ls dist/*.bundle.js\n\n</code-example>\n<!--\nRun the explorer to generate a graphical representation of one of the bundles.\nThe following example displays the graph for the _main_ bundle.\n-->\n<p>이제 <code>source-map-explorer</code>로 번들링 파일을 로드하면 번들링 파일의 구조를 시각화해볼 수 있습니다.\n예를 들어 <em>main</em> 파일이 번들링된 결과물을 분석하려면 다음과 같이 실행합니다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n\n  node_modules/.bin/source-map-explorer dist/main.*.bundle.js\n\n</code-example>\n<!--\nThe `source-map-explorer` analyzes the source map generated with the bundle and draws a map of all dependencies,\nshowing exactly which classes are included in the bundle.\n-->\n<p>그러면 <code>source-map-explorer</code>가 번들링 결과물과 소스 맵을 처리해서 이 번들링 파일에 어떤 클래스가 포함되어 있는지 분석할 수 있는 정보를 제공합니다.</p>\n<!--\nHere's the output for the _main_ bundle of an example app called `cli-quickstart`.\n-->\n<p><code>cli-quickstart</code> 프로젝트의 <em>main</em> 파일을 번들링한 결과로 이 프로그램을 실행시켜보면 다음과 같은 결과를 확인할 수 있습니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/deployment/quickstart-sourcemap-explorer.png\" alt=\"quickstart sourcemap explorer\" width=\"767\" height=\"401\">\n</div>\n<a id=\"base-tag\"></a>\n<!--\n## The `base` tag\n-->\n<h2 id=\"base-태그\"><code>base</code> 태그<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/deployment#base-태그\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe HTML [_&lt;base href=\"...\"/&gt;_](/guide/router)\nspecifies a base path for resolving relative URLs to assets such as images, scripts, and style sheets.\nFor example, given the `<base href=\"/my/app/\">`, the browser resolves a URL such as `some/place/foo.jpg`\ninto a server request for `my/app/some/place/foo.jpg`.\nDuring navigation, the Angular router uses the _base href_ as the base path to component, template, and module files.\n-->\n<p>이미지 파일이나 스크립트 파일, 스타일 시트는 상대 URL로 참조하는데, 상대 URL이 시작하는 위치는 HTML 문서에 <a href=\"/guide/router\"><em>&#x3C;base href=\"...\"/></em></a>로 지정합니다.\n그래서 예를 들어 <code>&#x3C;base href=\"/my/app/\"></code>라고 지정된 HTML 문서가 있고 <code>some/place/foo.jpg</code> 경로의 이미지 파일을 참조한다고 하면, 결과적으로 <code>my/app/some/place/foo.jpg</code> 경로에 요청을 보내게 됩니다.\n그리고 Angular 라우터를 사용해서 네비게이션을 할 때도 <em>base href</em> 를 참조해서 컴포넌트의 위치를 결정하며, 템플릿과 모듈 파일을 참조할 때도 이 주소를 기본으로 사용합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nSee also the [*APP_BASE_HREF*](api/common/APP_BASE_HREF \"API: APP_BASE_HREF\") alternative.\n-->\n<p><a href=\"api/common/APP_BASE_HREF\" title=\"API: APP_BASE_HREF\"><em>APP_BASE_HREF</em></a>를 사용하면 이 설정을 대체할 수 있습니다.</p>\n</div>\n<!--\nIn development, you typically start the server in the folder that holds `index.html`.\nThat's the root folder and you'd add `<base href=\"/\">` near the top of `index.html` because `/` is the root of the app.\n-->\n<p>개발 중에는 일반적으로 <code>index.html</code>이 있는 폴더를 서버로 띄웁니다.\n이 경우에는 <code>index.html</code> 파일 위쪽에 <code>&#x3C;base href=\"/\"></code>를 지정하면 애플리케이션 최상위 주소를 <code>/</code>로 연결할 수 있습니다.</p>\n<!--\nBut on the shared or production server, you might serve the app from a subfolder.\nFor example, when the URL to load the app is something like `http://www.mysite.com/my/app/`,\nthe subfolder is `my/app/` and you should add `<base href=\"/my/app/\">` to the server version of the `index.html`.\n-->\n<p>하지만 다른 앱과 함께 사용하는 서버라면 애플리케이션을 서브 폴더에 두어야 하는 경우도 생깁니다.\n그래서 애플리케이션이 시작되는 위치가 <code>http://www.mysite.com/my/app/</code>이고 이 애플리케이션이 위치하는 폴더가 <code>my/app/</code>이라면 <code>index.html</code> 파일에서 기본 주소를 <code>&#x3C;base href=\"/my/app/\"></code>으로 지정해야 합니다.</p>\n<!--\nWhen the `base` tag is mis-configured, the app fails to load and the browser console displays `404 - Not Found` errors\nfor the missing files. Look at where it _tried_ to find those files and adjust the base tag appropriately.\n-->\n<p><code>base</code> 태그가 잘못된 값으로 설정되면 애플리케이션 파일을 찾을 수 없기 때문에 애플리케이션을 실행할 수 없어서 브라우저 콘솔에 <code>404 - Not Found</code> 에러가 출력됩니다.\n이 에러가 발생하면 <code>base</code> 태그값을 바꿔보면서 정확한 위치를 지정해야 합니다.</p>\n<a id=\"differential-loading\"></a>\n<!--\n## Differential Loading\n-->\n<h2 id=\"선택적-로딩differential-loading\">선택적 로딩(Differential Loading)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/deployment#선택적-로딩differential-loading\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nWhen building web applications, you want to make sure your application is compatible with the majority of browsers.\nEven as JavaScript continues to evolve, with new features being introduced, not all browsers are updated with support for these new features at the same pace.\n\nThe code you write in development using TypeScript is compiled and bundled into ES2015, the JavaScript syntax that is compatible with most browsers.\nAll modern browsers support ES2015 and beyond, but in most cases, you still have to account for users accessing your application from a browser that doesn't.\nWhen targeting older browsers, [polyfills](guide/browser-support#polyfills) can bridge the gap by providing functionality that doesn't exist in the older versions of JavaScript supported by those browsers.\n\nTo maximize compatibility, you could ship a single bundle that includes all your compiled code, plus any polyfills that may be needed.\nUsers with modern browsers, however, shouldn't have to pay the price of increased bundle size that comes with polyfills they don't need.\nDifferential loading, which is supported by default in Angular CLI version 8 and higher, solves this problem.\n\nDifferential loading is a strategy that allows your web application to support multiple browsers, but only load the necessary code that the browser needs. When differential loading is enabled (which is the default) the CLI builds two separate bundles as part of your deployed application.\n\n* The first bundle contains modern ES2015 syntax, takes advantage of built-in support in modern browsers, ships fewer polyfills, and results in a smaller bundle size.\n\n* The second bundle contains code in the old ES5 syntax, along with all necessary polyfills. This results in a larger bundle size, but supports older browsers.\n-->\n<p>애플리케이션은 결국 더 많은 브라우저에서 정상적으로 실행되는지가 가장 중요합니다. 하지만 JavaScript 자체도 새로운 기능을 도입하면서 끊임없이 진보하기 때문에 모든 브라우저들이 JavaScript 표준에 있는 기능을 같은 수준으로 지원하지는 않습니다. 그래서 해결책으로 컴파일이라는 과정과 <a href=\"guide/browser-support#polyfills\">폴리필(polyfills)</a>이라는 개념이 등장했습니다. 이제는 개발자가 TypeScript로 작성한 코드가 컴파일 단계를 거쳐 브라우저에서 원활하게 실행되는 ES5 코드로 변환됩니다. 그리고 이 과정에서 JavaScript 문법으로 새로 추가되어 브라우저가 아직 지원하지 않는 기능은 폴리필을 활용해서 지원하기도 합니다.</p>\n<p>브라우저 호환성을 신경쓰다보면 번들 결과물의 크기가 점점 커질 수 있습니다. 최근에 나온 브라우저들은 보통 ES2015나 이후 버전을 지원하지만 그렇지 못한 브라우저를 사용하는 사용자가 있을 수 있고, 이런 사용자들을 위해 개발자가 작성한 코드 이외에 폴리필을 추가로 넣어야 하기 때문입니다. 하지만 최신 JavaScript 문법을 지원하는 브라우저를 사용하는 사용자는 이 증가분이 필요없습니다. 그래서 선택적 로딩이 등장했습니다.</p>\n<p>선택적 로딩은 Angular CLI로 애플리케이션을 빌드할 때 이 애플리케이션의 빌드 결과물을 두 벌로 생성하는 방식입니다. 첫번째 세트에는 최신 JavaScript 문법을 지원하는 코드가 들어갑니다. 이 결과물에는 폴리필이 최소한으로 들어가기 때문에 번들 결과물의 크기도 상대적으로 작습니다. 그리고 두번째 세트에는 조금 더 낮은 JavaScript 버전으로 빌드된 코드와 오래된 브라우저에서 지원하지 않는 문법을 실행하기 위한 폴리필이 모두 포함되는데, 따라서 번들 결과물의 크기는 상대적으로 좀 더 큽니다. 선택적 로딩 방식을 사용하면 애플리케이션이 동작하는 브라우저를 더 확보할 수 있으면서도, 브라우저에 꼭 필요한 코드만 로딩할 수 있습니다.</p>\n<ul>\n<li>\n<p>The first bundle contains modern ES2015 syntax, takes advantage of built-in support in modern browsers, ships fewer polyfills, and results in a smaller bundle size.</p>\n</li>\n<li>\n<p>The second bundle contains code in the old ES5 syntax, along with all necessary polyfills. This results in a larger bundle size, but supports older browsers.</p>\n</li>\n</ul>\n<!--\n### Differential builds\n-->\n<h3 id=\"선택적-빌드differential-builds\">선택적 빌드(Differential builds)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/deployment#선택적-빌드differential-builds\"><i class=\"material-icons\">link</i></a></h3>\n<p>When you deploy using the Angular CLI build process, you can choose how and when to support differential loading.\nThe <a href=\"cli/build\"><code>ng build</code> CLI command</a> queries the browser configuration and the configured build target to determine if support for legacy browsers is required, and whether the build should produce the necessary bundles used for differential loading.</p>\n<p>The following configurations determine your requirements.</p>\n<ul>\n<li>\n<p>Browsers list</p>\n<p> The <code>browserslist</code> configuration file is included in your application <a href=\"guide/file-structure#application-configuration-files\">project structure</a> and provides the minimum browsers your application supports. See the <a href=\"https://github.com/browserslist/browserslist\">Browserslist spec</a> for complete configuration options.</p>\n</li>\n<li>\n<p>TypeScript configuration</p>\n<p> In the TypeScript configuration file, <code>tsconfig.json</code>, the \"target\" option in the <code>compilerOptions</code> section determines the ECMAScript target version that the code is compiled to.\nModern browsers support ES2015 natively, while ES5 is more commonly used to support legacy browsers.</p>\n</li>\n</ul>\n<div class=\"alert is-helpful\">\n<p>   Differential loading is currently only supported when using <code>es2015</code> as a compilation target. When used with targets higher than <code>es2015</code>, the build process emits a warning.</p>\n</div>\n<p>For a development build, the output produced by <code>ng build</code> is simpler and easier to debug, allowing you to rely less on sourcemaps of compiled code.</p>\n<p>For a production build, your configuration determines which bundles are created for deployment of your application.\nWhen needed, the <code>index.html</code> file is also modified during the build process to include script tags that enable differential loading, as shown in the following example.</p>\n<code-example language=\"html\" header=\"index.html\">\n&#x3C;body>\n  &#x3C;app-root>&#x3C;/app-root>\n  &#x3C;script src=\"runtime-es2015.js\" type=\"module\">&#x3C;/script>\n  &#x3C;script src=\"runtime-es5.js\" nomodule>&#x3C;/script>\n  &#x3C;script src=\"polyfills-es2015.js\" type=\"module\">&#x3C;/script>\n  &#x3C;script src=\"polyfills-es5.js\" nomodule>&#x3C;/script>\n  &#x3C;script src=\"styles-es2015.js\" type=\"module\">&#x3C;/script>\n  &#x3C;script src=\"styles-es5.js\" nomodule>&#x3C;/script>\n  &#x3C;script src=\"vendor-es2015.js\" type=\"module\">&#x3C;/script>\n  &#x3C;script src=\"vendor-es5.js\" nomodule>&#x3C;/script>\n  &#x3C;script src=\"main-es2015.js\" type=\"module\">&#x3C;/script>\n  &#x3C;script src=\"main-es5.js\" nomodule>&#x3C;/script>\n&#x3C;/body>\n</code-example>\n<p>Each script tag has a <code>type=\"module\"</code> or <code>nomodule</code> attribute. Browsers with native support for ES modules only load the scripts with the <code>module</code> type attribute and ignore scripts with the <code>nomodule</code> attribute. Legacy browsers only load the scripts with the <code>nomodule</code> attribute, and ignore the script tags with the <code>module</code> type that load ES modules.</p>\n<div class=\"alert is-helpful\">\n<p>   Some legacy browsers still download both bundles, but only execute the appropriate scripts based on the attributes mentioned above. You can read more on the issue <a href=\"https://github.com/philipwalton/webpack-esnext-boilerplate/issues/1\">here</a>.</p>\n</div>\n<!--\n### Configuring differential loading\n-->\n<h3 id=\"선택적-로딩-활성화하기\">선택적 로딩 활성화하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/deployment#선택적-로딩-활성화하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nDifferential loading is supported by default with version 8 and later of the Angular CLI.\nFor each application project in your workspace, you can configure how builds are produced based on the `browserslist` and `tsconfig.json` configuration files in your application project.\n\nFor a newly created Angular application, legacy browsers such as IE 9-11 are ignored, and the compilation target is ES2015.\n-->\n<p>선택적 로딩 설정은 Angular CLI 8 버전부터 이미 지원하고 있습니다. 워크스페이스에 있는 애플리케이션 프로젝트를 보면 <code>browserlist</code> 파일과 <code>tsconfig.json</code> 파일이 존재하는 것을 확인할 수 있습니다.</p>\n<p>파일의 내용은 조금씩 달라질 수 있기 때문에 최신 Angular 애플리케이션에 생성된 파일을 기준으로 합시다.</p>\n<p>For a newly created Angular application, legacy browsers such as IE 9-11 are ignored, and the compilation target is ES2015.</p>\n<code-example language=\"none\" header=\"browserslist\">\n> 0.5%\nlast 2 versions\nFirefox ESR\nnot dead\nnot IE 9-11 # For IE 9-11 support, remove 'not'.\n</code-example>\n<code-example language=\"json\" header=\"tsconfig.json\">\n\n{\n  \"compileOnSave\": false,\n  \"compilerOptions\": {\n    \"baseUrl\": \"./\",\n    \"outDir\": \"./dist/out-tsc\",\n    \"sourceMap\": true,\n    \"declaration\": false,\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"node\",\n    \"emitDecoratorMetadata\": true,\n    \"experimentalDecorators\": true,\n    \"importHelpers\": true,\n    \"target\": \"es2015\",\n    \"typeRoots\": [\n      \"node_modules/@types\"\n    ],\n    \"lib\": [\n      \"es2018\",\n      \"dom\"\n    ]\n  }\n}\n\n</code-example>\n<p>The default configuration creates two builds, with differential loading enabled.</p>\n<div class=\"alert is-important\">\n<p>   To see which browsers are supported with the default configuration and determine which settings meet to your browser support requirements, see the <a href=\"https://browserl.ist/?q=%3E+0.5%25%2C+last+2+versions%2C+Firefox+ESR%2C+not+dead%2C+not+IE+9-11\">Browserslist compatibility page</a>.</p>\n</div>\n<p>The <code>browserslist</code> configuration allows you to ignore browsers without ES2015 support. In this case, a single build is produced.</p>\n<p>If your <code>browserslist</code> configuration includes support for any legacy browsers, the build target in the TypeScript configuration determines whether the build will support differential loading.</p>\n<a id=\"configuration-table\"></a>\n<!--\n| browserslist | ES target | Build result |\n| -------- | -------- | -------- |\n| ES5 support disabled | es2015  | Single build, ES5 not required |\n| ES5 support enabled  | es5     | Single build w/conditional polyfills for ES5 only |\n| ES5 support enabled  | es2015  | Differential loading (two builds w/conditional polyfills) |\n-->\n<table>\n<thead>\n<tr>\n<th>Browserslist 지원대상</th>\n<th>ES 문법</th>\n<th>빌드 결과물</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>지원하지 않음</td>\n<td>es5</td>\n<td>1벌</td>\n</tr>\n<tr>\n<td>지원</td>\n<td>es5</td>\n<td>1벌 + 폴리필</td>\n</tr>\n<tr>\n<td>지원하지 않음</td>\n<td>es2015</td>\n<td>1벌</td>\n</tr>\n<tr>\n<td>지원</td>\n<td>es2015</td>\n<td>선택적 빌드 (2벌 + 폴리필)</td>\n</tr>\n</tbody>\n</table>\n<!--\n### Opting out of differential loading\n-->\n<h3 id=\"선택적-로딩-비활성화하기\">선택적 로딩 비활성화하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/deployment#선택적-로딩-비활성화하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nDifferential loading can be explicitly disabled if it causes unexpected issues, or if you need to target ES5 specifically for legacy browser support.\n\nTo explicitly disable differential loading and create an ES5 build:\n\n- Enable the `dead` or `IE` browsers in the `browserslist` configuration file by removing the `not` keyword in front of them.\n- To create a single ES5 build, set the target in the `compilerOptions` to `es5`.\n-->\n<p>예상하지 못한 이슈가 있거나 오래된 브라우저를 확실하게 지원하기 위해 ES5 문법으로 빌드한다면 선택적 로딩을 명시적으로 비활성화할 수 있습니다.</p>\n<p>이렇게 설정하면 됩니다:</p>\n<ul>\n<li><code>browserlist</code> 파일에서 <code>dead</code>나 <code>IE</code> 앞에 설정된 <code>not</code> 키워드를 제거합니다.</li>\n<li><code>compilerOptions</code> 중 <code><a href=\"api/router/RouterLinkWithHref#target\" class=\"code-anchor\">target</a></code> 옵션을 <code>es5</code>로 지정합니다.</li>\n</ul>\n<a id=\"test-and-serve\"></a>\n<h2 id=\"local-development-in-older-browsers\">Local development in older browsers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/deployment#local-development-in-older-browsers\"><i class=\"material-icons\">link</i></a></h2>\n<p>In Angular CLI version 8 and higher, differential loading is enabled by default for the <code>ng build</code> command.\nThe <code>ng serve</code>, <code>ng test</code>, and <code>ng e2e</code> commands, however, generate a single ES2015 build which cannot run in older browsers that don't support the modules, such as IE 11.</p>\n<p>If you want to run ES5 code during development, you could disable differential loading completely.\nTo maintain the benefits of differential loading, however, a better option is to define multiple configurations for <code>ng serve</code>, <code>ng e2e</code>, and <code>ng test</code>.</p>\n<a id=\"differential-serve\"></a>\n<h3 id=\"configuring-serve-for-es5\">Configuring serve for ES5<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/deployment#configuring-serve-for-es5\"><i class=\"material-icons\">link</i></a></h3>\n<p>To do this for <code>ng serve</code>, create a new file, <code>tsconfig-es5.app.json</code> next to <code>tsconfig.app.json</code> with the following content.</p>\n<code-example language=\"json\">\n\n{\n \"extends\": \"./tsconfig.app.json\",\n \"compilerOptions\": {\n     \"target\": \"es5\"\n  }\n}\n\n</code-example>\n<p>In <code>angular.json</code> add two new configuration sections under the <code>build</code> and <code>serve</code> targets to point to the new TypeScript configuration.</p>\n<code-example language=\"json\">\n\n\"build\": {\n  \"builder\": \"@angular-devkit/build-angular:browser\",\n  \"options\": {\n      ...\n  },\n  \"configurations\": {\n    \"production\": {\n        ...\n    },\n    \"es5\": {\n      \"tsConfig\": \"./tsconfig-es5.app.json\"\n    }\n  }\n},\n\"serve\": {\n  \"builder\": \"@angular-devkit/build-angular:dev-server\",\n  \"options\": {\n      ...\n  },\n  \"configurations\": {\n    \"production\": {\n     ...\n    },\n    \"es5\": {\n      \"browserTarget\": \"&#x3C;app-name>:build:es5\"\n    }\n  }\n},\n\n</code-example>\n<p>You can then run the <code>ng serve</code> command with this configuration. Make sure to replace <code>&#x3C;app-name></code> (in <code>\"&#x3C;app-name>:build:es5\"</code>) with the actual name of the app, as it appears under <code>projects</code> in <code>angular.json</code>. For example, if your app name is <code>myAngularApp</code> the config will become <code>\"browserTarget\": \"myAngularApp:build:es5\"</code>.</p>\n<code-example language=\"none\" class=\"code-shell\">\n\nng serve --configuration es5\n\n</code-example>\n<a id=\"differential-test\"></a>\n<h3 id=\"configuring-the-test-command\">Configuring the test command<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/deployment#configuring-the-test-command\"><i class=\"material-icons\">link</i></a></h3>\n<p>Create a new file, <code>tsconfig-es5.spec.json</code> next to <code>tsconfig.spec.json</code> with the following content.</p>\n<code-example language=\"json\">\n\n{\n \"extends\": \"./tsconfig.spec.json\",\n \"compilerOptions\": {\n     \"target\": \"es5\"\n  }\n}\n\n</code-example>\n<code-example language=\"json\">\n\n\"test\": {\n  \"builder\": \"@angular-devkit/build-angular:karma\",\n  \"options\": {\n      ...\n  },\n  \"configurations\": {\n    \"es5\": {\n      \"tsConfig\": \"./tsconfig-es5.spec.json\"\n    }\n  }\n},\n\n</code-example>\n<p>You can then run the tests with this configuration</p>\n<code-example language=\"none\" class=\"code-shell\">\n\nng test --configuration es5\n\n</code-example>\n<h3 id=\"configuring-the-e2e-command\">Configuring the e2e command<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/deployment#configuring-the-e2e-command\"><i class=\"material-icons\">link</i></a></h3>\n<p>Create an <a href=\"guide/deployment#configuring-serve-for-es5\">ES5 serve configuration</a> as explained above, and configuration an ES5 configuration for the E2E target.</p>\n<code-example language=\"json\">\n\n\"e2e\": {\n  \"builder\": \"@angular-devkit/build-angular:protractor\",\n  \"options\": {\n      ...\n  },\n  \"configurations\": {\n\t  \"production\": {\n\t\t  ...\n\t  },\n    \"es5\": {\n      \"devServerTarget\": \"&#x3C;app-name>:serve:es5\"\n    }\n  }\n},\n\n</code-example>\n<p>You can then run the <code>ng e2e</code> command with this configuration. Make sure to replace <code>&#x3C;app-name></code> (in <code>\"&#x3C;app-name>:serve:es5\"</code>) with the actual name of the app, as it appears under <code>projects</code> in <code>angular.json</code>. For example, if your app name is <code>myAngularApp</code> the config will become <code>\"devServerTarget\": \"myAngularApp:serve:es5\"</code>.</p>\n<code-example language=\"none\" class=\"code-shell\">\n\nng e2e --configuration es5\n\n</code-example>\n\n</div>\n\n<!-- links to this doc:\n - guide/architecture-next-steps\n - guide/browser-support\n - guide/glossary\n - guide/npm-packages\n - guide/typescript-configuration\n - guide/upgrade-setup\n - guide/visual-studio-2015\n - start/deployment\n-->\n<!-- links from this doc:\n - /guide/router\n - api/common/APP_BASE_HREF\n - api/core/NgModule\n - api/core/enableProdMode\n - api/router/RouterLinkWithHref#target\n - api/router/Routes\n - cli/build\n - guide/aot-compiler\n - guide/browser-support#polyfills\n - guide/deployment#angular-앱이-동작해야-하는-경우는-모두-indexhtml로-보내야-합니다\n - guide/deployment#automatic-deployment-with-the-cli\n - guide/deployment#base-태그\n - guide/deployment#configuring-serve-for-es5\n - guide/deployment#configuring-the-e2e-command\n - guide/deployment#configuring-the-test-command\n - guide/deployment#enable-prod-mode\n - guide/deployment#fallback\n - guide/deployment#github-페이지에-배포하기\n - guide/deployment#local-development-in-older-browsers\n - guide/deployment#간단한-배포-옵션\n - guide/deployment#다른-서버로-요청-보내기-cors\n - guide/deployment#로컬-환경에서-빌드하고-실행해보기\n - guide/deployment#리모트-서버에-배포하기\n - guide/deployment#배포\n - guide/deployment#번들파일-분석하기\n - guide/deployment#서버-설정\n - guide/deployment#선택적-로딩-비활성화하기\n - guide/deployment#선택적-로딩-활성화하기\n - guide/deployment#선택적-로딩differential-loading\n - guide/deployment#선택적-빌드differential-builds\n - guide/deployment#성능-측정하기\n - guide/deployment#운영-모드-활성화하기\n - guide/deployment#운영-배포-최적화\n - guide/deployment#지연-로딩\n - guide/deployment#폴백fallback-설정-예\n - guide/file-structure#application-configuration-files\n - guide/router#preloading\n - http://enable-cors.org/server.html\n - http://httpd.apache.org/docs/current/mod/mod_rewrite.html\n - http://nginx.org/\n - http://sinatrarb.com/\n - http://stackoverflow.com/a/26152011/2116927\n - https://angular.io/guide/cli-builder\n - https://azure.microsoft.com/en-us/\n - https://browserl.ist/?q=%3E+0.5%25%2C+last+2+versions%2C+Firefox+ESR%2C+not+dead%2C+not+IE+9-11\n - https://developers.google.com/web/tools/chrome-devtools/network-performance/understanding-resource-timing\n - https://en.wikipedia.org/wiki/Cross-origin_resource_sharing\n - https://firebase.google.com/docs/hosting\n - https://firebase.google.com/docs/hosting/\n - https://firebase.google.com/docs/hosting/url-redirects-rewrites#section-rewrites\n - https://github.com/angular-buch/angular-cli-ghpages\n - https://github.com/angular/angular-cli/tree/master/packages/%40ngtools/webpack\n - https://github.com/angular/angular/edit/master/aio/content/guide/deployment.md?message=docs%3A%20describe%20your%20change...\n - https://github.com/browserslist/browserslist\n - https://github.com/danvk/source-map-explorer/blob/master/README.md\n - https://github.com/isaacs/github/issues/408\n - https://github.com/johnpapa/lite-server\n - https://github.com/join\n - https://github.com/philipwalton/webpack-esnext-boilerplate/issues/1\n - https://help.github.com/articles/configuring-a-publishing-source-for-github-pages/#publishing-your-github-pages-site-from-a-docs-folder-on-your-master-branch\n - https://help.github.com/articles/create-a-repo/\n - https://help.github.com/articles/what-is-github-pages/\n - https://httpd.apache.org/\n - https://ngmilk.rocks/2015/03/09/angularjs-html5-mode-or-pretty-urls-on-apache-using-htaccess/\n - https://npmjs.com/\n - https://npmjs.org/package/@angular/fire\n - https://npmjs.org/package/@azure/ng-deploy\n - https://npmjs.org/package/@netlify-builder/deploy\n - https://npmjs.org/package/@zeit/ng-deploy\n - https://npmjs.org/package/angular-cli-ghpages\n - https://npmjs.org/package/ngx-deploy-npm\n - https://pages.github.com/\n - https://webpack.js.org/guides/development/#webpack-dev-server\n - https://www.bennadel.com/blog/3181-including-node-modules-and-vendors-folders-in-your-github-pages-site.htm\n - https://www.iis.net/\n - https://www.netlify.com/\n - https://www.nginx.com/resources/wiki/start/topics/tutorials/config_pitfalls/#front-controller-pattern-web-apps\n - https://www.ruby-lang.org/\n - https://www.webpagetest.org/\n - https://zeit.co/now\n-->"
}