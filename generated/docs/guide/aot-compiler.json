{
  "id": "guide/aot-compiler",
  "title": "Ahead-of-Time (AOT) 컴파일러",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/aot-compiler.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# The Ahead-of-Time (AOT) Compiler\n-->\n<h1 id=\"ahead-of-time-aot-컴파일러\">Ahead-of-Time (AOT) 컴파일러<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#ahead-of-time-aot-컴파일러\"><i class=\"material-icons\">link</i></a></h1>\n<p>An Angular application consists mainly of components and their HTML templates. Because the components and templates provided by Angular cannot be understood by the browser directly, Angular applications require a compilation process before they can run in a browser.</p>\n<p>The Angular Ahead-of-Time (AOT) compiler converts your Angular HTML and TypeScript code into efficient JavaScript code during the build phase <em>before</em> the browser downloads and runs that code. Compiling your application during the build process provides a faster rendering in the browser.</p>\n<p>This guide explains how to specify metadata and apply available compiler options to compile your applications efficiently using the AOT compiler.</p>\n<div class=\"alert is-helpful\" &#x3C;p=\"\">  <a href=\"https://www.youtube.com/watch?v=kW9cJsvcsGo\">Watch compiler author Tobias Bosch explain the Angular compiler</a> at AngularConnect 2016.<p></p>\n</div>\n<a id=\"overview\"></a>\n<!--\n## Angular compilation\n-->\n<h2 id=\"angular의-컴파일\">Angular의 컴파일<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#angular의-컴파일\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAngular offers two ways to compile your application:\n-->\n<p>Angular는 두 종류의 컴파일 방식을 제공합니다:</p>\n<!--\n1. **_Just-in-Time_ (JIT)**, which compiles your app in the browser at runtime.\n1. **_Ahead-of-Time_ (AOT)**, which compiles your app at build time.\n-->\n<ol>\n<li><strong><em>Just-in-Time</em> (JIT)</strong>: 브라우저에서 애플리케이션을 실행하면서 코드를 직접 컴파일하는 방식입니다.</li>\n<li><strong><em>Ahead-of-Time</em> (AOT)</strong>: 브라우저에 애플리케이션 코드를 보내기 전에 미리 컴파일하는 방식입니다.</li>\n</ol>\n<p>JIT compilation is the default when you run the <a href=\"cli/build\"><code>ng build</code></a> (build only) or <a href=\"cli/serve\"><code>ng serve</code></a>  (build and serve locally) CLI commands: </p>\n<code-example language=\"sh\" class=\"code-shell\">\n  ng build\n  ng serve\n</code-example>\n<a id=\"compile\"></a>\n<p>For AOT compilation, include the <code>--aot</code> option with the <code>ng build</code> or <code>ng serve</code> command:</p>\n<code-example language=\"sh\" class=\"code-shell\">\n  ng build --aot\n  ng serve --aot\n</code-example>\n<div class=\"alert is-helpful\">\n<p>The <code>ng build</code> command with the <code>--prod</code> meta-flag (<code>ng build --prod</code>) compiles with AOT by default.</p>\n<p>See the <a href=\"cli\">CLI command reference</a> and <a href=\"guide/build\">Building and serving Angular apps</a> for more information.</p>\n</div>\n<a id=\"why-aot\"></a>\n<!--\n## Why compile with AOT?\n-->\n<h2 id=\"왜-aot-컴파일-하나요\">왜 AOT 컴파일 하나요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#왜-aot-컴파일-하나요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\n*Faster rendering*\n\nWith AOT, the browser downloads a pre-compiled version of the application.\nThe browser loads executable code so it can render the application immediately, without waiting to compile the app first.\n-->\n<p><em>렌더링 시간 단축</em></p>\n<p>AOT 방식으로 컴파일하면 브라우저가 미리 컴파일된 애플리케이션 코드를 내려받습니다.\n그런데 이 코드는 브라우저가 직접 실행할 수 있도록 변환된 코드이기 때문에, 브라우저는 코드를 컴파일하는 과정없이 바로 실행할 수 있습니다.</p>\n<!--\n*Fewer asynchronous requests*\n\nThe compiler _inlines_ external HTML templates and CSS style sheets within the application JavaScript,\neliminating separate ajax requests for those source files.\n-->\n<!--\n*Smaller Angular framework download size*\n\nThere's no need to download the Angular compiler if the app is already compiled.\nThe compiler is roughly half of Angular itself, so omitting it dramatically reduces the application payload.\n-->\n<p><em>내려받는 Angular 프레임워크 크기 감소</em></p>\n<p>AOT 컴파일 방식을 사용하면 클라이언트가 애플리케이션 코드를 내려받기 전에 미리 애플리케이션을 빌드하기 때문에 클라이언트에서 Angular 컴파일러를 내려받지 않아도 됩니다.\nAngular 컴파일러의 크기는 Angular 프레임워크 전체 크기의 반 정도를 차지합니다. AOT 컴파일 방식을 사용하면 이 용량을 내려받지 않아도 됩니다.</p>\n<!--\n*Detect template errors earlier*\n\nThe AOT compiler detects and reports template binding errors during the build step\nbefore users can see them.\n-->\n<p><em>템플릿 에러를 미리 검증</em></p>\n<p>AOT 컴파일러를 사용하면 실행 단계가 아니라 빌드 단계에서 템플릿 바인딩 에러를 검사합니다.</p>\n<!--\n*Better security*\n\nAOT compiles HTML templates and components into JavaScript files long before they are served to the client.\nWith no templates to read and no risky client-side HTML or JavaScript evaluation,\nthere are fewer opportunities for injection attacks.\n-->\n<p><em>더 나은 보안</em></p>\n<p>AOT 컴파일 방식을 사용하면 HTML 템플릿과 컴포넌트 코드가 모두 JavaScript로 변환되어 클라이언트에 제공됩니다.\n그래서 클라이언트에 존재하는 HTML 문서나 JavaScript가 없기 떄문에, 인젝션 공격의 기회를 상당수 차단할 수 있습니다.</p>\n<h2 id=\"controlling-app-compilation\">Controlling app compilation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#controlling-app-compilation\"><i class=\"material-icons\">link</i></a></h2>\n<p>When you use the Angular AOT compiler, you can control your app compilation in two ways:</p>\n<ul>\n<li>\n<p>By providing template compiler options in the <code>tsconfig.json</code> file.</p>\n<p>    For more information, see <a href=\"guide/aot-compiler#compiler-options\">Angular template compiler options</a>.</p>\n</li>\n<li>\n<p>By <a href=\"guide/aot-compiler#metadata-aot\">specifying Angular metadata</a>.</p>\n</li>\n</ul>\n<a id=\"metadata-aot\"></a>\n<h2 id=\"specifying-angular-metadata\">Specifying Angular metadata<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#specifying-angular-metadata\"><i class=\"material-icons\">link</i></a></h2>\n<p>Angular metadata tells Angular how to construct instances of your application classes and interact with them at runtime.\nThe Angular <strong>AOT compiler</strong> extracts <strong>metadata</strong> to interpret the parts of the application that Angular is supposed to manage.</p>\n<p>You can specify the metadata with <strong>decorators</strong> such as <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> and <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> or implicitly in the constructor declarations of these decorated classes.</p>\n<!--\nIn the following example, the `@Component()` metadata object and the class constructor tell Angular how to create and display an instance of `TypicalComponent`.\n-->\n<p>아래 코드에서 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code>에 지정하는 메타데이터 객체와 클래스 생성자는 Angular가 <code>TypicalComponent</code>의 인스턴스를 어떻게 생성하고 처리해야 할지 지정하는 용도로 사용됩니다.</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-typical',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: '&#x3C;div>A typical component for {{data.name}}&#x3C;/div>'\n)}\nexport class TypicalComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() data: TypicalData;\n  constructor(private someService: SomeService) { ... }\n}\n</code-example>\n<!--\nThe Angular compiler extracts the metadata _once_ and generates a _factory_ for `TypicalComponent`.\nWhen it needs to create a `TypicalComponent` instance, Angular calls the factory, which produces a new visual element, bound to a new instance of the component class with its injected dependency.\n-->\n<p>이 코드를 Angular 컴파일러가 처리하면 메타데이터를 추출해서 <code>TypicalComponent</code>에 대한 <em>팩토리</em> 를 만듭니다.\n그러면 <code>TypicalComponent</code>의 인스턴스가 필요한 시점에 Angular가 팩토리를 실행해서 인스턴스를 생성하며, 이렇게 생성된 인스턴스를 의존성으로 주입합니다.</p>\n<!--\n## Metadata restrictions\n-->\n<h2 id=\"메타데이터의-제약사항\">메타데이터의 제약사항<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#메타데이터의-제약사항\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nYou write metadata in a _subset_ of TypeScript that must conform to the following general constraints:\n-->\n<p>메타데이터는 TypeScript의 <em>하위 집합(subset)</em> 이며 보통 다음과 같은 제약사항이 있습니다:</p>\n<!--\n1. Limit [expression syntax](#expression-syntax) to the supported subset of JavaScript.\n2. Only reference exported symbols after [code folding](#folding).\n3. Only call [functions supported](#supported-functions) by the compiler.\n4. Decorated and data-bound class members must be public.\n-->\n<ol>\n<li>JavaScript 문법 중 <a href=\"guide/aot-compiler#expression-syntax\">표현식(expression syntax)</a>은 일부만 사용할 수 있습니다.</li>\n<li><a href=\"guide/aot-compiler#folding\">코드를 폴딩</a>한 이후에 존재하는 심볼만 참조할 수 있습니다.</li>\n<li>컴파일러가 지원하는 <a href=\"guide/aot-compiler#supported-functions\">일부 함수</a>만 사용할 수 있습니다.</li>\n<li>데코레이터가 사용되거나 데이터 바인딩되는 클래스 멤버는 public으로 지정되어야 합니다.</li>\n</ol>\n<!--\nThe next sections elaborate on these points.\n-->\n<p>이 내용에 대해 자세하게 알아봅시다.</p>\n<!--\n## How AOT works\n-->\n<h2 id=\"aot가-동작하는-방식\">AOT가 동작하는 방식<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#aot가-동작하는-방식\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nIt helps to think of the AOT compiler as having two phases: a code analysis phase in which it simply records a representation of the source; and a code generation phase in which the compiler's `StaticReflector` handles the interpretation as well as places restrictions on what it interprets.\n-->\n<p>AOT 컴파일러의 동작은 두 단계로 나누어 보는 것이 이해하기 편합니다. 첫 번째 단계는 코드를 분석하는 단계이며, 두 번째 단계는 Angular 컴파일러 내부의 <code>StaticReflector</code>를 사용해서 코드를 생성하는 단계입니다.</p>\n<!--\n## Phase 1: analysis\n-->\n<h2 id=\"1단계-분석\">1단계: 분석<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#1단계-분석\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe TypeScript compiler does some of the analytic work of the first phase. It emits the `.d.ts` _type definition files_ with type information that the AOT compiler needs to generate application code.\n\nAt the same time, the AOT **_collector_** analyzes the metadata recorded in the Angular decorators and outputs metadata information in **`.metadata.json`** files, one per `.d.ts` file.\n\nYou can think of `.metadata.json` as a diagram of the overall structure of a decorator's metadata, represented as an [abstract syntax tree (AST)](https://en.wikipedia.org/wiki/Abstract_syntax_tree).\n-->\n<p>첫번째 단계에서는 TypeScript 컴파일러가 분석과 관련된 작업을 합니다. TypeScript 컴파일러가 코드를 컴파일하고 나면 <em>타입 정의 파일</em> 인 <code>.d.ts</code> 파일이 생성되며, 이 정보는 이후에 AOT 컴파일러가 애플리케이션 코드를 생성할 때 사용합니다.</p>\n<p>그리고 이 때 AOT <strong><em>콜렉터(collector)</em></strong>가 각 <code>.d.ts</code> 파일에 있는 Angular 데코레이터의 메타데이터를 분석하고 분석한 내용을 <strong><code>.metadata.json</code></strong> 파일로 생성합니다.</p>\n<p><code>.metadata.json</code> 파일은 데코레이터의 메타데이터를 나타내는 청사진이라고도 볼 수 있습니다. <a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\">추상 구문 트리(abstract syntax tree, AST)</a>를 참고하세요.</p>\n<div class=\"alert is-helpful\">\n<!--\nAngular's [schema.ts](https://github.com/angular/angular/blob/master/packages/compiler-cli/src/metadata/schema.ts)\ndescribes the JSON format as a collection of TypeScript interfaces.\n-->\n<p>Angular가 생성하는 <a href=\"https://github.com/angular/angular/blob/master/packages/compiler-cli/src/metadata/schema.ts\">schema.ts</a> 파일은 TypeScript 인터페이스를 JSON 형식으로 기술하는 파일입니다.</p>\n</div>\n<a id=\"expression-syntax\"></a>\n<!--\n### Expression syntax\n-->\n<h3 id=\"표현식-expression-syntax\">표현식 (Expression syntax)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#표현식-expression-syntax\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe _collector_ only understands a subset of JavaScript.\nDefine metadata objects with the following limited syntax:\n-->\n<p>Angular <em>콜렉터(collector)</em> 는 JavaScript의 하위집합이며 JavaScript 문법 중 일부만 처리할 수 있습니다.\n그래서 메타데이터에는 다음과 같은 문법만 허용됩니다:</p>\n<style>\n  td, th {vertical-align: top}\n</style>\n<table>\n  <tbody><tr>\n    <th>Syntax</th>\n    <th>Example</th>\n  </tr>\n  <tr>\n    <td>Literal object </td>\n    <td><code>{cherry: true, apple: true, mincemeat: false}</code></td>\n  </tr>\n  <tr>\n    <td>Literal array  </td>\n    <td><code>['cherries', 'flour', 'sugar']</code></td>\n  </tr>\n  <tr>\n    <td>Spread in literal array</td>\n    <td><code>['apples', 'flour', ...the_rest]</code></td>\n  </tr>\n   <tr>\n    <td>Calls</td>\n    <td><code>bake(ingredients)</code></td>\n  </tr>\n   <tr>\n    <td>New</td>\n    <td><code>new Oven()</code></td>\n  </tr>\n   <tr>\n    <td>Property access</td>\n    <td><code>pie.slice</code></td>\n  </tr>\n   <tr>\n    <td>Array index</td>\n    <td><code>ingredients[0]</code></td>\n  </tr>\n   <tr>\n    <td>Identity reference</td>\n    <td><code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code></td>\n  </tr>\n   <tr>\n    <td>A template string</td>\n    <td><code>`pie is ${multiplier} times better than cake`</code></td>\n   </tr><tr>\n    <td>Literal string</td>\n    <td><code>pi</code></td>\n  </tr>\n   <tr>\n    <td>Literal number</td>\n    <td><code>3.14153265</code></td>\n  </tr>\n   <tr>\n    <td>Literal boolean</td>\n    <td><code>true</code></td>\n  </tr>\n   <tr>\n    <td>Literal null</td>\n    <td><code>null</code></td>\n  </tr>\n   <tr>\n    <td>Supported prefix operator </td>\n    <td><code>!cake</code></td>\n  </tr>\n   <tr>\n    <td>Supported binary operator </td>\n    <td><code><a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>+b</code></td>\n  </tr>\n   <tr>\n    <td>Conditional operator</td>\n    <td><code><a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> ? b : c</code></td>\n  </tr>\n   <tr>\n    <td>Parentheses</td>\n    <td><code>(<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>+b)</code></td>\n  </tr>\n</tbody></table>\n<!--\nIf an expression uses unsupported syntax, the _collector_ writes an error node to the `.metadata.json` file. The compiler later reports the error if it needs that\npiece of metadata to generate the application code.\n-->\n<p>만약 이 목록에 해당되지 않은 표현식이 사용되면 <em>콜렉터</em> 가 처리할 수 없기 때문에 에러기 발생하며 <code>.metadata.json</code> 파일도 정상적으로 생성되지 않습니다. 결국 애플리케이션 코드를 빌드할 때 에러가 발생합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\n If you want `ngc` to report syntax errors immediately rather than produce a `.metadata.json` file with errors, set the `strictMetadataEmit` option in `tsconfig`.\n-->\n<p><code>.metadata.json</code> 파일에 에러를 출력하는 대신 <code>ngc</code>에서 직접 문법 에러가 발생하게 하려면 <code>tsconfig</code> 옵션에 <code>strictMetadataEmit</code> 옵션을 다음과 같이 설정하세요.</p>\n<code-example>\n  \"angularCompilerOptions\": {\n   ...\n   \"strictMetadataEmit\" : true\n }\n</code-example>\n<!--\nAngular libraries have this option to ensure that all Angular `.metadata.json` files are clean and it is a best practice to do the same when building your own libraries.\n-->\n<p>Angular가 제공하는 라이브러리는 모두 이 옵션을 사용하기 때문에 Angular에서 제공하는 모든 <code>.metadata.json</code> 파일은 에러 없이 깔끔한 상태입니다. 커스텀 라이브러리를 만드는 경우에도 활용해 보세요.</p>\n</div>\n<a id=\"function-expression\"></a>\n<a id=\"arrow-functions\"></a>\n<!--\n### No arrow functions\n-->\n<h3 id=\"화살표-함수는-사용할-수-없습니다\">화살표 함수는 사용할 수 없습니다.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#화살표-함수는-사용할-수-없습니다\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe AOT compiler does not support [function expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function)\nand [arrow functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions), also called _lambda_ functions.\n-->\n<p>AOT 컴파일러는 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function\">함수 표현식</a>과 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">화살표 함수 (람다 함수)</a>를 지원하지 않습니다.</p>\n<!--\nConsider the following component decorator:\n-->\n<p>다음과 같은 컴포넌트 데코레이터가 있다고 합시다:</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  ...\n  providers: [{provide: server, useFactory: () => new Server()}]\n})\n</code-example>\n<!--\nThe AOT _collector_ does not support the arrow function, `() => new Server()`, in a metadata expression.\nIt generates an error node in place of the function.\n-->\n<p>이 코드에는 AOT <em>콜렉터</em> 가 지원하지 않는 화살표 함수가 <code>() => new Server()</code>와 같이 사용되었습니다.\n그러면 이 코드는 제대로 변환되지 못하고 에러 노드로 처리됩니다.</p>\n<!--\nWhen the compiler later interprets this node, it reports an error that invites you to turn the arrow function into an _exported function_.\n-->\n<p>그리고 이후에 컴파일러가 이 노드를 처리할 때 에러가 발생하기 때문에, 이 화살표 함수는 <em>export가 사용된 함수</em> 로 변경되어야 합니다.</p>\n<!--\nYou can fix the error by converting to this:\n-->\n<p>이 에러는 다음과 같이 수정하면 해결할 수 있습니다:</p>\n<code-example language=\"typescript\">\nexport function serverFactory() {\n  return new Server();\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  ...\n  providers: [{provide: server, useFactory: serverFactory}]\n})\n</code-example>\n<!--\nBeginning in version 5, the compiler automatically performs this rewriting while emitting the `.js` file.\n-->\n<p>Angular v5 버전 초기에는 화살표 함수를 변환하는 과정을 컴파일러가 직접 처리했었습니다.</p>\n<a id=\"function-calls\"></a>\n<!--\n### Limited function calls\n-->\n<h3 id=\"함수-실행-제한\">함수 실행 제한<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#함수-실행-제한\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe _collector_ can represent a function call or object creation with `new` as long as the syntax is valid. The _collector_ only cares about proper syntax.\n\nBut beware. The compiler may later refuse to generate a call to a _particular_ function or creation of a _particular_ object.\nThe compiler only supports calls to a small set of functions and will use `new` for only a few designated classes. These functions and classes are in a table of [below](#supported-functions).\n-->\n<p><em>콜렉터</em> 는 함수를 실행하거나 <code>new</code> 키워드로 객체를 생성할 수 있습니다. 하지만 <em>콜렉터</em> 를 사용할 때는 문법이 맞는지 주의해야 합니다.</p>\n<p>하지만 또 주의할 점이 있습니다. 콜렉터가 JavaScript 구문을 처리한 이후라도 AOT 컴파일러가 이 코드를 다시 처리하면서 <em>특정</em> 함수나 <em>특정</em> 객체가 생성되는 것은 처리하지 않을 수도 있습니다.\nAOT 컴파일러는 콜렉터와 다르게 일부 함수를 실행하거나 일부 클래스만 <code>new</code> 키워드로 생성할 수 있습니다. 컴파일러가 지원하는 목록은 <a href=\"guide/aot-compiler#supported-functions\">여기</a>를 참고하세요.</p>\n<a id=\"folding\"></a>\n<!--\n### Folding\n-->\n<h3 id=\"폴딩-folding\">폴딩 (Folding)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#폴딩-folding\"><i class=\"material-icons\">link</i></a></h3>\n<a id=\"exported-symbols\"></a>\n<!--\nThe compiler can only resolve references to **_exported_** symbols.\nFortunately, the _collector_ enables limited use of non-exported symbols through _folding_.\n\nThe _collector_ may be able to evaluate an expression during collection and record the result in the `.metadata.json` instead of the original expression.\n\nFor example, the _collector_ can evaluate the expression `1 + 2 + 3 + 4` and replace it with the result, `10`.\n\nThis process is called _folding_. An expression that can be reduced in this manner is _foldable_.\n-->\n<p>AOT 컴파일러는 <strong><em>export</em></strong> 키워드가 사용된 심볼만 참조할 수 있습니다.\n하지만 다행히도 <em>콜렉터</em> 는 <em>폴딩</em> 이라는 것을 통해 <code>export</code> 키워드가 사용되지 않은 심볼도 제한적으로 참조할 수 있습니다.</p>\n<p><em>콜렉터</em> 는 콜렉션 단계에서 표현식을 평가하고 그 결과를 <code>.metadata.json</code> 파일에 기록하는데, 이 때 원래 코드를 약간 변형해서 기록합니다.</p>\n<p>예를 들어 <em>콜렉터</em> 가 <code>1 + 2 + 3 + 4</code> 라는 표현식을 평가하고 나면 <code>.metadata.json</code> 파일에는 이 내용을 <code>10</code>으로 기록합니다.</p>\n<p>이 과정을 <em>폴딩(folding)</em> 이라고 합니다. 그리고 이 과정이 적용될 수 있는 코드를 <em>폴딩할 수 있는(foldable)</em> 코드라고 합니다.</p>\n<a id=\"var-declaration\"></a>\n<!--\nThe collector can evaluate references to\nmodule-local `const` declarations and initialized `var` and `let` declarations, effectively removing them from the `.metadata.json` file.\n\nConsider the following component definition:\n-->\n<p>콜렉터는 모듈 파일에 로컬 변수로 선언된 <code>const</code>, <code>var</code>, <code>let</code> 변수들을 참조할 수 있으며, 코드가 처리되어 <code>.metadata.json</code> 파일에 기록될 때는 이 코드가 모두 폴딩되면서 제거됩니다.</p>\n<p>다음과 같이 정의된 컴포넌트가 있다고 합시다:</p>\n<code-example language=\"typescript\">\nconst <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a> = '&#x3C;div>{{hero.name}}&#x3C;/div>';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n</code-example>\n<!--\nThe compiler could not refer to the `template` constant because it isn't exported.\n\nBut the _collector_ can _fold_ the `template` constant into the metadata definition by inlining its contents.\nThe effect is the same as if you had written:\n-->\n<p>컴파일러는 이 코드에 선언된 <code><a href=\"api/core/Component#template\" class=\"code-anchor\">template</a></code> 변수를 참조할 수 없습니다. 왜냐하면 이 변수에 <code>export</code> 키워드가 사용되지 않았기 때문입니다.</p>\n<p>하지만 <em>콜렉터</em> 는 <code><a href=\"api/core/Component#template\" class=\"code-anchor\">template</a></code> 변수를 <em>폴딩</em> 해서 컴포넌트 메타데이터 안으로 집어넣을 수 있습니다.\n결과적으로 이 코드는 아래 코드와 같습니다:</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: '&#x3C;div>{{hero.name}}&#x3C;/div>'\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n</code-example>\n<!--\nThere is no longer a reference to `template` and, therefore, nothing to trouble the compiler when it later interprets the _collector's_ output in `.metadata.json`.\n\nYou can take this example a step further by including the `template` constant in another expression:\n-->\n<p>이 코드에는 <code><a href=\"api/core/Component#template\" class=\"code-anchor\">template</a></code>이라는 변수가 없으며, <em>콜렉터</em> 가 생성한 <code>.metadata.json</code> 파일을 사용하는 컴파일러도 정상적으로 실행됩니다.</p>\n<p>그리고 이와 비슷한 방식으로 다음과 같은 코드도 정상적으로 처리됩니다:</p>\n<code-example language=\"typescript\">\nconst <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a> = '&#x3C;div>{{hero.name}}&#x3C;/div>';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a> + '&#x3C;div>{{hero.title}}&#x3C;/div>'\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n</code-example>\n<!--\nThe _collector_ reduces this expression to its equivalent _folded_ string:\n-->\n<p>이 코드의 템플릿을 <em>콜렉터</em> 가 처리하고 나면 다음과 같이 <em>폴딩 된</em> 문자열로 변환됩니다:</p>\n<p><code>'&#x3C;div>{{hero.name}}&#x3C;/div>&#x3C;div>{{hero.title}}&#x3C;/div>'</code>.</p>\n<!--\n#### Foldable syntax\n-->\n<h4 id=\"폴딩할-수-있는-문법\">폴딩할 수 있는 문법<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#폴딩할-수-있는-문법\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe following table describes which expressions the _collector_ can and cannot fold:\n-->\n<p><em>콜렉터</em> 가 폴딩할 수 있는 문법에는 어떤 것들이 있는지 확인해 보세요:</p>\n<style>\n  td, th {vertical-align: top}\n</style>\n<table>\n  <tbody><tr>\n    <th>Syntax</th>\n    <th>Foldable</th>\n  </tr>\n  <tr>\n    <td>Literal object </td>\n    <td>Yes</td>\n  </tr>\n  <tr>\n    <td>Literal array  </td>\n    <td>Yes</td>\n  </tr>\n  <tr>\n    <td>Spread in literal array</td>\n    <td>no</td>\n  </tr>\n   <tr>\n    <td>Calls</td>\n    <td>no</td>\n  </tr>\n   <tr>\n    <td>New</td>\n    <td>no</td>\n  </tr>\n   <tr>\n    <td>Property access</td>\n    <td>yes, if target is foldable</td>\n  </tr>\n   <tr>\n    <td>Array index</td>\n    <td> yes, if target and index are foldable</td>\n  </tr>\n   <tr>\n    <td>Identity reference</td>\n    <td>yes, if it is a reference to a local</td>\n  </tr>\n   <tr>\n    <td>A template with no substitutions</td>\n    <td>yes</td>\n  </tr>\n   <tr>\n    <td>A template with substitutions</td>\n    <td>yes, if the substitutions are foldable</td>\n  </tr>\n   <tr>\n    <td>Literal string</td>\n    <td>yes</td>\n  </tr>\n   <tr>\n    <td>Literal number</td>\n    <td>yes</td>\n  </tr>\n   <tr>\n    <td>Literal boolean</td>\n    <td>yes</td>\n  </tr>\n   <tr>\n    <td>Literal null</td>\n    <td>yes</td>\n  </tr>\n   <tr>\n    <td>Supported prefix operator </td>\n    <td>yes, if operand is foldable</td>\n  </tr>\n   <tr>\n    <td>Supported binary operator </td>\n    <td>yes, if both left and right are foldable</td>\n  </tr>\n   <tr>\n    <td>Conditional operator</td>\n    <td>yes, if condition is foldable </td>\n  </tr>\n   <tr>\n    <td>Parentheses</td>\n    <td>yes, if the expression is foldable</td>\n  </tr>\n</tbody></table>\n<!--\nIf an expression is not foldable, the collector writes it to `.metadata.json` as an [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree) for the compiler to resolve.\n-->\n<p>표현식이 폴딩될 수 없는 경우에는 콜렉터가 이 코드를 <a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\">AST</a> 형식으로 <code>.metadata.json</code>에 생성하며, 이 결과물은 이후에 AOT 컴파일러가 처리합니다.</p>\n<!--\n## Phase 2: code generation\n-->\n<h2 id=\"2단계-코드-생성\">2단계: 코드 생성<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#2단계-코드-생성\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe _collector_ makes no attempt to understand the metadata that it collects and outputs to `.metadata.json`. It represents the metadata as best it can and records errors when it detects a metadata syntax violation.\n-->\n<p><em>콜렉터</em> 는 메타데이터를 이해하는 것이 아니라 메타데이터를 찾아서 <code>.metadata.json</code>에 모으는 역할만 합니다. 그리고 이 과정에서 메타데이터에 사용된 문법에 오류가 있는지도 검사합니다.</p>\n<!--\nIt's the compiler's job to interpret the `.metadata.json` in the code generation phase.\n-->\n<p><code>.mdtadata.json</code> 파일을 해석해서 코드를 생성하는 것은 컴파일러의 역할입니다.</p>\n<!--\nThe compiler understands all syntax forms that the _collector_ supports, but it may reject _syntactically_ correct metadata if the _semantics_ violate compiler rules.\n\nThe compiler can only reference _exported symbols_.\n\nDecorated component class members must be public. You cannot make an `@Input()` property private or internal.\n\nData bound properties must also be public.\n-->\n<p>컴파일러는 <em>콜렉터</em> 가 처리할 수 있었던 문법을 모두 처리할 수 있지만, 콜렉터와 다르게 메타데이터가 <em>문법적으로</em> 컴파일 규칙에 어긋나면 에러를 발생시킵니다.</p>\n<p>컴파일러는 <em>export 키워드가 사용된 심볼</em> 만 참조할 수 있습니다.</p>\n<p>컴포넌트 클래스 멤버에 데코레이터가 사용되면 이 멤버는 반드시 public이어야 합니다. private 프로퍼티에는 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 데코레이터를 사용할 수 없습니다.</p>\n<p>데이터 바인딩으로 연결된 프로퍼티도 반드시 public이어야 합니다.</p>\n<!--\n```typescript\n// BAD CODE - title is private\n@Component({\n  selector: 'app-root',\n  template: '<h1>{{title}}</h1>'\n})\nexport class AppComponent {\n  private title = 'My App'; // Bad\n}\n```\n-->\n<code-example language=\"typescript\">\n// 잘못된 코드 - title이 private으로 지정되었습니다.\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: '&#x3C;h1>{{title}}&#x3C;/h1>'\n})\nexport class AppComponent {\n  private title = 'My App'; // 오류\n}\n</code-example>\n<a id=\"supported-functions\"></a>\n<!--\nMost importantly, the compiler only generates code to create instances of certain classes, support certain decorators, and call certain functions from the following lists.\n-->\n<p>컴파일러가 생성할 수 있는 클래스는 일부 목록으로 제한되며, 지원하는 데코레이터도 제한되어 있고, 실행할 수 있는 함수도 제한되어 있습니다. 다음 목록을 참고하세요.</p>\n<!--\n### New instances\n-->\n<h3 id=\"인스턴스-생성\">인스턴스 생성<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#인스턴스-생성\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe compiler only allows metadata that create instances of the class `InjectionToken` from `@angular/core`.\n-->\n<p>AOT 컴파일러는 <code>@angular/core</code>의 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code>으로 등록된 클래스의 인스턴스만 생성할 수 있습니다.</p>\n<!--\n### Annotations/Decorators\n-->\n<h3 id=\"어노테이션데코레이터\">어노테이션/데코레이터<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#어노테이션데코레이터\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe compiler only supports metadata for these Angular decorators.\n-->\n<p>컴파일러는 다음 목록에 해당하는 Angular 데코레이터만 지원합니다.</p>\n<style>\n  td, th {vertical-align: top}\n</style>\n<table>\n  <tbody><tr>\n    <th>Decorator</th>\n    <th>Module</th>\n  </tr>\n    <tr>\n    <td><code><a href=\"api/core/Attribute\" class=\"code-anchor\">Attribute</a></code></td>\n    <td><code>@angular/core</code></td>\n  </tr>\n  <tr>\n    <td><code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code></td>\n    <td><code>@angular/core</code></td>\n  </tr>\n  <tr>\n    <td><code><a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code></td>\n    <td><code>@angular/core</code></td>\n  </tr>\n  <tr>\n    <td><code><a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code></td>\n    <td><code>@angular/core</code></td>\n  </tr>\n  <tr>\n    <td><code><a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code></td>\n    <td><code>@angular/core</code></td>\n  </tr>\n  <tr>\n    <td><code><a href=\"api/core/Host\" class=\"code-anchor\">Host</a></code></td>\n    <td><code>@angular/core</code></td>\n  </tr>\n  <tr>\n    <td><code><a href=\"api/core/HostBinding\" class=\"code-anchor\">HostBinding</a></code></td>\n    <td><code>@angular/core</code></td>\n  </tr>\n  <tr>\n    <td><code>HostListner</code></td>\n    <td><code>@angular/core</code></td>\n  </tr>\n  <tr>\n    <td><code><a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code></td>\n    <td><code>@angular/core</code></td>\n  </tr>\n  <tr>\n    <td><code><a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code></td>\n    <td><code>@angular/core</code></td>\n  </tr>\n  <tr>\n    <td><code><a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code></td>\n    <td><code>@angular/core</code></td>\n  </tr>\n  <tr>\n    <td><code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code></td>\n    <td><code>@angular/core</code></td>\n  </tr>\n  <tr>\n    <td><code><a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code></td>\n    <td><code>@angular/core</code></td>\n  </tr>\n  <tr>\n    <td><code><a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code></td>\n    <td><code>@angular/core</code></td>\n  </tr>\n  <tr>\n    <td><code><a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a></code></td>\n    <td><code>@angular/core</code></td>\n  </tr>\n  <tr>\n    <td><code><a href=\"api/core/Self\" class=\"code-anchor\">Self</a></code></td>\n    <td><code>@angular/core</code></td>\n  </tr>\n  <tr>\n    <td><code><a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code></td>\n    <td><code>@angular/core</code></td>\n  </tr>\n  <tr>\n    <td><code><a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code></td>\n    <td><code>@angular/core</code></td>\n  </tr>\n  </tbody></table>\n<!--\n### Macro-functions and macro-static methods\n-->\n<h3 id=\"매크로-함수와-정적-매크로-메소드\">매크로 함수와 정적 매크로 메소드<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#매크로-함수와-정적-매크로-메소드\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe compiler also supports _macros_ in the form of functions or static\nmethods that return an expression.\n\nFor example, consider the following function:\n-->\n<p>AOT 컴파일러는 함수 형태로 된 <em>매크로</em> 와 표현식을 반환하는 정적 메소드도 지원합니다.</p>\n<p>다음과 같은 함수가 정의되어 있다고 합시다:</p>\n<code-example language=\"typescript\">\nexport function wrapInArray&#x3C;T>(value: T): T[] {\n  return [value];\n}\n</code-example>\n<!--\nYou can call the `wrapInArray` in a metadata definition because it returns the value of an expression that conforms to the compiler's restrictive JavaScript subset.\n-->\n<p>그러면 이 <code>wrapInArray</code> 함수를 메타데이터 정의에 사용할 수 있습니다. 왜냐하면 이 함수는 컴파일러가 처리할 수 있는 형태의 결과물을 반환하기 때문입니다.</p>\n<!--\nYou might use  `wrapInArray()` like this:\n-->\n<p>그래서 이 함수는 이렇게 사용할 수 있습니다:</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: wrapInArray(TypicalComponent)\n})\nexport class TypicalModule {}\n</code-example>\n<!--\nThe compiler treats this usage as if you had written:\n-->\n<p>이 코드는 다음 코드와 동일하게 처리됩니다.</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  <a href=\"api/core/NgModule#declarations\" class=\"code-anchor\">declarations</a>: [TypicalComponent]\n})\nexport class TypicalModule {}\n</code-example>\n<!--\nThe collector is simplistic in its determination of what qualifies as a macro\nfunction; it can only contain a single `return` statement.\n-->\n<p>콜렉터가 처리할 수 있는 매크로 함수의 기준은 단순합니다. 함수가 <code>return</code> 키워드로 무언가를 반환하기만 하면 됩니다.</p>\n<!--\nThe Angular [`RouterModule`](api/router/RouterModule) exports two macro static methods, `forRoot` and `forChild`, to help declare root and child routes.\nReview the [source code](https://github.com/angular/angular/blob/master/packages/router/src/router_module.ts#L139 \"RouterModule.forRoot source code\")\nfor these methods to see how macros can simplify configuration of complex [NgModules](guide/ngmodules).\n-->\n<p>Angular <a href=\"api/router/RouterModule\"><code>RouterModule</code></a>가 제공하는 메소드 중 애플리케이션의 최상위 라우팅을 정의하는 <code>forRoot</code>와 자식 라우팅을 정의하는 <code>forChild</code>가 정적 매크로 메소드입니다.\n<a href=\"guide/ngmodules\">NgModules</a> 설정이 복잡할 때 매크로 함수를 활용하면 이 설정을 좀 더 간단하게 작성할 수 있습니다. <a href=\"https://github.com/angular/angular/blob/master/packages/router/src/router_module.ts#L139\" title=\"RouterModule.forRoot source code\">소스 코드</a>를 보면서 내용을 확인해 보세요.</p>\n<a id=\"metadata-rewriting\"></a>\n<!--\n### Metadata rewriting\n-->\n<h3 id=\"메타데이터-재구축\">메타데이터 재구축<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#메타데이터-재구축\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe compiler treats object literals containing the fields `useClass`, `useValue`, `useFactory`, and `data` specially. The compiler converts the expression initializing one of these fields into an exported variable, which replaces the expression. This process of rewriting these expressions removes all the restrictions on what can be in them because\nthe compiler doesn't need to know the expression's value&mdash;it just needs to be able to generate a reference to the value.\n-->\n<p>AOT 컴파일러는 메타데이터에 사용된 <code>useClass</code>, <code>useValue</code>, <code>useFactory</code>에 사용된 객체 리터럴과 <code>data</code> 프로퍼티를 처리해서 각각 <code>export</code>로 지정된 변수로 변환합니다. 컴파일러는 이 필드에 사용된 표현식 자체를 알 필요는 없습니다. 단순하게 결과만 참조하면 됩니다.</p>\n<!--\nYou might write something like:\n-->\n<p>다음과 같은 코드가 있다고 합시다:</p>\n<code-example language=\"typescript\">\nclass TypicalServer {\n\n}\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  providers: [{provide: SERVER, useFactory: () => TypicalServer}]\n})\nexport class TypicalModule {}\n</code-example>\n<!--\nWithout rewriting, this would be invalid because lambdas are not supported and `TypicalServer` is not exported.\n\nTo allow this, the compiler automatically rewrites this to something like:\n-->\n<p>메타데이터 재구축 과정이 없다면 이 코드는 처리되지 않습니다. 왜나하면 AOT 컴파일러는 람다 함수를 지원하지 않으며, <code>TypicalServer</code> 클래스도 <code>export</code>로 지정되지 않았기 때문입니다.</p>\n<p>하지만 이 코드는 메타데이터 재구축 과정을 거치면서 다음과 같이 변환됩니다:</p>\n<code-example language=\"typescript\">\nclass TypicalServer {\n\n}\n\nexport const ɵ0 = () => new TypicalServer();\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  providers: [{provide: SERVER, useFactory: ɵ0}]\n})\nexport class TypicalModule {}\n</code-example>\n<!--\nThis allows the compiler to generate a reference to `ɵ0` in the\nfactory without having to know what the value of `ɵ0` contains.\n-->\n<p>그러면 AOT 컴파일러가 클래스를 직접 참조하지 않고 <code>ɵ0</code> 팩토리를 참조합니다.</p>\n<!--\nThe compiler does the rewriting during the emit of the `.js` file. This doesn't rewrite the `.d.ts` file, however, so TypeScript doesn't recognize it as being an export. Thus, it does not pollute the ES module's exported API.\n-->\n<p>메타데이터 재구축 과정은 컴파일러가 <code>.js</code> 파일을 생성할 때 이루어집니다. 그리고 이 과정은 <code>.d.ts</code> 파일을 수정하는 것이 아니기 때문에 TypeScript에서는 이 과정에 생성된 <code>export</code> 변수를 인식할 수 없습니다. 결과적으로 모듈이 제공하던 API도 영향을 받지 않습니다.</p>\n<h2 id=\"metadata-errors\">Metadata errors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#metadata-errors\"><i class=\"material-icons\">link</i></a></h2>\n<p>The following are metadata errors you may encounter, with explanations and suggested corrections.</p>\n<p><a href=\"guide/aot-compiler#expression-form-not-supported\">Expression form not supported</a><br>\n<a href=\"guide/aot-compiler#reference-to-a-local-symbol\">Reference to a local (non-exported) symbol</a><br>\n<a href=\"guide/aot-compiler#only-initialized-variables\">Only initialized variables and constants</a><br>\n<a href=\"guide/aot-compiler#reference-to-a-non-exported-class\">Reference to a non-exported class</a><br>\n<a href=\"guide/aot-compiler#reference-to-a-non-exported-function\">Reference to a non-exported function</a><br>\n<a href=\"guide/aot-compiler#function-calls-not-supported\">Function calls are not supported</a><br>\n<a href=\"guide/aot-compiler#destructured-variable-not-supported\">Destructured variable or constant not supported</a><br>\n<a href=\"guide/aot-compiler#could-not-resolve-type\">Could not resolve type</a><br>\n<a href=\"guide/aot-compiler#name-expected\">Name expected</a><br>\n<a href=\"guide/aot-compiler#unsupported-enum-member-name\">Unsupported enum member name</a><br>\n<a href=\"guide/aot-compiler#tagged-template-expressions-not-supported\">Tagged template expressions are not supported</a><br>\n<a href=\"guide/aot-compiler#symbol-reference-expected\">Symbol reference expected</a><br></p>\n<hr>\n<h3 class=\"no-toc\" id=\"expression-form-not-supported\">Expression form not supported<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#expression-form-not-supported\"><i class=\"material-icons\">link</i></a></h3>\n<p>The compiler encountered an expression it didn't understand while evaluating Angular metadata.</p>\n<p>Language features outside of the compiler's <a href=\"guide/aot-compiler#expression-syntax\">restricted expression syntax</a>\ncan produce this error, as seen in the following example:</p>\n<code-example>\n// ERROR\nexport class Fooish { ... }\n...\nconst prop = typeof Fooish; // typeof is not valid in metadata\n  ...\n  // bracket notation is not valid in metadata\n  { provide: 'token', useValue: { [prop]: 'value' } };\n  ...\n</code-example>\n<p>You can use <code>typeof</code> and bracket notation in normal application code.\nYou just can't use those features within expressions that define Angular metadata.</p>\n<p>Avoid this error by sticking to the compiler's <a href=\"guide/aot-compiler#expression-syntax\">restricted expression syntax</a>\nwhen writing Angular metadata\nand be wary of new or unusual TypeScript features.</p>\n<hr>\n<a id=\"reference-to-a-local-symbol\"></a>\n<h3 class=\"no-toc\" id=\"reference-to-a-local-non-exported-symbol\">Reference to a local (non-exported) symbol<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#reference-to-a-local-non-exported-symbol\"><i class=\"material-icons\">link</i></a></h3>\n<div class=\"alert is-helpful\">\n<p><em>Reference to a local (non-exported) symbol 'symbol name'. Consider exporting the symbol.</em></p>\n</div>\n<p>The compiler encountered a referenced to a locally defined symbol that either wasn't exported or wasn't initialized.</p>\n<p>Here's a <code>provider</code> example of the problem.</p>\n<code-example>\n// ERROR\nlet foo: number; // neither exported nor initialized\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: ... ,\n  providers: [\n    { provide: Foo, useValue: foo }\n  ]\n})\nexport class MyComponent {}\n</code-example>\n<p>The compiler generates the component factory, which includes the <code>useValue</code> provider code, in a separate module. <em>That</em> factory module can't reach back to <em>this</em> source module to access the local (non-exported) <code>foo</code> variable.</p>\n<p>You could fix the problem by initializing <code>foo</code>.</p>\n<code-example>\nlet foo = 42; // initialized\n</code-example>\n<p>The compiler will <a href=\"guide/aot-compiler#folding\">fold</a> the expression into the provider as if you had written this.</p>\n<code-example>\n  providers: [\n    { provide: Foo, useValue: 42 }\n  ]\n</code-example>\n<p>Alternatively, you can fix it by exporting <code>foo</code> with the expectation that <code>foo</code> will be assigned at runtime when you actually know its value.</p>\n<code-example>\n// CORRECTED\nexport let foo: number; // exported\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: ... ,\n  providers: [\n    { provide: Foo, useValue: foo }\n  ]\n})\nexport class MyComponent {}\n</code-example>\n<p>Adding <code>export</code> often works for variables referenced in metadata such as <code>providers</code> and <code>animations</code> because the compiler can generate <em>references</em> to the exported variables in these expressions. It doesn't need the <em>values</em> of those variables.</p>\n<p>Adding <code>export</code> doesn't work when the compiler needs the <em>actual value</em>\nin order to generate code.\nFor example, it doesn't work for the <code><a href=\"api/core/Component#template\" class=\"code-anchor\">template</a></code> property.</p>\n<code-example>\n// ERROR\nexport let someTemplate: string; // exported but not initialized\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: someTemplate\n})\nexport class MyComponent {}\n</code-example>\n<p>The compiler needs the value of the <code><a href=\"api/core/Component#template\" class=\"code-anchor\">template</a></code> property <em>right now</em> to generate the component factory.\nThe variable reference alone is insufficient.\nPrefixing the declaration with <code>export</code> merely produces a new error, \"<a href=\"guide/aot-compiler#only-initialized-variables\"><code>Only initialized variables and constants can be referenced</code></a>\".</p>\n<hr>\n<a id=\"only-initialized-variables\"></a>\n<h3 class=\"no-toc\" id=\"only-initialized-variables-and-constants\">Only initialized variables and constants<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#only-initialized-variables-and-constants\"><i class=\"material-icons\">link</i></a></h3>\n<div class=\"alert is-helpful\">\n<p><em>Only initialized variables and constants can be referenced because the value of this variable is needed by the template compiler.</em></p>\n</div>\n<p>The compiler found a reference to an exported variable or static field that wasn't initialized.\nIt needs the value of that variable to generate code.</p>\n<p>The following example tries to set the component's <code><a href=\"api/core/Component#template\" class=\"code-anchor\">template</a></code> property to the value of\nthe exported <code>someTemplate</code> variable which is declared but <em>unassigned</em>.</p>\n<code-example>\n// ERROR\nexport let someTemplate: string;\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: someTemplate\n})\nexport class MyComponent {}\n</code-example>\n<p>You'd also get this error if you imported <code>someTemplate</code> from some other module and neglected to initialize it there.</p>\n<code-example>\n// ERROR - not initialized there either\nimport { someTemplate } from './<a href=\"api/router/Router#config\" class=\"code-anchor\">config</a>';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: someTemplate\n})\nexport class MyComponent {}\n</code-example>\n<p>The compiler cannot wait until runtime to get the template information.\nIt must statically derive the value of the <code>someTemplate</code> variable from the source code\nso that it can generate the component factory, which includes\ninstructions for building the element based on the template.</p>\n<p>To correct this error, provide the initial value of the variable in an initializer clause <em>on the same line</em>.</p>\n<code-example>\n// CORRECTED\nexport let someTemplate = '&#x3C;h1>Greetings from Angular&#x3C;/h1>';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: someTemplate\n})\nexport class MyComponent {}\n</code-example>\n<hr>\n<h3 class=\"no-toc\" id=\"reference-to-a-non-exported-class\">Reference to a non-exported class<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#reference-to-a-non-exported-class\"><i class=\"material-icons\">link</i></a></h3>\n<div class=\"alert is-helpful\">\n<p><em>Reference to a non-exported class <class name=\"\">. Consider exporting the class.</class></em></p>\n</div>\n<p>Metadata referenced a class that wasn't exported.</p>\n<p>For example, you may have defined a class and used it as an injection token in a providers array\nbut neglected to export that class.</p>\n<code-example>\n// ERROR\nabstract class MyStrategy { }\n\n  ...\n  providers: [\n    { provide: MyStrategy, useValue: ... }\n  ]\n  ...\n</code-example>\n<p>Angular generates a class factory in a separate module and that\nfactory <a href=\"guide/aot-compiler#exported-symbols\">can only access exported classes</a>.\nTo correct this error, export the referenced class.</p>\n<code-example>\n// CORRECTED\nexport abstract class MyStrategy { }\n\n  ...\n  providers: [\n    { provide: MyStrategy, useValue: ... }\n  ]\n  ...\n</code-example>\n<hr>\n<h3 class=\"no-toc\" id=\"reference-to-a-non-exported-function\">Reference to a non-exported function<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#reference-to-a-non-exported-function\"><i class=\"material-icons\">link</i></a></h3>\n<p>Metadata referenced a function that wasn't exported.</p>\n<p>For example, you may have set a providers <code>useFactory</code> property to a locally defined function that you neglected to export.</p>\n<code-example>\n// ERROR\nfunction myStrategy() { ... }\n\n  ...\n  providers: [\n    { provide: MyStrategy, useFactory: myStrategy }\n  ]\n  ...\n</code-example>\n<p>Angular generates a class factory in a separate module and that\nfactory <a href=\"guide/aot-compiler#exported-symbols\">can only access exported functions</a>.\nTo correct this error, export the function.</p>\n<code-example>\n// CORRECTED\nexport function myStrategy() { ... }\n\n  ...\n  providers: [\n    { provide: MyStrategy, useFactory: myStrategy }\n  ]\n  ...\n</code-example>\n<hr>\n<a id=\"function-calls-not-supported\"></a>\n<h3 class=\"no-toc\" id=\"function-calls-are-not-supported\">Function calls are not supported<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#function-calls-are-not-supported\"><i class=\"material-icons\">link</i></a></h3>\n<div class=\"alert is-helpful\">\n<p><em>Function calls are not supported. Consider replacing the function or lambda with a reference to an exported function.</em></p>\n</div>\n<p>The compiler does not currently support <a href=\"guide/aot-compiler#function-expression\">function expressions or lambda functions</a>.\nFor example, you cannot set a provider's <code>useFactory</code> to an anonymous function or arrow function like this.</p>\n<code-example>\n// ERROR\n  ...\n  providers: [\n    { provide: MyStrategy, useFactory: function() { ... } },\n    { provide: OtherStrategy, useFactory: () => { ... } }\n  ]\n  ...\n</code-example>\n<p>You also get this error if you call a function or method in a provider's <code>useValue</code>.</p>\n<code-example>\n// ERROR\nimport { calculateValue } from './utilities';\n\n  ...\n  providers: [\n    { provide: SomeValue, useValue: calculateValue() }\n  ]\n  ...\n</code-example>\n<p>To correct this error, export a function from the module and refer to the function in a <code>useFactory</code> provider instead.</p>\n<code-example linenums=\"false\">\n// CORRECTED\nimport { calculateValue } from './utilities';\n\nexport function myStrategy() { ... }\nexport function otherStrategy() { ... }\nexport function someValueFactory() {\n  return calculateValue();\n}\n  ...\n  providers: [\n    { provide: MyStrategy, useFactory: myStrategy },\n    { provide: OtherStrategy, useFactory: otherStrategy },\n    { provide: SomeValue, useFactory: someValueFactory }\n  ]\n  ...\n</code-example>\n<hr>\n<a id=\"destructured-variable-not-supported\"></a>\n<h3 class=\"no-toc\" id=\"destructured-variable-or-constant-not-supported\">Destructured variable or constant not supported<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#destructured-variable-or-constant-not-supported\"><i class=\"material-icons\">link</i></a></h3>\n<div class=\"alert is-helpful\">\n<p><em>Referencing an exported destructured variable or constant is not supported by the template compiler. Consider simplifying this to avoid destructuring.</em></p>\n</div>\n<p>The compiler does not support references to variables assigned by <a href=\"https://www.typescriptlang.org/docs/handbook/variable-declarations.html#destructuring\">destructuring</a>.</p>\n<p>For example, you cannot write something like this:</p>\n<code-example linenums=\"false\">\n// ERROR\nimport { configuration } from './configuration';\n\n// destructured assignment to foo and bar\nconst {foo, bar} = configuration;\n  ...\n  providers: [\n    {provide: Foo, useValue: foo},\n    {provide: Bar, useValue: bar},\n  ]\n  ...\n</code-example>\n<p>To correct this error, refer to non-destructured values.</p>\n<code-example linenums=\"false\">\n// CORRECTED\nimport { configuration } from './configuration';\n  ...\n  providers: [\n    {provide: Foo, useValue: configuration.foo},\n    {provide: Bar, useValue: configuration.bar},\n  ]\n  ...\n</code-example>\n<hr>\n<h3 class=\"no-toc\" id=\"could-not-resolve-type\">Could not resolve type<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#could-not-resolve-type\"><i class=\"material-icons\">link</i></a></h3>\n<p>The compiler encountered a type and can't determine which module exports that type.</p>\n<p>This can happen if you refer to an ambient type.\nFor example, the <code>Window</code> type is an ambient type declared in the global <code>.d.ts</code> file.</p>\n<p>You'll get an error if you reference it in the component constructor,\nwhich the compiler must statically analyze.</p>\n<code-example>\n// ERROR\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({ })\nexport class MyComponent {\n  constructor (private win: Window) { ... }\n}\n</code-example>\n<p>TypeScript understands ambient types so you don't import them.\nThe Angular compiler does not understand a type that you neglect to export or import.</p>\n<p>In this case, the compiler doesn't understand how to inject something with the <code>Window</code> token.</p>\n<p>Do not refer to ambient types in metadata expressions.</p>\n<p>If you must inject an instance of an ambient type,\nyou can finesse the problem in four steps:</p>\n<ol>\n<li>Create an injection token for an instance of the ambient type.</li>\n<li>Create a factory function that returns that instance.</li>\n<li>Add a <code>useFactory</code> provider with that factory function.</li>\n<li>Use <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code> to inject the instance.</li>\n</ol>\n<p>Here's an illustrative example.</p>\n<code-example linenums=\"false\">\n// CORRECTED\nimport { <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a> } from '@angular/core';\n\nexport const WINDOW = new <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a>('Window');\nexport function _window() { return window; }\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  ...\n  providers: [\n    { provide: WINDOW, useFactory: _window }\n  ]\n})\nexport class MyComponent {\n  constructor (@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(WINDOW) private win: Window) { ... }\n}\n</code-example>\n<p>The <code>Window</code> type in the constructor is no longer a problem for the compiler because it\nuses the <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(WINDOW)</code> to generate the injection code.</p>\n<p>Angular does something similar with the <code><a href=\"api/common/DOCUMENT\" class=\"code-anchor\">DOCUMENT</a></code> token so you can inject the browser's <code><a href=\"api/platform-server/PlatformConfig#document\" class=\"code-anchor\">document</a></code> object (or an abstraction of it, depending upon the platform in which the application runs).</p>\n<code-example linenums=\"false\">\nimport { <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a> }   from '@angular/core';\nimport { <a href=\"api/common/DOCUMENT\" class=\"code-anchor\">DOCUMENT</a> } from '@angular/platform-browser';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({ ... })\nexport class MyComponent {\n  constructor (@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(<a href=\"api/common/DOCUMENT\" class=\"code-anchor\">DOCUMENT</a>) private doc: Document) { ... }\n}\n</code-example>\n<hr>\n<h3 class=\"no-toc\" id=\"name-expected\">Name expected<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#name-expected\"><i class=\"material-icons\">link</i></a></h3>\n<p>The compiler expected a name in an expression it was evaluating.\nThis can happen if you use a number as a property name as in the following example.</p>\n<code-example>\n// ERROR\nprovider: [{ provide: Foo, useValue: { 0: 'test' } }]\n</code-example>\n<p>Change the name of the property to something non-numeric.</p>\n<code-example>\n// CORRECTED\nprovider: [{ provide: Foo, useValue: { '0': 'test' } }]\n</code-example>\n<hr>\n<h3 class=\"no-toc\" id=\"unsupported-enum-member-name\">Unsupported enum member name<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#unsupported-enum-member-name\"><i class=\"material-icons\">link</i></a></h3>\n<p>Angular couldn't determine the value of the <a href=\"https://www.typescriptlang.org/docs/handbook/enums.html\">enum member</a>\nthat you referenced in metadata.</p>\n<p>The compiler can understand simple enum values but not complex values such as those derived from computed properties.</p>\n<code-example linenums=\"false\">\n// ERROR\nenum Colors {\n  Red = 1,\n  White,\n  Blue = \"Blue\".length // computed\n}\n\n  ...\n  providers: [\n    { provide: BaseColor,   useValue: Colors.White } // ok\n    { provide: DangerColor, useValue: Colors.Red }   // ok\n    { provide: StrongColor, useValue: Colors.Blue }  // bad\n  ]\n  ...\n</code-example>\n<p>Avoid referring to enums with complicated initializers or computed properties.</p>\n<hr>\n<a id=\"tagged-template-expressions-not-supported\"></a>\n<h3 class=\"no-toc\" id=\"tagged-template-expressions-are-not-supported\">Tagged template expressions are not supported<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#tagged-template-expressions-are-not-supported\"><i class=\"material-icons\">link</i></a></h3>\n<div class=\"alert is-helpful\">\n<p><em>Tagged template expressions are not supported in metadata.</em></p>\n</div>\n<p>The compiler encountered a JavaScript ES2015 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals\">tagged template expression</a> such as,</p>\n<code-example>\n// ERROR\nconst expression = 'funky';\nconst raw = String.raw`A tagged <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a> ${expression} string`;\n ...\n <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: '&#x3C;div>' + raw + '&#x3C;/div>'\n ...\n</code-example>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/raw\"><code>String.raw()</code></a>\nis a <em>tag function</em> native to JavaScript ES2015.</p>\n<p>The AOT compiler does not support tagged template expressions; avoid them in metadata expressions.</p>\n<hr>\n<h3 class=\"no-toc\" id=\"symbol-reference-expected\">Symbol reference expected<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#symbol-reference-expected\"><i class=\"material-icons\">link</i></a></h3>\n<p>The compiler expected a reference to a symbol at the location specified in the error message.</p>\n<p>This error can occur if you use an expression in the <code>extends</code> clause of a class.</p>\n<!--\n\nChuck: After reviewing your PR comment I'm still at a loss. See [comment there](https://github.com/angular/angular/pull/17712#discussion_r132025495).\n\n-->\n<a id=\"binding-expression-validation\"></a>\n<h2 id=\"phase-3-binding-expression-validation\">Phase 3: binding expression validation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#phase-3-binding-expression-validation\"><i class=\"material-icons\">link</i></a></h2>\n<p>  In the validation phase, the Angular template compiler uses the TypeScript compiler to validate the\nbinding expressions in templates. Enable this phase explicitly by adding the compiler\noption <code>\"fullTemplateTypeCheck\"</code> in the <code>\"angularCompilerOptions\"</code> of the project's <code>tsconfig.json</code> (see\n<a href=\"guide/aot-compiler#compiler-options\">Angular Compiler Options</a>).</p>\n<p>  Template validation produces error messages when a type error is detected in a template binding\nexpression, similar to how type errors are reported by the TypeScript compiler against code in a <code>.ts</code>\nfile.</p>\n<p>  For example, consider the following component:</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: '{{person.addresss.street}}'\n})\nclass MyComponent {\n  person?: Person;\n}\n</code-example>\n<p>  This will produce the following error:</p>\n<code-example>\nmy.component.ts.MyComponent.html(1,1): : Property 'addresss' does not exist on type 'Person'. Did you mean 'address'?\n</code-example>\n<p>  The file name reported in the error message, <code>my.component.ts.MyComponent.html</code>, is a synthetic file\ngenerated by the template compiler that holds contents of the <code>MyComponent</code> class template.\nCompiler never writes this file to disk. The line and column numbers are relative to the template string\nin the <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> annotation of the class, <code>MyComponent</code> in this case. If a component uses\n<code>templateUrl</code> instead of <code><a href=\"api/core/Component#template\" class=\"code-anchor\">template</a></code>, the errors are reported in the HTML file referenced by the\n<code>templateUrl</code> instead of a synthetic file.</p>\n<p>  The error location is the beginning of the text node that contains the interpolation expression with\nthe error. If the error is in an attribute binding such as <code>[value]=\"person.address.street\"</code>, the error\nlocation is the location of the attribute that contains the error.</p>\n<p>  The validation uses the TypeScript type checker and the options supplied to the TypeScript compiler to control\nhow detailed the type validation is. For example, if the <code>strictTypeChecks</code> is specified, the error  <code>my.component.ts.MyComponent.html(1,1): : Object is possibly 'undefined'</code> is reported as well as the above error message.</p>\n<h3 id=\"type-narrowing\">Type narrowing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#type-narrowing\"><i class=\"material-icons\">link</i></a></h3>\n<p>  The expression used in an <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> directive is used to narrow type unions in the Angular\ntemplate compiler, the same way the <code>if</code> expression does in TypeScript. For example, to avoid\n<code>Object is possibly 'undefined'</code> error in the template above, modify it to only emit the\ninterpolation if the value of <code>person</code> is initialized as shown below:</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: '&#x3C;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"person\"> {{person.addresss.street}} &#x3C;/span>'\n})\nclass MyComponent {\n  person?: Person;\n}\n</code-example>\n<p>  Using <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> allows the TypeScript compiler to infer that the <code>person</code> used in the\nbinding expression will never be <code>undefined</code>.</p>\n<h4 id=\"custom-ngif-like-directives\">Custom <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> like directives<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#custom-ngif-like-directives\"><i class=\"material-icons\">link</i></a></h4>\n<p>  Directives that behave like <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> can declare that they want the same treatment by including\na static member marker that is a signal to the template compiler to treat them\nlike <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>. This static member for <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> is:</p>\n<code-example language=\"typescript\">\n  public <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> ngIfUseIfTypeGuard: void;\n</code-example>\n<p>  This declares that the input property <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> of the <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> directive should be treated as a\nguard to the use of its template, implying that the template will only be instantiated if\nthe <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> input property is true.</p>\n<h3 id=\"non-null-type-assertion-operator\">Non-null type assertion operator<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#non-null-type-assertion-operator\"><i class=\"material-icons\">link</i></a></h3>\n<p>  Use the <a href=\"guide/template-syntax#non-null-assertion-operator\">non-null type assertion operator</a>\nto suppress the <code>Object is possibly 'undefined'</code> error when it is inconvenient to use\n<code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> or when some constraint in the component ensures that the expression is always\nnon-null when the binding expression is interpolated.</p>\n<p>  In the following example, the <code>person</code> and <code>address</code> properties are always set together,\nimplying that <code>address</code> is always non-null if <code>person</code> is non-null. There is no convenient\nway to describe this constraint to TypeScript and the template compiler, but the error\nis suppressed in the example by using <code>address!.street</code>.</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: '&#x3C;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"person\"> {{person.name}} lives on {{address!.street}} &#x3C;/span>'\n})\nclass MyComponent {\n  person?: Person;\n  address?: Address;\n\n  setData(person: Person, address: Address) {\n    this.person = person;\n    this.address = address;\n  }\n}\n</code-example>\n<p>  The non-null assertion operator should be used sparingly as refactoring of the component\nmight break this constraint.</p>\n<p>  In this example it is recommended to include the checking of <code>address</code>\nin the <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>as shown below:</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: '&#x3C;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"person &#x26;&#x26; address\"> {{person.name}} lives on {{address.street}} &#x3C;/span>'\n})\nclass MyComponent {\n  person?: Person;\n  address?: Address;\n\n  setData(person: Person, address: Address) {\n    this.person = person;\n    this.address = address;\n  }\n}\n</code-example>\n<h3 id=\"disabling-type-checking-using-any\">Disabling type checking using <code>$any()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#disabling-type-checking-using-any\"><i class=\"material-icons\">link</i></a></h3>\n<p>  Disable checking of a binding expression by surrounding the expression\nin a call to the <a href=\"guide/template-syntax\"><code>$any()</code> cast pseudo-function</a>.\nThe compiler treats it as a cast to the <code>any</code> type just like in TypeScript when a <code>&#x3C;any></code>\nor <code>as any</code> cast is used.</p>\n<p>  In the following example, the error <code>Property addresss does not exist</code> is suppressed\nby casting <code>person</code> to the <code>any</code> type.</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: '{{$any(person).addresss.street}}'\n})\nclass MyComponent {\n  person?: Person;\n}\n</code-example>\n<a id=\"tsconfig-extends\"></a>\n<h2 id=\"configuration-inheritance-with-extends\">Configuration inheritance with extends<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#configuration-inheritance-with-extends\"><i class=\"material-icons\">link</i></a></h2>\n<p>Similar to TypeScript Compiler, Angular Compiler also supports <code>extends</code> in the <code>tsconfig.json</code> on <code>angularCompilerOptions</code>. A tsconfig file can inherit configurations from another file using the <code>extends</code> property.\nThe <code>extends</code> is a top level property parallel to <code>compilerOptions</code> and <code>angularCompilerOptions</code>.\nThe configuration from the base file are loaded first, then overridden by those in the inheriting config file.\nExample:</p>\n<code-example language=\"json\">\n{\n  \"extends\": \"../tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"experimentalDecorators\": true,\n    ...\n  },\n  \"angularCompilerOptions\": {\n    \"fullTemplateTypeCheck\": true,\n    \"<a href=\"api/core/Component#preserveWhitespaces\" class=\"code-anchor\">preserveWhitespaces</a>\": true,\n    ...\n  }\n}\n</code-example>\n<p> More information about tsconfig extends can be found in the <a href=\"https://www.typescriptlang.org/docs/handbook/tsconfig-json.html\">TypeScript Handbook</a>.</p>\n<a id=\"compiler-options\"></a>\n<h2 id=\"angular-template-compiler-options\">Angular template compiler options<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#angular-template-compiler-options\"><i class=\"material-icons\">link</i></a></h2>\n<p>The template compiler options are specified as members of the <code>\"angularCompilerOptions\"</code> object in the <code>tsconfig.json</code> file. Specify template compiler options along with the options supplied to the TypeScript compiler as shown here:</p>\n<code-example language=\"json\">\n{\n  \"compilerOptions\": {\n    \"experimentalDecorators\": true,\n              ...\n  },\n  \"angularCompilerOptions\": {\n    \"fullTemplateTypeCheck\": true,\n    \"<a href=\"api/core/Component#preserveWhitespaces\" class=\"code-anchor\">preserveWhitespaces</a>\": true,\n              ...\n  }\n}\n</code-example>\n<p>The following section describes the Angular's template compiler options.</p>\n<h3 id=\"enableresourceinlining\"><em>enableResourceInlining</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#enableresourceinlining\"><i class=\"material-icons\">link</i></a></h3>\n<p>This option instructs the compiler to replace the <code>templateUrl</code> and <code><a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a></code> property in all <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> decorators with inlined contents in <code><a href=\"api/core/Component#template\" class=\"code-anchor\">template</a></code> and <code>styles</code> properties.\nWhen enabled, the <code>.js</code> output of <code>ngc</code> will have no lazy-loaded <code>templateUrl</code> or <code><a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a></code>.</p>\n<h3 id=\"skipmetadataemit\"><em>skipMetadataEmit</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#skipmetadataemit\"><i class=\"material-icons\">link</i></a></h3>\n<p>This option tells the compiler not to produce <code>.metadata.json</code> files.\nThe option is <code>false</code> by default.</p>\n<p><code>.metadata.json</code> files contain information needed by the template compiler from a <code>.ts</code>\nfile that is not included in the <code>.d.ts</code> file produced by the TypeScript compiler. This information contains,\nfor example, the content of annotations (such as a component's template), which TypeScript\nemits to the <code>.js</code> file but not to the <code>.d.ts</code> file.</p>\n<p>This option should be set to <code>true</code> if you are using TypeScript's <code>--outFile</code> option, because the metadata files\nare not valid for this style of TypeScript output. It is not recommended to use <code>--outFile</code> with\nAngular. Use a bundler, such as <a href=\"https://webpack.js.org/\">webpack</a>, instead.</p>\n<p>This option can also be set to <code>true</code> when using factory summaries because the factory summaries\ninclude a copy of the information that is in the <code>.metadata.json</code> file.</p>\n<h3 id=\"strictmetadataemit\"><em>strictMetadataEmit</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#strictmetadataemit\"><i class=\"material-icons\">link</i></a></h3>\n<p>This option tells the template compiler to report an error to the <code>.metadata.json</code>\nfile if <code>\"skipMetadataEmit\"</code> is <code>false</code>. This option is <code>false</code> by default. This should only be used when <code>\"skipMetadataEmit\"</code> is <code>false</code> and <code>\"skipTemplateCodeGen\"</code> is <code>true</code>.</p>\n<p>This option is intended to validate the <code>.metadata.json</code> files emitted for bundling with an <code>npm</code> package. The validation is strict and can emit errors for metadata that would never produce an error when used by the template compiler. You can choose to suppress the error emitted by this option for an exported symbol by including <code>@dynamic</code> in the comment documenting the symbol.</p>\n<p>It is valid for <code>.metadata.json</code> files to contain errors. The template compiler reports these errors\nif the metadata is used to determine the contents of an annotation. The metadata\ncollector cannot predict the symbols that are designed for use in an annotation, so it will preemptively\ninclude error nodes in the metadata for the exported symbols. The template compiler can then use the error\nnodes to report an error if these symbols are used. If the client of a library intends to use a symbol in an annotation, the template compiler will not normally report\nthis until the client uses the symbol. This option allows detecting these errors during the build phase of\nthe library and is used, for example, in producing Angular libraries themselves.</p>\n<h3 id=\"skiptemplatecodegen\"><em>skipTemplateCodegen</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#skiptemplatecodegen\"><i class=\"material-icons\">link</i></a></h3>\n<p>This option tells the compiler to suppress emitting <code>.ngfactory.js</code> and <code>.ngstyle.js</code> files. When set,\nthis turns off most of the template compiler and disables reporting template diagnostics.\nThis option can be used to instruct the\ntemplate compiler to produce <code>.metadata.json</code> files for distribution with an <code>npm</code> package while\navoiding the production of <code>.ngfactory.js</code> and <code>.ngstyle.js</code> files that cannot be distributed to\n<code>npm</code>.</p>\n<h3 id=\"strictinjectionparameters\"><em>strictInjectionParameters</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#strictinjectionparameters\"><i class=\"material-icons\">link</i></a></h3>\n<p>When set to <code>true</code>, this options tells the compiler to report an error for a parameter supplied\nwhose injection type cannot be determined. When this option is not provided or is <code>false</code>, constructor parameters of classes marked with <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> whose type cannot be resolved will\nproduce a warning.</p>\n<p><em>Note</em>: It is recommended to change this option explicitly to <code>true</code> as this option will default to <code>true</code> in the future.</p>\n<h3 id=\"flatmoduleoutfile\"><em>flatModuleOutFile</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#flatmoduleoutfile\"><i class=\"material-icons\">link</i></a></h3>\n<p>When set to <code>true</code>, this option tells the template compiler to generate a flat module\nindex of the given file name and the corresponding flat module metadata. Use this option when creating\nflat modules that are packaged similarly to <code>@angular/core</code> and <code>@angular/common</code>. When this option\nis used, the <code>package.json</code> for the library should refer\nto the generated flat module index instead of the library index file. With this\noption only one <code>.metadata.json</code> file is produced, which contains all the metadata necessary\nfor symbols exported from the library index. In the generated <code>.ngfactory.js</code> files, the flat\nmodule index is used to import symbols that includes both the public API from the library index\nas well as shrowded internal symbols.</p>\n<p>By default the <code>.ts</code> file supplied in the <code>files</code> field is assumed to be the library index.\nIf more than one <code>.ts</code> file is specified, <code>libraryIndex</code> is used to select the file to use.\nIf more than one <code>.ts</code> file is supplied without a <code>libraryIndex</code>, an error is produced. A flat module\nindex <code>.d.ts</code> and <code>.js</code> will be created with the given <code>flatModuleOutFile</code> name in the same\nlocation as the library index <code>.d.ts</code> file. For example, if a library uses the\n<code>public_api.ts</code> file as the library index of the module, the <code>tsconfig.json</code> <code>files</code> field\nwould be <code>[\"public_api.ts\"]</code>. The <code>flatModuleOutFile</code> options could then be set to, for\nexample <code>\"index.js\"</code>, which produces <code>index.d.ts</code> and  <code>index.metadata.json</code> files. The\nlibrary's <code>package.json</code>'s <code>module</code> field would be <code>\"index.js\"</code> and the <code>typings</code> field\nwould be <code>\"index.d.ts\"</code>.</p>\n<h3 id=\"flatmoduleid\"><em>flatModuleId</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#flatmoduleid\"><i class=\"material-icons\">link</i></a></h3>\n<p>This option specifies the preferred module id to use for importing a flat module.\nReferences generated by the template compiler will use this module name when importing symbols\nfrom the flat module.\nThis is only meaningful when <code>flatModuleOutFile</code> is also supplied. Otherwise the compiler ignores\nthis option.</p>\n<h3 id=\"generatecodeforlibraries\"><em>generateCodeForLibraries</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#generatecodeforlibraries\"><i class=\"material-icons\">link</i></a></h3>\n<p>This option tells the template compiler to generate factory files (<code>.ngfactory.js</code> and <code>.ngstyle.js</code>)\nfor <code>.d.ts</code> files with a corresponding <code>.metadata.json</code> file. This option defaults to\n<code>true</code>. When this option is <code>false</code>, factory files are generated only for <code>.ts</code> files.</p>\n<p>This option should be set to <code>false</code> when using factory summaries.</p>\n<h3 id=\"fulltemplatetypecheck\"><em>fullTemplateTypeCheck</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#fulltemplatetypecheck\"><i class=\"material-icons\">link</i></a></h3>\n<p>This option tells the compiler to enable the <a href=\"guide/aot-compiler#binding-expression-validation\">binding expression validation</a>\nphase of the template compiler which uses TypeScript to validate binding expressions.</p>\n<p>This option is <code>false</code> by default.</p>\n<p><em>Note</em>: It is recommended to set this to <code>true</code> because this option will default to <code>true</code> in the future.</p>\n<h3 id=\"annotateforclosurecompiler\"><em>annotateForClosureCompiler</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#annotateforclosurecompiler\"><i class=\"material-icons\">link</i></a></h3>\n<p>This option tells the compiler to use <a href=\"https://github.com/angular/tsickle\">Tsickle</a> to annotate the emitted\nJavaScript with <a href=\"http://usejsdoc.org/\">JSDoc</a> comments needed by the\n<a href=\"https://github.com/google/closure-compiler\">Closure Compiler</a>. This option defaults to <code>false</code>.</p>\n<h3 id=\"annotationsas\"><em>annotationsAs</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#annotationsas\"><i class=\"material-icons\">link</i></a></h3>\n<p>Use this option to modify how the Angular specific annotations are emitted to improve tree-shaking. Non-Angular\nannotations and decorators are unaffected. Default is <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> fields</code>.</p>\n<style>\n  td, th {vertical-align: top}\n</style>\n<table>\n  <tbody><tr>\n    <th>Value</th>\n    <th>Description</th>\n  </tr>\n  <tr>\n    <td><code>decorators</code></td>\n    <td>Leave the decorators in place. This makes compilation faster. TypeScript will emit calls to the __decorate helper.  Use <code>--emitDecoratorMetadata</code> for runtime reflection.  However, the resulting code will not properly tree-shake.</td>\n  </tr>\n  <tr>\n    <td><code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> fields</code></td>\n    <td>Replace decorators with a static field in the class. Allows advanced tree-shakers like\n    <a href=\"https://github.com/google/closure-compiler\">Closure compiler</a> to remove unused classes.</td>\n  </tr>\n  </tbody></table>\n<h3 id=\"trace\"><em>trace</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#trace\"><i class=\"material-icons\">link</i></a></h3>\n<p>This tells the compiler to print extra information while compiling templates.</p>\n<h3 id=\"enablelegacytemplate\"><em>enableLegacyTemplate</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#enablelegacytemplate\"><i class=\"material-icons\">link</i></a></h3>\n<p>Use of  the <code>&#x3C;<a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>></code> element was deprecated starting in Angular 4.0 in favor of using\n<code>&#x3C;ng-template></code> to avoid colliding with the DOM's element of the same name. Setting this option to\n<code>true</code> enables the use of the deprecated <code>&#x3C;<a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>></code> element. This option\nis <code>false</code> by default. This option might be required by some third-party Angular libraries.</p>\n<h3 id=\"disableexpressionlowering\"><em>disableExpressionLowering</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#disableexpressionlowering\"><i class=\"material-icons\">link</i></a></h3>\n<p>The Angular template compiler transforms code that is used, or could be used, in an annotation\nto allow it to be imported from template factory modules. See\n<a href=\"guide/aot-compiler#metadata-rewriting\">metadata rewriting</a> for more information.</p>\n<p>Setting this option to <code>false</code> disables this rewriting, requiring the rewriting to be\ndone manually.</p>\n<h3 id=\"disabletypescriptversioncheck\"><em>disableTypeScriptVersionCheck</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#disabletypescriptversioncheck\"><i class=\"material-icons\">link</i></a></h3>\n<p>When <code>true</code>, this option tells the compiler not to check the TypeScript version.\nThe compiler will skip checking and will not error out when an unsupported version of TypeScript is used.\nSetting this option to <code>true</code> is not recommended because unsupported versions of TypeScript might have undefined behaviour.</p>\n<p>This option is <code>false</code> by default.</p>\n<h3 id=\"preservewhitespaces\"><em>preserveWhitespaces</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#preservewhitespaces\"><i class=\"material-icons\">link</i></a></h3>\n<p>This option tells the compiler whether to remove blank text nodes from compiled templates.\nAs of v6, this option is <code>false</code> by default, which results in smaller emitted template factory modules.</p>\n<h3 id=\"allowemptycodegenfiles\"><em>allowEmptyCodegenFiles</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#allowemptycodegenfiles\"><i class=\"material-icons\">link</i></a></h3>\n<p>Tells the compiler to generate all the possible generated files even if they are empty. This option is\n<code>false</code> by default. This is an option used by the Bazel build rules and is needed to simplify\nhow Bazel rules track file dependencies. It is not recommended to use this option outside of the Bazel\nrules.</p>\n\n</div>\n\n<!-- links to this doc:\n - api/upgrade\n - api/upgrade/UpgradeAdapter\n - api/upgrade/UpgradeAdapterRef\n - guide/architecture-next-steps\n - guide/browser-support\n - guide/change-log\n - guide/creating-libraries\n - guide/deployment\n - guide/npm-packages\n - guide/universal\n - guide/upgrade\n - guide/upgrade-performance\n-->\n<!-- links from this doc:\n - api/common/DOCUMENT\n - api/common/NgIf\n - api/core/Attribute\n - api/core/Component\n - api/core/Component#preserveWhitespaces\n - api/core/Component#styleUrls\n - api/core/Component#template\n - api/core/ContentChild\n - api/core/ContentChildren\n - api/core/Directive\n - api/core/Host\n - api/core/HostBinding\n - api/core/Inject\n - api/core/Injectable\n - api/core/InjectionToken\n - api/core/Input\n - api/core/NgModule\n - api/core/NgModule#declarations\n - api/core/Optional\n - api/core/Output\n - api/core/Pipe\n - api/core/Self\n - api/core/SkipSelf\n - api/core/ViewChild\n - api/platform-server/PlatformConfig#document\n - api/router/Router#config\n - api/router/RouterLinkWithHref\n - api/router/RouterModule\n - api/upgrade/static\n - cli\n - cli/build\n - cli/serve\n - guide/aot-compiler#1단계-분석\n - guide/aot-compiler#2단계-코드-생성\n - guide/aot-compiler#ahead-of-time-aot-컴파일러\n - guide/aot-compiler#allowemptycodegenfiles\n - guide/aot-compiler#angular-template-compiler-options\n - guide/aot-compiler#angular의-컴파일\n - guide/aot-compiler#annotateforclosurecompiler\n - guide/aot-compiler#annotationsas\n - guide/aot-compiler#aot가-동작하는-방식\n - guide/aot-compiler#binding-expression-validation\n - guide/aot-compiler#compiler-options\n - guide/aot-compiler#configuration-inheritance-with-extends\n - guide/aot-compiler#controlling-app-compilation\n - guide/aot-compiler#could-not-resolve-type\n - guide/aot-compiler#custom-ngif-like-directives\n - guide/aot-compiler#destructured-variable-not-supported\n - guide/aot-compiler#destructured-variable-or-constant-not-supported\n - guide/aot-compiler#disableexpressionlowering\n - guide/aot-compiler#disabletypescriptversioncheck\n - guide/aot-compiler#disabling-type-checking-using-any\n - guide/aot-compiler#enablelegacytemplate\n - guide/aot-compiler#enableresourceinlining\n - guide/aot-compiler#exported-symbols\n - guide/aot-compiler#expression-form-not-supported\n - guide/aot-compiler#expression-syntax\n - guide/aot-compiler#flatmoduleid\n - guide/aot-compiler#flatmoduleoutfile\n - guide/aot-compiler#folding\n - guide/aot-compiler#fulltemplatetypecheck\n - guide/aot-compiler#function-calls-are-not-supported\n - guide/aot-compiler#function-calls-not-supported\n - guide/aot-compiler#function-expression\n - guide/aot-compiler#generatecodeforlibraries\n - guide/aot-compiler#metadata-aot\n - guide/aot-compiler#metadata-errors\n - guide/aot-compiler#metadata-rewriting\n - guide/aot-compiler#name-expected\n - guide/aot-compiler#non-null-type-assertion-operator\n - guide/aot-compiler#only-initialized-variables\n - guide/aot-compiler#only-initialized-variables-and-constants\n - guide/aot-compiler#phase-3-binding-expression-validation\n - guide/aot-compiler#preservewhitespaces\n - guide/aot-compiler#reference-to-a-local-non-exported-symbol\n - guide/aot-compiler#reference-to-a-local-symbol\n - guide/aot-compiler#reference-to-a-non-exported-class\n - guide/aot-compiler#reference-to-a-non-exported-function\n - guide/aot-compiler#skipmetadataemit\n - guide/aot-compiler#skiptemplatecodegen\n - guide/aot-compiler#specifying-angular-metadata\n - guide/aot-compiler#strictinjectionparameters\n - guide/aot-compiler#strictmetadataemit\n - guide/aot-compiler#supported-functions\n - guide/aot-compiler#symbol-reference-expected\n - guide/aot-compiler#tagged-template-expressions-are-not-supported\n - guide/aot-compiler#tagged-template-expressions-not-supported\n - guide/aot-compiler#trace\n - guide/aot-compiler#type-narrowing\n - guide/aot-compiler#unsupported-enum-member-name\n - guide/aot-compiler#매크로-함수와-정적-매크로-메소드\n - guide/aot-compiler#메타데이터-재구축\n - guide/aot-compiler#메타데이터의-제약사항\n - guide/aot-compiler#어노테이션데코레이터\n - guide/aot-compiler#왜-aot-컴파일-하나요\n - guide/aot-compiler#인스턴스-생성\n - guide/aot-compiler#폴딩-folding\n - guide/aot-compiler#폴딩할-수-있는-문법\n - guide/aot-compiler#표현식-expression-syntax\n - guide/aot-compiler#함수-실행-제한\n - guide/aot-compiler#화살표-함수는-사용할-수-없습니다\n - guide/build\n - guide/ngmodules\n - guide/template-syntax\n - guide/template-syntax#non-null-assertion-operator\n - http://usejsdoc.org/\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/raw\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals\n - https://en.wikipedia.org/wiki/Abstract_syntax_tree\n - https://github.com/angular/angular/blob/master/packages/compiler-cli/src/metadata/schema.ts\n - https://github.com/angular/angular/blob/master/packages/router/src/router_module.ts#L139\n - https://github.com/angular/angular/edit/master/aio/content/guide/aot-compiler.md?message=docs%3A%20describe%20your%20change...\n - https://github.com/angular/tsickle\n - https://github.com/google/closure-compiler\n - https://webpack.js.org/\n - https://www.typescriptlang.org/docs/handbook/enums.html\n - https://www.typescriptlang.org/docs/handbook/tsconfig-json.html\n - https://www.typescriptlang.org/docs/handbook/variable-declarations.html#destructuring\n - https://www.youtube.com/watch?v=kW9cJsvcsGo\n-->"
}