{
  "id": "guide/aot-compiler",
  "title": "Ahead-of-Time (AOT) 컴파일러",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/aot-compiler.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Ahead-of-time (AOT) compilation\n-->\n<h1 id=\"ahead-of-time-aot-컴파일러\">Ahead-of-Time (AOT) 컴파일러<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#ahead-of-time-aot-컴파일러\"><i class=\"material-icons\">link</i></a></h1>\n<!--\nAn Angular application consists mainly of components and their HTML templates. Because the components and templates provided by Angular cannot be understood by the browser directly, Angular applications require a compilation process before they can run in a browser.\n\nThe Angular [ahead-of-time (AOT) compiler](guide/glossary#aot) converts your Angular HTML and TypeScript code into efficient JavaScript code during the build phase _before_ the browser downloads and runs that code. Compiling your application during the build process provides a faster rendering in the browser.\n\nThis guide explains how to specify metadata and apply available compiler options to compile your applications efficiently using the AOT compiler.\n-->\n<p>Angular 애플리케이션은 크게 컴포넌트와 컴포넌트 HTML 템플릿으로 구성됩니다. 그런데 이 컴포넌트와 템플릿은 브라우저가 바로 이해할 수 없기 때문에 Angular 애플리케이션은 브라우저에서 실행되기 전에 컴파일되어야 합니다.</p>\n<p>Angular <a href=\"guide/glossary#aot\">Ahead-of-time (AOT) 컴파일러</a>는 브라우저가 애플리케이션 코드를 받아서 실행하기 <em>전에</em> 미리 HTML 파일과 TypeScript 코드를 브라우저가 실행할 수 있는 JavaScript 코드로 변환합니다.\n이 빌드 과정이 있기 때문에 브라우저가 앱을 렌더링하는 시간도 이전보다 빠릅니다.</p>\n<p>이 문서는 AOT 컴파일러를 사용할 때 지정할 수 있는 메타데이터와 컴파일러 옵션에 대해 다룹니다.</p>\n<div class=\"alert is-helpful\">\n  <!--\n  <a href=\"https://www.youtube.com/watch?v=anphffaCZrQ\">Watch Alex Rickabaugh explain the Angular compiler</a> at AngularConnect 2019.\n  -->\n<p>  Alex Rickabaugh가 <a href=\"https://www.youtube.com/watch?v=anphffaCZrQ\">AngularConnect 2019에서 발표한 내용</a>도 확인해 보세요.</p>\n</div>\n<a id=\"why-aot\"></a>\n<!--\nHere are some reasons you might want to use AOT.\n\n* *Faster rendering*\n   With AOT, the browser downloads a pre-compiled version of the application.\n   The browser loads executable code so it can render the application immediately, without waiting to compile the app first.\n\n* *Fewer asynchronous requests*\n   The compiler _inlines_ external HTML templates and CSS style sheets within the application JavaScript,\n   eliminating separate ajax requests for those source files.\n\n* *Smaller Angular framework download size*\n   There's no need to download the Angular compiler if the app is already compiled.\n   The compiler is roughly half of Angular itself, so omitting it dramatically reduces the application payload.\n\n* *Detect template errors earlier*\n   The AOT compiler detects and reports template binding errors during the build step\n   before users can see them.\n\n* *Better security*\n   AOT compiles HTML templates and components into JavaScript files long before they are served to the client.\n   With no templates to read and no risky client-side HTML or JavaScript evaluation,\n   there are fewer opportunities for injection attacks.\n-->\n<p>AOT 컴파일러는 이런 점에서 더 좋습니다.</p>\n<ul>\n<li>\n<p><em>렌더링이 빠릅니다.</em>\nAOT 컴파일러를 사용하면 애플리케이션을 미리 컴파일해서 제공할 수 있습니다.\n이 코드는 브라우저가 바로 실행할 수 있는 코드이기 때문에 브라우저가 내려받기만 하면 애플리케이션이 따로 빌드될 때까지 기다릴 필요가 없습니다.</p>\n</li>\n<li>\n<p><em>비동기 요청횟수가 줄어듭니다.</em>\n컴파일러가 애플리케이션 코드를 JavaScript로 컴파일하면 외부 HTML 템플릿 파일이나 CSS 파일을 모두 <em>인라인으로</em> 변환합니다. 따라서 추가 파일을 내려받기 위해 별도로 ajax 요청을 할 필요가 없습니다.</p>\n</li>\n<li>\n<p><em>내려받아야 하는 Angular 프레임워크 용량이 줄어듭니다.</em>\n앱은 이미 컴파일된 상태로 제공되기 때문에 Angular 컴파일러를 내려받아야 할 필요가 없습니다.\nAngular 컴파일러의 용량은 Angular 프레임워크의 절반 정도에 해당되기 때문에, 이 용량만 빼도 브라우저가 내려받아야 하는 용량은 크게 줄어듭니다.</p>\n</li>\n<li>\n<p><em>템플릿 에러를 더 빠르게 발견할 수 있습니다.</em>\nAOT 컴파일러는 애플리케이션을 빌드할 때 템플릿 바인딩 에러를 확인하고 에러가 발생했을 때 알려줍니다.\n이 타이밍은 사용자가 앱을 내려받기도 전입니다.</p>\n</li>\n<li>\n<p><em>더 안전합니다.</em>\nAOT 컴파일러가 HTML 템플릿과 컴포넌트를 JavaScript 파일로 변환하는 것은 클라이언트가 앱을 내려받는 시점보다 훨씬 이전입니다.\n따라서 템플릿을 추가로 요청하거나 클라이언트쪽에서 위험한 HTML 코드나 JavaScript 코드가 실행될 가능성이 없고, 인젝션 공격의 가능성도더  적습니다.</p>\n</li>\n</ul>\n<a id=\"overview\"></a>\n<!--\n## Choosing a compiler\n-->\n<h2 id=\"컴파일러-선택하기\">컴파일러 선택하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#컴파일러-선택하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAngular offers two ways to compile your application:\n-->\n<p>Angular는 두 종류의 컴파일 방식을 제공합니다:</p>\n<!--\n* **_Just-in-Time_ (JIT)**, which compiles your app in the browser at runtime. This was the default until Angular 8.\n* **_Ahead-of-Time_ (AOT)**, which compiles your app and libraries at build time. This is the default since Angular 9.\n-->\n<ul>\n<li><strong><em>Just-in-Time</em> (JIT)</strong>: 브라우저에서 애플리케이션을 실행하면서 코드를 직접 컴파일하는 방식입니다. Angular 8까지는 기본 컴파일러였습니다.</li>\n<li><strong><em>Ahead-of-Time</em> (AOT)</strong>: 브라우저에 애플리케이션 코드를 보내기 전에 미리 컴파일하는 방식입니다. Angular 9부터 기본 컴파일러입니다.</li>\n</ul>\n<p>When you run the <a href=\"cli/build\"><code>ng build</code></a> (build only) or <a href=\"cli/serve\"><code>ng serve</code></a> (build and serve locally) CLI commands, the type of compilation (JIT or AOT) depends on the value of the <code>aot</code> property in your build configuration specified in <code>angular.json</code>. By default, <code>aot</code> is set to <code>true</code> for new CLI apps.</p>\n<p>See the <a href=\"cli\">CLI command reference</a> and <a href=\"guide/build\">Building and serving Angular apps</a> for more information.</p>\n<!--\n## How AOT works\n-->\n<h2 id=\"aot-컴파일러가-동작하는-방식\">AOT 컴파일러가 동작하는 방식<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#aot-컴파일러가-동작하는-방식\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe Angular AOT compiler extracts **metadata** to interpret the parts of the application that Angular is supposed to manage.\nYou can specify the metadata explicitly in **decorators** such as `@Component()` and `@Input()`, or implicitly in the constructor declarations of the decorated classes.\nThe metadata tells Angular how to construct instances of your application classes and interact with them at runtime.\n\nIn the following example, the `@Component()` metadata object and the class constructor tell Angular how to create and display an instance of `TypicalComponent`.\n-->\n<p>Angular AOT 컴파일러는 애플리케이션을 구성하는 개별 요소를 관리하기 위해 코드에서 <strong>메타데이터(metadata)</strong>를 추출합니다.\n그리고 이 메타데이터는 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code>나 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>과 같이 <strong>데코레이터</strong>를 사용해서 명시적으로 지정할 수 있으며, 클래스 생성자의 인자에도 지정할 수 있습니다.\nAngular는 이 메타데이터에 지정된 내용을 바탕으로 애플리케이션 클래스의 인스턴스를 구성하며, 실행시점에 어떻게 동작할지 결정합니다.</p>\n<p>아래 코드에서 <code>TypicalComponent</code> 클래스에 지정된 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 데코레이터가 이 용도로 사용되었습니다.</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-typical',\n  template: '&#x3C;div>A typical component for {{data.name}}&#x3C;/div>'\n})\nexport class TypicalComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() data: TypicalData;\n  constructor(private someService: SomeService) { ... }\n}\n</code-example>\n<!--\nThe Angular compiler extracts the metadata _once_ and generates a _factory_ for `TypicalComponent`.\nWhen it needs to create a `TypicalComponent` instance, Angular calls the factory, which produces a new visual element, bound to a new instance of the component class with its injected dependency.\n-->\n<p>이 코드를 Angular 컴파일러가 처리하면 메타데이터를 추출해서 <code>TypicalComponent</code>에 대한 <em>팩토리</em> 를 만듭니다.\n그러면 <code>TypicalComponent</code>의 인스턴스가 필요한 시점에 Angular가 팩토리를 실행해서 인스턴스를 생성하며, 이렇게 생성된 인스턴스를 의존성으로 주입합니다.</p>\n<!--\n### Compilation phases\n-->\n<h3 id=\"컴파일-단계\">컴파일 단계<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#컴파일-단계\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThere are three phases of AOT compilation.\n* Phase 1 is *code analysis*.\n   In this phase, the TypeScript compiler and  *AOT collector* create a representation of the source. The collector does not attempt to interpret the metadata it collects. It represents the metadata as best it can and records errors when it detects a metadata syntax violation.\n\n* Phase 2 is *code generation*.\n    In this phase, the compiler's `StaticReflector` interprets the metadata collected in phase 1, performs additional validation of the metadata, and throws an error if it detects a metadata restriction violation.\n\n* Phase 3 is *template type checking*.\n   In this optional phase, the Angular *template compiler* uses the TypeScript compiler to validate the binding expressions in templates. You can enable this phase explicitly by setting the `fullTemplateTypeCheck` configuration option; see [Angular compiler options](guide/angular-compiler-options).\n-->\n<p>AOT 컴파일러는 3단계로 동작합니다.</p>\n<ul>\n<li>\n<p>1단계는 <em>코드 분석</em> 단계입니다.\nTypeScript 컴파일러와 <em>AOT 콜렉터</em> 가 소스 코드에서 필요한 정보를 수집합니다. 이 단계에서 콜렉터가 메타데이터를 직접 처리하지는 않으며, 단지 수집하기만 합니다. 그리고 이렇게 수집한 메타데이터를 최적화하는데, 메타데이터 문법이 잘못되면 이 단계에서 에러를 발생시킵니다.</p>\n</li>\n<li>\n<p>2단계는 <em>코드 생성</em> 단계입니다.\n1단계에서 수집한 메타데이터를 컴파일러의 <code>StaticReflector</code>가 처리하면서 메타데이터 유효성을 추가로 검사합니다. 이 때 에러가 추가로 발견되면 역시 에러를 발생시킵니다.</p>\n</li>\n<li>\n<p>3단계는 <em>템플릿 문법 체크</em> 단계입니다.\n이 단계는 생략될 수 있습니다. 이 단계에서는 Angular <em>템플릿 컴파일러</em>가 TypeScript 컴파일러를 사용해서 템플릿에 사용된 바인딩 표현식을 검증합니다.</p>\n</li>\n</ul>\n<!--\n### Metadata restrictions\n-->\n<h3 id=\"메타데이터의-제약사항\">메타데이터의 제약사항<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#메타데이터의-제약사항\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou write metadata in a _subset_ of TypeScript that must conform to the following general constraints:\n\n* Limit [expression syntax](#expression-syntax) to the supported subset of JavaScript.\n* Only reference exported symbols after [code folding](#code-folding).\n* Only call [functions supported](#supported-functions) by the compiler.\n* Decorated and data-bound class members must be public.\n\nFor additional guidelines and instructions on preparing an application for AOT compilation, see [Angular: Writing AOT-friendly applications](https://medium.com/sparkles-blog/angular-writing-aot-friendly-applications-7b64c8afbe3f).\n-->\n<p>메타데이터는 TypeScript의 <em>하위 집합(subset)</em> 이며 보통 다음과 같은 제약사항이 있습니다:</p>\n<ol>\n<li>JavaScript 문법 중 <a href=\"guide/aot-compiler#expression-syntax\">표현식(expression syntax)</a>은 일부만 사용할 수 있습니다.</li>\n<li><a href=\"guide/aot-compiler#code-folding\">코드를 폴딩</a>한 이후에 존재하는 심볼만 참조할 수 있습니다.</li>\n<li>컴파일러가 지원하는 <a href=\"guide/aot-compiler#supported-functions\">일부 함수</a>만 사용할 수 있습니다.</li>\n<li>데코레이터가 사용되거나 데이터 바인딩되는 클래스 멤버는 public으로 지정되어야 합니다.</li>\n</ol>\n<p>메타데이터의 제약사항이나 애플리케이션을 AOT 빌드하기 위해 필요한 내용에 대해 더 알아보려면 <a href=\"https://medium.com/sparkles-blog/angular-writing-aot-friendly-applications-7b64c8afbe3f\">Angular: Writing AOT-friendly applications</a> 글을 참고하세요.</p>\n<div class=\"alert is-helpful\">\n<!--\nErrors in AOT compilation commonly occur because of metadata that does not conform to the compiler's requirements (as described more fully below).\nFor help in understanding and resolving these problems, see [AOT Metadata Errors](guide/aot-metadata-errors).\n-->\n<p>AOT 컴파일 과정 중 발생하는 에러의 원인은 일반적으로 컴파일러에 필요한 정보가 일부 입력되지 않았기 때문입니다 (아래에서 자세하게 설명합니다).\n에러가 왜 발생했는지, 어떻게 해결해야 하는지 알아보려면 <a href=\"guide/aot-metadata-errors\">AOT 메타데이터 에러</a> 문서를 참고하세요.</p>\n</div>\n<!--\n### Configuring AOT compilation\n-->\n<h3 id=\"aot-컴파일-설정하기\">AOT 컴파일 설정하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#aot-컴파일-설정하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou can provide options in the [TypeScript configuration file](guide/typescript-configuration) that controls the compilation process. See [Angular compiler options](guide/angular-compiler-options) for a complete list of available options.\n-->\n<p>컴파일 옵션은 <a href=\"guide/typescript-configuration\">TypeScript 환경 설정 파일</a>에 지정합니다. 사용할 수 있는 옵션 목록은 <a href=\"guide/angular-compiler-options\">Angular 컴파일러 옵션</a> 문서를 참고하세요.</p>\n<!--\n## Phase 1: Code analysis\n-->\n<h2 id=\"1단계-분석\">1단계: 분석<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#1단계-분석\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe TypeScript compiler does some of the analytic work of the first phase. It emits the `.d.ts` _type definition files_ with type information that the AOT compiler needs to generate application code.\nAt the same time, the AOT **collector** analyzes the metadata recorded in the Angular decorators and outputs metadata information in **`.metadata.json`** files, one per `.d.ts` file.\n\nYou can think of `.metadata.json` as a diagram of the overall structure of a decorator's metadata, represented as an [abstract syntax tree (AST)](https://en.wikipedia.org/wiki/Abstract_syntax_tree).\n-->\n<p>첫번째 단계에서는 TypeScript 컴파일러가 분석과 관련된 작업을 합니다. TypeScript 컴파일러가 코드를 컴파일하고 나면 <em>타입 정의 파일</em> 인 <code>.d.ts</code> 파일이 생성되며, 이 정보는 이후에 AOT 컴파일러가 애플리케이션 코드를 생성할 때 사용합니다.</p>\n<p>그리고 이 때 AOT <strong><em>콜렉터(collector)</em></strong>가 각 <code>.d.ts</code> 파일에 있는 Angular 데코레이터의 메타데이터를 분석하고 분석한 내용을 <strong><code>.metadata.json</code></strong> 파일로 생성합니다.</p>\n<p><code>.metadata.json</code> 파일은 데코레이터의 메타데이터를 나타내는 청사진이라고도 볼 수 있습니다. <a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\">추상 구문 트리(abstract syntax tree, AST)</a>를 참고하세요.</p>\n<div class=\"alert is-helpful\">\n<!--\nAngular's [schema.ts](https://github.com/angular/angular/blob/master/packages/compiler-cli/src/metadata/schema.ts)\ndescribes the JSON format as a collection of TypeScript interfaces.\n-->\n<p>Angular가 생성하는 <a href=\"https://github.com/angular/angular/blob/master/packages/compiler-cli/src/metadata/schema.ts\">schema.ts</a> 파일은 TypeScript 인터페이스를 JSON 형식으로 기술하는 파일입니다.</p>\n</div>\n<a id=\"expression-syntax\"></a>\n<!--\n### Expression syntax limitations\n-->\n<h3 id=\"표현식expression-syntax의-한계\">표현식(Expression syntax)의 한계<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#표현식expression-syntax의-한계\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe AOT collector only understands a subset of JavaScript.\nDefine metadata objects with the following limited syntax:\n-->\n<p>Angular <em>콜렉터(collector)</em> 는 JavaScript의 하위집합이며 JavaScript 문법 중 일부만 처리할 수 있습니다.\n그래서 메타데이터에는 다음과 같은 문법만 허용됩니다:</p>\n<style>\n  td, th {vertical-align: top}\n</style>\n<!--\n<table>\n  <tr>\n    <th>Syntax</th>\n    <th>Example</th>\n  </tr>\n  <tr>\n    <td>Literal object </td>\n    <td><code>{cherry: true, apple: true, mincemeat: false}</code></td>\n  </tr>\n  <tr>\n    <td>Literal array  </td>\n    <td><code>['cherries', 'flour', 'sugar']</code></td>\n  </tr>\n  <tr>\n    <td>Spread in literal array</td>\n    <td><code>['apples', 'flour', ...the_rest]</code></td>\n  </tr>\n   <tr>\n    <td>Calls</td>\n    <td><code>bake(ingredients)</code></td>\n  </tr>\n   <tr>\n    <td>New</td>\n    <td><code>new Oven()</code></td>\n  </tr>\n   <tr>\n    <td>Property access</td>\n    <td><code>pie.slice</code></td>\n  </tr>\n   <tr>\n    <td>Array index</td>\n    <td><code>ingredients[0]</code></td>\n  </tr>\n   <tr>\n    <td>Identity reference</td>\n    <td><code>Component</code></td>\n  </tr>\n   <tr>\n    <td>A template string</td>\n    <td><code>`pie is ${multiplier} times better than cake`</code></td>\n   <tr>\n    <td>Literal string</td>\n    <td><code>pi</code></td>\n  </tr>\n   <tr>\n    <td>Literal number</td>\n    <td><code>3.14153265</code></td>\n  </tr>\n   <tr>\n    <td>Literal boolean</td>\n    <td><code>true</code></td>\n  </tr>\n   <tr>\n    <td>Literal null</td>\n    <td><code>null</code></td>\n  </tr>\n   <tr>\n    <td>Supported prefix operator </td>\n    <td><code>!cake</code></td>\n  </tr>\n   <tr>\n    <td>Supported binary operator </td>\n    <td><code>a+b</code></td>\n  </tr>\n   <tr>\n    <td>Conditional operator</td>\n    <td><code>a ? b : c</code></td>\n  </tr>\n   <tr>\n    <td>Parentheses</td>\n    <td><code>(a+b)</code></td>\n  </tr>\n</table>\n-->\n<table>\n  <tbody><tr>\n    <th>문법</th>\n    <th>예</th>\n  </tr>\n  <tr>\n    <td>객체 리터럴</td>\n    <td><code>{cherry: true, apple: true, mincemeat: false}</code></td>\n  </tr>\n  <tr>\n    <td>배열 리터럴</td>\n    <td><code>['cherries', 'flour', 'sugar']</code></td>\n  </tr>\n  <tr>\n    <td>배열 안에 사용된 전개 연산자</td>\n    <td><code>['apples', 'flour', ...the_rest]</code></td>\n  </tr>\n   <tr>\n    <td>함수 실행</td>\n    <td><code>bake(ingredients)</code></td>\n  </tr>\n   <tr>\n    <td>New</td>\n    <td><code>new Oven()</code></td>\n  </tr>\n   <tr>\n    <td>프로퍼티 참조</td>\n    <td><code>pie.slice</code></td>\n  </tr>\n   <tr>\n    <td>배열 인덱스 참조</td>\n    <td><code>ingredients[0]</code></td>\n  </tr>\n   <tr>\n    <td>타입 참조</td>\n    <td><code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code></td>\n  </tr>\n   <tr>\n    <td>템플릿 문자열</td>\n    <td><code>`pie is ${multiplier} times better than cake`</code></td>\n   </tr><tr>\n    <td>문자열 리터럴</td>\n    <td><code>pi</code></td>\n  </tr>\n   <tr>\n    <td>숫자 리터럴</td>\n    <td><code>3.14153265</code></td>\n  </tr>\n   <tr>\n    <td>불리언 리터럴</td>\n    <td><code>true</code></td>\n  </tr>\n   <tr>\n    <td>null 리터럴</td>\n    <td><code>null</code></td>\n  </tr>\n   <tr>\n    <td>접두사 연산자</td>\n    <td><code>!cake</code></td>\n  </tr>\n   <tr>\n    <td>바이너리 연산자</td>\n    <td><code>a+b</code></td>\n  </tr>\n   <tr>\n    <td>조건 연산자</td>\n    <td><code>a ? b : c</code></td>\n  </tr>\n   <tr>\n    <td>괄호</td>\n    <td><code>(a+b)</code></td>\n  </tr>\n</tbody></table>\n<!--\nIf an expression uses unsupported syntax, the collector writes an error node to the `.metadata.json` file.\nThe compiler later reports the error if it needs that piece of metadata to generate the application code.\n-->\n<p>만약 이 목록에 해당되지 않은 표현식이 사용되면 <em>콜렉터</em> 가 처리할 수 없기 때문에 에러기 발생하며 <code>.metadata.json</code> 파일도 정상적으로 생성되지 않습니다. 결국 애플리케이션 코드를 빌드할 때 에러가 발생합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\n If you want `ngc` to report syntax errors immediately rather than produce a `.metadata.json` file with errors, set the `strictMetadataEmit` option in the TypeScript configuration file.\n-->\n<p><code>.metadata.json</code> 파일에 에러를 출력하는 대신 <code>ngc</code>에서 직접 문법 에러가 발생하게 하려면 TypeScript 설정 파일에 <code>strictMetadataEmit</code> 옵션을 다음과 같이 설정하세요.</p>\n<code-example>\n  \"angularCompilerOptions\": {\n   ...\n   \"strictMetadataEmit\" : true\n }\n</code-example>\n<!--\nAngular libraries have this option to ensure that all Angular `.metadata.json` files are clean and it is a best practice to do the same when building your own libraries.\n-->\n<p>Angular가 제공하는 라이브러리는 모두 이 옵션을 사용하기 때문에 Angular에서 제공하는 모든 <code>.metadata.json</code> 파일은 에러 없이 깔끔한 상태입니다. 커스텀 라이브러리를 만드는 경우에도 활용해 보세요.</p>\n</div>\n<a id=\"function-expression\"></a>\n<a id=\"arrow-functions\"></a>\n<!--\n### No arrow functions\n-->\n<h3 id=\"화살표-함수는-사용할-수-없습니다\">화살표 함수는 사용할 수 없습니다.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#화살표-함수는-사용할-수-없습니다\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe AOT compiler does not support [function expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function)\nand [arrow functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions), also called _lambda_ functions.\n\nConsider the following component decorator:\n-->\n<p>AOT 컴파일러는 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function\">함수 표현식</a>과 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">화살표 함수 (람다 함수)</a>를 지원하지 않습니다.</p>\n<p>다음과 같은 컴포넌트 데코레이터가 있다고 합시다:</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  ...\n  providers: [{provide: server, useFactory: () => new Server()}]\n})\n</code-example>\n<!--\nThe AOT collector does not support the arrow function, `() => new Server()`, in a metadata expression.\nIt generates an error node in place of the function.\nWhen the compiler later interprets this node, it reports an error that invites you to turn the arrow function into an _exported function_.\n\nYou can fix the error by converting to this:\n-->\n<p>이 코드에는 AOT 콜렉터가 지원하지 않는 화살표 함수가 <code>() => new Server()</code>와 같이 사용되었습니다.\n그러면 이 코드는 제대로 변환되지 못하고 에러 노드로 처리됩니다.\n그리고 이후에 컴파일러가 이 노드를 처리할 때 에러가 발생하기 때문에, 이 화살표 함수는 <em>export가 사용된 함수</em> 로 변경되어야 합니다.</p>\n<p>이 에러는 다음과 같이 수정하면 해결할 수 있습니다:</p>\n<code-example language=\"typescript\">\nexport function serverFactory() {\n  return new Server();\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  ...\n  providers: [{provide: server, useFactory: serverFactory}]\n})\n</code-example>\n<!--\nIn version 5 and later, the compiler automatically performs this rewriting while emitting the `.js` file.\n-->\n<p>Angular 5버전 부터는 <code>.js</code> 파일을 생성할 때 이 문제를 자동으로 처리합니다.</p>\n<a id=\"exported-symbols\"></a>\n<a id=\"code-folding\"></a>\n<!--\n### Code folding\n-->\n<h3 id=\"코드-폴딩-code-folding\">코드 폴딩 (Code Folding)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#코드-폴딩-code-folding\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe compiler can only resolve references to **_exported_** symbols.\nThe collector, however, can evaluate an expression during collection and record the result in the `.metadata.json`, rather than the original expression.\nThis allows you to make limited use of non-exported symbols within expressions.\n\nFor example, the collector can evaluate the expression `1 + 2 + 3 + 4` and replace it with the result, `10`.\nThis process is called _folding_. An expression that can be reduced in this manner is _foldable_.\n-->\n<p>AOT 컴파일러는 <strong><em>export</em></strong> 키워드가 사용된 심볼만 참조할 수 있습니다.\n하지만 다행히도 <em>콜렉터</em> 는 <em>폴딩</em> 이라는 것을 통해 <code>export</code> 키워드가 사용되지 않은 심볼도 제한적으로 참조할 수 있습니다.</p>\n<p><em>콜렉터</em> 는 콜렉션 단계에서 표현식을 평가하고 그 결과를 <code>.metadata.json</code> 파일에 기록하는데, 이 때 원래 코드를 약간 변형해서 기록합니다.</p>\n<p>예를 들어 <em>콜렉터</em> 가 <code>1 + 2 + 3 + 4</code> 라는 표현식을 평가하고 나면 <code>.metadata.json</code> 파일에는 이 내용을 <code>10</code>으로 기록합니다.</p>\n<p>이 과정을 <em>폴딩(folding)</em> 이라고 합니다. 그리고 이 과정이 적용될 수 있는 코드를 <em>폴딩할 수 있는(foldable)</em> 코드라고 합니다.</p>\n<a id=\"var-declaration\"></a>\n<!--\nThe collector can evaluate references to module-local `const` declarations and initialized `var` and `let` declarations, effectively removing them from the `.metadata.json` file.\n\nConsider the following component definition:\n-->\n<p>콜렉터는 모듈 파일에 로컬 변수로 선언된 <code>const</code>, <code>var</code>, <code>let</code> 변수들을 참조할 수 있으며, 코드가 처리되어 <code>.metadata.json</code> 파일에 기록될 때는 이 코드가 모두 폴딩되면서 제거됩니다.</p>\n<p>다음과 같이 정의된 컴포넌트가 있다고 합시다:</p>\n<code-example language=\"typescript\">\nconst template = '&#x3C;div>{{hero.name}}&#x3C;/div>';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  template: template\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n</code-example>\n<!--\nThe compiler could not refer to the `template` constant because it isn't exported.\nThe collector, however, can fold the `template` constant into the metadata definition by in-lining its contents.\nThe effect is the same as if you had written:\n-->\n<p>컴파일러는 이 코드에 선언된 <code>template</code> 변수를 참조할 수 없습니다. 왜냐하면 이 변수에 <code>export</code> 키워드가 사용되지 않았기 때문입니다.</p>\n<p>하지만 <em>콜렉터</em> 는 <code>template</code> 변수를 <em>폴딩</em> 해서 컴포넌트 메타데이터 안으로 집어넣을 수 있습니다.\n결과적으로 이 코드는 아래 코드와 같습니다:</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  template: '&#x3C;div>{{hero.name}}&#x3C;/div>'\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n</code-example>\n<!--\nThere is no longer a reference to `template` and, therefore, nothing to trouble the compiler when it later interprets the _collector's_ output in `.metadata.json`.\n\nYou can take this example a step further by including the `template` constant in another expression:\n-->\n<p>이 코드에는 <code>template</code>이라는 변수가 없으며, <em>콜렉터</em> 가 생성한 <code>.metadata.json</code> 파일을 사용하는 컴파일러도 정상적으로 실행됩니다.</p>\n<p>그리고 이와 비슷한 방식으로 다음과 같은 코드도 정상적으로 처리됩니다:</p>\n<code-example language=\"typescript\">\nconst template = '&#x3C;div>{{hero.name}}&#x3C;/div>';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  template: template + '&#x3C;div>{{hero.title}}&#x3C;/div>'\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n</code-example>\n<!--\nThe collector reduces this expression to its equivalent _folded_ string:\n-->\n<p>이 코드의 템플릿을 콜렉터가 처리하고 나면 다음과 같이 <em>폴딩 된</em> 문자열로 변환됩니다:</p>\n<code-example>\n'&#x3C;div>{{hero.name}}&#x3C;/div>&#x3C;div>{{hero.title}}&#x3C;/div>'\n</code-example>\n<!--\n#### Foldable syntax\n-->\n<h4 id=\"폴딩할-수-있는-문법\">폴딩할 수 있는 문법<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#폴딩할-수-있는-문법\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe following table describes which expressions the collector can and cannot fold:\n-->\n<p>콜렉터가 폴딩할 수 있는 문법에는 어떤 것들이 있는지 확인해 보세요:</p>\n<style>\n  td, th {vertical-align: top}\n</style>\n<!--\n<table>\n  <tr>\n    <th>Syntax</th>\n    <th>Foldable</th>\n  </tr>\n  <tr>\n    <td>Literal object </td>\n    <td>yes</td>\n  </tr>\n  <tr>\n    <td>Literal array  </td>\n    <td>yes</td>\n  </tr>\n  <tr>\n    <td>Spread in literal array</td>\n    <td>no</td>\n  </tr>\n   <tr>\n    <td>Calls</td>\n    <td>no</td>\n  </tr>\n   <tr>\n    <td>New</td>\n    <td>no</td>\n  </tr>\n   <tr>\n    <td>Property access</td>\n    <td>yes, if target is foldable</td>\n  </tr>\n   <tr>\n    <td>Array index</td>\n    <td> yes, if target and index are foldable</td>\n  </tr>\n   <tr>\n    <td>Identity reference</td>\n    <td>yes, if it is a reference to a local</td>\n  </tr>\n   <tr>\n    <td>A template with no substitutions</td>\n    <td>yes</td>\n  </tr>\n   <tr>\n    <td>A template with substitutions</td>\n    <td>yes, if the substitutions are foldable</td>\n  </tr>\n   <tr>\n    <td>Literal string</td>\n    <td>yes</td>\n  </tr>\n   <tr>\n    <td>Literal number</td>\n    <td>yes</td>\n  </tr>\n   <tr>\n    <td>Literal boolean</td>\n    <td>yes</td>\n  </tr>\n   <tr>\n    <td>Literal null</td>\n    <td>yes</td>\n  </tr>\n   <tr>\n    <td>Supported prefix operator </td>\n    <td>yes, if operand is foldable</td>\n  </tr>\n   <tr>\n    <td>Supported binary operator </td>\n    <td>yes, if both left and right are foldable</td>\n  </tr>\n   <tr>\n    <td>Conditional operator</td>\n    <td>yes, if condition is foldable </td>\n  </tr>\n   <tr>\n    <td>Parentheses</td>\n    <td>yes, if the expression is foldable</td>\n  </tr>\n</table>\n-->\n<table>\n  <tbody><tr>\n    <th>문법</th>\n    <th>폴딩 가능 여부</th>\n  </tr>\n  <tr>\n    <td>객체 리터럴</td>\n    <td>가능</td>\n  </tr>\n  <tr>\n    <td>배열 리터럴</td>\n    <td>가능</td>\n  </tr>\n  <tr>\n    <td>배열 안에 사용된 전개 연산자</td>\n    <td>불가</td>\n  </tr>\n   <tr>\n    <td>함수 실행</td>\n    <td>불가</td>\n  </tr>\n   <tr>\n    <td>New</td>\n    <td>불가</td>\n  </tr>\n   <tr>\n    <td>프로퍼티 참조</td>\n    <td>대상이 폴딩 가능한 경우에 가능</td>\n  </tr>\n   <tr>\n    <td>배열 인덱스 참조</td>\n    <td>대상과 인덱스가 폴딩 가능한 경우에 가능</td>\n  </tr>\n   <tr>\n    <td>타입 참조</td>\n    <td>로컬에서 참조하는 경우 가능</td>\n  </tr>\n   <tr>\n    <td>문자열 바인딩이 없는 템플릿 문자열</td>\n    <td>가능</td>\n  </tr>\n   <tr>\n    <td>문자열 바인딩이 있는 템플릿 문자열</td>\n    <td>삽입되는 템플릿이 폴딩 가능한 경우에 가능</td>\n  </tr>\n   <tr>\n    <td>문자열 리터럴</td>\n    <td>가능</td>\n  </tr>\n   <tr>\n    <td>숫자 리터럴</td>\n    <td>가능</td>\n  </tr>\n   <tr>\n    <td>불리언 리터럴</td>\n    <td>가능</td>\n  </tr>\n   <tr>\n    <td>null 리터럴</td>\n    <td>가능</td>\n  </tr>\n   <tr>\n    <td>접두사 연산자</td>\n    <td>연산자가 폴딩 가능한 경우에 가능</td>\n  </tr>\n   <tr>\n    <td>바이너리 연산자</td>\n    <td>연산자 양쪽 항목이 모두 폴딩 가능한 경우에 가능</td>\n  </tr>\n   <tr>\n    <td>조건 연산자</td>\n    <td>조건이 폴딩 가능한 경우에 가능</td>\n  </tr>\n   <tr>\n    <td>괄호</td>\n    <td>표현식이 폴딩 가능한 경우에 가능</td>\n  </tr>\n</tbody></table>\n<!--\nIf an expression is not foldable, the collector writes it to `.metadata.json` as an [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree) for the compiler to resolve.\n-->\n<p>표현식이 폴딩될 수 없는 경우에는 콜렉터가 이 코드를 <a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\">AST</a> 형식으로 <code>.metadata.json</code>에 생성하며, 이 결과물은 이후에 AOT 컴파일러가 처리합니다.</p>\n<!--\n## Phase 2: code generation\n-->\n<h2 id=\"2단계-코드-생성\">2단계: 코드 생성<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#2단계-코드-생성\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe collector makes no attempt to understand the metadata that it collects and outputs to `.metadata.json`.\nIt represents the metadata as best it can and records errors when it detects a metadata syntax violation.\nIt's the compiler's job to interpret the `.metadata.json` in the code generation phase.\n\nThe compiler understands all syntax forms that the collector supports, but it may reject _syntactically_ correct metadata if the _semantics_ violate compiler rules.\n-->\n<p><em>콜렉터</em> 는 메타데이터를 이해하는 것이 아니라 메타데이터를 찾아서 <code>.metadata.json</code>에 모으는 역할만 합니다.\n그리고 이 과정에서 메타데이터에 사용된 문법에 오류가 있는지도 검사합니다.\n<code>.mdtadata.json</code> 파일을 해석해서 코드를 생성하는 것은 컴파일러의 역할입니다.</p>\n<p>콜렉터가 처리할 수 있는 문법은 컴파일러도 모두 처리할 수 있습니다. 다만, <em>문법</em> 은 맞지만 <em>잘못</em> 사용된 메타데이터는 컴파일러가 처리하면서 에러로 판단할 수 있습니다.</p>\n<!--\n### Public symbols\n-->\n<h3 id=\"public-심볼\">public 심볼<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#public-심볼\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe compiler can only reference _exported symbols_.\n\n* Decorated component class members must be public. You cannot make an `@Input()` property private or protected.\n* Data bound properties must also be public.\n-->\n<p>컴파일러는 <em>파일 외부로 오픈된(exported) 심볼</em> 만 참조할 수 있습니다.</p>\n<ul>\n<li>컴포넌트 클래스 멤버 중 데코레이터가 사용된 멤버는 반드시 public이어야 합니다. 그래서 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 프로퍼티도 private이나 protected로 지정되면 안됩니다.</li>\n<li>데이터 바인딩으로 연결된 프로퍼티도 반드시 public이어야 합니다.</li>\n</ul>\n<!--\n```typescript\n// BAD CODE - title is private\n@Component({\n  selector: 'app-root',\n  template: '<h1>{{title}}</h1>'\n})\nexport class AppComponent {\n  private title = 'My App'; // Bad\n}\n```\n-->\n<code-example language=\"typescript\">\n// BAD CODE - title이 private으로 지정되었습니다.\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  template: '&#x3C;h1>{{title}}&#x3C;/h1>'\n})\nexport class AppComponent {\n  private title = 'My App'; // Bad\n}\n</code-example>\n<a id=\"supported-functions\"></a>\n<!--\n### Supported classes and functions\n-->\n<h3 id=\"클래스-함수-지원\">클래스, 함수 지원<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#클래스-함수-지원\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe collector can represent a function call or object creation with `new` as long as the syntax is valid.\nThe compiler, however, can later refuse to generate a call to a _particular_ function or creation of a _particular_ object.\n\nThe compiler can only create instances of certain classes, supports only core decorators, and only supports calls to macros (functions or static methods) that return expressions.\n* New instances\n\n   The compiler only allows metadata that create instances of the class `InjectionToken` from `@angular/core`.\n\n* Supported decorators\n\n   The compiler only supports metadata for the [Angular decorators in the `@angular/core` module](api/core#decorators).\n\n* Function calls\n\n   Factory functions must be exported, named functions.\n   The AOT compiler does not support lambda expressions (\"arrow functions\") for factory functions.\n-->\n<p>콜렉터는 함수 실행이나 <code>new</code> 키워드를 사용한 객체 생성 문법을 지원합니다.\n하지만 <em>일부</em> 함수나 <em>일부</em> 객체 생성 코드는 컴파일러가 처리하지 않는 경우도 있습니다.</p>\n<p>컴파일러는 특정 클래스의 인스턴스를 생성하거나 코어 데코레이터만 지원하며, 표현식을 반환하는 매크로(함수나 static 메소드)만을 지원합니다.</p>\n<ul>\n<li>\n<p>인스턴스 생성</p>\n<p>  <code>@angular/core</code>가 제공하는 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 클래스의 인스턴스 생성만 가능합니다.</p>\n</li>\n<li>\n<p>사용할 수 있는 데코레이터</p>\n<p>  <a href=\"api/core#decorators\"><code>@angular/core</code> 모듈에 있는 Angular 데코레이터</a>만 지원합니다.</p>\n</li>\n<li>\n<p>함수 실행</p>\n<p> 팩토리 함수는 반드시 <code>export</code>로 지정되어야 하며, 함수의 이름이 있어야 합니다.\n이 때 람다 표현식(lambda expressions, arrow functions)은 사용할 수 없습니다.</p>\n</li>\n</ul>\n<a id=\"function-calls\"></a>\n<!--\n### Functions and static method calls\n-->\n<h3 id=\"함수-실행-스태틱-메소드-실행\">함수 실행, 스태틱 메소드 실행<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#함수-실행-스태틱-메소드-실행\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe collector accepts any function or static method that contains a single `return` statement.\nThe compiler, however, only supports macros in the form of functions or static methods that return an *expression*.\n\nFor example, consider the following function:\n-->\n<p>콜렉터는 일반 함수나 <code>return</code> 구문이 하나만 있는 스태틱 메소드를 처리할 수 있습니다.\n하지만 컴파일러는 <em>표현식(expression)</em>을 반환하는 함수나 스태틱 메소드만 지원합니다.</p>\n<p>다음과 같은 함수가 있다고 합시다:</p>\n<code-example language=\"typescript\">\nexport function wrapInArray&#x3C;T>(value: T): T[] {\n  return [value];\n}\n</code-example>\n<!--\nYou can call the `wrapInArray` in a metadata definition because it returns the value of an expression that conforms to the compiler's restrictive JavaScript subset.\n-->\n<p>그러면 이 <code>wrapInArray</code> 함수를 메타데이터 정의에 사용할 수 있습니다. 왜냐하면 이 함수는 컴파일러가 처리할 수 있는 형태의 결과물을 반환하기 때문입니다.</p>\n<!--\nYou might use  `wrapInArray()` like this:\n-->\n<p>그래서 이 함수는 이렇게 사용할 수 있습니다:</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: wrapInArray(TypicalComponent)\n})\nexport class TypicalModule {}\n</code-example>\n<!--\nThe compiler treats this usage as if you had written:\n-->\n<p>이 코드는 다음 코드와 동일하게 처리됩니다.</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: [TypicalComponent]\n})\nexport class TypicalModule {}\n</code-example>\n<!--\nThe Angular [`RouterModule`](api/router/RouterModule) exports two macro static methods, `forRoot` and `forChild`, to help declare root and child routes.\nReview the [source code](https://github.com/angular/angular/blob/master/packages/router/src/router_module.ts#L139 \"RouterModule.forRoot source code\")\nfor these methods to see how macros can simplify configuration of complex [NgModules](guide/ngmodules).\n-->\n<p>Angular <a href=\"api/router/RouterModule\"><code>RouterModule</code></a>가 제공하는 메소드 중 애플리케이션의 최상위 라우팅을 정의하는 <code>forRoot</code>와 자식 라우팅을 정의하는 <code>forChild</code>가 정적 매크로 메소드입니다.\n<a href=\"guide/ngmodules\">NgModules</a> 설정이 복잡할 때 매크로 함수를 활용하면 이 설정을 좀 더 간단하게 작성할 수 있습니다. <a href=\"https://github.com/angular/angular/blob/master/packages/router/src/router_module.ts#L139\" title=\"RouterModule.forRoot source code\">소스 코드</a>를 보면서 내용을 확인해 보세요.</p>\n<a id=\"metadata-rewriting\"></a>\n<!--\n### Metadata rewriting\n-->\n<h3 id=\"메타데이터-재구축\">메타데이터 재구축<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#메타데이터-재구축\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe compiler treats object literals containing the fields `useClass`, `useValue`, `useFactory`, and `data` specially, converting the expression initializing one of these fields into an exported variable that replaces the expression.\nThis process of rewriting these expressions removes all the restrictions on what can be in them because\nthe compiler doesn't need to know the expression's value&mdash;it just needs to be able to generate a reference to the value.\n-->\n<p>AOT 컴파일러는 메타데이터에 사용된 <code>useClass</code>, <code>useValue</code>, <code>useFactory</code>에 사용된 객체 리터럴과 <code>data</code> 프로퍼티를 처리해서 각각 <code>export</code>로 지정된 변수로 변환합니다.\n컴파일러는 이 필드에 사용된 표현식 자체를 알 필요는 없습니다. 단순하게 결과만 참조하면 됩니다.</p>\n<!--\nYou might write something like:\n-->\n<p>다음과 같은 코드가 있다고 합시다:</p>\n<code-example language=\"typescript\">\nclass TypicalServer {\n\n}\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  providers: [{provide: SERVER, useFactory: () => TypicalServer}]\n})\nexport class TypicalModule {}\n</code-example>\n<!--\nWithout rewriting, this would be invalid because lambdas are not supported and `TypicalServer` is not exported.\nTo allow this, the compiler automatically rewrites this to something like:\n-->\n<p>메타데이터 재구축 과정이 없다면 이 코드는 처리되지 않습니다. 왜나하면 AOT 컴파일러는 람다 함수를 지원하지 않으며, <code>TypicalServer</code> 클래스도 <code>export</code>로 지정되지 않았기 때문입니다.\n하지만 이 코드는 메타데이터 재구축 과정을 거치면서 다음과 같이 변환됩니다:</p>\n<code-example language=\"typescript\">\nclass TypicalServer {\n\n}\n\nexport const ɵ0 = () => new TypicalServer();\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  providers: [{provide: SERVER, useFactory: ɵ0}]\n})\nexport class TypicalModule {}\n</code-example>\n<!--\nThis allows the compiler to generate a reference to `ɵ0` in the factory without having to know what the value of `ɵ0` contains.\n\nThe compiler does the rewriting during the emit of the `.js` file.\nIt does not, however, rewrite the `.d.ts` file, so TypeScript doesn't recognize it as being an export. and it does not interfere with the ES module's exported API.\n-->\n<a id=\"binding-expression-validation\"></a>\n<!--\n## Phase 3: Template type checking\n-->\n<h3 id=\"3단계-템플릿-타입-체크\">3단계: 템플릿 타입 체크<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#3단계-템플릿-타입-체크\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nOne of the Angular compiler's most helpful features is the ability to type-check expressions within templates, and catch any errors before they cause crashes at runtime.\nIn the template type-checking phase, the Angular template compiler uses the TypeScript compiler to validate the binding expressions in templates.\n\nEnable this phase explicitly by adding the compiler option `\"fullTemplateTypeCheck\"` in the `\"angularCompilerOptions\"` of the project's TypeScript configuration file\n(see [Angular Compiler Options](guide/angular-compiler-options)).\n-->\n<p>템플릿 표현식에 사용된 코드의 타입을 체크하는 기능은 Angular 컴파일러가 제공하는 기능 중 가장 훌륭한 기능이라고도 할 수 있습니다.\n이 기능을 활용하면 실행 시점에 발생하는 문제로 앱이 종료되는 것을 미리 방지할 수 있기 때문입니다.\n이 단계에서는 Angular 템플릿 컴파일러가 TypeScript 컴파일러를 활용해서 템플릿에 사용된 바인딩 표현식의 유효성을 검증합니다.</p>\n<p>이 단계는 프로젝트의 환경설정 파일의 컴파일러 옵션 섹션인 <code>\"angularCompilerOptions\"</code>에 <code>\"fullTemplateTypeCheck\"</code> 옵션을 지정하면 명시적으로 활성화할 수 있습니다.\n자세한 내용은 <a href=\"guide/angular-compiler-options\">Angular 컴파일러 옵션</a> 문서를 참고하세요.</p>\n<div class=\"alert is-helpful\">\n<!--\nIn [Angular Ivy](guide/ivy), the template type checker has been completely rewritten to be more capable as well as stricter, meaning it can catch a variety of new errors that the previous type checker would not detect.\n\nAs a result, templates that previously compiled under View Engine can fail type checking under Ivy. This can happen because Ivy's stricter checking catches genuine errors, or because application code is not typed correctly, or because the application uses libraries in which typings are inaccurate or not specific enough.\n\nThis stricter type checking is not enabled by default in version 9, but can be enabled by setting the `strictTemplates` configuration option.\nWe do expect to make strict type checking the default in the future.\n\nFor more information about type-checking options, and about improvements to template type checking in version 9 and above, see [Template type checking](guide/template-typecheck).\n-->\n<p><a href=\"guide/ivy\">Angular Ivy</a>에 사용된 템플릿 타입 체커는 이전 버전보다 강력한 룰을 적용할 수 있도록 완전히 새로 작성되었습니다.\n이제는 이전 버전에서 발견하지 못했던 에러도 확실하게 검출할 수 있습니다.</p>\n<p>다만, 이렇게 변경되면서 이전의 View Engine에서 정상 컴파일되었던 템플릿이 Ivy에서는 컴파일되지 않을 수 있습니다.\n이것은 새로운 템플릿 엔진인 Angular Ivy가 검사하는 룰이 좀 더 강력해진 것이 직접적인 원인이지만, 애플리케이션 코드의 타입이 제대로 지정되지 않았거나, 타입정보가 부족한 라이브러리를 사용했기 때문에 발생하는 문제일 수도 있습니다.</p>\n<p>Angular 9버전의 기본 설정은 좀 더 깐깐한 타입 체크 기능을 사용하지 않는 것입니다.\n아직까지는 컴파일러 설정 파일에 <code>strictTemplates</code> 옵션을 지정해야 활성화할 수 있지만, 언젠가는 이 방식이 기본이 되기를 바랍니다.</p>\n<p>For more information about type-checking options, and about improvements to template type checking in version 9 and above, see <a href=\"guide/template-typecheck\">Template type checking</a>.</p>\n</div>\n<!--\nTemplate validation produces error messages when a type error is detected in a template binding\nexpression, similar to how type errors are reported by the TypeScript compiler against code in a `.ts`\nfile.\n\nFor example, consider the following component:\n-->\n<p>템플릿의 유효성을 검사하다가 에러가 발생하면 이 에러가 어디서 발생했는지 콘솔에 표시됩니다.\nTypeScript 컴파일러로 <code>.ts</code> 파일을 컴파일하다가 에러를 확인하는 것과 비슷합니다.</p>\n<p>다음과 같은 컴포넌트 코드를 봅시다:</p>\n<code-example language=\"typescript\">\n  @<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n    selector: 'my-component',\n    template: '{{person.addresss.street}}'\n  })\n  class MyComponent {\n    person?: Person;\n  }\n</code-example>\n<!--\nThis produces the following error:\n-->\n<p>이 컴포넌트의 템플릿에서 발생하는 에러는 다음과 같이 표시됩니다:</p>\n<code-example>\n  my.component.ts.MyComponent.html(1,1): : Property 'addresss' does not exist on type 'Person'. Did you mean 'address'?\n</code-example>\n<!--\nThe file name reported in the error message, `my.component.ts.MyComponent.html`, is a synthetic file\ngenerated by the template compiler that holds contents of the `MyComponent` class template.\nThe compiler never writes this file to disk.\nThe line and column numbers are relative to the template string in the `@Component` annotation of the class, `MyComponent` in this case.\nIf a component uses `templateUrl` instead of `template`, the errors are reported in the HTML file referenced by the `templateUrl` instead of a synthetic file.\n\nThe error location is the beginning of the text node that contains the interpolation expression with the error.\nIf the error is in an attribute binding such as `[value]=\"person.address.street\"`, the error\nlocation is the location of the attribute that contains the error.\n\nThe validation uses the TypeScript type checker and the options supplied to the TypeScript compiler to control how detailed the type validation is.\nFor example, if the `strictTypeChecks` is specified, the error\n// ```my.component.ts.MyComponent.html(1,1): : Object is possibly 'undefined'```\nis reported as well as the above error message.\n-->\n<p>에러 메시지에 표시된 파일 이름은 <code>my.component.ts.MyComponent.html</code>인데, 이 내용을 해석해 보면 <code>MyComponent</code> 클래스가 정의된 코드의 템플릿에서 에러가 발생했다는 것을 확인할 수 있습니다.\n컴파일러는 템플릿 파일을 디스크에 따로 저장하지 않습니다.\n그리고 에러 메시지로 출력되는 에러 위치는 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 어노테이션을 기준으로 한 상대 위치로 표시됩니다.\n컴포넌트에 <code>template</code> 대신 <code>templateUrl</code>을 사용했다면, 에러 메시지는 컴포넌트 클래스 파일 대신 HTML 파일을 가리키는 방식으로 출력됩니다.</p>\n<p>위 코드에서 에러가 발생한 위치는 문자열 바인딩이 사용된 첫번째 텍스트 노드입니다.\n에러가 <code>[value]=\"person.address.street\"</code>와 같은 어트리뷰트 바인딩에서 발생했다면 에러가 발생한 위치로 어트리뷰트의 위치가 표시됩니다.</p>\n<p>템플릿 표현식의 유효성을 검사하는 로직은 TypeScript가 제공하는 타입 체커를 활용하기 때문에 TypeScript 컴파일러에 사용할 수 있는 옵션은 이 단계에서도 사용할 수 있습니다.\n그래서 <code>strictTypeChecks</code> 옵션이 지정되면 위 코드를 처리하면서\n<code>my.component.ts.MyComponent.html(1,1): : Object is possibly 'undefined'</code>\n라는 에러가 출력됩니다.</p>\n<!--\n### Type narrowing\n-->\n<h3 id=\"타입-구체화하기\">타입 구체화하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#타입-구체화하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe expression used in an `ngIf` directive is used to narrow type unions in the Angular\ntemplate compiler, the same way the `if` expression does in TypeScript.\nFor example, to avoid `Object is possibly 'undefined'` error in the template above, modify it to only emit the interpolation if the value of `person` is initialized as shown below:\n-->\n<p>템플릿 표현식에 사용된 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>는 TypeScript 코드에 사용하는 <code>if</code>와 마찬가지로 타입을 구체화하는 역할을 합니다.\n그래서 위에서 살펴본 템플릿에서 발생하는 <code>Object is possibly 'undefined'</code> 에러는 아래 코드에서 발생하지 않습니다.\n템플릿에 사용된 문자열 바인딩 문법은 <code>person</code> 변수가 초기화된 이후에만 동작하기 때문입니다:</p>\n<code-example language=\"typescript\">\n  @<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n    selector: 'my-component',\n    template: '&#x3C;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"person\"> {{person.addresss.street}} &#x3C;/span>'\n  })\n  class MyComponent {\n    person?: Person;\n  }\n</code-example>\n<!--\nUsing `*ngIf` allows the TypeScript compiler to infer that the `person` used in the binding expression will never be `undefined`.\n-->\n<p><code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>를 사용하면 TypeScript 컴파일러가 <code>person</code> 객체의 타입을 추론할 수 있기 때문에 이 객체가 <code>undefined</code>라면 바인딩 표현식도 실행되지 않습니다.</p>\n<p>For more information about input type narrowing, see <a href=\"guide/template-typecheck#input-setter-coercion\">Input setter coercion</a> and <a href=\"guide/structural-directives#directive-type-checks\">Improving template type checking for custom directives</a>.</p>\n<!--\n### Non-null type assertion operator\n-->\n<h3 id=\"null값-아님-보장-연산자\">null값 아님 보장 연산자<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#null값-아님-보장-연산자\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nUse the [non-null type assertion operator](guide/template-expression-operators#non-null-assertion-operator) to suppress the `Object is possibly 'undefined'` error when it is inconvenient to use `*ngIf` or when some constraint in the component ensures that the expression is always non-null when the binding expression is interpolated.\n\nIn the following example, the `person` and `address` properties are always set together, implying that `address` is always non-null if `person` is non-null.\nThere is no convenient way to describe this constraint to TypeScript and the template compiler, but the error is suppressed in the example by using `address!.street`.\n-->\n<p>표현식에 문자열 바인딩 문법을 사용할 때 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>를 사용해도 <code>Object is possibly 'undefined'</code> 에러를 방지할 수 있지만, <a href=\"guide/template-expression-operators#non-null-assertion-operator\">nnull값 아님 보장 연산자(non-null assertion operator)</a>를 사용해도 이 에러를 방지할 수 있습니다.</p>\n<p>컴포넌트 프로퍼티 <code>person</code>과 <code>address</code>의 값은 동시에 할당되기 때문에 <code>person</code>만 검사하면 <code>address</code>가 null이 아니라는 것을 보장할 수 있습니다.\n하지만 TypeScript나 템플릿 컴파일러는 이 정보를 알 수 없기 때문에 <code>address</code> 프로퍼티에 대해 <code>Object is possibly 'undefined'</code> 에러가 발생할 수 있습니다.\n이 경우에 <code>address!.street</code>라는 표현식을 사용하면 <code>address</code>가 null이 아닐 때만 <code>street</code> 프로퍼티를 참조하라는 정보를 추가로 제공할 수 있습니다.</p>\n<code-example language=\"typescript\">\n  @<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n    selector: 'my-component',\n    template: '&#x3C;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"person\"> {{person.name}} lives on {{address!.street}} &#x3C;/span>'\n  })\n  class MyComponent {\n    person?: Person;\n    address?: Address;\n\n    setData(person: Person, address: Address) {\n      this.person = person;\n      this.address = address;\n    }\n  }\n</code-example>\n<!--\nThe non-null assertion operator should be used sparingly as refactoring of the component might break this constraint.\n\nIn this example it is recommended to include the checking of `address` in the `*ngIf` as shown below:\n-->\n<p>다만 null값 아님 보장 연산자는 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 디렉티브가 제공하는 타입 제약을 무시할 수 있기 때문에 남용하면 안됩니다.</p>\n<p>위와 같은 코드라면 null값 아님 보장 연산자를 사용하는 대신 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 조건에 <code>address</code>를 넣는 것이 더 좋습니다.</p>\n<code-example language=\"typescript\">\n  @<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n    selector: 'my-component',\n    template: '&#x3C;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"person &#x26;&#x26; address\"> {{person.name}} lives on {{address.street}} &#x3C;/span>'\n  })\n  class MyComponent {\n    person?: Person;\n    address?: Address;\n\n    setData(person: Person, address: Address) {\n      this.person = person;\n      this.address = address;\n    }\n  }\n</code-example>\n\n</div>\n\n<!-- links to this doc:\n - api/upgrade\n - api/upgrade/UpgradeAdapter\n - api/upgrade/UpgradeAdapterRef\n - guide/angular-compiler-options\n - guide/aot-metadata-errors\n - guide/architecture-next-steps\n - guide/creating-libraries\n - guide/deployment\n - guide/file-structure\n - guide/npm-packages\n - guide/template-expression-operators\n - guide/universal\n - guide/upgrade\n - guide/upgrade-performance\n - guide/upgrade-setup\n-->\n<!-- links from this doc:\n - api/common/NgIf\n - api/core#decorators\n - api/core/Component\n - api/core/InjectionToken\n - api/core/Input\n - api/core/NgModule\n - api/router/RouterModule\n - cli\n - cli/build\n - cli/serve\n - guide/angular-compiler-options\n - guide/aot-compiler#1단계-분석\n - guide/aot-compiler#2단계-코드-생성\n - guide/aot-compiler#3단계-템플릿-타입-체크\n - guide/aot-compiler#ahead-of-time-aot-컴파일러\n - guide/aot-compiler#aot-컴파일-설정하기\n - guide/aot-compiler#aot-컴파일러가-동작하는-방식\n - guide/aot-compiler#code-folding\n - guide/aot-compiler#expression-syntax\n - guide/aot-compiler#null값-아님-보장-연산자\n - guide/aot-compiler#public-심볼\n - guide/aot-compiler#supported-functions\n - guide/aot-compiler#메타데이터-재구축\n - guide/aot-compiler#메타데이터의-제약사항\n - guide/aot-compiler#컴파일-단계\n - guide/aot-compiler#컴파일러-선택하기\n - guide/aot-compiler#코드-폴딩-code-folding\n - guide/aot-compiler#클래스-함수-지원\n - guide/aot-compiler#타입-구체화하기\n - guide/aot-compiler#폴딩할-수-있는-문법\n - guide/aot-compiler#표현식expression-syntax의-한계\n - guide/aot-compiler#함수-실행-스태틱-메소드-실행\n - guide/aot-compiler#화살표-함수는-사용할-수-없습니다\n - guide/aot-metadata-errors\n - guide/build\n - guide/glossary#aot\n - guide/ivy\n - guide/ngmodules\n - guide/structural-directives#directive-type-checks\n - guide/template-expression-operators#non-null-assertion-operator\n - guide/template-typecheck\n - guide/template-typecheck#input-setter-coercion\n - guide/typescript-configuration\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function\n - https://en.wikipedia.org/wiki/Abstract_syntax_tree\n - https://github.com/angular/angular/blob/master/packages/compiler-cli/src/metadata/schema.ts\n - https://github.com/angular/angular/blob/master/packages/router/src/router_module.ts#L139\n - https://github.com/angular/angular/edit/master/aio/content/guide/aot-compiler.md?message=docs%3A%20describe%20your%20change...\n - https://medium.com/sparkles-blog/angular-writing-aot-friendly-applications-7b64c8afbe3f\n - https://www.youtube.com/watch?v=anphffaCZrQ\n-->"
}