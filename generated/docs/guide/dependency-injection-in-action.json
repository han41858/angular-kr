{
  "id": "guide/dependency-injection-in-action",
  "title": "실전 의존성 주입",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/dependency-injection-in-action.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Dependency Injection in Action\n-->\n<h1 id=\"실전-의존성-주입\">실전 의존성 주입<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#실전-의존성-주입\"><i class=\"material-icons\">link</i></a></h1>\n<!--\nThis section explores many of the features of dependency injection (DI) in Angular.\n-->\n<p>이 문서는 Angular에서 활용할 수 있는 다양한 의존성 주입 테크닉에 대해 소개합니다.</p>\n<a id=\"toc\"></a>\n<!--\nSee the <live-example name=\"dependency-injection-in-action\"></live-example>\nof the code in this cookbook.\n-->\n<p>이 문서에서 다루는 예제는 <live-example name=\"dependency-injection-in-action\"></live-example>에서 직접 실행하거나 다운받아 확인할 수 있습니다.</p>\n<a id=\"nested-dependencies\"></a>\n<!--\n## Nested service dependencies\n-->\n<h2 id=\"중첩된-서비스-의존성\">중첩된 서비스 의존성<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#중첩된-서비스-의존성\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe _consumer_ of an injected service doesn't need to know how to create that service.\nIt's the job of the DI framework to create and cache dependencies. The consumer just\nneeds to let the DI framework know which dependencies it needs.\n\nSometimes a service depends on other services, which may depend on yet other services.\nThe dependency injection framework resolves these nested dependencies in the correct order.\nAt each step, the consumer of dependencies declares what it requires in its\nconstructor, and lets the framework provide them.\n\nThe following example shows that `AppComponent` declares its dependence on `LoggerService` and `UserContext`.\n-->\n<p>서비스를 의존성으로 주입받아 <em>사용하는 쪽</em> 에서는 이 서비스가 어떻게 생성되었는지 신경쓸 필요가 없습니다.\n의존성 객체를 생성하고 관리하는 것은 온전히 프레임워크의 역할입니다. 의존성을 주입받는 쪽에서는 프레임워크에게 필요한 객체를 요청하기만 하면 됩니다.</p>\n<p>때로는 의존성으로 주입되는 서비스도 다른 서비스를 다시 의존성으로 주입받아야 하는 경우가 있습니다.\n이 때 서비스들을 순서대로 처리하는 것도 프레임워크가 하는 일입니다.\n생성자에서 의존성으로 요청할 객체의 타입을 지정하면 프레임워크가 이 생성자들의 처리 순서를 판단해서 요청하는 타입에 맞는 객체의 인스턴스를 생성해서 주입합니다.</p>\n<p>아래 코드는 <code>AppComponent</code>의 생성자가 <code>LoggerService</code>와 <code>UserContext</code>를 의존성으로 주입받도록 요청하는 예제 코드입니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/app.component.ts\" region=\"ctor\" header=\"src/app/app.component.ts\" linenums=\"false\">\nconstructor(logger: LoggerService, public userContext: UserContextService) {\n  userContext.loadUser(this.userId);\n  logger.logInfo('AppComponent initialized');\n}\n\n</code-example>\n<!--\n`UserContext` in turn depends on both `LoggerService` and\n`UserService`, another service that gathers information about a particular user.\n-->\n<p>그런데 <code>UserContext</code>에서도 <code>LoggerService</code>와 <code>UserService</code>를 의존성으로 주입받도록 요청합니다. 이 서비스는 특정 사용자에 대한 정보를 가져올 때 사용합니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/user-context.service.ts\" region=\"injectables\" header=\"user-context.service.ts (injection)\" linenums=\"false\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root'\n})\nexport class UserContextService {\n  constructor(private userService: UserService, private loggerService: LoggerService) {\n  }\n}\n\n</code-example>\n<!--\nWhen Angular creates `AppComponent`, the DI framework creates an instance of `LoggerService` and starts to create `UserContextService`.\n`UserContextService` also needs `LoggerService`, which the framework already has, so the framework can provide the same instance. `UserContextService` also needs `UserService`, which the framework has yet to create. `UserService` has no further dependencies, so the framework can simply use `new` to instantiate the class and provide the instance to the `UserContextService` constructor.\n\nThe parent `AppComponent` doesn't need to know about the dependencies of dependencies.\nDeclare what's needed in the constructor (in this case `LoggerService` and `UserContextService`)\nand the framework resolves the nested dependencies.\n\nWhen all dependencies are in place, `AppComponent` displays the user information.\n-->\n<p>그러면 Angular가 <code>AppComponent</code>를 생성할 때 <code>LoggerService</code>와 <code>UserContextService</code>의 인스턴스를 먼저 생성합니다.\n그런데 <code>UserContextService</code>에서 필요한 <code>LoggerService</code>의 인스턴스는 이미 프레임워크가 생성했기 때문에 이전에 만들었던 인스턴스를 다시 활용합니다. 이 시점에 <code>UserContextService</code>에 필요한 <code>UserService</code>는 아직 생성되지 않았습니다. <code>UserService</code>는 추가로 필요한 의존성이 없기 때문에 프레임워크는 간단하게 <code>new</code> 키워드를 사용해서 <code>UserService</code>의 인스턴스를 생성하고 이 인스턴스를 <code>UserContextService</code>의 생성자에 주입합니다.</p>\n<p><code>AppComponent</code>의 입장에서는 의존성 객체가 또다른 의존성을 갖는지 신경쓸 필요가 없습니다.\n원하는 객체 타입을 생성자에 지정하기만 하면 프레임워크가 모두 처리할 것입니다.</p>\n<p>그리고 모든 의존성 관계가 정리되면 <code>AppComponent</code>가 화면에 표시됩니다.</p>\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/logged-in-user.png\" alt=\"Logged In User\" width=\"145\" height=\"99\">\n</figure>\n<a id=\"service-scope\"></a>\n<!--\n## Limit service scope to a component subtree\n-->\n<h2 id=\"서비스가-주입될-수-있는-범위를-특정-컴포넌트로-제한하기\">서비스가 주입될 수 있는 범위를 특정 컴포넌트로 제한하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#서비스가-주입될-수-있는-범위를-특정-컴포넌트로-제한하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAn Angular application has multiple injectors, arranged in a tree hierarchy that parallels the component tree.\nEach injector creates a singleton instance of a dependency.\nThat same instance is injected wherever that injector provides that service.\nA particular service can be provided and created at any level of the injector hierarchy,\nwhich means that there can be multiple instances of a service if it is provided by multiple injectors.\n\nDependencies provided by the root injector can be injected into *any* component *anywhere* in the application.\nIn some cases, you might want to restrict service availability to a particular region of the application.\nFor instance, you might want to let users explicitly opt in to use a service,\nrather than letting the root injector provide it automatically.\n\nYou can limit the scope of an injected service to a *branch* of the application hierarchy\nby providing that service *at the sub-root component for that branch*.\nThis example shows how to make a different instance of `HeroService` available to `HeroesBaseComponent`\nby adding it to the `providers` array of the `@Component()` decorator of the sub-component.\n-->\n<p>Angular 애플리케이션의 인젝터는 동시에 여러 개가 존재하며, 컴포넌트 트리의 구조에 따라 트리 형태로 구성되고 계층에 따라서 병렬로 존재하는 경우도 있습니다.\n각각의 인젝터는 해당 인젝터에 등록된 의존성 객체의 싱글턴 인스턴스를 생성하고 관리하며, 이 인젝터가 주입하는 서비스는 모두 같은 인스턴스입니다.\n그런데 서비스 프로바이더는 다양한 인젝터 계층에 등록될 수 있기 때문에, 특정 서비스의 인스턴스도 여러 인젝터에 동시에 존재할 수 있습니다.</p>\n<p>애플리케이션의 최상위 인젝터가 관리하는 의존성 객체의 인스턴스는 애플리케이션 <em>전역</em>의 컴포넌트에 자유롭게 주입될 수 있습니다.\n그런데 어떤 경우에는 특정 서비스를 애플리케이션 일부 범위에서만 사용할 수 있도록 제한하고 싶은 경우가 있습니다.\n최상위 인젝터가 아무 제한없이 의존성으로 주입하는 대신, 명시적으로 지정한 서비스를 사용하도록 하려고 합니다.</p>\n<p>서비스 프로바이더를 <em>컴포넌트 트리의 특정 브랜치</em>에 등록하면 해당 <em>브랜치</em> 범위에 이 서비스를 사용하도록 지정할 수 있습니다.\n아래 예제는 <code>HeroService</code>의 프로바이더를 <code>HeroesBaseComponent</code> 계층의 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 데코레이터 <code>providers</code> 배열에 등록한 예제 코드입니다. 이렇게 구현하면 <code>HeroesBaseComponent</code> 상위 컴포넌트 트리와는 별개로 이 계층에 새로운 <code>HeroService</code>의 인스턴스가 생성됩니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/sorted-heroes.component.ts\" region=\"injection\" header=\"src/app/sorted-heroes.component.ts (HeroesBaseComponent excerpt)\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-unsorted-heroes',\n  template: `&#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">{{hero.name}}&#x3C;/div>`,\n  providers: [HeroService]\n})\nexport class HeroesBaseComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  constructor(private heroService: HeroService) { }\n}\n\n</code-example>\n<!--\nWhen Angular creates `HeroesBaseComponent`, it also creates a new instance of `HeroService`\nthat is visible only to that component and its children, if any.\n\nYou could also provide `HeroService` to a different component elsewhere in the application.\nThat would result in a different instance of the service, living in a different injector.\n-->\n<p>이제 Angular가 <code>HeroesBaseComponent</code>의 인스턴스를 생성하면 <code>HeroService</code>의 인스턴스도 새로 생성합니다. 그리고 <code>HeroesBaseComponent</code>와 이 컴포넌트의 자식 컴포넌트에서 <code>HeroService</code>를 의존성으로 요청하면 이 인스턴스가 사용됩니다.</p>\n<p><code>HeroService</code>의 프로바이더는 다른 컴포넌트에도 등록할 수 있습니다.\n결국 서로 다른 인젝터에 서로 다른 서비스 인스턴스가 존재하게 됩니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nExamples of such scoped `HeroService` singletons appear throughout the accompanying sample code,\nincluding `HeroBiosComponent`, `HeroOfTheMonthComponent`, and `HeroesBaseComponent`.\nEach of these components has its own `HeroService` instance managing its own independent collection of heroes.\n-->\n<p>이 문서에서 다루는 예제 코드에서 <code>HeroService</code>의 프로바이더를 등록하는 로직은 <code>HeroBiosComponent</code>, <code>HeroOfTheMonthComponent</code>, <code>HeroesBaseComponent</code>에 각각 사용되었습니다.\n그래서 각각의 컴포넌트는 독자적인 <code>HeroService</code> 인스턴스를 관리하며, 이들 컴포넌트가 관리하는 히어로의 목록도 서로 다릅니다.</p>\n</div>\n<a id=\"multiple-service-instances\"></a>\n<!--\n## Multiple service instances (sandboxing)\n-->\n<h2 id=\"다중-서비스-인스턴스-샌드박싱-sandboxing\">다중 서비스 인스턴스 (샌드박싱, sandboxing)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#다중-서비스-인스턴스-샌드박싱-sandboxing\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nSometimes you want multiple instances of a service at *the same level* of the component hierarchy.\n\nA good example is a service that holds state for its companion component instance.\nYou need a separate instance of the service for each component.\nEach service has its own work-state, isolated from the service-and-state of a different component.\nThis is called *sandboxing* because each service and component instance has its own sandbox to play in.\n-->\n<p>어떤 경우에는 <em>같은 계층의</em> 컴포넌트마다 서비스 인스턴스를 각각 유지해야 하는 경우가 있습니다.</p>\n<p>히어로 정보 관리 컴포넌트로 이 경우를 생각해 봅시다.\n이 예제에서는 컴포넌트마다 서비스 인스턴스를 하나씩 두려고 합니다.\n그리고 각각의 서비스 인스턴스가 현재 작업 상태를 저장하며, 다른 컴포넌트의 작업 상태에 영향을 받지 않게 하려고 합니다.\n이런 구조를 샌드박싱(sandboxing)이라고 합니다. 이 구조에서 서비스와 컴포넌트 인스턴스는 서로 연관된 것들끼리만 동작합니다.</p>\n<a id=\"hero-bios-component\"></a>\n<!--\nIn this example, `HeroBiosComponent` presents three instances of `HeroBioComponent`.\n-->\n<p>이번 예제에서 <code>HeroBiosComponent</code>에는 <code>HeroBioComponent</code> 인스턴스가 다음과 같이 3개 존재합니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-bios.component.ts\" region=\"simple\" header=\"ap/hero-bios.component.ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-bios',\n  template: `\n    &#x3C;app-hero-bio [heroId]=\"1\">&#x3C;/app-hero-bio>\n    &#x3C;app-hero-bio [heroId]=\"2\">&#x3C;/app-hero-bio>\n    &#x3C;app-hero-bio [heroId]=\"3\">&#x3C;/app-hero-bio>`,\n  providers: [HeroService]\n})\nexport class HeroBiosComponent {\n}\n\n</code-example>\n<!--\nEach `HeroBioComponent` can edit a single hero's biography.\n`HeroBioComponent` relies on `HeroCacheService` to fetch, cache, and perform other persistence operations on that hero.\n-->\n<p>각각의 <code>HeroBioComponent</code>에서는 히어로 한 명의 정보를 편집할 수 있습니다.\n그리고 히어로의 정보를 가져오거나 캐싱하고, 수정할 때는 <code>HeroCacheService</code>를 활용합니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-cache.service.ts\" region=\"service\" header=\"src/app/hero-cache.service.ts\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class HeroCacheService {\n  hero: Hero;\n  constructor(private heroService: HeroService) {}\n\n  fetchCachedHero(id: number) {\n    if (!this.hero) {\n      this.hero = this.heroService.getHeroById(id);\n    }\n    return this.hero;\n  }\n}\n\n</code-example>\n<!--\nThree instances of `HeroBioComponent` can't share the same instance of `HeroCacheService`,\nas they'd be competing with each other to determine which hero to cache.\n\nInstead, each `HeroBioComponent` gets its *own* `HeroCacheService` instance\nby listing `HeroCacheService` in its metadata `providers` array.\n-->\n<p>이 때 개별 <code>HeroBioComponent</code>가 <code>HeroCacheService</code> 인스턴스를 모두 공유한다면 각 컴포넌트에서 작업하는 히어로의 정보를 서로 덮어쓰기 때문에 정상적으로 동작하지 않습니다.</p>\n<p>그래서 <code>HeroBioComponent</code> 메타데이터의 <code>providers</code> 배열에 <code>HeroCacheService</code> 프로바이더를 등록하면 각 컴포넌트마다 독립된 <code>HeroCacheService</code> 인스턴스를 생성할 수 있습니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-bio.component.ts\" region=\"component\" header=\"src/app/hero-bio.component.ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-bio',\n  template: `\n    &#x3C;h4>{{hero.name}}&#x3C;/h4>\n    &#x3C;ng-content>&#x3C;/ng-content>\n    &#x3C;<a href=\"api/forms/DefaultValueAccessor\" class=\"code-anchor\">textarea</a> cols=\"25\" [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.description\">&#x3C;/<a href=\"api/forms/DefaultValueAccessor\" class=\"code-anchor\">textarea</a>>`,\n  providers: [HeroCacheService]\n})\n\nexport class HeroBioComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>  {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() heroId: number;\n\n  constructor(private heroCache: HeroCacheService) { }\n\n  ngOnInit() { this.heroCache.fetchCachedHero(this.heroId); }\n\n  get hero() { return this.heroCache.hero; }\n}\n\n</code-example>\n<!--\nThe parent `HeroBiosComponent` binds a value to `heroId`.\n`ngOnInit` passes that ID to the service, which fetches and caches the hero.\nThe getter for the `hero` property pulls the cached hero from the service.\nThe template displays this data-bound property.\n\nFind this example in <live-example name=\"dependency-injection-in-action\">live code</live-example>\nand confirm that the three `HeroBioComponent` instances have their own cached hero data.\n-->\n<p>부모 컴포넌트인 <code>HeroBiosComponent</code>는 자식 컴포넌트의 <code>heroId</code> 프로퍼티에 히어로의 ID를 바인딩합니다.\n그리고 자식 컴포넌트의 <code>ngOnInit()</code> 메소드에서 이 ID를 서비스로 전달하면 서비스가 해당되는 히어로의 정보를 가져와서 캐싱합니다.\n<code>hero</code> 프로퍼티에 사용된 게터 함수는 컴포넌트가 아니라 서비스에서 히어로의 정보를 가져오기 위해 선언했습니다.\n템플릿은 이 프로퍼티를 데이터 바인딩해서 표시합니다.</p>\n<p>이제 <code>HeroBioComponent</code>의 인스턴스 3개는 모두 독립된 히어로의 정보를 캐싱할 수 있습니다. 이 예제는 <live-example name=\"dependency-injection-in-action\">라이브 예제 링크</live-example>에서 직접 확인하거나 다운받아 확인할 수 있습니다.</p>\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/hero-bios.png\" alt=\"Bios\" width=\"199\" height=\"317\">\n</figure>\n<a id=\"qualify-dependency-lookup\"></a>\n<!--\n## Qualify dependency lookup with parameter decorators\n-->\n<h2 id=\"인자-데코레이터로-의존성-객체-보정하기\">인자 데코레이터로 의존성 객체 보정하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#인자-데코레이터로-의존성-객체-보정하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nWhen a class requires a dependency, that dependency is added to the constructor as a parameter.\nWhen Angular needs to instantiate the class, it calls upon the DI framework to supply the dependency.\nBy default, the DI framework searches for a provider in the injector hierarchy,\nstarting at the component's local injector of the component, and if necessary bubbling up\nthrough the injector tree until it reaches the root injector.\n-->\n<p>클래스에 의존성 객체를 주입하려면 생성자 인자에 의존성 객체의 타입을 지정하면 됩니다.\n그러면 Angular가 이 클래스의 인스턴스를 생성하면서 의존성 주입 프레임워크에 의존성 객체의 인스턴스를 요청합니다.\n의존성 주입 프레임워크는 인젝터 계층을 따라가면서 프로바이더를 찾기 시작하는데, 이 과정은 의존성 객체 주입을 요청한 컴포넌트 클래스의 인젝터부터 애플리케이션 최상위 인젝터에 도달할 때까지 버블링됩니다.</p>\n<!--\n* The first injector configured with a provider supplies the dependency (a service instance or value) to the constructor.\n\n* If no provider is found in the root injector, the DI framework throws an error.\n-->\n<ul>\n<li>\n<p>의존성 객체를 찾는 과정에서 처음 만나는 프로바이더를 사용해서 인스턴스를 생성하고, 의존성 주입을 요청한 클래스의 생성자에 주입합니다.</p>\n</li>\n<li>\n<p>애플리케이션 최상위 인젝터에 도달할 때까지 프로바이더를 찾지 못하면 에러가 발생합니다.</p>\n</li>\n</ul>\n<!--\nThere are a number of options for modifying the default search behavior, using _parameter decorators_\non the service-valued parameters of a class constructor.\n-->\n<p>그런데 클래스 생성자에 <em>인자 데코레이터(parameter decorators)</em> 를 지정하면 의존성을 찾는 과정을 조정할 수 있습니다. 이 데코레이터들에 대해 알아봅시다.</p>\n<a id=\"optional\"></a>\n<!--\n### Make a dependency `@Optional` and limit search with `@Host`\n-->\n<h3 id=\"생략해도-되는-optional과-탐색-범위를-제한하는-host\">생략해도 되는 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code>과 탐색 범위를 제한하는 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#생략해도-되는-optional과-탐색-범위를-제한하는-host\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nDependencies can be registered at any level in the component hierarchy.\nWhen a component requests a dependency, Angular starts with that component's injector\nand walks up the injector tree until it finds the first suitable provider.\nAngular throws an error if it can't find the dependency during that walk.\n\nIn some cases, you need to limit the search or accommodate a missing dependency.\nYou can modify Angular's search behavior with the `@Host` and `@Optional` qualifying\ndecorators on a service-valued parameter of the component's constructor.\n-->\n<p>의존성 객체는 컴포넌트 계층 중 어떠한 곳에도 자유롭게 등록할 수 있습니다.\n그래서 컴포넌트 클래스가 의존성 객체를 요청하면 Angular는 해당 컴포넌트의 인젝터부터 프로바이더를 찾기 시작하며, 원하는 프로바이더를 찾을 때까지 인젝터 트리를 따라 올라갑니다.\n그리고 어디에서도 의존성 객체를 찾지 못하면 에러가 발생합니다.</p>\n<p>그런데 의존성 객체를 찾는 범위를 제한하거나, 의존성 객체를 찾지 못하는 것을 허용할 수도 있습니다.\n생성자에 선언한 인자에 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a></code>와 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code> 보정 데코레이터를 사용하면 됩니다.</p>\n<!--\n* The `@Optional` property decorator tells Angular to return null when it can't find the dependency.\n\n* The `@Host` property decorator stops the upward search at the *host component*.\nThe host component is typically the component requesting the dependency.\nHowever, when this component is projected into a *parent* component,\nthat parent component becomes the host. The following example covers this second case.\n-->\n<ul>\n<li>\n<p><code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code> 프로퍼티 데코레이터를 사용하면 의존성 객체를 찾지 못했을 때 에러를 발생하는 대신 <code>null</code>을 주입합니다.</p>\n</li>\n<li>\n<p><code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a></code> 프로퍼티 데코레이터를 사용하면 의존성 객체를 찾는 과정이 <em>호스트 컴포넌트</em> 까지만 이루어집니다.\n이 때 호스트 컴포넌트는 일반적으로 의존성 객체를 요청한 컴포넌트를 의미합니다.\n그런데 이 컴포넌트가 <em>부모</em> 컴포넌트에 프로젝트된 상태라면 부모 컴포넌트가 호스트 컴포넌트입니다.\n이 내용에 대해서는 아래에서 자세하게 알아봅시다.</p>\n</li>\n</ul>\n<!--\nThese decorators can be used individually or together, as shown in the example.\nThis `HeroBiosAndContactsComponent` is a revision of `HeroBiosComponent` which you looked at [above](guide/dependency-injection-in-action#hero-bios-component).\n-->\n<p>아래에서 예제와 함께 다시 설명하겠지만, 이 데코레이터들은 따로 사용할 수도 있고 함께 사용할 수도 있습니다.\n이제부터 자세하게 살펴볼 <code>HeroBiosAndContactsComponent</code>는 <a href=\"guide/dependency-injection-in-action#hero-bios-component\">위</a>에서 살펴본 <code>HeroBiosComponent</code>를 변형한 컴포넌트입니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-bios.component.ts\" region=\"hero-bios-and-contacts\" header=\"src/app/hero-bios.component.ts (HeroBiosAndContactsComponent)\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-bios-and-contacts',\n  template: `\n    &#x3C;app-hero-bio [heroId]=\"1\"> &#x3C;app-hero-contact>&#x3C;/app-hero-contact> &#x3C;/app-hero-bio>\n    &#x3C;app-hero-bio [heroId]=\"2\"> &#x3C;app-hero-contact>&#x3C;/app-hero-contact> &#x3C;/app-hero-bio>\n    &#x3C;app-hero-bio [heroId]=\"3\"> &#x3C;app-hero-contact>&#x3C;/app-hero-contact> &#x3C;/app-hero-bio>`,\n  providers: [HeroService]\n})\nexport class HeroBiosAndContactsComponent {\n  constructor(logger: LoggerService) {\n    logger.logInfo('Creating HeroBiosAndContactsComponent');\n  }\n}\n\n</code-example>\n<!--\nFocus on the template:\n-->\n<p>템플릿을 자세히 봅시다:</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-bios.component.ts\" region=\"template\" header=\"dependency-injection-in-action/src/app/hero-bios.component.ts\" linenums=\"false\">\ntemplate: `\n  &#x3C;app-hero-bio [heroId]=\"1\"> &#x3C;app-hero-contact>&#x3C;/app-hero-contact> &#x3C;/app-hero-bio>\n  &#x3C;app-hero-bio [heroId]=\"2\"> &#x3C;app-hero-contact>&#x3C;/app-hero-contact> &#x3C;/app-hero-bio>\n  &#x3C;app-hero-bio [heroId]=\"3\"> &#x3C;app-hero-contact>&#x3C;/app-hero-contact> &#x3C;/app-hero-bio>`,\n\n</code-example>\n<!--\nNow there's a new `<hero-contact>` element between the `<hero-bio>` tags.\nAngular *projects*, or *transcludes*, the corresponding `HeroContactComponent` into the `HeroBioComponent` view,\nplacing it in the `<ng-content>` slot of the `HeroBioComponent` template.\n-->\n<p>템플릿에는 <code>&#x3C;hero-bio></code> 태그 안에 <code>&#x3C;hero-contact></code> 엘리먼트가 선언되어 있습니다.\n그러면 <code>HeroBioComponent</code>의 뷰에 있는 <code>&#x3C;ng-content></code> 안에 <code>HeroContactComponent</code>가 <em>프로젝트(project, transclude)</em> 됩니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-bio.component.ts\" region=\"template\" header=\"src/app/hero-bio.component.ts (template)\" linenums=\"false\">\ntemplate: `\n  &#x3C;h4>{{hero.name}}&#x3C;/h4>\n  &#x3C;ng-content>&#x3C;/ng-content>\n  &#x3C;<a href=\"api/forms/DefaultValueAccessor\" class=\"code-anchor\">textarea</a> cols=\"25\" [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.description\">&#x3C;/<a href=\"api/forms/DefaultValueAccessor\" class=\"code-anchor\">textarea</a>>`,\n\n</code-example>\n<!--\nThe result is shown below, with the hero's telephone number from `HeroContactComponent` projected above the hero description.\n-->\n<p>이 코드를 실행하면 <code>HeroContactComponent</code>에 정의되어 히어로의 전화번호를 입력하는 엘리먼트가 히어로의 정보 위에 다음과 같이 표시됩니다.</p>\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/hero-bio-and-content.png\" alt=\"bio and contact\" width=\"199\" height=\"92\">\n</figure>\n<!--\nHere's `HeroContactComponent`, which demonstrates the qualifying decorators.\n-->\n<p>이 때 <code>HeroContactComponent</code>에는 보정 데코레이터가 다음과 같이 선언되어 있습니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-contact.component.ts\" region=\"component\" header=\"src/app/hero-contact.component.ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-contact',\n  template: `\n  &#x3C;div>Phone #: {{phoneNumber}}\n  &#x3C;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hasLogger\">!!!&#x3C;/span>&#x3C;/div>`\n})\nexport class HeroContactComponent {\n\n  hasLogger = false;\n\n  constructor(\n      @<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>() // HeroCacheService 인스턴스 탐색 범위를 호스트 컴포넌트까지로 제한합니다.\n      private heroCache: HeroCacheService,\n\n      @<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()     // LoggerService를 찾을 범위를 제한합니다. 애플리케이션 전역 인스턴스는 가려집니다.\n      @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() // 서비스 인스턴스가 존재하지 않는 것도 허용합니다.\n      private loggerService: LoggerService\n  ) {\n    if (loggerService) {\n      this.hasLogger = true;\n      loggerService.logInfo('HeroContactComponent can <a href=\"api/animations/browser/testing/MockAnimationDriver#log\" class=\"code-anchor\">log</a>!');\n    }\n  }\n\n  get phoneNumber() { return this.heroCache.hero.phone; }\n\n}\n\n</code-example>\n<!--\nFocus on the constructor parameters.\n-->\n<p>생성자의 인자 선언을 자세히 봅시다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-contact.component.ts\" region=\"ctor-params\" header=\"src/app/hero-contact.component.ts\" linenums=\"false\">\n@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>() // HeroCacheService 인스턴스 탐색 범위를 호스트 컴포넌트까지로 제한합니다.\nprivate heroCache: HeroCacheService,\n\n@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()     // LoggerService를 찾을 범위를 제한합니다. 애플리케이션 전역 인스턴스는 가려집니다.\n@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() // 서비스 인스턴스가 존재하지 않는 것도 허용합니다.\nprivate loggerService: LoggerService\n\n</code-example>\n<!--\nThe `@Host()` function decorating the  `heroCache` constructor property ensures that\nyou get a reference to the cache service from the parent `HeroBioComponent`.\nAngular throws an error if the parent lacks that service, even if a component higher\nin the component tree includes it.\n\nA second `@Host()` function decorates the `loggerService` constructor property.\nThe only `LoggerService` instance in the app is provided at the `AppComponent` level.\nThe host `HeroBioComponent` doesn't have its own `LoggerService` provider.\n\nAngular throws an error if you haven't also decorated the property with `@Optional()`.\nWhen the property is marked as optional, Angular sets `loggerService` to null and the rest of the component adapts.\n-->\n<p>생성자의 인자인 <code>heroCache</code>에 사용된 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 함수는 이 인자를 의존성으로 찾을 때 부모 컴포넌트인 <code>HeroBioComponent</code>까지만 찾도록 탐색 범위를 제한하는 데코레이터입니다.\n그러면 이 의존성 객체가 부모 컴포넌트 위쪽에 등록되어 있더라도 부모 컴포넌트까지 이 서비스를 찾지 못하면 에러가 발생합니다.</p>\n<p>두번째 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 함수는 <code>loggerService</code> 생성자 인자에 지정되었습니다.\n그런데 <code>LoggerService</code>는 <code>AppComponent</code> 계층에만 등록되어 있다고 합시다.\n호스트 컴포넌트인 <code>HeroBioComponent</code>에는 <code>LoggerService</code>의 프로바이더가 등록되어 있지 않습니다.</p>\n<p>만약 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 데코레이터가 사용되지 않았다면 이 코드는 에러가 발생합니다.\n하지만 <code>loggerService</code>는 생략할 수 있도록 지정되었기 때문에 의존성 객체의 인스턴스를 찾지 못하더라도 에러가 발생하지 않으며 생성자에는 <code>null</code>이 주입됩니다.</p>\n<!--\nHere's `HeroBiosAndContactsComponent` in action.\n-->\n<p><code>HeroBiosAndContactsComponent</code>는 이제 아래 그림과 같이 동작합니다.</p>\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/hero-bios-and-contacts.png\" alt=\"Bios with contact into\" width=\"206\" height=\"393\">\n</figure>\n<!--\nIf you comment out the `@Host()` decorator, Angular walks up the injector ancestor tree\nuntil it finds the logger at the `AppComponent` level.\nThe logger logic kicks in and the hero display updates\nwith the \"!!!\" marker to indicate that the logger was found.\n-->\n<p>만약 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 데코레이터를 제거하면 의존성 객체를 찾는 과정이 <code>AppComponent</code> 계층까지 버블링되기 때문에 이 애플리케이션은 에러없이 동작합니다.\n로그도 정상적으로 동작할 것이며, <code>logger</code> 인스턴스를 찾았다는 것은 화면에 \"!!!\"가 표시되는 것으로 확인할 수 있습니다.</p>\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/hero-bio-contact-no-host.png\" alt=\"Without @Host\" width=\"199\" height=\"93\">\n</figure>\n<!--\nIf you restore the `@Host()` decorator and comment out `@Optional`,\nthe app throws an exception when it cannot find the required logger at the host component level.\n-->\n<p>만약 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 데코레이터를 다시 추가하고 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code> 데코레이터를 제거하면, 호스트 컴포넌트 계층까지 탐색해도 의존성 객체를 찾을 수 없기 때문에 다음과 같은 에러가 발생합니다.</p>\n<p><code>EXCEPTION: No provider for LoggerService! (HeroContactComponent -> LoggerService)</code></p>\n<!--\n### Supply a custom provider with `@Inject`\n-->\n<h3 id=\"inject로-커스텀-프로바이더-주입하기\"><code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code>로 커스텀 프로바이더 주입하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#inject로-커스텀-프로바이더-주입하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nUsing a custom provider allows you to provide a concrete implementation for implicit dependencies, such as built-in browser APIs. The following example uses an `InjectionToken` to provide the [localStorage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage) browser API as a dependency in the `BrowserStorageService`.\n-->\n<p>브라우저 내장 API로 제공되는 객체는 커스텀 프로바이더를 사용해서 의존성으로 주입할 수 있습니다. 아래 예제는 브라우저가 제공하는 API 중 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage\">localStorage</a>에<code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code>을 사용해서 <code>BrowserStorageService</code>로 만드는 예제 코드입니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/storage.service.ts\" header=\"src/app/storage.service.ts\">\nimport { <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>, <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>, <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a> } from '@angular/core';\n\nexport const BROWSER_STORAGE = new <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a>&#x3C;Storage>('Browser Storage', {\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n  factory: () => localStorage\n});\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root'\n})\nexport class BrowserStorageService {\n  constructor(@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(BROWSER_STORAGE) public storage: Storage) {}\n\n  get(key: string) {\n    this.storage.getItem(key);\n  }\n\n  set(key: string, value: string) {\n    this.storage.setItem(key, value);\n  }\n\n  remove(key: string) {\n    this.storage.removeItem(key);\n  }\n\n  clear() {\n    this.storage.clear();\n  }\n}\n\n\n</code-example>\n<!--\nThe `factory` function returns the `localStorage` property that is attached to the browser window object. The `Inject` decorator is a constructor parameter used to specify a custom provider of a dependency. This custom provider can now be overridden during testing with a mock API of `localStorage` instead of interactive with real browser APIs.\n-->\n<p><code>factory</code> 프로퍼티에 지정된 함수는 브라우저의 <code>window</code> 객체에서 <code>localStorage</code> 프로퍼티를 반환합니다. 그리고 이렇게 만든 커스텀 프로바이더를 생성자의 인자에 주입하기 위해 <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code> 데코레이터를 사용했습니다. 이제 커스텀 프로바이더는 기본 환경에서도 동작하지만, 테스트 환경에서 목 API로 <code>localStorage</code>를 대체할 때도 사용할 수 있습니다.</p>\n<a id=\"skip\"></a>\n<!--\n### Modify the provider search with `@Self` and `@SkipSelf`\n-->\n<h3 id=\"self와-skipself로-탐색-범위-조정하기\"><code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a></code>와 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code>로 탐색 범위 조정하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#self와-skipself로-탐색-범위-조정하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nProviders can also be scoped by injector through constructor parameter decorators. The following example overrides the `BROWSER_STORAGE` token in the `Component` class `providers` with the `sessionStorage` browser API. The same `BrowserStorageService` is injected twice in the constructor, decorated with `@Self` and `@SkipSelf` to define which injector handles the provider dependency.\n-->\n<p>프로바이더는 생성자의 인자에 사용된 데코레이터의 영향을 받기도 합니다.\n아래 예제에서 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 데코레이터의 <code>providers</code>에 등록된 <code>BROWSER_STORAGE</code>는 브라우저에서 API로 제공하는 <code>sessionStorage</code>를 오버라이드하는 토큰입니다. 이 때 <code>BrowserStorageService</code>는 생성자의 인자로 두 번 지정되었지만, 각각 <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a></code>와 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code>가 지정되었기 때문에 의존성 주입이 동작하는 방식은 다릅니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/storage.component.ts\" header=\"src/app/storage.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>, <a href=\"api/core/Self\" class=\"code-anchor\">Self</a>, <a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a> } from '@angular/core';\nimport { BROWSER_STORAGE, BrowserStorageService } from './storage.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-storage',\n  template: `\n    Open the inspector to see the local/session storage <a href=\"api/router/ParamMap#keys\" class=\"code-anchor\">keys</a>:\n\n    &#x3C;h3>Session Storage&#x3C;/h3>\n    &#x3C;button (click)=\"setSession()\">Set Session Storage&#x3C;/button>\n\n    &#x3C;h3>Local Storage&#x3C;/h3>\n    &#x3C;button (click)=\"setLocal()\">Set Local Storage&#x3C;/button>\n  `,\n  providers: [\n    BrowserStorageService,\n    { provide: BROWSER_STORAGE, useFactory: () => sessionStorage }\n  ]\n})\nexport class StorageComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n\n  constructor(\n    @<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>() private sessionStorageService: BrowserStorageService,\n    @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() private localStorageService: BrowserStorageService,\n  ) { }\n\n  ngOnInit() {\n  }\n\n  setSession() {\n    this.sessionStorageService.set('hero', 'Dr Nice - Session');\n  }\n\n  setLocal() {\n    this.localStorageService.set('hero', 'Dr Nice - Local');\n  }\n}\n\n\n</code-example>\n<!--\nUsing the `@Self` decorator, the injector only looks at the component's injector for its providers. The `@SkipSelf` decorator allows you to skip the local injector and look up in the hierarchy to find a provider that satisfies this dependency. The `sessionStorageService` instance interacts with the `BrowserStorageService` using the `sessionStorage` browser API, while the `localStorageService` skips the local injector and uses the root `BrowserStorageService` that uses the `localStorage` browswer API.\n-->\n<p><code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a></code> 데코레이터가 사용된 의존성 객체는 해당 컴포넌트의 인젝터에 등록된 프로바이더만 참조합니다. 그리고 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 데코레이터가 사용된 의존성 객체는 해당 컴포넌트의 인젝터를 건너뛰고 그 위쪽 인젝터부터 의존성 객체를 찾기 시작합니다. 결국 <code>sessionStorageService</code>에 할당되는 것은 이 컴포넌트에 등록된 프로바이더에 따라 브라우저 내장 <code>sessionStorage</code>가 될 것이며, <code>localStorageService</code>는 이 컴포넌트를 건너뛰고 탐색하도록 지정했기 때문에 <code>BrowserStorageService</code>에서 제공하는 <code>localStorage</code>가 할당될 것입니다.</p>\n<a id=\"component-element\"></a>\n<!--\n## Inject the component's DOM element\n-->\n<h2 id=\"컴포넌트의-dom-엘리먼트-주입하기\">컴포넌트의 DOM 엘리먼트 주입하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#컴포넌트의-dom-엘리먼트-주입하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAlthough developers strive to avoid it, many visual effects and third-party tools, such as jQuery,\nrequire DOM access.\nAs a result, you might need to access a component's DOM element.\n\nTo illustrate, here's a simplified version of `HighlightDirective` from\nthe [Attribute Directives](guide/attribute-directives) page.\n-->\n<p>가능한 한 이 방법은 사용하지 않을 것을 권장하지만, 시각 효과를 위한 서드파티 툴이 jQuery를 사용한다면 DOM에 접근해야 하는 경우가 있습니다.\n그러면 결국 컴포넌트의 DOM 엘리먼트에 접근할 수 있는 방법을 찾아야 합니다.</p>\n<p>이 내용을 알아보기 위해 <a href=\"guide/attribute-directives\">어트리뷰트 디렉티브</a> 페이지에서 살펴봤던 <code>HighlightDirective</code>를 간단하게 확인해 봅시다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/highlight.directive.ts\" header=\"src/app/highlight.directive.ts\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, <a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a> } from '@angular/core';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: '[appHighlight]'\n})\nexport class HighlightDirective {\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('appHighlight') highlightColor: string;\n\n  private el: HTMLElement;\n\n  constructor(el: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>) {\n    this.el = el.nativeElement;\n  }\n\n  @<a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>('mouseenter') onMouseEnter() {\n    this.highlight(this.highlightColor || 'cyan');\n  }\n\n  @<a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>('mouseleave') onMouseLeave() {\n    this.highlight(null);\n  }\n\n  private highlight(color: string) {\n    this.el.style.backgroundColor = color;\n  }\n}\n\n\n</code-example>\n<!--\nThe directive sets the background to a highlight color when the user mouses over the\nDOM element to which the directive is applied.\n\nAngular sets the constructor's `el` parameter to the injected `ElementRef`.\n(An `ElementRef` is a wrapper around a DOM element,\nwhose `nativeElement` property exposes the DOM element for the directive to manipulate.)\n\nThe sample code applies the directive's `myHighlight` attribute to two `<div>` tags,\nfirst without a value (yielding the default color) and then with an assigned color value.\n-->\n<p>이 디렉티브가 적용된 DOM 엘리먼트에 사용자가 마우스를 올리면 배경색이 변경됩니다.</p>\n<p>그리고 배경색을 변경하기 위해 디렉티브의 생성자로 <code><a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a></code>를 주입하고, 이 객체를 <code>el</code> 프로퍼티로 할당했습니다.\n(<code><a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a></code>는 DOM 엘리먼트를 랩핑한 타입이며, 이 객체의 <code>nativeElement</code> 프로퍼티를 사용하면 디렉티브에서 DOM 엘리먼트를 직접 조작할 수 있습니다.)</p>\n<p>이 디렉티브는 DOM 엘리먼트에 적용하면서 입력값을 받을 수 있는데, 색상을 지정하지 않으면 기본 색상이 배경색으로 적용되고 색상을 지정하면 지정된 색상이 배경색이 됩니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/app.component.html\" region=\"highlight\" header=\"src/app/app.component.html (highlight)\" linenums=\"false\">\n&#x3C;div id=\"highlight\"  class=\"di-component\"  appHighlight>\n  &#x3C;h3>Hero Bios and Contacts&#x3C;/h3>\n  &#x3C;div appHighlight=\"yellow\">\n    &#x3C;app-hero-bios-and-contacts>&#x3C;/app-hero-bios-and-contacts>\n  &#x3C;/div>\n&#x3C;/div>\n\n</code-example>\n<!--\nThe following image shows the effect of mousing over the `<hero-bios-and-contacts>` tag.\n-->\n<p>이제 <code>&#x3C;hero-bios-and-contacts></code>에 마우스를 올려보면 아래 그림과 같이 표시됩니다.</p>\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/highlight.png\" alt=\"Highlighted bios\" width=\"318\" height=\"196\">\n</figure>\n<a id=\"providers\"></a>\n<!--\n## Define dependencies with providers\n-->\n<h2 id=\"프로바이더로-의존성-정의하기\">프로바이더로 의존성 정의하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#프로바이더로-의존성-정의하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThis section demonstrates how to write providers that deliver dependent services.\n\nIn order to get a service from a dependency injector, you have to give it a [token](guide/glossary#token).\nAngular usually handles this transaction by specifying a constructor parameter and its type.\nThe parameter type serves as the injector lookup token.\nAngular passes this token to the injector and assigns the result to the parameter.\n\nThe following is a typical example.\n-->\n<p>이번 섹션에서는 의존성으로 주입하는 서비스의 프로바이더를 어떻게 정의할 수 있는지 알아봅시다.</p>\n<p>인젝터를 통해 서비스를 주입받으려면 이 서비스에 해당하는 <a href=\"guide/glossary#token\">토큰</a>을 선언해야 합니다.\n그리고 이렇게 선언된 토큰은 Angular가 생성자의 인자에 지정된 타입을 인젝터에서 찾을때 활용됩니다.\n그래서 인젝터에 토큰을 보내면 그 토큰에 해당되는 의존성 객체를 받아올 수 있습니다.</p>\n<p>예제를 보면서 이 내용을 확인해 봅시다.</p>\n<!--\n<code-example path=\"dependency-injection-in-action/src/app/hero-bios.component.ts\" region=\"ctor\" header=\"src/app/hero-bios.component.ts (component constructor injection)\" linenums=\"false\">\n-->\n<code-example path=\"dependency-injection-in-action/src/app/hero-bios.component.ts\" region=\"ctor\" header=\"src/app/hero-bios.component.ts (컴포넌트 생성자로 주입되는 의존성 객체)\" linenums=\"false\">\nconstructor(logger: LoggerService) {\n  logger.logInfo('Creating HeroBiosComponent');\n}\n\n</code-example>\n<!--\nAngular asks the injector for the service associated with `LoggerService`\nand assigns the returned value to the `logger` parameter.\n\nIf the injector has already cached an instance of the service associated with the token,\nit provides that instance.\nIf it doesn't, it needs to make one using the provider associated with the token.\n-->\n<p>이 코드에서 Angular는 인젝터에 <code>LoggerService</code>에 해당하는 서비스가 있는지 확인하고, 인젝터가 반환하는 객체를 <code>logger</code> 프로퍼티에 할당합니다.</p>\n<p>그리고 인젝터는 이 토큰에 해당하는 서비스의 인스턴스가 이미 캐싱되어 있으면 그 인스턴스를 바로 반환하며, 인스턴스가 존재하지 않으면 프로바이더를 사용해서 새로운 인스턴스를 생성합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nIf the injector doesn't have a provider for a requested token, it delegates the request\nto its parent injector, where the process repeats until there are no more injectors.\nIf the search fails, the injector throws an error&mdash;unless the request was [optional](guide/dependency-injection-in-action#optional).\n-->\n<p>요청된 토큰에 해당하는 프로바이더가 인젝터에 없다면 이 의존성 주입 요청은 부모 인젝터로 전달되며, 이 과정은 애플리케이션 최상위 인젝터까지 반복됩니다.\n그리고 —<a href=\"guide/dependency-injection-in-action#optional\">optional</a> 데코레이터가 사용되지 않은 상태에서—최종 인젝터에서도 프로바이더를 찾지 못하면 에러가 발생합니다.</p>\n</div>\n<!--\nA new injector has no providers.\nAngular initializes the injectors it creates with a set of preferred providers.\nYou have to configure providers for your own app-specific dependencies.\n-->\n<p>새로 생성된 인젝터에는 프로바이더가 없습니다.\n그리고 프로바이더가 등록되지 않은 인젝터는 Angular가 생성하지도 않습니다.\n애플리케이션에 의존성 객체가 필요하다면 프로바이더를 꼭 등록해야 합니다.</p>\n<a id=\"defining-providers\"></a>\n<!--\n### Defining providers\n-->\n<h3 id=\"프로바이더-정의하기\">프로바이더 정의하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#프로바이더-정의하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nA dependency can't always be created by the default method of instantiating a class.\nYou learned about some other methods in [Dependency Providers](guide/dependency-injection-providers).\nThe following `HeroOfTheMonthComponent` example demonstrates many of the alternatives and why you need them.\nIt's visually simple: a few properties and the logs produced by a logger.\n-->\n<p>의존성 객체의 인스턴스는 클래스를 생성하는 기본 방식 외에 다른 방식으로도 생성할 수 있습니다.\n이 내용은 <a href=\"guide/dependency-injection-providers\">의존성 주입 프로바이더</a>에서 이미 다뤘습니다.\n아래 <code>HeroOfTheMonthComponent</code> 예제를 보면서 기본 방식 외에 다른 방식이 어떤 경우에 사용되는지 알아봅시다.\n동작하는 모습은 간단합니다. 이 예제는 <code>logger</code>가 처리하는 프로퍼티와 로그를 아래 그림과 같이 화면에 단순하게 표시하는 예제입니다.</p>\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/hero-of-month.png\" alt=\"Hero of the month\" width=\"300\" height=\"165\">\n</figure>\n<!--\nThe code behind it customizes how and where the DI framework provides dependencies.\nThe use cases illustrate different ways to use the [*provide* object literal](guide/dependency-injection-providers#provide) to associate a definition object with a DI token.\n-->\n<p>하지만 이 코드는 의존성 주입 프레임워크에 활용되는 의존성 객체를 모두 커스터마이징 하기 위해 조금 복잡해졌습니다.\n그럼에도 불구하고 모든 프로바이더는 의존성 객체와 토큰을 <a href=\"guide/dependency-injection-providers#provide\"><em>provide</em> 객체 리터럴</a>로 등록하는데 각각 다른 방식을 사용한 것 뿐입니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"hero-of-the-month\" header=\"hero-of-the-month.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a> } from '@angular/core';\n\nimport { DateLoggerService } from './date-logger.service';\nimport { Hero }              from './hero';\nimport { HeroService }       from './hero.service';\nimport { LoggerService }     from './logger.service';\nimport { MinimalLogger }     from './minimal-logger.service';\nimport { RUNNERS_UP,\n         runnersUpFactory }  from './runners-up';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-of-the-month',\n  templateUrl: './hero-of-the-month.component.html',\n  providers: [\n    { provide: Hero,          <a href=\"api/core/ValueSansProvider#useValue\" class=\"code-anchor\">useValue</a>:    someHero },\n    { provide: TITLE,         <a href=\"api/core/ValueSansProvider#useValue\" class=\"code-anchor\">useValue</a>:   'Hero of the Month' },\n    { provide: HeroService,   <a href=\"api/core/ClassSansProvider#useClass\" class=\"code-anchor\">useClass</a>:    HeroService },\n    { provide: LoggerService, <a href=\"api/core/ClassSansProvider#useClass\" class=\"code-anchor\">useClass</a>:    DateLoggerService },\n    { provide: MinimalLogger, useExisting: LoggerService },\n    { provide: RUNNERS_UP,    useFactory:  runnersUpFactory(2), <a href=\"api/core/ConstructorSansProvider#deps\" class=\"code-anchor\">deps</a>: [Hero, HeroService] }\n  ]\n})\nexport class HeroOfTheMonthComponent {\n  logs: string[] = [];\n\n  constructor(\n      logger: MinimalLogger,\n      public heroOfTheMonth: Hero,\n      @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(RUNNERS_UP) public runnersUp: string,\n      @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(TITLE) public title: string)\n  {\n    this.logs = logger.logs;\n    logger.logInfo('starting up');\n  }\n}\n\n</code-example>\n<!--\nThe `providers` array shows how you might use the different provider-definition keys;\n`useValue`, `useClass`, `useExisting`, or `useFactory`.\n-->\n<p><code>providers</code> 배열을 보면 알수 있듯이, 의존성 토큰에 프로바이더를 연결할 때는 <code><a href=\"api/core/ValueSansProvider#useValue\" class=\"code-anchor\">useValue</a></code>, <code><a href=\"api/core/ClassSansProvider#useClass\" class=\"code-anchor\">useClass</a></code>, <code>useExisting</code>, <code>useFactory</code>를 사용할 수 있습니다.</p>\n<a id=\"usevalue\"></a>\n<!--\n#### Value providers: `useValue`\n-->\n<h4 id=\"값-프로바이더-usevalue\">값 프로바이더: <code><a href=\"api/core/ValueSansProvider#useValue\" class=\"code-anchor\">useValue</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#값-프로바이더-usevalue\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe `useValue` key lets you associate a fixed value with a DI token.\nUse this technique to provide *runtime configuration constants* such as website base addresses and feature flags.\nYou can also use a value provider in a unit test to provide mock data in place of a production data service.\n\nThe `HeroOfTheMonthComponent` example has two value providers.\n-->\n<p><code><a href=\"api/core/ValueSansProvider#useValue\" class=\"code-anchor\">useValue</a></code>키를 사용하면 고정된 값을 의존성 토큰에 연결할 수 있습니다.\n이 방식은 웹사이트의 기본 주소나 플래그 값 등 <em>실행시점에 결정되는 상수</em>를 의존성으로 주입할 때 사용합니다.\n그리고 이 방식은 데이터 서비스에 유닛 테스트를 적용할 때 목 데이터를 주입하는 용도로도 사용할 수 있습니다.</p>\n<p><code>HeroOfTheMonthComponent</code> 예제에서는 이 방식의 프로바이더가 두 번 사용되었습니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"use-value\" header=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" linenums=\"false\">\n{ provide: Hero,          <a href=\"api/core/ValueSansProvider#useValue\" class=\"code-anchor\">useValue</a>:    someHero },\n{ provide: TITLE,         <a href=\"api/core/ValueSansProvider#useValue\" class=\"code-anchor\">useValue</a>:   'Hero of the Month' },\n\n</code-example>\n<!--\n* The first provides an existing instance of the `Hero` class to use for the `Hero` token, rather than\nrequiring the injector to create a new instance with `new` or use its own cached instance.\nHere, the token is the class itself.\n\n* The second specifies a literal string resource to use for the `TITLE` token.\nThe `TITLE` provider token is *not* a class, but is instead a\nspecial kind of provider lookup key called an [injection token](guide/dependency-injection-in-action#injection-token), represented by\nan `InjectionToken` instance.\n\nYou can use an injection token for any kind of provider but it's particularly\nhelpful when the dependency is a simple value like a string, a number, or a function.\n\nThe value of a *value provider* must be defined before you specify it here.\nThe title string literal is immediately available.\nThe `someHero` variable in this example was set earlier in the file as shown below.\nYou can't use a variable whose value will be defined later.\n-->\n<ul>\n<li>\n<p>첫번째 사용된 프로바이더는 <code>Hero</code> 토큰에 <code>Hero</code> 클래스 인스턴스를 <code>new</code> 키워드로 생성해서 반환하지 않고, 어딘가에 캐싱된 인스턴스를 사용하는 방식으로 등록되었습니다.\n이 때 클래스 그 자체가 토큰입니다.</p>\n</li>\n<li>\n<p>두번째로 사용된 프로바이더는 <code>TITLE</code> 토큰에 문자열 리소스를 연결하는 방식으로 등록되었습니다.\n이 때 <code>TITLE</code> 프로바이더 토큰은 <em>클래스</em>가 아니지만 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 인스턴스로 생성된 <a href=\"guide/dependency-injection-in-action#injection-token\">인젝션 토큰</a>이기 때문에 프로바이더를 찾는 키로 사용할 수 있습니다.</p>\n</li>\n</ul>\n<p>인젝션 토큰에는 어떠한 것이라도 연결할 수 있지만, 보통 문자열이나 숫자, 함수를 연결할 때 사용합니다.</p>\n<p><em>값 프로바이더</em>의 값(value)에 해당하는 객체는 프로바이더가 등록되기 전에 반드시 선언되어야 합니다.\n그래서 <code>TITLE</code>에 해당하는 문자열은 프로바이더를 등록하면서 바로 선언했으며, <code>someHero</code> 변수에 해당하는 객체는 프로바이더가 등록되기 전 어딘가에 이미 선언되어 있습니다.\n프로바이더 선언보다 늦게 선언되는 변수는 프로바이더에 제대로 등록되지 않습니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"some-hero\" header=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\">\nconst someHero = new Hero(42, 'Magma', 'Had <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> great month!', '555-555-5555');\n\n</code-example>\n<!--\nOther types of providers can create their values *lazily*; that is, when they're needed for injection.\n-->\n<p>다른 타입의 프로바이더는 값에 해당하는 객체가 의존성 주입되기 전까지라면 프로바이더가 등록되는 것보다 <em>늦게</em> 생성되어도 됩니다.</p>\n<a id=\"useclass\"></a>\n<!--\n#### Class providers: `useClass`\n-->\n<h4 id=\"클래스-프로바이더-useclass\">클래스 프로바이더: <code><a href=\"api/core/ClassSansProvider#useClass\" class=\"code-anchor\">useClass</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#클래스-프로바이더-useclass\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe `useClass` provider key lets you create and return a new instance of the specified class.\n\nYou can use this type of provider to substitute an *alternative implementation*\nfor a common or default class.\nThe alternative implementation could, for example, implement a different strategy,\nextend the default class, or emulate the behavior of the real class in a test case.\n\nThe following code shows two examples in `HeroOfTheMonthComponent`.\n-->\n<p><code><a href=\"api/core/ClassSansProvider#useClass\" class=\"code-anchor\">useClass</a></code> 프로바이더 키를 사용하면 이 키에 연결된 클래스 인스턴스가 대신 주입됩니다.</p>\n<p>이 방식은 어떤 클래스를 <em>다른 구현체로 대체할 때</em>도 사용할 수 있습니다.\n이 때 다른 구현체라는 것은 다른 정책일 수도 있고, 기본 클래스를 상속받은 클래스일 수도 있으며, 테스트 환경에서 실제 클래스를 대체하기 위한 객체일 수도 있습니다.</p>\n<p><code>HeroOfTheMonthComponent</code> 예제에서는 이 방식의 프로바이더가 두 번 사용되었습니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"use-class\" header=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" linenums=\"false\">\n{ provide: HeroService,   <a href=\"api/core/ClassSansProvider#useClass\" class=\"code-anchor\">useClass</a>:    HeroService },\n{ provide: LoggerService, <a href=\"api/core/ClassSansProvider#useClass\" class=\"code-anchor\">useClass</a>:    DateLoggerService },\n\n</code-example>\n<!--\nThe first provider is the *de-sugared*, expanded form of the most typical case in which the\nclass to be created (`HeroService`) is also the provider's dependency injection token.\nThe short form is generally preferred; this long form makes the details explicit.\n\nThe second provider substitutes `DateLoggerService` for `LoggerService`.\n`LoggerService` is already registered at the `AppComponent` level.\nWhen this child component requests `LoggerService`, it receives a `DateLoggerService` instance instead.\n-->\n<p>첫번째 프로바이더는 <em>축약형을 사용하지 않은(de-sugared)</em> 문법이며 클래스를 의존성 객체로 등록할 때 가장 많이 사용하는 방식입니다. 이 경우에 <code>HeroService</code>는 의존성 토큰이면서 구현체이기도 합니다.\n일반적으로는 축약형이 사용되지만 이 예제에서는 개념을 명확하게 하기 위해 풀어서 사용했습니다.</p>\n<p>두번째 프로바이더는 <code>AppComponent</code> 계층에 등록된 <code>LoggerService</code>를 <code>DateLoggerService</code>로 대체하기 위해 사용했습니다.\n이제 이 프로바이더가 등록된 컴포넌트 계층부터는 <code>LoggerService</code>가 요청되었을 때 <code>DateLoggerService</code>의 인스턴스가 대신 주입됩니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nThis component and its tree of child components receive `DateLoggerService` instance.\nComponents outside the tree continue to receive the original `LoggerService` instance.\n-->\n<p>이 컴포넌트와 이 컴포넌트 트리 아래에 있는 컴포넌트에는 <code>DateLoggerService</code>의 인스턴스가 주입됩니다.\n하지만 이 트리 밖에 있는 컴포넌트에는 여전히 <code>LoggerService</code>의 인스턴스가 주입됩니다.</p>\n</div>\n<!--\n`DateLoggerService` inherits from `LoggerService`; it appends the current date/time to each message:\n-->\n<p><code>DateLoggerService</code>는 <code>LoggerService</code>를 상속한 클래스이며, 원래 로그의 기능에 날짜와 시간을 함께 출력하는 클래스입니다:</p>\n<code-example path=\"dependency-injection-in-action/src/app/date-logger.service.ts\" region=\"date-logger-service\" header=\"src/app/date-logger.service.ts\" linenums=\"false\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root'\n})\nexport class DateLoggerService extends LoggerService\n{\n  logInfo(msg: any)  { super.logInfo(stamp(msg)); }\n  logDebug(msg: any) { super.logInfo(stamp(msg)); }\n  logError(msg: any) { super.logError(stamp(msg)); }\n}\n\nfunction stamp(msg: any) { return msg + ' at ' + new Date(); }\n\n</code-example>\n<a id=\"useexisting\"></a>\n<!--\n#### Alias providers: `useExisting`\n-->\n<h4 id=\"별칭-프로바이더-useexisting\">별칭 프로바이더: <code>useExisting</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#별칭-프로바이더-useexisting\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe `useExisting` provider key lets you map one token to another.\nIn effect, the first token is an *alias* for the service associated with the second token,\ncreating two ways to access the same service object.\n-->\n<p><code>useExisting</code> 프로바이더 키는 어떤 토큰을 다른 토큰과 연결할 때 사용합니다.\n그래서 <code>provide</code>에 사용된 토큰은 <code>useExisting</code>에 사용된 토큰의 <em>별칭(alias)</em> 역할을 하기 때문에, 결국 같은 서비스 객체를 또 다른 이름으로 참조할 수 있습니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"use-existing\" header=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\">\n{ provide: MinimalLogger, useExisting: LoggerService },\n\n</code-example>\n<!--\nYou can use this technique to narrow an API through an aliasing interface.\nThe following example shows an alias introduced for that purpose.\n\nImagine that `LoggerService` had a large API, much larger than the actual three methods and a property.\nYou might want to shrink that API surface to just the members you actually need.\nIn this example, the `MinimalLogger` [class-interface](#class-interface) reduces the API to two members:\n-->\n<p>이 방식은 또 다른 인터페이스를 만들어서 어떤 클래스의 API를 제한하는 용도로 사용할 수 있습니다.\n아래 예제에서 확인해 봅시다.</p>\n<p><code>LoggerService</code>가 제공하는 API가 너무 방대한데, 실제로 사용하는 API는 이 중에 2개밖에 안된다고 합시다.\n그래서 이 서비스를 그대로 사용하지 않고 2개의 API만 제공하는 인터페이스를 대신 사용하려고 합니다.\n아래 예제에서 <code>MinimalLogger</code> <a href=\"guide/dependency-injection-in-action#class-interface\">클래스-인터페이스</a>에는 실제로 사용하는 API 2개만 정의되어 있습니다:</p>\n<code-example path=\"dependency-injection-in-action/src/app/minimal-logger.service.ts\" header=\"src/app/minimal-logger.service.ts\" linenums=\"false\">\n// 이 클래스는 원래 있는 클래스의 API를 제한하기 위해 사용합니다.\n// 이 클래스에 정의되지 않은 부모 클래스의 멤버는 보이지 않게 됩니다.\nexport abstract class MinimalLogger {\n  logs: string[];\n  logInfo: (msg: string) => void;\n}\n\n</code-example>\n<!--\nThe following example puts `MinimalLogger` to use in a simplified version of `HeroOfTheMonthComponent`.\n-->\n<p>그러면 <code>HeroOfTheMonthComponent</code>는 <code>MinimalLogger</code>를 주입받아 간단한 로그 서비스를 사용할 수 잇습니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.1.ts\" header=\"src/app/hero-of-the-month.component.ts (minimal version)\" linenums=\"false\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-of-the-month',\n  templateUrl: './hero-of-the-month.component.html',\n  // TODO: 이 컴포넌트에 등록하는 것보다 AppModule에 `useExisting`으로 등록하는 것이 더 좋습니다.\n  providers: [{ provide: MinimalLogger, useExisting: LoggerService }]\n})\nexport class HeroOfTheMonthComponent {\n  logs: string[] = [];\n  constructor(logger: MinimalLogger) {\n    logger.logInfo('starting up');\n  }\n}\n\n</code-example>\n<!--\nThe `HeroOfTheMonthComponent` constructor's `logger` parameter is typed as `MinimalLogger`, so only the `logs` and `logInfo` members are visible in a TypeScript-aware editor.\n-->\n<p><code>HeroOfTheMonthComponent</code>의 생성자 인자 <code>logger</code>는 <code>MinimalLogger</code> 타입으로 지정되었기 때문에 TypeScript를 지원하는 에디터에서는 <code>logs</code>와 <code>logInfo</code> 멤버만 보이게 됩니다.</p>\n<figure>\n  <!--\n  <img src=\"generated/images/guide/dependency-injection-in-action/minimal-logger-intellisense.png\" alt=\"MinimalLogger restricted API\">\n  -->\n  <img src=\"generated/images/guide/dependency-injection-in-action/minimal-logger-intellisense.png\" alt=\"MinimalLogger로 제한된 API\" width=\"532\" height=\"60\">\n</figure>\n<!--\nBehind the scenes, Angular sets the `logger` parameter to the full service registered under the `LoggingService` token, which happens to be the `DateLoggerService` instance that was [provided above](guide/dependency-injection-in-action#useclass).\n-->\n<p>하지만 실제로 Angular가 <code>logger</code> 인자에 할당하는 것은 <code>LoggingService</code> 토큰에 해당하는 서비스 전체이며, 이 경우에는 <a href=\"guide/dependency-injection-in-action#useclass\">위에서 등록한 프로바이더</a> 때문에 <code>DateLoggerService</code>의 인스턴스가 주입됩니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nThis is illustrated in the following image, which displays the logging date.\n-->\n<p>이 코드를 실행하면 날짜와 시간을 함께 출력하는 로그 서비스가 사용되는 것을 확인할 수 있습니다.</p>\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/date-logger-entry.png\" alt=\"DateLoggerService entry\" width=\"300\" height=\"32\">\n</figure>\n</div>\n<a id=\"usefactory\"></a>\n<!--\n#### Factory providers: `useFactory`\n-->\n<h4 id=\"팩토리-프로바이더-usefactory\">팩토리 프로바이더: <code>useFactory</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#팩토리-프로바이더-usefactory\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe `useFactory` provider key lets you create a dependency object by calling a factory function,\nas in the following example.\n-->\n<p><code>useFactory</code> 프로바이더 키를 사용하면 팩토리 함수가 실행되고 반환한 객체를 의존성으로 등록할 수 있습니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"use-factory\" header=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\">\n{ provide: RUNNERS_UP,    useFactory:  runnersUpFactory(2), <a href=\"api/core/ConstructorSansProvider#deps\" class=\"code-anchor\">deps</a>: [Hero, HeroService] }\n\n</code-example>\n<!--\nThe injector provides the dependency value by invoking a factory function,\nthat you provide as the value of the `useFactory` key.\nNotice that this form of provider has a third key, `deps`, which specifies\ndependencies for the `useFactory` function.\n\nUse this technique to create a dependency object with a factory function\nwhose inputs are a combination of *injected services* and *local state*.\n\nThe dependency object (returned by the factory function) is typically a class instance,\nbut can be other things as well.\nIn this example, the dependency object is a string of the names of the runners up\nto the \"Hero of the Month\" contest.\n\nIn the example, the local state is the number `2`, the number of runners up that the component should show.\nThe state value is passed as an argument to `runnersUpFactory()`.\nThe `runnersUpFactory()` returns the *provider factory function*, which can use both\nthe passed-in state value and the injected services `Hero` and `HeroService`.\n-->\n<p>인젝터에 <code>useFactory</code> 키에 해당하는 의존성 객체 주입 요청이 들어오면 인젝터가 팩토리 함수를 실행하고 반환하는 값을 의존성으로 주입합니다.\n<code>useFactory</code> 키를 사용하는 프로바이더에는 <code><a href=\"api/core/ConstructorSansProvider#deps\" class=\"code-anchor\">deps</a></code> 키도 존재합니다. 이 키는 <code>useFactory</code> 함수에 필요한 의존성 객체를 정의할 때 사용합니다.</p>\n<p>이 방식은 <em>의존성으로 주입되는 서비스</em>를 <em>로컬 상태</em>에 맞게 재구성해야 할 때 사용합니다.</p>\n<p>팩토리 함수가 반환하는 의존성 객체는 일반적으로 클래스 인스턴스인 경우가 많지만, 반드시 그래야 하는 것은 아닙니다.\n이 예제에서도 팩토리 함수가 반환하는 의존성 객체는 \"Hero of the Month\" 컨테스트에서 우승한 히어로의 이름을 의미하는 문자열입니다.</p>\n<p>예제에서 로컬 상태는 숫자 <code>2</code>인데, 이 숫자는 컴포넌트에 표시해야 하는 우승자의 숫자입니다.\n이 값은 <code>runnersUpFactory()</code>에 인자로 주입되며, <code>runnersUpFactory()</code>가 반환하는 것은 <em>또 다른 프로바이더 팩토리 함수</em>인데, 이 팩토리 함수는 <code>Hero</code>와 <code>HeroService</code>가 서비스로 주입되어야 합니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/runners-up.ts\" region=\"factory-synopsis\" header=\"runners-up.ts (excerpt)\" linenums=\"false\">\nexport function runnersUpFactory(take: number) {\n  return (winner: Hero, heroService: HeroService): string => {\n    /* ... */\n  };\n};\n\n</code-example>\n<!--\nThe provider factory function (returned by `runnersUpFactory()`) returns the actual dependency object,\nthe string of names.\n\n* The function takes a winning `Hero` and a `HeroService` as arguments.\nAngular supplies these arguments from injected values identified by\nthe two *tokens* in the `deps` array.\n\n* The function returns the string of names, which Angular than injects into\nthe `runnersUp` parameter of `HeroOfTheMonthComponent`.\n-->\n<p><code>runnersUpFactory()</code>가 반환하는 프로바이더 팩토리 함수는 실제 의존성 객체로 주입되는 객체가 됩니다. 이 예제의 경우는 히어로들의 이름입니다.</p>\n<ul>\n<li>\n<p>이 함수는 우승한 <code>Hero</code>와 <code>HeroService</code>를 인자로 받아야 합니다.\n이 인자에 해당하는 객체는 <code><a href=\"api/core/ConstructorSansProvider#deps\" class=\"code-anchor\">deps</a></code> 배열에 등록된 <em>두 토큰</em>을 사용해서 주입됩니다.</p>\n</li>\n<li>\n<p>이 함수가 반환하는 히어로들의 이름은 최종적으로 <code>HeroOfTheMonthComponent</code>의 <code>runnersUp</code> 인자로 주입됩니다.</p>\n</li>\n</ul>\n<div class=\"alert is-helpful\">\n<!--\nThe function retrieves candidate heroes from the `HeroService`,\ntakes `2` of them to be the runners-up, and returns their concatenated names.\nLook at the <live-example name=\"dependency-injection-in-action\"></live-example>\nfor the full source code.\n-->\n<p>이 함수의 역할은 <code>HeroService</code>에서 우승 후보 히어로의 이름을 <code>2</code>개 받아와서 조합된 문자열로 반환하는 것입니다.\n<live-example name=\"dependency-injection-in-action\"></live-example>에서 전체 코드를 확인해 보세요.</p>\n</div>\n<a id=\"tokens\"></a>\n<!--\n## Provider token alternatives: class interface and 'InjectionToken'\n-->\n<h2 id=\"프로바이더-토큰-대체하기-클래스-인터페이스와-injectiontoken\">프로바이더 토큰 대체하기: 클래스 인터페이스와 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#프로바이더-토큰-대체하기-클래스-인터페이스와-injectiontoken\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAngular dependency injection is easiest when the provider token is a class\nthat is also the type of the returned dependency object, or service.\n\nHowever, a token doesn't have to be a class and even when it is a class,\nit doesn't have to be the same type as the returned object.\nThat's the subject of the next section.\n-->\n<p>Angular의 의존성 주입은 프로바이더 토큰이 클래스일 때가 가장 간단한데, 의존성 객체가 객체이거나 클래스인 경우가 이 경우에 해당됩니다.</p>\n<p>그런데 토큰이 반드시 클래스일 필요는 없으며, 토큰이 클래스이더라도 의존성으로 반환되는 객체가 꼭 그 클래스일 필요도 없습니다.\n이 내용에 대해 알아봅시다.</p>\n<a id=\"class-interface\"></a>\n<!--\n### Class interface\n-->\n<h3 id=\"클래스-인터페이스\">클래스 인터페이스<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#클래스-인터페이스\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe previous *Hero of the Month* example used the `MinimalLogger` class\nas the token for a provider of `LoggerService`.\n-->\n<p>이전에 살펴본 <em>이번 달의 히어로</em> 예제에서 <code>MinimalLogger</code> 클래스는 <code>LoggerService</code>의 토큰 역할을 하며 프로바이더에 등록되었습니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"use-existing\" header=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\">\n{ provide: MinimalLogger, useExisting: LoggerService },\n\n</code-example>\n<!--\n`MinimalLogger` is an abstract class.\n-->\n<p>그리고 <code>MinimalLogger</code>는 다음과 같은 추상 클래스입니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/minimal-logger.service.ts\" header=\"dependency-injection-in-action/src/app/minimal-logger.service.ts\" linenums=\"false\">\n// 이 클래스는 원래 있는 클래스의 API를 제한하기 위해 사용합니다.\n// 이 클래스에 정의되지 않은 부모 클래스의 멤버는 보이지 않게 됩니다.\nexport abstract class MinimalLogger {\n  logs: string[];\n  logInfo: (msg: string) => void;\n}\n\n</code-example>\n<!--\nAn abstract class is usually a base class that you can extend.\nIn this app, however there is no class that inherits from `MinimalLogger`.\nThe `LoggerService` and the `DateLoggerService`could have inherited from `MinimalLogger`,\nor they could have implemented it instead, in the manner of an interface.\nBut they did neither.\n`MinimalLogger` is used only as a dependency injection token.\n\nWhen you use a class this way, it's called a *class interface*.\n-->\n<p>추상 클래스는 상속하기 위한 기초가 되는 클래스로 사용하는 것이 일반적입니다.\n하지만 이 앱에서 <code>MinimalLogger</code>를 상속받는 클래스는 하나도 없습니다.\n물론 <code>LoggerService</code>나 <code>DateLoggerService</code>도 <code>MinimalLogger</code>를 상속받을 수 있으며, <code>MinimalLogger</code>를 인터페이스로 정의하고 이 인터페이스를 기반으로 구현할 수도 있습니다.\n하지만 이 경우는 두가지 방법 중 아무것도 사용되지 않습니다.\n<code>MinimalLogger</code>는 오로지 의존성 주입 토큰으로만 사용될 뿐입니다.</p>\n<p>클래스가 이렇게 사용되는 것을 <em>클래스 인터페이스</em>라고 합니다.</p>\n<!--\nAs mentioned in [DI Providers](guide/dependency-injection-providers#interface-not-valid-token),\nan interface is not a valid DI token because it is a TypeScript artifact that doesn't exist at run time.\nUse this abstract class interface to get the strong typing of an interface,\nand also use it as a provider token in the way you would a normal class.\n\nA  class interface should define *only* the members that its consumers are allowed to call.\nSuch a narrowing interface helps decouple the concrete class from its consumers.\n-->\n<p><a href=\"guide/dependency-injection-providers#interface-not-valid-token\">의존성 주입 프로바이더</a>에서 언급했던 것처럼, 인터페이스는 TypeScript에만 있는 개념이며 애플리케이션이 실행되는 시점에는 존재하지 않기 때문에 의존성 주입 토큰으로 사용할 수 없습니다.\n그래서 인터페이스처럼 형태를 강제할 수 있고, 일반 클래스처럼 프로바이더 토큰으로 사용할 수 있는 추상 클래스 인터페이스를 사용하는 것입니다.</p>\n<p>그리고 클래스 인터페이스에는 이 클래스가 주입된 곳에서 <em>사용할 수 있는 멤버만</em> 정의하는 것이 좋습니다.\n이렇게 인터페이스를 제한하면 클래스 사이의 결합도를 낮출 수 있습니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nUsing a class as an interface gives you the characteristics of an interface in a real JavaScript object.\nTo minimize memory cost, however, the class should have *no implementation*.\nThe `MinimalLogger` transpiles to this unoptimized, pre-minified JavaScript for a constructor function.\n-->\n<p>클래스를 인터페이스처럼 사용하면 JavaScript 환경에서도 인터페이스를 사용하는 효과를 얻을 수 있습니다.\n하지만 사용되는 메모리를 절약하기 위해 이 클래스에는 <em>실제 메소드를 정의하는 내용</em>이 없어야 합니다.\n이 클래스가 TypeScript 컴파일러에 의해 트랜스파일되고 아직 압축되기 전 시점의 JavaScript 코드는 다음과 같습니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/minimal-logger.service.ts\" region=\"minimal-logger-transpiled\" header=\"dependency-injection-in-action/src/app/minimal-logger.service.ts\" linenums=\"false\">\nvar MinimalLogger = (function () {\n  function MinimalLogger() {}\n  return MinimalLogger;\n}());\nexports(\"MinimalLogger\", MinimalLogger);\n\n</code-example>\n<!--\nNotice that it doesn't have any members. It never grows no matter how many members you add to the class,\nas long as those members are typed but not implemented.\n\nLook again at the TypeScript `MinimalLogger` class to confirm that it has no implementation.\n-->\n<p>코드를 보면 알 수 있듯이 이 클래스의 멤버는 하나도 없습니다. 왜냐하면 이 클래스에 정의된 모든 멤버는 클래스 멤버의 타입을 지정하는 용도로만 사용되었기 때문입니다.</p>\n<p><code>MinimalLogger</code> 클래스에는 메소드의 구현체를 의도적으로 정의하지 않았습니다.</p>\n</div>\n<a id=\"injection-token\"></a>\n<!--\n### 'InjectionToken' objects\n-->\n<h3 id=\"injectiontoken-객체\"><code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 객체<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#injectiontoken-객체\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nDependency objects can be simple values like dates, numbers and strings, or\nshapeless objects like arrays and functions.\n\nSuch objects don't have application interfaces and therefore aren't well represented by a class.\nThey're better represented by a token that is both unique and symbolic,\na JavaScript object that has a friendly name but won't conflict with\nanother token that happens to have the same name.\n\n`InjectionToken` has these characteristics.\nYou encountered them twice in the *Hero of the Month* example,\nin the *title* value provider and in the *runnersUp* factory provider.\n-->\n<p>의존성 객체는 Date 객체나 숫자, 문자열, 심지어 배열이나 함수가 될 수도 있습니다.</p>\n<p>그런데 이런 객체를 인터페이스로 다시 정의할 필요는 없으며 클래스로 정의해야 할 이유는 더더욱 없습니다.\n이 객체는 이름이 겹치지 않고, 그 자체로 의미를 표현할 수 있는 JavaScript 객체, 즉, 토큰이기만 하면 되고, 쉽게 이해할 수 있지만 다른 곳에서 사용하는 이름과 겹치지 않기만 하면 됩니다.</p>\n<p><code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code>은 이런 경우에 사용합니다.\n이 객체는 <em>이번 달의 히어로</em> 예제를 설명하면서 다룬 <em>TITLE</em> 값 프로바이더와 <em>RUNNERS_UP</em> 팩토리 프로바이더에 이미 사용되었습니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"provide-injection-token\" header=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" linenums=\"false\">\n{ provide: TITLE,         <a href=\"api/core/ValueSansProvider#useValue\" class=\"code-anchor\">useValue</a>:   'Hero of the Month' },\n{ provide: RUNNERS_UP,    useFactory:  runnersUpFactory(2), <a href=\"api/core/ConstructorSansProvider#deps\" class=\"code-anchor\">deps</a>: [Hero, HeroService] }\n\n</code-example>\n<!--\nYou created the `TITLE` token like this:\n-->\n<p><code>TITLE</code> 토큰은 다음과 같이 정의합니다:</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"injection-token\" header=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" linenums=\"false\">\nimport { <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a> } from '@angular/core';\n\nexport const TITLE = new <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a>&#x3C;string>('title');\n\n</code-example>\n<!--\nThe type parameter, while optional, conveys the dependency's type to developers and tooling.\nThe token description is another developer aid.\n-->\n<p>제네릭으로 사용된 타입 정보는 생략할 수 있습니다. 이 타입은 단순하게 개발자와 IDE에 좀 더 많은 정보를 제공하기 위해 지정되었습니다.\n생성자 인자로 사용한 토큰 설명도 마찬가지입니다.</p>\n<a id=\"di-inheritance\"></a>\n<!--\n## Inject into a derived class\n-->\n<h2 id=\"상속된-클래스로-의존성-주입하기\">상속된 클래스로 의존성 주입하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#상속된-클래스로-의존성-주입하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nTake care when writing a component that inherits from another component.\nIf the base component has injected dependencies,\nyou must re-provide and re-inject them in the derived class\nand then pass them down to the base class through the constructor.\n\nIn this contrived example, `SortedHeroesComponent` inherits from `HeroesBaseComponent`\nto display a *sorted* list of heroes.\n-->\n<p>어떤 컴포넌트를 상속하는 컴포넌트를 구현한다면 주의할 필요가 있습니다.\n왜냐하면 부모 컴포넌트에 의존성 주입이 필요한 경우에 이 의존성 객체는 자식 클래스에도 주입되어야 하고, 이 의존성 객체들이 자식 컴포넌트의 생성자에서 부모 컴포넌트의 생성자로 전달되어야 하기 때문입니다.</p>\n<p>이 말이 조금 이상해 보일 수도 있습니다. 이번에는 <code>HeroesBaseComponent</code>를 상속받아 히어로의 목록을 <em>정렬해서 출력하는</em> <code>SortedHeroesComponent</code>를 보면서 자세하게 알아봅시다.</p>\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/sorted-heroes.png\" alt=\"Sorted Heroes\" width=\"135\" height=\"107\">\n</figure>\n<!--\nThe `HeroesBaseComponent` can stand on its own.\nIt demands its own instance of `HeroService` to get heroes\nand displays them in the order they arrive from the database.\n-->\n<p><code>HeroesBaseComponent</code>는 단독으로도 사용할 수 있습니다.\n이 컴포넌트는 히어로의 목록을 가져오기 위해 <code>HeroService</code> 인스턴스가 필요하며, 이렇게 가져온 목록을 DB에서 꺼내온 그대로 화면에 표시합니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/sorted-heroes.component.ts\" region=\"heroes-base\" header=\"src/app/sorted-heroes.component.ts (HeroesBaseComponent)\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-unsorted-heroes',\n  template: `&#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">{{hero.name}}&#x3C;/div>`,\n  providers: [HeroService]\n})\nexport class HeroesBaseComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  constructor(private heroService: HeroService) { }\n\n  heroes: Array&#x3C;Hero>;\n\n  ngOnInit() {\n    this.heroes = this.heroService.getAllHeroes();\n    this.afterGetHeroes();\n  }\n\n  // 히어로 목록을 처리하는 로직은 자식 클래스에서 오버라이드합니다.\n  protected afterGetHeroes() {}\n\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\n### Keep constructors simple\n-->\n<h3 id=\"생성자는-간단하게-유지하세요\">생성자는 간단하게 유지하세요.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#생성자는-간단하게-유지하세요\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nConstructors should do little more than initialize variables.\nThis rule makes the component safe to construct under test without fear that it will do something dramatic like talk to the server.\nThat's why you call the `HeroService` from within the `ngOnInit` rather than the constructor.\n-->\n<p>생성자는 최대한 간단하게 작성되어야 하며 변수 초기화만 하는 것이 이상적입니다.\n이렇게 작성하면 컴포넌트가 서버와 통신하는 무언가가 실행되는 것을 배제할 수 있기 때문에 유닛 테스트를 편하게 적용할 수 있습니다.\n그래서 <code>HeroService</code>를 활용하는 로직은 생성자가 아니라 <code>ngOnInit</code>에 작성하는 것이 좋습니다.</p>\n</div>\n<!--\nUsers want to see the heroes in alphabetical order.\nRather than modify the original component, sub-class it and create a\n`SortedHeroesComponent` that sorts the heroes before presenting them.\nThe `SortedHeroesComponent` lets the base class fetch the heroes.\n\nUnfortunately, Angular cannot inject the `HeroService` directly into the base class.\nYou must provide the `HeroService` again for *this* component,\nthen pass it down to the base class inside the constructor.\n-->\n<p>히어로의 목록을 알파벳 순서로 정렬해서 보고 싶다고 합시다.\n그런데 이 때 원래 컴포넌트는 수정하지 않고 자식 클래스인 <code>SortedHeroesComponent</code>에서 히어로의 목록을 정렬한 후에 화면에 표시하려고 합니다.\n<code>SortedHeroesComponent</code>는 부모 컴포넌트가 히어로 목록을 가져온다는 것을 알고 있는 상태입니다.</p>\n<p>하지만 Angular는 의존성 객체인 <code>HeroService</code>를 부모 컴포넌트에 직접 주입할 수 없습니다.\n부모 컴포넌트에 주입되는 <code>HeroService</code>는 <em>자식</em> 컴포넌트를 통해 주입되어야 하는데, 이 예제처럼 자식 컴포넌트의 생성자에서 부모 클래스의 생성자로 전달되어야 합니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/sorted-heroes.component.ts\" region=\"sorted-heroes\" header=\"src/app/sorted-heroes.component.ts (SortedHeroesComponent)\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-sorted-heroes',\n  template: `&#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">{{hero.name}}&#x3C;/div>`,\n  providers: [HeroService]\n})\nexport class SortedHeroesComponent extends HeroesBaseComponent {\n  constructor(heroService: HeroService) {\n    super(heroService);\n  }\n\n  protected afterGetHeroes() {\n    this.heroes = this.heroes.sort((h1, h2) => {\n      return h1.name &#x3C; h2.name ? -1 :\n            (h1.name > h2.name ? 1 : 0);\n    });\n  }\n}\n\n</code-example>\n<!--\nNow take note of the `afterGetHeroes()` method.\nYour first instinct might have been to create an `ngOnInit` method in `SortedHeroesComponent` and do the sorting there.\nBut Angular calls the *derived* class's `ngOnInit` *before* calling the base class's `ngOnInit`\nso you'd be sorting the heroes array *before they arrived*. That produces a nasty error.\n\nOverriding the base class's `afterGetHeroes()` method solves the problem.\n\nThese complications argue for *avoiding component inheritance*.\n-->\n<p><code>afterGetHeroes()</code> 메소드에 대해 생각해 봅시다.\n얼핏 <code>SortedHeroesComponent</code>의 <code>ngOnInit</code> 메소드에서 히어로를 정렬하는 것이 낫다는 생각이 들 수도 있습니다.\n하지만 Angular는 <em>자식</em> 클래스의 <code>ngOnInit</code>를 부모 클래스의 <code>ngOnInit</code> 보다 <em>먼저</em> 실행하기 때문에, 이렇게 구현하면 <em>히어로의 목록을 컴포넌트에 가져오기도 전에</em> 정렬하는 로직이 실행되게 됩니다. 물론 에러가 발생합니다.</p>\n<p>그래서 <code>afterGetHeroes()</code> 메소드는 부모 클래스에 선언하고 이 함수를 자식 컴포넌트에서 오버라이드하는 방식으로 구현해야 합니다.</p>\n<p><em>컴포넌트를 상속할 때는</em> 이런 의존성 관계를 주의해야 합니다.</p>\n<a id=\"forwardref\"></a>\n<!--\n## Break circularities with a forward class reference (*forwardRef*)\n-->\n<h2 id=\"forwardref로-순환-참조-해결하기\"><em>forwardRef</em>로 순환 참조 해결하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#forwardref로-순환-참조-해결하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe order of class declaration matters in TypeScript.\nYou can't refer directly to a class until it's been defined.\n\nThis isn't usually a problem, especially if you adhere to the recommended *one class per file* rule.\nBut sometimes circular references are unavoidable.\nYou're in a bind when class 'A' refers to class 'B' and 'B' refers to 'A'.\nOne of them has to be defined first.\n\nThe Angular `forwardRef()` function creates an *indirect* reference that Angular can resolve later.\n\nThe *Parent Finder* sample is full of circular class references that are impossible to break.\n\nYou face this dilemma when a class makes *a reference to itself*\nas does `AlexComponent` in its `providers` array.\nThe `providers` array is a property of the `@Component()` decorator function which must\nappear *above* the class definition.\n\nBreak the circularity with `forwardRef`.\n-->\n<p>TypeScript에서는 클래스가 정의되는 순서도 신경써야 합니다.\n클래스는 선언되기 전에 참조할 수 없습니다.</p>\n<p>일반적인 경우에 <em>한 파일에 한 클래스</em>를 정의하는 규칙을 잘 지켰다면 이 제약은 큰 문제가 되지 않습니다.\n하지만 이 규칙을 지키는 경우에도 순환 참조가 발생할 수 있습니다.\n클래스 'A'가 클래스 'B'를 참조하는데 클래스 'B'가 다시 클래스 'A'를 참조한다고 합시다.\n이 경우에 클래스 둘 중 하나는 반드시 먼저 정의되어야 하지만, 두 클래스는 순환 참조 관계이기 때문에 어느 한 클래스가 먼저 정의될 수 없습니다.</p>\n<p>이 때 Angular가 제공하는 <code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>()</code>를 사용하면 의존성 객체에 대한 참조를 <em>간접 참조</em>로 만들면서 클래스를 생성하고, 이 의존성 객체를 나중에 처리할 수 있습니다.</p>\n<p>순환 참조가 발생하는 <em>부모 찾기(Parent Finder)</em> 예제를 확인해 보세요.</p>\n<p>이 예제에서 <code>AlexComponent</code>는 컴포넌트의 데코레이터 <code>providers</code> 배열에 바로 등록되어 있습니다.\n하지만 <code>providers</code> 배열은 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 데코레이터의 프로퍼티이기 때문에 이 클래스가 먼저 선언되어야 해당 컴포넌트를 참조할 수 있습니다.</p>\n<p>이 경우에도 <code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a></code>를 사용하면 순환 참조를 해결할 수 있습니다.</p>\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-providers\" header=\"parent-finder.component.ts (AlexComponent providers)\" linenums=\"false\">\nproviders: [{ provide: Parent, useExisting: <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() => AlexComponent) }],\n\n</code-example>\n<!--- Waiting for good examples\n\n<a id=\"directive-level-providers\"></a>\n\n<a id=\"element-level-providers\"></a>\n\n## Element-level providers\n\nA component is a specialization of directive, and the `@Component()` decorator inherits the `providers` property from `@Directive`. The injector is at the element level, so a provider configured with any element-level injector is available to any component, directive, or pipe attached to the same element.\n\nHere's a live example that implements a custom form control, taking advantage of an injector that is shared by a component and a directive on the same element.\n\nhttps://stackblitz.com/edit/basic-form-control\n\nThe component, `custom-control`, configures a provider for the DI token `NG_VALUE_ACCESSOR`.\nIn the template, the `FormControlName` directive is instantiated along with the custom component.\nIt can inject the `NG_VALUE_ACCESSOR` dependency because they share the same injector.\n(Notice that this example also makes use of `forwardRef()` to resolve a circularity in the definitions.)\n\n### Sharing a service among components\n\n__NEED TO TURN THIS INTO FULL EXTERNAL EXAMPLE__\n\nSuppose you want to share the same `HeroCacheService` among multiple components. One way to do this is to create a directive.\n\n```\n<ng-container heroCache>\n  <hero-overview></hero-overview>\n  <hero-details></hero-details>\n</ng-container>\n```\n\nUse the `@Directive()` decorator to configure the provider for the service:\n\n```\n@Directive(providers:[HeroCacheService])\n\nclass heroCache{...}\n```\n\nBecause the injectors for both the overview and details components are children of the injector created from the `heroCache` directive, they can inject things it provides.\nIf the `heroCache` directive provides the `HeroCacheService`, the two components end up sharing them.\n\nIf you want to show only one of them, use the directive to make sure __??of what??__.\n\n`<hero-overview heroCache></hero-overview>`\n\n --->\n\n</div>\n\n<!-- links to this doc:\n - api/core/Host\n - api/core/SkipSelf\n - guide/dependency-injection\n - guide/dependency-injection-navtree\n - guide/hierarchical-dependency-injection\n-->\n<!-- links from this doc:\n - api/animations/browser/testing/MockAnimationDriver#log\n - api/common/NgForOf\n - api/common/NgIf\n - api/core/ClassSansProvider#useClass\n - api/core/Component\n - api/core/ConstructorSansProvider#deps\n - api/core/Directive\n - api/core/ElementRef\n - api/core/Host\n - api/core/HostListener\n - api/core/Inject\n - api/core/Injectable\n - api/core/Injectable#providedIn\n - api/core/InjectionToken\n - api/core/Input\n - api/core/OnInit\n - api/core/Optional\n - api/core/Self\n - api/core/SkipSelf\n - api/core/ValueSansProvider#useValue\n - api/core/forwardRef\n - api/forms/DefaultValueAccessor\n - api/forms/NgModel\n - api/router/ParamMap#keys\n - api/router/RouterLinkWithHref\n - guide/attribute-directives\n - guide/dependency-injection-in-action#class-interface\n - guide/dependency-injection-in-action#forwardref로-순환-참조-해결하기\n - guide/dependency-injection-in-action#hero-bios-component\n - guide/dependency-injection-in-action#injection-token\n - guide/dependency-injection-in-action#injectiontoken-객체\n - guide/dependency-injection-in-action#inject로-커스텀-프로바이더-주입하기\n - guide/dependency-injection-in-action#optional\n - guide/dependency-injection-in-action#self와-skipself로-탐색-범위-조정하기\n - guide/dependency-injection-in-action#useclass\n - guide/dependency-injection-in-action#값-프로바이더-usevalue\n - guide/dependency-injection-in-action#다중-서비스-인스턴스-샌드박싱-sandboxing\n - guide/dependency-injection-in-action#별칭-프로바이더-useexisting\n - guide/dependency-injection-in-action#상속된-클래스로-의존성-주입하기\n - guide/dependency-injection-in-action#생략해도-되는-optional과-탐색-범위를-제한하는-host\n - guide/dependency-injection-in-action#생성자는-간단하게-유지하세요\n - guide/dependency-injection-in-action#서비스가-주입될-수-있는-범위를-특정-컴포넌트로-제한하기\n - guide/dependency-injection-in-action#실전-의존성-주입\n - guide/dependency-injection-in-action#인자-데코레이터로-의존성-객체-보정하기\n - guide/dependency-injection-in-action#중첩된-서비스-의존성\n - guide/dependency-injection-in-action#컴포넌트의-dom-엘리먼트-주입하기\n - guide/dependency-injection-in-action#클래스-인터페이스\n - guide/dependency-injection-in-action#클래스-프로바이더-useclass\n - guide/dependency-injection-in-action#팩토리-프로바이더-usefactory\n - guide/dependency-injection-in-action#프로바이더-정의하기\n - guide/dependency-injection-in-action#프로바이더-토큰-대체하기-클래스-인터페이스와-injectiontoken\n - guide/dependency-injection-in-action#프로바이더로-의존성-정의하기\n - guide/dependency-injection-providers\n - guide/dependency-injection-providers#interface-not-valid-token\n - guide/dependency-injection-providers#provide\n - guide/glossary#token\n - https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage\n - https://github.com/angular/angular/edit/master/aio/content/guide/dependency-injection-in-action.md?message=docs%3A%20describe%20your%20change...\n-->"
}