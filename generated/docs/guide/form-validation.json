{
  "id": "guide/form-validation",
  "title": "폼 유효성 검사",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/form-validation.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Form Validation\n-->\n<h1 id=\"폼-유효성-검사\">폼 유효성 검사<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#폼-유효성-검사\"><i class=\"material-icons\">link</i></a></h1>\n<!--\nImprove overall data quality by validating user input for accuracy and completeness.\n\nThis page shows how to validate user input in the UI and display useful validation messages\nusing both reactive and template-driven forms. It assumes some basic knowledge of the two\nforms modules.\n-->\n<p>폼 유효성 검사는 사용자가 폼에 입력한 내용이 올바른지 확인할 때 사용합니다.</p>\n<p>이 문서는 사용자가 폼에 입력한 내용을 어떻게 검사하는지, 검사 결과를 화면에 메시지로 표시하려면 어떻게 해야 하는지 설명합니다. 이 때 폼 반응형 폼과 템플릿 기반 폼 모두 해당되며, 두 모듈의 기본적인 내용은 이미 알고 있다고 가정합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nIf you're new to forms, start by reviewing the [Forms](guide/forms) and\n[Reactive Forms](guide/reactive-forms) guides.\n-->\n<p>폼에 대해 익숙하지 않다면 <a href=\"guide/forms\">폼</a> 문서와 <a href=\"guide/reactive-forms\">반응형 폼</a> 문서를 참고하세요.</p>\n</div>\n<!--\n## Template-driven validation\n-->\n<h2 id=\"템플릿-기반-폼-유효성-검사\">템플릿 기반 폼 유효성 검사<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#템플릿-기반-폼-유효성-검사\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nTo add validation to a template-driven form, you add the same validation attributes as you\nwould with [native HTML form validation](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation).\nAngular uses directives to match these attributes with validator functions in the framework.\n-->\n<p>템플릿 기반 폼에서는 <a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation\">네이티브 HTML 폼 유효성 검사</a>를 그대로 활용할 수 있습니다. 네이티브 유효성 검사 어트리뷰트를 사용하면, Angular가 이 어트리뷰트들을 적당한 디렉티브로 연결해서 Angular 내부 로직으로 처리합니다.</p>\n<!--\nEvery time the value of a form control changes, Angular runs validation and generates\neither a list of validation errors, which results in an INVALID status, or null, which results in a VALID status.\n-->\n<p>Angular는 폼의 내용이 바뀔때마다 다시 유효성을 검사하며, 유효성 검사 결과를 새로 반환합니다.</p>\n<!--\nYou can then inspect the control's state by exporting `ngModel` to a local template variable.\nThe following example exports `NgModel` into a variable called `name`:\n-->\n<p>폼 컨트롤의 상태는 템플릿 변수로 참조하는 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code>을 활용해서 추적할 수 있습니다.\n다음 코드는 <code>name</code> 폼 컨트롤의 유효성을 확인하는 예제입니다:</p>\n<code-example path=\"form-validation/src/app/template/hero-form-template.component.html\" region=\"name-with-error-msg\" header=\"template/hero-form-template.component.html (name)\" linenums=\"false\">\n&#x3C;input id=\"name\" name=\"name\" class=\"form-control\"\n      required <a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a>=\"4\" appForbiddenName=\"bob\"\n      [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.name\" #name=\"<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>\" >\n\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.invalid &#x26;&#x26; (name.dirty || name.touched)\"\n    class=\"alert alert-danger\">\n\n  &#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors.required\">\n    Name is required.\n  &#x3C;/div>\n  &#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors.minlength\">\n    Name must be at least 4 characters long.\n  &#x3C;/div>\n  &#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors.forbiddenName\">\n    Name cannot be Bob.\n  &#x3C;/div>\n\n&#x3C;/div>\n\n</code-example>\n<!--\nNote the following:\n-->\n<p>다음 내용을 확인해 보세요:</p>\n<!--\n* The `<input>` element carries the HTML validation attributes: `required` and `minlength`. It\nalso carries a custom validator directive, `forbiddenName`. For more\ninformation, see [Custom validators](guide/form-validation#custom-validators) section.\n-->\n<ul>\n<li><code>&#x3C;input></code> 엘리먼트에는 HTML 유효성 검사 어트리뷰트인 <code>required</code>와 <code><a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a></code>가 적용되었으며, 커스텀 유효성 검사 디렉티브인 <code>forbiddenName</code>도 적용되었습니다. 커스텀 유효성 검사기에 대해서는 <a href=\"guide/form-validation#%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%9C%A0%ED%9A%A8%EC%84%B1-%EA%B2%80%EC%82%AC%EA%B8%B0\">커스텀 유효성 검사기</a> 문서를 참고하세요.</li>\n</ul>\n<!--\n* `#name=\"ngModel\"` exports `NgModel` into a local variable called `name`. `NgModel` mirrors many of the properties of its underlying\n`FormControl` instance, so you can use this in the template to check for control states such as `valid` and `dirty`. For a full list of control properties, see the [AbstractControl](api/forms/AbstractControl)\nAPI reference.\n-->\n<ul>\n<li><code>#name=\"<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>\"</code>을 사용하면 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 폼 컨트롤을 템플릿 변수 <code>name</code>에 연결합니다. 이 변수를 활용하면 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 인스턴스에 있는 모든 프로퍼티에 접근할 수 있으며, 폼 컨트롤의 상태를 나타내는 <code>valid</code>나 <code>dirty</code>도 물론 템플릿에서 활용할 수 있습니다. 폼 컨트롤 프로퍼티의 전체 목록은 <a href=\"api/forms/AbstractControl\">AbstractControl</a> 문서를 확인하세요.</li>\n</ul>\n<!--\n* The `*ngIf` on the `<div>` element reveals a set of nested message `divs`\nbut only if the `name` is invalid and the control is either `dirty` or `touched`.\n-->\n<ul>\n<li><code>&#x3C;div></code> 엘리먼트에 사용된 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>는 이 엘리먼트 안에 있는 모든 <code>&#x3C;div></code>가 화면에 표시되는 것을 제어하기 위해 사용합니다. 이 엘리먼트는 <code>name</code> 폼 컨트롤이 <code>dirty</code>나 <code>touched</code> 상태이고 입력된 값이 유효하지 않을 때 표시됩니다.</li>\n</ul>\n<!--\n* Each nested `<div>` can present a custom message for one of the possible validation errors.\nThere are messages for `required`, `minlength`, and `forbiddenName`.\n-->\n<ul>\n<li>각각의 <code>&#x3C;div></code> 엘리먼트는 에러로 발생할 수 있는 각 상황의 에러 메시지를 표현합니다. 이 코드에서는 <code>required</code>와 <code><a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a></code>, <code>forbiddenName</code> 과 관련된 메시지가 작성되어 있습니다.</li>\n</ul>\n<div class=\"alert is-helpful\">\n<!--\n#### Why check _dirty_ and _touched_?\n-->\n<h4 id=\"왜-dirty-와-touched-를-확인할까요\">왜 <em>dirty</em> 와 <em>touched</em> 를 확인할까요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#왜-dirty-와-touched-를-확인할까요\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nYou may not want your application to display errors before the user has a chance to edit the form.\nThe checks for `dirty` and `touched` prevent errors from showing until the user\ndoes one of two things: changes the value,\nturning the control dirty; or blurs the form control element, setting the control to touched.\n-->\n<p>사용자가 폼의 내용을 수정하기 전에는 에러 메시지를 표시하지 않는 것이 자연스럽습니다.\n그래서 <code>dirty</code>와 <code>touched</code> 상태를 조건에 포함시켰으며, 이제는 사용자가 입력된 내용을 변경해서 <em>dirty</em> 상태가 되거나 폼 컨트롤에 접근한 뒤에 포커스를 옮겼을 때(<em>touched</em>)부터 에러 메시지가 표시됩니다.</p>\n</div>\n<!--\n## Reactive form validation\n-->\n<h2 id=\"반응형-폼-유효성-검사\">반응형 폼 유효성 검사<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#반응형-폼-유효성-검사\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nIn a reactive form, the source of truth is the component class. Instead of adding validators through attributes in the template, you add validator functions directly to the form control model in the component class. Angular then calls these functions whenever the value of the control changes.\n-->\n<p>반응형 폼에서는 유효성 검사 결과가 컴포넌트 클래스에서 전달됩니다. 그래서 유효성 검사 어트리뷰트는 템플릿에서 적용하지 않고 컴포넌트 클래스에서 폼 컨트롤 모델을 정의할 때 유효성 검사기로 적용합니다. 이 함수는 해당 폼 컨트롤의 값이 변경될 때마다 실행됩니다.</p>\n<!--\n### Validator functions\n-->\n<h3 id=\"유효성-검사기\">유효성 검사기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#유효성-검사기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThere are two types of validator functions: sync validators and async validators.\n\n* **Sync validators**: functions that take a control instance and immediately return either a set of validation errors or `null`. You can pass these in as the second argument when you instantiate a `FormControl`.\n\n* **Async validators**: functions that take a control instance and return a Promise\nor Observable that later emits a set of validation errors or `null`. You can\npass these in as the third argument when you instantiate a `FormControl`.\n\nNote: for performance reasons, Angular only runs async validators if all sync validators pass. Each must complete before errors are set.\n-->\n<p>유효성 검사기는 동기(sync), 비동기(async) 두 종류가 있습니다.</p>\n<ul>\n<li>\n<p><strong>동기 유효성 검사기</strong> : 유효성 검사 결과를 바로 반환하는 함수입니다. <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 인스턴스를 생성할 때 두번째 인자로 지정하며, 유효성 검사 결과는 에러 객채이거나 <code>null</code>입니다.</p>\n</li>\n<li>\n<p><strong>비동기 유효성 검사기</strong> : 유효성 검사 결과를 Promise나 Observable로 감싸서 반환하는 함수입니다. <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 인스턴스를 생성할 때 세번째 인자로 지정합니다.</p>\n</li>\n</ul>\n<p>참고 : 성능 이슈로 인해 비동기 유효성 검사기는 동기 유효성 검사기가 모두 실행된 이후에 실행됩니다. 그리고 유효성 검사 결과는 모든 검사가 완료된 이후에 설정됩니다.</p>\n<!--\n### Built-in validators\n-->\n<h3 id=\"기본-유효성-검사기\">기본 유효성 검사기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#기본-유효성-검사기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou can choose to [write your own validator functions](guide/form-validation#custom-validators), or you can use some of\nAngular's built-in validators.\n-->\n<p>유효성 검사기는 <a href=\"guide/form-validation#%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%9C%A0%ED%9A%A8%EC%84%B1-%EA%B2%80%EC%82%AC%EA%B8%B0\">커스텀 유효성 검사기</a>를 만들어서 활용할 수도 있고, Angular 기본 유효성 검사기를 활용할 수도 있습니다.</p>\n<!--\nThe same built-in validators that are available as attributes in template-driven forms, such as `required` and `minlength`, are all available to use as functions from the `Validators` class. For a full list of built-in validators, see the [Validators](api/forms/Validators) API reference.\n-->\n<p>템플릿 기반 폼에서 사용한 <code>required</code>나 <code><a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a></code>와 같은 어트리뷰트는 Angular 기본 유효성 검사기로 모두 제공됩니다. 이 유효성 검사기들은 <code><a href=\"api/forms/Validators\" class=\"code-anchor\">Validators</a></code> 클래스에 선언되어 있으며, 목록을 확인하려면 <a href=\"api/forms/Validators\">Validators</a> API 문서를 확인하세요.</p>\n<!--\nTo update the hero form to be a reactive form, you can use some of the same\nbuilt-in validators&mdash;this time, in function form. See below:\n-->\n<p>그래서 폼을 반응형으로 변경하더라도 기존에 사용하던 유효성 검사기는 모두 사용할 수 있습니다. 다음 코드를 참고하세요:</p>\n<a id=\"reactive-component-class\"></a>\n<code-example path=\"form-validation/src/app/reactive/hero-form-reactive.component.1.ts\" region=\"form-group\" header=\"reactive/hero-form-reactive.component.ts (validator functions)\" linenums=\"false\">\nngOnInit(): void {\n  this.heroForm = new <a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a>({\n    'name': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.name, [\n      Validators.required,\n      Validators.minLength(4),\n      forbiddenNameValidator(/bob/i) // &#x3C;-- 커스텀 유효성 검사기의 인자는 이렇게 전달합니다.\n    ]),\n    'alterEgo': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.alterEgo),\n    'power': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.power, Validators.required)\n  });\n\n}\n\nget name() { return this.heroForm.get('name'); }\n\nget power() { return this.heroForm.get('power'); }\n\n</code-example>\n<!--\nNote that:\n-->\n<p>다음 내용을 확인해 보세요:</p>\n<!--\n* The name control sets up two built-in validators&mdash;`Validators.required` and `Validators.minLength(4)`&mdash;and one custom validator, `forbiddenNameValidator`. For more details see the [Custom validators](guide/form-validation#custom-validators) section in this guide.\n* As these validators are all sync validators, you pass them in as the second argument.\n* Support multiple validators by passing the functions in as an array.\n* This example adds a few getter methods. In a reactive form, you can always access any form control through the `get` method on its parent group, but sometimes it's useful to define getters as shorthands\nfor the template.\n-->\n<ul>\n<li>이름에 해당하는 폼 컨트롤에는 기본 유효성 검사기인 <code>Validators.required</code>와 <code>Validators.minLength(4)</code>가 적용되었으며, 커스텀 유효성 검사기인 <code>forbiddenNameValidator</code>가 적용되었습니다. <a href=\"guide/form-validation#%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%9C%A0%ED%9A%A8%EC%84%B1-%EA%B2%80%EC%82%AC%EA%B8%B0\">커스텀 유효성 검사기</a>는 아래에서 다시 설명합니다.</li>\n<li>이 코드에 적용된 유효성 검사기는 모두 동기 함수입니다. 따라서 유효성 검사기는 모두 폼 컨트롤의 두 번째 인자로 전달합니다.</li>\n<li>유효성 검사기를 한번에 여러개 적용하려면 배열 형태로 전달합니다.</li>\n<li>이 예제에는 <code>name</code>과 <code>power</code> 필드에 게터(getter) 함수가 지정되었습니다. 반응형으로 폼을 구성하고, 템플릿에서 폼 컨트롤의 상태나 값을 참조한다면 게터 함수를 사용하는 것이 편합니다.</li>\n</ul>\n<!--\nIf you look at the template for the name input again, it is fairly similar to the template-driven example.\n-->\n<p>이 내용은 템플릿 기반 폼을 다룰 때와 비슷하게 템플릿에 적용할 수 있습니다.</p>\n<code-example path=\"form-validation/src/app/reactive/hero-form-reactive.component.html\" region=\"name-with-error-msg\" header=\"reactive/hero-form-reactive.component.html (name with error msg)\" linenums=\"false\">\n&#x3C;input id=\"name\" class=\"form-control\"\n      <a href=\"api/forms/FormControlName\" class=\"code-anchor\">formControlName</a>=\"name\" required >\n\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.invalid &#x26;&#x26; (name.dirty || name.touched)\"\n    class=\"alert alert-danger\">\n\n  &#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors.required\">\n    Name is required.\n  &#x3C;/div>\n  &#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors.minlength\">\n    Name must be at least 4 characters long.\n  &#x3C;/div>\n  &#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors.forbiddenName\">\n    Name cannot be Bob.\n  &#x3C;/div>\n&#x3C;/div>\n\n</code-example>\n<!--\nKey takeaways:\n-->\n<p>다음 내용을 확인해 보세요:</p>\n<!--\n * The form no longer exports any directives, and instead uses the `name` getter defined in\n the component class.\n * The `required` attribute is still present. While it's not necessary for validation purposes,\n you may want to keep it in your template for CSS styling or accessibility reasons.\n-->\n<ul>\n<li>템플릿 기반 폼에서 사용하던 템플릿 참조 변수 대신 컴포넌트 클래스에 선언된 <code>name</code> 게터 함수를 사용합니다.</li>\n<li><code>required</code> 어트리뷰트는 여전히 존재합니다. 이 어트리뷰트는 유효성을 검사하기 위한 용도로도 사용하지만, 템플릿에 CSS 스타일을 적용할 때도 사용하며, 웹 접근성에도 사용됩니다.</li>\n</ul>\n<!--\n## Custom validators\n-->\n<h2 id=\"커스텀-유효성-검사기\">커스텀 유효성 검사기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#커스텀-유효성-검사기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nSince the built-in validators won't always match the exact use case of your application, sometimes you'll want to create a custom validator.\n\nConsider the `forbiddenNameValidator` function from previous\n[examples](guide/form-validation#reactive-component-class) in\nthis guide. Here's what the definition of that function looks like:\n-->\n<p>Angular의 기본 유효성 검사기가 애플리케이션의 요구사항을 모두 만족시킬 수는 없기 때문에, 커스텀 유효성 검사기를 만들어서 활용할 수도 있습니다.</p>\n<p><a href=\"guide/form-validation#reactive-component-class\">이전 예제</a>에서 살펴본 <code>forbiddenNameValidator</code> 함수를 구현해봅시다. 이 함수는 다음과 같이 정의합니다:</p>\n<code-example path=\"form-validation/src/app/shared/forbidden-name.directive.ts\" region=\"custom-validator\" header=\"shared/forbidden-name.directive.ts (forbiddenNameValidator)\" linenums=\"false\">\n/** 히어로의 이름은 인자로 받은 정규표현식에 매칭되지 않아야 합니다.  */\nexport function forbiddenNameValidator(nameRe: RegExp): <a href=\"api/forms/ValidatorFn\" class=\"code-anchor\">ValidatorFn</a> {\n  return (control: <a href=\"api/forms/AbstractControl\" class=\"code-anchor\">AbstractControl</a>): {[key: string]: any} | null => {\n    const forbidden = nameRe.test(control.value);\n    return forbidden ? {'forbiddenName': {value: control.value}} : null;\n  };\n}\n\n</code-example>\n<!--\nThe function is actually a factory that takes a regular expression to detect a _specific_ forbidden name and returns a validator function.\n-->\n<p>이 함수의 실제 역할은 팩토리 함수일 뿐이며, <em>금지할 이름에 해당하는</em> 정규 표현식을 인자로 받고 유효성 검사기를 함수 형태로 반환합니다.</p>\n<!--\nIn this sample, the forbidden name is \"bob\", so the validator will reject any hero name containing \"bob\".\nElsewhere it could reject \"alice\" or any name that the configuring regular expression matches.\n-->\n<p>컴포넌트에 정의한 대로라면 \"bob\"이라는 이름이 금지되며, \"bob\"이 아닌 값은 모두 유효합니다.\n다른 이름을 금지하려면 인자로 전달하는 정규 표현식을 수정하면 됩니다.</p>\n<!--\nThe `forbiddenNameValidator` factory returns the configured validator function.\nThat function takes an Angular control object and returns _either_\nnull if the control value is valid _or_ a validation error object.\nThe validation error object typically has a property whose name is the validation key, `'forbiddenName'`,\nand whose value is an arbitrary dictionary of values that you could insert into an error message, `{name}`.\n-->\n<p><code>forbiddenNameValidator</code> 팩토리는 유효성 검사기를 반환합니다.\n이 함수는 Angular 폼 컨트롤 객체를 인자로 받으며, 유효성 검사에 실패하면 에러 오브젝트를 반환하고 유효성 검사를 통과하면 null을 반환합니다.\n에러 오브젝트의 프로퍼티는 보통 유효성 검사기의 이름을 지정하기 때문에 <code>'forbiddenName'</code>으로 선언했으며, 이 프로퍼티의 값은 폼 컨트롤의 현재값을 할당했습니다. 이 에러 객체를 활용하면 어떤 값이 입력되어서 잘못되었는지 템플릿에 표시할 수 있습니다.</p>\n<!--\nCustom async validators are similar to sync validators, but they must instead return a Promise or Observable\nthat later emits null or a validation error object. In the case of an Observable, the Observable must complete,\nat which point the form uses the last value emitted for validation.\n-->\n<p>커스텀 비동기 유효성 검사기는 반환 타입이 Promise나 Observable인 것만 빼면 동기 유효성 검사기와 비슷하며, 이 객체 안에 에러 객체나 null을 반환합니다.\n만약 반환 타입이 옵저버블이라면 유효성 검사 로직이 종료된 이후에 이 옵저버블은 반드시 종료되어야 합니다.</p>\n<!--\n### Adding to reactive forms\n-->\n<h3 id=\"반응형-폼에-적용하기\">반응형 폼에 적용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#반응형-폼에-적용하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn reactive forms, custom validators are fairly simple to add. All you have to do is pass the function directly\nto the `FormControl`.\n-->\n<p>커스텀 유효성 검사기를 반응형 폼에 적용하는 것은 아주 간단합니다. <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 인스턴스를 생성할 때 인자로 전달하기만 하면 됩니다.</p>\n<code-example path=\"form-validation/src/app/reactive/hero-form-reactive.component.1.ts\" region=\"custom-validator\" header=\"reactive/hero-form-reactive.component.ts (validator functions)\" linenums=\"false\">\nthis.heroForm = new <a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a>({\n  'name': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.name, [\n    Validators.required,\n    Validators.minLength(4),\n    forbiddenNameValidator(/bob/i) // &#x3C;-- 커스텀 유효성 검사기의 인자는 이렇게 전달합니다.\n  ]),\n  'alterEgo': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.alterEgo),\n  'power': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.power, Validators.required)\n});\n\n</code-example>\n<!--\n### Adding to template-driven forms\n-->\n<h3 id=\"템플릿-기반-폼에-적용하기\">템플릿 기반 폼에 적용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#템플릿-기반-폼에-적용하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn template-driven forms, you don't have direct access to the `FormControl` instance, so you can't pass the\nvalidator in like you can for reactive forms. Instead, you need to add a directive to the template.\n-->\n<p>템플릿 기반 폼에서는 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 인스턴스에 직접 접근할 수 없기 때문에 반응형 폼의 방식을 사용할 수 없습니다. 대신 유효성 검사기를 디렉티브로 감싸서 활용합니다.</p>\n<!--\nThe corresponding `ForbiddenValidatorDirective` serves as a wrapper around the `forbiddenNameValidator`.\n-->\n<p><code>forbiddenNameValidator</code>를 디렉티브로 랩핑한 <code>ForbiddenValidatorDirective</code>를 정의해 봅시다.</p>\n<!--\nAngular recognizes the directive's role in the validation process because the directive registers itself\nwith the `NG_VALIDATORS` provider, a provider with an extensible collection of validators.\n-->\n<p>이 디렉티브의 역할이 유효성 검사라는 것을 Angular에게 알리기 위해 <code><a href=\"api/forms/NG_VALIDATORS\" class=\"code-anchor\">NG_VALIDATORS</a></code> 프로바이더를 사용하며, Angular의 기본 디렉티브 목록에 이 디렉티브를 추가하도록 다음과 같이 등록합니다.</p>\n<code-example path=\"form-validation/src/app/shared/forbidden-name.directive.ts\" region=\"directive-providers\" header=\"shared/forbidden-name.directive.ts (providers)\" linenums=\"false\">\nproviders: [{provide: <a href=\"api/forms/NG_VALIDATORS\" class=\"code-anchor\">NG_VALIDATORS</a>, useExisting: ForbiddenValidatorDirective, multi: true}]\n\n</code-example>\n<!--\nThe directive class then implements the `Validator` interface, so that it can easily integrate\nwith Angular forms. Here is the rest of the directive to help you get an idea of how it all\ncomes together:\n-->\n<p>그리고 디렉티브 클래스는 <code><a href=\"api/forms/Validator\" class=\"code-anchor\">Validator</a></code> 인터페이스를 사용해서 구현하는데, 이 인터페이스를 사용하면 Angular 폼과 호환되도록 클래스를 정의할 수 있습니다.\n디렉티브 클래스는 다음과 같이 정의합니다:</p>\n<code-example path=\"form-validation/src/app/shared/forbidden-name.directive.ts\" region=\"directive\" header=\"shared/forbidden-name.directive.ts (directive)\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: '[appForbiddenName]',\n  providers: [{provide: <a href=\"api/forms/NG_VALIDATORS\" class=\"code-anchor\">NG_VALIDATORS</a>, useExisting: ForbiddenValidatorDirective, multi: true}]\n})\nexport class ForbiddenValidatorDirective implements <a href=\"api/forms/Validator\" class=\"code-anchor\">Validator</a> {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('appForbiddenName') forbiddenName: string;\n\n  validate(control: <a href=\"api/forms/AbstractControl\" class=\"code-anchor\">AbstractControl</a>): {[key: string]: any} | null {\n    return this.forbiddenName ? forbiddenNameValidator(new RegExp(this.forbiddenName, 'i'))(control)\n                              : null;\n  }\n}\n\n</code-example>\n<!--\nOnce the `ForbiddenValidatorDirective` is ready, you can simply add its selector, `appForbiddenName`, to any input element to activate it. For example:\n-->\n<p><code>ForbiddenValidatorDirective</code>를 등록하고 나면 <code>appForbiddenName</code> 어트리뷰트를 사용해서 엘리먼트에 적용할 수 있습니다. 다음과 같이 적용합니다:</p>\n<code-example path=\"form-validation/src/app/template/hero-form-template.component.html\" region=\"name-input\" header=\"template/hero-form-template.component.html (forbidden-name-input)\" linenums=\"false\">\n&#x3C;input id=\"name\" name=\"name\" class=\"form-control\"\n      required <a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a>=\"4\" appForbiddenName=\"bob\"\n      [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.name\" #name=\"<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>\" >\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\nYou may have noticed that the custom validation directive is instantiated with `useExisting`\nrather than `useClass`. The registered validator must be _this instance_ of\nthe `ForbiddenValidatorDirective`&mdash;the instance in the form with\nits `forbiddenName` property bound to “bob\". If you were to replace\n`useExisting` with `useClass`, then you’d be registering a new class instance, one that\ndoesn’t have a `forbiddenName`.\n-->\n<p>커스텀 유효성 검사 디렉티브의 인스턴스는 <code>useClass</code>가 아니라 <code>useExisting</code>을 사용해서 생성됩니다.\n이렇게 생성된 디렉티브의 인스턴스는 \"bob\"에 해당하는 정규표현식이 적용된 인스턴스이며, <code>useExisting</code> 대신 <code>useClass</code>를 사용하면 이 디렉티브를 사용할 때마다 새로운 인스턴스가 생성되며, 이때마다 <code>forbiddenName</code> 대신 다른 디렉티브 셀렉터를 다시 등록해야 합니다.</p>\n</div>\n<!--\n## Control status CSS classes\n-->\n<h2 id=\"css-클래스-활용하기\">CSS 클래스 활용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#css-클래스-활용하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nLike in AngularJS, Angular automatically mirrors many control properties onto the form control element as CSS classes. You can use these classes to style form control elements according to the state of the form. The following classes are currently supported:\n-->\n<p>AngularJS와 비슷하게, Angular도 폼 컨트롤의 상태에 맞는 CSS 클래스를 엘리먼트에 지정합니다. 이 클래스를 활용하면 폼 컨트롤의 상태를 화면에 표시할 수 있으며, 다음과 같은 클래스들을 활용할 수 있습니다:</p>\n<ul>\n<li><code>.ng-valid</code></li>\n<li><code>.ng-invalid</code></li>\n<li><code>.ng-pending</code></li>\n<li><code>.ng-pristine</code></li>\n<li><code>.ng-dirty</code></li>\n<li><code>.ng-untouched</code></li>\n<li><code>.ng-touched</code></li>\n</ul>\n<!--\nThe hero form uses the `.ng-valid` and `.ng-invalid` classes to\nset the color of each form control's border.\n-->\n<p>이 중 <code>.ng-valid</code>와 <code>.ng-invalid</code> 클래스를 활용해서 폼 컨트롤의 외곽선을 다르게 표시하려면 다음과 같이 작성합니다.</p>\n<code-example path=\"form-validation/src/assets/forms.css\" header=\"forms.css (status classes)\">\n\n.ng-valid[required], .ng-valid.required  {\n  border-left: 5px solid #42A948; /* green */\n}\n\n.ng-invalid:not(form)  {\n  border-left: 5px solid #a94442; /* red */\n}\n\n\n</code-example>\n<!--\n## Cross field validation\n-->\n<h2 id=\"필드-교차-검증-cross-field-validation\">필드 교차 검증 (Cross field validation)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#필드-교차-검증-cross-field-validation\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThis section shows how to perform cross field validation. It assumes some basic knowledge of creating custom validators.\n-->\n<p>이번에는 필드 교차 검증에 대해 알아봅시다. 이 내용을 확실히 이해하려면 커스텀 유효성 검사기를 어떻게 만드는지 먼저 알고 있는 것이 좋습니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nIf you haven't created custom validators before, start by reviewing the [custom validators section](guide/form-validation#custom-validators).\n-->\n<p>커스텀 유효성 검사기가 익숙하지 않다면 <a href=\"guide/form-validation#%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%9C%A0%ED%9A%A8%EC%84%B1-%EA%B2%80%EC%82%AC%EA%B8%B0\">커스텀 유효성 검사기</a> 문서를 먼저 보는 것을 권장합니다.</p>\n</div>\n<!--\nIn the following section, we will make sure that our heroes do not reveal their true identities by filling out the Hero Form. We will do that by validating that the hero names and alter egos do not match.\n-->\n<p>앞으로 살펴볼 예제에서 우리는 히어로 폼을 수정해서 히어로의 진짜 정체가 드러나지 않도록 할 것입니다. 히어로의 이름과 별명을 똑같이 입력할 수 없도록 만들어 봅시다.</p>\n<!--\n### Adding to reactive forms\n-->\n<h3 id=\"반응형-폼에-적용하기-1\">반응형 폼에 적용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#반응형-폼에-적용하기-1\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe form has the following structure:\n-->\n<p>폼은 다음과 같은 구조로 선언되어 있습니다:</p>\n<code-example language=\"javascript\">\nconst heroForm = new <a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a>({\n  'name': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(),\n  'alterEgo': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(),\n  'power': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>()\n});\n</code-example>\n<!--\nNotice that the name and alterEgo are sibling controls. To evaluate both controls in a single custom validator, we should perform the validation in a common ancestor control: the `FormGroup`. That way, we can query the `FormGroup` for the child controls which will allow us to compare their values.\n-->\n<p>이 폼에서 히어로의 이름(name)과 별명(alterEgo)은 서로 이웃한 폼 컨트롤입니다. 이 경우에 두 폼 컨트롤을 함께 검사하려면 부모 폼 컨트롤인 <code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code>에 유효성 검사기를 지정해야 합니다. 그러면 <code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code>를 참조해서 자식 폼 컨트롤에 어떤 값이 들어있는지 확인할 수 있습니다.</p>\n<!--\nTo add a validator to the `FormGroup`, pass the new validator in as the second argument on creation.\n-->\n<p><code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code>에 유효성 검사기는 폼 그룹 생성자의 두 번째 인자로 지정합니다.</p>\n<code-example language=\"javascript\">\nconst heroForm = new <a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a>({\n  'name': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(),\n  'alterEgo': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(),\n  'power': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>()\n}, { <a href=\"api/forms/AbstractControlOptions#validators\" class=\"code-anchor\">validators</a>: identityRevealedValidator });\n</code-example>\n<!--\nThe validator code is as follows:\n-->\n<p>이 때 지정한 유효성 검사기는 다음과 같이 구현되어 있습니다:</p>\n<code-example path=\"form-validation/src/app/shared/identity-revealed.directive.ts\" region=\"cross-validation-validator\" header=\"shared/identity-revealed.directive.ts\" linenums=\"false\">\n/** 히어로의 이름은 별명과 일치하지 않아야 합니다. */\nexport const identityRevealedValidator: <a href=\"api/forms/ValidatorFn\" class=\"code-anchor\">ValidatorFn</a> = (control: <a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a>): <a href=\"api/forms/ValidationErrors\" class=\"code-anchor\">ValidationErrors</a> | null => {\n  const name = control.get('name');\n  const alterEgo = control.get('alterEgo');\n\n  return name &#x26;&#x26; alterEgo &#x26;&#x26; name.value === alterEgo.value ? { 'identityRevealed': true } : null;\n};\n\n</code-example>\n<!--\nThe identity validator implements the `ValidatorFn` interface. It takes an Angular control object as an argument and returns either null if the form is valid, or `ValidationErrors` otherwise.\n-->\n<p>이 유효성 검사 함수는 <code><a href=\"api/forms/ValidatorFn\" class=\"code-anchor\">ValidatorFn</a></code> 인터페이스를 활용해서 구현했습니다. 그래서 이 함수는 Angular 폼 컨트롤 객체를 인자로 받으며, 유효성 검사에 성공하면 null을 반환하고 유효성 검사에 실패하면 <code>ValidationErros</code> 객체를 반환합니다.</p>\n<!--\nFirst we retrieve the child controls by calling the `FormGroup`'s [get](api/forms/AbstractControl#get) method. Then we simply compare the values of the `name` and `alterEgo` controls.\n-->\n<p>먼저, <code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code>의 <a href=\"api/forms/AbstractControl#get\">get</a> 메소드를 사용해서 자식 폼 컨트롤의 값을 가져옵니다. 그리고 <code>name</code>과 <code>alterEgo</code> 폼 컨트롤의 값을 비교하면 됩니다.</p>\n<!--\nIf the values do not match, the hero's identity remains secret, and we can safely return null. Otherwise, the hero's identity is revealed and we must mark the form as invalid by returning an error object.\n-->\n<p>두 필드의 값이 다르다면 히어로의 정체는 노출되지 않으며, 이것이 원하는 로직이기 때문에 null을 반환합니다. 하지만 히어로의 정체가 별명에서 그대로 드러난다면 폼 유효성 검사에 실패한 것으로 판단해야 하기 때문에 에러 객체를 반환해야 합니다.</p>\n<!--\nNext, to provide better user experience, we show an appropriate error message when the form is invalid.\n-->\n<p>그 다음에는 좀 더 편한 사용성을 제공하기 위해 에러 메시지를 폼에 표시해 봅시다.</p>\n<code-example path=\"form-validation/src/app/reactive/hero-form-reactive.component.html\" region=\"cross-validation-error-message\" header=\"reactive/hero-form-template.component.html\" linenums=\"false\">\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"heroForm.errors?.identityRevealed &#x26;&#x26; (heroForm.touched || heroForm.dirty)\" class=\"cross-validation-error-message alert alert-danger\">\n    Name cannot match alter ego.\n&#x3C;/div>\n\n</code-example>\n<!--\nNote that we check if:\n- the `FormGroup` has the cross validation error returned by the `identityRevealed` validator,\n- the user is yet to [interact](guide/form-validation#why-check-dirty-and-touched) with the form.\n-->\n<p>개선 포인트:</p>\n<ul>\n<li><code>identityRevealed</code> 유효성 검사기의 결과는 <code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code>이 처리합니다.</li>\n<li>아직 사용자가 <a href=\"guide/form-validation#%EC%99%9C-dirty-%EC%99%80-touched-%EB%A5%BC-%ED%99%95%EC%9D%B8%ED%95%A0%EA%B9%8C%EC%9A%94\">접근하지 않았는데도</a> 에러 메시지가 표시됩니다.</li>\n</ul>\n<!--\n### Adding to template driven forms\n-->\n<h3 id=\"템플릿-기반-폼에-적용하기-1\">템플릿 기반 폼에 적용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#템플릿-기반-폼에-적용하기-1\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nFirst we must create a directive that will wrap the validator function. We provide it as the validator using the `NG_VALIDATORS` token. If you are not sure why, or you do not fully understand the syntax, revisit the previous [section](guide/form-validation#adding-to-template-driven-forms).\n-->\n<p>먼저, 유효성 검사 함수를 디렉티브로 랩핑해서 <code><a href=\"api/forms/NG_VALIDATORS\" class=\"code-anchor\">NG_VALIDATORS</a></code> 토큰으로 만들어야 합니다. 왜 이렇게 해야하는지, 어떻게 해야하는지 잘 모르겠다면 <a href=\"guide/form-validation#%ED%85%9C%ED%94%8C%EB%A6%BF-%EA%B8%B0%EB%B0%98-%ED%8F%BC%EC%97%90-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0\">이 문서</a>를 참고하세요.</p>\n<code-example path=\"form-validation/src/app/shared/identity-revealed.directive.ts\" region=\"cross-validation-directive\" header=\"shared/identity-revealed.directive.ts\" linenums=\"false\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: '[appIdentityRevealed]',\n  providers: [{ provide: <a href=\"api/forms/NG_VALIDATORS\" class=\"code-anchor\">NG_VALIDATORS</a>, useExisting: IdentityRevealedValidatorDirective, multi: true }]\n})\nexport class IdentityRevealedValidatorDirective implements <a href=\"api/forms/Validator\" class=\"code-anchor\">Validator</a> {\n  validate(control: <a href=\"api/forms/AbstractControl\" class=\"code-anchor\">AbstractControl</a>): <a href=\"api/forms/ValidationErrors\" class=\"code-anchor\">ValidationErrors</a> {\n    return identityRevealedValidator(control)\n  }\n}\n\n</code-example>\n<!--\nNext, we have to add the directive to the html template. Since the validator must be registered at the highest level in the form, we put the directive on the `form` tag.\n-->\n<p>그 다음에는 이렇게 만든 디렉티브를 HTML 템플릿에 적용해야 합니다. 이 우효성 검사기는 폼의 최상위 계층에 적용되어야 하기 때문에 <code>form</code> 태그에 이 디렉티브를 지정합니다.\n<code-example path=\"form-validation/src/app/template/hero-form-template.component.html\" region=\"cross-validation-register-validator\" header=\"template/hero-form-template.component.html\" linenums=\"false\">\n&#x3C;form #heroForm=\"<a href=\"api/forms/NgForm\" class=\"code-anchor\">ngForm</a>\" appIdentityRevealed>\n\n</code-example></p>\n<!--\nTo provide better user experience, we show an appropriate error message when the form is invalid.\n-->\n<p>그리고 좀더 나은 사용성을 위해 폼 유효성 검사가 실패했을 때 에러 메시지를 표시해 줍니다.\n<code-example path=\"form-validation/src/app/template/hero-form-template.component.html\" region=\"cross-validation-error-message\" header=\"template/hero-form-template.component.html\" linenums=\"false\">\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"heroForm.errors?.identityRevealed &#x26;&#x26; (heroForm.touched || heroForm.dirty)\" class=\"cross-validation-error-message alert alert-danger\">\n    Name cannot match alter ego.\n&#x3C;/div>\n\n</code-example></p>\n<!--\nNote that we check if:\n- the form has the cross validation error returned by the `identityRevealed` validator,\n- the user is yet to [interact](guide/form-validation#why-check-dirty-and-touched) with the form.\n-->\n<p>개선 포인트:</p>\n<ul>\n<li><code>identityRevealed</code> 유효성 검사기의 결과는 폼이 처리합니다.</li>\n<li>아직 사용자가 <a href=\"guide/form-validation#%EC%99%9C-dirty-%EC%99%80-touched-%EB%A5%BC-%ED%99%95%EC%9D%B8%ED%95%A0%EA%B9%8C%EC%9A%94\">접근하지 않았는데도</a> 에러 메시지가 표시됩니다.</li>\n</ul>\n<!--\nThis completes the cross validation example. We managed to:\n- validate the form based on the values of two sibling controls,\n- show a descriptive error message after the user interacted with the form and the validation failed.\n-->\n<p>필드 교차 검증은 이것이 전부입니다. 필드 교차 검증을 활용하면 다음과 같은 기능을 구현할 수 있습니다:</p>\n<ul>\n<li>폼에 있는 여러 폼 컨트롤을 함께 검사할 수 있습니다.</li>\n<li>사용자가 폼에 접근하고 유효성 검사가 실패한 경우에 에러 메시지를 표시할 수 있습니다.</li>\n</ul>\n<!--\n## Async Validation\nThis section shows how to create asynchronous validators. It assumes some basic knowledge of creating [custom validators](guide/form-validation#custom-validators).\n-->\n<h2 id=\"비동기-유효성-검증-async-validation\">비동기 유효성 검증 (Async Validation)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#비동기-유효성-검증-async-validation\"><i class=\"material-icons\">link</i></a></h2>\n<p>이번에는 비동기 유효성 검사기를 어떻게 만들 수 있는지 알아봅시다. 이 내용은 <a href=\"guide/form-validation#%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%9C%A0%ED%9A%A8%EC%84%B1-%EA%B2%80%EC%82%AC%EA%B8%B0\">커스텀 유효성 검사기</a>를 먼저 이해하고 보는 것이 좋습니다.</p>\n<!--\n### The Basics\nJust like synchronous validators have the `ValidatorFn` and `Validator` interfaces, asynchronous validators have their own counterparts: `AsyncValidatorFn` and `AsyncValidator`.\n-->\n<h3 id=\"기본\">기본<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#기본\"><i class=\"material-icons\">link</i></a></h3>\n<p><code><a href=\"api/forms/ValidatorFn\" class=\"code-anchor\">ValidatorFn</a></code>과 <code><a href=\"api/forms/Validator\" class=\"code-anchor\">Validator</a></code> 인터페이스로 동기 유효성 검사기를 만드는 것처럼, 비동기 검사기는 <code><a href=\"api/forms/AsyncValidatorFn\" class=\"code-anchor\">AsyncValidatorFn</a></code>과 <code><a href=\"api/forms/AsyncValidator\" class=\"code-anchor\">AsyncValidator</a></code> 인터페이스로 만듭니다.</p>\n<!--\nThey are very similar with the only difference being:\n-->\n<p>이 때 동기 유효성 검사기와 비동기 유효성 검사기는 아주 비슷하지만 다른 점이 있습니다:</p>\n<!--\n* They must return a Promise or an Observable,\n* The observable returned must be finite, meaning it must complete at some point. To convert an infinite observable into a finite one, pipe the observable through a filtering operator such as `first`, `last`, `take`, or `takeUntil`.\n-->\n<ul>\n<li>비동기 유효성 검사기는 Promise나 Observable 타입을 반환해야 합니다.</li>\n<li>옵저버블이 반환된다면 이 옵저버블은 반드시 종료되어야 합니다. 중단되지 않는 옵저버블을 사용한다면 <code>first</code>, <code>last</code>, <code>take</code>, <code>takeUntil</code>과 같은 연산자를 사용해야 합니다.</li>\n</ul>\n<!--\nIt is important to note that the asynchronous validation happens after the synchronous validation, and is performed only if the synchronous validation is successful. This check allows forms to avoid potentially expensive async validation processes such as an HTTP request if more basic validation methods fail.\n-->\n<p>비동기 유효성 검사기는 동기 유효성 검사기가 모두 실행된 이후에 실행된다는 것이 중요하며, 동기 유효성 검사기를 모두 통과한 경우에만 실행됩니다. 이렇게 동작하는 이유는 이미 동기 유효성 검사를 실패했는데 HTTP 요청과 같이 좀 더 무거운 비동기 로직을 실행할 필요가 없기 때문입니다.</p>\n<!--\nAfter asynchronous validation begins, the form control enters a `pending` state. You can inspect the control's `pending` property and use it to give visual feedback about the ongoing validation.\n-->\n<p>비동기 유효성 검사가 시작되면 폼 컨트롤은 <code>pending</code> 상태가 됩니다. 이 상태는 폼 컨트롤의 <code>pending</code> 프로퍼티로 참조할 수 있으며, 현재 폼 유효성 검사가 진행중이라는 시각 효과를 표현하는 데에 활용할 수 있습니다.</p>\n<!--\nA common UI pattern is to show a spinner while the async validation is being performed. The following example presents how to achieve this with template-driven forms:\n-->\n<p>가장 일반적인 방법은 비동기 유효성 검사가 실행되는 동안 회전하는 로딩 아이콘을 표시하는 것입니다. 템플릿 기반의 폼이라면 다음과 같이 구현할 수 있습니다:</p>\n<code-example language=\"html\">\n&#x3C;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"name\" #<a href=\"api/forms/NgModel#model\" class=\"code-anchor\">model</a>=\"<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>\" appSomeAsyncValidator>\n&#x3C;app-spinner *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"model.pending\">&#x3C;/app-spinner>\n</code-example>\n<!--\n### Implementing Custom Async Validator\n-->\n<h3 id=\"커스텀-비동기-유효성-검사기-구현하기\">커스텀 비동기 유효성 검사기 구현하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#커스텀-비동기-유효성-검사기-구현하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn the following section, validation is performed asynchronously to ensure that our heroes pick an alter ego that is not already taken. New heroes are constantly enlisting and old heroes are leaving the service. That means that we do not have the list of available alter egos ahead of time.\n-->\n<p>이전 예제에서 히어로의 별명이 중복되지 않았는지 처리하는 유효성 검사는 비동기로 실행합니다. 그리고 우리가 관리하는 히어로의 목록에는 은퇴한 히어로가 없어지기도 하고 새로운 히어로가 등록되기도 합니다. 이 말은 히어로의 별명으로 사용할 수 있는 목록이 계속 바뀐다는 것을 의미합니다.</p>\n<!--\nTo validate the potential alter ego, we need to consult a central database of all currently enlisted heroes. The process is asynchronous, so we need a special validator for that.\n-->\n<p>히어로가 등록하려는 별명이 유효한지 판단하려면 DB에서 현재 등록된 히어로들의 목록을 확인해야 합니다. 이 동작은 비동기로 이루어지기 때문에 비동기로 동작하는 유효성 검사기가 필요합니다.</p>\n<!--\nLet's start by creating the validator class.\n-->\n<p>먼저 유효성 검사기 클래스를 만들어 봅시다.</p>\n<code-example path=\"form-validation/src/app/shared/alter-ego.directive.ts\" region=\"async-validator\" linenums=\"false\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({ <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root' })\nexport class UniqueAlterEgoValidator implements <a href=\"api/forms/AsyncValidator\" class=\"code-anchor\">AsyncValidator</a> {\n  constructor(private heroesService: HeroesService) {}\n\n  validate(\n    ctrl: <a href=\"api/forms/AbstractControl\" class=\"code-anchor\">AbstractControl</a>\n  ): Promise&#x3C;<a href=\"api/forms/ValidationErrors\" class=\"code-anchor\">ValidationErrors</a> | null> | Observable&#x3C;<a href=\"api/forms/ValidationErrors\" class=\"code-anchor\">ValidationErrors</a> | null> {\n    return this.heroesService.isAlterEgoTaken(ctrl.value).pipe(\n      map(isTaken => (isTaken ? { uniqueAlterEgo: true } : null)),\n      catchError(() => null)\n    );\n  }\n}\n\n</code-example>\n<!--\nAs you can see, the `UniqueAlterEgoValidator` class implements the `AsyncValidator` interface. In the constructor, we inject the `HeroesService` that has the following interface:\n-->\n<p>코드에서 확인할 수 있듯이, <code>UniqueAlterEgoValidator</code> 클래스는 <code><a href=\"api/forms/AsyncValidator\" class=\"code-anchor\">AsyncValidator</a></code> 인터페이스를 확장해서 만듭니다. 그리고 이 유효성 검사기의 생성자에 주입하는 <code>HeroesService</code>의 인터페이스는 다음과 같이 정의되어 있습니다:</p>\n<code-example language=\"typescript\">\ninterface HeroesService {\n  isAlterEgoTaken: (alterEgo: string) => Observable&#x3C;boolean>;\n}\n</code-example>\n<!--\nIn a real world application, the `HeroesService` is responsible for making an HTTP request to the hero database to check if the alter ego is available. From the validator's point of view, the actual implementation of the service is not important, so we can just code against the `HeroesService` interface.\n-->\n<p>실제 애플리케이션이라면 히어로 DB를 확인하는 HTTP 요청은 <code>Heroservice</code>가 담당합니다. 그래서 유효성 검사기의 입장에서는 이 서비스가 어떻게 구현되어 있는지 중요하지 않습니다. 이 예제에서는 <code>HeroesService</code>를 활용하는 로직을 작성하는 것에만 집중합시다.</p>\n<!--\nAs the validation begins, the `UniqueAlterEgoValidator` delegates to the `HeroesService` `isAlterEgoTaken()` method with the current control value. At this point the control is marked as `pending` and remains in this state until the observable chain returned from the `validate()` method completes.\n-->\n<p>유효성 검사가 시작되면 <code>UniqueAlterEgoValidator</code>는 <code>HeroesService</code>의 <code>isAlterEgoTaken()</code> 메소드에 폼 컨트롤 값을 전달합니다. 그러면 이 시점에 폼 컨트롤의 <code>pending</code> 상태가 설정되며, 유효성 검사기의 <code>validate()</code> 메소드가 종료되어야 <code>pending</code> 상태가 해제됩니다.</p>\n<!--\nThe `isAlterEgoTaken()` method dispatches an HTTP request that checks if the alter ego is available, and returns `Observable<boolean>` as the result. We pipe the response through the `map` operator and transform it into a validation result. As always, we return `null` if the form is valid, and `ValidationErrors` if it is not. We make sure to handle any potential errors with the `catchError` operator.\n-->\n<p><code>isAlterEgoTaken()</code> 메소드는 HTTP 요청을 보내서 인자로 받은 히어로의 별명을 사용할 수 있는지 확인하고 그 결과로 <code>Observable&#x3C;boolean></code>을 반환합니다. 그러면 이 옵저버블에 <code>map</code> 연산자를 활용해서 원하는 형태로 변환할 수 있습니다. 폼이 유효성 검사를 통과하면 <code>null</code>을 반환하고, 유효성 검사를 통과하지 못하면 <code><a href=\"api/forms/ValidationErrors\" class=\"code-anchor\">ValidationErrors</a></code>를 반환해야 합니다. 그리고 예상치 못한 에러를 처리하기 위해 <code>catchError</code> 연산자를 사용하는 것도 좋습니다.</p>\n<!--\nHere we decided that `isAlterEgoTaken()` error is treated as a successful validation, because failure to make a validation request does not necessarily mean that the alter ego is invalid. You could handle the error differently and return the `ValidationError` object instead.\n-->\n<p>이 예제에서는 <code>isAlterEgoTaken()</code>이 에러를 반환할 때 성공한 것으로 처리합니다. 왜냐하면 히어로의 별명이 사용되지 않았다면 이 별명을 새 히어로에게 붙여줄 수 있기 때문입니다. 물론 이 로직은 자유롭게 바꿀 수 있습니다.</p>\n<!--\nAfter some time passes, the observable chain completes and the async validation is done. The `pending` flag is set to `false`, and the form validity is updated.\n-->\n<p>HTTP 통신을 끝내고 나면 옵저버블 체인이 종료되면서 비동기 유효성 검사기도 종료됩니다. 이 때 <code>pending</code> 플래그가 <code>false</code>로 할당되며 폼 유효성 상태가 갱신됩니다.</p>\n<!--\n### Note on performance\n-->\n<h3 id=\"성능을-고려하세요\">성능을 고려하세요.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#성능을-고려하세요\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nBy default, all validators are run after every form value change. With synchronous validators, this will not likely have a noticeable impact on application performance. However, it's common for async validators to perform some kind of HTTP request to validate the control. Dispatching an HTTP request after every keystroke could put a strain on the backend API, and should be avoided if possible.\n-->\n<p>일반적으로 모든 유효성 검사기는 폼 값이 변경되었을 때 실행됩니다. 이 때 비동기 유효성 검사기라면 애플리케이션 성능에 큰 영향이 없겠지만, 비동기 유효성 검사기는 HTTP 통신과 같은 동작을 실행하기 때문에 애플리케이션 동작 성능에 영향이 있을 수 있습니다. 그래서 키 입력이 있을 때마다 HTTP 요청을 보낸다면 백엔드 API에 큰 부하가 걸리기 때문에, 이런 로직은 최대한 피해야 합니다.</p>\n<!--\nWe can delay updating the form validity by changing the `updateOn` property from `change` (default) to `submit` or `blur`.\n-->\n<p>그래서 폼 유효성을 검사하는 시점은 기본값인 <code>change</code>를 피해서 <code>submit</code>이나 <code>blur</code> 시점을 활용할 수도 있습니다. 이 동작은 <code>updateOn</code> 프로퍼티로 설정합니다.</p>\n<!--\nWith template-driven forms:\n-->\n<p>이 프로퍼티는 템플릿 기반 폼에서 다음과 같이 사용합니다:</p>\n<code-example language=\"html\">\n&#x3C;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"name\" [ngModelOptions]=\"{updateOn: 'blur'}\">\n</code-example>\n<!--\nWith reactive forms:\n-->\n<p>그리고 반응형 폼에서는 다음과 같이 사용합니다:</p>\n<code-example language=\"typescript\">\nnew <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>('', {updateOn: 'blur'});\n</code-example>\n<!--\n**You can run the <live-example></live-example> to see the complete reactive and template-driven example code.**\n-->\n<p><strong>이 문서에서 다룬 예제는 <live-example></live-example>에서 직접 확인하거나 다운받아 확인할 수 있습니다. 예제는 반응형 폼과 템플릿 기반 폼 모두 제공됩니다.</strong></p>\n\n</div>\n\n<!-- links to this doc:\n - api/forms/CheckboxRequiredValidator\n - api/forms/EmailValidator\n - api/forms/MaxLengthValidator\n - api/forms/MinLengthValidator\n - api/forms/PatternValidator\n - api/forms/RequiredValidator\n - guide/forms-overview\n - guide/glossary\n - guide/reactive-forms\n-->\n<!-- links from this doc:\n - api/common/NgIf\n - api/core/Directive\n - api/core/Injectable\n - api/core/Injectable#providedIn\n - api/core/Input\n - api/forms/AbstractControl\n - api/forms/AbstractControl#get\n - api/forms/AbstractControlOptions#validators\n - api/forms/AsyncValidator\n - api/forms/AsyncValidatorFn\n - api/forms/FormControl\n - api/forms/FormControlName\n - api/forms/FormGroup\n - api/forms/MinLengthValidator\n - api/forms/NG_VALIDATORS\n - api/forms/NgForm\n - api/forms/NgModel\n - api/forms/NgModel#model\n - api/forms/ValidationErrors\n - api/forms/Validator\n - api/forms/ValidatorFn\n - api/forms/Validators\n - guide/form-validation#%EC%99%9C-dirty-%EC%99%80-touched-%EB%A5%BC-%ED%99%95%EC%9D%B8%ED%95%A0%EA%B9%8C%EC%9A%94\n - guide/form-validation#%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%9C%A0%ED%9A%A8%EC%84%B1-%EA%B2%80%EC%82%AC%EA%B8%B0\n - guide/form-validation#%ED%85%9C%ED%94%8C%EB%A6%BF-%EA%B8%B0%EB%B0%98-%ED%8F%BC%EC%97%90-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0\n - guide/form-validation#css-클래스-활용하기\n - guide/form-validation#reactive-component-class\n - guide/form-validation#기본\n - guide/form-validation#기본-유효성-검사기\n - guide/form-validation#반응형-폼-유효성-검사\n - guide/form-validation#반응형-폼에-적용하기\n - guide/form-validation#반응형-폼에-적용하기-1\n - guide/form-validation#비동기-유효성-검증-async-validation\n - guide/form-validation#성능을-고려하세요\n - guide/form-validation#왜-dirty-와-touched-를-확인할까요\n - guide/form-validation#유효성-검사기\n - guide/form-validation#커스텀-비동기-유효성-검사기-구현하기\n - guide/form-validation#커스텀-유효성-검사기\n - guide/form-validation#템플릿-기반-폼-유효성-검사\n - guide/form-validation#템플릿-기반-폼에-적용하기\n - guide/form-validation#템플릿-기반-폼에-적용하기-1\n - guide/form-validation#폼-유효성-검사\n - guide/form-validation#필드-교차-검증-cross-field-validation\n - guide/forms\n - guide/reactive-forms\n - https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation\n - https://github.com/angular/angular/edit/master/aio/content/guide/form-validation.md?message=docs%3A%20describe%20your%20change...\n-->"
}