{
  "id": "guide/component-interaction",
  "title": "컴포넌트 통신",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/component-interaction.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Component interaction\n-->\n<h1 id=\"컴포넌트-통신\">컴포넌트 통신<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#컴포넌트-통신\"><i class=\"material-icons\">link</i></a></h1>\n<a id=\"top\"></a>\n<!--\nThis cookbook contains recipes for common component communication scenarios\nin which two or more components share information.\n-->\n<p>이 가이드 문서는 둘 이상의 컴포넌트가 서로 데이터를 공유하는 방법을 다룹니다.</p>\n<a id=\"toc\"></a>\n<!--\n\n# Contents\n\n* [Pass data from parent to child with input binding](guide/component-interaction#parent-to-child)\n* [Intercept input property changes with a setter](guide/component-interaction#parent-to-child-setter)\n* [Intercept input property changes with `ngOnChanges()`](guide/component-interaction#parent-to-child-on-changes)\n* [Parent calls an `@ViewChild()`](guide/component-interaction#parent-to-view-child)\n* [Parent and children communicate via a service](guide/component-interaction#bidirectional-service)\n\n-->\n<!--\n**See the <live-example name=\"component-interaction\"></live-example>**.\n-->\n<p><strong>이 문서에서 다루는 예제는 <live-example name=\"component-interaction\"></live-example>에서 확인할 수 있습니다.</strong></p>\n<a id=\"parent-to-child\"></a>\n<!--\n## Pass data from parent to child with input binding\n-->\n<h2 id=\"부모-컴포넌트에서-자식-컴포넌트로-데이터-전달하기--입력-바인딩\">부모 컴포넌트에서 자식 컴포넌트로 데이터 전달하기 : 입력 바인딩<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#부모-컴포넌트에서-자식-컴포넌트로-데이터-전달하기--입력-바인딩\"><i class=\"material-icons\">link</i></a></h2>\n<!--\n`HeroChildComponent` has two ***input properties***,\ntypically adorned with [@Input() decorator](guide/inputs-outputs#input).\n\n<code-example path=\"component-interaction/src/app/hero-child.component.ts\" header=\"component-interaction/src/app/hero-child.component.ts\">\nimport { Component, Input } from &#39;@angular/core&#39;;\n\nimport { Hero } from &#39;./hero&#39;;\n\n@Component({\n  selector: &#39;app-hero-child&#39;,\n  template: `\n    &lt;h3&gt;{{hero.name}} says:&lt;/h3&gt;\n    &lt;p&gt;I, {{hero.name}}, am at your service, {{masterName}}.&lt;/p&gt;\n  `\n})\nexport class HeroChildComponent {\n  @Input() hero: Hero;\n  @Input(&#39;master&#39;) masterName: string; // tslint:disable-line: no-input-rename\n}\n\n</code-example>\n\nThe second `@Input` aliases the child component property name `masterName` as `'master'`.\n\nThe `HeroParentComponent` nests the child `HeroChildComponent` inside an `*ngFor` repeater,\nbinding its `master` string property to the child's `master` alias,\nand each iteration's `hero` instance to the child's `hero` property.\n\n<code-example path=\"component-interaction/src/app/hero-parent.component.ts\" header=\"component-interaction/src/app/hero-parent.component.ts\">\nimport { Component } from &#39;@angular/core&#39;;\n\nimport { HEROES } from &#39;./hero&#39;;\n\n@Component({\n  selector: &#39;app-hero-parent&#39;,\n  template: `\n    &lt;h2&gt;{{master}} controls {{heroes.length}} heroes&lt;/h2&gt;\n    &lt;app-hero-child *ngFor=&quot;let hero of heroes&quot;\n      [hero]=&quot;hero&quot;\n      [master]=&quot;master&quot;&gt;\n    &lt;/app-hero-child&gt;\n  `\n})\nexport class HeroParentComponent {\n  heroes = HEROES;\n  master = &#39;Master&#39;;\n}\n\n</code-example>\n\nThe running application displays three heroes:\n\n\n<h3 class=\"no-toc\">Test it</h3>\n\nE2E test that all children were instantiated and displayed as expected:\n\n<code-example path=\"component-interaction/e2e/src/app.e2e-spec.ts\" region=\"parent-to-child\" header=\"component-interaction/e2e/src/app.e2e-spec.ts\">\n// ...\nconst heroNames = [&#39;Dr IQ&#39;, &#39;Magneta&#39;, &#39;Bombasto&#39;];\nconst masterName = &#39;Master&#39;;\n\nit(&#39;should pass properties to children properly&#39;, () =&gt; {\n  const parent = element.all(by.tagName(&#39;app-hero-parent&#39;)).get(0);\n  const heroes = parent.all(by.tagName(&#39;app-hero-child&#39;));\n\n  for (let i = 0; i &lt; heroNames.length; i++) {\n    const childTitle = heroes.get(i).element(by.tagName(&#39;h3&#39;)).getText();\n    const childDetail = heroes.get(i).element(by.tagName(&#39;p&#39;)).getText();\n    expect(childTitle).toEqual(heroNames[i] + &#39; says:&#39;);\n    expect(childDetail).toContain(masterName);\n  }\n});\n// ...\n\n</code-example>\n\n[Back to top](guide/component-interaction#top)\n-->\n<p><code>HeroChildComponent</code>에는 <strong><em>입력 프로퍼티</em></strong>가 두 개 있습니다. 입력 프로퍼티는 <a href=\"guide/inputs-outputs#input\">@Input() 데코레이터</a>를 붙여 선언합니다.</p>\n<code-example path=\"component-interaction/src/app/hero-child.component.ts\" header=\"component-interaction/src/app/hero-child.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a> } from '@angular/core';\n\nimport { Hero } from './hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-child',\n  template: `\n    &#x3C;h3>{{hero.name}} says:&#x3C;/h3>\n    &#x3C;p>I, {{hero.name}}, am at your service, {{masterName}}.&#x3C;/p>\n  `\n})\nexport class HeroChildComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('master') masterName: string; // tslint:disable-line: no-input-rename\n}\n\n</code-example>\n<p>이 코드에 선언된 입력 프로퍼티 중 두 번째 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code>에는 <code>masterName</code> 프로퍼티를 외부에서 바인딩 할 때 <code>'master'</code>라는 이름으로 사용하기 위한 선언이 추가되어 있습니다.</p>\n<p><code>HeroParentComponent</code>는 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>를 사용해서 배열에 있는 항목마다 <code>HeroChildComponent</code>를 만드는데, 각 컴포넌트를 만들때마다 <code>master</code> 문자열 프로퍼티를 자식 컴포넌트의 <code>master</code>로 연결하고, 반복되는 <code>hero</code> 인스턴스를 자식 컴포넌트의 <code>hero</code> 프로퍼티로 바인딩 합니다.</p>\n<code-example path=\"component-interaction/src/app/hero-parent.component.ts\" header=\"component-interaction/src/app/hero-parent.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\nimport { HEROES } from './hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-parent',\n  template: `\n    &#x3C;h2>{{master}} controls {{heroes.length}} heroes&#x3C;/h2>\n    &#x3C;app-hero-child *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"\n      [hero]=\"hero\"\n      [master]=\"master\">\n    &#x3C;/app-hero-child>\n  `\n})\nexport class HeroParentComponent {\n  heroes = HEROES;\n  master = 'Master';\n}\n\n</code-example>\n<p>이 애플리케이션을 실행하면 다음과 같이 세 명의 히어로가 표시됩니다:</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/component-interaction/parent-to-child.png\" alt=\"Parent-to-child\" width=\"272\" height=\"267\">\n</div>\n<h3 class=\"no-toc\" id=\"동작-확인\">동작 확인<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#동작-확인\"><i class=\"material-icons\">link</i></a></h3>\n<p>반복문을 순회하며 각각의 히어로마다 결과를 제대로 표시하는지 확인하기 위해 E2E 테스트 환경을 다음과 같이 설정합니다:</p>\n<code-example path=\"component-interaction/e2e/src/app.e2e-spec.ts\" region=\"parent-to-child\" header=\"component-interaction/e2e/src/app.e2e-spec.ts\">\n// ...\nconst heroNames = ['Dr IQ', 'Magneta', 'Bombasto'];\nconst masterName = 'Master';\n\nit('should pass properties to children properly', () => {\n  const parent = element.all(by.tagName('app-hero-parent')).get(0);\n  const heroes = parent.all(by.tagName('app-hero-child'));\n\n  for (let i = 0; i &#x3C; heroNames.length; i++) {\n    const childTitle = heroes.get(i).element(by.tagName('h3')).getText();\n    const childDetail = heroes.get(i).element(by.tagName('p')).getText();\n    expect(childTitle).toEqual(heroNames[i] + ' says:');\n    expect(childDetail).toContain(masterName);\n  }\n});\n// ...\n\n</code-example>\n<p><a href=\"guide/component-interaction#top\">맨 위로</a></p>\n<a id=\"parent-to-child-setter\"></a>\n<!--\n## Intercept input property changes with a setter\n-->\n<h2 id=\"입력-프로퍼티를-세터setter로-가로채기\">입력 프로퍼티를 세터(setter)로 가로채기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#입력-프로퍼티를-세터setter로-가로채기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nUse an input property setter to intercept and act upon a value from the parent.\n\nThe setter of the `name` input property in the child `NameChildComponent`\ntrims the whitespace from a name and replaces an empty value with default text.\n\n<code-example path=\"component-interaction/src/app/name-child.component.ts\" header=\"component-interaction/src/app/name-child.component.ts\">\nimport { Component, Input } from &#39;@angular/core&#39;;\n\n@Component({\n  selector: &#39;app-name-child&#39;,\n  template: &#39;&lt;h3&gt;&quot;{{name}}&quot;&lt;/h3&gt;&#39;\n})\nexport class NameChildComponent {\n  @Input()\n  get name(): string { return this._name; }\n  set name(name: string) {\n    this._name = (name &amp;&amp; name.trim()) || &#39;&lt;no name set&gt;&#39;;\n  }\n  private _name = &#39;&#39;;\n}\n\n</code-example>\n\nHere's the `NameParentComponent` demonstrating name variations including a name with all spaces:\n\n<code-example path=\"component-interaction/src/app/name-parent.component.ts\" header=\"component-interaction/src/app/name-parent.component.ts\">\nimport { Component } from &#39;@angular/core&#39;;\n\n@Component({\n  selector: &#39;app-name-parent&#39;,\n  template: `\n  &lt;h2&gt;Master controls {{names.length}} names&lt;/h2&gt;\n  &lt;app-name-child *ngFor=&quot;let name of names&quot; [name]=&quot;name&quot;&gt;&lt;/app-name-child&gt;\n  `\n})\nexport class NameParentComponent {\n  // &#39;Dr IQ&#39;, &#39;&lt;빈 값&gt;&#39;, &#39;Bombasto&#39;를 표시합니다.\n  names = [&#39;Dr IQ&#39;, &#39;   &#39;, &#39;  Bombasto  &#39;];\n}\n\n</code-example>\n\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/component-interaction/setter.png\" alt=\"Parent-to-child-setter\">\n</div>\n\n\n<h3 class=\"no-toc\">Test it</h3>\n\nE2E tests of input property setter with empty and non-empty names:\n\n<code-example path=\"component-interaction/e2e/src/app.e2e-spec.ts\" region=\"parent-to-child-setter\" header=\"component-interaction/e2e/src/app.e2e-spec.ts\">\n// ...\nit(&#39;should display trimmed, non-empty names&#39;, () =&gt; {\n  const nonEmptyNameIndex = 0;\n  const nonEmptyName = &#39;&quot;Dr IQ&quot;&#39;;\n  const parent = element.all(by.tagName(&#39;app-name-parent&#39;)).get(0);\n  const hero = parent.all(by.tagName(&#39;app-name-child&#39;)).get(nonEmptyNameIndex);\n\n  const displayName = hero.element(by.tagName(&#39;h3&#39;)).getText();\n  expect(displayName).toEqual(nonEmptyName);\n});\n\nit(&#39;should replace empty name with default name&#39;, () =&gt; {\n  const emptyNameIndex = 1;\n  const defaultName = &#39;&quot;&lt;no name set&gt;&quot;&#39;;\n  const parent = element.all(by.tagName(&#39;app-name-parent&#39;)).get(0);\n  const hero = parent.all(by.tagName(&#39;app-name-child&#39;)).get(emptyNameIndex);\n\n  const displayName = hero.element(by.tagName(&#39;h3&#39;)).getText();\n  expect(displayName).toEqual(defaultName);\n});\n// ...\n\n</code-example>\n\n[Back to top](guide/component-interaction#top)\n-->\n<p>부모 컴포넌트에서 값이 전달될 때 추가 로직을 실행하기 위해 입력 프로퍼티에 세터를 사용해 봅시다.</p>\n<p>자식 컴포넌트 <code>NameChildComponent</code>의 입력 프로퍼티 <code>name</code>에 세터를 연결해서 전달되는 문자열의 여백 문자를 다른 문자로 변경해 봅시다.</p>\n<code-example path=\"component-interaction/src/app/name-child.component.ts\" header=\"component-interaction/src/app/name-child.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-name-child',\n  template: '&#x3C;h3>\"{{name}}\"&#x3C;/h3>'\n})\nexport class NameChildComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()\n  get name(): string { return this._name; }\n  set name(name: string) {\n    this._name = (name &#x26;&#x26; name.trim()) || '&#x3C;no name set>';\n  }\n  private _name = '';\n}\n\n</code-example>\n<p>그리고 부모 컴포넌트인 <code>NameParentComponent</code>는 자식 컴포넌트에 다음과 같이 몇 가지 경우를 적용해 봅니다:</p>\n<code-example path=\"component-interaction/src/app/name-parent.component.ts\" header=\"component-interaction/src/app/name-parent.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-name-parent',\n  template: `\n  &#x3C;h2>Master controls {{names.length}} names&#x3C;/h2>\n  &#x3C;app-name-child *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let name of names\" [name]=\"name\">&#x3C;/app-name-child>\n  `\n})\nexport class NameParentComponent {\n  // 'Dr IQ', '&#x3C;빈 값>', 'Bombasto'를 표시합니다.\n  names = ['Dr IQ', '   ', '  Bombasto  '];\n}\n\n</code-example>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/component-interaction/setter.png\" alt=\"Parent-to-child-setter\" width=\"322\" height=\"193\">\n</div>\n<h3 class=\"no-toc\" id=\"동작-확인-1\">동작 확인<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#동작-확인-1\"><i class=\"material-icons\">link</i></a></h3>\n<p>입력 프로퍼티 세터를 테스트하는 E2E 환경은 다음과 같이 설정합니다:</p>\n<code-example path=\"component-interaction/e2e/src/app.e2e-spec.ts\" region=\"parent-to-child-setter\" header=\"component-interaction/e2e/src/app.e2e-spec.ts\">\n// ...\nit('should display trimmed, non-empty names', () => {\n  const nonEmptyNameIndex = 0;\n  const nonEmptyName = '\"Dr IQ\"';\n  const parent = element.all(by.tagName('app-name-parent')).get(0);\n  const hero = parent.all(by.tagName('app-name-child')).get(nonEmptyNameIndex);\n\n  const displayName = hero.element(by.tagName('h3')).getText();\n  expect(displayName).toEqual(nonEmptyName);\n});\n\nit('should replace empty name with default name', () => {\n  const emptyNameIndex = 1;\n  const defaultName = '\"&#x3C;no name set>\"';\n  const parent = element.all(by.tagName('app-name-parent')).get(0);\n  const hero = parent.all(by.tagName('app-name-child')).get(emptyNameIndex);\n\n  const displayName = hero.element(by.tagName('h3')).getText();\n  expect(displayName).toEqual(defaultName);\n});\n// ...\n\n</code-example>\n<p><a href=\"guide/component-interaction#top\">맨 위로</a></p>\n<a id=\"parent-to-child-on-changes\"></a>\n<!--\n## Intercept input property changes with *ngOnChanges()*\n-->\n<h2 id=\"ngonchanges로-입력-프로퍼티-가로채기\"><em>ngOnChanges()</em>로 입력 프로퍼티 가로채기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#ngonchanges로-입력-프로퍼티-가로채기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nDetect and act upon changes to input property values with the `ngOnChanges()` method of the `OnChanges` lifecycle hook interface.\n\n\n<div class=\"alert is-helpful\">\n\nYou may prefer this approach to the property setter when watching multiple, interacting input properties.\n\nLearn about `ngOnChanges()` in the [Lifecycle Hooks](guide/lifecycle-hooks) chapter.\n\n</div>\n\n\nThis `VersionChildComponent` detects changes to the `major` and `minor` input properties and composes a log message reporting these changes:\n\n<code-example path=\"component-interaction/src/app/version-child.component.ts\" header=\"component-interaction/src/app/version-child.component.ts\">\nimport { Component, Input, OnChanges, SimpleChange } from &#39;@angular/core&#39;;\n\n@Component({\n  selector: &#39;app-version-child&#39;,\n  template: `\n    &lt;h3&gt;Version {{major}}.{{minor}}&lt;/h3&gt;\n    &lt;h4&gt;Change log:&lt;/h4&gt;\n    &lt;ul&gt;\n      &lt;li *ngFor=&quot;let change of changeLog&quot;&gt;{{change}}&lt;/li&gt;\n    &lt;/ul&gt;\n  `\n})\nexport class VersionChildComponent implements OnChanges {\n  @Input() major: number;\n  @Input() minor: number;\n  changeLog: string[] = [];\n\n  ngOnChanges(changes: {[propKey: string]: SimpleChange}) {\n    const log: string[] = [];\n    for (const propName in changes) {\n      const changedProp = changes[propName];\n      const to = JSON.stringify(changedProp.currentValue);\n      if (changedProp.isFirstChange()) {\n        log.push(`Initial value of ${propName} set to ${to}`);\n      } else {\n        const from = JSON.stringify(changedProp.previousValue);\n        log.push(`${propName} changed from ${from} to ${to}`);\n      }\n    }\n    this.changeLog.push(log.join(&#39;, &#39;));\n  }\n}\n\n</code-example>\n\nThe `VersionParentComponent` supplies the `minor` and `major` values and binds buttons to methods that change them.\n\n<code-example path=\"component-interaction/src/app/version-parent.component.ts\" header=\"component-interaction/src/app/version-parent.component.ts\">\nimport { Component } from &#39;@angular/core&#39;;\n\n@Component({\n  selector: &#39;app-version-parent&#39;,\n  template: `\n    &lt;h2&gt;Source code version&lt;/h2&gt;\n    &lt;button (click)=&quot;newMinor()&quot;&gt;New minor version&lt;/button&gt;\n    &lt;button (click)=&quot;newMajor()&quot;&gt;New major version&lt;/button&gt;\n    &lt;app-version-child [major]=&quot;major&quot; [minor]=&quot;minor&quot;&gt;&lt;/app-version-child&gt;\n  `\n})\nexport class VersionParentComponent {\n  major = 1;\n  minor = 23;\n\n  newMinor() {\n    this.minor++;\n  }\n\n  newMajor() {\n    this.major++;\n    this.minor = 0;\n  }\n}\n\n</code-example>\n\n\nHere's the output of a button-pushing sequence:\n\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/component-interaction/parent-to-child-on-changes.gif\" alt=\"Parent-to-child-onchanges\">\n</div>\n\n\n<h3 class=\"no-toc\">Test it</h3>\n\nTest that ***both*** input properties are set initially and that button clicks trigger\nthe expected `ngOnChanges` calls and values:\n\n<code-example path=\"component-interaction/e2e/src/app.e2e-spec.ts\" region=\"parent-to-child-onchanges\" header=\"component-interaction/e2e/src/app.e2e-spec.ts\">\n// ...\n// 테스트는 정확히 이 순서대로 실행됩니다.\nit(&#39;should set expected initial values&#39;, () =&gt; {\n  const actual = getActual();\n\n  const initialLabel = &#39;Version 1.23&#39;;\n  const initialLog = &#39;Initial value of major set to 1, Initial value of minor set to 23&#39;;\n\n  expect(actual.label).toBe(initialLabel);\n  expect(actual.count).toBe(1);\n  expect(actual.logs.get(0).getText()).toBe(initialLog);\n});\n\nit(&#39;should set expected values after clicking \\&#39;Minor\\&#39; twice&#39;, () =&gt; {\n  const repoTag = element(by.tagName(&#39;app-version-parent&#39;));\n  const newMinorButton = repoTag.all(by.tagName(&#39;button&#39;)).get(0);\n\n  newMinorButton.click().then(() =&gt; {\n    newMinorButton.click().then(() =&gt; {\n      const actual = getActual();\n\n      const labelAfter2Minor = &#39;Version 1.25&#39;;\n      const logAfter2Minor = &#39;minor changed from 24 to 25&#39;;\n\n      expect(actual.label).toBe(labelAfter2Minor);\n      expect(actual.count).toBe(3);\n      expect(actual.logs.get(2).getText()).toBe(logAfter2Minor);\n    });\n  });\n});\n\nit(&#39;should set expected values after clicking \\&#39;Major\\&#39; once&#39;, () =&gt; {\n  const repoTag = element(by.tagName(&#39;app-version-parent&#39;));\n  const newMajorButton = repoTag.all(by.tagName(&#39;button&#39;)).get(1);\n\n  newMajorButton.click().then(() =&gt; {\n    const actual = getActual();\n\n    const labelAfterMajor = &#39;Version 2.0&#39;;\n    const logAfterMajor = &#39;major changed from 1 to 2, minor changed from 25 to 0&#39;;\n\n    expect(actual.label).toBe(labelAfterMajor);\n    expect(actual.count).toBe(4);\n    expect(actual.logs.get(3).getText()).toBe(logAfterMajor);\n  });\n});\n\nfunction getActual() {\n  const versionTag = element(by.tagName(&#39;app-version-child&#39;));\n  const label = versionTag.element(by.tagName(&#39;h3&#39;)).getText();\n  const ul = versionTag.element((by.tagName(&#39;ul&#39;)));\n  const logs = ul.all(by.tagName(&#39;li&#39;));\n\n  return {\n    label,\n    logs,\n    count: logs.count()\n  };\n}\n// ...\n\n</code-example>\n\n\n[Back to top](guide/component-interaction#top)\n-->\n<p>입력 프로퍼티는 <code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a></code> 라이프싸이클 후킹 인터페이스를 사용하는 <code>ngOnChanges()</code> 메소드로도 가로챌 수 있습니다.</p>\n<div class=\"alert is-helpful\">\n<p>입력 프로퍼티 여러개를 가로채야 한다면 세터를 사용하는 것보다 이 방식이 더 편할 수 있습니다.</p>\n<p><code>ngOnChanges()</code> 함수에 대한 자세한 설명은 <a href=\"guide/lifecycle-hooks\">라이프싸이클 후킹</a> 문서를 참고하세요.</p>\n</div>\n<p><code>VersionChildComponent</code>는 <code>major</code>와 <code>minor</code> 두 입력 프로퍼티 값이 변경되는 것을 감지하고 이 내용을 로그로 출력합니다:</p>\n<code-example path=\"component-interaction/src/app/version-child.component.ts\" header=\"component-interaction/src/app/version-child.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a>, <a href=\"api/core/SimpleChange\" class=\"code-anchor\">SimpleChange</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-version-child',\n  template: `\n    &#x3C;h3><a href=\"api/core/Version\" class=\"code-anchor\">Version</a> {{major}}.{{minor}}&#x3C;/h3>\n    &#x3C;h4>Change log:&#x3C;/h4>\n    &#x3C;ul>\n      &#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let change of changeLog\">{{change}}&#x3C;/li>\n    &#x3C;/ul>\n  `\n})\nexport class VersionChildComponent implements <a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a> {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() major: number;\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() minor: number;\n  changeLog: string[] = [];\n\n  ngOnChanges(changes: {[propKey: string]: <a href=\"api/core/SimpleChange\" class=\"code-anchor\">SimpleChange</a>}) {\n    const log: string[] = [];\n    for (const propName in changes) {\n      const changedProp = changes[propName];\n      const to = JSON.stringify(changedProp.currentValue);\n      if (changedProp.isFirstChange()) {\n        log.push(`Initial value of ${propName} set to ${to}`);\n      } else {\n        const from = JSON.stringify(changedProp.previousValue);\n        log.push(`${propName} changed from ${from} to ${to}`);\n      }\n    }\n    this.changeLog.push(log.join(', '));\n  }\n}\n\n</code-example>\n<p>그리고 부모 컴포넌트 <code>VersionParentComponent</code>는 자식 컴포넌트에 바인딩되는 <code>minor</code>, <code>major</code> 두 값을 버튼으로 조정합니다.</p>\n<code-example path=\"component-interaction/src/app/version-parent.component.ts\" header=\"component-interaction/src/app/version-parent.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-version-parent',\n  template: `\n    &#x3C;h2>Source code version&#x3C;/h2>\n    &#x3C;button (click)=\"newMinor()\">New minor version&#x3C;/button>\n    &#x3C;button (click)=\"newMajor()\">New major version&#x3C;/button>\n    &#x3C;app-version-child [major]=\"major\" [minor]=\"minor\">&#x3C;/app-version-child>\n  `\n})\nexport class VersionParentComponent {\n  major = 1;\n  minor = 23;\n\n  newMinor() {\n    this.minor++;\n  }\n\n  newMajor() {\n    this.major++;\n    this.minor = 0;\n  }\n}\n\n</code-example>\n<p>버튼을 눌렀을 때 화면은 이렇습니다:</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/component-interaction/parent-to-child-on-changes.gif\" alt=\"Parent-to-child-onchanges\" width=\"481\" height=\"264\">\n</div>\n<h3 class=\"no-toc\" id=\"동작-확인-2\">동작 확인<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#동작-확인-2\"><i class=\"material-icons\">link</i></a></h3>\n<p><strong><em>두</em></strong> 입력 프로퍼티는 초기값이 설정된 이후에 버튼을 누를 때마다 값이 변경되면서 <code>ngOnChanges()</code>를 실행하는데, 이 동작을 테스트하는 E2E 환경을 다음과 같이 정의합니다:</p>\n<code-example path=\"component-interaction/e2e/src/app.e2e-spec.ts\" region=\"parent-to-child-onchanges\" header=\"component-interaction/e2e/src/app.e2e-spec.ts\">\n// ...\n// 테스트는 정확히 이 순서대로 실행됩니다.\nit('should set expected initial values', () => {\n  const actual = getActual();\n\n  const initialLabel = '<a href=\"api/core/Version\" class=\"code-anchor\">Version</a> 1.23';\n  const initialLog = 'Initial value of major set to 1, Initial value of minor set to 23';\n\n  expect(actual.label).toBe(initialLabel);\n  expect(actual.count).toBe(1);\n  expect(actual.logs.get(0).getText()).toBe(initialLog);\n});\n\nit('should set expected values after clicking \\'Minor\\' twice', () => {\n  const repoTag = element(by.tagName('app-version-parent'));\n  const newMinorButton = repoTag.all(by.tagName('button')).get(0);\n\n  newMinorButton.click().then(() => {\n    newMinorButton.click().then(() => {\n      const actual = getActual();\n\n      const labelAfter2Minor = '<a href=\"api/core/Version\" class=\"code-anchor\">Version</a> 1.25';\n      const logAfter2Minor = 'minor changed from 24 to 25';\n\n      expect(actual.label).toBe(labelAfter2Minor);\n      expect(actual.count).toBe(3);\n      expect(actual.logs.get(2).getText()).toBe(logAfter2Minor);\n    });\n  });\n});\n\nit('should set expected values after clicking \\'Major\\' once', () => {\n  const repoTag = element(by.tagName('app-version-parent'));\n  const newMajorButton = repoTag.all(by.tagName('button')).get(1);\n\n  newMajorButton.click().then(() => {\n    const actual = getActual();\n\n    const labelAfterMajor = '<a href=\"api/core/Version\" class=\"code-anchor\">Version</a> 2.0';\n    const logAfterMajor = 'major changed from 1 to 2, minor changed from 25 to 0';\n\n    expect(actual.label).toBe(labelAfterMajor);\n    expect(actual.count).toBe(4);\n    expect(actual.logs.get(3).getText()).toBe(logAfterMajor);\n  });\n});\n\nfunction getActual() {\n  const versionTag = element(by.tagName('app-version-child'));\n  const label = versionTag.element(by.tagName('h3')).getText();\n  const ul = versionTag.element((by.tagName('ul')));\n  const logs = ul.all(by.tagName('li'));\n\n  return {\n    label,\n    logs,\n    count: logs.count()\n  };\n}\n// ...\n\n</code-example>\n<p><a href=\"guide/component-interaction#top\">맨 위로</a></p>\n<a id=\"child-to-parent\"></a>\n<!--\n## Parent listens for child event\n-->\n<h2 id=\"자식-컴포넌트에서-보내는-이벤트-받기\">자식 컴포넌트에서 보내는 이벤트 받기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#자식-컴포넌트에서-보내는-이벤트-받기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe child component exposes an `EventEmitter` property with which it `emits` events when something happens.\nThe parent binds to that event property and reacts to those events.\n\nThe child's `EventEmitter` property is an ***output property***,\n  typically adorned with an [@Output() decorator](guide/inputs-outputs#output)\n  as seen in this `VoterComponent`:\n\n<code-example path=\"component-interaction/src/app/voter.component.ts\" header=\"component-interaction/src/app/voter.component.ts\">\nimport { Component, EventEmitter, Input, Output } from &#39;@angular/core&#39;;\n\n@Component({\n  selector: &#39;app-voter&#39;,\n  template: `\n    &lt;h4&gt;{{name}}&lt;/h4&gt;\n    &lt;button (click)=&quot;vote(true)&quot;  [disabled]=&quot;didVote&quot;&gt;Agree&lt;/button&gt;\n    &lt;button (click)=&quot;vote(false)&quot; [disabled]=&quot;didVote&quot;&gt;Disagree&lt;/button&gt;\n  `\n})\nexport class VoterComponent {\n  @Input()  name: string;\n  @Output() voted = new EventEmitter&lt;boolean&gt;();\n  didVote = false;\n\n  vote(agreed: boolean) {\n    this.voted.emit(agreed);\n    this.didVote = true;\n  }\n}\n\n</code-example>\n\n\nClicking a button triggers emission of a `true` or `false`, the boolean *payload*.\n\nThe parent `VoteTakerComponent` binds an event handler called `onVoted()` that responds to the child event\npayload `$event` and updates a counter.\n\n<code-example path=\"component-interaction/src/app/votetaker.component.ts\" header=\"component-interaction/src/app/votetaker.component.ts\">\nimport { Component } from &#39;@angular/core&#39;;\n\n@Component({\n  selector: &#39;app-vote-taker&#39;,\n  template: `\n    &lt;h2&gt;Should mankind colonize the Universe?&lt;/h2&gt;\n    &lt;h3&gt;Agree: {{agreed}}, Disagree: {{disagreed}}&lt;/h3&gt;\n    &lt;app-voter *ngFor=&quot;let voter of voters&quot;\n      [name]=&quot;voter&quot;\n      (voted)=&quot;onVoted($event)&quot;&gt;\n    &lt;/app-voter&gt;\n  `\n})\nexport class VoteTakerComponent {\n  agreed = 0;\n  disagreed = 0;\n  voters = [&#39;Narco&#39;, &#39;Celeritas&#39;, &#39;Bombasto&#39;];\n\n  onVoted(agreed: boolean) {\n    agreed ? this.agreed++ : this.disagreed++;\n  }\n}\n\n</code-example>\n\nThe framework passes the event argument&mdash;represented by `$event`&mdash;to the handler method,\nand the method processes it:\n\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/component-interaction/child-to-parent.gif\" alt=\"Child-to-parent\">\n</div>\n\n\n<h3 class=\"no-toc\">Test it</h3>\n\nTest that clicking the *Agree* and *Disagree* buttons update the appropriate counters:\n\n<code-example path=\"component-interaction/e2e/src/app.e2e-spec.ts\" region=\"child-to-parent\" header=\"component-interaction/e2e/src/app.e2e-spec.ts\">\n// ...\nit(&#39;should not emit the event initially&#39;, () =&gt; {\n  const voteLabel = element(by.tagName(&#39;app-vote-taker&#39;))\n    .element(by.tagName(&#39;h3&#39;)).getText();\n  expect(voteLabel).toBe(&#39;Agree: 0, Disagree: 0&#39;);\n});\n\nit(&#39;should process Agree vote&#39;, () =&gt; {\n  const agreeButton1 = element.all(by.tagName(&#39;app-voter&#39;)).get(0)\n    .all(by.tagName(&#39;button&#39;)).get(0);\n  agreeButton1.click().then(() =&gt; {\n    const voteLabel = element(by.tagName(&#39;app-vote-taker&#39;))\n      .element(by.tagName(&#39;h3&#39;)).getText();\n    expect(voteLabel).toBe(&#39;Agree: 1, Disagree: 0&#39;);\n  });\n});\n\nit(&#39;should process Disagree vote&#39;, () =&gt; {\n  const agreeButton1 = element.all(by.tagName(&#39;app-voter&#39;)).get(1)\n    .all(by.tagName(&#39;button&#39;)).get(1);\n  agreeButton1.click().then(() =&gt; {\n    const voteLabel = element(by.tagName(&#39;app-vote-taker&#39;))\n      .element(by.tagName(&#39;h3&#39;)).getText();\n    expect(voteLabel).toBe(&#39;Agree: 1, Disagree: 1&#39;);\n  });\n});\n// ...\n\n</code-example>\n\n[Back to top](guide/component-interaction#top)\n-->\n<p>자식 컴포넌트에서 어떤 이벤트가 발생하면 이 이벤트는 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 타입으로 지정한 프로퍼티를 통해 부모 컴포넌트에게 보낼 수 있습니다.\n부모 컴포넌트는 이 이벤트를 바인딩해서 원하는 로직을 실행하면 됩니다.</p>\n<p>자식 컴포넌트에서 외부로 이벤트를 보내려면 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 타입으로 선언한 프로퍼티에 <a href=\"guide/inputs-outputs#output\">@Output() 데코레이터</a>를 사용해서 <strong><em>출력 프로퍼티</em></strong>로 지정하면 됩니다. <code>VoterComponent</code>에서는 다음과 같이 선언했습니다:</p>\n<code-example path=\"component-interaction/src/app/voter.component.ts\" header=\"component-interaction/src/app/voter.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/Output\" class=\"code-anchor\">Output</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-voter',\n  template: `\n    &#x3C;h4>{{name}}&#x3C;/h4>\n    &#x3C;button (click)=\"vote(true)\"  [disabled]=\"didVote\">Agree&#x3C;/button>\n    &#x3C;button (click)=\"vote(false)\" [disabled]=\"didVote\">Disagree&#x3C;/button>\n  `\n})\nexport class VoterComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()  name: string;\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() voted = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;boolean>();\n  didVote = false;\n\n  vote(agreed: boolean) {\n    this.voted.emit(agreed);\n    this.didVote = true;\n  }\n}\n\n</code-example>\n<p>이 예제에서 버튼을 클릭하면 자식 컴포넌트로 불리언 타입의 데이터를 전달합니다.</p>\n<p>그리고 <code>VoteTakerComponent</code>의 <code>onVoted()</code> 함수가 이벤트 객체를 인자로 받아서 <code>agree</code>와 <code>disagree</code> 카운터를 갱신합니다.</p>\n<code-example path=\"component-interaction/src/app/votetaker.component.ts\" header=\"component-interaction/src/app/votetaker.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-vote-taker',\n  template: `\n    &#x3C;h2>Should mankind colonize the Universe?&#x3C;/h2>\n    &#x3C;h3>Agree: {{agreed}}, Disagree: {{disagreed}}&#x3C;/h3>\n    &#x3C;app-voter *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let voter of voters\"\n      [name]=\"voter\"\n      (voted)=\"onVoted($event)\">\n    &#x3C;/app-voter>\n  `\n})\nexport class VoteTakerComponent {\n  agreed = 0;\n  disagreed = 0;\n  voters = ['Narco', 'Celeritas', 'Bombasto'];\n\n  onVoted(agreed: boolean) {\n    agreed ? this.agreed++ : this.disagreed++;\n  }\n}\n\n</code-example>\n<p>이 때 전달되는 이벤트 객체는 템플릿에서 <code>$event</code>라는 이름으로 접근할 수 있으며, 템플릿에서 이벤트 핸들러 함수에 인자로 전달하기 때문에 컴포넌트 클래스 코드에서 이 이벤트 객체를 활용할 수 있습니다:</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/component-interaction/child-to-parent.gif\" alt=\"Child-to-parent\" width=\"418\" height=\"342\">\n</div>\n<h3 class=\"no-toc\" id=\"동작-확인-3\">동작 확인<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#동작-확인-3\"><i class=\"material-icons\">link</i></a></h3>\n<p><em>Agree</em> 버튼이나 <em>Disagree</em> 버튼을 클릭하면 해당 카운터 값이 증가합니다.</p>\n<code-example path=\"component-interaction/e2e/src/app.e2e-spec.ts\" region=\"child-to-parent\" header=\"component-interaction/e2e/src/app.e2e-spec.ts\">\n// ...\nit('should not emit the event initially', () => {\n  const voteLabel = element(by.tagName('app-vote-taker'))\n    .element(by.tagName('h3')).getText();\n  expect(voteLabel).toBe('Agree: 0, Disagree: 0');\n});\n\nit('should process Agree vote', () => {\n  const agreeButton1 = element.all(by.tagName('app-voter')).get(0)\n    .all(by.tagName('button')).get(0);\n  agreeButton1.click().then(() => {\n    const voteLabel = element(by.tagName('app-vote-taker'))\n      .element(by.tagName('h3')).getText();\n    expect(voteLabel).toBe('Agree: 1, Disagree: 0');\n  });\n});\n\nit('should process Disagree vote', () => {\n  const agreeButton1 = element.all(by.tagName('app-voter')).get(1)\n    .all(by.tagName('button')).get(1);\n  agreeButton1.click().then(() => {\n    const voteLabel = element(by.tagName('app-vote-taker'))\n      .element(by.tagName('h3')).getText();\n    expect(voteLabel).toBe('Agree: 1, Disagree: 1');\n  });\n});\n// ...\n\n</code-example>\n<p><a href=\"guide/component-interaction#top\">맨 위로</a></p>\n<!--\n## Parent interacts with child via *local variable*\n-->\n<h2 id=\"템플릿-지역-변수로-자식-컴포넌트에-접근하기\"><em>템플릿 지역 변수</em>로 자식 컴포넌트에 접근하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#템플릿-지역-변수로-자식-컴포넌트에-접근하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nA parent component cannot use data binding to read child properties\nor invoke child methods. You can do both\nby creating a template reference variable for the child element\nand then reference that variable *within the parent template*\nas seen in the following example.\n\n<a id=\"countdown-timer-example\"></a>\n\nThe following is a child `CountdownTimerComponent` that repeatedly counts down to zero and launches a rocket.\nIt has `start` and `stop` methods that control the clock and it displays a\ncountdown status message in its own template.\n\n<code-example path=\"component-interaction/src/app/countdown-timer.component.ts\" header=\"component-interaction/src/app/countdown-timer.component.ts\">\nimport { Component, OnDestroy, OnInit } from &#39;@angular/core&#39;;\n\n@Component({\n  selector: &#39;app-countdown-timer&#39;,\n  template: &#39;&lt;p&gt;{{message}}&lt;/p&gt;&#39;\n})\nexport class CountdownTimerComponent implements OnInit, OnDestroy {\n\n  intervalId = 0;\n  message = &#39;&#39;;\n  seconds = 11;\n\n  clearTimer() { clearInterval(this.intervalId); }\n\n  ngOnInit()    { this.start(); }\n  ngOnDestroy() { this.clearTimer(); }\n\n  start() { this.countDown(); }\n  stop()  {\n    this.clearTimer();\n    this.message = `Holding at T-${this.seconds} seconds`;\n  }\n\n  private countDown() {\n    this.clearTimer();\n    this.intervalId = window.setInterval(() =&gt; {\n      this.seconds -= 1;\n      if (this.seconds === 0) {\n        this.message = &#39;Blast off!&#39;;\n      } else {\n        if (this.seconds &lt; 0) { this.seconds = 10; } // reset\n        this.message = `T-${this.seconds} seconds and counting`;\n      }\n    }, 1000);\n  }\n}\n\n\n</code-example>\n\n\nThe `CountdownLocalVarParentComponent` that hosts the timer component is as follows:\n\n<code-example path=\"component-interaction/src/app/countdown-parent.component.ts\" region=\"lv\" header=\"component-interaction/src/app/countdown-parent.component.ts\">\nimport { Component } from &#39;@angular/core&#39;;\nimport { CountdownTimerComponent } from &#39;./countdown-timer.component&#39;;\n\n@Component({\n  selector: &#39;app-countdown-parent-lv&#39;,\n  template: `\n  &lt;h3&gt;Countdown to Liftoff (via local variable)&lt;/h3&gt;\n  &lt;button (click)=&quot;timer.start()&quot;&gt;Start&lt;/button&gt;\n  &lt;button (click)=&quot;timer.stop()&quot;&gt;Stop&lt;/button&gt;\n  &lt;div class=&quot;seconds&quot;&gt;{{timer.seconds}}&lt;/div&gt;\n  &lt;app-countdown-timer #timer&gt;&lt;/app-countdown-timer&gt;\n  `,\n  styleUrls: [&#39;../assets/demo.css&#39;]\n})\nexport class CountdownLocalVarParentComponent { }\n\n</code-example>\n\n\nThe parent component cannot data bind to the child's\n`start` and `stop` methods nor to its `seconds` property.\n\nYou can place a local variable, `#timer`, on the tag `<countdown-timer>` representing the child component.\nThat gives you a reference to the child component and the ability to access\n*any of its properties or methods* from within the parent template.\n\nThis example wires parent buttons to the child's `start` and `stop` and\nuses interpolation to display the child's `seconds` property.\n\nHere we see the parent and child working together.\n\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/component-interaction/countdown-timer-anim.gif\" alt=\"countdown timer\">\n</div>\n\n\n\n<a id=\"countdown-tests\"></a>\n\n<h3 class=\"no-toc\">Test it</h3>\n\nTest that the seconds displayed in the parent template\nmatch the seconds displayed in the child's status message.\nTest also that clicking the *Stop* button pauses the countdown timer:\n\n<code-example path=\"component-interaction/e2e/src/app.e2e-spec.ts\" region=\"countdown-timer-tests\" header=\"component-interaction/e2e/src/app.e2e-spec.ts\">\n// ...\nit(&#39;timer and parent seconds should match&#39;, () =&gt; {\n  const parent = element(by.tagName(parentTag));\n  const message = parent.element(by.tagName(&#39;app-countdown-timer&#39;)).getText();\n  browser.sleep(10); // give `seconds` a chance to catchup with `message`\n  const seconds = parent.element(by.className(&#39;seconds&#39;)).getText();\n  expect(message).toContain(seconds);\n});\n\nit(&#39;should stop the countdown&#39;, () =&gt; {\n  const parent = element(by.tagName(parentTag));\n  const stopButton = parent.all(by.tagName(&#39;button&#39;)).get(1);\n\n  stopButton.click().then(() =&gt; {\n    const message = parent.element(by.tagName(&#39;app-countdown-timer&#39;)).getText();\n    expect(message).toContain(&#39;Holding&#39;);\n  });\n});\n// ...\n\n</code-example>\n\n\n[Back to top](guide/component-interaction#top)\n-->\n<p>부모 컴포넌트는 자식 컴포넌트의 프로퍼티나 메소드에 직접 접근할 수 없습니다.\n하지만 <em>부모 템플릿</em>에 템플릿 참조 변수를 선언하면 자식 컴포넌트의 프로퍼티나 메소드에 접근할 수 있습니다.</p>\n<a id=\"countdown-timer-example\"></a>\n<p>다음 예제에서 <code>CountdownTimerComponent</code>는 타이머를 동작시켜서 카운트가 0이 되면 로켓을 발사한다고 합시다.\n그리고 이 컴포넌트에 있는 <code>start</code> 메소드와 <code>stop</code> 메소드는 각각 타이머를 시작하거나 정지합니다.</p>\n<code-example path=\"component-interaction/src/app/countdown-timer.component.ts\" header=\"component-interaction/src/app/countdown-timer.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-countdown-timer',\n  template: '&#x3C;p>{{message}}&#x3C;/p>'\n})\nexport class CountdownTimerComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>, <a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a> {\n\n  intervalId = 0;\n  message = '';\n  seconds = 11;\n\n  clearTimer() { clearInterval(this.intervalId); }\n\n  ngOnInit()    { this.start(); }\n  ngOnDestroy() { this.clearTimer(); }\n\n  start() { this.countDown(); }\n  stop()  {\n    this.clearTimer();\n    this.message = `Holding at T-${this.seconds} seconds`;\n  }\n\n  private countDown() {\n    this.clearTimer();\n    this.intervalId = window.setInterval(() => {\n      this.seconds -= 1;\n      if (this.seconds === 0) {\n        this.message = 'Blast off!';\n      } else {\n        if (this.seconds &#x3C; 0) { this.seconds = 10; } // reset\n        this.message = `T-${this.seconds} seconds and counting`;\n      }\n    }, 1000);\n  }\n}\n\n\n</code-example>\n<p>부모 컴포넌트인 <code>CountdownLocalVarParentComponent</code>는 자식 컴포넌트를 다음과 같이 활용합니다:</p>\n<code-example path=\"component-interaction/src/app/countdown-parent.component.ts\" region=\"lv\" header=\"component-interaction/src/app/countdown-parent.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { CountdownTimerComponent } from './countdown-timer.component';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-countdown-parent-lv',\n  template: `\n  &#x3C;h3>Countdown to Liftoff (via local variable)&#x3C;/h3>\n  &#x3C;button (click)=\"timer.start()\">Start&#x3C;/button>\n  &#x3C;button (click)=\"timer.stop()\">Stop&#x3C;/button>\n  &#x3C;div class=\"seconds\">{{timer.seconds}}&#x3C;/div>\n  &#x3C;app-countdown-timer #timer>&#x3C;/app-countdown-timer>\n  `,\n  styleUrls: ['../assets/demo.css']\n})\nexport class CountdownLocalVarParentComponent { }\n\n</code-example>\n<p>원래 부모 컴포넌트는 자식 컴포넌트의 <code>seconds</code> 프로퍼티나 <code>start</code>, <code>stop</code> 메소드에 직접 접근할 수 없습니다.</p>\n<p>하지만 <code>&#x3C;countdown-timer></code>를 템플릿 지역 변수 <code>#timer</code>로 선언하면 이 변수를 사용해서 자식 컴포넌트에 접근할 수 있습니다.\n이 템플릿 지역 변수는 자식 컴포넌트 자체를 가리키며, 템플릿 지역 변수를 선언한 후에는 부모 컴포넌트의 템플릿에서 <em>자식 컴포넌트의 프로퍼티나 메소드</em>에 자유롭게 접근할 수 있습니다.</p>\n<p>이 예제에서는 부모 컴포넌트에 있는 버튼을 각각 자식 컴포넌트의 <code>start</code> 함수와 <code>stop</code> 함수와 연결하며, <code>seconds</code> 프로퍼티를 직접 가져와서 부모 컴포넌트에서 활용합니다.</p>\n<p>부모 컴포넌트와 자식 컴포넌트가 어떻게 연동되는지 확인해 보세요.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/component-interaction/countdown-timer-anim.gif\" alt=\"countdown timer\" width=\"212\" height=\"172\">\n</div>\n<a id=\"countdown-tests\"></a>\n<h3 class=\"no-toc\" id=\"동작-확인-4\">동작 확인<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#동작-확인-4\"><i class=\"material-icons\">link</i></a></h3>\n<p>부모 컴포넌트의 템플릿에 표시되는 타이머는 자식 컴포넌트에 있는 프로퍼티를 참조하기 때문에 자식 컴포넌트에서 표시하는 메시지와 같은 값을 표시합니다.\n그리고 다음 테스트 코드는 <em>Stop</em> 버튼을 클릭했을 때 카운트다운 타이머가 멈추는지도 확인합니다:</p>\n<code-example path=\"component-interaction/e2e/src/app.e2e-spec.ts\" region=\"countdown-timer-tests\" header=\"component-interaction/e2e/src/app.e2e-spec.ts\">\n// ...\nit('timer and parent seconds should match', () => {\n  const parent = element(by.tagName(parentTag));\n  const message = parent.element(by.tagName('app-countdown-timer')).getText();\n  browser.sleep(10); // give `seconds` a chance to catchup with `message`\n  const seconds = parent.element(by.className('seconds')).getText();\n  expect(message).toContain(seconds);\n});\n\nit('should stop the countdown', () => {\n  const parent = element(by.tagName(parentTag));\n  const stopButton = parent.all(by.tagName('button')).get(1);\n\n  stopButton.click().then(() => {\n    const message = parent.element(by.tagName('app-countdown-timer')).getText();\n    expect(message).toContain('Holding');\n  });\n});\n// ...\n\n</code-example>\n<p><a href=\"guide/component-interaction#top\">맨 위로</a></p>\n<a id=\"parent-to-view-child\"></a>\n<!--\n## Parent calls an _@ViewChild()_\n-->\n<h2 id=\"viewchild-로-자식-컴포넌트-접근하기\"><em>@ViewChild()</em> 로 자식 컴포넌트 접근하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#viewchild-로-자식-컴포넌트-접근하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe *local variable* approach is simple and easy. But it is limited because\nthe parent-child wiring must be done entirely within the parent template.\nThe parent component *itself* has no access to the child.\n\nYou can't use the *local variable* technique if an instance of the parent component *class*\nmust read or write child component values or must call child component methods.\n\nWhen the parent component *class* requires that kind of access,\n***inject*** the child component into the parent as a *ViewChild*.\n\nThe following example illustrates this technique with the same\n[Countdown Timer](guide/component-interaction#countdown-timer-example) example.\nNeither its appearance nor its behavior will change.\nThe child [CountdownTimerComponent](guide/component-interaction#countdown-timer-example) is the same as well.\n\n<div class=\"alert is-helpful\">\n\n\nThe switch from the *local variable* to the *ViewChild* technique\nis solely for the purpose of demonstration.\n\n</div>\n\n\nHere is the parent, `CountdownViewChildParentComponent`:\n\n<code-example path=\"component-interaction/src/app/countdown-parent.component.ts\" region=\"vc\" header=\"component-interaction/src/app/countdown-parent.component.ts\">\nimport { AfterViewInit, ViewChild } from &#39;@angular/core&#39;;\nimport { Component } from &#39;@angular/core&#39;;\nimport { CountdownTimerComponent } from &#39;./countdown-timer.component&#39;;\n\n@Component({\n  selector: &#39;app-countdown-parent-vc&#39;,\n  template: `\n  &lt;h3&gt;Countdown to Liftoff (via ViewChild)&lt;/h3&gt;\n  &lt;button (click)=&quot;start()&quot;&gt;Start&lt;/button&gt;\n  &lt;button (click)=&quot;stop()&quot;&gt;Stop&lt;/button&gt;\n  &lt;div class=&quot;seconds&quot;&gt;{{ seconds() }}&lt;/div&gt;\n  &lt;app-countdown-timer&gt;&lt;/app-countdown-timer&gt;\n  `,\n  styleUrls: [&#39;../assets/demo.css&#39;]\n})\nexport class CountdownViewChildParentComponent implements AfterViewInit {\n\n  @ViewChild(CountdownTimerComponent)\n  private timerComponent: CountdownTimerComponent;\n\n  seconds() { return 0; }\n\n  ngAfterViewInit() {\n    // `seconds()` 메소드는 `CountdownTimerComponent.seconds`에서 다시 구현합니다.\n    // 이 때 개발 모드에서 출력하는 단방향 바인딩 검사 에러를 방지하기 위해\n    // 한 싸이클 기다려야 합니다.\n    setTimeout(() =&gt; this.seconds = () =&gt; this.timerComponent.seconds, 0);\n  }\n\n  start() { this.timerComponent.start(); }\n  stop() { this.timerComponent.stop(); }\n}\n\n</code-example>\n\n\nIt takes a bit more work to get the child view into the parent component *class*.\n\nFirst, you have to import references to the `ViewChild` decorator and the `AfterViewInit` lifecycle hook.\n\nNext, inject the child `CountdownTimerComponent` into the private `timerComponent` property\nvia the `@ViewChild` property decoration.\n\nThe `#timer` local variable is gone from the component metadata.\nInstead, bind the buttons to the parent component's own `start` and `stop` methods and\npresent the ticking seconds in an interpolation around the parent component's `seconds` method.\n\nThese methods access the injected timer component directly.\n\nThe `ngAfterViewInit()` lifecycle hook is an important wrinkle.\nThe timer component isn't available until *after* Angular displays the parent view.\nSo it displays `0` seconds initially.\n\nThen Angular calls the `ngAfterViewInit` lifecycle hook at which time it is *too late*\nto update the parent view's display of the countdown seconds.\nAngular's unidirectional data flow rule prevents updating the parent view's\nin the same cycle. The app has to *wait one turn* before it can display the seconds.\n\nUse `setTimeout()` to wait one tick and then revise the `seconds()` method so\nthat it takes future values from the timer component.\n\n<h3 class=\"no-toc\">Test it</h3>\n\nUse [the same countdown timer tests](guide/component-interaction#countdown-tests) as before.\n\n[Back to top](guide/component-interaction#top)\n-->\n<p><em>템플릿 지역 변수</em>로 자식 컴포넌트에 접근하는 것은 문법도 간단하고 이해하기 쉽습니다.\n하지만 이 방식은 부모 컴포넌트의 템플릿에서만 자식 컴포넌트에 접근할 수 있기 때문에 자유롭게 활용하기에는 제한이 있습니다.\n부모 컴포넌트의 <em>클래스</em>에서는 자식 컴포넌트에 접근할 수 없기 때문입니다.</p>\n<p><em>템플릿 지역 변수</em>를 사용하는 방법은 부모 컴포넌트 <em>클래스</em>에서는 사용할 수 없습니다.\n그래서 부모 컴포넌트의 클래스에서는 자식 컴포넌트의 프로퍼티를 읽거나 메소드를 실행할 수 없습니다.</p>\n<p>부모 컴포넌트의 <em>클래스</em>에서 자식 컴포넌트에 접근하려면 자식 컴포넌트에 <em>ViewChild</em>를 사용해서 부모 컴포넌트로 <strong><em>주입(inject)</em></strong> 해야 합니다.</p>\n<p>이 내용은 예제를 보면서 알아봅시다.\n이 예제는 위에서 살펴본 <a href=\"guide/component-interaction#countdown-timer-example\">카운트다운 타이머</a>와 거의 비슷하지만, 구현 방식은 조금 다릅니다.\n먼저, 자식 컴포넌트 <a href=\"guide/component-interaction#countdown-timer-example\">CountdownTimerComponent</a> 코드는 동일합니다.</p>\n<div class=\"alert is-helpful\">\n<p><em>템플릿 지역 변수</em>를 사용하는 방식과 <em>ViewChild</em>를 사용하는 방식은 거의 비슷합니다.\n사용하려는 목적에 따라 구현 방식을 선택하면 됩니다.</p>\n</div>\n<p>그리고 부모 컴포넌트인 <code>CountdownViewChildParentComponent</code>는 다음과 같이 구현합니다:</p>\n<code-example path=\"component-interaction/src/app/countdown-parent.component.ts\" region=\"vc\" header=\"component-interaction/src/app/countdown-parent.component.ts\">\nimport { <a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a>, <a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a> } from '@angular/core';\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { CountdownTimerComponent } from './countdown-timer.component';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-countdown-parent-vc',\n  template: `\n  &#x3C;h3>Countdown to Liftoff (via <a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>)&#x3C;/h3>\n  &#x3C;button (click)=\"start()\">Start&#x3C;/button>\n  &#x3C;button (click)=\"stop()\">Stop&#x3C;/button>\n  &#x3C;div class=\"seconds\">{{ seconds() }}&#x3C;/div>\n  &#x3C;app-countdown-timer>&#x3C;/app-countdown-timer>\n  `,\n  styleUrls: ['../assets/demo.css']\n})\nexport class CountdownViewChildParentComponent implements <a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a> {\n\n  @<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>(CountdownTimerComponent)\n  private timerComponent: CountdownTimerComponent;\n\n  seconds() { return 0; }\n\n  ngAfterViewInit() {\n    // `seconds()` 메소드는 `CountdownTimerComponent.seconds`에서 다시 구현합니다.\n    // 이 때 개발 모드에서 출력하는 단방향 바인딩 검사 에러를 방지하기 위해\n    // 한 싸이클 기다려야 합니다.\n    setTimeout(() => this.seconds = () => this.timerComponent.seconds, 0);\n  }\n\n  start() { this.timerComponent.start(); }\n  stop() { this.timerComponent.stop(); }\n}\n\n</code-example>\n<p>이 코드를 보면 부모 컴포넌트 <em>클래스</em>에서 자식 컴포넌트에 이전보다 좀 더 많이 개입하는 것을 확인할 수 있습니다.</p>\n<p>먼저, <code><a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 데코레이터와 <code><a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a></code> 라이프싸이클 후킹 인터페이스를 로드합니다.</p>\n<p>그리고 <code>CountdownTimerComponent</code>를 <code>timerComponent</code> 프로퍼티로 선언하면서 <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 데코레이터를 사용했습니다.</p>\n<p>이전에 사용했던 부모 컴포넌트의 템플릿은 템플릿 지역 변수 <code>#timer</code>를 활용해서 자식 컴포넌트의 메소드를 직접 실행했습니다.\n하지만 이번 예제는 자식 컴포넌트를 직접 호출하지 않고 부모 컴포넌트에 있는 <code>start</code>, <code>stop</code> 메소드를 사옹하며, 현재 남아있는 초를 확인할 때도 부모 컴포넌트의 <code>seconds</code> 메소드를 활용합니다.</p>\n<p>각각의 메소드에서 자식 컴포넌트에 접근하는 식으로 구현하는 것입니다.</p>\n<p>이 때 <code>ngAfterViewInit()</code> 라이프싸이클 후킹 함수가 중요합니다.\n자식 컴포넌트인 타이머 컴포넌트는 Angular가 부모 컴포넌트의 뷰를 화면에 표시한 <em>이후에야</em> 사용할 수 있습니다.\n그래서 뷰가 완전히 준비되기 전까지는 <code>0</code>을 표시합니다.</p>\n<p>부모 컴포넌트의 뷰가 준비되면 자식 컴포넌트에서 시간을 가져오기 위해 <code>ngAfterViewInit</code> 라이프싸이클 후킹 함수를 실행하는데,\nAngular는 단방향 데이터 흐름을 권장하기 때문에 부모 컴포넌트의 뷰를 같은 JavaScript 실행 싸이클 안에서 갱신하는 것을 금지합니다.</p>\n<p>그래서 <code>ngAfterViewInit()</code>에서 자식 컴포넌트의 시간을 가져와서 부모 컴포넌트 프로퍼티에 할당하는 것은 <code>setTimeout()</code> 으로 <em>한 싸이클</em> 늦췄습니다.</p>\n<h3 class=\"no-toc\" id=\"동작-확인-5\">동작 확인<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#동작-확인-5\"><i class=\"material-icons\">link</i></a></h3>\n<p>이전에 살펴봤던 <a href=\"guide/component-interaction#countdown-tests\">카운트다운 타이머 테스트</a>와 같습니다.</p>\n<p><a href=\"guide/component-interaction#top\">맨 위로</a></p>\n<a id=\"bidirectional-service\"></a>\n<!--\n## Parent and children communicate via a service\n-->\n<h2 id=\"서비스를-사용해서-통신하기\">서비스를 사용해서 통신하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#서비스를-사용해서-통신하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nA parent component and its children share a service whose interface enables bi-directional communication\n*within the family*.\n\nThe scope of the service instance is the parent component and its children.\nComponents outside this component subtree have no access to the service or their communications.\n\nThis `MissionService` connects the `MissionControlComponent` to multiple `AstronautComponent` children.\n\n<code-example path=\"component-interaction/src/app/mission.service.ts\" header=\"component-interaction/src/app/mission.service.ts\">\nimport { Injectable } from &#39;@angular/core&#39;;\nimport { Subject } from &#39;rxjs&#39;;\n\n@Injectable()\nexport class MissionService {\n\n  // 문자열 타입의 옵저버블 소스\n  private missionAnnouncedSource = new Subject&lt;string&gt;();\n  private missionConfirmedSource = new Subject&lt;string&gt;();\n\n  // 문자열 옵저버블 스트림\n  missionAnnounced$ = this.missionAnnouncedSource.asObservable();\n  missionConfirmed$ = this.missionConfirmedSource.asObservable();\n\n  // 서비스가 옵저버블을 전달할 때 사용하는 메소드\n  announceMission(mission: string) {\n    this.missionAnnouncedSource.next(mission);\n  }\n\n  confirmMission(astronaut: string) {\n    this.missionConfirmedSource.next(astronaut);\n  }\n}\n\n</code-example>\n\n\nThe `MissionControlComponent` both provides the instance of the service that it shares with its children\n(through the `providers` metadata array) and injects that instance into itself through its constructor:\n\n<code-example path=\"component-interaction/src/app/missioncontrol.component.ts\" header=\"component-interaction/src/app/missioncontrol.component.ts\">\nimport { Component } from &#39;@angular/core&#39;;\n\nimport { MissionService } from &#39;./mission.service&#39;;\n\n@Component({\n  selector: &#39;app-mission-control&#39;,\n  template: `\n    &lt;h2&gt;Mission Control&lt;/h2&gt;\n    &lt;button (click)=&quot;announce()&quot;&gt;Announce mission&lt;/button&gt;\n    &lt;app-astronaut *ngFor=&quot;let astronaut of astronauts&quot;\n      [astronaut]=&quot;astronaut&quot;&gt;\n    &lt;/app-astronaut&gt;\n    &lt;h3&gt;History&lt;/h3&gt;\n    &lt;ul&gt;\n      &lt;li *ngFor=&quot;let event of history&quot;&gt;{{event}}&lt;/li&gt;\n    &lt;/ul&gt;\n  `,\n  providers: [MissionService]\n})\nexport class MissionControlComponent {\n  astronauts = [&#39;Lovell&#39;, &#39;Swigert&#39;, &#39;Haise&#39;];\n  history: string[] = [];\n  missions = [&#39;Fly to the moon!&#39;,\n              &#39;Fly to mars!&#39;,\n              &#39;Fly to Vegas!&#39;];\n  nextMission = 0;\n\n  constructor(private missionService: MissionService) {\n    missionService.missionConfirmed$.subscribe(\n      astronaut =&gt; {\n        this.history.push(`${astronaut} confirmed the mission`);\n      });\n  }\n\n  announce() {\n    const mission = this.missions[this.nextMission++];\n    this.missionService.announceMission(mission);\n    this.history.push(`Mission &quot;${mission}&quot; announced`);\n    if (this.nextMission &gt;= this.missions.length) { this.nextMission = 0; }\n  }\n}\n\n</code-example>\n\n\nThe `AstronautComponent` also injects the service in its constructor.\nEach `AstronautComponent` is a child of the `MissionControlComponent` and therefore receives its parent's service instance:\n\n<code-example path=\"component-interaction/src/app/astronaut.component.ts\" header=\"component-interaction/src/app/astronaut.component.ts\">\nimport { Component, Input, OnDestroy } from &#39;@angular/core&#39;;\n\nimport { MissionService } from &#39;./mission.service&#39;;\nimport { Subscription } from &#39;rxjs&#39;;\n\n@Component({\n  selector: &#39;app-astronaut&#39;,\n  template: `\n    &lt;p&gt;\n      {{astronaut}}: &lt;strong&gt;{{mission}}&lt;/strong&gt;\n      &lt;button\n        (click)=&quot;confirm()&quot;\n        [disabled]=&quot;!announced || confirmed&quot;&gt;\n        Confirm\n      &lt;/button&gt;\n    &lt;/p&gt;\n  `\n})\nexport class AstronautComponent implements OnDestroy {\n  @Input() astronaut: string;\n  mission = &#39;&lt;no mission announced&gt;&#39;;\n  confirmed = false;\n  announced = false;\n  subscription: Subscription;\n\n  constructor(private missionService: MissionService) {\n    this.subscription = missionService.missionAnnounced$.subscribe(\n      mission =&gt; {\n        this.mission = mission;\n        this.announced = true;\n        this.confirmed = false;\n    });\n  }\n\n  confirm() {\n    this.confirmed = true;\n    this.missionService.confirmMission(this.astronaut);\n  }\n\n  ngOnDestroy() {\n    // prevent memory leak when component destroyed\n    this.subscription.unsubscribe();\n  }\n}\n\n</code-example>\n\n\n<div class=\"alert is-helpful\">\n\nNotice that this example captures the `subscription` and `unsubscribe()` when the `AstronautComponent` is destroyed.\nThis is a memory-leak guard step. There is no actual risk in this app because the\nlifetime of a `AstronautComponent` is the same as the lifetime of the app itself.\nThat *would not* always be true in a more complex application.\n\nYou don't add this guard to the `MissionControlComponent` because, as the parent,\nit controls the lifetime of the `MissionService`.\n\n</div>\n\n\nThe *History* log demonstrates that messages travel in both directions between\nthe parent `MissionControlComponent` and the `AstronautComponent` children,\nfacilitated by the service:\n\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/component-interaction/bidirectional-service.gif\" alt=\"bidirectional-service\">\n</div>\n\n\n<h3 class=\"no-toc\">Test it</h3>\n\nTests click buttons of both the parent `MissionControlComponent` and the `AstronautComponent` children\nand verify that the history meets expectations:\n\n<code-example path=\"component-interaction/e2e/src/app.e2e-spec.ts\" region=\"bidirectional-service\" header=\"component-interaction/e2e/src/app.e2e-spec.ts\">\n// ...\nit(&#39;should announce a mission&#39;, () =&gt; {\n  const missionControl = element(by.tagName(&#39;app-mission-control&#39;));\n  const announceButton = missionControl.all(by.tagName(&#39;button&#39;)).get(0);\n  announceButton.click().then(() =&gt; {\n    const history = missionControl.all(by.tagName(&#39;li&#39;));\n    expect(history.count()).toBe(1);\n    expect(history.get(0).getText()).toMatch(/Mission.* announced/);\n  });\n});\n\nit(&#39;should confirm the mission by Lovell&#39;, () =&gt; {\n  testConfirmMission(1, 2, &#39;Lovell&#39;);\n});\n\nit(&#39;should confirm the mission by Haise&#39;, () =&gt; {\n  testConfirmMission(3, 3, &#39;Haise&#39;);\n});\n\nit(&#39;should confirm the mission by Swigert&#39;, () =&gt; {\n  testConfirmMission(2, 4, &#39;Swigert&#39;);\n});\n\nfunction testConfirmMission(buttonIndex: number, expectedLogCount: number, astronaut: string) {\n  const confirmedLog = &#39; confirmed the mission&#39;;\n  const missionControl = element(by.tagName(&#39;app-mission-control&#39;));\n  const confirmButton = missionControl.all(by.tagName(&#39;button&#39;)).get(buttonIndex);\n  confirmButton.click().then(() =&gt; {\n    const history = missionControl.all(by.tagName(&#39;li&#39;));\n    expect(history.count()).toBe(expectedLogCount);\n    expect(history.get(expectedLogCount - 1).getText()).toBe(astronaut + confirmedLog);\n  });\n}\n// ...\n\n</code-example>\n\n\n[Back to top](guide/component-interaction#top)\n-->\n<p>부모 컴포넌트와 자식 컴포넌트가 같은 서비스를 주입받는다면 이 서비스를 활용해서 양방향으로 데이터를 주고받을 수 있습니다.</p>\n<p>컴포넌트에 주입되는 서비스는 그 컴포넌트에서 자유롭게 사용할 수 있습니다.\n이 때 주입되는 서비스의 인스턴스가 동일해야 하기 때문에 서비스 프로바이더를 별도로 지정하면 컴포넌트 통신에 활용할 수 없습니다.</p>\n<p><code>MissionControlComponent</code>가 여러 개의 <code>AstronautComponent</code>와 통신하기 위해 <code>MissionService</code>를 만들어 봅시다.</p>\n<code-example path=\"component-interaction/src/app/mission.service.ts\" header=\"component-interaction/src/app/mission.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { Subject } from 'rxjs';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class MissionService {\n\n  // 문자열 타입의 옵저버블 소스\n  private missionAnnouncedSource = new Subject&#x3C;string>();\n  private missionConfirmedSource = new Subject&#x3C;string>();\n\n  // 문자열 옵저버블 스트림\n  missionAnnounced$ = this.missionAnnouncedSource.asObservable();\n  missionConfirmed$ = this.missionConfirmedSource.asObservable();\n\n  // 서비스가 옵저버블을 전달할 때 사용하는 메소드\n  announceMission(mission: string) {\n    this.missionAnnouncedSource.next(mission);\n  }\n\n  confirmMission(astronaut: string) {\n    this.missionConfirmedSource.next(astronaut);\n  }\n}\n\n</code-example>\n<p><code>MissionControlComponent</code>는 생성자를 통해 <code>MissionService</code>의 인스턴스를 주입받으며, <code>providers</code> 메타데이터를 사용해서 서비스 인스턴스를 자식 컴포넌트에서도 사용할 수 있도록 공유합니다:</p>\n<code-example path=\"component-interaction/src/app/missioncontrol.component.ts\" header=\"component-interaction/src/app/missioncontrol.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\nimport { MissionService } from './mission.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-mission-control',\n  template: `\n    &#x3C;h2>Mission Control&#x3C;/h2>\n    &#x3C;button (click)=\"announce()\">Announce mission&#x3C;/button>\n    &#x3C;app-astronaut *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let astronaut of astronauts\"\n      [astronaut]=\"astronaut\">\n    &#x3C;/app-astronaut>\n    &#x3C;h3>History&#x3C;/h3>\n    &#x3C;ul>\n      &#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let event of history\">{{event}}&#x3C;/li>\n    &#x3C;/ul>\n  `,\n  providers: [MissionService]\n})\nexport class MissionControlComponent {\n  astronauts = ['Lovell', 'Swigert', 'Haise'];\n  history: string[] = [];\n  missions = ['Fly to the moon!',\n              'Fly to mars!',\n              'Fly to Vegas!'];\n  nextMission = 0;\n\n  constructor(private missionService: MissionService) {\n    missionService.missionConfirmed$.subscribe(\n      astronaut => {\n        this.history.push(`${astronaut} confirmed the mission`);\n      });\n  }\n\n  announce() {\n    const mission = this.missions[this.nextMission++];\n    this.missionService.announceMission(mission);\n    this.history.push(`Mission \"${mission}\" announced`);\n    if (this.nextMission >= this.missions.length) { this.nextMission = 0; }\n  }\n}\n\n</code-example>\n<p>그리고 자식 컴포넌트 <code>AstronautComponent</code>도 생성자를 통해 서비스 인스턴스를 주입 받습니다:</p>\n<code-example path=\"component-interaction/src/app/astronaut.component.ts\" header=\"component-interaction/src/app/astronaut.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a> } from '@angular/core';\n\nimport { MissionService } from './mission.service';\nimport { Subscription } from 'rxjs';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-astronaut',\n  template: `\n    &#x3C;p>\n      {{astronaut}}: &#x3C;strong>{{mission}}&#x3C;/strong>\n      &#x3C;button\n        (click)=\"confirm()\"\n        [disabled]=\"!announced || confirmed\">\n        Confirm\n      &#x3C;/button>\n    &#x3C;/p>\n  `\n})\nexport class AstronautComponent implements <a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a> {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() astronaut: string;\n  mission = '&#x3C;no mission announced>';\n  confirmed = false;\n  announced = false;\n  subscription: Subscription;\n\n  constructor(private missionService: MissionService) {\n    this.subscription = missionService.missionAnnounced$.subscribe(\n      mission => {\n        this.mission = mission;\n        this.announced = true;\n        this.confirmed = false;\n    });\n  }\n\n  confirm() {\n    this.confirmed = true;\n    this.missionService.confirmMission(this.astronaut);\n  }\n\n  ngOnDestroy() {\n    // prevent memory leak when component destroyed\n    this.subscription.unsubscribe();\n  }\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>이 예제는 옵저버블을 활용하기 때문에 <code>AstronautComponent</code>가 종료될 때 옵저버블을 해제하기 위해 <code>unsubscribe()</code>를 실행합니다.\n이 함수는 메모리 누수를 막기 위해 필요하며, <code>AstronautComponent</code>가 종료되는 시점이 앱이 종료되는 시점과 같다면 이 로직을 작성하지 않아도 문제는 없습니다.\n하지만 애플리케이션이 복잡해진다면 <em>그렇지 않을</em> 가능성이 더 크기 때문에 빠뜨리지 않고 작성하는 것이 좋습니다.</p>\n<p>그리고 이 로직은 부모 컴포넌트 <code>MissionControlComponent</code>에는 필요 없습니다. 부모 컴포넌트와 <code>MissionService</code>가 종료되는 시점은 같습니다.</p>\n</div>\n<p>부모 컴포넌트 <code>MissionControlComponent</code>와 자식 컴포넌트 <code>AstronautComponent</code>가 서비스를 통해 데이터를 주고받는 과정은 <em>History</em> 영역에 다음과 같이 표시됩니다: </p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/component-interaction/bidirectional-service.gif\" alt=\"bidirectional-service\" width=\"310\" height=\"346\">\n</div>\n<h3 class=\"no-toc\" id=\"동작-확인-6\">동작 확인<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#동작-확인-6\"><i class=\"material-icons\">link</i></a></h3>\n<p>부모 컴포넌트 <code>MissionControlComponent</code>와 자식 컴포넌트 <code>AstronautComponent</code>의 버튼을 클릭했을 때 로그를 제대로 출력하는지 확인하기 위해 테스트 코드를 다음과 같이 작성합니다:</p>\n<code-example path=\"component-interaction/e2e/src/app.e2e-spec.ts\" region=\"bidirectional-service\" header=\"component-interaction/e2e/src/app.e2e-spec.ts\">\n// ...\nit('should announce a mission', () => {\n  const missionControl = element(by.tagName('app-mission-control'));\n  const announceButton = missionControl.all(by.tagName('button')).get(0);\n  announceButton.click().then(() => {\n    const history = missionControl.all(by.tagName('li'));\n    expect(history.count()).toBe(1);\n    expect(history.get(0).getText()).toMatch(/Mission.* announced/);\n  });\n});\n\nit('should confirm the mission by Lovell', () => {\n  testConfirmMission(1, 2, 'Lovell');\n});\n\nit('should confirm the mission by Haise', () => {\n  testConfirmMission(3, 3, 'Haise');\n});\n\nit('should confirm the mission by Swigert', () => {\n  testConfirmMission(2, 4, 'Swigert');\n});\n\nfunction testConfirmMission(buttonIndex: number, expectedLogCount: number, astronaut: string) {\n  const confirmedLog = ' confirmed the mission';\n  const missionControl = element(by.tagName('app-mission-control'));\n  const confirmButton = missionControl.all(by.tagName('button')).get(buttonIndex);\n  confirmButton.click().then(() => {\n    const history = missionControl.all(by.tagName('li'));\n    expect(history.count()).toBe(expectedLogCount);\n    expect(history.get(expectedLogCount - 1).getText()).toBe(astronaut + confirmedLog);\n  });\n}\n// ...\n\n</code-example>\n<p><a href=\"guide/component-interaction#top\">맨 위로</a></p>\n\n</div>\n\n<!-- links to this doc:\n - start\n-->\n<!-- links from this doc:\n - api/common/NgForOf\n - api/core/AfterViewInit\n - api/core/Component\n - api/core/EventEmitter\n - api/core/Injectable\n - api/core/Input\n - api/core/OnChanges\n - api/core/OnDestroy\n - api/core/OnInit\n - api/core/Output\n - api/core/SimpleChange\n - api/core/Version\n - api/core/ViewChild\n - guide/component-interaction#countdown-tests\n - guide/component-interaction#countdown-timer-example\n - guide/component-interaction#ngonchanges로-입력-프로퍼티-가로채기\n - guide/component-interaction#top\n - guide/component-interaction#viewchild-로-자식-컴포넌트-접근하기\n - guide/component-interaction#동작-확인\n - guide/component-interaction#동작-확인-1\n - guide/component-interaction#동작-확인-2\n - guide/component-interaction#동작-확인-3\n - guide/component-interaction#동작-확인-4\n - guide/component-interaction#동작-확인-5\n - guide/component-interaction#동작-확인-6\n - guide/component-interaction#부모-컴포넌트에서-자식-컴포넌트로-데이터-전달하기--입력-바인딩\n - guide/component-interaction#서비스를-사용해서-통신하기\n - guide/component-interaction#입력-프로퍼티를-세터setter로-가로채기\n - guide/component-interaction#자식-컴포넌트에서-보내는-이벤트-받기\n - guide/component-interaction#컴포넌트-통신\n - guide/component-interaction#템플릿-지역-변수로-자식-컴포넌트에-접근하기\n - guide/inputs-outputs#input\n - guide/inputs-outputs#output\n - guide/lifecycle-hooks\n - https://github.com/angular/angular/edit/master/aio/content/guide/component-interaction.md?message=docs%3A%20describe%20your%20change...\n-->"
}