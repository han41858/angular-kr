{
  "id": "guide/component-interaction",
  "title": "컴포넌트 통신",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/component-interaction.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Component Interaction\n-->\n<h1 id=\"컴포넌트-통신\">컴포넌트 통신<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#컴포넌트-통신\"><i class=\"material-icons\">link</i></a></h1>\n<a id=\"top\"></a>\n<!--\nThis cookbook contains recipes for common component communication scenarios\nin which two or more components share information.\n-->\n<p>이 가이드 문서는 둘 이상의 컴포넌트가 서로 데이터를 공유하는 방법을 다룹니다.</p>\n<a id=\"toc\"></a>\n<!--\n\n# Contents\n\n* [Pass data from parent to child with input binding](guide/component-interaction#parent-to-child)\n* [Intercept input property changes with a setter](guide/component-interaction#parent-to-child-setter)\n* [Intercept input property changes with `ngOnChanges()`](guide/component-interaction#parent-to-child-on-changes)\n* [Parent calls an `@ViewChild()`](guide/component-interaction#parent-to-view-child)\n* [Parent and children communicate via a service](guide/component-interaction#bidirectional-service)\n\n-->\n<!--\n**See the <live-example name=\"component-interaction\"></live-example>**.\n-->\n<p><strong>이 장에서 다루는 예제는 <live-example name=\"component-interaction\"></live-example>에서 확인할 수 있습니다.</strong></p>\n<a id=\"parent-to-child\"></a>\n<!--\n## Pass data from parent to child with input binding\n-->\n<h2 id=\"부모-컴포넌트에서-자식-컴포넌트로-데이터-전달하기--입력-바인딩\">부모 컴포넌트에서 자식 컴포넌트로 데이터 전달하기 : 입력 바인딩<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#부모-컴포넌트에서-자식-컴포넌트로-데이터-전달하기--입력-바인딩\"><i class=\"material-icons\">link</i></a></h2>\n<!--\n`HeroChildComponent` has two ***input properties***,\ntypically adorned with [@Input decorations](guide/template-syntax#inputs-outputs).\n-->\n<p><code>HeroChildComponent</code>에는 <strong><em>입력 프로퍼티</em></strong>가 두 개 있습니다. 이 프로퍼티들은 <a href=\"guide/template-syntax#inputs-outputs\">@Input 데코레이터</a>를 사용해서 선언합니다.</p>\n<code-example path=\"component-interaction/src/app/hero-child.component.ts\" header=\"component-interaction/src/app/hero-child.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a> } from '@angular/core';\n\nimport { Hero } from './hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-child',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n    &#x3C;h3>{{hero.name}} says:&#x3C;/h3>\n    &#x3C;p>I, {{hero.name}}, am at your service, {{masterName}}.&#x3C;/p>\n  `\n})\nexport class HeroChildComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('master') masterName: string;\n}\n\n</code-example>\n<!--\nThe second `@Input` aliases the child component property name `masterName` as `'master'`.\n-->\n<p>이 코드에 사용된 두 번째 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code>은 <code>masterName</code> 프로퍼티를 외부에서 바인딩 할 때 <code>'master'</code>라는 이름으로 사용하기 위한 선언이 추가되어 있습니다.</p>\n<!--\nThe `HeroParentComponent` nests the child `HeroChildComponent` inside an `*ngFor` repeater,\nbinding its `master` string property to the child's `master` alias,\nand each iteration's `hero` instance to the child's `hero` property.\n-->\n<p><code>HeroParentComponent</code>는 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>를 사용해서 배열에 있는 항목마다 <code>HeroChildComponent</code>를 만드는데,\n각 컴포넌트를 만들때마다 <code>master</code> 문자열 프로퍼티를 자식 컴포넌트의 <code>master</code>로 연결하고,\n반복되는 <code>hero</code> 인스턴스를 자식 컴포넌트의 <code>hero</code> 프로퍼티로 바인딩 합니다.</p>\n<code-example path=\"component-interaction/src/app/hero-parent.component.ts\" header=\"component-interaction/src/app/hero-parent.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\nimport { HEROES } from './hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-parent',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n    &#x3C;h2>{{master}} controls {{heroes.length}} heroes&#x3C;/h2>\n    &#x3C;app-hero-child *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"\n      [hero]=\"hero\"\n      [master]=\"master\">\n    &#x3C;/app-hero-child>\n  `\n})\nexport class HeroParentComponent {\n  heroes = HEROES;\n  master = 'Master';\n}\n\n</code-example>\n<!--\nThe running application displays three heroes:\n-->\n<p>그리고 이 애플리케이션을 실행하면 다음과 같이 세 명의 히어로가 표시됩니다:</p>\n<figure>\n  <img src=\"generated/images/guide/component-interaction/parent-to-child.png\" alt=\"Parent-to-child\" width=\"272\" height=\"267\">\n</figure>\n<!--\n<h3 class=\"no-toc\">Test it</h3>\n-->\n<h3 class=\"no-toc\" id=\"동작-확인\">동작 확인<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#동작-확인\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nE2E test that all children were instantiated and displayed as expected:\n-->\n<p>반복문을 순회하며 각각의 히어로마다 결과를 제대로 표시하는지 확인하기 위해 E2E 테스트 환경을 다음과 같이 설정합니다:</p>\n<code-example path=\"component-interaction/e2e/src/app.e2e-spec.ts\" region=\"parent-to-child\" header=\"component-interaction/e2e/src/app.e2e-spec.ts\">\n// ...\nlet _heroNames = ['Mr. IQ', 'Magneta', 'Bombasto'];\nlet _masterName = 'Master';\n\nit('should pass <a href=\"api/core/DebugElement#properties\" class=\"code-anchor\">properties</a> to children properly', function () {\n  let parent = element.all(by.tagName('app-hero-parent')).get(0);\n  let heroes = parent.all(by.tagName('app-hero-child'));\n\n  for (let i = 0; i &#x3C; _heroNames.length; i++) {\n    let childTitle = heroes.get(i).element(by.tagName('h3')).getText();\n    let childDetail = heroes.get(i).element(by.tagName('p')).getText();\n    expect(childTitle).toEqual(_heroNames[i] + ' says:');\n    expect(childDetail).toContain(_masterName);\n  }\n});\n// ...\n\n</code-example>\n<!--\n[Back to top](guide/component-interaction#top)\n-->\n<p><a href=\"guide/component-interaction#top\">맨 위로</a></p>\n<a id=\"parent-to-child-setter\"></a>\n<!--\n## Intercept input property changes with a setter\n-->\n<h2 id=\"입력-프로퍼티를-세터setter로-가로채기\">입력 프로퍼티를 세터(setter)로 가로채기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#입력-프로퍼티를-세터setter로-가로채기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nUse an input property setter to intercept and act upon a value from the parent.\n-->\n<p>부모 컴포넌트에서 값이 전달될 때 추가 로직을 실행하기 위해 입력 프로퍼티에 세터를 사용해 봅시다.</p>\n<!--\nThe setter of the `name` input property in the child `NameChildComponent`\ntrims the whitespace from a name and replaces an empty value with default text.\n-->\n<p>자식 컴포넌트인 <code>NameChildComponent</code>의 입력 프로퍼티인 <code>name</code>에 세터를 연결해서 전달되는 문자열의 여백 문자를 다른 문자로 변경해 봅시다.</p>\n<code-example path=\"component-interaction/src/app/name-child.component.ts\" header=\"component-interaction/src/app/name-child.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-name-child',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: '&#x3C;h3>\"{{name}}\"&#x3C;/h3>'\n})\nexport class NameChildComponent {\n  private _name = '';\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()\n  set name(name: string) {\n    this._name = (name &#x26;&#x26; name.trim()) || '&#x3C;no name set>';\n  }\n\n  get name(): string { return this._name; }\n}\n\n</code-example>\n<!--\nHere's the `NameParentComponent` demonstrating name variations including a name with all spaces:\n-->\n<p>그리고 부모 컴포넌트인 <code>NameParentComponent</code>는 자식 컴포넌트에 다음과 같이 몇 가지 경우를 적용해 봅니다:</p>\n<code-example path=\"component-interaction/src/app/name-parent.component.ts\" header=\"component-interaction/src/app/name-parent.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-name-parent',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n  &#x3C;h2>Master controls {{names.length}} names&#x3C;/h2>\n  &#x3C;app-name-child *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let name of names\" [name]=\"name\">&#x3C;/app-name-child>\n  `\n})\nexport class NameParentComponent {\n  // 'Mr. IQ', '&#x3C;빈 값>', 'Bombasto'를 표시합니다.\n  names = ['Mr. IQ', '   ', '  Bombasto  '];\n}\n\n</code-example>\n<figure>\n  <img src=\"generated/images/guide/component-interaction/setter.png\" alt=\"Parent-to-child-setter\" width=\"322\" height=\"193\">\n</figure>\n<!--\n<h3 class=\"no-toc\">Test it</h3>\n-->\n<h3 class=\"no-toc\" id=\"동작-확인-1\">동작 확인<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#동작-확인-1\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nE2E tests of input property setter with empty and non-empty names:\n-->\n<p>입력 프로퍼티 세터를 테스트하는 E2E 환경은 다음과 같이 설정합니다:</p>\n<code-example path=\"component-interaction/e2e/src/app.e2e-spec.ts\" region=\"parent-to-child-setter\" header=\"component-interaction/e2e/src/app.e2e-spec.ts\">\n// ...\nit('should display trimmed, non-empty names', function () {\n  let _nonEmptyNameIndex = 0;\n  let _nonEmptyName = '\"Mr. IQ\"';\n  let parent = element.all(by.tagName('app-name-parent')).get(0);\n  let hero = parent.all(by.tagName('app-name-child')).get(_nonEmptyNameIndex);\n\n  let <a href=\"api/core/ReflectiveKey#displayName\" class=\"code-anchor\">displayName</a> = hero.element(by.tagName('h3')).getText();\n  expect(<a href=\"api/core/ReflectiveKey#displayName\" class=\"code-anchor\">displayName</a>).toEqual(_nonEmptyName);\n});\n\nit('should replace empty name with default name', function () {\n  let _emptyNameIndex = 1;\n  let _defaultName = '\"&#x3C;no name set>\"';\n  let parent = element.all(by.tagName('app-name-parent')).get(0);\n  let hero = parent.all(by.tagName('app-name-child')).get(_emptyNameIndex);\n\n  let <a href=\"api/core/ReflectiveKey#displayName\" class=\"code-anchor\">displayName</a> = hero.element(by.tagName('h3')).getText();\n  expect(<a href=\"api/core/ReflectiveKey#displayName\" class=\"code-anchor\">displayName</a>).toEqual(_defaultName);\n});\n// ...\n\n</code-example>\n<!--\n[Back to top](guide/component-interaction#top)\n-->\n<p><a href=\"guide/component-interaction#top\">맨 위로</a></p>\n<a id=\"parent-to-child-on-changes\"></a>\n<!--\n## Intercept input property changes with *ngOnChanges()*\n-->\n<h2 id=\"ngonchanges로-입력-프로퍼티-가로채기\"><em>ngOnChanges()</em>로 입력 프로퍼티 가로채기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#ngonchanges로-입력-프로퍼티-가로채기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nDetect and act upon changes to input property values with the `ngOnChanges()` method of the `OnChanges` lifecycle hook interface.\n-->\n<p>입력 프로퍼티는 <code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a></code> 라이프싸이클 후킹 인터페이스를 사용하는 <code>ngOnChanges()</code> 메소드로도 가로챌 수 있습니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nYou may prefer this approach to the property setter when watching multiple, interacting input properties.\n\nLearn about `ngOnChanges()` in the [LifeCycle Hooks](guide/lifecycle-hooks) chapter.\n-->\n<p>입력 프로퍼티 여러개를 가로채야 한다면 세터를 사용하는 것보다 이 방식이 더 편할 수 있습니다.</p>\n<p><code>ngOnChanges()</code> 함수에 대한 자세한 설명은 <a href=\"guide/lifecycle-hooks\">라이프싸이클 후킹</a> 문서를 참고하세요.</p>\n</div>\n<!--\nThis `VersionChildComponent` detects changes to the `major` and `minor` input properties and composes a log message reporting these changes:\n-->\n<p><code>VersionChildComponent</code>는 <code><a href=\"api/core/Version#major\" class=\"code-anchor\">major</a></code>와 <code><a href=\"api/core/Version#minor\" class=\"code-anchor\">minor</a></code> 두 입력 프로퍼티 값이 변경되는 것을 감지하고 이 내용을 로그로 출력합니다:</p>\n<code-example path=\"component-interaction/src/app/version-child.component.ts\" header=\"component-interaction/src/app/version-child.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a>, <a href=\"api/core/SimpleChange\" class=\"code-anchor\">SimpleChange</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-version-child',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n    &#x3C;h3><a href=\"api/core/Version\" class=\"code-anchor\">Version</a> {{<a href=\"api/core/Version#major\" class=\"code-anchor\">major</a>}}.{{<a href=\"api/core/Version#minor\" class=\"code-anchor\">minor</a>}}&#x3C;/h3>\n    &#x3C;h4>Change <a href=\"api/animations/browser/testing/MockAnimationDriver#log\" class=\"code-anchor\">log</a>:&#x3C;/h4>\n    &#x3C;ul>\n      &#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let change of changeLog\">{{change}}&#x3C;/li>\n    &#x3C;/ul>\n  `\n})\nexport class VersionChildComponent implements <a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a> {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() <a href=\"api/core/Version#major\" class=\"code-anchor\">major</a>: number;\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() <a href=\"api/core/Version#minor\" class=\"code-anchor\">minor</a>: number;\n  changeLog: string[] = [];\n\n  ngOnChanges(<a href=\"api/core/QueryList#changes\" class=\"code-anchor\">changes</a>: {[propKey: string]: <a href=\"api/core/SimpleChange\" class=\"code-anchor\">SimpleChange</a>}) {\n    let <a href=\"api/animations/browser/testing/MockAnimationDriver#log\" class=\"code-anchor\">log</a>: string[] = [];\n    for (let propName in <a href=\"api/core/QueryList#changes\" class=\"code-anchor\">changes</a>) {\n      let changedProp = <a href=\"api/core/QueryList#changes\" class=\"code-anchor\">changes</a>[propName];\n      let to = JSON.stringify(changedProp.currentValue);\n      if (changedProp.isFirstChange()) {\n        log.push(`Initial value of ${propName} set to ${to}`);\n      } else {\n        let from = JSON.stringify(changedProp.previousValue);\n        log.push(`${propName} changed from ${from} to ${to}`);\n      }\n    }\n    this.changeLog.push(log.join(', '));\n  }\n}\n\n</code-example>\n<!--\nThe `VersionParentComponent` supplies the `minor` and `major` values and binds buttons to methods that change them.\n-->\n<p>그리고 부모 컴포넌트인 <code>VersionParentComponent</code>는 자식 컴포넌트에 바인딩되는 <code><a href=\"api/core/Version#minor\" class=\"code-anchor\">minor</a></code>, <code><a href=\"api/core/Version#major\" class=\"code-anchor\">major</a></code> 두 값을 버튼으로 조정합니다.</p>\n<code-example path=\"component-interaction/src/app/version-parent.component.ts\" header=\"component-interaction/src/app/version-parent.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-version-parent',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n    &#x3C;h2>Source code version&#x3C;/h2>\n    &#x3C;button (click)=\"newMinor()\">New <a href=\"api/core/Version#minor\" class=\"code-anchor\">minor</a> version&#x3C;/button>\n    &#x3C;button (click)=\"newMajor()\">New <a href=\"api/core/Version#major\" class=\"code-anchor\">major</a> version&#x3C;/button>\n    &#x3C;app-version-child [<a href=\"api/core/Version#major\" class=\"code-anchor\">major</a>]=\"<a href=\"api/core/Version#major\" class=\"code-anchor\">major</a>\" [<a href=\"api/core/Version#minor\" class=\"code-anchor\">minor</a>]=\"<a href=\"api/core/Version#minor\" class=\"code-anchor\">minor</a>\">&#x3C;/app-version-child>\n  `\n})\nexport class VersionParentComponent {\n  <a href=\"api/core/Version#major\" class=\"code-anchor\">major</a> = 1;\n  <a href=\"api/core/Version#minor\" class=\"code-anchor\">minor</a> = 23;\n\n  newMinor() {\n    this.minor++;\n  }\n\n  newMajor() {\n    this.major++;\n    this.minor = 0;\n  }\n}\n\n</code-example>\n<!--\nHere's the output of a button-pushing sequence:\n-->\n<p>버튼을 눌렀을 때 화면은 다음과 같습니다:</p>\n<figure>\n  <img src=\"generated/images/guide/component-interaction/parent-to-child-on-changes.gif\" alt=\"Parent-to-child-onchanges\" width=\"481\" height=\"264\">\n</figure>\n<!--\n<h3 class=\"no-toc\">Test it</h3>\n-->\n<h3 class=\"no-toc\" id=\"동작-확인-2\">동작 확인<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#동작-확인-2\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nTest that ***both*** input properties are set initially and that button clicks trigger\nthe expected `ngOnChanges` calls and values:\n-->\n<p><strong><em>두</em></strong> 입력 프로퍼티는 초기값이 설정된 이후에 버튼을 누를 때마다 변경되면서 <code>ngOnChanges()</code>를 실행하는데, 이 동작을 테스트하는 E2E 환경을 다음과 같이 정의합니다:</p>\n<code-example path=\"component-interaction/e2e/src/app.e2e-spec.ts\" region=\"parent-to-child-onchanges\" header=\"component-interaction/e2e/src/app.e2e-spec.ts\">\n// ...\n// 테스트는 정확히 이 순서대로 실행됩니다.\nit('should set expected initial values', function () {\n  let actual = getActual();\n\n  let initialLabel = '<a href=\"api/core/Version\" class=\"code-anchor\">Version</a> 1.23';\n  let initialLog = 'Initial value of <a href=\"api/core/Version#major\" class=\"code-anchor\">major</a> set to 1, Initial value of <a href=\"api/core/Version#minor\" class=\"code-anchor\">minor</a> set to 23';\n\n  expect(actual.label).toBe(initialLabel);\n  expect(actual.count).toBe(1);\n  expect(actual.logs.get(0).getText()).toBe(initialLog);\n});\n\nit('should set expected values after clicking \\'Minor\\' twice', function () {\n  let repoTag = element(by.tagName('app-version-parent'));\n  let newMinorButton = repoTag.all(by.tagName('button')).get(0);\n\n  newMinorButton.click().then(function() {\n    newMinorButton.click().then(function() {\n      let actual = getActual();\n\n      let labelAfter2Minor = '<a href=\"api/core/Version\" class=\"code-anchor\">Version</a> 1.25';\n      let logAfter2Minor = '<a href=\"api/core/Version#minor\" class=\"code-anchor\">minor</a> changed from 24 to 25';\n\n      expect(actual.label).toBe(labelAfter2Minor);\n      expect(actual.count).toBe(3);\n      expect(actual.logs.get(2).getText()).toBe(logAfter2Minor);\n    });\n  });\n});\n\nit('should set expected values after clicking \\'Major\\' once', function () {\n  let repoTag = element(by.tagName('app-version-parent'));\n  let newMajorButton = repoTag.all(by.tagName('button')).get(1);\n\n  newMajorButton.click().then(function() {\n    let actual = getActual();\n\n    let labelAfterMajor = '<a href=\"api/core/Version\" class=\"code-anchor\">Version</a> 2.0';\n    let logAfterMajor = '<a href=\"api/core/Version#major\" class=\"code-anchor\">major</a> changed from 1 to 2, <a href=\"api/core/Version#minor\" class=\"code-anchor\">minor</a> changed from 25 to 0';\n\n    expect(actual.label).toBe(labelAfterMajor);\n    expect(actual.count).toBe(4);\n    expect(actual.logs.get(3).getText()).toBe(logAfterMajor);\n  });\n});\n\nfunction getActual() {\n  let versionTag = element(by.tagName('app-version-child'));\n  let label = versionTag.element(by.tagName('h3')).getText();\n  let ul = versionTag.element((by.tagName('ul')));\n  let logs = ul.all(by.tagName('li'));\n\n  return {\n    label: label,\n    logs: logs,\n    <a href=\"api/common/NgForOfContext#count\" class=\"code-anchor\">count</a>: logs.count()\n  };\n}\n// ...\n\n</code-example>\n<!--\n[Back to top](guide/component-interaction#top)\n-->\n<p><a href=\"guide/component-interaction#top\">맨 위로</a></p>\n<a id=\"child-to-parent\"></a>\n<!--\n## Parent listens for child event\n-->\n<h2 id=\"자식-컴포넌트에서-보내는-이벤트-받기\">자식 컴포넌트에서 보내는 이벤트 받기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#자식-컴포넌트에서-보내는-이벤트-받기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe child component exposes an `EventEmitter` property with which it `emits` events when something happens.\nThe parent binds to that event property and reacts to those events.\n-->\n<p>자식 컴포넌트에서 어떤 이벤트가 발생하면 이 이벤트는 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 타입으로 짖어한 프로퍼티를 통해 부모 컴포넌트에게 보낼 수 있습니다.\n그러면 부모 컴포넌트는 이 이벤트를 바인딩해서 원하는 로직을 실행할 수 있습니다.</p>\n<!--\nThe child's `EventEmitter` property is an ***output property***,\n  typically adorned with an [@Output decoration](guide/template-syntax#inputs-outputs)\n  as seen in this `VoterComponent`:\n-->\n<p>자식 컴포넌트에서 외부로 이벤트를 보내려면 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 타입으로 선언한 프로퍼티에 <a href=\"guide/template-syntax#inputs-outputs\">@Output 데코레이터</a>를 사용해서 <strong><em>출력 프로퍼티</em></strong>로 지정합니다. <code>VoterComponent</code>에서는 다음과 같이 선언했습니다:</p>\n<code-example path=\"component-interaction/src/app/voter.component.ts\" header=\"component-interaction/src/app/voter.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/Output\" class=\"code-anchor\">Output</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-voter',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n    &#x3C;h4>{{name}}&#x3C;/h4>\n    &#x3C;button (click)=\"vote(true)\"  [disabled]=\"didVote\">Agree&#x3C;/button>\n    &#x3C;button (click)=\"vote(false)\" [disabled]=\"didVote\">Disagree&#x3C;/button>\n  `\n})\nexport class VoterComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()  name: string;\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() voted = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;boolean>();\n  didVote = false;\n\n  vote(agreed: boolean) {\n    this.voted.emit(agreed);\n    this.didVote = true;\n  }\n}\n\n</code-example>\n<!--\nClicking a button triggers emission of a `true` or `false`, the boolean *payload*.\n-->\n<p>이 예제에서 버튼을 클릭하면 자식 컴포넌트로 불리언 타입의 데이터를 전달합니다.</p>\n<!--\nThe parent `VoteTakerComponent` binds an event handler called `onVoted()` that responds to the child event\npayload `$event` and updates a counter.\n-->\n<p>그러면 <code>VoteTakerComponent</code>의 <code>onVoted()</code> 함수가 이벤트 객체를 인자로 받아서 <code>agree</code>와 <code>disagree</code> 카운터를 갱신합니다.</p>\n<code-example path=\"component-interaction/src/app/votetaker.component.ts\" header=\"component-interaction/src/app/votetaker.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> }      from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-vote-taker',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n    &#x3C;h2>Should mankind colonize the Universe?&#x3C;/h2>\n    &#x3C;h3>Agree: {{agreed}}, Disagree: {{disagreed}}&#x3C;/h3>\n    &#x3C;app-voter *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let voter of voters\"\n      [name]=\"voter\"\n      (voted)=\"onVoted($event)\">\n    &#x3C;/app-voter>\n  `\n})\nexport class VoteTakerComponent {\n  agreed = 0;\n  disagreed = 0;\n  voters = ['Mr. IQ', 'Ms. Universe', 'Bombasto'];\n\n  onVoted(agreed: boolean) {\n    agreed ? this.agreed++ : this.disagreed++;\n  }\n}\n\n</code-example>\n<!--\nThe framework passes the event argument&mdash;represented by `$event`&mdash;to the handler method,\nand the method processes it:\n-->\n<p>이 때 전달되는 이벤트 객체는 템플릿에서 <code>$event</code>라는 이름으로 접근할 수 있으며, 템플릿에서 이벤트 핸들러 함수에 인자로 전달하기 때문에 컴포넌트 클래스 코드에서 이 이벤트 객체를 활용할 수 있습니다:</p>\n<figure>\n  <img src=\"generated/images/guide/component-interaction/child-to-parent.gif\" alt=\"Child-to-parent\" width=\"418\" height=\"342\">\n</figure>\n<!--\n<h3 class=\"no-toc\">Test it</h3>\n-->\n<h3 class=\"no-toc\" id=\"동작-확인-3\">동작 확인<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#동작-확인-3\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nTest that clicking the *Agree* and *Disagree* buttons update the appropriate counters:\n-->\n<p><em>Agree</em> 버튼이나 <em>Disagree</em> 버튼을 클릭하면 해당 카운터 값이 증가합니다.</p>\n<code-example path=\"component-interaction/e2e/src/app.e2e-spec.ts\" region=\"child-to-parent\" header=\"component-interaction/e2e/src/app.e2e-spec.ts\">\n// ...\nit('should not emit the event initially', function () {\n  let voteLabel = element(by.tagName('app-vote-taker'))\n    .element(by.tagName('h3')).getText();\n  expect(voteLabel).toBe('Agree: 0, Disagree: 0');\n});\n\nit('should process Agree vote', function () {\n  let agreeButton1 = element.all(by.tagName('app-voter')).get(0)\n    .all(by.tagName('button')).get(0);\n  agreeButton1.click().then(function() {\n    let voteLabel = element(by.tagName('app-vote-taker'))\n      .element(by.tagName('h3')).getText();\n    expect(voteLabel).toBe('Agree: 1, Disagree: 0');\n  });\n});\n\nit('should process Disagree vote', function () {\n  let agreeButton1 = element.all(by.tagName('app-voter')).get(1)\n    .all(by.tagName('button')).get(1);\n  agreeButton1.click().then(function() {\n    let voteLabel = element(by.tagName('app-vote-taker'))\n      .element(by.tagName('h3')).getText();\n    expect(voteLabel).toBe('Agree: 1, Disagree: 1');\n  });\n});\n// ...\n\n</code-example>\n<!--\n[Back to top](guide/component-interaction#top)\n-->\n<p><a href=\"guide/component-interaction#top\">맨 위로</a></p>\n<!--\n## Parent interacts with child via *local variable*\n-->\n<h2 id=\"템플릿-지역-변수로-자식-컴포넌트에-접근하기\"><em>템플릿 지역 변수</em>로 자식 컴포넌트에 접근하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#템플릿-지역-변수로-자식-컴포넌트에-접근하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nA parent component cannot use data binding to read child properties\nor invoke child methods. You can do both\nby creating a template reference variable for the child element\nand then reference that variable *within the parent template*\nas seen in the following example.\n-->\n<p>부모 컴포넌트는 자식 컴포넌트의 프로퍼티나 메소드에 직접 접근할 수 없습니다.\n하지만 <em>부모 템플릿</em>에 템플릿 참조 변수를 선언하면 자식 컴포넌트의 프로퍼티나 메소드에 접근할 수 있습니다.</p>\n<a id=\"countdown-timer-example\"></a>\n<!--\nThe following is a child `CountdownTimerComponent` that repeatedly counts down to zero and launches a rocket.\nIt has `start` and `stop` methods that control the clock and it displays a\ncountdown status message in its own template.\n-->\n<p>다음 예제에서 <code>CountdownTimerComponent</code>는 타이머를 동작시켜서 카운트가 0이 되면 로켓을 발사한다고 합시다.\n그리고 이 컴포넌트에 있는 <code>start</code> 메소드와 <code>stop</code> 메소드는 각각 타이머를 시작하거나 정지합니다.</p>\n<code-example path=\"component-interaction/src/app/countdown-timer.component.ts\" header=\"component-interaction/src/app/countdown-timer.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-countdown-timer',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: '&#x3C;p>{{<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>}}&#x3C;/p>'\n})\nexport class CountdownTimerComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>, <a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a> {\n\n  intervalId = 0;\n  <a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a> = '';\n  seconds = 11;\n\n  clearTimer() { clearInterval(this.intervalId); }\n\n  ngOnInit()    { this.start(); }\n  ngOnDestroy() { this.clearTimer(); }\n\n  start() { this.countDown(); }\n  stop()  {\n    this.clearTimer();\n    this.message = `Holding at T-${this.seconds} seconds`;\n  }\n\n  private countDown() {\n    this.clearTimer();\n    this.intervalId = window.setInterval(() => {\n      this.seconds -= 1;\n      if (this.seconds === 0) {\n        this.message = 'Blast off!';\n      } else {\n        if (this.seconds &#x3C; 0) { this.seconds = 10; } // reset\n        this.message = `T-${this.seconds} seconds and counting`;\n      }\n    }, 1000);\n  }\n}\n\n\n</code-example>\n<!--\nThe `CountdownLocalVarParentComponent` that hosts the timer component is as follows:\n-->\n<p>부모 컴포넌트인 <code>CountdownLocalVarParentComponent</code>는 자식 컴포넌트를 다음과 같이 활용합니다:</p>\n<code-example path=\"component-interaction/src/app/countdown-parent.component.ts\" region=\"lv\" header=\"component-interaction/src/app/countdown-parent.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> }                from '@angular/core';\nimport { CountdownTimerComponent }  from './countdown-timer.component';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-countdown-parent-lv',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n  &#x3C;h3>Countdown to Liftoff (via local variable)&#x3C;/h3>\n  &#x3C;button (click)=\"timer.start()\">Start&#x3C;/button>\n  &#x3C;button (click)=\"timer.stop()\">Stop&#x3C;/button>\n  &#x3C;div class=\"seconds\">{{timer.seconds}}&#x3C;/div>\n  &#x3C;app-countdown-timer #timer>&#x3C;/app-countdown-timer>\n  `,\n  <a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a>: ['../assets/demo.css']\n})\nexport class CountdownLocalVarParentComponent { }\n\n</code-example>\n<!--\nThe parent component cannot data bind to the child's\n`start` and `stop` methods nor to its `seconds` property.\n-->\n<p>원래 부모 컴포넌트는 자식 컴포넌트의 <code>seconds</code> 프로퍼티나 <code>start</code>, <code>stop</code> 메소드에 직접 접근할 수 없습니다.</p>\n<!--\nYou can place a local variable, `#timer`, on the tag `<countdown-timer>` representing the child component.\nThat gives you a reference to the child component and the ability to access\n*any of its properties or methods* from within the parent template.\n-->\n<p>하지만 <code>&#x3C;countdown-timer></code>를 템플릿 지역 변수 <code>#timer</code>로 선언하면 이 변수를 사용해서 자식 컴포넌트에 접근할 수 있습니다.\n이 템플릿 지역 변수는 자식 컴포넌트 자체를 가리키며, 템플릿 지역 변수를 선언한 후에는 부모 컴포넌트의 템플릿에서 <em>자식 컴포넌트의 프로퍼티나 메소드</em>에 자유롭게 접근할 수 있습니다.</p>\n<!--\nThis example wires parent buttons to the child's `start` and `stop` and\nuses interpolation to display the child's `seconds` property.\n-->\n<p>이 예제에서는 부모 컴포넌트에 있는 버튼을 각각 자식 컴포넌트의 <code>start</code> 함수와 <code>stop</code> 함수와 연결하며, <code>seconds</code> 프로퍼티를 직접 가져와서 부모 컴포넌트에서 활용합니다.</p>\n<!--\nHere we see the parent and child working together.\n-->\n<p>부모 컴포넌트와 자식 컴포넌트가 어떻게 연동되는지 확인해 보세요.</p>\n<figure>\n  <img src=\"generated/images/guide/component-interaction/countdown-timer-anim.gif\" alt=\"countdown timer\" width=\"212\" height=\"172\">\n</figure>\n<a id=\"countdown-tests\"></a>\n<!--\n<h3 class=\"no-toc\">Test it</h3>\n-->\n<h3 class=\"no-toc\" id=\"동작-확인-4\">동작 확인<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#동작-확인-4\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nTest that the seconds displayed in the parent template\nmatch the seconds displayed in the child's status message.\nTest also that clicking the *Stop* button pauses the countdown timer:\n-->\n<p>부모 컴포넌트의 템플릿에 표시되는 타이머는 자식 컴포넌트에 있는 프로퍼티를 참조하기 때문에 자식 컴포넌트에서 표시하는 메시지와 같은 값을 표시합니다.\n그리고 다음 테스트 코드는 <em>Stop</em> 버튼을 클릭했을 때 카운트다운 타이머가 멈추는지도 확인합니다:</p>\n<code-example path=\"component-interaction/e2e/src/app.e2e-spec.ts\" region=\"countdown-timer-tests\" header=\"component-interaction/e2e/src/app.e2e-spec.ts\">\n// ...\nit('timer and parent seconds should match', function () {\n  let parent = element(by.tagName(parentTag));\n  let <a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a> = parent.element(by.tagName('app-countdown-timer')).getText();\n  browser.sleep(10); // give `seconds` <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> chance to catchup with `<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>`\n  let seconds = parent.element(by.className('seconds')).getText();\n  expect(<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>).toContain(seconds);\n});\n\nit('should stop the countdown', function () {\n  let parent = element(by.tagName(parentTag));\n  let stopButton = parent.all(by.tagName('button')).get(1);\n\n  stopButton.click().then(function() {\n    let <a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a> = parent.element(by.tagName('app-countdown-timer')).getText();\n    expect(<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>).toContain('Holding');\n  });\n});\n// ...\n\n</code-example>\n<!--\n[Back to top](guide/component-interaction#top)\n-->\n<p><a href=\"guide/component-interaction#top\">맨 위로</a></p>\n<a id=\"parent-to-view-child\"></a>\n<!--\n## Parent calls an _@ViewChild()_\n-->\n<h2 id=\"viewchild-로-자식-컴포넌트-접근하기\"><em>@ViewChild()</em> 로 자식 컴포넌트 접근하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#viewchild-로-자식-컴포넌트-접근하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe *local variable* approach is simple and easy. But it is limited because\nthe parent-child wiring must be done entirely within the parent template.\nThe parent component *itself* has no access to the child.\n-->\n<p><em>템플릿 지역 변수</em>로 자식 컴포넌트에 접근하는 것은 문법도 간단하고 이해하기 쉽습니다. 하지만 이 방식은 부모 컴포넌트의 템플릿에서만 자식 컴포넌트에 접근할 수 있기 때문에 자유롭게 활용하기에는 제한이 있습니다.\n부모 컴포넌트의 <em>클래스</em>에서는 자식 컴포넌트에 접근할 수 없기 때문입니다.</p>\n<!--\nYou can't use the *local variable* technique if an instance of the parent component *class*\nmust read or write child component values or must call child component methods.\n-->\n<p><em>템플릿 지역 변수</em>를 사용하는 방법은 부모 컴포넌트 <em>클래스</em>에서는 유효하지 않습니다. 그래서 부모 컴포넌트의 클래스에서는 자식 컴포넌트의 프로퍼티를 읽거나 메소드를 실행할 수 없습니다.</p>\n<!--\nWhen the parent component *class* requires that kind of access,\n***inject*** the child component into the parent as a *ViewChild*.\n-->\n<p>부모 컴포넌트의 <em>클래스</em>에서 자식 컴포넌트에 접근하려면 자식 컴포넌트에 <em>ViewChild</em>를 사용해서 부모 컴포넌트로 <strong><em>주입</em></strong> 해야 합니다.</p>\n<!--\nThe following example illustrates this technique with the same\n[Countdown Timer](guide/component-interaction#countdown-timer-example) example.\nNeither its appearance nor its behavior will change.\nThe child [CountdownTimerComponent](guide/component-interaction#countdown-timer-example) is the same as well.\n-->\n<p>이 내용은 다음 예제로 알아봅시다. 이 예제는 위에서 살펴본 <a href=\"guide/component-interaction#countdown-timer-example\">카운트다운 타이머</a>와 같은 동작을 하지만, 구현 방식은 조금 다릅니다.\n먼저, 자식 컴포넌트인 <a href=\"guide/component-interaction#countdown-timer-example\">CountdownTimerComponent</a> 코드는 동일합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nThe switch from the *local variable* to the *ViewChild* technique\nis solely for the purpose of demonstration.\n-->\n<p><em>템플릿 지역 변수</em>를 사용하는 방식에서 <em>ViewChild</em>를 사용하는 방식으로 변경하는 것은 단순히 설명을 위한 것입니다.\n목적에 따라 구현 방식을 선택하면 됩니다.</p>\n</div>\n<!--\nHere is the parent, `CountdownViewChildParentComponent`:\n-->\n<p>그리고 부모 컴포넌트인 <code>CountdownViewChildParentComponent</code>는 다음과 같이 구현합니다:</p>\n<code-example path=\"component-interaction/src/app/countdown-parent.component.ts\" region=\"vc\" header=\"component-interaction/src/app/countdown-parent.component.ts\">\nimport { <a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a>, <a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a> } from '@angular/core';\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> }                from '@angular/core';\nimport { CountdownTimerComponent }  from './countdown-timer.component';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-countdown-parent-vc',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n  &#x3C;h3>Countdown to Liftoff (via <a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>)&#x3C;/h3>\n  &#x3C;button (click)=\"start()\">Start&#x3C;/button>\n  &#x3C;button (click)=\"stop()\">Stop&#x3C;/button>\n  &#x3C;div class=\"seconds\">{{ seconds() }}&#x3C;/div>\n  &#x3C;app-countdown-timer>&#x3C;/app-countdown-timer>\n  `,\n  <a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a>: ['../assets/demo.css']\n})\nexport class CountdownViewChildParentComponent implements <a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a> {\n\n  @<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>(CountdownTimerComponent)\n  private timerComponent: CountdownTimerComponent;\n\n  seconds() { return 0; }\n\n  ngAfterViewInit() {\n    // `seconds()` 메소드는 `CountdownTimerComponent.seconds`에서 다시 구현합니다.\n    // 이 때 개발 모드에서 출력하는 단방향 바인딩 검사 에러를 방지하기 위해\n    // 한 싸이클 기다려야 합니다.\n    setTimeout(() => this.seconds = () => this.timerComponent.seconds, 0);\n  }\n\n  start() { this.timerComponent.start(); }\n  stop() { this.timerComponent.stop(); }\n}\n\n</code-example>\n<!--\nIt takes a bit more work to get the child view into the parent component *class*.\n-->\n<p>이 코드를 보면 부모 컴포넌트 <em>클래스</em>에서 자식 컴포넌트에 이전보다 좀 더 많이 개입하는 것을 확인할 수 있습니다.</p>\n<!--\nFirst, you have to import references to the `ViewChild` decorator and the `AfterViewInit` lifecycle hook.\n-->\n<p>먼저, <code><a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 데코레이터와 <code><a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a></code> 라이프싸이클 후킹 인터페이스를 로드합니다.</p>\n<!--\nNext, inject the child `CountdownTimerComponent` into the private `timerComponent` property\nvia the `@ViewChild` property decoration.\n-->\n<p>그리고 <code>CountdownTimerComponent</code>를 <code>timerComponent</code> 프로퍼티로 선언하면서 <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 데코레이터를 사용했습니다.</p>\n<!--\nThe `#timer` local variable is gone from the component metadata.\nInstead, bind the buttons to the parent component's own `start` and `stop` methods and\npresent the ticking seconds in an interpolation around the parent component's `seconds` method.\n-->\n<p>이전에 사용했던 부모 컴포넌트의 템플릿은 템플릿 지역 변수 <code>#timer</code>를 활용해서 자식 컴포넌트의 메소드를 직접 실행했습니다.\n하지만 이번 예제는 자식 컴포넌트를 직접 호출하지 않고 부모 컴포넌트에 있는 <code>start</code>, <code>stop</code> 메소드를 사옹하며, 현재 남아있는 초를 확인할 때도 부모 컴포넌트의 <code>seconds</code> 메소드를 활용합니다.</p>\n<!--\nThese methods access the injected timer component directly.\n-->\n<p>각각의 메소드에서 자식 컴포넌트에 접근하는 식으로 구현하는 것입니다.</p>\n<!--\nThe `ngAfterViewInit()` lifecycle hook is an important wrinkle.\nThe timer component isn't available until *after* Angular displays the parent view.\nSo it displays `0` seconds initially.\n-->\n<p>이 때 <code>ngAfterViewInit()</code> 라이프싸이클 후킹 함수가 중요합니다.\n자식 컴포넌트인 타이머 컴포넌트는 Angular가 부모 컴포넌트의 뷰를 화면에 표시한 <em>이후에야</em> 사용할 수 있습니다.\n그래서 뷰가 완전히 준비되기 전까지는 <code>0</code>을 표시합니다.</p>\n<!--\nThen Angular calls the `ngAfterViewInit` lifecycle hook at which time it is *too late*\nto update the parent view's display of the countdown seconds.\nAngular's unidirectional data flow rule prevents updating the parent view's\nin the same cycle. The app has to *wait one turn* before it can display the seconds.\n-->\n<p>부모 컴포넌트의 뷰가 준비되면 자식 컴포넌트에서 시간을 가져오기 위해 <code>ngAfterViewInit</code> 라이프싸이클 후킹 함수를 실행하는데,\nAngular는 단방향 데이터 흐름을 권장하기 때문에 부모 컴포넌트의 뷰를 같은 JavaScript 실행 싸이클에 업데이트하는 것을 금지합니다.</p>\n<!--\nUse `setTimeout()` to wait one tick and then revise the `seconds()` method so\nthat it takes future values from the timer component.\n-->\n<p>그래서 <code>ngAfterViewInit()</code>에서 자식 컴포넌트의 시간을 가져와서 부모 컴포넌트 프로퍼티에 할당하는 것은 <code>setTimeout()</code> 으로 <em>한 싸이클</em> 늦췄습니다.</p>\n<!--\n<h3 class=\"no-toc\">Test it</h3>\n-->\n<h3 class=\"no-toc\" id=\"동작-확인-5\">동작 확인<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#동작-확인-5\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nUse [the same countdown timer tests](guide/component-interaction#countdown-tests) as before.\n-->\n<p>이전에 살펴봤던 <a href=\"guide/component-interaction#countdown-tests\">카운트다운 타이머 테스트</a>와 같습니다.</p>\n<!--\n[Back to top](guide/component-interaction#top)\n-->\n<p><a href=\"guide/component-interaction#top\">맨 위로</a></p>\n<a id=\"bidirectional-service\"></a>\n<!--\n## Parent and children communicate via a service\n-->\n<h2 id=\"서비스를-사용해서-통신하기\">서비스를 사용해서 통신하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#서비스를-사용해서-통신하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nA parent component and its children share a service whose interface enables bi-directional communication\n*within the family*.\n-->\n<p>부모 컴포넌트와 자식 컴포넌트가 같은 서비스를 주입받는다면 이 서비스를 활용해서 양방향으로 데이터를 주고받을 수 있습니다.</p>\n<!--\nThe scope of the service instance is the parent component and its children.\nComponents outside this component subtree have no access to the service or their communications.\n-->\n<p>컴포넌트에 주입되는 서비스는 그 컴포넌트에서 자유롭게 사용할 수 있습니다.\n이 때 주입되는 서비스의 인스턴스가 동일해야 하기 때문에 서비스 프로바이더를 별도로 지정하면 컴포넌트 통신에 활용할 수 없습니다.</p>\n<!--\nThis `MissionService` connects the `MissionControlComponent` to multiple `AstronautComponent` children.\n-->\n<p><code>MissionControlComponent</code>가 여러 개의 <code>AstronautComponent</code>와 통신하기 위해 <code>MissionService</code>를 만들어 봅시다.</p>\n<code-example path=\"component-interaction/src/app/mission.service.ts\" header=\"component-interaction/src/app/mission.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { Subject }    from 'rxjs';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class MissionService {\n\n  // 문자열 타입의 옵저버블 소스\n  private missionAnnouncedSource = new Subject&#x3C;string>();\n  private missionConfirmedSource = new Subject&#x3C;string>();\n\n  // 문자열 옵저버블 스트림\n  missionAnnounced$ = this.missionAnnouncedSource.asObservable();\n  missionConfirmed$ = this.missionConfirmedSource.asObservable();\n\n  // 서비스가 옵저버블을 전달할 때 사용하는 메소드\n  announceMission(mission: string) {\n    this.missionAnnouncedSource.next(mission);\n  }\n\n  confirmMission(astronaut: string) {\n    this.missionConfirmedSource.next(astronaut);\n  }\n}\n\n</code-example>\n<!--\nThe `MissionControlComponent` both provides the instance of the service that it shares with its children\n(through the `providers` metadata array) and injects that instance into itself through its constructor:\n-->\n<p><code>MissionControlComponent</code>는 생성자를 통해 <code>MissionService</code>의 인스턴스를 주입받으며, <code>providers</code> 메타데이터를 사용해서 서비스 인스턴스를 자식 컴포넌트에서도 사용할 수 있도록 공유합니다:</p>\n<code-example path=\"component-interaction/src/app/missioncontrol.component.ts\" header=\"component-interaction/src/app/missioncontrol.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> }          from '@angular/core';\n\nimport { MissionService }     from './mission.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-mission-control',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n    &#x3C;h2>Mission Control&#x3C;/h2>\n    &#x3C;button (click)=\"announce()\">Announce mission&#x3C;/button>\n    &#x3C;app-astronaut *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let astronaut of astronauts\"\n      [astronaut]=\"astronaut\">\n    &#x3C;/app-astronaut>\n    &#x3C;h3>History&#x3C;/h3>\n    &#x3C;ul>\n      &#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let event of history\">{{event}}&#x3C;/li>\n    &#x3C;/ul>\n  `,\n  providers: [MissionService]\n})\nexport class MissionControlComponent {\n  astronauts = ['Lovell', 'Swigert', 'Haise'];\n  history: string[] = [];\n  missions = ['Fly to the moon!',\n              'Fly to mars!',\n              'Fly to Vegas!'];\n  nextMission = 0;\n\n  constructor(private missionService: MissionService) {\n    missionService.missionConfirmed$.subscribe(\n      astronaut => {\n        this.history.push(`${astronaut} confirmed the mission`);\n      });\n  }\n\n  announce() {\n    let mission = this.missions[this.nextMission++];\n    this.missionService.announceMission(mission);\n    this.history.push(`Mission \"${mission}\" announced`);\n    if (this.nextMission >= this.missions.length) { this.nextMission = 0; }\n  }\n}\n\n</code-example>\n<!--\nThe `AstronautComponent` also injects the service in its constructor.\nEach `AstronautComponent` is a child of the `MissionControlComponent` and therefore receives its parent's service instance:\n-->\n<p>그리고 자식 컴포넌트 <code>AstronautComponent</code>도 생성자를 통해 서비스 인스턴스를 주입 받습니다:</p>\n<code-example path=\"component-interaction/src/app/astronaut.component.ts\" header=\"component-interaction/src/app/astronaut.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a> } from '@angular/core';\n\nimport { MissionService } from './mission.service';\nimport { Subscription }   from 'rxjs';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-astronaut',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n    &#x3C;p>\n      {{astronaut}}: &#x3C;strong>{{mission}}&#x3C;/strong>\n      &#x3C;button\n        (click)=\"confirm()\"\n        [disabled]=\"!announced || confirmed\">\n        Confirm\n      &#x3C;/button>\n    &#x3C;/p>\n  `\n})\nexport class AstronautComponent implements <a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a> {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() astronaut: string;\n  mission = '&#x3C;no mission announced>';\n  confirmed = false;\n  announced = false;\n  <a href=\"api/service-worker/SwPush#subscription\" class=\"code-anchor\">subscription</a>: Subscription;\n\n  constructor(private missionService: MissionService) {\n    this.subscription = missionService.missionAnnounced$.subscribe(\n      mission => {\n        this.mission = mission;\n        this.announced = true;\n        this.confirmed = false;\n    });\n  }\n\n  confirm() {\n    this.confirmed = true;\n    this.missionService.confirmMission(this.astronaut);\n  }\n\n  ngOnDestroy() {\n    // prevent memory leak when component destroyed\n    this.subscription.unsubscribe();\n  }\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\nNotice that this example captures the `subscription` and `unsubscribe()` when the `AstronautComponent` is destroyed.\nThis is a memory-leak guard step. There is no actual risk in this app because the\nlifetime of a `AstronautComponent` is the same as the lifetime of the app itself.\nThat *would not* always be true in a more complex application.\n-->\n<p>이 예제는 옵저버블을 활용하기 때문에 <code>AstronautComponent</code>가 종료될 때 옵저버블을 해제하기 위해 <code><a href=\"api/service-worker/SwPush#unsubscribe\" class=\"code-anchor\">unsubscribe()</a></code>를 실행합니다.\n이 함수는 메모리 누수를 막기 위해 필요하며, <code>AstronautComponent</code>가 종료되는 시점이 앱이 종료되는 시점과 같다면 이 로직을 작성하지 않아도 문제는 없습니다.\n하지만 애플리케이션이 복잡해진다면 <em>그렇지 않을</em> 가능성이 더 크기 때문에 빠뜨리지 않고 작성하는 것이 좋습니다.</p>\n<!--\nYou don't add this guard to the `MissionControlComponent` because, as the parent,\nit controls the lifetime of the `MissionService`.\n-->\n<p>그리고 이 로직은 부모 컴포넌트 <code>MissionControlComponent</code>에는 필요 없습니다. 부모 컴포넌트와 <code>MissionService</code>가 종료되는 시점은 같습니다.</p>\n</div>\n<!--\nThe *History* log demonstrates that messages travel in both directions between\nthe parent `MissionControlComponent` and the `AstronautComponent` children,\nfacilitated by the service:\n-->\n<p>부모 컴포넌트 <code>MissionControlComponent</code>와 자식 컴포넌트 <code>AstronautComponent</code>가 서비스를 통해 데이터를 주고받는 과정은 <em>History</em> 영역에 다음과 같이 표시됩니다: </p>\n<figure>\n  <img src=\"generated/images/guide/component-interaction/bidirectional-service.gif\" alt=\"bidirectional-service\" width=\"310\" height=\"346\">\n</figure>\n<!--\n<h3 class=\"no-toc\">Test it</h3>\n-->\n<h3 class=\"no-toc\" id=\"동작-확인-6\">동작 확인<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#동작-확인-6\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nTests click buttons of both the parent `MissionControlComponent` and the `AstronautComponent` children\nand verify that the history meets expectations:\n-->\n<p>부모 컴포넌트 <code>MissionControlComponent</code>와 자식 컴포넌트 <code>AstronautComponent</code>의 버튼을 클릭했을 때 로그를 제대로 출력하는지 확인하기 위해 테스트 코드를 다음과 같이 작성합니다:</p>\n<code-example path=\"component-interaction/e2e/src/app.e2e-spec.ts\" region=\"bidirectional-service\" header=\"component-interaction/e2e/src/app.e2e-spec.ts\">\n// ...\nit('should announce <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> mission', function () {\n  let missionControl = element(by.tagName('app-mission-control'));\n  let announceButton = missionControl.all(by.tagName('button')).get(0);\n  announceButton.click().then(function () {\n    let history = missionControl.all(by.tagName('li'));\n    expect(history.count()).toBe(1);\n    expect(history.get(0).getText()).toMatch(/Mission.* announced/);\n  });\n});\n\nit('should confirm the mission by Lovell', function () {\n  testConfirmMission(1, 2, 'Lovell');\n});\n\nit('should confirm the mission by Haise', function () {\n  testConfirmMission(3, 3, 'Haise');\n});\n\nit('should confirm the mission by Swigert', function () {\n  testConfirmMission(2, 4, 'Swigert');\n});\n\nfunction testConfirmMission(buttonIndex: number, expectedLogCount: number, astronaut: string) {\n  let _confirmedLog = ' confirmed the mission';\n  let missionControl = element(by.tagName('app-mission-control'));\n  let confirmButton = missionControl.all(by.tagName('button')).get(buttonIndex);\n  confirmButton.click().then(function () {\n    let history = missionControl.all(by.tagName('li'));\n    expect(history.count()).toBe(expectedLogCount);\n    expect(history.get(expectedLogCount - 1).getText()).toBe(astronaut + _confirmedLog);\n  });\n}\n// ...\n\n</code-example>\n<!--\n[Back to top](guide/component-interaction#top)\n-->\n<p><a href=\"guide/component-interaction#top\">맨 위로</a></p>\n\n</div>\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/animations/browser/testing/MockAnimationDriver#log\n - api/common/NgForOf\n - api/common/NgForOfContext#count\n - api/common/http/HttpErrorResponse#message\n - api/core/AfterViewInit\n - api/core/Component\n - api/core/Component#styleUrls\n - api/core/Component#template\n - api/core/DebugElement#properties\n - api/core/EventEmitter\n - api/core/Injectable\n - api/core/Input\n - api/core/OnChanges\n - api/core/OnDestroy\n - api/core/OnInit\n - api/core/Output\n - api/core/QueryList#changes\n - api/core/ReflectiveKey#displayName\n - api/core/SimpleChange\n - api/core/Version\n - api/core/Version#major\n - api/core/Version#minor\n - api/core/ViewChild\n - api/router/RouterLinkWithHref\n - api/service-worker/SwPush#subscription\n - api/service-worker/SwPush#unsubscribe\n - guide/component-interaction#countdown-tests\n - guide/component-interaction#countdown-timer-example\n - guide/component-interaction#ngonchanges로-입력-프로퍼티-가로채기\n - guide/component-interaction#top\n - guide/component-interaction#viewchild-로-자식-컴포넌트-접근하기\n - guide/component-interaction#동작-확인\n - guide/component-interaction#동작-확인-1\n - guide/component-interaction#동작-확인-2\n - guide/component-interaction#동작-확인-3\n - guide/component-interaction#동작-확인-4\n - guide/component-interaction#동작-확인-5\n - guide/component-interaction#동작-확인-6\n - guide/component-interaction#부모-컴포넌트에서-자식-컴포넌트로-데이터-전달하기--입력-바인딩\n - guide/component-interaction#서비스를-사용해서-통신하기\n - guide/component-interaction#입력-프로퍼티를-세터setter로-가로채기\n - guide/component-interaction#자식-컴포넌트에서-보내는-이벤트-받기\n - guide/component-interaction#컴포넌트-통신\n - guide/component-interaction#템플릿-지역-변수로-자식-컴포넌트에-접근하기\n - guide/lifecycle-hooks\n - guide/template-syntax#inputs-outputs\n - https://github.com/angular/angular/edit/master/aio/content/guide/component-interaction.md?message=docs%3A%20describe%20your%20change...\n-->"
}