{
  "id": "guide/providers",
  "title": "Providing dependencies in modules",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/providers.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"providing-dependencies-in-modules\">Providing dependencies in modules<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#providing-dependencies-in-modules\"><i class=\"material-icons\">link</i></a></h1>\n<!--\nA provider is an instruction to the [Dependency Injection](/guide/dependency-injection) system on how to obtain a value for a dependency. Most of the time, these dependencies are services that you create and provide.\n\nFor the final sample app using the provider that this page describes,\nsee the <live-example></live-example>.\n-->\n<p>프로바이더는 <a href=\"/guide/dependency-injection\">의존성 주입</a>에 사용되는 객체를 가져오는 방법을 지정한 것입니다. 이 때 의존성으로 주입되는 객체는 일반적으로 서비스입니다.</p>\n<p>이 가이드에서 다루는 예제의 최종 코드는 <live-example></live-example>에서 직접 확인하거나 다운받아 확인할 수 있습니다.</p>\n<!--\n## Providing a service\n-->\n<h2 id=\"서비스-등록하기\">서비스 등록하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#서비스-등록하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nIf you already have an app that was created with the [Angular CLI](cli), you can create a service using the [`ng generate`](cli/generate) CLI command in the root project directory. Replace _User_ with the name of your service.\n\n```sh\nng generate service User\n```\n\nThis command creates the following `UserService` skeleton:\n\n<code-example path=\"providers/src/app/user.service.0.ts\" header=\"src/app/user.service.ts\">\nimport { Injectable } from &#39;@angular/core&#39;;\n\n@Injectable({\n  providedIn: &#39;root&#39;,\n})\nexport class UserService {\n}\n\n\n</code-example>\n\nYou can now inject `UserService` anywhere in your application.\n\nThe service itself is a class that the CLI generated and that's decorated with `@Injectable()`. By default, this decorator has a `providedIn` property, which creates a provider for the service. In this case, `providedIn: 'root'` specifies that Angular should provide the service in the root injector.\n-->\n<p><a href=\"cli\">Angular CLI</a>로 프로젝트를 생성했다면, 서비스를 만드는 것도 간단합니다.\n프로젝트 최상위 폴더에서 <a href=\"cli/generate\"><code>ng generate</code></a> 명령을 실행하는데, 이 때 <code>Service</code> 접미사 없이 <em>User</em> 라고 지정합니다.</p>\n<code-example language=\"sh\">\nng generate service User\n</code-example>\n<p>그러면 <code>UserService</code>가 다음과 같이 생성됩니다:</p>\n<code-example path=\"providers/src/app/user.service.0.ts\" header=\"src/app/user.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class UserService {\n}\n\n\n</code-example>\n<p>이제 이 <code>UserService</code>는 애플리케이션 어디에라도 의존성으로 자유롭게 주입할 수 있습니다.</p>\n<p>서비스는 단순하게 JavaScript 클래스일 뿐이며, Angular CLI로 서비스를 생성하면 CLI가 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> 데코레이터를 자동으로 붙여서 Angular 서비스로 지정합니다.\n<code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> 데코레이터 안에는 <code>providedIn</code> 프로퍼티가 있는데, 이 프로퍼티를 지정하면 서비스 프로바이더의 범위를 지정할 수 있습니다.\n이 예제 코드에서 지정된 <code>providedIn: 'root'</code>는 이 서비스가 최상위 인젝터에 위치하도록 지정하는 코드입니다.</p>\n<!--\n## Provider scope\n-->\n<h2 id=\"프로바이더의-접근범위\">프로바이더의 접근범위<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#프로바이더의-접근범위\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nWhen you add a service provider to the root application injector, it’s available throughout the app. Additionally, these providers are also available to all the classes in the app as long they have the lookup token.\n\nYou should always provide your service in the root injector unless there is a case where you want the service to be available only if the consumer imports a particular `@NgModule`.\n-->\n<p>애플리케이션의 최상위 인젝터에 서비스 프로바이더를 등록하면, 이 서비스는 앱 전역에서 자유롭게 사용할 수 있습니다.</p>\n<p>서비스 프로바이더는 특정 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>에 포함되지 않는 이상, 최상위 인젝터에 등록하는 것이 좋습니다.</p>\n<!--\n## `providedIn` and NgModules\n-->\n<h2 id=\"providedin과-ngmodule\"><code>providedIn</code>과 NgModule<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#providedin과-ngmodule\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nIt's also possible to specify that a service should be provided in a particular `@NgModule`. For example, if you don't want `UserService` to be available to applications unless they import a `UserModule` you've created, you can specify that the service should be provided in the module:\n\n<code-example path=\"providers/src/app/user.service.1.ts\" header=\"src/app/user.service.ts\">\nimport { Injectable } from &#39;@angular/core&#39;;\nimport { UserModule } from &#39;./user.module&#39;;\n\n@Injectable({\n  providedIn: UserModule,\n})\nexport class UserService {\n}\n\n\n</code-example>\n\nThe example above shows the preferred way to provide a service in a module. This method is preferred because it enables tree-shaking of the service if nothing injects it. If it's not possible to specify in the service which module should provide it, you can also declare a provider for the service within the module:\n\n<code-example path=\"providers/src/app/user.module.ts\" header=\"src/app/user.module.ts\">\nimport { NgModule } from &#39;@angular/core&#39;;\n\nimport { UserService } from &#39;./user.service&#39;;\n\n@NgModule({\n  providers: [UserService],\n})\nexport class UserModule {\n}\n\n\n</code-example>\n-->\n<p>특정 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>에 포함되도록 서비스를 등록할 수도 있습니다. 예를 들어 <code>UserModule</code>을 로드하지 않은 상태에서는 <code>UserService</code>를 사용할 수 없도록 하려면, 코드를 다음과 같이 작성하면 됩니다:</p>\n<code-example path=\"providers/src/app/user.service.1.ts\" header=\"src/app/user.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { UserModule } from './user.module';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: UserModule,\n})\nexport class UserService {\n}\n\n\n</code-example>\n<p>이 방법을 사용하면 실제로 사용되지 않는 서비스는 트리 셰이킹으로 제거되기 때문에 애플리케이션을 배포할 때도 좋습니다. 서비스가 포함될 모듈을 지정하는 방법을 사용할 수 없다면, 반대로 모듈 안에 서비스 프로바이더를 등록하는 방법도 있습니다:</p>\n<code-example path=\"providers/src/app/user.module.ts\" header=\"src/app/user.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\n\nimport { UserService } from './user.service';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  providers: [UserService],\n})\nexport class UserModule {\n}\n\n\n</code-example>\n<a id=\"limiting-provider-scope-by-lazy-loading-modules\"></a>\n<!--\n## Limiting provider scope by lazy loading modules\n-->\n<h2 id=\"프로바이더-범위-제한하기--지연-로딩되는-모듈\">프로바이더 범위 제한하기 : 지연 로딩되는 모듈<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#프로바이더-범위-제한하기--지연-로딩되는-모듈\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nIn the basic CLI-generated app, modules are eagerly loaded which means that they are all loaded when the app launches. Angular uses an injector system to make things available between modules. In an eagerly loaded app, the root application injector makes all of the providers in all of the modules available throughout the app.\n\nThis behavior necessarily changes when you use lazy loading. Lazy loading is when you load modules only when you need them; for example, when routing. They aren’t loaded right away like with eagerly loaded modules. This means that any services listed in their provider arrays aren’t available because the root injector doesn’t know about these modules.\n-->\n<p>Angular CLI를 사용해서 생성한 앱은 애플리케이션이 실행되면서 모든 모듈이 즉시 로드됩니다.\n애플리케이션의 최상위 인젝터는 애플리케이션이 실행된 직후에 모듈 안에 등로된 프로바이더에 접근해서 의존성 객체를 생성할 준비를 합니다.</p>\n<p>하지만 지연 로딩 되는 모듈에서는 좀 다릅니다.\n지연 로딩 되도록 설정된 모듈은 애플리케이션이 실행된 직후에 바로 로드되지 않고, 라우팅 이동 등 해당 모듈을 사용하는 시점에 로드됩니다.\n따라서 지연 로딩되는 모듈에 지정된 서비스 프로바이더는 최상위 인젝터에서 인식할 수 없기 때문에 이 모듈 밖에서는 사용할 수도 없습니다.</p>\n<!-- KW--Make diagram here -->\n<!-- KW--per Misko: not clear if the lazy modules are siblings or grand-children. They are both depending on router structure. -->\n<!--\nWhen the Angular router lazy-loads a module, it creates a new injector. This injector is a child of the root application injector. Imagine a tree of injectors; there is a single root injector and then a child injector for each lazy loaded module. The router adds all of the providers from the root injector to the child injector. When the router creates a component within the lazy-loaded context, Angular prefers service instances created from these providers to the service instances of the application root injector.\n\nAny component created within a lazy loaded module’s context, such as by router navigation, gets the local instance of the service, not the instance in the root application injector. Components in external modules continue to receive the instance created for the application root.\n\nThough you can provide services by lazy loading modules, not all services can be lazy loaded. For instance, some modules only work in the root module, such as the Router. The Router works with the global location object in the browser.\n\nAs of Angular version 9, you can provide a new instance of a service with each lazy loaded module. The following code adds this functionality to `UserService`.\n\n<code-example path=\"providers/src/app/user.service.2.ts\" header=\"src/app/user.service.ts\">\nimport { Injectable } from &#39;@angular/core&#39;;\n\n@Injectable({\n  providedIn: &#39;any&#39;,\n})\nexport class UserService {\n}\n\n\n</code-example>\n\nWith `providedIn: 'any'`, all eagerly loaded modules share a singleton instance; however, lazy loaded modules each get their own unique instance, as shown in the following diagram.\n\n<img src=\"generated/images/guide/providers/any-provider.svg\" alt=\"any-provider-scope\" class=\"left\">\n-->\n<p>Angular 라우터가 모듈을 지연 로딩하면, 이 때 새로운 인젝터를 생성합니다.\n이 인젝터는 애플리케이션의 최상위 인젝터의 자식 인젝터인데, 인젝트도 모듈 트리와 비슷하게 트리 구조로 구성됩니다.\n지연 로딩되는 모듈에 생성된 인젝터가 등록하는 모든 프로바이더는 최상위 인젝터에도 등록되며, 지연 로딩되는 모듈에 있는 컴포넌트가 사용될 때는 애플리케이션의 최상위 인젝터 대신 이 모듈의 인젝터가 서비스 인스턴스를 생성합니다.</p>\n<p>지연 로딩되는 모듈이 로딩되고 나면, 지연 로딩되는 모듈이 아니라면 애플리케이션의 최상위 인젝터를 계속 사용하지만 지연 로딩되는 모듈 안에서는 최상위 인젝터 대신 모듈의 인젝터를 사용합니다.</p>\n<p>하지만 모듈이 지연 로딩된다고 해서 모든 서비스가 지연로딩 되는 것은 아닙니다.\n예를 들면, Router와 같은 모듈은 앱 모듈에만 등록되었지만 이 모듈은 브라우저 전체를 대상으로 동작합니다.</p>\n<p>As of Angular version 9, you can provide a new instance of a service with each lazy loaded module. The following code adds this functionality to <code>UserService</code>.</p>\n<code-example path=\"providers/src/app/user.service.2.ts\" header=\"src/app/user.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'any',\n})\nexport class UserService {\n}\n\n\n</code-example>\n<p>With <code>providedIn: 'any'</code>, all eagerly loaded modules share a singleton instance; however, lazy loaded modules each get their own unique instance, as shown in the following diagram.</p>\n<img src=\"generated/images/guide/providers/any-provider.svg\" alt=\"any-provider-scope\" class=\"left\" width=\"607\" height=\"389\">\n<!--\n## Limiting provider scope with components\n-->\n<h2 id=\"프로바이더-범위-제한하기--컴포넌트\">프로바이더 범위 제한하기 : 컴포넌트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#프로바이더-범위-제한하기--컴포넌트\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAnother way to limit provider scope is by adding the service you want to limit to the component’s\n`providers` array. Component providers and NgModule providers are independent of each other. This\nmethod is helpful when you want to eagerly load a module that needs a service all to itself.\nProviding a service in the component limits the service only to that component and its descendants.\nOther components in the same module can’t access it.\n\n<code-example path=\"providers/src/app/app.component.ts\" region=\"component-providers\" header=\"src/app/app.component.ts\">\n@Component({\n/* . . . */\n  providers: [UserService]\n})\n\n</code-example>\n-->\n<p>프로바이더의 범위는 컴포넌트 안으로 제한할 수도 있는데, 이 때 컴포넌트 메타데이터의 <code>providers</code> 배열을 사용합니다.\n그러면 NgModule의 프로바이더와는 별개로 컴포넌트 프로바이더가 의존성 객체를 생성합니다.\n이 방법은 컴포넌트마다 서비스 인스턴스를 별개로 사용하는 경우에 활용하면 좋습니다.\n이렇게 구성하면 서비스가 컴포넌트의 접근 범위가 컴포넌트와 해당 컴포넌트의 자식 컴포넌트 범위로 제한됩니다.\n다른 컴포넌트는 같은 모듈에 있다고 해도 이 서비스에 접근할 수 없습니다.</p>\n<code-example path=\"providers/src/app/app.component.ts\" region=\"component-providers\" header=\"src/app/app.component.ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n/* . . . */\n  providers: [UserService]\n})\n\n</code-example>\n<!--\n## Providing services in modules vs. components\n-->\n<h2 id=\"프로바이더-등록-위치--모듈-vs-컴포넌트\">프로바이더 등록 위치 : 모듈 vs. 컴포넌트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#프로바이더-등록-위치--모듈-vs-컴포넌트\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nGenerally, provide services the whole app needs in the root module and scope services by providing them in lazy loaded modules.\n\nThe router works at the root level so if you put providers in a component, even `AppComponent`, lazy loaded modules, which rely on the router, can’t see them.\n-->\n<p>일반적으로 서비스는 최상위 모듈 전역을 대상으로 제공되며 지연 로딩되는 모듈의 서비스는 그 모듈의 범위로 제한됩니다.</p>\n<p>그리고 라우터는 최상위 계층에서 동작하기 때문에 <code>AppComponent</code>를 포함한 모든 컴포넌트에서 서비스를 자유롭게 주입받을 수 있지만, 지연 로딩 모듈은 모듈이 로딩되기 전까지 사용할 수 없습니다.</p>\n<!-- KW--Make a diagram here -->\n<!--\nRegister a provider with a component when you must limit a service instance to a component and its component tree, that is, its child components. For example, a user editing component, `UserEditorComponent`, that needs a private copy of a caching `UserService` should register the `UserService` with the `UserEditorComponent`. Then each new instance of the `UserEditorComponent` gets its own cached service instance.\n-->\n<p>프로바이더를 컴포넌트에 지정하면 서비스 인스턴스의 범위도 해당 컴포넌트로 제한되며, 컴포넌트가 생성될 때마다 서비스 인스턴스가 생성됩니다.\n예를 들면 <code>UserEditorComponent</code>에서 <code>UserService</code>를 사용하는데 이 서비스가 컴포넌트마다 다른 값을 캐싱하는 용도로 사용할 수 있으며, 새로운 <code>UserEditorComponent</code>가 생성되면 <code>UserService</code>의 인스턴스도 새롭게 생성됩니다.</p>\n<hr>\n<!--\n## More on NgModules\n-->\n<h2 id=\"ngmodule-더-알아보기\">NgModule 더 알아보기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#ngmodule-더-알아보기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nYou may also be interested in:\n* [Singleton Services](guide/singleton-services), which elaborates on the concepts covered on this page.\n* [Lazy Loading Modules](guide/lazy-loading-ngmodules).\n* [Tree-shakable Providers](guide/dependency-injection-providers#tree-shakable-providers).\n* [NgModule FAQ](guide/ngmodule-faq).\n-->\n<p>다음 내용에 대해서도 알아보세요.</p>\n<ul>\n<li><a href=\"guide/singleton-services\">싱글턴 서비스</a></li>\n<li><a href=\"guide/lazy-loading-ngmodules\">모듈 지연 로딩</a></li>\n<li><a href=\"guide/dependency-injection-providers#%ED%8A%B8%EB%A6%AC-%EC%85%B0%EC%9D%B4%ED%82%B9-%EB%8C%80%EC%83%81%EC%9D%B4-%EB%90%98%EB%8A%94-%ED%94%84%EB%A1%9C%EB%B0%94%EC%9D%B4%EB%8D%94\">트리 셰이킹 프로바이더</a></li>\n<li><a href=\"guide/ngmodule-faq\">NgModule FAQ</a></li>\n</ul>\n\n</div>\n\n<!-- links to this doc:\n - guide/bootstrapping\n - guide/entry-components\n - guide/example-apps-list\n - guide/feature-modules\n - guide/lazy-loading-ngmodules\n - guide/module-types\n - guide/ngmodule-api\n - guide/ngmodules\n - guide/sharing-ngmodules\n - tutorial/toh-pt4\n-->\n<!-- links from this doc:\n - /guide/dependency-injection\n - api/core/Component\n - api/core/Injectable\n - api/core/NgModule\n - cli\n - cli/generate\n - guide/dependency-injection-providers#%ED%8A%B8%EB%A6%AC-%EC%85%B0%EC%9D%B4%ED%82%B9-%EB%8C%80%EC%83%81%EC%9D%B4-%EB%90%98%EB%8A%94-%ED%94%84%EB%A1%9C%EB%B0%94%EC%9D%B4%EB%8D%94\n - guide/lazy-loading-ngmodules\n - guide/ngmodule-faq\n - guide/providers#ngmodule-더-알아보기\n - guide/providers#providedin과-ngmodule\n - guide/providers#providing-dependencies-in-modules\n - guide/providers#서비스-등록하기\n - guide/providers#프로바이더-등록-위치--모듈-vs-컴포넌트\n - guide/providers#프로바이더-범위-제한하기--지연-로딩되는-모듈\n - guide/providers#프로바이더-범위-제한하기--컴포넌트\n - guide/providers#프로바이더의-접근범위\n - guide/singleton-services\n - https://github.com/angular/angular/edit/master/aio/content/guide/providers.md?message=docs%3A%20describe%20your%20change...\n-->"
}