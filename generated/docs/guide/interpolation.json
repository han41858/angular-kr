{
  "id": "guide/interpolation",
  "title": "문자열 바인딩과 템플릿 표현식",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/interpolation.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Interpolation and template expressions\n-->\n<h1 id=\"문자열-바인딩과-템플릿-표현식\">문자열 바인딩과 템플릿 표현식<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/interpolation#문자열-바인딩과-템플릿-표현식\"><i class=\"material-icons\">link</i></a></h1>\n<!--\nInterpolation allows you to incorporate calculated strings into the text\nbetween HTML element tags and within attribute assignments. Template\nexpressions are what you use to calculate those strings.\n\n<div class=\"alert is-helpful\">\n\nSee the <live-example></live-example> for all of\nthe syntax and code snippets in this guide.\n\n</div>\n-->\n<p>문자열 바인딩(interpolation)을 활용하면 문자열이 계산된 결과를 HTML 엘리먼트나 어트리뷰트에 할당할 수 있습니다.\n그리고 이런 방식으로 사용되는 문자열을 템플릿 표현식(template expression)이라고 합니다.</p>\n<div class=\"alert is-helpful\">\n<p>이 문서에서 설명하는 내용은 <live-example></live-example>에서 직접 확인하거나 다운받아 확인할 수 있습니다.</p>\n</div>\n<!--\n## Interpolation `{{...}}`\n-->\n<h2 id=\"문자열-바인딩-\">문자열 바인딩 <code>{{...}}</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/interpolation#문자열-바인딩-\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nInterpolation refers to embedding expressions into marked up text.\nBy default, interpolation uses as its delimiter the double curly braces, `{{` and `}}`.\n\nIn the following snippet, `{{ currentCustomer }}` is an example of interpolation.\n\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"interpolation-example1\" header=\"src/app/app.component.html\">\n&lt;h3&gt;Current customer: {{ currentCustomer }}&lt;/h3&gt;\n\n</code-example>\n\nThe text between the braces is often the name of a component\nproperty. Angular replaces that name with the\nstring value of the corresponding component property.\n\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"component-property\" header=\"src/app/app.component.html\">\n&lt;p&gt;{{title}}&lt;/p&gt;\n&lt;div&gt;&lt;img src=&quot;{{itemImageUrl}}&quot;&gt;&lt;/div&gt;\n\n</code-example>\n\nIn the example above, Angular evaluates the `title` and `itemImageUrl` properties\nand fills in the blanks, first displaying some title text and then an image.\n\nMore generally, the text between the braces is a **template expression**\nthat Angular first **evaluates** and then **converts to a string**.\nThe following interpolation illustrates the point by adding two numbers:\n\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"convert-string\" header=\"src/app/app.component.html\">\n&lt;!-- &quot;The sum of 1 + 1 is 2&quot; --&gt;\n&lt;p&gt;The sum of 1 + 1 is {{1 + 1}}.&lt;/p&gt;\n\n</code-example>\n\nThe expression can invoke methods of the host component such as `getVal()` in\nthe following example:\n\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"invoke-method\" header=\"src/app/app.component.html\">\n&lt;!-- &quot;The sum of 1 + 1 is not 4&quot; --&gt;\n&lt;p&gt;The sum of 1 + 1 is not {{1 + 1 + getVal()}}.&lt;/p&gt;\n\n</code-example>\n\nAngular evaluates all expressions in double curly braces,\nconverts the expression results to strings, and links them with neighboring literal strings. Finally,\nit assigns this composite interpolated result to an **element or directive property**.\n\nYou appear to be inserting the result between element tags and assigning it to attributes.\nHowever, interpolation is a special syntax that Angular converts into a *property binding*.\n\n<div class=\"alert is-helpful\">\n\nIf you'd like to use something other than `{{` and `}}`, you can\nconfigure the interpolation delimiter via the\n[interpolation](api/core/Component#interpolation)\noption in the `Component` metadata.\n\n</div>\n-->\n<p>템플릿 표현식을 HTML 엘리먼트에 할당하는 문법을 문자열 바인딩이라고 합니다.\n일반적으로 문자열 바인딩은 이중 중괄호 <code>{{</code>, <code>}}</code>를 사용합니다.</p>\n<p>아래 예제 코드에서 <code>{{ currentCustomer }}</code>라고 작성한 부분이 문자열 바인딩을 사용한 코드입니다.</p>\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"interpolation-example1\" header=\"src/app/app.component.html\">\n&#x3C;h3>Current customer: {{ currentCustomer }}&#x3C;/h3>\n\n</code-example>\n<p>이중 중괄호 안에는 보통 컴포넌트 프로퍼티를 사용하는 것이 일반적입니다.\nAngular는 컴포넌트에서 이 프로퍼티를 찾아서 프로퍼티 값을 템플릿에 할당합니다.</p>\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"component-property\" header=\"src/app/app.component.html\">\n&#x3C;p>{{title}}&#x3C;/p>\n&#x3C;div>&#x3C;img src=\"{{itemImageUrl}}\">&#x3C;/div>\n\n</code-example>\n<p>이렇게 작성하면 Angular가 <code>title</code>, <code>itemImageUrl</code> 프로퍼티의 값을 찾아서 템플릿에 할당합니다.\n그래서 결국 제목과 이미지가 화면에 표시됩니다.</p>\n<p>좀 더 일반적으로 설명하면, 이중 중괄호 안에 사용되는 문자열을 <strong>템플릿 표현식(template expression)</strong>라고 하며, Angular가 가장 처음 <strong>평가</strong>해서 <strong>문자열로 변환</strong>하는 항목입니다.\n문자열 바인딩을 사용해서 숫자 2개를 더해 봅시다:</p>\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"convert-string\" header=\"src/app/app.component.html\">\n&#x3C;!-- \"The sum of 1 + 1 is 2\" -->\n&#x3C;p>The sum of 1 + 1 is {{1 + 1}}.&#x3C;/p>\n\n</code-example>\n<p>템플릿 표현식은 호스트 컴포넌트의 메서드를 실행할 수 있습니다.\n그래서 컴포넌트에 있는 <code>getVal()</code> 메서드를 사용한다면 이렇게 작성하면 됩니다:</p>\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"invoke-method\" header=\"src/app/app.component.html\">\n&#x3C;!-- \"The sum of 1 + 1 is not 4\" -->\n&#x3C;p>The sum of 1 + 1 is not {{1 + 1 + getVal()}}.&#x3C;/p>\n\n</code-example>\n<p>이중 중괄호 안에 있는 템플릿 표현식은 모두 Angular가 평가해서 문자열로 변환하며, 해당 문맥에 맞게 할당합니다.\n그래서 <strong>엘리먼트나 디렉티브의 프로퍼티</strong>에 문자열 바인딩을 사용하면 템플릿 표현식이 평가된 문자열이 할당됩니다.</p>\n<p>문자열 바인딩은 엘리먼트 태그나 어트리뷰트에 사용되는 것을 많이 볼 수 있습니다.\n하지만 이 문법은 <em>프로퍼티 바인딩</em>에도 사용됩니다.</p>\n<div class=\"alert is-helpful\">\n<p>문자열 바인딩 문법을 <code>{{</code>, <code>}}</code> 말고 다른 기호로 사용하려면 컴포넌트 메타데이터에 <a href=\"api/core/Component#interpolation\">interpolation</a> 옵션을 지정하면 됩니다.</p>\n</div>\n<a id=\"template-expressions\"></a>\n<!--\n## Template expressions\n-->\n<h2 id=\"템플릿-표현식\">템플릿 표현식<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/interpolation#템플릿-표현식\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nA template **expression** produces a value and appears within the double\ncurly braces, `{{ }}`.\nAngular executes the expression and assigns it to a property of a binding target;\nthe target could be an HTML element, a component, or a directive.\n\nThe interpolation braces in `{{1 + 1}}` surround the template expression `1 + 1`.\nIn the property binding,\na template expression appears in quotes to the right of the&nbsp;`=` symbol as in `[property]=\"expression\"`.\n\nIn terms of syntax, template expressions are similar to JavaScript.\nMany JavaScript expressions are legal template expressions, with a few exceptions.\n\nYou can't use JavaScript expressions that have or promote side effects,\nincluding:\n\n* Assignments (`=`, `+=`, `-=`, `...`)\n* Operators such as `new`, `typeof`, `instanceof`, etc.\n* Chaining expressions with <code>;</code> or <code>,</code>\n* The increment and decrement operators `++` and `--`\n* Some of the ES2015+ operators\n\nOther notable differences from JavaScript syntax include:\n\n* No support for the bitwise operators such as `|` and `&`\n* New [template expression operators](guide/template-expression-operators), such as `|`, `?.` and `!`\n-->\n<p>이중 중괄호 <code>{{ }}</code> 안에 템플릿 표현식(template expression)을 사용하면 표현식의 평가 결과가 해당 부분에 할당됩니다.\n그래서 Angular는 템플릿 표현식이 평가된 결과를 사용해서 HTML 엘리먼트나 컴포넌트, 디렉티브에 프로퍼티 바인딩 할 수 있습니다.</p>\n<p><code>{{1 + 1}}</code> 라는 문자열 바인딩 문법에서 템플릿 표현식은 <code>1 + 1</code> 부분입니다.\n그리고 <code>[프로퍼티]=\"표현식\"</code>과 같이 프로퍼티 바인딩에 사용할 때는 등호(<code>=</code>) 오른쪽에 사용된 부분이 템플릿 표현식입니다.</p>\n<p>문법 측면에서 따져보면 템플릿 표현식은 JavaScript와 비슷합니다.\n실제로도 일부 예외를 제외하면 JavaScript의 문법 대부분을 템플릿 표현식에 사용할 수 있습니다.</p>\n<p>하지만 JavaScript 표현식 중 부수 효과를 발생시키는 다음 항목들은 사용할 수 없습니다:</p>\n<ul>\n<li>할당 표현: <code>=</code>, <code>+=</code>, <code>-=</code>, <code>...</code></li>\n<li><code>new</code>, <code>typeof</code>, <code>instanceof</code> 연산자</li>\n<li><code>;</code>와 <code>,</code>를 사용한 체이닝 표현식</li>\n<li>증감연산자:<code>++</code>, <code>--</code></li>\n<li>ES2015+ 에 도입된 연산자 일부</li>\n</ul>\n<p>그리고 이런 문법도 사용할 수 없습니다:</p>\n<ul>\n<li>비트 연산자: <code>|</code>,  <code>&#x26;</code></li>\n<li>새로 도입된 <a href=\"guide/template-expression-operators\">템플릿 표현식 연산자</a>: <code>|</code>, <code>?.</code>, <code>!</code></li>\n</ul>\n<!--\n## Expression context\n-->\n<h2 id=\"표현식의-컨텍스트\">표현식의 컨텍스트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/interpolation#표현식의-컨텍스트\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe *expression context* is typically the _component_ instance.\nIn the following snippets, the `recommended` within double curly braces and the\n`itemImageUrl2` in quotes refer to properties of the `AppComponent`.\n\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"component-context\" header=\"src/app/app.component.html\">\n&lt;h4&gt;{{recommended}}&lt;/h4&gt;\n&lt;img [src]=&quot;itemImageUrl2&quot;&gt;\n\n</code-example>\n\nAn expression may also refer to properties of the _template's_ context\nsuch as a template input variable,\n<!- link to built-in-directives#template-input-variables ->\n`let customer`, or a template reference variable, `#customerInput`.\n<!- link to guide/template-ref-variables ->\n\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"template-input-variable\" header=\"src/app/app.component.html (template input variable)\">\n&lt;ul&gt;\n  &lt;li *ngFor=&quot;let customer of customers&quot;&gt;{{customer.name}}&lt;/li&gt;\n&lt;/ul&gt;\n\n</code-example>\n\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"template-reference-variable\" header=\"src/app/app.component.html (template reference variable)\">\n&lt;label&gt;Type something:\n  &lt;input #customerInput&gt;{{customerInput.value}}\n&lt;/label&gt;\n\n</code-example>\n\nThe context for terms in an expression is a blend of the _template variables_,\nthe directive's _context_ object (if it has one), and the component's _members_.\nIf you reference a name that belongs to more than one of these namespaces,\nthe template variable name takes precedence, followed by a name in the directive's _context_,\nand, lastly, the component's member names.\n\nThe previous example presents such a name collision. The component has a `customer`\nproperty and the `*ngFor` defines a `customer` template variable.\n\n<div class=\"alert is-helpful\">\n\nThe `customer` in `{{customer.name}}`\nrefers to the template input variable, not the component's property.\n\nTemplate expressions cannot refer to anything in\nthe global namespace, except `undefined`. They can't refer to\n`window` or `document`. Additionally, they\ncan't call `console.log()` or `Math.max()` and they are restricted to referencing\nmembers of the expression context.\n\n</div>\n-->\n<p><em>표현식의 컨텍스트</em>는 일반적으로 <em>컴포넌트</em> 인스턴스 범위입니다.\n아래 예제에서도 이중 중괄호 안에 사용된 <code>recommended</code>와 <code>itemImageUrl2</code>는 모두 <code>AppComponent</code>에 있는 프로퍼티를 가리킵니다.</p>\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"component-context\" header=\"src/app/app.component.html\">\n&#x3C;h4>{{recommended}}&#x3C;/h4>\n&#x3C;img [src]=\"itemImageUrl2\">\n\n</code-example>\n<p>그런데 템플릿 표현식은 <code>let customer</code>와 같은 템플릿 입력 변수나 <code>#customerInput</code>과 같은 템플릿 참조 변수와 같이 <em>템플릿 안</em> 에 있는 프로퍼티를 가리킬 수도 있습니다.</p>\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"template-input-variable\" header=\"src/app/app.component.html (템플릿 입력 변수)\">\n&#x3C;ul>\n  &#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let customer of customers\">{{customer.name}}&#x3C;/li>\n&#x3C;/ul>\n\n</code-example>\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"template-reference-variable\" header=\"src/app/app.component.html (템플릿 참조 변수)\">\n&#x3C;label><a href=\"api/core/Type\" class=\"code-anchor\">Type</a> something:\n  &#x3C;input #customerInput>{{customerInput.value}}\n&#x3C;/label>\n\n</code-example>\n<p>결국 템플릿 표현식의 컨텍스트는 <em>템플릿 변수</em> 와 디렉티브 <em>context</em> 객체, 컴포넌트 <em>멤버</em> 가 섞여 있는 범위라고 볼 수 있습니다.\n이 중 여러 네임스페이스에 속한 이름이 언급되면 템플릿 변수, 디렉티브의 <em>context</em> 객체, 컴포넌트 멤버 순으로 참조합니다.</p>\n<p>위에서 살펴본 예제에서도 이름이 충돌하는 경우가 있었습니다.\n컴포넌트에 <code>customer</code> 프로퍼티가 있지만 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>에서도 따로 템플릿 변수 <code>customer</code>를 선언했습니다.</p>\n<div class=\"alert is-helpful\">\n<p><code>{{customer.name}}</code>에 사용된 <code>customer</code>는 컴포넌트 프로퍼티가 아니라 템플릿 입력 변수를 가리킵니다.</p>\n<p>템플릿 표현식은 <code>undefined</code> 외에는 전역 네임스페이스에 있는 어떠한 것도 참조할 수 없습니다.\n그래서 <code>window</code>나 <code>document</code> 객체를 참조할 수 없으며, <code>console.log()</code>, <code>Math.max()</code>와 같은 함수도 사용할 수 없습니다.</p>\n</div>\n<!--\n## Expression guidelines\n-->\n<h2 id=\"표현식-가이드라인\">표현식 가이드라인<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/interpolation#표현식-가이드라인\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nWhen using template expressions follow these guidelines:\n\n* [Simplicity](guide/interpolation#simplicity)\n* [Quick execution](guide/interpolation#quick-execution)\n* [No visible side effects](guide/interpolation#no-visible-side-effects)\n-->\n<p>템플릿 표현식은 다음 가이드라인을 따라 작성하는 것을 권장합니다:</p>\n<ul>\n<li><a href=\"guide/interpolation#simplicity\">간결하게</a></li>\n<li><a href=\"guide/interpolation#quick-execution\">빠르게 실행되도록</a></li>\n<li><a href=\"guide/interpolation#no-visible-side-effects\">부수효과 최소화</a></li>\n</ul>\n<a id=\"simplicity\"></a>\n<!--\n### Simplicity\n-->\n<h3 id=\"간결하게\">간결하게<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/interpolation#간결하게\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAlthough it's possible to write complex template expressions, it's a better\npractice to avoid them.\n\nA property name or method call should be the norm, but an occasional Boolean negation, `!`, is OK.\nOtherwise, confine application and business logic to the component,\nwhere it is easier to develop and test.\n-->\n<p>템플릿 표현식에는 복잡한 로직도 작성할 수 있지만 이런 로직은 피하는 것이 좋습니다.</p>\n<p>프로퍼티 이름으로 참조하거나 메서드를 간단하게 실행하는 것이 가장 좋으며 불리언 반전 연산자 <code>!</code>를 사용하는 것까지도 괜찮습니다.\n이것보다 복잡한 애플리케이션 로직이나 비즈니스 로직은 컴포넌트에 작성해야 개발하기 편하고 테스트하기도 쉽습니다.</p>\n<a id=\"quick-execution\"></a>\n<!--\n### Quick execution\n-->\n<h3 id=\"빠르게-실행되도록\">빠르게 실행되도록<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/interpolation#빠르게-실행되도록\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAngular executes template expressions after every change detection cycle.\nChange detection cycles are triggered by many asynchronous activities such as\npromise resolutions, HTTP results, timer events, key presses and mouse moves.\n\nExpressions should finish quickly or the user experience may drag, especially on slower devices.\nConsider caching values when their computation is expensive.\n-->\n<p>템플릿 표현식은 Angular 변화 감지 싸이클이 실행될 때마다 실행됩니다.\n그리고 변화 감지 싸이클은 Promise 상태 변화, HTTP 응답, 타이머 이벤트, 키 이벤트, 마우스 이벤트가 발생할 때마다 계속 실행됩니다.</p>\n<p>그래서 템플릿 표현식은 최대한 빠르게 실행되어야 사용자가 불편함을 느끼지 않으며, 성능이 좋지 않은 장비일수록 더 중요합니다.\n연산이 오래 걸리는 로직은 캐싱하는 방법도 고려해 보세요.</p>\n<a id=\"no-visible-side-effects\"></a>\n<!--\n### No visible side effects\n-->\n<h3 id=\"부수효과-최소화\">부수효과 최소화<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/interpolation#부수효과-최소화\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nA template expression should not change any application state other than the value of the\ntarget property.\n\nThis rule is essential to Angular's \"unidirectional data flow\" policy.\nYou should never worry that reading a component value might change some other displayed value.\nThe view should be stable throughout a single rendering pass.\n\nAn [idempotent](https://en.wikipedia.org/wiki/Idempotence) expression is ideal because\nit is free of side effects and improves Angular's change detection performance.\nIn Angular terms, an idempotent expression always returns\n*exactly the same thing* until one of its dependent values changes.\n\nDependent values should not change during a single turn of the event loop.\nIf an idempotent expression returns a string or a number, it returns the same string or number when called twice in a row. If the expression returns an object, including an `array`, it returns the same object *reference* when called twice in a row.\n\n<div class=\"alert is-helpful\">\n\nThere is one exception to this behavior that applies to `*ngFor`. `*ngFor` has `trackBy` functionality that can deal with referential inequality of objects when iterating over them. See [`*ngFor` with `trackBy`](guide/built-in-directives#ngfor-with-trackby) for details.\n\n</div>\n-->\n<p>템플릿 표현식은 대상이 되는 프로퍼티 외에는 애플리케이션 상태를 변경하지 않는 것이 좋습니다.</p>\n<p>이 규칙은 Angular가 제안하는 \"단방향 데이터 흐름\" 정책 측면에서도 중요합니다.\n컴포넌트 값을 읽기만 했는데 다른 값이 변경되는 상황은 피해야 합니다.\n화면은 한 번 렌더링되는 동안 다른 상태로 변경되지 않아야 합니다.</p>\n<p>그래서 <a href=\"https://en.wikipedia.org/wiki/Idempotence\">멱등성(idempotent)</a>을 갖춘 표현식을 사용하는 것이 이상적입니다.\n왜냐하면 멱등성을 갖춘 표현식을 사용하면 부수효과를 발생시키지 않으며 Angular의 변화감지 성능도 끌어올릴 수 있기 때문입니다.\nAngular의 관점에서 설명하면, 멱등성을 갖춘 표현식은 표현식에 사용된 값이 변하지 않는 한 언제나 <em>같은 값</em>을 반환합니다.</p>\n<p>개별 변수의 값도 이벤트 루프가 한 번 실행되는 동안 변경되면 안됩니다.\n멱등성을 갖춘 표현식이 어떤 값을 반환한다면 이 표현식은 다시 실행되어도 같은 값을 반환해야 합니다.\n그리고 표현식이 객체(<code>array</code> 포함)를 반환한다면 다시 실행되어도 같은 객체를 <em>참조</em>해야 합니다.</p>\n<div class=\"alert is-helpful\">\n<p>이 규칙의 예외가 되는 경우는 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>를 사용할때 뿐입니다.\n<code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>는 순회하는 객체가 변경되는 것을 감지하기 위해 <code>trackBy</code> 옵션을 제공합니다.\n자세한 내용은 <a href=\"guide/built-in-directives#ngfor-with-trackby\"><code>*ngFor</code>에 <code>trackBy</code> 사용하기</a> 문서를 참고하세요.</p>\n</div>\n\n</div>\n\n<!-- links to this doc:\n - guide/ajs-quick-reference\n - guide/built-in-directives\n - guide/displaying-data\n - guide/event-binding\n - guide/glossary\n - guide/structural-directives\n - guide/template-syntax\n - guide/user-input\n - tutorial/toh-pt5\n-->\n<!-- links from this doc:\n - api/common/NgForOf\n - api/core/Component#interpolation\n - api/core/Type\n - guide/built-in-directives#ngfor-with-trackby\n - guide/interpolation#no-visible-side-effects\n - guide/interpolation#quick-execution\n - guide/interpolation#simplicity\n - guide/interpolation#간결하게\n - guide/interpolation#문자열-바인딩-\n - guide/interpolation#문자열-바인딩과-템플릿-표현식\n - guide/interpolation#부수효과-최소화\n - guide/interpolation#빠르게-실행되도록\n - guide/interpolation#템플릿-표현식\n - guide/interpolation#표현식-가이드라인\n - guide/interpolation#표현식의-컨텍스트\n - guide/template-expression-operators\n - https://en.wikipedia.org/wiki/Idempotence\n - https://github.com/angular/angular/edit/master/aio/content/guide/interpolation.md?message=docs%3A%20describe%20your%20change...\n-->"
}