{
  "id": "guide/lifecycle-hooks",
  "title": "컴포넌트 라이프싸이클 후킹",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/lifecycle-hooks.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Hooking into the component lifecycle\n-->\n<h1 id=\"컴포넌트-라이프싸이클-후킹\">컴포넌트 라이프싸이클 후킹<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#컴포넌트-라이프싸이클-후킹\"><i class=\"material-icons\">link</i></a></h1>\n<!--\nA component instance has a lifecycle that starts when Angular instantiates the component class and renders the component view along with its child views.\nThe lifecycle continues with change detection, as Angular checks to see when data-bound properties change, and updates both the view and the component instance as needed.\nThe lifecycle ends when Angular destroys the component instance and removes its rendered template from the DOM.\nDirectives have a similar lifecycle, as Angular creates, updates, and destroys instances in the course of execution.\n\nYour application can use [lifecycle hook methods](guide/glossary#lifecycle-hook \"Definition of lifecycle hook\") to tap into key events in the lifecycle of a component or directive in order to initialize new instances, initiate change detection when needed, respond to updates during change detection, and clean up before deletion of instances.\n-->\n<p>컴포넌트 인스턴스는 Angular가 컴포넌트 클래스의 인스턴스를 생성한 시점부터 미리 정의된 라이프싸이클을 따라 동작하며 라이프싸이클 단계에 따라 화면에 렌더링되고 자식 컴포넌트를 화면에 추가합니다.\n그리고 컴포넌트가 동작하는 동안 프로퍼티로 바인딩된 데이터가 변경되었는지 감지하며, 값이 변경되면 화면과 컴포넌트 인스턴스에 있는 데이터를 갱신하기도 합니다.\n라이프싸이클은 Angular가 컴포넌트 인스턴스를 종료하고 DOM에서 템플릿을 제거할 때까지 이어집니다.\n그리고 디렉티브도 컴포넌트와 비슷하게 Angular가 인스턴스를 생성하고 갱신하며 종료하는 라이프싸이클을 따릅니다.</p>\n<p>애플리케이션에서 <a href=\"guide/glossary#lifecycle-hook\" title=\"Definition of lifecycle hook\">라이프싸이클 후킹 메서드(lifecycle hook method)</a>를 사용하면 컴포넌트나 디렉티브가 동작하는 라이프싸이클에 개입할 수 있습니다.\n그래서 인스턴스가 생성되는 시점, 데이터 변화가 감지되는 시점, 데이터 변화가 감지된 이후 시점, 인스턴스가 종료되는 시점에 원하는 동작을 할 수 있습니다.</p>\n<!--\n## Prerequisites\n-->\n<h2 id=\"사전지식\">사전지식<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#사전지식\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nBefore working with lifecycle hooks, you should have a basic understanding of the following:\n\n* [TypeScript programming](https://www.typescriptlang.org/).\n* Angular app-design fundamentals, as described in [Angular Concepts](guide/architecture \"Introduction to fundamental app-design concepts\").\n-->\n<p>라이프싸이클에 대해 알아보기 전에 다음 내용을 먼저 이해하는 것이 좋습니다:</p>\n<ul>\n<li><a href=\"https://www.typescriptlang.org/\">TypeScript 문법</a></li>\n<li>Angular 앱의 구조, <a href=\"guide/architecture\" title=\"Introduction to fundamental app-design concepts\">Angular 개요</a> 문서를 참고하세요.</li>\n</ul>\n<a id=\"hooks-overview\"></a>\n<!--\n## Responding to lifecycle events\n-->\n<h2 id=\"라이프싸이클-이벤트에-반응하기\">라이프싸이클 이벤트에 반응하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#라이프싸이클-이벤트에-반응하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nYou can respond to events in the lifecycle of a component or directive by implementing one or more of the *lifecycle hook* interfaces in the Angular `core` library.\nThe hooks give you the opportunity to act on a component or directive instance at the appropriate moment, as Angular creates, updates, or destroys that instance.\n\nEach interface defines the prototype for a single hook method, whose name is the interface name prefixed with `ng`.\nFor example, the `OnInit` interface has a hook method named `ngOnInit()`. If you implement this method in your component or directive class, Angular calls it shortly after checking the input properties for that component or directive for the first time.\n\n<code-example path=\"lifecycle-hooks/src/app/peek-a-boo.component.ts\" region=\"ngOnInit\" header=\"peek-a-boo.component.ts (excerpt)\">\n@Directive()\nexport class PeekABooDirective implements OnInit {\n  constructor(private logger: LoggerService) { }\n\n  // OnInit 인터페이스에서 정의하는 `ngOnInit` 메소드를 구현합니다.\n  ngOnInit() { this.logIt(`OnInit`); }\n\n  logIt(msg: string) {\n    this.logger.log(`#${nextId++} ${msg}`);\n  }\n}\n\n</code-example>\n\nYou don't have to implement all (or any) of the lifecycle hooks, just the ones you need.\n-->\n<p>Angular <code>core</code> 라이브러리의 <em>라이프싸이클 훅</em> 인터페이스에 정의된 메서드를 컴포넌트나 디렉티브 클래스에 구현하면 해당 라이프싸이클에 반응할 수 있습니다.\n그래서 Angular가 컴포넌트나 디렉티브 인스턴스를 초기화하고, 갱신하며, 종료하는 시점에 원하는 동작을 실행할 수 있습니다.</p>\n<p>각 인터페이스에는 라이프싸이클 후킹 메서드가 하나씩 정의되어 있으며, 이 메서드의 이름은 인터페이스 이름에 <code>ng</code> 접두사를 붙인 형태입니다.\n<code><a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a></code> 인터페이스에는 <code>ngOnInit()</code> 메서드가 정의되어 있는 식입니다.\n<code>ngOnInit()</code> 메서드를 컴포넌트나 디렉티브 클래스에 정의하면 Angular가 입력 프로퍼티를 검사한 직후에 실행되기 때문에 인스턴스 초기화 로직을 작성할 수 있습니다.</p>\n<code-example path=\"lifecycle-hooks/src/app/peek-a-boo.component.ts\" region=\"ngOnInit\" header=\"peek-a-boo.component.ts (일부)\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()\nexport class PeekABooDirective implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  constructor(private logger: LoggerService) { }\n\n  // <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> 인터페이스에서 정의하는 `ngOnInit` 메소드를 구현합니다.\n  ngOnInit() { this.logIt(`<a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>`); }\n\n  logIt(msg: string) {\n    this.logger.log(`#${nextId++} ${msg}`);\n  }\n}\n\n</code-example>\n<p>라이프싸이클 후킹 함수를 전부 구현할 필요는 없습니다.\n필요한 것만 구현해서 사용하면 됩니다.</p>\n<a id=\"hooks-purpose-timing\"></a>\n<!--\n### Lifecycle event sequence\n-->\n<h3 id=\"라이프싸이클-이벤트-순서\">라이프싸이클 이벤트 순서<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#라이프싸이클-이벤트-순서\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAfter your application instantiates a component or directive by calling its constructor, Angular calls the hook methods you have implemented at the appropriate point in the lifecycle of that instance.\n\nAngular executes hook methods in the following sequence. You can use them to perform the following kinds of operations.\n-->\n<p>애플리케이션이 컴포넌트나 디렉티브 클래스의 생성자를 실행하면서 인스턴스를 초기화하고 나면 정해진 시점에 라이프싸이클 메서드가 실행됩니다.</p>\n<table width=\"100%\">\n  <colgroup><col width=\"20%\">\n  <col width=\"60%\">\n  <col width=\"20%\">\n  </colgroup><tbody><tr>\n    <!--\n    <th>Hook method</th>\n    <th>Purpose</th>\n    <th>Timing</th>\n    -->\n    <th>후킹 메서드</th>\n    <th>용도</th>\n    <th>실행 시점</th>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngOnChanges()</code>\n    </td>\n    <td>\n      <!--\n      Respond when Angular sets or resets data-bound input properties.\n      The method receives a `SimpleChanges` object of current and previous property values.\n\n      Note that this happens very frequently, so any operation you perform here impacts performance significantly.\n      See details in [Using change detection hooks](#onchanges) in this document.\n      -->\n<p>      바인딩된 입력 프로퍼티 값이 처음 설정되거나 변경될 때 실행됩니다.\n이 메서드는 프로퍼티의 이전 값과 현재 값을 표현하는 <code><a href=\"api/core/SimpleChanges\" class=\"code-anchor\">SimpleChanges</a></code> 객체를 인자로 받습니다.</p>\n<p>      이 메서드는 매우 자주 실행됩니다.\n그래서 이 메서드에 복잡한 로직을 작성하면 애플리케이션 성능이 크게 저하될 수 있습니다.\n자세한 내용은 <a href=\"guide/lifecycle-hooks#onchanges\">변화 감지 후킹 함수 활용하기</a> 섹션을 참고하세요.</p>\n    </td>\n    <td>\n      <!--\n      Called before `ngOnInit()` and whenever one or more data-bound input properties change.\n\n      Note that if your component has no inputs or you use it without providing any inputs, the framework will not call `ngOnChanges()`.\n      -->\n<p>      <code>ngOnInit()</code>이 실행되기 전에 한 번 실행되며 입력 프로퍼티로 바인딩된 값이 변경될 때마다 실행됩니다.</p>\n<p>      컴포넌트에 입력 프로퍼티가 없거나, 선언하고 사용하지 않는다면 <code>ngOnChanges()</code>가 실행되지 않습니다.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngOnInit()</code>\n    </td>\n    <td>\n      <!--\n      Initialize the directive or component after Angular first displays the data-bound properties\n      and sets the directive or component's input properties.\n      See details in [Initializing a component or directive](#oninit) in this document.\n      -->\n<p>      디렉티브나 컴포넌트에 바인딩된 입력 프로퍼티 값이 처음 할당된 후에 실행됩니다.\n자세한 내용은 <a href=\"guide/lifecycle-hooks#oninit\">컴포넌트, 디렉티브 초기화하기</a> 섹션을 참고하세요.</p>\n    </td>\n    <td>\n      <!--\n      Called once, after the first `ngOnChanges()`.\n      -->\n<p>      <code>ngOnChanges()</code>가 처음 실행된 후에 한 번 실행됩니다.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngDoCheck()</code>\n    </td>\n    <td>\n      <!--\n      Detect and act upon changes that Angular can't or won't detect on its own.\n      See details and example in [Defining custom change detection](#docheck) in this document.\n      -->\n<p>      Angular가 검출하지 못한 변화에 반응하거나, Angular가 변화를 감지하지 못하게 할 때 사용합니다.\n자세한 내용은 <a href=\"guide/lifecycle-hooks#docheck\">커스텀 변화감지 로직 정의하기</a> 섹션을 참고하세요.</p>\n    </td>\n    <td>\n      <!--\n      Called immediately after `ngOnChanges()` on every change detection run, and immediately after `ngOnInit()` on the first run.\n      -->\n<p>      <code>ngOnInit()</code>이 실행된 직후에 한 번 실행되며, 변화 감지 싸이클이 실행되면서 <code>ngOnChanges()</code>가 실행된 이후에 매번 실행됩니다.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngAfterContentInit()</code>\n    </td>\n    <td>\n      <!--\n      Respond after Angular projects external content into the component's view, or into the view that a directive is in.\n\n      See details and example in [Responding to changes in content](#aftercontent) in this document.\n      -->\n<p>      Angular가 외부 컨텐츠를 컴포넌트나 디렉티브 뷰에 프로젝션한 이후에 실행됩니다.</p>\n<p>      자세한 내용은 <a href=\"guide/lifecycle-hooks#aftercontent\">외부 컨텐츠 변경사항 감지하기</a> 섹션을 참고하세요.</p>\n    </td>\n    <td>\n      <!--\n      Called _once_ after the first `ngDoCheck()`.\n      -->\n<p>      <code>ngDoCheck()</code>가 처음 실행된 후 <em>한 번</em> 실행됩니다.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngAfterContentChecked()</code>\n    </td>\n    <td>\n      <!--\n      Respond after Angular checks the content projected into the directive or component.\n\n      See details and example in [Responding to projected content changes](#aftercontent) in this document.\n      -->\n<p>      Angular가 디렉티브나 컴포넌트에 프로젝션된 컨텐츠를 검사하고 난 후에 실행됩니다.</p>\n<p>      자세한 내용은 <a href=\"guide/lifecycle-hooks#aftercontent\">외부 컨텐츠 변경사항 감지하기</a> 섹션을 참고하세요.</p>\n    </td>\n    <td>\n      <!--\n      Called after `ngAfterContentInit()` and every subsequent `ngDoCheck()`.\n      -->\n<p>      <code>ngAfterContentInit()</code>이 실행된 후, <code>ngDoCheck()</code>가 실행된 이후마다 실행됩니다.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngAfterViewInit()</code>\n    </td>\n    <td>\n      <!--\n      Respond after Angular initializes the component's views and child views, or the view that contains the directive.\n\n      See details and example in [Responding to view changes](#afterview) in this document.\n      -->\n<p>      Angular가 컴포넌트나 디렉티브 화면과 자식 컴포넌트 화면을 초기화한 후에 실행됩니다.</p>\n<p>      자세한 내용은 <a href=\"guide/lifecycle-hooks#afterview\">화면 변경사항 감지하기</a> 섹션을 참고하세요.</p>\n    </td>\n    <td>\n      <!--\n      Called _once_ after the first `ngAfterContentChecked()`.\n      -->\n<p>      <code>ngAfterContentChecked()</code>가 처음 실행된 후에 <em>한 번</em> 실행됩니다.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngAfterViewChecked()</code>\n    </td>\n    <td>\n      <!--\n      Respond after Angular checks the component's views and child views, or the view that contains the directive.\n      -->\n<p>      Angular가 컴포넌트나 디렉티브 화면과 자식 화면을 검사한 후에 실행됩니다.</p>\n    </td>\n    <td>\n      <!--\n      Called after the `ngAfterViewInit()` and every subsequent `ngAfterContentChecked()`.\n      -->\n<p>      <code>ngAfterViewInit()</code>가 실행된 후, <code>ngAfterContentChecked()</code>가 실행된 이후마다 실행됩니다.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngOnDestroy()</code>\n    </td>\n    <td>\n      <!--\n      Cleanup just before Angular destroys the directive or component.\n      Unsubscribe Observables and detach event handlers to avoid memory leaks.\n      See details in [Cleaning up on instance destruction](#ondestroy) in this document.\n      -->\n<p>      Angular가 디렉티브나 컴포넌트 인스턴스를 종료하기 전에 실행됩니다.\n이 메서드는 옵저버블을 구독 해지하거나 이벤트 핸들러를 제거하는 등 메모리 누수를 방지하는 로직을 작성하는 용도로 사용합니다.\n자세한 내용은 <a href=\"guide/lifecycle-hooks#ondestroy\">인스턴스 종료하기</a> 섹션을 참고하세요.</p>\n    </td>\n    <td>\n      <!--\n      Called immediately before Angular destroys the directive or component.\n      -->\n<p>      Angular가 디렉티브나 컴포넌트 인스턴스를 종료하기 직전에 실행됩니다.</p>\n    </td>\n  </tr>\n</tbody></table>\n<a id=\"the-sample\"></a>\n<!--\n### Lifecycle example set\n-->\n<h3 id=\"라이프싸이클-활용-예제\">라이프싸이클 활용 예제<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#라이프싸이클-활용-예제\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe <live-example></live-example>\ndemonstrates the use of lifecycle hooks through a series of exercises\npresented as components under the control of the root `AppComponent`.\nIn each case a *parent* component serves as a test rig for\na *child* component that illustrates one or more of the lifecycle hook methods.\n\nThe following table lists the exercises with brief descriptions.\nThe sample code is also used to illustrate specific tasks in the following sections.\n-->\n<p><live-example></live-example>에서 최상위 컴포넌트 <code>AppComponent</code> 안에 있는 컴포넌트들을 보면 라이프싸이클 후킹 함수를 어떻게 활용하는지 확인할 수 있습니다.\n이 예제 프로젝트에서 <code>AppComponent</code>는 모든 자식 컴포넌트의 테스트 베드로 동작하며 자식 컴포넌트는 개별 라이프싸이클 후킹 메서드를 다룹니다.</p>\n<p>예제 프로젝트에서 어떤 내용을 다루는지 간단하게 살펴봅시다.\n개별 항목에 대해서는 이 문서를 진행하면서 계속 알아봅니다.</p>\n<table width=\"100%\">\n  <colgroup><col width=\"20%\">\n  <col width=\"80%\">\n  </colgroup><tbody><tr>\n    <!--\n    <th>Component</th>\n    <th>Description</th>\n    -->\n    <th>컴포넌트</th>\n    <th>설명</th>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <a href=\"guide/lifecycle-hooks#peek-a-boo\">Peek-a-boo</a>\n    </td>\n    <td>\n      <!--\n      Demonstrates every lifecycle hook.\n      Each hook method writes to the on-screen log.\n      -->\n<p>      전체 라이프싸이클 후킹 메서드가 어떻게 동작하는지 보여줍니다.\n개별 후킹 메서드가 실행되는 것을 화면에서 확인할 수 있습니다.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <a href=\"guide/lifecycle-hooks#spy\">Spy</a>\n    </td>\n    <td>\n      <!--\n      Shows how you can use lifecycle hooks with a custom directive.\n      The `SpyDirective` implements the `ngOnInit()` and `ngOnDestroy()` hooks,\n      and uses them to watch and report when an element goes in or out of the current view.\n      -->\n<p>      커스텀 디렉티브로 라이프싸이클 후킹 메서드를 활용하는 방법에 대해 다룹니다.\n<code>SpyDirective</code>에는 <code>ngOnInit()</code>과 <code>ngOnDestroy()</code> 후킹 메서드가 정의되어 있으며, 이 디렉티브를 사용해서 엘리먼트가 화면에 추가되고 제거되는 것을 확인할 수 있습니다.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <a href=\"guide/lifecycle-hooks#onchanges\">OnChanges</a>\n    </td>\n    <td>\n      <!--\n      Demonstrates how Angular calls the `ngOnChanges()` hook\n      every time one of the component input properties changes,\n      and shows how to interpret the `changes` object passed to the hook method.\n      -->\n<p>      컴포넌트의 입력 프로퍼티 값이 변경될 때 <code>ngOnChanges()</code>가 어떻게 실행되는지에 대해 다룹니다.\n후킹 메서드에 전달되는 <code>changes</code> 객체를 어떻게 활용할 수 있는지도 확인해 보세요.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <a href=\"guide/lifecycle-hooks#docheck\">DoCheck</a>\n    </td>\n    <td>\n      <!--\n      Implements the `ngDoCheck()` method with custom change detection.\n      Watch the hook post changes to a log to see how often Angular calls this hook.\n      -->\n<p>      <code>ngDoCheck()</code> 메서드로 커스텀 변화감지 로직을 구현하는 방법에 대해 다룹니다.\n<code>ngDoCheck()</code> 메서드가 얼마나 자주 실행되는지 화면에 표시되는 로그를 확인해 보세요.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <a href=\"guide/lifecycle-hooks#afterview\">AfterView</a>\n    </td>\n    <td>\n      <!--\n      Shows what Angular means by a [view](guide/glossary#view \"Definition of view.\").\n      Demonstrates the `ngAfterViewInit()` and `ngAfterViewChecked()` hooks.\n      -->\n<p>      Angular에서 의미하는 <a href=\"guide/glossary#view\" title=\"Definition of view.\">화면(view)</a>이 무엇인지에 대해 다룹니다.\n<code>ngAfterViewInit()</code> 메서드와 <code>ngAfterViewChecked()</code> 메서드에 대해 다룹니다.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <a href=\"guide/lifecycle-hooks#aftercontent\">AfterContent</a>\n    </td>\n    <td>\n      <!--\n      Shows how to project external content into a component and\n      how to distinguish projected content from a component's view children.\n      Demonstrates the `ngAfterContentInit()` and `ngAfterContentChecked()` hooks.\n      -->\n<p>      외부 컨텐츠를 컴포넌트에 프로젝션하는 것에 대해 다룹니다.\n컴포넌트 자식 뷰와 프로젝션된 컨텐츠를 구분하는 방법도 설명하며, <code>ngAfterContentInit()</code> 메서드와 <code>ngAfterContentChecked()</code> 메서드에 대해 다룹니다.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n       <a href=\"guide/lifecycle-hooks#counter\">Counter</a>\n    </td>\n    <td>\n      <!--\n      Demonstrates a combination of a component and a directive, each with its own hooks.\n      -->\n<p>      컴포넌트와 디렉티브를 함께 사용할 때 라이프싸이클 후킹 함수를 각각 어떻게 적용하는지 알아봅니다.</p>\n    </td>\n  </tr>\n</tbody></table>\n<a id=\"oninit\"></a>\n<!--\n## Initializing a component or directive\n-->\n<h2 id=\"컴포넌트-디렉티브-초기화하기\">컴포넌트, 디렉티브 초기화하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#컴포넌트-디렉티브-초기화하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nUse the `ngOnInit()` method to perform the following initialization tasks.\n\n* Perform complex initializations outside of the constructor.\n  Components should be cheap and safe to construct.\n  You should not, for example, fetch data in a component constructor.\n  You shouldn't worry that a new component will try to contact a remote server when\n  created under test or before you decide to display it.\n\n  An `ngOnInit()` is a good place for a component to fetch its initial data.\n  For an example, see the [Tour of Heroes tutorial](tutorial/toh-pt4#oninit).\n\n\n* Set up the component after Angular sets the input properties.\n  Constructors should do no more than set the initial local variables to simple values.\n\n  Keep in mind that a directive's data-bound input properties are not set until _after construction_.\n  If you need to initialize the directive based on those properties, set them when `ngOnInit()` runs.\n\n  <div class=\"alert is-helpful\">\n\n     The `ngOnChanges()` method is your first opportunity to access those properties.\n     Angular calls `ngOnChanges()` before `ngOnInit()`, but also many times after that.\n     It only calls `ngOnInit()` once.\n\n  </div>\n-->\n<p><code>ngOnInit()</code> 메서드를 활용하면 다음과 같은 초기화 작업을 실행할 수 있습니다.</p>\n<ul>\n<li>\n<p>일반적으로 컴포넌트는 가볍고 간단하게 생성할 수 있어야 합니다.\n그래서 초기화 로직이 복잡하다면 이 로직은 생성자에 작성하지 않는 것이 좋습니다.\n외부에서 데이터를 받아와야 하는 로직도 마찬가지입니다.\n이런 로직이 생성자에 있으면 테스트 환경에서 컴포넌트를 생성하거나 화면에 컴포넌트가 표시되기 전에도 외부로 HTTP 요청이 발생할 수 있습니다.</p>\n<p>데이터를 외부에서 받아오고 컴포넌트를 초기화하는 로직은 <code>ngOnInit()</code>에 작성하는 것이 좋습니다.\n<a href=\"tutorial/toh-pt4#oninit\">히어로들의 여행 튜토리얼</a>에서도 이 내용을 확인할 수 있습니다.</p>\n<div class=\"alert is-helpful\">\n<p>Angular 팀 리더인 Misko Hevery가 설명하는 <a href=\"http://misko.hevery.com/code-reviewers-guide/flaw-constructor-does-real-work/\">한계: 생성자가 실제로 동작하는 방식</a>를 확인해 보세요. 생성자에 복잡한 로직을 사용하지 말아야 하는 이유에 대해 설명합니다.</p>\n</div>\n</li>\n<li>\n<p>Angular가 입력 프로퍼티 값을 할당한 후에 컴포넌트 초기화 작업을 할 수 있습니다.\n생성자에서는 지역 변수를 할당하는 것 이외의 로직은 작성하지 않는 것이 좋습니다.</p>\n<p>디렉티브에 바인딩되는 입력 프로퍼티 값은 <em>생성자가 실행된 후에</em> 할당된다는 것을 명심하세요.\n이 프로퍼티 값에 따라 디렉티브를 초기화해야 한다면 생성자가 아니라 <code>ngOnInit()</code>에서 해야 합니다.</p>\n<div class=\"alert is-helpful\">\n<p>   입력 프로퍼티에 데이터가 전달되는 것을 가장 먼저 확인할 수 있는 메서드는 <code>ngOnChanges())</code> 메서드입니다.\n하지만 <code>ngOnChanges()</code>는 <code>ngOnInit()</code> 이전뿐 아니라 그 이후에도 여러번 실행됩니다.\n<code>ngOnInit()</code>은 한번만 실행되기 때문에 초기화 로직은 이 메서드에 작성하는 것이 좋습니다.</p>\n</div>\n</li>\n</ul>\n<a id=\"ondestroy\"></a>\n<!--\n## Cleaning up on instance destruction\n-->\n<h2 id=\"인스턴스-종료하기\">인스턴스 종료하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#인스턴스-종료하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nPut cleanup logic in `ngOnDestroy()`, the logic that must run before Angular destroys the directive.\n\nThis is the place to free resources that won't be garbage-collected automatically.\nYou risk memory leaks if you neglect to do so.\n\n* Unsubscribe from Observables and DOM events.\n* Stop interval timers.\n* Unregister all callbacks that the directive registered with global or application services.\n\nThe `ngOnDestroy()` method is also the time to notify another part of the application that the component is going away.\n-->\n<p>Angular가 디렉티브나 컴포넌트를 종료하기 전에 실행해야 하는 로직이 있다면 이 로직은 <code>ngOnDestroy()</code>에 작성합니다.</p>\n<p>그래서 자동으로 메모리 정리되지 않는 항목이 있다면 이 메서드에서 정리하면 됩니다.\n이런 용도로 활용할 수 있습니다.</p>\n<ul>\n<li>옵저버블이나 DOM 이벤트 구독 해지</li>\n<li>인터벌 타이머 중단</li>\n<li>디렉티브가 전역이나 애플리케이션 서비스에 등록한 콜백 정리</li>\n</ul>\n<p><code>ngOnDestroy()</code> 메서드는 컴포넌트나 디렉티브가 종료된다는 것을 애플리케이션 다른 영역으로 전달하는 용도로도 사용할 수 있습니다.</p>\n<!--\n## General examples\n-->\n<h2 id=\"활용-예제\">활용 예제<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#활용-예제\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe following examples demonstrate the call sequence and relative frequency of the various lifecycle events, and how the hooks can be used separately or together for components and directives.\n-->\n<p>라이프싸이클 이벤트가 얼마나 자주 발생하는지, 어떻게 활용할 수 있는지 예제를 보며 확인해 봅시다.</p>\n<a id=\"peek-a-boo\"></a>\n<!--\n### Sequence and frequency of all lifecycle events\n-->\n<h3 id=\"라이프싸이클-이벤트-발생-순서-빈도\">라이프싸이클 이벤트 발생 순서, 빈도<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#라이프싸이클-이벤트-발생-순서-빈도\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nTo show how Angular calls the hooks in the expected order, the `PeekABooComponent` demonstrates all of the hooks in one component.\n\nIn practice you would rarely, if ever, implement all of the interfaces the way this demo does.\n\nThe following snapshot reflects the state of the log after the user clicked the *Create...* button and then the *Destroy...* button.\n\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/lifecycle-hooks/peek-a-boo.png\" alt=\"Peek-a-boo\">\n</div>\n\nThe sequence of log messages follows the prescribed hook calling order:\n`OnChanges`, `OnInit`, `DoCheck`&nbsp;(3x), `AfterContentInit`, `AfterContentChecked`&nbsp;(3x),\n`AfterViewInit`, `AfterViewChecked`&nbsp;(3x), and `OnDestroy`.\n\n<div class=\"alert is-helpful\">\n\n  Notice that the log confirms that input properties (the `name` property in this case) have no assigned values at construction.\n  The input properties are available to the `onInit()` method for further initialization.\n\n</div>\n\nHad the user clicked the *Update Hero* button, the log would show another `OnChanges` and two more triplets of `DoCheck`, `AfterContentChecked` and `AfterViewChecked`.\nNotice that these three hooks fire *often*, so it is important to keep their logic as lean as possible.\n-->\n<p>Angular가 라이프싸이클 후킹 메서드를 어떤 순서로 실행하는지 확인하려면 <code>PeekABooComponent</code>를 확인하면 됩니다.</p>\n<p>물론 실제 앱에서 이 컴포넌트처럼 모든 라이프싸이클 메서드를 정의할 일은 거의 없으며, 데모를 위해 구현한 것입니다.</p>\n<p>이 컴포넌트에서 <em>Create...</em> 버튼을 누른 후에 <em>Destroy...</em> 버튼을 누르면 다음과 같은 로그가 화면에 표시됩니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/lifecycle-hooks/peek-a-boo.png\" alt=\"Peek-a-boo\" width=\"309\" height=\"366\">\n</div>\n<p>라이프싸이클 후킹 메서드가 실행된 순서는 이렇습니다:\n<code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a></code>, <code><a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a></code>, <code><a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a></code> (3번), <code><a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a></code>, <code><a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a></code> (3번),\n<code><a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a></code>, <code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a></code> (3번), <code><a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a></code>.</p>\n<div class=\"alert is-helpful\">\n<p>  입력 프로퍼티(예제에서는 <code>name</code> 프로퍼티)의 값은 생성자가 실행되는 시점에 할당되지 않았다는 것에 주의하세요.\n그래서 입력 프로퍼티를 활용해서 컴포넌트를 초기화하는 로직은 <code>onInit()</code> 메서드 안에 작성해야 합니다.</p>\n</div>\n<p>그리고 <em>Update Hero</em> 버튼을 누르면 <code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a></code> 로그와 함께 <code><a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a></code>, <code><a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a></code>, <code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a></code> 로그도 함께 출력됩니다.\n이 인터페이스로 구현하는 라이프싸이클 후킹 메서드는 <em>자주</em> 실행됩니다.\n이 메서드에는 간단한 로직만 작성하는 것이 좋습니다.</p>\n<a id=\"spy\"></a>\n<!--\n### Use directives to watch the DOM\n-->\n<h3 id=\"dom을-추적하는-디렉티브\">DOM을 추적하는 디렉티브<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#dom을-추적하는-디렉티브\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe `Spy` example demonstrates how you can use hook method for directives as well as components.\nThe `SpyDirective` implements two hooks, `ngOnInit()` and `ngOnDestroy()`, in order to discover when a watched element is in the current view.\n\nThis template applies the `SpyDirective` to a `<div>` in the `ngFor` *hero* repeater managed by the parent `SpyComponent`.\n\nThe example does not perform any initialization or clean-up.\nIt just tracks the appearance and disappearance of an element in the view by recording when the directive itself is instantiated and destroyed.\n\nA spy directive like this can provide insight into a DOM object that you cannot change directly.\nYou can't touch the implementation of a native `<div>`, or modify a third party component.\nYou can, however watch these elements with a directive.\n\nThe directive defines `ngOnInit()` and `ngOnDestroy()` hooks\nthat log messages to the parent via an injected `LoggerService`.\n\n<code-example path=\"lifecycle-hooks/src/app/spy.directive.ts\" region=\"spy-directive\" header=\"src/app/spy.directive.ts\">\n// 엘리먼트에 스파이 디렉티브를 자유롭게 적용합니다.\n// 사용방법: &lt;div appSpy&gt;...&lt;/div&gt;\n@Directive({selector: &#39;[appSpy]&#39;})\nexport class SpyDirective implements OnInit, OnDestroy {\n\n  constructor(private logger: LoggerService) { }\n\n  ngOnInit()    { this.logIt(`onInit`); }\n\n  ngOnDestroy() { this.logIt(`onDestroy`); }\n\n  private logIt(msg: string) {\n    this.logger.log(`Spy #${nextId++} ${msg}`);\n  }\n}\n\n</code-example>\n\nYou can apply the spy to any native or component element, and see that it is initialized and destroyed\nat the same time as that element.\nHere it is attached to the repeated hero `<div>`:\n\n<code-example path=\"lifecycle-hooks/src/app/spy.component.html\" region=\"template\" header=\"src/app/spy.component.html\">\n&lt;div *ngFor=&quot;let hero of heroes&quot; appSpy class=&quot;heroes&quot;&gt;\n  {{hero}}\n&lt;/div&gt;\n\n</code-example>\n\nEach spy's creation and destruction marks the appearance and disappearance of the attached hero `<div>`\nwith an entry in the *Hook Log* as seen here:\n\n<div class=\"lightbox\">\n  <img src='generated/images/guide/lifecycle-hooks/spy-directive.gif' alt=\"Spy Directive\">\n</div>\n\nAdding a hero results in a new hero `<div>`. The spy's `ngOnInit()` logs that event.\n\nThe *Reset* button clears the `heroes` list.\nAngular removes all hero `<div>` elements from the DOM and destroys their spy directives at the same time.\nThe spy's `ngOnDestroy()` method reports its last moments.\n-->\n<p><code>Spy</code> 예제를 보면 디렉티브에 라이프싸이클 메서드를 정의해서 컴포넌트처럼 사용하는 방법을 확인할 수 있습니다.\n<code>SpyDirective</code>에는 엘리먼트가 화면에 표시되는 시점을 확인하기 위해 <code>ngOnInit()</code>, <code>ngOnDestroy()</code> 메서드를 구현했습니다.</p>\n<p>그리고 부모 컴포넌트 <code>SpyComponent</code> 템플릿의 <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 안에서 반복하는 <code>&#x3C;div></code>에 <code>SpyDirective</code>를 적용했습니다.</p>\n<p>이번 예제에는 디렉티브를 초기화하거나 정리하는 로직이 없습니다.\n이 디렉티브는 단순하게 엘리먼트가 화면에 나타나고 사라지는 것을 추적하는 용도로만 활용합니다.</p>\n<p>스파이 디렉티브는 이렇게 개발자가 직접 조작할 수 없는 DOM 객체를 추적하는 용도로 활용할 수 있습니다.\n그래서 네이티브 <code>&#x3C;div></code> 엘리먼트의 구현 코드나 서드 파티 컴포넌트를 직접 수정하지 않아도 됩니다.</p>\n<p>이 디렉티브는 <code>ngOnInit()</code>, <code>ngOnDestroy()</code> 후킹 메서드가 실행될 때마다 <code>LoggerService</code>를 사용해서 로그 메시지를 출력합니다.</p>\n<code-example path=\"lifecycle-hooks/src/app/spy.directive.ts\" region=\"spy-directive\" header=\"src/app/spy.directive.ts\">\n// 엘리먼트에 스파이 디렉티브를 자유롭게 적용합니다.\n// 사용방법: &#x3C;div appSpy>...&#x3C;/div>\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({selector: '[appSpy]'})\nexport class SpyDirective implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>, <a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a> {\n\n  constructor(private logger: LoggerService) { }\n\n  ngOnInit()    { this.logIt(`onInit`); }\n\n  ngOnDestroy() { this.logIt(`onDestroy`); }\n\n  private logIt(msg: string) {\n    this.logger.log(`Spy #${nextId++} ${msg}`);\n  }\n}\n\n</code-example>\n<p>이 스파이 디렉티브는 네이티브 엘리먼트나 컴포넌트 엘리먼트에도 자유롭게 적용할 수 있으며, 동시에 여러 엘리먼트에 적용할 수도 있습니다.\n이렇게 사용하면 됩니다:</p>\n<code-example path=\"lifecycle-hooks/src/app/spy.component.html\" region=\"template\" header=\"src/app/spy.component.html\">\n&#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\" appSpy class=\"heroes\">\n  {{hero}}\n&#x3C;/div>\n\n</code-example>\n<p>히어로 목록이 변경되면서 <code>&#x3C;div></code> 엘리먼트가 화면에 나타나거나 제거되면 관련 로그가 다음과 같이 표시됩니다:</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/lifecycle-hooks/spy-directive.gif\" alt=\"Spy Directive\" width=\"656\" height=\"378\">\n</div>\n<p>새 히어로가 추가되면서 <code>&#x3C;div></code> 엘리먼트가 DOM에 추가되면 <code>ngOnInit()</code> 에 정의한 로그가 화면에 표시됩니다.</p>\n<p><em>Reset</em> 버튼을 눌러서 <code>heroes</code> 목록을 초기화 해보세요.\n그러면 Angular가 히어로와 관련된 <code>&#x3C;div></code> 엘리먼트를 모두 DOM에서 제거하면서 스파이 디렉티브도 종료됩니다.\n이 때 <code>ngOnDestroy()</code> 메서드에 정의한 로그가 화면에 표시됩니다.</p>\n<a id=\"counter\"></a>\n<!--\n### Use component and directive hooks together\n-->\n<h3 id=\"컴포넌트와-디렉티브에서-동시에-후킹하기\">컴포넌트와 디렉티브에서 동시에 후킹하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#컴포넌트와-디렉티브에서-동시에-후킹하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn this example, a `CounterComponent` uses the `ngOnChanges()` method to log a change every time the parent component increments its input `counter` property.\n\nThis example applies the `SpyDirective` from the previous example to the `CounterComponent` log, in order to watch the creation and destruction of log entries.\n-->\n<p>이 예제에서 <code>CounterComponent</code>는 <code>ngOnChanges()</code> 메서드를 사용해서 부모 컴포넌트에서 전달되는 <code>counter</code> 프로퍼티 값이 변경될 때마다 로그를 출력합니다.</p>\n<p>코드를 보면 <code>SpyDirective</code>가 <code>CounterComponent</code>에도 적용된 것을 확인할 수 있으며, 이 경우에도 <code>SpyDirective</code>가 출력하는 로그로 <code>CounterComponent</code>가 생성되고 종료되는 시점을 확인할 수 있습니다.</p>\n<a id=\"onchanges\"></a>\n<a id=\"using-change-detection-hooks\"></a>\n<!--\n## Using change detection hooks\n-->\n<h2 id=\"변화-감지-후킹-함수-활용하기\">변화 감지 후킹 함수 활용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#변화-감지-후킹-함수-활용하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAngular calls the `ngOnChanges()` method of a component or directive whenever it detects changes to the  ***input properties***.\nThe *onChanges* example demonstrates this by monitoring the `OnChanges()` hook.\n\n<code-example path=\"lifecycle-hooks/src/app/on-changes.component.ts\" region=\"ng-on-changes\" header=\"on-changes.component.ts (excerpt)\">\nngOnChanges(changes: SimpleChanges) {\n  for (const propName in changes) {\n    const chng = changes[propName];\n    const cur  = JSON.stringify(chng.currentValue);\n    const prev = JSON.stringify(chng.previousValue);\n    this.changeLog.push(`${propName}: currentValue = ${cur}, previousValue = ${prev}`);\n  }\n}\n\n</code-example>\n\nThe `ngOnChanges()` method takes an object that maps each changed property name to a\n[SimpleChange](api/core/SimpleChange) object holding the current and previous property values.\nThis hook iterates over the changed properties and logs them.\n\nThe example component, `OnChangesComponent`, has two input properties: `hero` and `power`.\n\n<code-example path=\"lifecycle-hooks/src/app/on-changes.component.ts\" region=\"inputs\" header=\"src/app/on-changes.component.ts\">\n@Input() hero: Hero;\n@Input() power: string;\n\n</code-example>\n\nThe host `OnChangesParentComponent` binds to them as follows.\n\n<code-example path=\"lifecycle-hooks/src/app/on-changes-parent.component.html\" region=\"on-changes\" header=\"src/app/on-changes-parent.component.html\">\n&lt;on-changes [hero]=&quot;hero&quot; [power]=&quot;power&quot;&gt;&lt;/on-changes&gt;\n\n</code-example>\n\nHere's the sample in action as the user makes changes.\n\n<div class=\"lightbox\">\n  <img src='generated/images/guide/lifecycle-hooks/on-changes-anim.gif' alt=\"OnChanges\">\n</div>\n\nThe log entries appear as the string value of the *power* property changes.\nNotice, however, that the `ngOnChanges()` method does not catch changes to `hero.name`.\nThis is because Angular calls the hook only when the value of the input property changes.\nIn this case, `hero` is the input property, and the value of the `hero` property is the *reference to the hero object*.\nThe object reference did not change when the value of its own `name` property changed.\n-->\n<p>컴포넌트나 디렉티브에 바인딩된 <strong><em>입력 프로퍼티</em></strong> 값이 변경된 것을 감지하면 Angular가 <code>ngOnChanges()</code> 메서드를 실행합니다.\n<code>ngOnChanges()</code> 함수에서 값이 어떻게 변경되었는지 확인하려면 다음과 같이 작성하면 됩니다.</p>\n<code-example path=\"lifecycle-hooks/src/app/on-changes.component.ts\" region=\"ng-on-changes\" header=\"on-changes.component.ts (일부)\">\nngOnChanges(changes: <a href=\"api/core/SimpleChanges\" class=\"code-anchor\">SimpleChanges</a>) {\n  for (const propName in changes) {\n    const chng = changes[propName];\n    const cur  = JSON.stringify(chng.currentValue);\n    const prev = JSON.stringify(chng.previousValue);\n    this.changeLog.push(`${propName}: currentValue = ${cur}, previousValue = ${prev}`);\n  }\n}\n\n</code-example>\n<p><code>ngOnChanges()</code> 메서드는 <a href=\"api/core/SimpleChange\">SimpleChange</a> 객체를 인자로 받는데, 이 객체에는 개별 입력 프로퍼티가 객체의 프로퍼티 이름으로 선언되어 이전값과 현재값을 전달합니다.\n그래서 객체 프로퍼티를 순회하면 어떤 값이 변경되었는지 확인할 수 있습니다.</p>\n<p>예제로 다루는 <code>OnChangesComponent</code>에는 입력 프로퍼티가 2개 있습니다: <code>hero</code>, <code>power</code>.</p>\n<code-example path=\"lifecycle-hooks/src/app/on-changes.component.ts\" region=\"inputs\" header=\"src/app/on-changes.component.ts\">\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() power: string;\n\n</code-example>\n<p>그리고 이 입력 프로퍼티들은 <code>OnChangesParentComponent</code>에서 이렇게 바인딩됩니다.</p>\n<code-example path=\"lifecycle-hooks/src/app/on-changes-parent.component.html\" region=\"on-changes\" header=\"src/app/on-changes-parent.component.html\">\n&#x3C;on-changes [hero]=\"hero\" [power]=\"power\">&#x3C;/on-changes>\n\n</code-example>\n<p>사용자가 입력 프로퍼티 값을 변경할 때 어떻게 동작하는지 확인해 보세요.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/lifecycle-hooks/on-changes-anim.gif\" alt=\"OnChanges\" width=\"632\" height=\"512\">\n</div>\n<p><em>power</em> 프로퍼티의 값이 변경될 때마다 로그가 출력됩니다.\n하지만 <code>hero.name</code> 프로퍼티가 변경된 것은 감지하지 못하며 <code>ngOnChanges()</code> 메서드도 실행되지 않는 것에 주의하세요.\n왜냐하면 Angular는 기본 상태에서 입력 프로퍼티 객체 자체가 변경된 것만 감지하기 때문입니다.\n이 경우에 입력 프로퍼티는 <code>hero</code>이며 <code>hero</code> 값은 <em>히어로 객체 참조</em>입니다.\n그래서 <code>hero</code> 안에 있는 <code>name</code> 프로퍼티 값이 변경되는 것은 감지하지 못합니다.</p>\n<a id=\"afterview\"></a>\n<!--\n### Responding to view changes\n-->\n<h3 id=\"화면-변경사항-감지하기\">화면 변경사항 감지하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#화면-변경사항-감지하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAs Angular traverses the [view hierarchy](guide/glossary#view-hierarchy \"Definition of view hierarchy definition\") during change detection, it needs to be sure that a change in a child does not attempt to cause a change in its own parent. Such a change would not be rendered properly, because of how [unidirectional data flow](guide/glossary#unidirectional-data-flow \"Definition\") works.\n\nIf you need to make a change that inverts the expected data flow, you must trigger a new change detection cycle to allow that change to be rendered.\nThe examples illustrate how to make such changes safely.\n\nThe *AfterView* sample explores the `AfterViewInit()` and `AfterViewChecked()` hooks that Angular calls\n*after* it creates a component's child views.\n\nHere's a child view that displays a hero's name in an `<input>`:\n\n<code-example path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"child-view\" header=\"ChildComponent\">\n@Component({\n  selector: &#39;app-child-view&#39;,\n  template: &#39;&lt;input [(ngModel)]=&quot;hero&quot;&gt;&#39;\n})\nexport class ChildViewComponent {\n  hero = &#39;Magneta&#39;;\n}\n\n</code-example>\n\nThe `AfterViewComponent` displays this child view *within its template*:\n\n<code-example path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"template\" header=\"AfterViewComponent (template)\">\ntemplate: `\n  &lt;div&gt;-- child view begins --&lt;/div&gt;\n    &lt;app-child-view&gt;&lt;/app-child-view&gt;\n  &lt;div&gt;-- child view ends --&lt;/div&gt;`\n\n</code-example>\n\nThe following hooks take action based on changing values *within the child view*,\nwhich can only be reached by querying for the child view via the property decorated with\n[@ViewChild](api/core/ViewChild).\n\n<code-example path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"hooks\" header=\"AfterViewComponent (class excerpts)\">\nexport class AfterViewComponent implements  AfterViewChecked, AfterViewInit {\n  private prevHero = &#39;&#39;;\n\n  // `ChildViewComponent` 타입의 뷰 자식 컴포넌트를 참조합니다.\n  @ViewChild(ChildViewComponent) viewChild: ChildViewComponent;\n\n  ngAfterViewInit() {\n    // viewChild는 뷰가 모두 초기화된 이후에 값이 할당됩니다.\n    this.logIt(&#39;AfterViewInit&#39;);\n    this.doSomething();\n  }\n\n  ngAfterViewChecked() {\n    // 뷰에서 변화감지 로직이 동작하면 viewChild가 갱신됩니다.\n    if (this.prevHero === this.viewChild.hero) {\n      this.logIt(&#39;AfterViewChecked (no change)&#39;);\n    } else {\n      this.prevHero = this.viewChild.hero;\n      this.logIt(&#39;AfterViewChecked&#39;);\n      this.doSomething();\n    }\n  }\n  // ...\n}\n\n</code-example>\n-->\n<p>변화 감지 싸이클이 실행되는 동안 Angular가 <a href=\"guide/glossary#view-hierarchy\" title=\"Definition of view hierarchy definition\">뷰 계층</a>를 순회하면서 자식 뷰에서 발생한 변화가 부모 뷰에 영향을 미치지 않아야 합니다.\n자식 뷰에서 부모 뷰에 영향을 주면 <a href=\"guide/glossary#unidirectional-data-flow\" title=\"Definition\">단방향 데이터 흐름</a>을 어기게 되기 때문에 예상한대로 렌더링되지 않을 수 있습니다.</p>\n<p>그래서 자식 뷰에서 부모 뷰로 전달되는 변화를 만들어 내려면 이 변화를 반영하는 변화 감지 싸이클을 새로 발생시켜야 합니다.\n이 과정을 어떻게 처리하는지 알아봅시다.</p>\n<p><em>AfterView</em> 예제는 컴포넌트 자식 뷰를 생성한 <em>후에</em> Angular가 실행하는 <code><a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a>()</code>, <code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>()</code> 후킹 메서드에 대해 다룹니다.</p>\n<p>자식 뷰는 히어로의 이름을 <code>&#x3C;input></code> 엘리먼트에 표시합니다:</p>\n<code-example path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"child-view\" header=\"ChildComponent\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-child-view',\n  template: '&#x3C;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero\">'\n})\nexport class ChildViewComponent {\n  hero = 'Magneta';\n}\n\n</code-example>\n<p>그리고 <code>AfterViewComponent</code>는 <em>템플릿 안에</em> 이 자식 뷰를 표시합니다:</p>\n<code-example path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"template\" header=\"AfterViewComponent (템플릿)\">\ntemplate: `\n  &#x3C;div>-- child view begins --&#x3C;/div>\n    &#x3C;app-child-view>&#x3C;/app-child-view>\n  &#x3C;div>-- child view ends --&#x3C;/div>`\n\n</code-example>\n<p>아래 코드는 <em>자식 뷰 안에서</em> 발생한 변화를 감지했을 때 처리하는 로직을 구현한 것입니다.\n자식 뷰에 있는 프로퍼티에 접근하기 위해 <a href=\"api/core/ViewChild\">@ViewChild</a> 데코레이터를 사용했습니다.</p>\n<code-example path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"hooks\" header=\"AfterViewComponent (클래스 일부)\">\nexport class AfterViewComponent implements  <a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>, <a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a> {\n  private prevHero = '';\n\n  // `ChildViewComponent` 타입의 뷰 자식 컴포넌트를 참조합니다.\n  @<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>(ChildViewComponent) viewChild: ChildViewComponent;\n\n  ngAfterViewInit() {\n    // viewChild는 뷰가 모두 초기화된 이후에 값이 할당됩니다.\n    this.logIt('<a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a>');\n    this.doSomething();\n  }\n\n  ngAfterViewChecked() {\n    // 뷰에서 변화감지 로직이 동작하면 viewChild가 갱신됩니다.\n    if (this.prevHero === this.viewChild.hero) {\n      this.logIt('<a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a> (no change)');\n    } else {\n      this.prevHero = this.viewChild.hero;\n      this.logIt('<a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>');\n      this.doSomething();\n    }\n  }\n  // ...\n}\n\n</code-example>\n<a id=\"wait-a-tick\"></a>\n<!--\n#### Wait before updating the view\n-->\n<h4 id=\"화면이-갱신될-때까지-기다리기\">화면이 갱신될 때까지 기다리기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#화면이-갱신될-때까지-기다리기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nIn this example, the `doSomething()` method updates the screen when the hero name exceeds 10 characters, but waits a tick before updating `comment`.\n\n<code-example path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"do-something\" header=\"AfterViewComponent (doSomething)\">\n// 동작을 확인하기 위해 `comment` 값을 변경해 봅니다.\nprivate doSomething() {\n  const c = this.viewChild.hero.length &gt; 10 ? `That&#39;s a long name` : &#39;&#39;;\n  if (c !== this.comment) {\n    // 컴포넌트의 뷰는 방금 검사를 마쳤기 때문에 한 싸이클 뒤에 실행합니다.\n    this.logger.tick_then(() =&gt; this.comment = c);\n  }\n}\n\n</code-example>\n\nBoth the `AfterViewInit()` and `AfterViewChecked()` hooks fire after the component's view has been composed.\nIf you modify the code so that the hook updates the component's data-bound `comment` property immediately, you can see that Angular throws an error.\n\nThe `LoggerService.tick_then()` statement postpones the log update\nfor one turn of the browser's JavaScript cycle, which triggers a new change-detection cycle.\n-->\n<p>이 예제에서 <code>doSomething()</code> 메서드는 히어로의 이름이 10글자를 넘어갔을 때 화면에 관련 메시지를 표시하는데, <code>comment</code> 프로퍼티를 갱신하기 전에 한 싸이클(tick) 기다립니다.</p>\n<code-example path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"do-something\" header=\"AfterViewComponent (doSomething())\">\n// 동작을 확인하기 위해 `comment` 값을 변경해 봅니다.\nprivate doSomething() {\n  const c = this.viewChild.hero.length > 10 ? `That's a long name` : '';\n  if (c !== this.comment) {\n    // 컴포넌트의 뷰는 방금 검사를 마쳤기 때문에 한 싸이클 뒤에 실행합니다.\n    this.logger.tick_then(() => this.comment = c);\n  }\n}\n\n</code-example>\n<p>후킹 메서드 <code>ngAfterViewInit()</code>과 <code>ngAfterViewChecked()</code>는 모두 컴포넌트 뷰가 갱신된 후에 실행됩니다.\n이 때 컴포넌트에 바인딩되는 <code>comment</code> 프로퍼티 값을 즉시 변경하면 Angular가 에러를 발생시킵니다.</p>\n<p>그래서 <code>LoggerService.tick_then()</code>를 사용해서 브라우저의 JavaScript 싸이클을 한 번 지연시킨 후 새로운 변화 감지 싸이클을 시작하는 방식으로 구현하는 것이 좋습니다.</p>\n<!--\n#### Write lean hook methods to avoid performance problems\n-->\n<h4 id=\"성능-저하에-주의하세요\">성능 저하에 주의하세요.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#성능-저하에-주의하세요\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nWhen you run the *AfterView* sample, notice how frequently Angular calls `AfterViewChecked()`-often when there are no changes of interest.\nBe very careful about how much logic or computation you put into one of these methods.\n\n<div class=\"lightbox\">\n\n  <img src='generated/images/guide/lifecycle-hooks/after-view-anim.gif' alt=\"AfterView\">\n\n</div>\n-->\n<p><em>AfterView</em> 예제를 실행해보면 별다른 변화가 없어도 <code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>()</code> 메서드가 자주 실행되는 것을 확인할 수 있습니다.\n이렇게 자주 실행되는 라이프싸이클 후킹 메서드에는 복잡한 로직을 작성하지 않아야 합니다.\n그래야 앱 성능 저하를 피할 수 있습니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/lifecycle-hooks/after-view-anim.gif\" alt=\"AfterView\" width=\"520\" height=\"532\">\n</div>\n<a id=\"aftercontent\"></a>\n<a id=\"aftercontent-hooks\"></a>\n<a id=\"content-projection\"></a>\n<!--\n### Responding to projected content changes\n-->\n<h3 id=\"외부-컨텐츠-변경사항-감지하기\">외부 컨텐츠 변경사항 감지하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#외부-컨텐츠-변경사항-감지하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\n*Content projection* is a way to import HTML content from outside the component and insert that content\ninto the component's template in a designated spot.\nYou can identify content projection in a template by looking for the following constructs.\n\n  * HTML between component element tags.\n  * The presence of `<ng-content>` tags in the component's template.\n\n<div class=\"alert is-helpful\">\n\n  AngularJS developers know this technique as *transclusion*.\n\n</div>\n\nThe *AfterContent* sample explores the `AfterContentInit()` and `AfterContentChecked()` hooks that Angular calls *after* Angular projects external content into the component.\n\nConsider this variation on the [previous _AfterView_](#afterview) example.\nThis time, instead of including the child view within the template, it imports the content from\nthe `AfterContentComponent`'s parent.\nThe following is the parent's template.\n\n<code-example path=\"lifecycle-hooks/src/app/after-content.component.ts\" region=\"parent-template\" header=\"AfterContentParentComponent (template excerpt)\">\n`&lt;after-content&gt;\n   &lt;app-child&gt;&lt;/app-child&gt;\n &lt;/after-content&gt;`\n\n</code-example>\n\nNotice that the `<app-child>` tag is tucked between the `<after-content>` tags.\nNever put content between a component's element tags *unless you intend to project that content\ninto the component*.\n\nNow look at the component's template.\n\n<code-example path=\"lifecycle-hooks/src/app/after-content.component.ts\" region=\"template\" header=\"AfterContentComponent (template)\">\ntemplate: `\n  &lt;div&gt;-- projected content begins --&lt;/div&gt;\n    &lt;ng-content&gt;&lt;/ng-content&gt;\n  &lt;div&gt;-- projected content ends --&lt;/div&gt;`\n\n</code-example>\n\nThe `<ng-content>` tag is a *placeholder* for the external content.\nIt tells Angular where to insert that content.\nIn this case, the projected content is the `<app-child>` from the parent.\n\n<div class=\"lightbox\">\n  <img src='generated/images/guide/lifecycle-hooks/projected-child-view.png' alt=\"Projected Content\">\n</div>\n-->\n<p><em>컨텐츠 프로젝션(content projection)</em>은 컴포넌트 밖에서 가져온 HTML 컨텐츠를 컴포넌트 템플릿 안에 표시하는 것을 의미합니다.\n템플릿에 사용된 컨텐츠 프로젝션은 이런 경우입니다.</p>\n<ul>\n<li>컴포넌트 엘리먼트 태그 안에 들어있는 HTML</li>\n<li>컴포넌트 템플릿에서 <code>&#x3C;ng-content></code>가 사용된 부분</li>\n</ul>\n<div class=\"alert is-helpful\">\n<p>  AngularJS에서는 이 테크닉을 <em>트랜스클루전(transclusion)</em>이라고 했습니다.</p>\n</div>\n<p><em>AfterContent</em> 예제에서 다루는 <code><a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a></code>과 <code><a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a></code> 후킹 함수는 Angular가 외부 컨텐츠를 컴포넌트 안에 프로젝션한 <em>후에</em> 실행됩니다.</p>\n<p><a href=\"guide/lifecycle-hooks#afterview\">이전에 살펴본 <em>AfterView</em></a> 예제와 비교해 보세요.\n이번에는 템플릿에 자식 뷰를 포함하는 것이 아니라 부모 컴포넌트 <code>AfterContentComponent</code>에서 받아오는 방식으로 구현했습니다.\n그래서 부모 템플릿은 이렇게 구성됩니다.</p>\n<code-example path=\"lifecycle-hooks/src/app/after-content.component.ts\" region=\"parent-template\" header=\"AfterContentParentComponent (템플릿 일부)\">\n`&#x3C;after-content>\n   &#x3C;app-child>&#x3C;/app-child>\n &#x3C;/after-content>`\n\n</code-example>\n<p><code>&#x3C;app-child></code> 태그가 <code>&#x3C;after-content></code> 태그 안에 들어가 있는 것을 유심히 보세요.\n<em>컴포넌트 안에 프로젝션하는 경우가 아니라면</em> 컴포넌트 엘리먼트 태그 안에는 아무것도 넣어서는 안됩니다.</p>\n<p>이제 컴포넌트 템플릿을 봅시다.</p>\n<code-example path=\"lifecycle-hooks/src/app/after-content.component.ts\" region=\"template\" header=\"AfterContentComponent (템플릿)\">\ntemplate: `\n  &#x3C;div>-- projected content begins --&#x3C;/div>\n    &#x3C;ng-content>&#x3C;/ng-content>\n  &#x3C;div>-- projected content ends --&#x3C;/div>`\n\n</code-example>\n<p><code>&#x3C;ng-content></code> 태그는 외부 컨텐츠가 들어갈 위치를 지정합니다.\n그래서 이 경우에는 부모 컴포넌트에 사용한 <code>&#x3C;app-child></code>가 컴포넌트 안으로 프로젝션 됩니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/lifecycle-hooks/projected-child-view.png\" alt=\"Projected Content\" width=\"230\" height=\"89\">\n</div>\n<a id=\"using-aftercontent-hooks\"></a>\n<!--\n#### Using AfterContent hooks\n-->\n<h4 id=\"aftercontent-후킹-함수-활용하기\">AfterContent 후킹 함수 활용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#aftercontent-후킹-함수-활용하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\n*AfterContent* hooks are similar to the *AfterView* hooks.\nThe key difference is in the child component.\n\n* The *AfterView* hooks concern `ViewChildren`, the child components whose element tags\nappear *within* the component's template.\n\n* The *AfterContent* hooks concern `ContentChildren`, the child components that Angular\nprojected into the component.\n\nThe following *AfterContent* hooks take action based on changing values in a *content child*,\nwhich can only be reached by querying for them via the property decorated with\n[@ContentChild](api/core/ContentChild).\n\n<code-example path=\"lifecycle-hooks/src/app/after-content.component.ts\" region=\"hooks\" header=\"AfterContentComponent (class excerpts)\">\nexport class AfterContentComponent implements AfterContentChecked, AfterContentInit {\n  private prevHero = &#39;&#39;;\n  comment = &#39;&#39;;\n\n  // `ChildComponent` 타입의 자식 컴포넌트를 참조합니다.\n  @ContentChild(ChildComponent) contentChild: ChildComponent;\n\n  ngAfterContentInit() {\n    // contentChild는 컨텐츠가 모두 초기화된 이후에 값이 할당됩니다.\n    this.logIt(&#39;AfterContentInit&#39;);\n    this.doSomething();\n  }\n\n  ngAfterContentChecked() {\n    // 컨텐츠에서 변화감지 로직이 동작하면 contentChild가 갱신됩니다.\n    if (this.prevHero === this.contentChild.hero) {\n      this.logIt(&#39;AfterContentChecked (no change)&#39;);\n    } else {\n      this.prevHero = this.contentChild.hero;\n      this.logIt(&#39;AfterContentChecked&#39;);\n      this.doSomething();\n    }\n  }\n  // ...\n}\n\n</code-example>\n\n<a id=\"no-unidirectional-flow-worries\"></a>\n\n<div class=\"alert is-helpful\">\n\n<header>No need to wait for content updates</header>\n\nThis component's `doSomething()` method updates the component's data-bound `comment` property immediately.\nThere's no need to [delay the update to ensure proper rendering](#wait-a-tick \"Delaying updates\").\n\nAngular calls both *AfterContent* hooks before calling either of the *AfterView* hooks.\nAngular completes composition of the projected content *before* finishing the composition of this component's view.\nThere is a small window between the `AfterContent...` and `AfterView...` hooks that allows you to modify the host view.\n\n</div>\n-->\n<p><em>AfterContent</em>는 <em>AfterView</em>와 비슷하게 동작합니다.\n자식 컴포넌트에서 일어난다는 점만 다릅니다.</p>\n<ul>\n<li>\n<p><em>AfterView</em>는 <code><a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code>과 관련이 있습니다. 컴포넌트 템플릿 <em>안에</em> 사용된 자식 컴포넌트 태그에 반응합니다.</p>\n</li>\n<li>\n<p><em>AfterContent</em>는 <code><a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code>과 관련이 있습니다. 컴포넌트에 프로젝션된 자식 컴포넌트에 반응합니다.</p>\n</li>\n</ul>\n<p>아래 예제 코드에서 <em>AfterContent</em> 후킹 함수는 <em>자식 컨텐츠</em>가 변경된 것을 감지할 때 동작합니다.\n컴포넌트 클래스에서 자식 컨텐츠를 참조하려면 <a href=\"api/core/ContentChild\">@ContentChild</a> 데코레이터를 사용하면 됩니다.</p>\n<code-example path=\"lifecycle-hooks/src/app/after-content.component.ts\" region=\"hooks\" header=\"AfterContentComponent (클래스 일부)\">\nexport class AfterContentComponent implements <a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a>, <a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a> {\n  private prevHero = '';\n  comment = '';\n\n  // `ChildComponent` 타입의 자식 컴포넌트를 참조합니다.\n  @<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(ChildComponent) contentChild: ChildComponent;\n\n  ngAfterContentInit() {\n    // contentChild는 컨텐츠가 모두 초기화된 이후에 값이 할당됩니다.\n    this.logIt('<a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a>');\n    this.doSomething();\n  }\n\n  ngAfterContentChecked() {\n    // 컨텐츠에서 변화감지 로직이 동작하면 contentChild가 갱신됩니다.\n    if (this.prevHero === this.contentChild.hero) {\n      this.logIt('<a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a> (no change)');\n    } else {\n      this.prevHero = this.contentChild.hero;\n      this.logIt('<a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a>');\n      this.doSomething();\n    }\n  }\n  // ...\n}\n\n</code-example>\n<a id=\"no-unidirectional-flow-worries\"></a>\n<div class=\"alert is-helpful\">\n<header>컨텐츠가 갱신된 것은 기다릴 필요가 없습니다.</header>\n<p>컴포넌트에 정의된 <code>doSomething()</code> 메서드는 컴포넌트에 바인딩된 <code>comment</code> 프로퍼티 값을 즉시 갱신합니다.\n그런데 이때는 <a href=\"guide/lifecycle-hooks#wait-a-tick\" title=\"Delaying updates\">렌더링이 제대로 되도록 한 싸이클 기다리는 동작</a>을 할 필요가 없습니다.</p>\n<p>Angular는 <em>AfterView</em>를 실행하기 전에 <em>AfterContent</em> 후킹 함수를 먼저 실행합니다.\n그리고 컨텐츠 프로젝션이 마무리 되는 시점은 Angular가 컴포넌트 뷰 화면을 마무리하기 <em>전</em> 입니다.\n따라서 <code>AfterContent...</code>와 <code>AfterView...</code> 후킹함수가 실행되는 타이밍 사이에 약간의 틈이 있습니다.\n이 시점에 호스트 뷰에서 무언가 변경해도 정상적으로 렌더링 됩니다.</p>\n</div>\n<a id=\"docheck\"></a>\n<a id=\"defining-custom-change-detection\"></a>\n<!--\n## Defining custom change detection\n-->\n<h2 id=\"커스텀-변화감지-로직-정의하기\">커스텀 변화감지 로직 정의하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#커스텀-변화감지-로직-정의하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nTo monitor changes that occur where `ngOnChanges()` won't catch them, you can implement your own change check, as shown in the *DoCheck* example.\nThis example shows how you can use the `ngDoCheck()` hook to detect and act upon changes that Angular doesn't catch on its own.\n\nThe *DoCheck* sample extends the *OnChanges* sample with the following `ngDoCheck()` hook:\n\n<code-example path=\"lifecycle-hooks/src/app/do-check.component.ts\" region=\"ng-do-check\" header=\"DoCheckComponent (ngDoCheck)\">\nngDoCheck() {\n\n  if (this.hero.name !== this.oldHeroName) {\n    this.changeDetected = true;\n    this.changeLog.push(`DoCheck: Hero name changed to &quot;${this.hero.name}&quot; from &quot;${this.oldHeroName}&quot;`);\n    this.oldHeroName = this.hero.name;\n  }\n\n  if (this.power !== this.oldPower) {\n    this.changeDetected = true;\n    this.changeLog.push(`DoCheck: Power changed to &quot;${this.power}&quot; from &quot;${this.oldPower}&quot;`);\n    this.oldPower = this.power;\n  }\n\n  if (this.changeDetected) {\n      this.noChangeCount = 0;\n  } else {\n      // 컴포넌트의 내용이 변경되지 않았으면 함수가 몇번 실행되었는지 로그를 출력합니다.\n      const count = this.noChangeCount += 1;\n      const noChangeMsg = `DoCheck called ${count}x when no change to hero or power`;\n      if (count === 1) {\n        // &quot;no change&quot; 메시지를 추가합니다.\n        this.changeLog.push(noChangeMsg);\n      } else {\n        // 마지막에 추가한 &quot;no change&quot; 메시지를 수정합니다.\n        this.changeLog[this.changeLog.length - 1] = noChangeMsg;\n      }\n  }\n\n  this.changeDetected = false;\n}\n\n</code-example>\n\nThis code inspects certain _values of interest_, capturing and comparing their current state against previous values.\nIt writes a special message to the log when there are no substantive changes to the `hero` or the `power` so you can see how often `DoCheck()` is called.\nThe results are illuminating.\n\n<div class=\"lightbox\">\n  <img src='generated/images/guide/lifecycle-hooks/do-check-anim.gif' alt=\"DoCheck\">\n</div>\n\nWhile the `ngDoCheck()` hook can detect when the hero's `name` has changed, it is very expensive.\nThis hook is called with enormous frequency&mdash;after _every_\nchange detection cycle no matter where the change occurred.\nIt's called over twenty times in this example before the user can do anything.\n\nMost of these initial checks are triggered by Angular's first rendering of *unrelated data elsewhere on the page*.\nJust moving the cursor into another `<input>` triggers a call.\nRelatively few calls reveal actual changes to pertinent data.\nIf you use this hook, your implementation must be extremely lightweight or the user experience suffers.\n-->\n<p>입력 프로퍼티 값이 변경되었지만 <code>ngOnChanges()</code>에서 감지하지 못했다면, <em>DoCheck</em> 예제에서 다룬 것처럼 직접 변화를 감지하는 로직을 작성해도 됩니다.\n아래 예제를 확인해 보세요.</p>\n<p><em>DoCheck</em> 예제는 <em>OnChanges</em> 앱을 확장하며 <code>ngDoCheck()</code> 메서드를 추가한 것입니다:</p>\n<code-example path=\"lifecycle-hooks/src/app/do-check.component.ts\" region=\"ng-do-check\" header=\"DoCheckComponent (ngDoCheck())\">\nngDoCheck() {\n\n  if (this.hero.name !== this.oldHeroName) {\n    this.changeDetected = true;\n    this.changeLog.push(`<a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a>: Hero name changed to \"${this.hero.name}\" from \"${this.oldHeroName}\"`);\n    this.oldHeroName = this.hero.name;\n  }\n\n  if (this.power !== this.oldPower) {\n    this.changeDetected = true;\n    this.changeLog.push(`<a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a>: Power changed to \"${this.power}\" from \"${this.oldPower}\"`);\n    this.oldPower = this.power;\n  }\n\n  if (this.changeDetected) {\n      this.noChangeCount = 0;\n  } else {\n      // 컴포넌트의 내용이 변경되지 않았으면 함수가 몇번 실행되었는지 로그를 출력합니다.\n      const count = this.noChangeCount += 1;\n      const noChangeMsg = `<a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a> called ${count}x when no change to hero or power`;\n      if (count === 1) {\n        // \"no change\" 메시지를 추가합니다.\n        this.changeLog.push(noChangeMsg);\n      } else {\n        // 마지막에 추가한 \"no change\" 메시지를 수정합니다.\n        this.changeLog[this.changeLog.length - 1] = noChangeMsg;\n      }\n  }\n\n  this.changeDetected = false;\n}\n\n</code-example>\n<p>이 코드는 <em>확인하고 싶은 값</em> 을 직접 가져와서 이전 값과 현재 값을 비교하고, <code>hero</code> 프로퍼티와 <code>power</code> 프로퍼티 값이 변경되지 않으면 변경된 내용이 없다는 메시지를 출력합니다.\n이 과정은 <code><a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a>()</code>가 실행될 때마다 반복됩니다.\n실행되는 모습을 확인해 보세요.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/lifecycle-hooks/do-check-anim.gif\" alt=\"DoCheck\" width=\"632\" height=\"588\">\n</div>\n<p>이렇게 구현하면 <code>ngDoCheck()</code> 메서드에서 히어로의 <code>name</code> 프로퍼티가 변경된 것을 감지할 수 있지만, 이 방식은 아주 무거운 부하를 동반합니다.\n<code>ngDoCheck()</code> 메서드는 꼭 필요하지 않은 변화 감지 싸이클에도 <em>매번</em> 반응하며 실행되기 때문입니다.\n실제로 사용자가 아무런 동작을 하지 않아도 이 메서드는 20번 이상 실행되는 것도 확인할 수 있습니다.</p>\n<p>이 중 대부분은 Angular가 화면을 렌더링하는 동안 <em>이 컴포넌트와는 상관없는 영역에서 일어난 변화</em> 때문에 실행된 것입니다.\n심지어 마우스 커서를 <code>&#x3C;input></code> 엘리먼트로 옮기기만 해도 후킹 함수가 실행됩니다.\n실제로 변화를 감지하기 위해 필요한 함수 실행은 몇 번 되지 않습니다.\n그래서 이 후킹 메서드를 사용하면서 사용자에게 불편을 주지 않으려면 메서드 안에 들어가는 로직을 아주 간단하게 작성해야 합니다.</p>\n\n</div>\n\n<!-- links to this doc:\n - api/core/AfterContentChecked\n - api/core/AfterContentInit\n - api/core/AfterViewChecked\n - api/core/AfterViewInit\n - api/core/ChangeDetectorRef\n - api/core/Component\n - api/core/Directive\n - api/core/DoCheck\n - api/core/OnChanges\n - api/core/OnDestroy\n - api/core/OnInit\n - guide/architecture-components\n - guide/architecture-next-steps\n - guide/component-interaction\n - guide/example-apps-list\n - guide/glossary\n - guide/inputs-outputs\n - guide/lightweight-injection-tokens\n - guide/module-types\n - guide/testing-components-basics\n - guide/testing-components-scenarios\n - guide/upgrade\n - tutorial/toh-pt1\n - tutorial/toh-pt4\n - tutorial/toh-pt5\n-->\n<!-- links from this doc:\n - api/common/NgForOf\n - api/core/AfterContentChecked\n - api/core/AfterContentInit\n - api/core/AfterViewChecked\n - api/core/AfterViewInit\n - api/core/Component\n - api/core/ContentChild\n - api/core/ContentChildren\n - api/core/Directive\n - api/core/DoCheck\n - api/core/Input\n - api/core/OnChanges\n - api/core/OnDestroy\n - api/core/OnInit\n - api/core/SimpleChange\n - api/core/SimpleChanges\n - api/core/ViewChild\n - api/core/ViewChildren\n - api/forms/NgModel\n - guide/architecture\n - guide/glossary#lifecycle-hook\n - guide/glossary#unidirectional-data-flow\n - guide/glossary#view\n - guide/glossary#view-hierarchy\n - guide/lifecycle-hooks#aftercontent\n - guide/lifecycle-hooks#aftercontent-후킹-함수-활용하기\n - guide/lifecycle-hooks#afterview\n - guide/lifecycle-hooks#counter\n - guide/lifecycle-hooks#docheck\n - guide/lifecycle-hooks#dom을-추적하는-디렉티브\n - guide/lifecycle-hooks#onchanges\n - guide/lifecycle-hooks#ondestroy\n - guide/lifecycle-hooks#oninit\n - guide/lifecycle-hooks#peek-a-boo\n - guide/lifecycle-hooks#spy\n - guide/lifecycle-hooks#wait-a-tick\n - guide/lifecycle-hooks#라이프싸이클-이벤트-발생-순서-빈도\n - guide/lifecycle-hooks#라이프싸이클-이벤트-순서\n - guide/lifecycle-hooks#라이프싸이클-이벤트에-반응하기\n - guide/lifecycle-hooks#라이프싸이클-활용-예제\n - guide/lifecycle-hooks#변화-감지-후킹-함수-활용하기\n - guide/lifecycle-hooks#사전지식\n - guide/lifecycle-hooks#성능-저하에-주의하세요\n - guide/lifecycle-hooks#외부-컨텐츠-변경사항-감지하기\n - guide/lifecycle-hooks#인스턴스-종료하기\n - guide/lifecycle-hooks#커스텀-변화감지-로직-정의하기\n - guide/lifecycle-hooks#컴포넌트-디렉티브-초기화하기\n - guide/lifecycle-hooks#컴포넌트-라이프싸이클-후킹\n - guide/lifecycle-hooks#컴포넌트와-디렉티브에서-동시에-후킹하기\n - guide/lifecycle-hooks#화면-변경사항-감지하기\n - guide/lifecycle-hooks#화면이-갱신될-때까지-기다리기\n - guide/lifecycle-hooks#활용-예제\n - tutorial/toh-pt4#oninit\n - http://misko.hevery.com/code-reviewers-guide/flaw-constructor-does-real-work/\n - https://github.com/angular/angular/edit/master/aio/content/guide/lifecycle-hooks.md?message=docs%3A%20describe%20your%20change...\n - https://www.typescriptlang.org/\n-->"
}