{
  "id": "guide/lifecycle-hooks",
  "title": "라이프싸이클 후킹",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/lifecycle-hooks.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Lifecycle Hooks\n-->\n<h1 id=\"라이프싸이클-후킹\">라이프싸이클 후킹<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#라이프싸이클-후킹\"><i class=\"material-icons\">link</i></a></h1>\n<!--\nA component has a lifecycle managed by Angular.\n-->\n<p>컴포넌트는 Angular가 관리하는 라이프싸이클을 따릅니다.</p>\n<!--\nAngular creates it, renders it, creates and renders its children,\nchecks it when its data-bound properties change, and destroys it before removing it from the DOM.\n-->\n<p>컴포넌트는 Angular가 생성하고, 렌더링하며, 자식 컴포넌트를 순차적으로 생성하고 생성하고 렌더링합니다.</p>\n<!--\nAngular offers **lifecycle hooks**\nthat provide visibility into these key life moments and the ability to act when they occur.\n-->\n<p>컴포넌트가 만나는 각 라이프싸이클은 Angular에서 제공하는 <strong>라이프싸이클 후킹 함수</strong>를 사용해서 원하는 동작을 하도록 조정할 수 있습니다.</p>\n<!--\nA directive has the same set of lifecycle hooks.\n-->\n<p>디렉티브는 컴포넌트와 같은 라이크싸이클을 갖습니다.</p>\n<a id=\"hooks-overview\"></a>\n<!--\n## Component lifecycle hooks overview\n-->\n<h2 id=\"개요\">개요<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#개요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nDirective and component instances have a lifecycle\nas Angular creates, updates, and destroys them.\nDevelopers can tap into key moments in that lifecycle by implementing\none or more of the *lifecycle hook* interfaces in the Angular `core` library.\n-->\n<p>디렉티브와 컴포넌트 인스턴스는 Angular가 생성하고, 업데이트하며, 종료하는 라이프싸이클을 따릅니다.\n이 라이프싸이클은 Angular <code>core</code> 라이크러리에 인터페이스로 제공되는 <em>라이프싸이클 후킹 함수</em>로 가로채서 원하는 동작을 수행하도록 조정할 수 있습니다.</p>\n<!--\nEach interface has a single hook method whose name is the interface name prefixed with `ng`.\nFor example, the `OnInit` interface has a hook method named `ngOnInit()`\nthat Angular calls shortly after creating the component:\n-->\n<p>각각의 인터페이스에는 <code>ng</code> 접두사가 붙는 라이프싸이클 후킹 메소드가 정의되어 있습니다.\n예를 들면, <code><a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a></code> 인터페이스에는 <code>ngOnInit()</code> 메소드가 정의되어 있으며, 이 메소드를 구현하면 Angular가 컴포넌트를 생성한 후에 실행되는 시점을 가로챌 수 있습니다.</p>\n<code-example path=\"lifecycle-hooks/src/app/peek-a-boo.component.ts\" region=\"ngOnInit\" header=\"peek-a-boo.component.ts (excerpt)\" linenums=\"false\">\nexport class PeekABoo implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  constructor(private logger: LoggerService) { }\n\n  // <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> 인터페이스에서 정의하는 `ngOnInit` 메소드를 구현합니다.\n  ngOnInit() { this.logIt(`<a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>`); }\n\n  logIt(msg: string) {\n    this.logger.log(`#${nextId++} ${msg}`);\n  }\n}\n\n</code-example>\n<!--\nNo directive or component will implement all of the lifecycle hooks.\nAngular only calls a directive/component hook method *if it is defined*.\n-->\n<p>하지만 디렉티브나 컴포넌트에 모든 라이프싸이클 후킹 함수를 구현할 필요는 없습니다.\n라이프싸이클 후킹 함수는 필요한 것만 골라서 사용하면 되며, Angular 프레임워크는 명시적으로 구현한 라이프싸이클 후킹 함수만 실행합니다.</p>\n<a id=\"hooks-purpose-timing\"></a>\n<!--\n## Lifecycle sequence\n-->\n<h2 id=\"라이프싸이클-함수-실행-순서\">라이프싸이클 함수 실행 순서<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#라이프싸이클-함수-실행-순서\"><i class=\"material-icons\">link</i></a></h2>\n<!--\n*After* creating a component/directive by calling its constructor, Angular\ncalls the lifecycle hook methods in the following sequence at specific moments:\n-->\n<p>컴포넌트나 디렉티브가 생성된 <em>후에는</em> 생성자가 제일 먼저 실행됩니다.\n그리고 다음 순서에 따라 라이프싸이클 후킹 함수가 실행됩니다:</p>\n<table width=\"100%\">\n  <colgroup><col width=\"20%\">\n  <col width=\"80%\">\n  </colgroup><tbody><tr>\n    <!--\n    <th>Hook</th>\n    <th>Purpose and Timing</th>\n    -->\n    <th>후킹 함수</th>\n    <th>용도와 실행 타이밍</th>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngOnChanges()</code>\n    </td>\n    <td>\n      <!--\n      Respond when Angular (re)sets data-bound input properties.\n      The method receives a `SimpleChanges` object of current and previous property values.\n\n      Called before `ngOnInit()` and whenever one or more data-bound input properties change.\n      -->\n<p>      Angular가 입력 프로퍼티 값을 설정할 때 실행됩니다.\n이 메소드는 <code><a href=\"api/core/SimpleChanges\" class=\"code-anchor\">SimpleChanges</a></code> 타입의 객체를 인자로 받으며, 이 객체에서 이전 값과 현재 값을 확인할 수 있습니다.</p>\n<p>      <code>ngOnInit()</code> 함수가 실행되기 전에 먼저 실행되고, 입력 프로퍼티의 값이 바뀔때마다 실행됩니다.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngOnInit()</code>\n    </td>\n    <td>\n      <!--\n      Initialize the directive/component after Angular first displays the data-bound properties\n      and sets the directive/component's input properties.\n\n      Called _once_, after the _first_ `ngOnChanges()`.\n      -->\n<p>      디렉티브나 컴포넌트는 인스턴스가 생성되고 입력 프로퍼티를 통해 초기값이 지정된 이후에 화면에 표시되는데,\n디렉티브나 컴포넌트를 초기화하는 로직이 더 있을 때 사용합니다.</p>\n<p>      <code>ngOnChanges()</code>가 <em>처음</em> 실행된 이후에 <em>한 번만</em> 실행됩니다.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngDoCheck()</code>\n    </td>\n    <td>\n      <!--\n      Detect and act upon changes that Angular can't or won't detect on its own.\n\n      Called during every change detection run, immediately after `ngOnChanges()` and `ngOnInit()`.\n      -->\n<p>      변화 감지 싸이클을 수동으로 실행할 때 사용합니다.</p>\n<p>      변화 감지 싸이클이 실행될 때마다 실행되며, <code>ngOnChanges()</code>와 <code>ngOnInit()</code> 메소드가 실행된 직후에도 한 번 실행됩니다.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code><a href=\"api/router/RouterLinkActive#ngAfterContentInit\" class=\"code-anchor\">ngAfterContentInit()</a></code>\n    </td>\n    <td>\n      <!--\n      Respond after Angular projects external content into the component's view / the view that a directive is in.\n\n      Called _once_ after the first `ngDoCheck()`.\n      -->\n<p>      Angular가 컴포넌트의 템플릿을 컴포넌트 뷰로 준비하거나 뷰 안에 있는 디렉티브를 준비한 이후에 실행됩니다.</p>\n<p>      <code>ngDoCheck()</code>가 처음 실행된 직후에 <em>한 번만</em> 실행됩니다.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngAfterContentChecked()</code>\n    </td>\n    <td>\n      <!--\n      Respond after Angular checks the content projected into the directive/component.\n\n      Called after the `ngAfterContentInit()` and every subsequent `ngDoCheck()`.\n      -->\n<p>      Angular가 디렉티브나 컴포넌트의 뷰를 검사한 이후에 실행됩니다.</p>\n<p>      <code><a href=\"api/router/RouterLinkActive#ngAfterContentInit\" class=\"code-anchor\">ngAfterContentInit()</a></code>이 실행된 후에 실행되며, <code>ngDoCheck()</code> 함수가 실행된 뒤에도 실행됩니다.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code><a href=\"api/forms/NgForm#ngAfterViewInit\" class=\"code-anchor\">ngAfterViewInit()</a></code>\n    </td>\n    <td>\n      <!--\n      Respond after Angular initializes the component's views and child views / the view that a directive is in.\n\n      Called _once_ after the first `ngAfterContentChecked()`.\n      -->\n<p>      Angular가 컴포넌트 뷰와 자식 컴포넌트 뷰, 뷰 안에 있는 디렉티브를 모두 초기화한 후에 실행됩니다.</p>\n<p>      <code>ngAfterContentChecked()</code>가 처음 실행된 직후에 <em>한 번만</em> 실행됩니다.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngAfterViewChecked()</code>\n    </td>\n    <td>\n      <!--\n      Respond after Angular checks the component's views and child views / the view that a directive is in.\n\n      Called after the `ngAfterViewInit` and every subsequent `ngAfterContentChecked()`.\n      -->\n<p>      Angular가 컴포넌트 뷰와 자식 컴포넌트 뷰, 뷰 안에 있는 디렉티브가 준비되었는지 검사한 후에 실행됩니다.</p>\n<p>      <code><a href=\"api/forms/NgForm#ngAfterViewInit\" class=\"code-anchor\">ngAfterViewInit()</a></code>이 실행된 직후에 실행되며, <code>ngAfterContentChecked()</code>가 실행될 때마다 실행됩니다.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngOnDestroy()</code>\n    </td>\n    <td>\n      \n      <!--\n      Cleanup just before Angular destroys the directive/component.\n      Unsubscribe Observables and detach event handlers to avoid memory leaks.\n<p>      Called <em>just before</em> Angular destroys the directive/component.\n-->\n디렉티브나 컴포넌트가 종료되기 직전에 실행되며,\n이 함수에서 옵저버블 구독을 해제하거나 이벤트 핸들러를 제거해서 메모리 누수를 방지할 때 사용합니다.<p></p>\n<p>      Angular가 디렉티브나 컴포넌트를 <em>종료하기 직전에</em> 실행됩니다.</p>\n    </td>\n  </tr>\n</tbody></table>\n<!--\n<a id=\"interface-optional\"></a>\n-->\n<a id=\"인터페이스는-옵션\"></a>\n<!--\n## Interfaces are optional (technically)\n-->\n<h2 id=\"인터페이스-구현은-옵션입니다\">인터페이스 구현은 옵션입니다.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#인터페이스-구현은-옵션입니다\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe interfaces are optional for JavaScript and Typescript developers from a purely technical perspective.\nThe JavaScript language doesn't have interfaces.\nAngular can't see TypeScript interfaces at runtime because they disappear from the transpiled JavaScript.\n-->\n<p>문법적인 측면에서 JavaScript나 TypeScript를 개발할 때 인터페이스를 꼭 사용해야 하는 것은 아닙니다.\n심지어 JavaScript는 인터페이스를 제공하고 있지도 않습니다.\n그래서 Angular 애플리케이션이 JavaScript 코드로 변환된 이후에는 Angular가 TypeScript 인터페이스가 있는지 알 수 없습니다.</p>\n<!--\nFortunately, they aren't necessary.\nYou don't have to add the lifecycle hook interfaces to directives and components to benefit from the hooks themselves.\n-->\n<p>하지만 다행히, Angular의 라이프싸이클 후킹을 활용하기 위해 인터페이스를 항상 구현해야 하는 것은 아닙니다.</p>\n<!--\nAngular instead inspects directive and component classes and calls the hook methods *if they are defined*.\nAngular finds and calls methods like `ngOnInit()`, with or without the interfaces.\n-->\n<p>Angular는 디렉티브나 컴포넌트 클래스에 라이프사이클 후킹 함수가 <em>메소드로 정의되어 있으면</em> 라이프싸이클 후킹 함수를 실행합니다.\n그래서 인터페이스를 사용하는 여부와 관계없이, 클래스에 <code>ngOnInit()</code> 메소드가 정의되어 있으면 이 함수를 실행합니다.</p>\n<!--\nNonetheless, it's good practice to add interfaces to TypeScript directive classes\nin order to benefit from strong typing and editor tooling.\n-->\n<p>그럼에도 불구하고, TypeScript의 강력한 타입 검사와 에디터가 지원하는 타입 지원 기능을 제대로 활용하려면 Angular가 제안하는 방법처럼 인터페이스를 제대로 구현하는 것이 좋습니다.</p>\n<!--\n<a id=\"other-lifecycle-hooks\"></a>\n-->\n<a id=\"기타-라이프싸이클-후킹-함수\"></a>\n<!--\n## Other Angular lifecycle hooks\n-->\n<h2 id=\"기타-라이프싸이클-후킹-함수\">기타 라이프싸이클 후킹 함수<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#기타-라이프싸이클-후킹-함수\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nOther Angular sub-systems may have their own lifecycle hooks apart from these component hooks.\n-->\n<p>Angular 서드파티 라이브러리 중에는 라이프싸이클 후킹 함수를 따로 정의해서 사용하는 경우도 있습니다.</p>\n<!--\n3rd party libraries might implement their hooks as well in order to give developers more\ncontrol over how these libraries are used.\n-->\n<p>이런 라이프싸이클 후킹 함수는 Angular가 정의하는 라이프싸이클 외에 좀 더 다양한 시점을 활용하기 위해 마련된 것이며, 컴포넌트를 좀 더 효율적으로 활용할 수 있는 방법입니다.</p>\n<a id=\"the-sample\"></a>\n<!--\n## Lifecycle examples\n-->\n<h2 id=\"라이프싸이클-활용-예제\">라이프싸이클 활용 예제<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#라이프싸이클-활용-예제\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe <live-example></live-example>\ndemonstrates the lifecycle hooks in action through a series of exercises\npresented as components under the control of the root `AppComponent`.\n-->\n<p>이 섹션에서 다루는 라이프싸이클 후킹 함수 활용 예제는 <live-example></live-example>에서 바로 확인할 수 있습니다.\n각 예제는 <code>AppComponent</code>의 자식 컴포넌트로 구성됩니다.</p>\n<!--\nThey follow a common pattern: a *parent* component serves as a test rig for\na *child* component that illustrates one or more of the lifecycle hook methods.\n-->\n<p>이 예제들은 모두 같은 패턴으로 구성되어 있습니다. 라이프싸이클 후킹 함수는 <em>자식</em> 컴포넌트에 각각 정의되어 있으며, <em>부모</em> 컴포넌트가 이 컴포넌트를 동작시킵니다.</p>\n<!--\nHere's a brief description of each exercise:\n-->\n<p>각 예제를 간단하게 설명하면 다음과 같습니다:</p>\n<table width=\"100%\">\n  <colgroup><col width=\"20%\">\n  <col width=\"80%\">\n  </colgroup><tbody><tr>\n    <!--\n    <th>Component</th>\n    <th>Description</th>\n    -->\n    <th>컴포넌트</th>\n    <th>설명</th>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <a href=\"guide/lifecycle-hooks#peek-a-boo\">Peek-a-boo</a>\n    </td>\n    <td>\n      <!--\n      Demonstrates every lifecycle hook.\n      Each hook method writes to the on-screen log.\n      -->\n<p>      모든 라이프싸이클 후킹 함수를 다룹니다.\n각 함수가 실행될때마다 화면에서 로그를 확인할 수 있습니다.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <a href=\"guide/lifecycle-hooks#spy\">Spy</a>\n    </td>\n    <td>\n      <!--\n      Directives have lifecycle hooks too.\n      A `SpyDirective` can log when the element it spies upon is\n      created or destroyed using the `ngOnInit` and `ngOnDestroy` hooks.\n\n      This example applies the `SpyDirective` to a `<div>` in an `ngFor` *hero* repeater\n      managed by the parent `SpyComponent`.\n      -->\n<p>      디렉티브도 라이프싸이클 후킹 함수를 활용할 수 있습니다.\n<code>SpyDirective</code>가 생성되거나 종료될 때 각각 <code>ngOnInit</code>과 <code>ngOnDestroy</code> 후킹 함수가 실행되는 것을 확인할 수 있습니다.</p>\n<p>      이 예제에서는 <code>&#x3C;div></code>에 <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>를 사용해서 <em>hero</em> 객체를 반복할 때 <code>SpyDirective</code>가 사용됩니다.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <a href=\"guide/lifecycle-hooks#onchanges\">OnChanges</a>\n    </td>\n    <td>\n      <!--\n      See how Angular calls the `ngOnChanges()` hook with a `changes` object\n      every time one of the component input properties changes.\n      Shows how to interpret the `changes` object.\n      -->\n<p>      컴포넌트의 입력 프로퍼티가 변경될 때 <code>ngOnChanges()</code> 함수가 어떻게 실행되는지 확인할 수 있습니다.\n이 때 인자로 <code><a href=\"api/core/QueryList#changes\" class=\"code-anchor\">changes</a></code> 객체가 전달되며, 이 객체를 어떻게 활용하는지 알아봅니다.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <a href=\"guide/lifecycle-hooks#docheck\">DoCheck</a>\n    </td>\n    <td>\n      <!--\n      Implements an `ngDoCheck()` method with custom change detection.\n      See how often Angular calls this hook and watch it post changes to a log.\n      -->\n<p>      변화감지 싸이클이 수동으로 실행되었을 때 <code>ngDoCheck()</code>가 어떻게 실행되는지 알아봅니다.\n이 함수가 어떤 경우를 감지하고 실행되는지 로그로 확인해 보세요.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <a href=\"guide/lifecycle-hooks#afterview\">AfterView</a>\n    </td>\n    <td>\n      <!--\n      Shows what Angular means by a *view*.\n      Demonstrates the `ngAfterViewInit` and `ngAfterViewChecked` hooks.\n      -->\n<p>      Angular에서 화면을 담당하는 것은 <em>뷰</em> 입니다.\n<code>ngAfterViewInit</code>과 <code>ngAfterViewChecked</code>가 어떻게 실행되는지 확인해 보세요.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <a href=\"guide/lifecycle-hooks#aftercontent\">AfterContent</a>\n    </td>\n    <td>\n      <!--\n      Shows how to project external content into a component and\n      how to distinguish projected content from a component's view children.\n      Demonstrates the `ngAfterContentInit` and `ngAfterContentChecked` hooks.\n      -->\n<p>      외부 컨텐츠가 컴포넌트에 어떻게 반영되는지, 이 컨텐츠가 컴포넌트의 자식 뷰와는 어떻게 구별되는지 확인해 보세요.\n이 예제는 <code>ngAfterContentInit</code>과 <code>ngAfterContentChecked</code> 함수에 대해 알아봅니다.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      Counter\n    </td>\n    <td>\n      <!--\n      Demonstrates a combination of a component and a directive\n      each with its own hooks.\n      -->\n<p>      컴포넌트와 디렉티브를 함께 사용하면서 라이프싸이클 후킹 함수를 각각 활용하는 경우를 살펴봅니다.</p>\n      <!--\n      In this example, a `CounterComponent` logs a change (via `ngOnChanges`)\n      every time the parent component increments its input counter property.\n      Meanwhile, the `SpyDirective` from the previous example is applied\n      to the `CounterComponent` log where it watches log entries being created and destroyed.\n      -->\n<p>      이 예제에서 <code>CounterComponent</code>는 부모 컴포넌트가 전달하는 입력 프로퍼티가 변경될 때마다 <code>ngOnChanges</code> 함수를 통해 로그를 출력합니다. 그리고 이전 예제에서 사용되었던 <code>SpyDirective</code>가 <code>CounterComponent</code>에도 적용되어, 디렉티브가 생성되거나 종료되는 시점을 로그로 출력합니다.</p>\n    </td>\n  </tr>\n</tbody></table>\n<!--\nThe remainder of this page discusses selected exercises in further detail.\n-->\n<p>이제부터는 각각의 예제를 좀 더 자세하게 알아봅시다.</p>\n<a id=\"peek-a-boo\"></a>\n<!--\n## Peek-a-boo: all hooks\n-->\n<h2 id=\"peek-a-boo-모든-라이프싸이클-후킹-함수\">Peek-a-boo: 모든 라이프싸이클 후킹 함수<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#peek-a-boo-모든-라이프싸이클-후킹-함수\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe `PeekABooComponent` demonstrates all of the hooks in one component.\n-->\n<p><code>PeekABooComponent</code>는 컴포넌트에서 발생하는 라이프싸이클 후킹 함수를 모두 다룹니다.</p>\n<!--\nYou would rarely, if ever, implement all of the interfaces like this.\nThe peek-a-boo exists to show how Angular calls the hooks in the expected order.\n-->\n<p>라이프싸이클 후킹 함수를 모두 구현하는 경우는 많지 않지만, 혹시 필요하다면 이 컴포넌트를 참고하면 됩니다.\n그리고 이 컴포넌트를 보면 Angular 라이프싸이클 후킹 함수가 어떤 순서로 실행되는지도 확인할 수 있습니다.</p>\n<!--\nThis snapshot reflects the state of the log after the user clicked the *Create...* button and then the *Destroy...* button.\n-->\n<p>사용자가 <em>Create...</em> 버튼을 클릭한 시점부터 <em>Destroy...</em> 버튼을 클릭하는 시점까지 출력하는 로그는 아래 그림으로 확인할 수 있습니다.</p>\n<figure>\n  <img src=\"generated/images/guide/lifecycle-hooks/peek-a-boo.png\" alt=\"Peek-a-boo\" width=\"309\" height=\"366\">\n</figure>\n<!--\nThe sequence of log messages follows the prescribed hook calling order:\n`OnChanges`, `OnInit`, `DoCheck`&nbsp;(3x), `AfterContentInit`, `AfterContentChecked`&nbsp;(3x),\n`AfterViewInit`, `AfterViewChecked`&nbsp;(3x), and `OnDestroy`.\n-->\n<p>이전에 설명했듯이, 라이프싸이클 후킹 함수는 다음과 같은 순서로 실행됩니다:\n<code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a></code>, <code><a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a></code>, <code><a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a></code> (3번), <code><a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a></code>, <code><a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a></code> (3번),\n<code><a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a></code>, <code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a></code> (3번), <code><a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a></code>.</p>\n<div class=\"alert is-helpful\">\n  <!--\n  The constructor isn't an Angular hook *per se*.\n  The log confirms that input properties (the `name` property in this case) have no assigned values at construction.\n  -->\n<p>  생성자 함수 자체는 Angular의 라이프싸이클이 아닙니다.\n그래서 생성자에서 확인하는 <code>name</code> 프로퍼티의 값은 아직 할당되지 않았습니다.</p>\n</div>\n<!--\nHad the user clicked the *Update Hero* button, the log would show another `OnChanges` and two more triplets of\n`DoCheck`, `AfterContentChecked` and `AfterViewChecked`.\nClearly these three hooks fire *often*. Keep the logic in these hooks as lean as possible!\n-->\n<p>사용자가 <em>Update Hero</em> 버튼을 클릭하면 <code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a></code> 함수와 <code><a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a></code>, <code><a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a></code>, <code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a></code> 함수가 연달아 실행되면서 로그를 출력합니다.\n이 함수들은 컴포넌트가 변화할 때마다 <em>계속</em> 실행됩니다. 그래서 각각의 함수에는 간결한 로직만 작성하는 것이 좋습니다!</p>\n<!--\nThe next examples focus on hook details.\n-->\n<p>그리고 다음 예제부터는 각각의 라이프싸이클 후킹 함수를 자세하게 다룹니다.</p>\n<a id=\"spy\"></a>\n<!--\n## Spying *OnInit* and *OnDestroy*\n-->\n<h2 id=\"oninit과-ondestroy-후킹하기\"><em>OnInit</em>과 <em>OnDestroy</em> 후킹하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#oninit과-ondestroy-후킹하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nGo undercover with these two spy hooks to discover when an element is initialized or destroyed.\n-->\n<p>엘리먼트가 생성되거나 종료되는 시점은 이 두 인터페이스를 활용해서 확인할 수 있습니다.</p>\n<!--\nThis is the perfect infiltration job for a directive.\nThe heroes will never know they're being watched.\n-->\n<p>이 예제에서는 디렉티브의 생성과 종료를 확인할 수 있는 스파이 디렉티브를 만들어 봅니다.</p>\n<div class=\"alert is-helpful\">\n  <!--\n  Kidding aside, pay attention to two key points:\n  -->\n<p>  다음 두 가지 내용을 기억해 두세요:</p>\n  <!--\n  1. Angular calls hook methods for *directives* as well as components.<br><br>\n  -->\n<ol>\n<li>\n<p>Angular에서 <em>디렉티브</em>에 적용되는 라이프싸이클 후킹 메소드는 컴포넌트에도 똑같이 적용됩니다.<br><br></p>\n<!--\n</li>\n<li>\n<p>A spy directive can provide insight into a DOM object that you cannot change directly.\nObviously you can't touch the implementation of a native <code>&#x3C;div></code>.\nYou can't modify a third party component either.\nBut you can watch both with a directive.\n--><p></p>\n</li>\n<li>\n<p>라이프싸이클 후킹 함수를 활용하면 컴포넌트에서 사용하는 DOM 객체에 직접 접근할 수 있습니다.\n하지만 네이티브 <code>&#x3C;div></code>와 같은 엘리먼트가 어떻게 생성되는지 변경하는 것은 불가능하며, 서드파티 컴포넌트도 직접 수정할 수는 없습니다.\n이 때 DOM 접근에 접근할 수 있다는 것은 수정 없이 DOM 객체를 확인하는 것만 가능합니다.</p>\n</li>\n</ol>\n</div>\n<!--\nThe sneaky spy directive is simple, consisting almost entirely of `ngOnInit()` and `ngOnDestroy()` hooks\nthat log messages to the parent via an injected `LoggerService`.\n-->\n<p>스파이 디렉티브는 간단합니다. 이 디렉티브는 <code>ngOnInit()</code> 함수와 <code>ngOnDestroy()</code> 후킹 함수를 구현하고 의존성으로 주입되는 <code>LoggerService</code>를 활용해서 브라우저에 로그를 출력합니다.</p>\n<code-example path=\"lifecycle-hooks/src/app/spy.directive.ts\" region=\"spy-directive\" header=\"src/app/spy.directive.ts\" linenums=\"false\">\n// 엘리먼트에 스파이 디렉티브를 자유롭게 적용합니다.\n// 사용방법: &#x3C;div mySpy>...&#x3C;/div>\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({selector: '[mySpy]'})\nexport class SpyDirective implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>, <a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a> {\n\n  constructor(private logger: LoggerService) { }\n\n  ngOnInit()    { this.logIt(`onInit`); }\n\n  ngOnDestroy() { this.logIt(`onDestroy`); }\n\n  private logIt(msg: string) {\n    this.logger.log(`Spy #${nextId++} ${msg}`);\n  }\n}\n\n</code-example>\n<!--\nYou can apply the spy to any native or component element and it'll be initialized and destroyed\nat the same time as that element.\nHere it is attached to the repeated hero `<div>`:\n-->\n<p>이 디렉티브는 네이티브 엘리먼트나 커스텀 컴포넌트 어느곳에라도 적용할 수 있으며, 이 디렉티브가 적용된 엘리먼트가 생성될 때 함께 생성되고 엘리먼트가 종료될 때 이 디렉티브도 함께 종료됩니다.\n<code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>로 반복되는 <code>&#x3C;div></code>에는 다음과 같이 적용할 수 있습니다:</p>\n<code-example path=\"lifecycle-hooks/src/app/spy.component.html\" region=\"template\" header=\"src/app/spy.component.html\" linenums=\"false\">\n&#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\" mySpy class=\"heroes\">\n  {{hero}}\n&#x3C;/div>\n\n</code-example>\n<!--\nEach spy's birth and death marks the birth and death of the attached hero `<div>`\nwith an entry in the *Hook Log* as seen here:\n-->\n<p>각 스파이 디렉티브가 생성되고 종료되는 시점은 이 디렉티브가 적용된 <code>&#x3C;div></code> 엘리먼트가 생성되고 종료되는 시점과 같습니다.\n이 내용을 로그로 확인해 보세요:</p>\n<figure>\n  <img src=\"generated/images/guide/lifecycle-hooks/spy-directive.gif\" alt=\"Spy Directive\" width=\"656\" height=\"378\">\n</figure>\n<!--\nAdding a hero results in a new hero `<div>`. The spy's `ngOnInit()` logs that event.\n-->\n<p>히어로를 목록에 추가하면 새로운 히어로에 해당되는 <code>&#x3C;div></code>가 생성됩니다. 그러면 스파이 디렉티브의 <code>ngOnInit()</code>에서 로그를 출력합니다.</p>\n<!--\nThe *Reset* button clears the `heroes` list.\nAngular removes all hero `<div>` elements from the DOM and destroys their spy directives at the same time.\nThe spy's `ngOnDestroy()` method reports its last moments.\n-->\n<p><em>Reset</em> 버튼은 <code>heroes</code> 리스트를 초기화합니다.\n그러면 Angular가 히어로에 해당하는 <code>&#x3C;div></code> 엘리먼트를 DOM에서 제거하며, 이 때 스파이 디렉티브도 함께 종료됩니다.\n스파이 디렉티브가 종료될 때 <code>ngOnDestroy()</code> 메소드가 실행됩니다.</p>\n<!--\nThe `ngOnInit()` and `ngOnDestroy()` methods have more vital roles to play in real applications.\n-->\n<p><code>ngOnInit()</code> 함수와 <code>ngOnDestroy()</code> 함수는 실제 업무용 애플리케이션에도 중요하게 사용됩니다.</p>\n<a id=\"oninit\"></a>\n<!--\n### _OnInit()_\n-->\n<h3 id=\"oninit\"><em>OnInit</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#oninit\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nUse `ngOnInit()` for two main reasons:\n-->\n<p><code>ngOnInit()</code> 함수는 다음 두 용도로 사용합니다:</p>\n<!--\n1. To perform complex initializations shortly after construction.\n1. To set up the component after Angular sets the input properties.\n-->\n<ol>\n<li>생성자가 이후에 실행되어야 하는 초기화 로직이 복잡할 때</li>\n<li>Angular가 입력 프로퍼티 값을 설정한 이후 컴포넌트에 추가 로직이 필요할 때</li>\n</ol>\n<!--\nExperienced developers agree that components should be cheap and safe to construct.\n-->\n<p>숙련된 개발자라면 컴포넌트의 생성자는 최대한 간결하게 작성해야 한다는 것에 동의할 것입니다.</p>\n<div class=\"alert is-helpful\">\n  <!--\n  Misko Hevery, Angular team lead,\n  [explains why](http://misko.hevery.com/code-reviewers-guide/flaw-constructor-does-real-work/)\n  you should avoid complex constructor logic.\n  -->\n<p>  Angular 팀 리더인 Misko Hevery가 <a href=\"http://misko.hevery.com/code-reviewers-guide/flaw-constructor-does-real-work/\">생성자를 왜 간단하게 작성해야 하는지</a> 언급한 내용을 확인해 보세요.</p>\n</div>\n<!--\nDon't fetch data in a component constructor.\nYou shouldn't worry that a new component will try to contact a remote server when\ncreated under test or before you decide to display it.\nConstructors should do no more than set the initial local variables to simple values.\n-->\n<p>서버에서 데이터를 받아오는 로직은 컴포넌트 생성자에 작성하지 마세요.\n컴포넌트가 생성될 때 서버에서 데이터를 받아온다면 생성자를 활용하는 것이 좋은 방법이라고 생각하기 쉽습니다.\n하지만 생성자에는 지역 변수를 간단하게 초기화하는 로직만 두는 것이 좋습니다.</p>\n<!--\nAn `ngOnInit()` is a good place for a component to fetch its initial data. The\n[Tour of Heroes Tutorial](tutorial/toh-pt4#oninit) guide shows how.\n-->\n<p>서버에서 받아오는 데이터로 컴포넌트를 초기화해야 한다면, 이 로직은 <code>ngOnInit()</code>에 작성하는 것이 좋습니다.\n<a href=\"tutorial/toh-pt4#oninit\">히어로들의 여정 튜토리얼</a>도 확인해 보세요.</p>\n<!--\nRemember also that a directive's data-bound input properties are not set until _after construction_.\nThat's a problem if you need to initialize the directive based on those properties.\nThey'll have been set when `ngOnInit()` runs.\n-->\n<p>디렉티브에 입력 프로퍼티가 있을 때 이 입력 프로퍼티의 값은 <em>생성자가 실행된 후</em> 에 반영된다는 것도 잊지 마세요.\n입력 프로퍼티의 값이 반영되는 것은 Angular의 라이프싸이클을 따르기 때문에 JavaScript에서 제공하는 생성자에서 이 입력 프로퍼티 값을 사용할 수 없습니다.\n<code>ngOnInit()</code>이 실행되는 시점이라면 입력 프로퍼티 값이 모두 반영된 이후입니다.</p>\n<div class=\"alert is-helpful\">\n  <!--\n  The `ngOnChanges()` method is your first opportunity to access those properties.\n  Angular calls `ngOnChanges()` before `ngOnInit()` and many times after that.\n  It only calls `ngOnInit()` once.\n  -->\n<p>  입력 프로퍼티 값을 확인할 수 있는 가장 빠른 시점은 <code>ngOnChanges()</code> 메소드입니다.\nAngular의 라이프싸이클 후킹 함수 순서에 따르면 <code>ngOnInit()</code> 함수가 실행되기 전에 <code>ngOnChanges()</code> 함수가 먼저 실행되기 때문입니다.\n그리고 <code>ngOnChanges()</code> 함수는 입력 프로퍼티 값이 변경될 때마다 계속 실행되지만 <code>ngOnInit()</code> 함수는 한 번만 실행됩니다.</p>\n</div>\n<!--\nYou can count on Angular to call the `ngOnInit()` method _soon_ after creating the component.\nThat's where the heavy initialization logic belongs.\n-->\n<p><code>ngOnInit()</code> 메소드는 컴포넌트가 생성된 <em>직후에</em> 실행되기 때문에 생성자가 실행되는 시점과 많이 차이나지 않습니다.</p>\n<a id=\"ondestroy\"></a>\n<!--\n### _OnDestroy()_\n-->\n<h3 id=\"ondestroy\"><em>OnDestroy</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#ondestroy\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nPut cleanup logic in `ngOnDestroy()`, the logic that *must* run before Angular destroys the directive.\n-->\n<p>Angular가 디렉티브를 종료하기 전에 <em>꼭 실행되어야 하는</em> 로직은 <code>ngOnDestroy()</code>에 작성합니다.</p>\n<!--\nThis is the time to notify another part of the application that the component is going away.\n-->\n<p>그리고 이 시점은 컴포넌트가 종료되는 것을 애플리케이션의 다른 부분에 전파할 수 있는 시점이기도 합니다.</p>\n<!--\nThis is the place to free resources that won't be garbage collected automatically.\nUnsubscribe from Observables and DOM events. Stop interval timers.\nUnregister all callbacks that this directive registered with global or application services.\nYou risk memory leaks if you neglect to do so.\n-->\n<p>JavaScript 환경은 필요없는 자원을 자동으로 정리하지만, 정리해야 하는 자원이 그 외에 추가로 있다면 이 함수에 작성하는 것이 좋습니다.\n옵저버블이나 DOM 이벤트를 구독한 것을 해제하거나, 타이머를 종료하는 로직, 서비스나 디렉티브에 등록된 콜백 함수를 해제하는 것도 이 함수에서 하는 것이 좋습니다.\n수동으로 정리해야 하는 항목을 정리하지 않으면 메모리 누수의 위험이 있습니다.</p>\n<a id=\"onchanges\"></a>\n<!--\n## _OnChanges()_\n-->\n<h2 id=\"onchanges\"><em>OnChanges</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#onchanges\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAngular calls its `ngOnChanges()` method whenever it detects changes to ***input properties*** of the component (or directive).\nThis example monitors the `OnChanges` hook.\n-->\n<p>컴포넌트나 디렉티브의 <strong><em>입력 프로퍼티</em></strong> 값이 변경될 때마다 Angular는 <code>ngOnChanges()</code> 메소드를 실행합니다.\n<code>OnChagnes</code> 후킹 함수를 활용하는 간단한 방법은 다음과 같습니다.</p>\n<code-example path=\"lifecycle-hooks/src/app/on-changes.component.ts\" region=\"ng-on-changes\" header=\"on-changes.component.ts (excerpt)\" linenums=\"false\">\nngOnChanges(<a href=\"api/core/QueryList#changes\" class=\"code-anchor\">changes</a>: <a href=\"api/core/SimpleChanges\" class=\"code-anchor\">SimpleChanges</a>) {\n  for (let propName in <a href=\"api/core/QueryList#changes\" class=\"code-anchor\">changes</a>) {\n    let chng = <a href=\"api/core/QueryList#changes\" class=\"code-anchor\">changes</a>[propName];\n    let cur  = JSON.stringify(chng.currentValue);\n    let prev = JSON.stringify(chng.previousValue);\n    this.changeLog.push(`${propName}: currentValue = ${cur}, previousValue = ${prev}`);\n  }\n}\n\n</code-example>\n<!--\nThe `ngOnChanges()` method takes an object that maps each changed property name to a\n[SimpleChange](api/core/SimpleChange) object holding the current and previous property values.\nThis hook iterates over the changed properties and logs them.\n-->\n<p><code>ngOnChanges()</code> 메소드는 <a href=\"api/core/SimpleChange\">SimpleChange</a> 타입의 객체를 인자로 받으며, 이 객체 안에는 입력 프로퍼티의 이전 값과 현재 값이 포함되어 있습니다.\n위 예제는 이 값들을 로그로 출력하는 간단한 예제입니다.</p>\n<!--\nThe example component, `OnChangesComponent`, has two input properties: `hero` and `power`.\n-->\n<p>이번에 예제로 만드는 <code>OnChangesComponent</code>에는 <code>hero</code>와 <code>power</code>라는 입력 프로퍼티가 2개 있습니다.</p>\n<code-example path=\"lifecycle-hooks/src/app/on-changes.component.ts\" region=\"inputs\" header=\"src/app/on-changes.component.ts\" linenums=\"false\">\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() power: string;\n\n</code-example>\n<!--\nThe host `OnChangesParentComponent` binds to them like this:\n-->\n<p>그리고 부모 컴포넌트인 <code>OnChangesParentComponent</code>는 이 컴포넌트를 이렇게 바인딩합니다:</p>\n<code-example path=\"lifecycle-hooks/src/app/on-changes-parent.component.html\" region=\"on-changes\" header=\"src/app/on-changes-parent.component.html\">\n&#x3C;on-changes [hero]=\"hero\" [power]=\"power\">&#x3C;/on-changes>\n\n</code-example>\n<!--\nHere's the sample in action as the user makes changes.\n-->\n<p>그리고 사용자가 문자열을 입력하면 다음과 같은 로그를 확인할 수 있습니다.</p>\n<figure>\n  <img src=\"generated/images/guide/lifecycle-hooks/on-changes-anim.gif\" alt=\"OnChanges\" width=\"632\" height=\"512\">\n</figure>\n<!--\nThe log entries appear as the string value of the *power* property changes.\nBut the `ngOnChanges` does not catch changes to `hero.name`\nThat's surprising at first.\n-->\n<p>이 로그를 보면 <em>power</em> 프로퍼티의 값이 변경될 때마다 <code>ngOnChanges()</code> 함수가 실행되는 것을 확인할 수 있습니다.\n하지만 <code>hero.name</code> 값은 변경되어도 <code>ngOnChanges()</code> 함수가 실행되지 않습니다.\n이 결과를 처음 보면 당황스러울 수 있습니다.</p>\n<!--\nAngular only calls the hook when the value of the input property changes.\nThe value of the `hero` property is the *reference to the hero object*.\nAngular doesn't care that the hero's own `name` property changed.\nThe hero object *reference* didn't change so, from Angular's perspective, there is no change to report!\n-->\n<p>Angular는 입력 프로퍼티 값이 변경되었을 때만 <code>ngOnChangaes()</code> 함수를 실행합니다.\n하지만 <code>hero</code> 프로퍼티는 객체가 전달되기 때문에 프로퍼티 값은 <em>객체의 참조</em>값으로 할당됩니다.\n그래서 <code>hero</code> 객체 안에 있는 <code>name</code> 값이 변경되는 것은 Angular가 신경쓰지 않습니다.\n객체가 인자로 전달될 때는 <em>참조하는 주소 자체가</em> 변경되지 않는 이상 값이 변경된 것으로 처리하지 않습니다.</p>\n<a id=\"docheck\"></a>\n<!--\n## _DoCheck()_\n-->\n<h2 id=\"docheck\"><em>DoCheck</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#docheck\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nUse the `DoCheck` hook to detect and act upon changes that Angular doesn't catch on its own.\n-->\n<p>Angular의 변화 감지 싸이클을 수동으로 실행하는 경우라면 <code><a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a></code> 함수를 사용할 수 있습니다.</p>\n<div class=\"alert is-helpful\">\n  <!--\n  Use this method to detect a change that Angular overlooked.\n  -->\n<p>  이 함수는 Angular가 감지하지 못하는 변화를 감지하는 용도로 사용합니다.</p>\n</div>\n<!--\nThe *DoCheck* sample extends the *OnChanges* sample with the following `ngDoCheck()` hook:\n-->\n<p>이번에 살펴볼 <em>DoCheck</em> 예제는 <em>OnChanges</em> 예제에서 살펴봤던 <code>ngDoCheck()</code> 후킹 함수를 확장한 것입니다:</p>\n<code-example path=\"lifecycle-hooks/src/app/do-check.component.ts\" region=\"ng-do-check\" header=\"DoCheckComponent (ngDoCheck)\" linenums=\"false\">\nngDoCheck() {\n\n  if (this.hero.name !== this.oldHeroName) {\n    this.changeDetected = true;\n    this.changeLog.push(`<a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a>: Hero name changed to \"${this.hero.name}\" from \"${this.oldHeroName}\"`);\n    this.oldHeroName = this.hero.name;\n  }\n\n  if (this.power !== this.oldPower) {\n    this.changeDetected = true;\n    this.changeLog.push(`<a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a>: Power changed to \"${this.power}\" from \"${this.oldPower}\"`);\n    this.oldPower = this.power;\n  }\n\n  if (this.changeDetected) {\n      this.noChangeCount = 0;\n  } else {\n      // 컴포넌트의 내용이 변경되지 않았으면 함수가 몇번 실행되었는지 로그를 출력합니다.\n      let <a href=\"api/common/NgForOfContext#count\" class=\"code-anchor\">count</a> = this.noChangeCount += 1;\n      let noChangeMsg = `<a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a> called ${<a href=\"api/common/NgForOfContext#count\" class=\"code-anchor\">count</a>}x when no change to hero or power`;\n      if (<a href=\"api/common/NgForOfContext#count\" class=\"code-anchor\">count</a> === 1) {\n        // \"no change\" 메시지를 추가합니다.\n        this.changeLog.push(noChangeMsg);\n      } else {\n        // 마지막에 추가한 \"no change\" 메시지를 수정합니다.\n        this.changeLog[this.changeLog.length - 1] = noChangeMsg;\n      }\n  }\n\n  this.changeDetected = false;\n}\n\n</code-example>\n<!--\nThis code inspects certain _values of interest_, capturing and comparing their current state against previous values.\nIt writes a special message to the log when there are no substantive changes to the `hero` or the `power`\nso you can see how often `DoCheck` is called. The results are illuminating:\n-->\n<p>예제 코드가 조금 복잡해 보이지만, 이 예제는 이전값과 현재값을 비교해서 값이 변경되었는지 검사하는 코드입니다.\n이 코드는 <code><a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a></code> 인터페이스에 의해 <code>ngDoCheck()</code> 함수가 실행될 때마다 <code>hero</code>와 <code>power</code>의 값을 비교하고, 값이 변경된 것으로 확인되면 로그를 출력합니다. 그림으로 결과를 확인해 보세요:</p>\n<figure>\n  <img src=\"generated/images/guide/lifecycle-hooks/do-check-anim.gif\" alt=\"DoCheck\" width=\"632\" height=\"588\">\n</figure>\n<!--\nWhile the `ngDoCheck()` hook can detect when the hero's `name` has changed, it has a frightful cost.\nThis hook is called with enormous frequency&mdash;after _every_\nchange detection cycle no matter where the change occurred.\nIt's called over twenty times in this example before the user can do anything.\n-->\n<p>하지만 <code>ngDoCheck()</code> 함수에서 히어로의 <code>name</code> 프로퍼티가 변경되는 것을 확인하는 것은 비효율적입니다.\n왜냐하면 이 함수는 프로퍼티 값이 변하지 않더라도 Angular의변화 감지 싸이클이 <em>실행될 때마다</em> 계속 실행되기 때문입니다.\n위 예제에서도 보면 사용자가 의미있는 동작을 하지 않더라도 20번 이상 실행되는 것을 확인할 수 있습니다.</p>\n<!--\nMost of these initial checks are triggered by Angular's first rendering of *unrelated data elsewhere on the page*.\nMere mousing into another `<input>` triggers a call.\nRelatively few calls reveal actual changes to pertinent data.\nClearly our implementation must be very lightweight or the user experience suffers.\n-->\n<p>이 예제에서 첫 렌더링될 때 이렇게 많은 함수가 실행된 것은 <em>페이지와 관계없는 데이터</em> 에 의한 것일 수도 있습니다.\n예를 들면, <code>&#x3C;input></code> 엘리먼트에 마우스 동작이 있을 때도 이 함수가 실행됩니다.\n따라서 컴포넌트 프로퍼티값이 변한 것을 수동으로 감지할 때는 꼭 필요한 곳에만, 최대한 간단한 로직으로 작성해야 사용자가 불편함을 느끼지 않습니다.</p>\n<a id=\"afterview\"></a>\n<h2 id=\"afterview\">AfterView<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#afterview\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe *AfterView* sample explores the `AfterViewInit()` and `AfterViewChecked()` hooks that Angular calls\n*after* it creates a component's child views.\n-->\n<p><em>AfterView</em> 예제는 Angular가 자식 컴포넌트의 뷰를 생성한 <em>이후</em>인 <code><a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a></code>과 <code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a></code> 에 대해 다룹니다.</p>\n<!--\nHere's a child view that displays a hero's name in an `<input>`:\n-->\n<p>자식 컴포넌트에서 <code>&#x3C;input></code> 엘리먼트에 히어로의 이름을 받는다고 합시다:</p>\n<code-example path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"child-view\" header=\"ChildComponent\" linenums=\"false\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-child-view',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: '&#x3C;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero\">'\n})\nexport class ChildViewComponent {\n  hero = 'Magneta';\n}\n\n</code-example>\n<!--\nThe `AfterViewComponent` displays this child view *within its template*:\n-->\n<p>그리고 <code>AfterViewComponent</code>는 <em>이 컴포넌트의 템플릿에</em> 자식 컴포넌트 뷰를 표시합니다:</p>\n<code-example path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"template\" header=\"AfterViewComponent (template)\" linenums=\"false\">\n<a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n  &#x3C;div>-- child view begins --&#x3C;/div>\n    &#x3C;app-child-view>&#x3C;/app-child-view>\n  &#x3C;div>-- child view ends --&#x3C;/div>`\n\n</code-example>\n<!--\nThe following hooks take action based on changing values *within the child view*,\nwhich can only be reached by querying for the child view via the property decorated with\n[@ViewChild](api/core/ViewChild).\n-->\n<p>마지막으로 다음 코드는 <em>자식 컴포넌트 뷰</em>가 변경될 때마다 <a href=\"api/core/ViewChild\">@ViewChild</a>로 지정된 프로퍼티를 통해 자식 컴포넌트에 있는 <code>hero</code> 객체를 가져와서 동작을 수행할 수 있는 예제 코드입니다.</p>\n<code-example path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"hooks\" header=\"AfterViewComponent (class excerpts)\" linenums=\"false\">\nexport class AfterViewComponent implements  <a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>, <a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a> {\n  private prevHero = '';\n\n  // `ChildViewComponent` 타입의 뷰 차일드를 참조합니다.\n  @<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>(ChildViewComponent) viewChild: ChildViewComponent;\n\n  ngAfterViewInit() {\n    // viewChild는 뷰가 모두 초기화된 이후에 값이 할당됩니다.\n    this.logIt('<a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a>');\n    this.doSomething();\n  }\n\n  ngAfterViewChecked() {\n    // 뷰에서 변화감지 로직이 동작하면 viewChild가 갱신됩니다.\n    if (this.prevHero === this.viewChild.hero) {\n      this.logIt('<a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a> (no change)');\n    } else {\n      this.prevHero = this.viewChild.hero;\n      this.logIt('<a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>');\n      this.doSomething();\n    }\n  }\n  // ...\n}\n\n</code-example>\n<a id=\"wait-a-tick\"></a>\n<!--\n### Abide by the unidirectional data flow rule\n-->\n<h3 id=\"단방향-데이터-흐름-유지\">단방향 데이터 흐름 유지<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#단방향-데이터-흐름-유지\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe `doSomething()` method updates the screen when the hero name exceeds 10 characters.\n-->\n<p><code>doSomething()</code> 메소드는 히어로의 이름이 10글자를 넘어가면 화면에 에러 메시지를 표시합니다.</p>\n<code-example path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"do-something\" header=\"AfterViewComponent (doSomething)\" linenums=\"false\">\n// 동작을 확인하기 위해 `comment` 값을 변경해 봅니다.\nprivate doSomething() {\n  let c = this.viewChild.hero.length > 10 ? `That's <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> long name` : '';\n  if (c !== this.comment) {\n    // 컴포넌트의 뷰는 방금 검사를 마쳤기 때문에 한 싸이클 뒤에 실행합니다.\n    this.logger.tick_then(() => this.comment = c);\n  }\n}\n\n</code-example>\n<!--\nWhy does the `doSomething()` method wait a tick before updating `comment`?\n-->\n<p>그런데 <code>doSomething()</code> 메소드는 <code>comment</code> 프로퍼티에 값을 할당하기 전에 왜 한 타이밍을 기다릴까요?</p>\n<!--\nAngular's unidirectional data flow rule forbids updates to the view *after* it has been composed.\nBoth of these hooks fire _after_ the component's view has been composed.\n-->\n<p>Angular는 단방향 데이터 흐름을 권장하기 때문에 뷰가 구성된 <em>직후에</em> 뷰를 다시 갱신하는 것은 권장하지 않습니다.\n그리고 <code><a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a></code>과 <code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a></code> 함수는 컴포넌트의 뷰가 구성된 <em>직후에</em> 실행됩니다.</p>\n<!--\nAngular throws an error if the hook updates the component's data-bound `comment` property immediately (try it!).\nThe `LoggerService.tick_then()` postpones the log update\nfor one turn of the browser's JavaScript cycle and that's just long enough.\n-->\n<p>그래서 컴포넌트 뷰가 구성된 직후에 바로 <code>comment</code> 프로퍼티 값을 수정하면 Angular가 에러를 발생시킵니다. (한 번 해보세요!)\n이 문제를 해결하기 위해 <code>LoggerService.tick_then()</code>에 있는 함수를 사용했고, 이 함수를 사용해서 다음 브라우저의 JavaScript 싸이클에 <code>comment</code> 프로퍼티 값을 갱신하도록 했습니다.</p>\n<!--\nHere's *AfterView* in action:\n-->\n<p><em>AfterView</em> 후킹 인터페이스가 어떻게 동작하는지 확인해 보세요:</p>\n<figure>\n  <img src=\"generated/images/guide/lifecycle-hooks/after-view-anim.gif\" alt=\"AfterView\" width=\"520\" height=\"532\">\n</figure>\n<!--\nNotice that Angular frequently calls `AfterViewChecked()`, often when there are no changes of interest.\nWrite lean hook methods to avoid performance problems.\n-->\n<p>이 결과를 보면 별다른 변화가 없을 때도 <code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a></code> 후킹 함수가 여러번 실행되는 것을 확인할 수 있습니다.\n성능 문제를 피하려면 후킹 함수에는 간단한 로직만 작성하세요.</p>\n<a id=\"aftercontent\"></a>\n<h2 id=\"aftercontent\">AfterContent<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#aftercontent\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe *AfterContent* sample explores the `AfterContentInit()` and `AfterContentChecked()` hooks that Angular calls\n*after* Angular projects external content into the component.\n-->\n<p><em>AfterContent</em> 예제는 Angular가 컴포넌트 안에 외부 컨텐츠를 넣은 이후에 실행되는 <code><a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a></code>과 <code><a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a></code> 후킹 인터페이스를 다룹니다.</p>\n<a id=\"content-projection\"></a>\n<!--\n### Content projection\n-->\n<h3 id=\"컨텐츠-프로젝션\">컨텐츠 프로젝션<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#컨텐츠-프로젝션\"><i class=\"material-icons\">link</i></a></h3>\n<!--\n*Content projection* is a way to import HTML content from outside the component and insert that content\ninto the component's template in a designated spot.\n-->\n<p><em>컨텐츠 프로젝션</em>은 컴포넌트의 템플릿을 정의하는 외부 HTML 파일을 컴포넌트 안에 가져와서 컴포넌트 템플릿에 반영하는 것을 의미합니다.</p>\n<div class=\"alert is-helpful\">\n  <!--\n  AngularJS developers know this technique as *transclusion*.\n  -->\n<p>  이 개념은 AngularJS에서 <em>트랜스클루전(transclusion)</em>이라는 개념으로 사용했습니다.</p>\n</div>\n<!--\nConsider this variation on the [previous _AfterView_](guide/lifecycle-hooks#afterview) example.\nThis time, instead of including the child view within the template, it imports the content from\nthe `AfterContentComponent`'s parent. Here's the parent's template:\n-->\n<p>이 예제는 이전에 다뤘던 <a href=\"guide/lifecycle-hooks#afterview\"><em>AfterView</em></a> 예제를 변형한 것입니다.\n이전 예제에서 템플릿에 자식 컴포넌트의 뷰를 직접 표시했던 대신, 이번 예제는 <code>AfterContentComponent</code>의 부모 컴포넌트에서 컨텐츠를 받아옵니다.\n부모 컴포넌트의 템플릿은 이렇습니다:</p>\n<code-example path=\"lifecycle-hooks/src/app/after-content.component.ts\" region=\"parent-template\" header=\"AfterContentParentComponent (template excerpt)\" linenums=\"false\">\n`&#x3C;after-content>\n   &#x3C;app-child>&#x3C;/app-child>\n &#x3C;/after-content>`\n\n</code-example>\n<!--\nNotice that the `<app-child>` tag is tucked between the `<after-content>` tags.\nNever put content between a component's element tags *unless you intend to project that content\ninto the component*.\n-->\n<p><code>&#x3C;after-content></code> 태그 안에 있는 <code>&#x3C;my-child></code> 태그를 주의해서 보세요.\n<em>컴포넌트 외부에서 전달하는 컨텐츠를 컴포넌트 안에 표시하려고 하지만</em> 컴포넌트를 의미하는 엘리먼트 태그 안에는 아무 내용도 넣지 않았습니다.</p>\n<!--\nNow look at the component's template:\n-->\n<p>그리고 <code>AfterContentComponent</code> 컴포넌트의 템플릿은 다음과 같이 구성했습니다:</p>\n<code-example path=\"lifecycle-hooks/src/app/after-content.component.ts\" region=\"template\" header=\"AfterContentComponent (template)\" linenums=\"false\">\n<a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n  &#x3C;div>-- projected content begins --&#x3C;/div>\n    &#x3C;ng-content>&#x3C;/ng-content>\n  &#x3C;div>-- projected content ends --&#x3C;/div>`\n\n</code-example>\n<!--\nThe `<ng-content>` tag is a *placeholder* for the external content.\nIt tells Angular where to insert that content.\nIn this case, the projected content is the `<app-child>` from the parent.\n-->\n<p><code>&#x3C;ng-content></code> 태그는 외부 컨텐츠가 <em>들어갈 위치</em>를 지정하는 태그입니다.\nAngular가 이 태그를 확인하면 컴포넌트 외부에서 전달되는 컨텐츠를 이 위치에 표시하며, 이 예제에서 부모 컴포넌트가 자식 컴포넌트로 전달하는 컨텐츠는 <code>&#x3C;my-child></code> 엘리먼트입니다.</p>\n<figure>\n  <img src=\"generated/images/guide/lifecycle-hooks/projected-child-view.png\" alt=\"Projected Content\" width=\"230\" height=\"89\">\n</figure>\n<div class=\"alert is-helpful\">\n  <!--\n  The telltale signs of *content projection* are twofold:\n\n  * HTML between component element tags.\n  * The presence of `<ng-content>` tags in the component's template.\n  -->\n<p>  <em>컨텐츠 프로젝션</em>이 사용된 것은 다음 두 가지로 확인할 수 있습니다:</p>\n<ul>\n<li>컴포넌트 엘리먼트 태그 안에 HTML이 있는 경우</li>\n<li>컴포넌트 템플릿 안에 <code>&#x3C;ng-content></code> 태그가 있는 경우</li>\n</ul>\n</div>\n<a id=\"aftercontent-hooks\"></a>\n<!--\n### AfterContent hooks\n-->\n<h3 id=\"aftercontent-후킹\">AfterContent 후킹<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#aftercontent-후킹\"><i class=\"material-icons\">link</i></a></h3>\n<!--\n*AfterContent* hooks are similar to the *AfterView* hooks.\nThe key difference is in the child component.\n-->\n<p><em>AfterContent</em> 후킹은 <em>AfterView</em> 후킹과 비슷합니다.\n자식 컴포넌트에서 발생한다는 것만 다릅니다.</p>\n<!--\n* The *AfterView* hooks concern `ViewChildren`, the child components whose element tags\nappear *within* the component's template.\n-->\n<ul>\n<li><em>AfterView</em> 후킹은 <code><a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> 데코레이터를 활용합니다. 이 데코레이터는 컴포넌트 템플릿 <em>안에 있는</em> 자식 컴포넌트를 가리킵니다.</li>\n</ul>\n<!--\n* The *AfterContent* hooks concern `ContentChildren`, the child components that Angular\nprojected into the component.\n-->\n<ul>\n<li><em>AfterContent</em> 후킹은 <code><a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> 데코레이터를 활용합니다. 이 데코레이터는 컴포넌트 안에 프로젝트된 자식 컴포넌트를 가리킵니다.</li>\n</ul>\n<!--\nThe following *AfterContent* hooks take action based on changing values in a *content child*,\nwhich can only be reached by querying for them via the property decorated with\n[@ContentChild](api/core/ContentChild).\n-->\n<p><em>AfterContent</em> 후킹은 <em>자식 컴포넌트에 반영된 컨텐츠가</em> 변경되는 것과 관계가 있으며, 이 컨텐츠 내용을 직접 할용하려면 <a href=\"api/core/ContentChild\">@ContentChild</a> 데코레이터를 사용해야 합니다.</p>\n<code-example path=\"lifecycle-hooks/src/app/after-content.component.ts\" region=\"hooks\" header=\"AfterContentComponent (class excerpts)\" linenums=\"false\">\nexport class AfterContentComponent implements <a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a>, <a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a> {\n  private prevHero = '';\n  comment = '';\n\n  // `ChildComponent` 타입의 컨텐츠 차일드를 참조합니다.\n  @<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(ChildComponent) contentChild: ChildComponent;\n\n  ngAfterContentInit() {\n    // contentChild는 컨텐츠가 모두 초기화된 이후에 값이 할당됩니다.\n    this.logIt('<a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a>');\n    this.doSomething();\n  }\n\n  ngAfterContentChecked() {\n    // 컨텐츠에서 변화감지 로직이 동작하면 contentChild가 갱신됩니다.\n    if (this.prevHero === this.contentChild.hero) {\n      this.logIt('<a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a> (no change)');\n    } else {\n      this.prevHero = this.contentChild.hero;\n      this.logIt('<a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a>');\n      this.doSomething();\n    }\n  }\n  // ...\n}\n\n</code-example>\n<a id=\"no-unidirectional-flow-worries\"></a>\n<!--\n### No unidirectional flow worries with _AfterContent_\n-->\n<h3 id=\"aftercontent-도-단방향-데이터-흐름을-따릅니다\"><em>AfterContent</em> 도 단방향 데이터 흐름을 따릅니다.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#aftercontent-도-단방향-데이터-흐름을-따릅니다\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThis component's `doSomething()` method update's the component's data-bound `comment` property immediately.\nThere's no [need to wait](guide/lifecycle-hooks#wait-a-tick).\n-->\n<p>이 컴포넌트의 <code>doSomething()</code> 메소드는 컴포넌트 프로퍼티인 <code>comment</code>의 값을 변경합니다.\n하지만 <a href=\"guide/lifecycle-hooks#wait-a-tick\">다음 실행 싸이클을 기다릴 필요</a>는 없습니다.</p>\n<!--\nRecall that Angular calls both *AfterContent* hooks before calling either of the *AfterView* hooks.\nAngular completes composition of the projected content *before* finishing the composition of this component's view.\nThere is a small window between the `AfterContent...` and `AfterView...` hooks to modify the host view.\n-->\n<p>Angular는 <em>AfterView</em> 후킹을 실행하기 전에 <em>AfterContent</em> 후킹을 실행합니다.\n그래서 자식 컴포넌트의 컴포넌트 뷰 구성이 끝나는 시점은 프로젝션될 컨텐츠가 준비된 이후입니다.\n이 과정에서 컴포넌트의 호스트 뷰가 프로젝션될 컨텐츠에 의해 갱신되기 때문에 <code>AfterContent</code>와 <code>AfterView</code> 후킹 사이에는 약간의 차이가 있기 때문에, 이전처럼 JavaScript 실행 싸이클을 조정하는 로직이 필요하지 않습니다.</p>\n\n</div>\n\n<!-- links to this doc:\n - api/core/AfterContentChecked\n - api/core/AfterContentInit\n - api/core/AfterViewChecked\n - api/core/AfterViewInit\n - api/core/Component\n - api/core/Directive\n - api/core/DoCheck\n - api/core/OnChanges\n - api/core/OnDestroy\n - api/core/OnInit\n - guide/architecture-components\n - guide/architecture-next-steps\n - guide/change-log\n - guide/component-interaction\n - guide/glossary\n - guide/testing\n - guide/upgrade\n - tutorial/toh-pt1\n - tutorial/toh-pt4\n - tutorial/toh-pt5\n-->\n<!-- links from this doc:\n - api/common/NgForOf\n - api/common/NgForOfContext#count\n - api/core/AfterContentChecked\n - api/core/AfterContentInit\n - api/core/AfterViewChecked\n - api/core/AfterViewInit\n - api/core/Component\n - api/core/Component#template\n - api/core/ContentChild\n - api/core/ContentChildren\n - api/core/Directive\n - api/core/DoCheck\n - api/core/Input\n - api/core/OnChanges\n - api/core/OnDestroy\n - api/core/OnInit\n - api/core/QueryList#changes\n - api/core/SimpleChange\n - api/core/SimpleChanges\n - api/core/ViewChild\n - api/core/ViewChildren\n - api/forms/NgForm#ngAfterViewInit\n - api/forms/NgModel\n - api/router/RouterLinkActive#ngAfterContentInit\n - api/router/RouterLinkWithHref\n - guide/lifecycle-hooks#aftercontent\n - guide/lifecycle-hooks#aftercontent-도-단방향-데이터-흐름을-따릅니다\n - guide/lifecycle-hooks#aftercontent-후킹\n - guide/lifecycle-hooks#afterview\n - guide/lifecycle-hooks#docheck\n - guide/lifecycle-hooks#onchanges\n - guide/lifecycle-hooks#ondestroy\n - guide/lifecycle-hooks#oninit\n - guide/lifecycle-hooks#oninit과-ondestroy-후킹하기\n - guide/lifecycle-hooks#peek-a-boo\n - guide/lifecycle-hooks#peek-a-boo-모든-라이프싸이클-후킹-함수\n - guide/lifecycle-hooks#spy\n - guide/lifecycle-hooks#wait-a-tick\n - guide/lifecycle-hooks#개요\n - guide/lifecycle-hooks#기타-라이프싸이클-후킹-함수\n - guide/lifecycle-hooks#단방향-데이터-흐름-유지\n - guide/lifecycle-hooks#라이프싸이클-함수-실행-순서\n - guide/lifecycle-hooks#라이프싸이클-활용-예제\n - guide/lifecycle-hooks#라이프싸이클-후킹\n - guide/lifecycle-hooks#인터페이스-구현은-옵션입니다\n - guide/lifecycle-hooks#컨텐츠-프로젝션\n - tutorial/toh-pt4#oninit\n - http://misko.hevery.com/code-reviewers-guide/flaw-constructor-does-real-work/\n - https://github.com/angular/angular/edit/master/aio/content/guide/lifecycle-hooks.md?message=docs%3A%20describe%20your%20change...\n-->"
}