{
  "id": "guide/observables",
  "title": "Using observables to pass values",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/observables.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"using-observables-to-pass-values\">Using observables to pass values<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#using-observables-to-pass-values\"><i class=\"material-icons\">link</i></a></h1>\n<p>Observables provide support for passing messages between parts of your application.\nThey are used frequently in Angular and are the recommended technique for event handling, asynchronous programming, and handling multiple values.</p>\n<p>The observer pattern is a software design pattern in which an object, called the <em>subject</em>, maintains a list of its dependents, called <em>observers</em>, and notifies them automatically of state changes.\nThis pattern is similar (but not identical) to the <a href=\"https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern\">publish/subscribe</a> design pattern.</p>\n<p>Observables are declarative—that is, you define a function for publishing values, but it is not executed until a consumer subscribes to it.\nThe subscribed consumer then receives notifications until the function completes, or until they unsubscribe.</p>\n<p>An observable can deliver multiple values of any type—literals, messages, or events, depending on the context. The API for receiving values is the same whether the values are delivered synchronously or asynchronously. Because setup and teardown logic are both handled by the observable, your application code only needs to worry about subscribing to consume values, and when done, unsubscribing. Whether the stream was keystrokes, an HTTP response, or an interval timer, the interface for listening to values and stopping listening is the same.</p>\n<p>Because of these advantages, observables are used extensively within Angular, and are recommended for app development as well.</p>\n<!--\n## Basic usage and terms\n-->\n<h2 id=\"용어-정의-사용-방법\">용어 정의, 사용 방법<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#용어-정의-사용-방법\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAs a publisher, you create an `Observable` instance that defines a *subscriber* function. This is the function that is executed when a consumer calls the `subscribe()` method. The subscriber function defines how to obtain or generate values or messages to be published.\n\nTo execute the observable you have created and begin receiving notifications, you call its `subscribe()` method, passing an *observer*. This is a JavaScript object that defines the handlers for the notifications you receive. The `subscribe()` call returns a `Subscription` object that has an `unsubscribe()` method, which you call to stop receiving notifications.\n\nHere's an example that demonstrates the basic usage model by showing how an observable could be used to provide geolocation updates.\n\n<code-example class=\"no-auto-link\" path=\"observables/src/geolocation.ts\" header=\"Observe geolocation updates\">\n\n// 구독자가 구독을 실행하면 새로운 Observable 인스턴스를 생성하고\n// 클라이언트의 접속 위치를 추적하기 시작합니다.\nconst locations = new Observable((observer) =&gt; {\n  let watchId: number;\n\n\n  // 접속 위치를 처리하는 API는 간단하게 사용해 봅니다.\n  if (&#39;geolocation&#39; in navigator) {\n    watchId = navigator.geolocation.watchPosition((position: Position) =&gt; {\n      observer.next(position);\n    }, (error: PositionError) =&gt; {\n      observer.error(error);\n    });\n  } else {\n    observer.error(&#39;Geolocation not available&#39;);\n  }\n\n  // 구독자가 구독을 해지하면 사용하던 데이터를 모두 지웁니다.\n  return {\n    unsubscribe() {\n      navigator.geolocation.clearWatch(watchId);\n    }\n  };\n});\n\n// 옵저버블을 시작하려면 subscribe() 함수를 실행합니다.\nconst locationsSubscription = locations.subscribe({\n  next(position) {\n    console.log(&#39;Current Position: &#39;, position);\n  },\n  error(msg) {\n    console.log(&#39;Error Getting Location: &#39;, msg);\n  }\n});\n\n// 옵저버블은 10초 후에 구독을 해지합니다.\nsetTimeout(() =&gt; {\n  locationsSubscription.unsubscribe();\n}, 10000);\n\n</code-example>\n-->\n<p>발행자는 <em>구독자</em> 함수를 사용해서 <code>Observable</code> 인스턴스를 생성합니다.\n구독자 함수는 구독자가 <code>subscribe()</code> 메소드를 사용할 때 실행되며, 이 함수에서 데이터나 메시지를 생성하고 발행합니다.</p>\n<p>그리고 구독자 함수를 <code>subscribe()</code>로 구독할 때 <em>옵저버(observer)</em>를 함께 전달하며, 옵저버는 옵저버블에서 발행된 데이터를 어떻게 처리할지 JavaScript 객체 형태로 정의한 것입니다.\n옵저버블의 <code>subscribe()</code> 함수를 실행하면 반환되는 <code>Subscription</code> 타입의 객체가 옵저버이며, 이 객체의 <code>unsubscribe()</code>를 실행하면 옵저버블 구독을 해지할 수 있습니다.</p>\n<p>다음 코드는 옵저버블을 사용해서 사용자의 접속 위치를 확인하는 예제 코드입니다.</p>\n<code-example class=\"no-auto-link\" path=\"observables/src/geolocation.ts\" header=\"접속 위치 추적하기\">\n\n// 구독자가 구독을 실행하면 새로운 Observable 인스턴스를 생성하고\n// 클라이언트의 접속 위치를 추적하기 시작합니다.\nconst locations = new Observable((observer) => {\n  let watchId: number;\n\n\n  // 접속 위치를 처리하는 API는 간단하게 사용해 봅니다.\n  if ('geolocation' in navigator) {\n    watchId = navigator.geolocation.watchPosition((position: Position) => {\n      observer.next(position);\n    }, (error: PositionError) => {\n      observer.error(error);\n    });\n  } else {\n    observer.error('Geolocation not available');\n  }\n\n  // 구독자가 구독을 해지하면 사용하던 데이터를 모두 지웁니다.\n  return {\n    unsubscribe() {\n      navigator.geolocation.clearWatch(watchId);\n    }\n  };\n});\n\n// 옵저버블을 시작하려면 subscribe() 함수를 실행합니다.\nconst locationsSubscription = locations.subscribe({\n  next(position) {\n    console.log('Current Position: ', position);\n  },\n  error(msg) {\n    console.log('Error Getting Location: ', msg);\n  }\n});\n\n// 옵저버블은 10초 후에 구독을 해지합니다.\nsetTimeout(() => {\n  locationsSubscription.unsubscribe();\n}, 10000);\n\n</code-example>\n<!--\n## Defining observers\n-->\n<h2 id=\"옵저버-정의하기\">옵저버 정의하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#옵저버-정의하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nA handler for receiving observable notifications implements the `Observer` interface. It is an object that defines callback methods to handle the three types of notifications that an observable can send:\n\n| Notification type | Description |\n|:---------|:-------------------------------------------|\n| `next`  | Required. A handler for each delivered value. Called zero or more times after execution starts.|\n| `error` | Optional. A handler for an error notification. An error halts execution of the observable instance.|\n| `complete` | Optional. A handler for the execution-complete notification. Delayed values can continue to be delivered to the next handler after execution is complete.|\n\nAn observer object can define any combination of these handlers. If you don't supply a handler for a notification type, the observer ignores notifications of that type.\n-->\n<p>옵저버블 스트림을 처리하려면 <code>Observer</code> 인터페이스로 옵저버를 정의해야 합니다. 이 옵저버는 옵저버블이 보내는 세 종류의 알림을 처리하는 콜백 함수로 구성됩니다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">알림 타입</th>\n<th align=\"left\">설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>next</code></td>\n<td align=\"left\">필수. 데이터 스트림을 처리하는 핸들러입니다. 옵저버블 구독을 시작한 후 여러번 실행됩니다.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>error</code></td>\n<td align=\"left\">필수는 아님. 에러 스트림을 처리하는 핸들러입니다. 에러 스트림이 전달되면 이후 옵저버블 로직이 실행되지 않습니다.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>complete</code></td>\n<td align=\"left\">필수는 아님. 옵저버블 종료 스트림을 처리하는 핸들러입니다. 옵저버블에서 지연 로직을 사용한다면 옵저버블이 종료된 이후에도 새로운 데이터가 전달될 수 있습니다.</td>\n</tr>\n</tbody>\n</table>\n<p>옵저버 객체는 이 3가지 핸들러를 조합해서 정의합니다. 특정 타입의 알림을 사용하지 않는다면, 이 타입에 해당하는 핸들러를 생략해도 됩니다.</p>\n<!--\n## Subscribing\n-->\n<h2 id=\"구독-subscribing\">구독 (Subscribing)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#구독-subscribing\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAn `Observable` instance begins publishing values only when someone subscribes to it. You subscribe by calling the `subscribe()` method of the instance, passing an observer object to receive the notifications.\n\n<div class=\"alert is-helpful\">\n\nIn order to show how subscribing works, we need to create a new observable. There is a constructor that you use to create new instances, but for illustration, we can use some methods from the RxJS library that create simple observables of frequently used types:\n\n  * `of(...items)`&mdash;Returns an `Observable` instance that synchronously delivers the values provided as arguments.\n  * `from(iterable)`&mdash;Converts its argument to an `Observable` instance. This method is commonly used to convert an array to an observable.\n\n</div>\n\nHere's an example of creating and subscribing to a simple observable, with an observer that logs the received message to the console:\n\n<code-example path=\"observables/src/subscribing.ts\" region=\"observer\" header=\"Subscribe using observer\">\n\n// 3개의 값을 전달하도록 옵저버블을 간단하게 정의합니다.\nconst myObservable = of(1, 2, 3);\n\n// 옵저버 객체를 정의합니다.\nconst myObserver = {\n  next: x =&gt; console.log(&#39;Observer got a next value: &#39; + x),\n  error: err =&gt; console.error(&#39;Observer got an error: &#39; + err),\n  complete: () =&gt; console.log(&#39;Observer got a complete notification&#39;),\n};\n\n// 옵저버 객체를 실행합니다.\nmyObservable.subscribe(myObserver);\n// 로그:\n// Observer got a next value: 1\n// Observer got a next value: 2\n// Observer got a next value: 3\n// Observer got a complete notification\n\n\n</code-example>\n\nAlternatively, the `subscribe()` method can accept callback function definitions in line, for `next`, `error`, and `complete` handlers. For example, the following `subscribe()` call is the same as the one that specifies the predefined observer:\n\n<code-example path=\"observables/src/subscribing.ts\" region=\"sub_fn\" header=\"Subscribe with positional arguments\">\nmyObservable.subscribe(\n  x =&gt; console.log(&#39;Observer got a next value: &#39; + x),\n  err =&gt; console.error(&#39;Observer got an error: &#39; + err),\n  () =&gt; console.log(&#39;Observer got a complete notification&#39;)\n);\n\n</code-example>\n\nIn either case, a `next` handler is required. The `error` and `complete` handlers are optional.\n\nNote that a `next()` function could receive, for instance, message strings, or event objects, numeric values, or structures, depending on context. As a general term, we refer to data published by an observable as a *stream*. Any type of value can be represented with an observable, and the values are published as a stream.\n-->\n<p><code>Observable</code> 인스턴스는 누군가 이 옵저버블을 구독해야 데이터를 발행하기 시작합니다.\n옵저버블 인스턴스에서 제공하는 <code>subscribe()</code> 함수를 실행하면 구독을 시작할 수 있으며, 이 때 옵저버블을 처리하는 옵저버 객체를 함께 전달합니다.</p>\n<div class=\"alert is-helpful\">\n<p>구독이 동작하는 것을 확인하려면 새로운 옵저버블을 생성해야 합니다. 이 때 활용할 수 있는 RxJS 함수는 여러가지지만, 이 문서에서는 간단하게 개념만 살펴볼 것이기 때문에 다음 함수들을 주로 사용할 것입니다:</p>\n<ul>\n<li><code>of(...배열)</code>—인자로 전달한 배열의 항목을 하나씩 전달하는 <code>Observable</code> 인스턴스를 생성합니다.</li>\n<li><code>from(이터러블)</code>—인자로 전달한 이터러블의 항목을 하나씩 전달하는 <code>Observable</code> 인스턴스를 생성합니다. 이 메소드는 배열을 옵저버블로 변환할 때 자주 사용합니다.</li>\n</ul>\n</div>\n<p>Here's an example of creating and subscribing to a simple observable, with an observer that logs the received message to the console:</p>\n<code-example path=\"observables/src/subscribing.ts\" region=\"observer\" header=\"옵저버 객체로 구독하기\">\n\n// 3개의 값을 전달하도록 옵저버블을 간단하게 정의합니다.\nconst myObservable = of(1, 2, 3);\n\n// 옵저버 객체를 정의합니다.\nconst myObserver = {\n  next: x => console.log('Observer got a next value: ' + x),\n  error: err => console.error('Observer got an error: ' + err),\n  complete: () => console.log('Observer got a complete notification'),\n};\n\n// 옵저버 객체를 실행합니다.\nmyObservable.subscribe(myObserver);\n// 로그:\n// Observer got a next value: 1\n// Observer got a next value: 2\n// Observer got a next value: 3\n// Observer got a complete notification\n\n\n</code-example>\n<p>이 예제처럼 <code>subscribe()</code> 메소드를 실행하면서 옵저버 객체를 전달하는 방식 대신, <code>subscribe()</code> 메소드를 실행하면서 인자로 <code>next</code>, <code>error</code>, <code>complete</code> 핸들러를 바로 지정할 수도 있습니다.\n아래 코드를 실행한 결과는 이전과 같습니다.</p>\n<code-example path=\"observables/src/subscribing.ts\" region=\"sub_fn\" header=\"함수의 인자로 구독하기\">\nmyObservable.subscribe(\n  x => console.log('Observer got a next value: ' + x),\n  err => console.error('Observer got an error: ' + err),\n  () => console.log('Observer got a complete notification')\n);\n\n</code-example>\n<p>두 경우 모두 <code>next</code> 핸들러는 필수항목입니다. <code>error</code>와 <code>complete</code> 핸들러는 생략할 수 있습니다.</p>\n<p>이 때 <code>next()</code> 함수는 객체의 인스턴스나 문자열 형태의 메시지, 이벤트 객체, 숫자 등 어떠한 객체라도 자유롭게 받을 수 있습니다.\n이렇게 옵저버블로 발행되는 데이터를 <em>스트림(stream)</em> 이라고 합니다.\n옵저버블은 타입에 관계없이 자유롭게 데이터를 처리할 수 있으며, 이 데이터는 스트림이 되어 구독자에게 전달됩니다.</p>\n<!--\n## Creating observables\n-->\n<h2 id=\"옵저버블-생성하기\">옵저버블 생성하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#옵저버블-생성하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nUse the `Observable` constructor to create an observable stream of any type. The constructor takes as its argument the subscriber function to run when the observable’s `subscribe()` method executes. A subscriber function receives an `Observer` object, and can publish values to the observer's `next()` method.\n\nFor example, to create an observable equivalent to the `of(1, 2, 3)` above, you could do something like this:\n\n<code-example path=\"observables/src/creating.ts\" region=\"subscriber\" header=\"Create observable with constructor\">\n\n// 이 함수는 subscribe()가 실행될 때 같이 실행됩니다.\nfunction sequenceSubscriber(observer) {\n  // 1, 2, 3을 순서대로 보내고, 옵저버블을 종료합니다.\n  observer.next(1);\n  observer.next(2);\n  observer.next(3);\n  observer.complete();\n\n  // 이 함수는 모든 데이터를 동기 방식으로 보내기 때문에\n  // 구독이 해제될 때 실행해야 하는 로직은 없습니다.\n  return {unsubscribe() {}};\n}\n\n// 구독자 함수를 인자로 전달하면서 새로운 Observable 인스턴스를 만듭니다.\nconst sequence = new Observable(sequenceSubscriber);\n\n// 옵저버블을 실행하고 스트림이 전달될 때마다 로그를 출력합니다.\nsequence.subscribe({\n  next(num) { console.log(num); },\n  complete() { console.log(&#39;Finished sequence&#39;); }\n});\n\n// 로그:\n// 1\n// 2\n// 3\n// Finished sequence\n\n\n</code-example>\n\nTo take this example a little further, we can create an observable that publishes events. In this example, the subscriber function is defined inline.\n\n<code-example path=\"observables/src/creating.ts\" region=\"fromevent\" header=\"Create with custom fromEvent function\">\n\nfunction fromEvent(target, eventName) {\n  return new Observable((observer) =&gt; {\n    const handler = (e) =&gt; observer.next(e);\n\n    // 대상 엘리먼트에 이벤트 핸들러를 추가합니다.\n    target.addEventListener(eventName, handler);\n\n    return () =&gt; {\n      // 이벤트 핸들러를 제거합니다.\n      target.removeEventListener(eventName, handler);\n    };\n  });\n}\n\n\n</code-example>\n\nNow you can use this function to create an observable that publishes keydown events:\n\n<code-example path=\"observables/src/creating.ts\" region=\"fromevent_use\" header=\"Use custom fromEvent function\">\n\nconst ESC_KEY = 27;\nconst nameInput = document.getElementById(&#39;name&#39;) as HTMLInputElement;\n\nconst subscription = fromEvent(nameInput, &#39;keydown&#39;)\n  .subscribe((e: KeyboardEvent) =&gt; {\n    if (e.keyCode === ESC_KEY) {\n      nameInput.value = &#39;&#39;;\n    }\n  });\n\n\n</code-example>\n-->\n<p>옵저버블 스트림을 생성하려면 <code>Observable</code> 생성자를 사용하면 됩니다.\n이 때 생성자는 구독자 함수(subscriber function)를 인자로 받으며, 인자로 받은 함수에 정의된 내용으로 옵저버블 스트림을 생성합니다.\n구독자 함수는 <code>Observer</code> 객체를 인자로 받는데, 이 객체의 <code>next()</code> 메소드를 실행하면 옵저버블 스트림을 발행할 수 있습니다.</p>\n<p>예를 들어 <code>Observable.of(1, 2, 3)</code>과 같은 동작을 하는 옵저버블을 직접 구현하려면 다음과 같이 작성합니다:</p>\n<code-example path=\"observables/src/creating.ts\" region=\"subscriber\" header=\"Create observable with constructor\">\n\n// 이 함수는 subscribe()가 실행될 때 같이 실행됩니다.\nfunction sequenceSubscriber(observer) {\n  // 1, 2, 3을 순서대로 보내고, 옵저버블을 종료합니다.\n  observer.next(1);\n  observer.next(2);\n  observer.next(3);\n  observer.complete();\n\n  // 이 함수는 모든 데이터를 동기 방식으로 보내기 때문에\n  // 구독이 해제될 때 실행해야 하는 로직은 없습니다.\n  return {unsubscribe() {}};\n}\n\n// 구독자 함수를 인자로 전달하면서 새로운 Observable 인스턴스를 만듭니다.\nconst <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a> = new Observable(sequenceSubscriber);\n\n// 옵저버블을 실행하고 스트림이 전달될 때마다 로그를 출력합니다.\nsequence.subscribe({\n  next(num) { console.log(num); },\n  complete() { console.log('Finished <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a>'); }\n});\n\n// 로그:\n// 1\n// 2\n// 3\n// Finished <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a>\n\n\n</code-example>\n<p>이 코드는 이벤트 객체를 발생하는 옵저버블을 만들 때도 활용할 수 있습니다.\n이 경우라면 다음과 같이 정의하면 됩니다.</p>\n<code-example path=\"observables/src/creating.ts\" region=\"fromevent\" header=\"fromEvent() 함수로 옵저버블 생성하기\">\n\nfunction fromEvent(target, eventName) {\n  return new Observable((observer) => {\n    const handler = (e) => observer.next(e);\n\n    // 대상 엘리먼트에 이벤트 핸들러를 추가합니다.\n    target.addEventListener(eventName, handler);\n\n    return () => {\n      // 이벤트 핸들러를 제거합니다.\n      target.removeEventListener(eventName, handler);\n    };\n  });\n}\n\n\n</code-example>\n<p>이 함수를 사용해서 키다운 이벤트를 처리하려면 다음과 같이 작성합니다:</p>\n<code-example path=\"observables/src/creating.ts\" region=\"fromevent_use\" header=\"fromEvent() 함수 활용하기\">\n\nconst ESC_KEY = 27;\nconst nameInput = document.getElementById('name') as HTMLInputElement;\n\nconst subscription = fromEvent(nameInput, 'keydown')\n  .subscribe((e: KeyboardEvent) => {\n    if (e.keyCode === ESC_KEY) {\n      nameInput.value = '';\n    }\n  });\n\n\n</code-example>\n<!--\n## Multicasting\n-->\n<h2 id=\"멀티캐스팅-multicasting\">멀티캐스팅 (Multicasting)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#멀티캐스팅-multicasting\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nA typical observable creates a new, independent execution for each subscribed observer. When an observer subscribes, the observable wires up an event handler and delivers values to that observer. When a second observer subscribes, the observable then wires up a new event handler and delivers values to that second observer in a separate execution.\n\nSometimes, instead of starting an independent execution for each subscriber, you want each subscription to get the same values&mdash;even if values have already started emitting. This might be the case with something like an observable of clicks on the document object.\n\n*Multicasting* is the practice of broadcasting to a list of multiple subscribers in a single execution. With a multicasting observable, you don't register multiple listeners on the document, but instead re-use the first listener and send values out to each subscriber.\n\nWhen creating an observable you should determine how you want that observable to be used and whether or not you want to multicast its values.\n\nLet’s look at an example that counts from 1 to 3, with a one-second delay after each number emitted.\n\n<code-example path=\"observables/src/multicasting.ts\" region=\"delay_sequence\" header=\"Create a delayed sequence\">\n\nfunction sequenceSubscriber(observer) {\n  const seq = [1, 2, 3];\n  let timeoutId;\n\n  // 배열을 순회하면서 배열의 항목을 1초마다 하나씩 발행합니다.\n  function doSequence(arr, idx) {\n    timeoutId = setTimeout(() =&gt; {\n      observer.next(arr[idx]);\n      if (idx === arr.length - 1) {\n        observer.complete();\n      } else {\n        doSequence(arr, ++idx);\n      }\n    }, 1000);\n  }\n\n  doSequence(seq, 0);\n\n  // 구독이 해지되면 타이머를 중지합니다.\n  return {unsubscribe() {\n    clearTimeout(timeoutId);\n  }};\n}\n\n// 위에서 정의한 데이터 스트림을 발생하는 옵저버블을 생성합니다.\nconst sequence = new Observable(sequenceSubscriber);\n\nsequence.subscribe({\n  next(num) { console.log(num); },\n  complete() { console.log(&#39;Finished sequence&#39;); }\n});\n\n// 로그:\n// (1초 후): 1\n// (2초 후): 2\n// (3초 후): 3\n// (3초 후): Finished sequence\n\n\n</code-example>\n\nNotice that if you subscribe twice, there will be two separate streams, each emitting values every second. It looks something like this:\n\n<code-example path=\"observables/src/multicasting.ts\" region=\"subscribe_twice\" header=\"Two subscriptions\">\n\n// 구독을 시작하면 타이머가 시작되면서, 1초마다 데이터가 전달됩니다.\nsequence.subscribe({\n  next(num) { console.log(&#39;1st subscribe: &#39; + num); },\n  complete() { console.log(&#39;1st sequence finished.&#39;); }\n});\n\n// 0.5초 후에 새로운 구독을 시작합니다.\nsetTimeout(() =&gt; {\n  sequence.subscribe({\n    next(num) { console.log(&#39;2nd subscribe: &#39; + num); },\n    complete() { console.log(&#39;2nd sequence finished.&#39;); }\n  });\n}, 500);\n\n// 로그:\n// (1초 후): 1st subscribe: 1\n// (1.5초 후): 2nd subscribe: 1\n// (2초 후): 1st subscribe: 2\n// (2.5초 후): 2nd subscribe: 2\n// (3초 후): 1st subscribe: 3\n// (3초 후): 1st sequence finished\n// (3.5초 후): 2nd subscribe: 3\n// (3.5초 후): 2nd sequence finished\n\n\n</code-example>\n\n Changing the observable to be multicasting could look something like this:\n\n<code-example path=\"observables/src/multicasting.ts\" region=\"multicast_sequence\" header=\"Create a multicast subscriber\">\n\nfunction multicastSequenceSubscriber() {\n  const seq = [1, 2, 3];\n  // 구독중인 옵저버를 추적합니다.\n  const observers = [];\n  // 한 번 생성된 데이터는 모든 구독자에게 멀티캐스팅되기 때문에\n  // 타이머 id는 하나로 관리합니다.\n  let timeoutId;\n\n  // 구독자 함수를 반환합니다.\n  // 이 함수는 subscribe()가 실행될 때 함께 실행됩니다.\n  return (observer) =&gt; {\n    observers.push(observer);\n    // 구독이 처음 실행되면 스트림을 발생하기 시작합니다.\n    if (observers.length === 1) {\n      timeoutId = doSequence({\n        next(val) {\n          // 모든 구독에 대해 스트림을 발행합니다.\n          observers.forEach(obs =&gt; obs.next(val));\n        },\n        complete() {\n          // 모든 구독에 종료 스트림을 전달합니다.\n          observers.slice(0).forEach(obs =&gt; obs.complete());\n        }\n      }, seq, 0);\n    }\n\n    return {\n      unsubscribe() {\n        // 구독을 해지한 옵저버는 배열에서 제거합니다.\n        observers.splice(observers.indexOf(observer), 1);\n        // 구독자가 없으면 타이머를 종료합니다.\n        if (observers.length === 0) {\n          clearTimeout(timeoutId);\n        }\n      }\n    };\n  };\n}\n\n// 배열을 순회하면서 1초마다 하나씩 스트림을 발행합니다.\nfunction doSequence(observer, arr, idx) {\n  return setTimeout(() =&gt; {\n    observer.next(arr[idx]);\n    if (idx === arr.length - 1) {\n      observer.complete();\n    } else {\n      doSequence(observer, arr, ++idx);\n    }\n  }, 1000);\n}\n\n// doSequence()에 정의된 스트림을 발행하는 옵저버블을 생성합니다.\nconst multicastSequence = new Observable(multicastSequenceSubscriber());\n\n// 옵저버블을 구독하면 타이머를 시작하고 1초마다 스트림을 받습니다.\nmulticastSequence.subscribe({\n  next(num) { console.log(&#39;1st subscribe: &#39; + num); },\n  complete() { console.log(&#39;1st sequence finished.&#39;); }\n});\n\n// 0.5초 후에 또 다른 구독을 시작합니다.\n// (첫번째 값은 다시 받지 않습니다.)\nsetTimeout(() =&gt; {\n  multicastSequence.subscribe({\n    next(num) { console.log(&#39;2nd subscribe: &#39; + num); },\n    complete() { console.log(&#39;2nd sequence finished.&#39;); }\n  });\n}, 1500);\n\n// 로그:\n// (1초 후): 1st subscribe: 1\n// (2초 후): 1st subscribe: 2\n// (2초 후): 2nd subscribe: 2\n// (3초 후): 1st subscribe: 3\n// (3초 후): 1st sequence finished\n// (3초 후): 2nd subscribe: 3\n// (3초 후): 2nd sequence finished\n\n\n</code-example>\n\n<div class=\"alert is-helpful\">\n   Multicasting observables take a bit more setup, but they can be useful for certain applications. Later we will look at tools that simplify the process of multicasting, allowing you to take any observable and make it multicasting.\n</div>\n-->\n<p>옵저버블은 일반적으로 옵저버블을 구독하는 옵저버끼리 영향을 주지 않는 단일 데이터를 생성합니다.\n그리고 이 데이터는 옵저버블을 구독하는 이벤트 핸들러에 각각 전달되며, 개별 옵저버가 이 데이터를 받아서 처리합니다.\n그래서 두 번째 옵저버가 구독을 시작하더라도 그 전에 구독한 옵저버와는 관련이 없습니다.</p>\n<p>그런데 어떤 경우에는, 이미 발생되어 처리된 데이터를 다른 구독자가 다시 받고 싶은 경우가 있습니다.\n이 경우는 도큐먼트 객체에서 일어나는 클릭 이벤트를 옵저버블로 처리하는 경우에도 적용할 수 있습니다.</p>\n<p><em>멀티캐스팅</em>은 여러 구독자가 같은 실행 싸이클에서 실행될 수 있도록 브로드캐스팅(broadcasting)하는 방법입니다.\n멀티캐스팅 옵저버블을 사용하면 도큐먼트에 여러개의 리스너를 연결하지 않아도 모든 구독자들이 같은 데이터 객체를 처리할 수 있습니다.</p>\n<p>옵저버블을 어떻게 사용할지, 멀티캐스팅을 사용할지 여부는 옵저버블을 생성할 때 지정합니다.</p>\n<p>1부터 3까지 숫자를 세는 예제를 봅시다. 이 예제는 1초마다 각각의 숫자를 스트림으로 보냅니다.</p>\n<code-example path=\"observables/src/multicasting.ts\" region=\"delay_sequence\" header=\"시퀀스 정의하기\">\n\nfunction sequenceSubscriber(observer) {\n  const seq = [1, 2, 3];\n  let timeoutId;\n\n  // 배열을 순회하면서 배열의 항목을 1초마다 하나씩 발행합니다.\n  function doSequence(arr, idx) {\n    timeoutId = setTimeout(() => {\n      observer.next(arr[idx]);\n      if (idx === arr.length - 1) {\n        observer.complete();\n      } else {\n        doSequence(arr, ++idx);\n      }\n    }, 1000);\n  }\n\n  doSequence(seq, 0);\n\n  // 구독이 해지되면 타이머를 중지합니다.\n  return {unsubscribe() {\n    clearTimeout(timeoutId);\n  }};\n}\n\n// 위에서 정의한 데이터 스트림을 발생하는 옵저버블을 생성합니다.\nconst <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a> = new Observable(sequenceSubscriber);\n\nsequence.subscribe({\n  next(num) { console.log(num); },\n  complete() { console.log('Finished <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a>'); }\n});\n\n// 로그:\n// (1초 후): 1\n// (2초 후): 2\n// (3초 후): 3\n// (3초 후): Finished <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a>\n\n\n</code-example>\n<p>옵저버블을 두 번 구독하면 각각의 스트림은 독립적으로 생성되며, 매초마다 각각 새로운 데이터가 전달될 것입니다:</p>\n<code-example path=\"observables/src/multicasting.ts\" region=\"subscribe_twice\" header=\"두 번 구독하기\">\n\n// 구독을 시작하면 타이머가 시작되면서, 1초마다 데이터가 전달됩니다.\nsequence.subscribe({\n  next(num) { console.log('1st subscribe: ' + num); },\n  complete() { console.log('1st <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a> finished.'); }\n});\n\n// 0.5초 후에 새로운 구독을 시작합니다.\nsetTimeout(() => {\n  sequence.subscribe({\n    next(num) { console.log('2nd subscribe: ' + num); },\n    complete() { console.log('2nd <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a> finished.'); }\n  });\n}, 500);\n\n// 로그:\n// (1초 후): 1st subscribe: 1\n// (1.5초 후): 2nd subscribe: 1\n// (2초 후): 1st subscribe: 2\n// (2.5초 후): 2nd subscribe: 2\n// (3초 후): 1st subscribe: 3\n// (3초 후): 1st <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a> finished\n// (3.5초 후): 2nd subscribe: 3\n// (3.5초 후): 2nd <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a> finished\n\n\n</code-example>\n<p>이 옵저버블을 멀티캐스팅 방식으로 바꿔봅시다:</p>\n<code-example path=\"observables/src/multicasting.ts\" region=\"multicast_sequence\" header=\"멀티캐스트 구독하기\">\n\nfunction multicastSequenceSubscriber() {\n  const seq = [1, 2, 3];\n  // 구독중인 옵저버를 추적합니다.\n  const observers = [];\n  // 한 번 생성된 데이터는 모든 구독자에게 멀티캐스팅되기 때문에\n  // 타이머 id는 하나로 관리합니다.\n  let timeoutId;\n\n  // 구독자 함수를 반환합니다.\n  // 이 함수는 subscribe()가 실행될 때 함께 실행됩니다.\n  return (observer) => {\n    observers.push(observer);\n    // 구독이 처음 실행되면 스트림을 발생하기 시작합니다.\n    if (observers.length === 1) {\n      timeoutId = doSequence({\n        next(val) {\n          // 모든 구독에 대해 스트림을 발행합니다.\n          observers.forEach(obs => obs.next(val));\n        },\n        complete() {\n          // 모든 구독에 종료 스트림을 전달합니다.\n          observers.slice(0).forEach(obs => obs.complete());\n        }\n      }, seq, 0);\n    }\n\n    return {\n      unsubscribe() {\n        // 구독을 해지한 옵저버는 배열에서 제거합니다.\n        observers.splice(observers.indexOf(observer), 1);\n        // 구독자가 없으면 타이머를 종료합니다.\n        if (observers.length === 0) {\n          clearTimeout(timeoutId);\n        }\n      }\n    };\n  };\n}\n\n// 배열을 순회하면서 1초마다 하나씩 스트림을 발행합니다.\nfunction doSequence(observer, arr, idx) {\n  return setTimeout(() => {\n    observer.next(arr[idx]);\n    if (idx === arr.length - 1) {\n      observer.complete();\n    } else {\n      doSequence(observer, arr, ++idx);\n    }\n  }, 1000);\n}\n\n// doSequence()에 정의된 스트림을 발행하는 옵저버블을 생성합니다.\nconst multicastSequence = new Observable(multicastSequenceSubscriber());\n\n// 옵저버블을 구독하면 타이머를 시작하고 1초마다 스트림을 받습니다.\nmulticastSequence.subscribe({\n  next(num) { console.log('1st subscribe: ' + num); },\n  complete() { console.log('1st <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a> finished.'); }\n});\n\n// 0.5초 후에 또 다른 구독을 시작합니다.\n// (첫번째 값은 다시 받지 않습니다.)\nsetTimeout(() => {\n  multicastSequence.subscribe({\n    next(num) { console.log('2nd subscribe: ' + num); },\n    complete() { console.log('2nd <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a> finished.'); }\n  });\n}, 1500);\n\n// 로그:\n// (1초 후): 1st subscribe: 1\n// (2초 후): 1st subscribe: 2\n// (2초 후): 2nd subscribe: 2\n// (3초 후): 1st subscribe: 3\n// (3초 후): 1st <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a> finished\n// (3초 후): 2nd subscribe: 3\n// (3초 후): 2nd <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a> finished\n\n\n</code-example>\n<div class=\"alert is-helpful\">\n   멀티태스킹 옵저버블은 준비 과정이 조금 더 복잡합니다.\n   이 과정은 이후에 다시 간단한 방법으로 살펴봅시다. 이후에 알아볼 방법을 사용하면 모든 옵저버블을 멀티태스킹으로 활용할 수도 있습니다.\n</div>\n<!--\n## Error handling\n-->\n<h2 id=\"에러-처리\">에러 처리<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#에러-처리\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nBecause observables produce values asynchronously, try/catch will not effectively catch errors. Instead, you handle errors by specifying an `error` callback on the observer. Producing an error also causes the observable to clean up subscriptions and stop producing values. An observable can either produce values (calling the `next` callback), or it can complete, calling either the `complete` or `error` callback.\n\n<code-example>\nmyObservable.subscribe({\n  next(num) { console.log('Next num: ' + num)},\n  error(err) { console.log('Received an error: ' + err)}\n});\n</code-example>\n\nError handling (and specifically recovering from an error) is covered in more detail in a later section.\n-->\n<p>옵저버블은 데이터를 비동기로 발행하기 때문에 try/catch로 에러를 처리할 수 없습니다.\n대신, 옵저버블에서 발행하는 에러 스트림은 옵저버의 <code>error</code> 콜백으로 처리합니다.\n그리고 옵저버블에서 에러가 발생하면 구독을 중단하고 새로운 값이 다시 생성되지 않도록 해야합니다.\n옵저버블에서 <code>next</code>로 데이터 스트림을 받았던 것과 비슷하게, 종료 스트림과 에러스트림은 각각 <code>complete</code> 콜백과 <code>error</code> 콜백으로 받을 수 있습니다.</p>\n<code-example>\nmyObservable.subscribe({\n  next(num) { console.log('Next num: ' + num)},\n  error(err) { console.log('Received an errror: ' + err)}\n});\n</code-example>\n<p>에러를 처리하는 방법과 에러 상태에서 벗어나는 방법은 다음 문서에서 자세히 알아봅니다.</p>\n\n</div>\n\n<!-- links to this doc:\n - api/service-worker/SwRegistrationOptions\n - guide/architecture-next-steps\n - guide/glossary\n - guide/http\n-->\n<!-- links from this doc:\n - api/animations/sequence\n - guide/observables#using-observables-to-pass-values\n - guide/observables#구독-subscribing\n - guide/observables#멀티캐스팅-multicasting\n - guide/observables#에러-처리\n - guide/observables#옵저버-정의하기\n - guide/observables#옵저버블-생성하기\n - guide/observables#용어-정의-사용-방법\n - https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern\n - https://github.com/angular/angular/edit/master/aio/content/guide/observables.md?message=docs%3A%20describe%20your%20change...\n-->"
}