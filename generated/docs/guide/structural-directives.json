{
  "id": "guide/structural-directives",
  "title": "구조 디렉티브 (Structural Directives)",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/structural-directives.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Structural directives\n-->\n<h1 id=\"구조-디렉티브-structural-directives\">구조 디렉티브 (Structural Directives)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#구조-디렉티브-structural-directives\"><i class=\"material-icons\">link</i></a></h1>\n<style>\n  h4 {font-size: 17px !important; text-transform: none !important;}\n  .syntax { font-family: Consolas, 'Lucida Sans', Courier, sans-serif; color: black; font-size: 85%; }\n\n</style>\n<!--\nThis guide looks at how Angular manipulates the DOM with **structural directives** and\nhow you can write your own structural directives to do the same thing.\n\nTry the <live-example></live-example>.\n-->\n<p>이 문서는 <strong>구조 디렉티브</strong>가 DOM을 어떻게 조작하는지 설명합니다. 그리고 커스텀 구조 디렉티브를 어떻게 구현하는지도 알아봅시다.</p>\n<p>이 문서에서 다루는 예제는 <live-example></live-example>에서 바로 확인하거나 다운받아 확인할 수 있습니다.</p>\n<a id=\"definition\"></a>\n<!--\n## What are structural directives?\n-->\n<h2 id=\"구조-디렉티브란\">구조 디렉티브란?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#구조-디렉티브란\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nStructural directives are responsible for HTML layout.\nThey shape or reshape the DOM's _structure_, typically by adding, removing, or manipulating\nelements.\n\nAs with other directives, you apply a structural directive to a _host element_.\nThe directive then does whatever it's supposed to do with that host element and its descendants.\n\nStructural directives are easy to recognize.\nAn asterisk (*) precedes the directive attribute name as in this example.\n\n\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (ngif)\" region=\"ngif\">\n&lt;div *ngIf=&quot;hero&quot; class=&quot;name&quot;&gt;{{hero.name}}&lt;/div&gt;\n\n</code-example>\n\n\nNo brackets. No parentheses. Just `*ngIf` set to a string.\n\nYou'll learn in this guide that the [asterisk (*) is a convenience notation](guide/structural-directives#asterisk)\nand the string is a [_microsyntax_](guide/structural-directives#microsyntax) rather than the usual\n[template expression](guide/interpolation#template-expressions).\nAngular desugars this notation into a marked-up `<ng-template>` that surrounds the\nhost element and its descendants.\nEach structural directive does something different with that template.\n\nThree of the common, built-in structural directives&mdash;[NgIf](guide/built-in-directives#ngIf),\n[NgFor](guide/built-in-directives#ngFor), and [NgSwitch...](guide/built-in-directives#ngSwitch)&mdash;are\ndescribed in the [Built-in directives](guide/built-in-directives) guide and seen in samples throughout the Angular documentation.\nHere's an example of them in a template:\n\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (built-in)\" region=\"built-in\">\n&lt;div *ngIf=&quot;hero&quot; class=&quot;name&quot;&gt;{{hero.name}}&lt;/div&gt;\n\n&lt;ul&gt;\n  &lt;li *ngFor=&quot;let hero of heroes&quot;&gt;{{hero.name}}&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;div [ngSwitch]=&quot;hero?.emotion&quot;&gt;\n  &lt;app-happy-hero    *ngSwitchCase=&quot;&#39;happy&#39;&quot;    [hero]=&quot;hero&quot;&gt;&lt;/app-happy-hero&gt;\n  &lt;app-sad-hero      *ngSwitchCase=&quot;&#39;sad&#39;&quot;      [hero]=&quot;hero&quot;&gt;&lt;/app-sad-hero&gt;\n  &lt;app-confused-hero *ngSwitchCase=&quot;&#39;confused&#39;&quot; [hero]=&quot;hero&quot;&gt;&lt;/app-confused-hero&gt;\n  &lt;app-unknown-hero  *ngSwitchDefault           [hero]=&quot;hero&quot;&gt;&lt;/app-unknown-hero&gt;\n&lt;/div&gt;\n\n</code-example>\n\n\nThis guide won't repeat how to _use_ them. But it does explain _how they work_\nand how to [write your own](guide/structural-directives#unless) structural directive.\n-->\n<p>구조 디렉티브는 HTML 문서의 레이아웃과 관계가 있습니다.\n구조 디렉티브는 엘리먼트를 DOM에 추가하거나 제거하면서  DOM의 <em>구조</em> 를 조작합니다.</p>\n<p>다른 디렉티브와 마찬가지로 구조 디렉티브도 <em>호스트 엘리먼트</em> 에 지정하는데, 구조 디렉티브는 디렉티브에 정의된 로직에 따라 호스트 엘리먼트나 자식 엘리먼트를 조작합니다.</p>\n<p>구조 디렉티브가 사용된 것은 확인하기 쉽습니다.\n이 디렉티브는 아래 예제처럼 별표(<code>*</code>)로 시작하는 어트리뷰트 이름으로 적용합니다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (ngif)\" region=\"ngif\">\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero\" class=\"name\">{{hero.name}}&#x3C;/div>\n\n</code-example>\n<p>구조 디렉티브에는 괄호(<code>(</code>, <code>)</code>)도 없고 대괄호(<code>[</code>, <code>]</code>)도 없습니다. <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>는 단순하게 문자열일 뿐입니다.</p>\n<p>아래 부분에서 좀 더 자세히 설명하겠지만, <a href=\"guide/structural-directives#asterisk\">별표(<code>*</code>)는 구조 디렉티브를 사용하기 편하게 만드는</a> 문법 테크닉이며, 이런 문법은 <a href=\"guide/interpolation#template-expressions\">템플릿 표현식</a>이라기 보다는 <a href=\"guide/structural-directives#microsyntax\"><em>세부 문법(microsyntax)</em></a>이라고 하는 것이 더 적절합니다.\nAngular가 애플리케이션을 빌드하면 이 문법 테크닉은 호스트 엘리먼트와 자식 엘리먼트 사이에 <code>&#x3C;ng-template></code> 계층의 마크업을 구성하면서 사라집니다.\n이 때 구조 디렉티브를 템플릿에서 어떻게 사용했느냐에 따라 결과물이 달라집니다.</p>\n<p>Angular가 제공하는 구조 디렉티브 중 가장 많이 사용하는 것은 <a href=\"guide/built-in-directives#ngIf\">NgIf</a>, <a href=\"guide/built-in-directives#ngFor\">NgFor</a>, <a href=\"guide/built-in-directives#ngSwitch\">NgSwitch...</a> 이렇게 3가지 입니다.\n각각은 <a href=\"guide/built-in-directives\"><em>기본 디렉티브</em></a> 문서에서 자세하게 다루며, 예제도 함께 확인할 수 있습니다.\n이 문서에서는 간단하게만 알아봅시다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (기본 디렉티브)\" region=\"built-in\">\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero\" class=\"name\">{{hero.name}}&#x3C;/div>\n\n&#x3C;ul>\n  &#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">{{hero.name}}&#x3C;/li>\n&#x3C;/ul>\n\n&#x3C;div [<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a>]=\"hero?.emotion\">\n  &#x3C;app-happy-hero    *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'happy'\"    [hero]=\"hero\">&#x3C;/app-happy-hero>\n  &#x3C;app-sad-hero      *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'sad'\"      [hero]=\"hero\">&#x3C;/app-sad-hero>\n  &#x3C;app-confused-hero *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'confused'\" [hero]=\"hero\">&#x3C;/app-confused-hero>\n  &#x3C;app-unknown-hero  *<a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">ngSwitchDefault</a>           [hero]=\"hero\">&#x3C;/app-unknown-hero>\n&#x3C;/div>\n\n</code-example>\n<p>각각의 디렉티브를 <em>어떻게 사용하는지</em> 에 대해서는 이 문서에서 다루지 않습니다. 대신, 디렉티브가 <em>어떻게 동작하며</em>, 커스텀 구조 디렉티브는 <a href=\"guide/structural-directives#unless\">어떻게 만드는지</a> 알아봅시다.</p>\n<!--\n<div class=\"callout is-helpful\">\n\n<header>\n  Directive spelling\n</header>\n\nThroughout this guide, you'll see a directive spelled in both _UpperCamelCase_ and _lowerCamelCase_.\nAlready you've seen `NgIf` and `ngIf`.\nThere's a reason. `NgIf` refers to the directive _class_;\n`ngIf` refers to the directive's _attribute name_.\n\nA directive _class_ is spelled in _UpperCamelCase_ (`NgIf`).\nA directive's _attribute name_ is spelled in _lowerCamelCase_ (`ngIf`).\nThe guide refers to the directive _class_ when talking about its properties and what the directive does.\nThe guide refers to the _attribute name_ when describing how\nyou apply the directive to an element in the HTML template.\n\n</div>\n-->\n<div class=\"callout is-helpful\">\n<header>\n  디렉티브의 대소문자 구분\n</header>\n<p>이 문서에서는 디렉티브를 <em>대문자 캐멀 케이스(UpperCamelCase)</em> 로 언급하기도 하고 <em>소문자 캐멀 케이스(lowerCamelCase)</em> 로 언급하기도 합니다.\n지금까지의 설명에서도 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>라고 하기도 했고 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>라고 하기도 했죠.\n이렇게 사용하는 이유가 있습니다. <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>는 디렉티브 <em>클래스</em> 자체를 가리키며, <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>는 디렉티브를 적용할 때 사용하는 <em>어트리뷰트 이름</em> 을 가리킵니다.</p>\n<p>디렉티브의 프로퍼티나 디렉티브의 동작을 설명할 때는 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>와 같이 <em>대문자 캐멀 케이스</em> 로 정의하는 디렉티브 <em>클래스</em> 자체를 가리킵니다.\n그리고 디렉티브를 HTML 템플릿에 있는 엘리먼트에 적용하는 것을 설명할 때는 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>와 같이 <em>소문자 캐멀 케이스</em> 로 정의하는 <em>어트리뷰트 이름</em> 을 가리킵니다.</p>\n</div>\n<!--\n<div class=\"alert is-helpful\">\n\nThere are two other kinds of Angular directives, described extensively elsewhere:\n(1)&nbsp;components and (2)&nbsp;attribute directives.\n\nA *component* manages a region of HTML in the manner of a native HTML element.\nTechnically it's a directive with a template.\n\nAn [*attribute* directive](guide/attribute-directives) changes the appearance or behavior\nof an element, component, or another directive.\nFor example, the built-in [`NgStyle`](guide/built-in-directives#ngStyle) directive\nchanges several element styles at the same time.\n\nYou can apply many _attribute_ directives to one host element.\nYou can [only apply one](guide/structural-directives#one-per-element) _structural_ directive to a host element.\n\n</div>\n-->\n<div class=\"alert is-helpful\">\n<p>다른 문서에서도 언급한 것처럼 Angular의 디렉티브는 크게 두 종류입니다. 그 중 하나는 (1) 컴포넌트이고, 다른 하나는 (2) 어트리뷰트 디렉티브 입니다.</p>\n<p><em>컴포넌트</em>는 네이티브 HTML 엘리먼트를 사용해서 HTML 문서의 한 부분을 담당합니다.\n문법적으로는 디렉티브에 템플릿이 추가된 것이 컴포넌트입니다.</p>\n<p><a href=\"guide/attribute-directives\"><em>어트리뷰트</em> 디렉티브</a>는 엘리먼트나 컴포넌트, 디렉티브의 모습이나 동작을 변경합니다.\n예를 들어 보면, <a href=\"guide/built-in-directives#ngStyle\"><code>NgStyle</code></a> 디렉티브는 엘리먼트에 여러 엘리먼트 스타일을 동시에 지정할 수 있습니다.</p>\n<p>호스트 엘리먼트에는 여러 개의 <em>어트리뷰트</em> 디렉티브를 지정할 수도 있습니다.\n하지만 구조 디렉티브는 호스트 엘리먼트에 <a href=\"guide/structural-directives#one-per-element\">하나만</a> 적용할 수 있습니다.</p>\n</div>\n<a id=\"ngIf\"></a>\n<a id=\"ngif-case-study\"></a>\n<!--\n## NgIf case study\n-->\n<h2 id=\"ngif로-이해하기\">NgIf로 이해하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#ngif로-이해하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\n`NgIf` is the simplest structural directive and the easiest to understand.\nIt takes a boolean expression and makes an entire chunk of the DOM appear or disappear.\n\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (ngif-true)\" region=\"ngif-true\">\n&lt;p *ngIf=&quot;true&quot;&gt;\n  Expression is true and ngIf is true.\n  This paragraph is in the DOM.\n&lt;/p&gt;\n&lt;p *ngIf=&quot;false&quot;&gt;\n  Expression is false and ngIf is false.\n  This paragraph is not in the DOM.\n&lt;/p&gt;\n\n</code-example>\n\nThe `ngIf` directive doesn't hide elements with CSS. It adds and removes them physically from the DOM.\nConfirm that fact using browser developer tools to inspect the DOM.\n\n<div class=\"lightbox\">\n  <img src='generated/images/guide/structural-directives/element-not-in-dom.png' alt=\"ngIf=false element not in DOM\">\n</div>\n\nThe top paragraph is in the DOM. The bottom, disused paragraph is not;\nin its place is a comment about \"bindings\" (more about that [later](guide/structural-directives#asterisk)).\n\nWhen the condition is false, `NgIf` removes its host element from the DOM,\ndetaches it from DOM events (the attachments that it made),\ndetaches the component from Angular change detection, and destroys it.\nThe component and DOM nodes can be garbage-collected and free up memory.\n-->\n<p>구조 디렉티브 중에서 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>는 가장 간단하며 이해하기도 쉽습니다.\n이 디렉티브는 표현식의 결과에 따라 DOM 조각을 추가하거나 제거합니다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (ngif-true)\" region=\"ngif-true\">\n&#x3C;p *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"true\">\n  Expression is true and <a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a> is true.\n  This paragraph is in the DOM.\n&#x3C;/p>\n&#x3C;p *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"false\">\n  Expression is false and <a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a> is false.\n  This paragraph is not in the DOM.\n&#x3C;/p>\n\n</code-example>\n<p><code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 디렉티브는 CSS처럼 엘리먼트를 숨기는 것이 아닙니다. 이 디렉티브가 <code>false</code> 조건으로 동작하면 DOM에서 엘리먼트를 완전히 제거합니다.\n그래서 브라우저 개발자 도구로 DOM을 직접 보면 다음과 같이 처리되는 것을 확인할 수 있습니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/structural-directives/element-not-in-dom.png\" alt=\"ngIf=false element not in DOM\" width=\"322\" height=\"114\">\n</div>\n<p>위에 있는 <code>&#x3C;p></code> 엘리먼트는 DOM에 존재하는 엘리먼트입니다. 그리고 아래에 있는 <code>&#x3C;p></code> 엘리먼트는 DOM에 존재하지 않습니다. 이 엘리먼트는 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 디렉티브에 의해 처리되고 주석으로만 존재합니다. 이 내용은 <a href=\"guide/structural-directives#asterisk\">아래</a>에서 좀 더 자세하게 설명합니다.</p>\n<p>평가식의 값이 <code>false</code>이면 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 디렉티브는 호스트 엘리먼트를 DOM에서 완전히 제거하고 DOM 이벤트 대상에서도 제외합니다. 그리고 Angular의 변화 감지 대상에서도 제외한 후에 디렉티브를 종료합니다.\n따라서 이 디렉티브와 DOM 노드 조각은 가비지 콜렉션의 대상이 되어 메모리에서도 완전히 제거됩니다.</p>\n<!--\n### Why *remove* rather than *hide*?\n-->\n<h3 id=\"왜-숨기지않고-제거하는-걸까요\">왜 <em>숨기지</em>않고 <em>제거</em>하는 걸까요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#왜-숨기지않고-제거하는-걸까요\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nA directive could hide the unwanted paragraph instead by setting its `display` style to `none`.\n\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (display-none)\" region=\"display-none\">\n&lt;p [style.display]=&quot;&#39;block&#39;&quot;&gt;\n  Expression sets display to &quot;block&quot;.\n  This paragraph is visible.\n&lt;/p&gt;\n&lt;p [style.display]=&quot;&#39;none&#39;&quot;&gt;\n  Expression sets display to &quot;none&quot;.\n  This paragraph is hidden but still in the DOM.\n&lt;/p&gt;\n\n</code-example>\n\nWhile invisible, the element remains in the DOM.\n\n<div class=\"lightbox\">\n  <img src='generated/images/guide/structural-directives/element-display-in-dom.png' alt=\"hidden element still in DOM\">\n</div>\n\nThe difference between hiding and removing doesn't matter for a simple paragraph.\nIt does matter when the host element is attached to a resource intensive component.\nSuch a component's behavior continues even when hidden.\nThe component stays attached to its DOM element. It keeps listening to events.\nAngular keeps checking for changes that could affect data bindings.\nWhatever the component was doing, it keeps doing.\n\nAlthough invisible, the component&mdash;and all of its descendant components&mdash;tie up resources.\nThe performance and memory burden can be substantial, responsiveness can degrade, and the user sees nothing.\n\nOn the positive side, showing the element again is quick.\nThe component's previous state is preserved and ready to display.\nThe component doesn't re-initialize&mdash;an operation that could be expensive.\nSo hiding and showing is sometimes the right thing to do.\n\nBut in the absence of a compelling reason to keep them around,\nyour preference should be to remove DOM elements that the user can't see\nand recover the unused resources with a structural directive like `NgIf` .\n\n**These same considerations apply to every structural directive, whether built-in or custom.**\nBefore applying a structural directive, you might want to pause for a moment\nto consider the consequences of adding and removing elements and of creating and destroying components.\n-->\n<p>디렉티브가 화면에 보일 필요가 없으면 <code>display</code> 스타일을 <code>none</code>으로 지정해서 감추는 방법도 있습니다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (display-none)\" region=\"display-none\">\n&#x3C;p [style.display]=\"'block'\">\n  Expression sets display to \"block\".\n  This paragraph is visible.\n&#x3C;/p>\n&#x3C;p [style.display]=\"'none'\">\n  Expression sets display to \"none\".\n  This paragraph is hidden but still in the DOM.\n&#x3C;/p>\n\n</code-example>\n<p>하지만 이 경우에 엘리먼트는 DOM에 여전히 존재합니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/structural-directives/element-display-in-dom.png\" alt=\"hidden element still in DOM\" width=\"415\" height=\"185\">\n</div>\n<p><code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>가 조작하는 엘리먼트가 간단하다면 숨기든 제거하든 큰 문제가 되지 않을 수도 있습니다.\n하지만 복잡한 경우에는 문제가 될 수 있는데, 컴포넌트가 화면에는 보이지 않더라도 이 컴포넌트는 계속 동작하기 때문입니다.\nDOM에 여전히 남아있으면서 이벤트도 계속 받고, 바인딩 된 데이터가 변경되면 변화 감지 로직도 동작합니다.\n컴포넌트는 원래 동작하던 대로 계속 동작할 것입니다.</p>\n<p>컴포넌트가 보이지 않는 상황에서도 이 컴포넌트와 컴포넌트의 자식 컴포넌트 들은 리소스를 계속 사용합니다.\n애플리케이션 성능은 저하되고 가용 메모리는 줄어들 것이며, 사용자의 반응성은 떨어질 것이지만 사용자는 이 컴포넌트를 여전히 볼 수 없습니다.</p>\n<p>장점이 하나 있다면, 이 엘리먼트를 다시 표시하는 것은 빠릅니다.\n컴포넌트의 이전 상태가 계속 유지되며 화면에 표시될 준비도 이미 끝났기 때문입니다.\n그리고 복잡할수도 있는 컴포넌트 초기화 동작은 이미 실행되었기 때문에 다시 실행되지 않습니다.\n그래서 어떤 경우에는 DOM에서 제거하지 않고 감추기만 하는 것이 좋을 수도 있습니다.</p>\n<p>하지만 굳이 이런 경우가 아니라면, 사용자에게 표시될 필요가 없는 컴포넌트는 DOM에서 완전히 제거하고 사용하던 자원도 반환하는 것이 좋습니다.</p>\n<p><strong>이 개념은 Angular 기본 디렉티브는 물론이고 커스텀 디렉티브에도 적용됩니다.</strong>\n구조 디렉티브를 템플릿에 적용하기 전에, 이 디렉티브를 생성하고 종료하는 비용, 엘리먼트를 DOM에 추가하고 제거하는 비용이 얼마나 필요한지 꼭 고민해 보세요.</p>\n<a id=\"asterisk\"></a>\n<a id=\"the-asterisk--prefix\"></a>\n<!--\n## The asterisk (*) prefix\n-->\n<h2 id=\"별표-asterisk-접두사\">별표(<code>*</code>, asterisk) 접두사<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#별표-asterisk-접두사\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nSurely you noticed the asterisk (*) prefix to the directive name\nand wondered why it is necessary and what it does.\n\nHere is `*ngIf` displaying the hero's name if `hero` exists.\n\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (asterisk)\" region=\"asterisk\">\n&lt;div *ngIf=&quot;hero&quot; class=&quot;name&quot;&gt;{{hero.name}}&lt;/div&gt;\n\n</code-example>\n\nThe asterisk is \"syntactic sugar\" for something a bit more complicated.\nInternally, Angular translates the `*ngIf` _attribute_ into a `<ng-template>` _element_, wrapped around the host element, like this.\n\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (ngif-template)\" region=\"ngif-template\">\n&lt;ng-template [ngIf]=&quot;hero&quot;&gt;\n  &lt;div class=&quot;name&quot;&gt;{{hero.name}}&lt;/div&gt;\n&lt;/ng-template&gt;\n\n</code-example>\n\n* The `*ngIf` directive moved to the `<ng-template>` element where it became a property binding,`[ngIf]`.\n* The rest of the `<div>`, including its class attribute, moved inside the `<ng-template>` element.\n\nThe first form is not actually rendered, only the finished product ends up in the DOM.\n\n<div class=\"lightbox\">\n  <img src='generated/images/guide/structural-directives/hero-div-in-dom.png' alt=\"hero div in DOM\">\n</div>\n\n\nAngular consumed the `<ng-template>` content during its actual rendering and\nreplaced the `<ng-template>` with a diagnostic comment.\n\nThe [`NgFor`](guide/structural-directives#ngFor) and [`NgSwitch...`](guide/structural-directives#ngSwitch) directives follow the same pattern.\n-->\n<p>지금까지 설명한 예제처럼 디렉티브 이름에는 별표(<code>*</code>) 접두사를 사용하는데, 왜 이 접두사가 필요한지 궁금할 수 있습니다.</p>\n<p>아래 코드는 <code>hero</code> 프로퍼티에 객체가 할당되었을 때 히어로의 이름을 표시하는 예제입니다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (asterisk)\" region=\"asterisk\">\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero\" class=\"name\">{{hero.name}}&#x3C;/div>\n\n</code-example>\n<p>별표는 복잡한 문법을 단순하게 표현하는 문법 테크닉(syntactic sugar)입니다.\nAngular가 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> <em>어트리뷰트</em> 를 내부적으로 처리할 때는 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 디렉티브가 적용된 호스트 엘리먼트를 감싸도록 <code>&#x3C;ng-template></code> <em>엘리먼트</em> 를 구성합니다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (ngif-template)\" region=\"ngif-template\">\n&#x3C;ng-template [<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>]=\"hero\">\n  &#x3C;div class=\"name\">{{hero.name}}&#x3C;/div>\n&#x3C;/ng-template>\n\n</code-example>\n<ul>\n<li><code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 디렉티브는 호스트 엘리먼트 대신 <code>&#x3C;ng-template></code> 엘리먼트로 옮겨지며, 프로퍼티 바인딩 형태인 <code>[<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>]</code>로 변환됩니다.</li>\n<li>그리고 호스트 엘리먼트 <code>&#x3C;div></code>는 나머지 어트리뷰트를 그대로 갖고 <code>&#x3C;ng-template></code> 엘리먼트 안으로 이동합니다.</li>\n</ul>\n<p>DOM에는 원래 엘리먼트 대신 변환된 엘리먼트가 적용됩니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/structural-directives/hero-div-in-dom.png\" alt=\"hero div in DOM\" width=\"330\" height=\"67\">\n</div>\n<p>그리고 이 호스트 엘리먼트가 렌더링될 때는 <code>&#x3C;ng-template></code>가 제거되고 디버깅 주석과 안쪽 내용물만 렌더링 됩니다.</p>\n<p>이 과정은 <a href=\"guide/structural-directives#ngFor\"><code>NgFor</code></a>나 <a href=\"guide/structural-directives#ngSwitch\"><code>NgSwitch...</code></a>에서도 비슷합니다.</p>\n<a id=\"ngFor\"></a>\n<a id=\"inside-ngfor\"></a>\n<!--\n## Inside _*ngFor_\n-->\n<h2 id=\"ngfor-내부-동작\"><em>*ngFor</em> 내부 동작<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#ngfor-내부-동작\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAngular transforms the `*ngFor` in similar fashion from asterisk (*) syntax to `<ng-template>` _element_.\n\nHere's a full-featured application of `NgFor`, written both ways:\n\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (inside-ngfor)\" region=\"inside-ngfor\">\n&lt;div *ngFor=&quot;let hero of heroes; let i=index; let odd=odd; trackBy: trackById&quot; [class.odd]=&quot;odd&quot;&gt;\n  ({{i}}) {{hero.name}}\n&lt;/div&gt;\n\n&lt;ng-template ngFor let-hero [ngForOf]=&quot;heroes&quot; let-i=&quot;index&quot; let-odd=&quot;odd&quot; [ngForTrackBy]=&quot;trackById&quot;&gt;\n  &lt;div [class.odd]=&quot;odd&quot;&gt;({{i}}) {{hero.name}}&lt;/div&gt;\n&lt;/ng-template&gt;\n\n</code-example>\n\n\nThis is manifestly more complicated than `ngIf` and rightly so.\nThe `NgFor` directive has more features, both required and optional, than the `NgIf` shown in this guide.\nAt minimum `NgFor` needs a looping variable (`let hero`) and a list (`heroes`).\n\nYou enable these features in the string assigned to `ngFor`, which you write in Angular's [microsyntax](guide/structural-directives#microsyntax).\n\n<div class=\"alert is-helpful\">\n\nEverything _outside_ the `ngFor` string stays with the host element\n(the `<div>`) as it moves inside the `<ng-template>`.\nIn this example, the `[class.odd]=\"odd\"` stays on the `<div>`.\n\n</div>\n-->\n<p>별표(<code>*</code>) 접두사가 붙는 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>도 이와 비슷하게 <code>&#x3C;ng-template></code> <em>엘리먼트</em> 를 활용합니다.</p>\n<p><code>NgFor</code> 디렉티브의 기능이 다양하게 활용된 예제를 확인해 봅시다:</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (inside-ngfor)\" region=\"inside-ngfor\">\n&#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes; let i=index; let odd=odd; trackBy: trackById\" [class.odd]=\"odd\">\n  ({{i}}) {{hero.name}}\n&#x3C;/div>\n\n&#x3C;ng-template <a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a> let-hero [<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngForOf</a>]=\"heroes\" let-i=\"index\" let-odd=\"odd\" [ngForTrackBy]=\"trackById\">\n  &#x3C;div [class.odd]=\"odd\">({{i}}) {{hero.name}}&#x3C;/div>\n&#x3C;/ng-template>\n\n</code-example>\n<p>이 예제는 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 때보다 복잡해 보이고, 실제로도 복잡합니다.\n<code>NgFor</code>는 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>보다 기능이 많습니다. <code>NgFor</code>를 최소한으로 사용하려면 배열(<code>heroes</code>)과 변수(<code>let hero</code>)만 있으면 되지만요.</p>\n<p><code>NgFor</code>의 기능은 <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>에 적용되는 문자열이 어떻게 구성되느냐에 따라 달라집니다.\n이 내용은 <a href=\"guide/structural-directives#microsyntax\">세부 문법</a>에서 자세하게 확인해 보세요.</p>\n<div class=\"alert is-helpful\">\n<p><code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>에 적용되는 문자열 이외에는 모두 호스트 엘리먼트 <code>&#x3C;div></code>에 남아 있으며, <code>&#x3C;ng-template></code> 내부로 호스트 엘리먼트가 이동할 때 함께 움직입니다.\n이 예제로 보면 <code>[class.odd]=\"odd\"</code>는 <code>&#x3C;div></code> 엘리먼트에 그대로 적용되는 것을 확인할 수 있습니다.</p>\n</div>\n<a id=\"microsyntax\"></a>\n<!--\n## Microsyntax\n-->\n<h2 id=\"세부-문법microsyntax\">세부 문법(microsyntax)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#세부-문법microsyntax\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe Angular microsyntax lets you configure a directive in a compact, friendly string.\nThe microsyntax parser translates that string into attributes on the `<ng-template>`:\n\n* The `let` keyword declares a [_template input variable_](guide/structural-directives#template-input-variable)\nthat you reference within the template. The input variables in this example are `hero`, `i`, and `odd`.\nThe parser translates `let hero`, `let i`, and `let odd` into variables named\n`let-hero`, `let-i`, and `let-odd`.\n\n* The microsyntax parser title-cases all directives and prefixes them with the directive's\nattribute name, such as `ngFor`. For example, the `ngFor` input properties,\n`of` and `trackBy`, become `ngForOf` and `ngForTrackBy`, respectively.\nThat's how the directive learns that the list is `heroes` and the track-by function is `trackById`.\n\n* As the `NgFor` directive loops through the list, it sets and resets properties of its own _context_ object.\nThese properties can include, but aren't limited to, `index`, `odd`, and a special property\nnamed `$implicit`.\n\n* The `let-i` and `let-odd` variables were defined as `let i=index` and `let odd=odd`.\nAngular sets them to the current value of the context's `index` and `odd` properties.\n\n* The context property for `let-hero` wasn't specified.\nIts intended source is implicit.\nAngular sets `let-hero` to the value of the context's `$implicit` property,\nwhich `NgFor` has initialized with the hero for the current iteration.\n\n* The [`NgFor` API guide](api/common/NgForOf \"API: NgFor\")\ndescribes additional `NgFor` directive properties and context properties.\n\n* The `NgForOf` directive implements `NgFor`. Read more about additional `NgForOf` directive properties and context properties in the [NgForOf API reference](api/common/NgForOf).\n-->\n<p>세부 문법을 활용하면 복잡한 디렉티브 설정을 문자열로 간단하게 할 수 있습니다.\n세부 문법 파서는 어트리뷰트에 사용된 문자열을 <code>&#x3C;ng-template></code>의 어트리뷰트로 이렇게 변환합니다:</p>\n<ul>\n<li>\n<p><code>let</code> 키워드는 <a href=\"guide/structural-directives#template-input-variable\"><em>템플릿 입력 변수</em></a>를 선언합니다. 이 변수는 템플릿 안에서 참조할 수 있으며, <code>hero</code>나 <code>i</code>, <code>odd</code> 등이 템플릿 변수에 해당합니다.\n문자열에 있던 <code>let hero</code>, <code>let i</code>, <code>let odd</code>를 파서가 처리하고 나면 <code>let-hero</code>, <code>let-i</code>, <code>let-odd</code>와 같은 이름으로 변경됩니다.</p>\n</li>\n<li>\n<p>그리고 세부문법 파서는 엘리먼트에 사용된 디렉티브 어트리뷰트 이름을 실제 디렉티브와 연결합니다.\n<code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>의 경우에는 <code>of</code>와 <code>trackBy</code>를 <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngForOf</a></code>와 <code>ngForTrackBy</code>로 연결하는 식입니다.\n이 작업을 거쳐야 디렉티브에서 처리하는 배열이 <code>heroes</code>이며 <code>trackById</code> 함수로 객체를 추적할 수 있습니다.</p>\n</li>\n<li>\n<p><code>NgFor</code> 디렉티브가 배열을 순회할 때 각 싸이클마다 <code>NgFor</code> 컨텍스트에만 적용되는 프로퍼티가 있습니다.\n<code>index</code>나 <code>odd</code>, <code>$implicit</code>가 이런 프로퍼티에 해당됩니다.</p>\n</li>\n<li>\n<p><code>let-i</code>나 <code>let-odd</code>와 같은 변수는 <code>let i=index</code>나 <code>let odd=odd</code>를 사용할 때만 선언됩니다.\n그리고 이 때 사용되는 <code>index</code>와 <code>odd</code> 프로퍼티는 <code>NgFor</code> 컨텍스트에 맞게 Angular가 각각 할당합니다.</p>\n</li>\n<li>\n<p>하지만 <code>let-hero</code> 변수는 소스 코드에 따로 선언되며 외부에서는 확인할 수 없습니다. 좀 더 자세하게 설명하면, <code>let-hero</code> 변수는 컨텍스트의 <code>$implicit</code> 프로퍼티 안에 선언되며, 현재 순회하는 배열에 맞게 Angular가 값을 할당합니다.</p>\n</li>\n<li>\n<p><code>NgFor</code> 디렉티브의 프로퍼티와 컨텍스트 프로퍼티에 대해 더 알아보려면 <a href=\"api/common/NgForOf\" title=\"API: NgFor\"><code>NgFor</code> API 문서</a>를 참고하세요.</p>\n</li>\n<li>\n<p><code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> 디렉티브는 <code>NgFor</code> 디렉티블르 기반으로 만들어졌습니다. <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> 디렉티브의 프로퍼티와 컨텍스트 프로퍼티에 대해 더 알아보려면 <a href=\"api/common/NgForOf\">NgForOf API 문서</a>를 참고하세요.</p>\n</li>\n</ul>\n<!--\n### Writing your own structural directives\n-->\n<h3 id=\"커스텀-구조-디렉티브-구현하기\">커스텀 구조 디렉티브 구현하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#커스텀-구조-디렉티브-구현하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThese microsyntax mechanisms are also available to you when you write your own structural directives.\nFor example, microsyntax in Angular allows you to write `<div *ngFor=\"let item of items\">{{item}}</div>`\ninstead of `<ng-template ngFor let-item [ngForOf]=\"items\"><div>{{item}}</div></ng-template>`.\nThe following sections provide detailed information on constraints, grammar,\nand translation of microsyntax.\n-->\n<p>세부문법은 커스텀 구조 디렉티브에서도 동일하게 동작합니다.\n그래서 <code>&#x3C;ng-template <a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a> let-item [<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngForOf</a>]=\"items\">&#x3C;div>{{item}}&#x3C;/div>&#x3C;/ng-template></code> 라고 작성하지 않고 <code>&#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let item of items\">{{item}}&#x3C;/div></code>처럼 작성해도 됩니다.\n다음 섹션에서는 세부문법의 제약사항, 문법, 변환결과에 대해 자세하게 알아봅시다.</p>\n<!--\n### Constraints\n-->\n<h3 id=\"제약사항\">제약사항<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#제약사항\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nMicrosyntax must meet the following requirements:\n\n- It must be known ahead of time so that IDEs can parse it without knowing the underlying semantics of the directive or what directives are present.\n- It must translate to key-value attributes in the DOM.\n-->\n<p>세부문법에는 이런 제약사항들이 있습니다:</p>\n<ul>\n<li>세부문법은 문자열이기 때문에 IDE가 제대로 처리하지 못할 수 있습니다. 어떤 디렉티브가 사용되었는지 개발자가 충분히 알고 있어야 합니다.</li>\n<li>DOM에서 키-값 어트리뷰트로 변환되어야 합니다.</li>\n</ul>\n<!--\n### Grammar\n-->\n<h3 id=\"문법\">문법<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#문법\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nWhen you write your own structural directives, use the following grammar:\n\n```\n*:prefix=\"( :let | :expression ) (';' | ',')? ( :let | :as | :keyExp )*\"\n```\n\nThe following tables describe each portion of the microsyntax grammar.\n-->\n<p>커스텀 구조 디렉티브를 만들었다면 이렇게 사용해야 합니다:</p>\n<code-example>\n*:prefix=\"( :let | :expression ) (';' | ',')? ( :let | :as | :keyExp )*\"\n</code-example>\n<p>세부문법의 각 부분에 대해 자세하게 알아봅시다.</p>\n<!-- What should I put in the table headers? -->\n<table>\n  <tbody><tr>\n    <th></th>\n    <th></th>\n  </tr>\n  <tr>\n    <td><code>prefix</code></td>\n    <!--\n    <td>HTML attribute key</td>\n    -->\n    <td>HTML 어트리뷰트 키</td>\n  </tr>\n  <tr>\n    <td><code>key</code></td>\n    <!--\n    <td>HTML attribute key</td>\n    -->\n    <td>HTML 어트리뷰트 키</td>\n  </tr>\n  <tr>\n    <td><code>local</code></td>\n    <!--\n    <td>local variable name used in the template</td>\n    -->\n    <td>템플릿에 있는 로벌 변수 이름</td>\n  </tr>\n  <tr>\n    <td><code>export</code></td>\n    <!--\n    <td>value exported by the directive under a given name</td>\n    -->\n    <td>디렉티브 외부로 공개되는 값</td>\n  </tr>\n  <tr>\n    <td><code>expression</code></td>\n    <!--\n    <td>standard Angular expression</td>\n    -->\n    <td>일반적인 Angular 표현식</td>\n  </tr>\n</tbody></table>\n<!-- The items in this table seem different. Is there another name for how we should describe them? -->\n<table>\n  <tbody><tr>\n    <th></th>\n  </tr>\n  <tr>\n    <td colspan=\"3\"><code>keyExp = :key \":\"? :expression (\"as\" :local)? \";\"? </code></td>\n  </tr>\n  <tr>\n    <td colspan=\"3\"><code>let = \"let\" :local \"=\" :export \";\"?</code></td>\n  </tr>\n  <tr>\n    <td colspan=\"3\"><code>as = :export \"as\" :local \";\"?</code></td>\n  </tr>\n</tbody></table>\n<!--\n### Translation\n-->\n<h3 id=\"변환결과\">변환결과<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#변환결과\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nA microsyntax is translated to the normal binding syntax as follows:\n-->\n<p>세부문법이 파서로 처리되면 다음과 같이 변환됩니다:</p>\n<!-- What to put in the table headers below? Are these correct?-->\n<!--\n<table>\n  <tr>\n    <th>Microsyntax</th>\n    <th>Translation</th>\n  </tr>\n  <tr>\n    <td><code>prefix</code> and naked <code>expression</code></td>\n    <td><code>[prefix]=\"expression\"</code></td>\n  </tr>\n  <tr>\n    <td><code>keyExp</code></td>\n    <td><code>[prefixKey] \"expression\"\n    (let-prefixKey=\"export\")</code>\n    <br />\n    Notice that the <code>prefix</code>\n    is added to the <code>key</code>\n    </td>\n  </tr>\n  <tr>\n    <td><code>let</code></td>\n    <td><code>let-local=\"export\"</code></td>\n  </tr>\n</table>\n-->\n<table>\n  <tbody><tr>\n    <th>세부문법</th>\n    <th>변환결과</th>\n  </tr>\n  <tr>\n    <td><code>prefix</code>, <code>expression</code></td>\n    <td><code>[prefix]=\"expression\"</code></td>\n  </tr>\n  <tr>\n    <td><code>keyExp</code></td>\n    <td><code>[prefixKey] \"expression\"\n    (let-prefixKey=\"export\")</code>\n    <br>\n    <code>key</code> 앞에 <code>prefix</code>가 추가됩니다.\n    </td>\n  </tr>\n  <tr>\n    <td><code>let</code></td>\n    <td><code>let-local=\"export\"</code></td>\n  </tr>\n</tbody></table>\n<!--\n### Microsyntax examples\n-->\n<h3 id=\"세부문법-예제\">세부문법 예제<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#세부문법-예제\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe following table demonstrates how Angular desugars microsyntax.\n\n<table>\n  <tr>\n    <th>Microsyntax</th>\n    <th>Desugared</th>\n  </tr>\n  <tr>\n    <td><code>*ngFor=\"let item of [1,2,3]\"</code></td>\n    <td><code>&lt;ng-template ngFor let-item [ngForOf]=\"[1,2,3]\"&gt;</code></td>\n  </tr>\n  <tr>\n    <td><code>*ngFor=\"let item of [1,2,3] as items; trackBy: myTrack; index as i\"</code></td>\n    <td><code>&lt;ng-template ngFor let-item [ngForOf]=\"[1,2,3]\" let-items=\"ngForOf\" [ngForTrackBy]=\"myTrack\" let-i=\"index\"&gt;</code>\n    </td>\n  </tr>\n  <tr>\n    <td><code>*ngIf=\"exp\"</code></td>\n    <td><code>&lt;ng-template [ngIf]=\"exp\"&gt;</code></td>\n  </tr>\n  <tr>\n    <td><code>*ngIf=\"exp as value\"</code></td>\n    <td><code>&lt;ng-template [ngIf]=\"exp\" let-value=\"ngIf\"&gt;</code></td>\n  </tr>\n</table>\n\nStudying the\n[source code for `NgIf`](https://github.com/angular/angular/blob/master/packages/common/src/directives/ng_if.ts \"Source: NgIf\")\nand [`NgForOf`](https://github.com/angular/angular/blob/master/packages/common/src/directives/ng_for_of.ts \"Source: NgForOf\")\nis a great way to learn more.\n-->\n<p>Angular가 세부문법의 문법 설탕을 제거하고 나면(desugar) 다음과 같이 변환됩니다.</p>\n<table>\n  <tbody><tr>\n    <th>세부문법</th>\n    <th>변환결과</th>\n  </tr>\n  <tr>\n    <td><code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let item of [1,2,3]\"</code></td>\n    <td><code>&#x3C;ng-template <a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a> let-item [<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngForOf</a>]=\"[1,2,3]\"></code></td>\n  </tr>\n  <tr>\n    <td><code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let item of [1,2,3] as items; trackBy: myTrack; index as i\"</code></td>\n    <td><code>&#x3C;ng-template <a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a> let-item [<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngForOf</a>]=\"[1,2,3]\" let-items=\"<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngForOf</a>\" [ngForTrackBy]=\"myTrack\" let-i=\"index\"></code>\n    </td>\n  </tr>\n  <tr>\n    <td><code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"exp\"</code></td>\n    <td><code>&#x3C;ng-template [<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>]=\"exp\"></code></td>\n  </tr>\n  <tr>\n    <td><code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"exp as value\"</code></td>\n    <td><code>&#x3C;ng-template [<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>]=\"exp\" let-value=\"<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>\"></code></td>\n  </tr>\n</tbody></table>\n<p>세부문법에 대해 더 자세하게 알아보려면 <a href=\"https://github.com/angular/angular/blob/master/packages/common/src/directives/ng_if.ts\" title=\"Source: NgIf\"><code>NgIf</code> 소스 코드</a>나 <a href=\"https://github.com/angular/angular/blob/master/packages/common/src/directives/ng_for_of.ts\" title=\"Source: NgForOf\"><code>NgForOf</code> 소스 코드</a>를 참고하는 것도 좋습니다.</p>\n<a id=\"template-input-variable\"></a>\n<a id=\"template-input-variables\"></a>\n<!--\n## Template input variable\n-->\n<h2 id=\"템플릿-입력-변수-template-input-variable\">템플릿 입력 변수 (Template input variable)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#템플릿-입력-변수-template-input-variable\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nA _template input variable_ is a variable whose value you can reference _within_ a single instance of the template.\nThere are several such variables in this example: `hero`, `i`, and `odd`.\nAll are preceded by the keyword `let`.\n\nA _template input variable_ is **_not_** the same as a\n[template _reference_ variable](guide/template-reference-variables),\nneither _semantically_ nor _syntactically_.\n\nYou declare a template _input_ variable using the `let` keyword (`let hero`).\nThe variable's scope is limited to a _single instance_ of the repeated template.\nYou can use the same variable name again in the definition of other structural directives.\n\nYou declare a template _reference_ variable by prefixing the variable name with `#` (`#var`).\nA _reference_ variable refers to its attached element, component or directive.\nIt can be accessed _anywhere_ in the _entire template_.\n\nTemplate _input_ and _reference_ variable names have their own namespaces. The `hero` in `let hero` is never the same\nvariable as the `hero` declared as `#hero`.\n-->\n<p><em>템플릿 입력 변수</em> 는 템플릿 인스턴스 <em>안에서</em> 참조할 수 있는 변수입니다.\n위에서 살펴본 예제에서는 <code>hero</code>, <code>i</code>, <code>odd</code>가 템플릿 입력 변수이며, <code>let</code> 키워드를 사용해서 선언합니다.</p>\n<p><em>템플릿 입력 변수</em> 는 <em>용도</em> 나 <em>문법</em> 측면에서 봤을 때 <a href=\"guide/template-reference-variables\">템플릿 <em>참조</em> 변수</a>와는 <strong><em>다릅니다</em></strong>.</p>\n<p>템플릿 <em>입력</em> 변수는 <code>let hero</code>와 같이 <code>let</code> 키워드를 사용해서 선언합니다.\n이 변수의 스코프는 반복되는 템플릿 <em>인스턴스 하나</em> 로만 제한되며, 템플릿 안에 있는 다른 구조 디렉티브에도 같은 이름의 변수를 사용할 수 있습니다.</p>\n<p>반면에 템플릿 <em>참조</em> 변수는 <code>#var</code>와 같이 <code>#</code> 접두사를 붙여 선언합니다.\n이 변수는 템플릿 참조 변수가 붙은 엘리먼트나 컴포넌트, 디렉티브를 가리키며, <em>템플릿 전체</em> 범위에서 이 엘리먼트를 자유롭게 참조할 수 있습니다.</p>\n<p>템플릿 <em>입력</em> 변수와 <em>참조</em> 변수의 이름은 각각의 네임스페이스 안에 존재합니다.\n그래서 <code>let hero</code>라고 선언했을 때의 <code>hero</code>와 <code>#hero</code>라고 선언했을 때의 <code>hero</code>는 다른 변수입니다.</p>\n<a id=\"one-per-element\"></a>\n<a id=\"one-structural-directive-per-host-element\"></a>\n<!--\n## One structural directive per host element\n-->\n<h2 id=\"구조-디렉티브는-호스트-엘리먼트에-하나만\">구조 디렉티브는 호스트 엘리먼트에 하나만<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#구조-디렉티브는-호스트-엘리먼트에-하나만\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nSomeday you'll want to repeat a block of HTML but only when a particular condition is true.\nYou'll _try_ to put both an `*ngFor` and an `*ngIf` on the same host element.\nAngular won't let you. You may apply only one _structural_ directive to an element.\n\nThe reason is simplicity. Structural directives can do complex things with the host element and its descendents.\nWhen two directives lay claim to the same host element, which one takes precedence?\nWhich should go first, the `NgIf` or the `NgFor`? Can the `NgIf` cancel the effect of the `NgFor`?\nIf so (and it seems like it should be so), how should Angular generalize the ability to cancel for other structural directives?\n\nThere are no easy answers to these questions. Prohibiting multiple structural directives makes them moot.\nThere's an easy solution for this use case: put the `*ngIf` on a container element that wraps the `*ngFor` element.\nOne or both elements can be an [`ng-container`](guide/structural-directives#ngcontainer) so you don't have to introduce extra levels of HTML.\n-->\n<p><code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>로 순회하는 배열의 각 항목이 특정 조건일때만 이 항목을 화면에 사용하도록 하려고 합니다.\n그러면 호스트 엘리먼트에 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>를 사용하면서 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>를 함께 사용하는 것이 맞다고 생각할 수 있습니다.\n하지만 이 문법은 동작하지 않습니다. <em>구조</em> 디렉티브는 한 엘리먼트에 하나만 적용할 수 있습니다.</p>\n<p>이유는 단순합니다. 구조 디렉티브를 다른 구조 디렉티브와 함께 사용하는 로직은 간단하게 일반화 할 수 없습니다.\n하나의 호스트 엘리먼트에 구조 디렉티브가 여러개 적용되면 어떻게 될까요?\n<code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>와 <code>NgFor</code>중 어떤 것이 먼저 처리되어야 할까요? <code>NgFor</code> 전체에 대해 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>가 적용되는 것이 맞을까요?\n<code>NgFor</code>이외의 구조 디렉티브에도 이 정책을 적용하는 것이 맞을까요?</p>\n<p>답을 내리기는 쉽지 않습니다. 구조 디렉티브가 동시에 여러개 사용된다면 각각의 경우를 모두 따져봐야 합니다.\n하지만 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>를 적용한 엘리먼트 안에 또 다른 엘리먼트를 두고 이 엘리먼트에 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>를 적용하는 경우라면 간단합니다.\n하나 또는 두 개의 엘리먼트는 <a href=\"guide/structural-directives#ngcontainer\"><code>ng-container</code></a>의 대상이 될 수 있기 때문에, 기존에 활용하던 HTML에서 크게 벗어나지 않습니다.</p>\n<a id=\"ngSwitch\"></a>\n<!--\n## Inside _NgSwitch_ directives\n-->\n<h2 id=\"ngswitch-내부-동작\"><em>NgSwitch</em> 내부 동작<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#ngswitch-내부-동작\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe Angular _NgSwitch_ is actually a set of cooperating directives: `NgSwitch`, `NgSwitchCase`, and `NgSwitchDefault`.\n\nHere's an example.\n\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (ngswitch)\" region=\"ngswitch\">\n&lt;div [ngSwitch]=&quot;hero?.emotion&quot;&gt;\n  &lt;app-happy-hero    *ngSwitchCase=&quot;&#39;happy&#39;&quot;    [hero]=&quot;hero&quot;&gt;&lt;/app-happy-hero&gt;\n  &lt;app-sad-hero      *ngSwitchCase=&quot;&#39;sad&#39;&quot;      [hero]=&quot;hero&quot;&gt;&lt;/app-sad-hero&gt;\n  &lt;app-confused-hero *ngSwitchCase=&quot;&#39;confused&#39;&quot; [hero]=&quot;hero&quot;&gt;&lt;/app-confused-hero&gt;\n  &lt;app-unknown-hero  *ngSwitchDefault           [hero]=&quot;hero&quot;&gt;&lt;/app-unknown-hero&gt;\n&lt;/div&gt;\n\n</code-example>\n\nThe switch value assigned to `NgSwitch` (`hero.emotion`) determines which\n(if any) of the switch cases are displayed.\n\n`NgSwitch` itself is not a structural directive.\nIt's an _attribute_ directive that controls the behavior of the other two switch directives.\nThat's why you write `[ngSwitch]`, never `*ngSwitch`.\n\n`NgSwitchCase` and `NgSwitchDefault` _are_ structural directives.\nYou attach them to elements using the asterisk (*) prefix notation.\nAn `NgSwitchCase` displays its host element when its value matches the switch value.\nThe `NgSwitchDefault` displays its host element when no sibling `NgSwitchCase` matches the switch value.\n\n\n<div class=\"alert is-helpful\">\n\nThe element to which you apply a directive is its _host_ element.\nThe `<happy-hero>` is the host element for the happy `*ngSwitchCase`.\nThe `<unknown-hero>` is the host element for the `*ngSwitchDefault`.\n</div>\n\n\nAs with other structural directives, the `NgSwitchCase` and `NgSwitchDefault`\ncan be desugared into the `<ng-template>` element form.\n\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (ngswitch-template)\" region=\"ngswitch-template\">\n&lt;div [ngSwitch]=&quot;hero?.emotion&quot;&gt;\n  &lt;ng-template [ngSwitchCase]=&quot;&#39;happy&#39;&quot;&gt;\n    &lt;app-happy-hero [hero]=&quot;hero&quot;&gt;&lt;/app-happy-hero&gt;\n  &lt;/ng-template&gt;\n  &lt;ng-template [ngSwitchCase]=&quot;&#39;sad&#39;&quot;&gt;\n    &lt;app-sad-hero [hero]=&quot;hero&quot;&gt;&lt;/app-sad-hero&gt;\n  &lt;/ng-template&gt;\n  &lt;ng-template [ngSwitchCase]=&quot;&#39;confused&#39;&quot;&gt;\n    &lt;app-confused-hero [hero]=&quot;hero&quot;&gt;&lt;/app-confused-hero&gt;\n  &lt;/ng-template &gt;\n  &lt;ng-template ngSwitchDefault&gt;\n    &lt;app-unknown-hero [hero]=&quot;hero&quot;&gt;&lt;/app-unknown-hero&gt;\n  &lt;/ng-template&gt;\n&lt;/div&gt;\n\n</code-example>\n-->\n<p>Angular 기본 디렉티브인 <em>NgSwitch</em> 를 사용한다는 것은 사실 <code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code>, <code><a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">NgSwitchCase</a></code>, <code><a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">NgSwitchDefault</a></code> 디렉티브를 함께 사용하는 것을 의미합니다.</p>\n<p>예제를 확인해 봅시다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (ngswitch)\" region=\"ngswitch\">\n&#x3C;div [<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a>]=\"hero?.emotion\">\n  &#x3C;app-happy-hero    *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'happy'\"    [hero]=\"hero\">&#x3C;/app-happy-hero>\n  &#x3C;app-sad-hero      *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'sad'\"      [hero]=\"hero\">&#x3C;/app-sad-hero>\n  &#x3C;app-confused-hero *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'confused'\" [hero]=\"hero\">&#x3C;/app-confused-hero>\n  &#x3C;app-unknown-hero  *<a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">ngSwitchDefault</a>           [hero]=\"hero\">&#x3C;/app-unknown-hero>\n&#x3C;/div>\n\n</code-example>\n<p><code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code>는 적용되는 값에 해당되는 템플릿을 화면에 표시합니다. 위 예제의 경우에는 <code>hero.emotion</code>에 의해 결정됩니다.</p>\n<p><code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code> 디렉티브 자체는 구조 디렉티브가 아닙니다.\n<code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code> 디렉티브는 <em>어트리뷰트</em> 디렉티브이며, 다른 두 디렉티브의 동작을 조절합니다.\n그래서 <code>*<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a></code>와 같이 지정하지 않고 <code>[<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a>]</code>로 지정합니다.</p>\n<p><code><a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">NgSwitchCase</a></code>와 <code><a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">NgSwitchDefault</a></code>는 구조 디렉티브입니다.\n그래서 이 디렉티브들은 별표(<code>*</code>)를 사용하면서 엘리먼트에 지정합니다.\n그러면 지정된 값에 해당하는 <code><a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">NgSwitchCase</a></code>가 화면에 표시되고, 아무 값도 해당되지 않으면 <code><a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">NgSwitchDefault</a></code>가 화면에 표시됩니다.</p>\n<div class=\"alert is-helpful\">\n<p>각각의 디렉티브가 적용된 엘리먼트가 그 디렉티브의 <em>호스트</em> 엘리먼트입니다.\n그래서 <code>*<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a></code>의 호스트 엘리먼트는 <code>&#x3C;app-happy-hero></code>이고, <code>*<a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">ngSwitchDefault</a></code>의 호스트 엘리먼트는 <code>&#x3C;app-unknown-hero></code>입니다.</p>\n</div>\n<p>다른 구조 디렉티브와 마찬가지로, <code><a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">NgSwitchCase</a></code>와 <code><a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">NgSwitchDefault</a></code>도 Angular가 렌더링할 때는 <code>&#x3C;ng-template></code> 엘리먼트로 변환됩니다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (ngswitch-template)\" region=\"ngswitch-template\">\n&#x3C;div [<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a>]=\"hero?.emotion\">\n  &#x3C;ng-template [<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>]=\"'happy'\">\n    &#x3C;app-happy-hero [hero]=\"hero\">&#x3C;/app-happy-hero>\n  &#x3C;/ng-template>\n  &#x3C;ng-template [<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>]=\"'sad'\">\n    &#x3C;app-sad-hero [hero]=\"hero\">&#x3C;/app-sad-hero>\n  &#x3C;/ng-template>\n  &#x3C;ng-template [<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>]=\"'confused'\">\n    &#x3C;app-confused-hero [hero]=\"hero\">&#x3C;/app-confused-hero>\n  &#x3C;/ng-template >\n  &#x3C;ng-template <a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">ngSwitchDefault</a>>\n    &#x3C;app-unknown-hero [hero]=\"hero\">&#x3C;/app-unknown-hero>\n  &#x3C;/ng-template>\n&#x3C;/div>\n\n</code-example>\n<a id=\"prefer-asterisk\"></a>\n<!--\n## Prefer the asterisk (*) syntax.\n-->\n<h2 id=\"별표-문법을-사용하세요\">별표(<code>*</code>) 문법을 사용하세요.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#별표-문법을-사용하세요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe asterisk (*) syntax is more clear than the desugared form.\nUse [&lt;ng-container&gt;](guide/structural-directives#ng-container) when there's no single element\nto host the directive.\n\nWhile there's rarely a good reason to apply a structural directive in template _attribute_ or _element_ form,\nit's still important to know that Angular creates a `<ng-template>` and to understand how it works.\nYou'll refer to the `<ng-template>` when you [write your own structural directive](guide/structural-directives#unless).\n-->\n<p><code>&#x3C;ng-template></code>을 직접 사용하는 것보다는 별표(<code>*</code>)를 사용한 문법이 좀 더 간결합니다.\n그리고 별표(<code>*</code>) 문법을 사용하지 않고 <em>어트리뷰트</em> 형태나 <code>&#x3C;ng-template></code> 형태로 구조 디렉티브를 사용했을 때 더 나은 점도 딱히 없습니다.\n그래서 구조 디렉티브는 별표(<code>*</code>)를 붙여 축약된 문법으로 사용하는 것을 권장합니다.</p>\n<p>별표(<code>*</code>) 문법이 사용된 엘리먼트는 Angular가 <code>&#x3C;ng-template></code>으로 변환한다는 것을 알고 넘어가는 것이 중요합니다.\n<code>&#x3C;ng-template></code>은 <a href=\"guide/structural-directives#unless\">커스텀 구조 디렉티브</a>를 정의할 때도 활용됩니다.</p>\n<p>디렉티브가 조작하는 엘리먼트가 여러개라면 <a href=\"guide/structural-directives#ng-container\">&#x3C;ng-container></a>를 사용하는 것도 좋습니다.</p>\n<a id=\"template\"></a>\n<a id=\"the-ng-template\"></a>\n<!--\n## The *&lt;ng-template&gt;*\n-->\n<h2 id=\"ng-template\"><em>&#x3C;ng-template></em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#ng-template\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe &lt;ng-template&gt; is an Angular element for rendering HTML.\nIt is never displayed directly.\nIn fact, before rendering the view, Angular _replaces_ the `<ng-template>` and its contents with a comment.\n\nIf there is no structural directive and you merely wrap some elements in a `<ng-template>`,\nthose elements disappear.\nThat's the fate of the middle \"Hip!\" in the phrase \"Hip! Hip! Hooray!\".\n\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (template-tag)\" region=\"template-tag\">\n&lt;p&gt;Hip!&lt;/p&gt;\n&lt;ng-template&gt;\n  &lt;p&gt;Hip!&lt;/p&gt;\n&lt;/ng-template&gt;\n&lt;p&gt;Hooray!&lt;/p&gt;\n\n</code-example>\n\nAngular erases the middle \"Hip!\", leaving the cheer a bit less enthusiastic.\n\n<div class=\"lightbox\">\n  <img src='generated/images/guide/structural-directives/template-rendering.png' alt=\"template tag rendering\">\n</div>\n\nA structural directive puts a `<ng-template>` to work\nas you'll see when you [write your own structural directive](guide/structural-directives#unless).\n-->\n<p><code>&#x3C;ng-template></code>은 Angular가 HTML을 렌더링할 때 사용하는 엘리먼트이며, 화면에 직접 노출되지는 않습니다.\n그리고 <code>&#x3C;ng-template></code> 안에 있는 내용은 Angular가 뷰를 렌더링하기 전에 주석으로 변경됩니다.</p>\n<p>구조 디렉티브를 하나도 사용하지 않고 엘리먼트를 <code>&#x3C;ng-template></code>으로 감싸기만 하면, 이 엘리먼트는 화면에 표시되지 않습니다.\n그래서 다음 \"Hip! Hip! Hooray!\" 문단들 중 두 번째 문단인 \"Hip!\"은 표시되지 않습니다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (template-tag)\" region=\"template-tag\">\n&#x3C;p>Hip!&#x3C;/p>\n&#x3C;ng-template>\n  &#x3C;p>Hip!&#x3C;/p>\n&#x3C;/ng-template>\n&#x3C;p>Hooray!&#x3C;/p>\n\n</code-example>\n<p>Angular는 두 번째 문단을 제거하면서 개발자가 보기에는 의미없어 보이는 주석을 남깁니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/structural-directives/template-rendering.png\" alt=\"template tag rendering\" width=\"520\" height=\"94\">\n</div>\n<p><code>&#x3C;ng-template></code>는 구조 디렉티브가 적용될 때에만 그 용도에 맞게 동작하며, <a href=\"guide/structural-directives#unless\">커스텀 구조 디렉티브를 구현</a>할 때도 활용됩니다.</p>\n<a id=\"ngcontainer\"></a>\n<a id=\"ng-container\"></a>\n<!--\n## Group sibling elements with &lt;ng-container&gt;\n-->\n<h2 id=\"비슷한-엘리먼트-묶기--ng-container\">비슷한 엘리먼트 묶기 : &#x3C;ng-container><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#비슷한-엘리먼트-묶기--ng-container\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThere's often a _root_ element that can and should host the structural directive.\nThe list element (`<li>`) is a typical host element of an `NgFor` repeater.\n\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (ngfor-li)\" region=\"ngfor-li\">\n&lt;li *ngFor=&quot;let hero of heroes&quot;&gt;{{hero.name}}&lt;/li&gt;\n\n</code-example>\n\nWhen there isn't a host element, you can usually wrap the content in a native HTML container element,\nsuch as a `<div>`, and attach the directive to that wrapper.\n\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (ngif)\" region=\"ngif\">\n&lt;div *ngIf=&quot;hero&quot; class=&quot;name&quot;&gt;{{hero.name}}&lt;/div&gt;\n\n</code-example>\n\n\nIntroducing another container element&mdash;typically a `<span>` or `<div>`&mdash;to\ngroup the elements under a single _root_ is usually harmless.\n_Usually_ ... but not _always_.\n\nThe grouping element may break the template appearance because CSS styles\nneither expect nor accommodate the new layout.\nFor example, suppose you have the following paragraph layout.\n\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (ngif-span)\" region=\"ngif-span\">\n&lt;p&gt;\n  I turned the corner\n  &lt;span *ngIf=&quot;hero&quot;&gt;\n    and saw {{hero.name}}. I waved\n  &lt;/span&gt;\n  and continued on my way.\n&lt;/p&gt;\n\n</code-example>\n\n\nYou also have a CSS style rule that happens to apply to a `<span>` within a `<p>`aragraph.\n\n<code-example path=\"structural-directives/src/app/app.component.css\" header=\"src/app/app.component.css (p-span)\" region=\"p-span\">\np span { color: red; font-size: 70%; }\n\n</code-example>\n\n\nThe constructed paragraph renders strangely.\n\n<div class=\"lightbox\">\n  <img src='generated/images/guide/structural-directives/bad-paragraph.png' alt=\"spanned paragraph with bad style\">\n</div>\n\n\nThe `p span` style, intended for use elsewhere, was inadvertently applied here.\n\nAnother problem: some HTML elements require all immediate children to be of a specific type.\nFor example, the `<select>` element requires `<option>` children.\nYou can't wrap the _options_ in a conditional `<div>` or a `<span>`.\n\nWhen you try this,\n\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (select-span)\" region=\"select-span\">\n&lt;div&gt;\n  Pick your favorite hero\n  (&lt;label&gt;&lt;input type=&quot;checkbox&quot; checked (change)=&quot;showSad = !showSad&quot;&gt;show sad&lt;/label&gt;)\n&lt;/div&gt;\n&lt;select [(ngModel)]=&quot;hero&quot;&gt;\n  &lt;span *ngFor=&quot;let h of heroes&quot;&gt;\n    &lt;span *ngIf=&quot;showSad || h.emotion !== &#39;sad&#39;&quot;&gt;\n      &lt;option [ngValue]=&quot;h&quot;&gt;{{h.name}} ({{h.emotion}})&lt;/option&gt;\n    &lt;/span&gt;\n  &lt;/span&gt;\n&lt;/select&gt;\n\n</code-example>\n\n\nthe drop down is empty.\n\n<div class=\"lightbox\">\n  <img src='generated/images/guide/structural-directives/bad-select.png' alt=\"spanned options don't work\">\n</div>\n\n\nThe browser won't display an `<option>` within a `<span>`.\n-->\n<p>구조 디렉티브의 호스트 엘리먼트는 보통 엘리먼트 하나입니다.\n예를 들어 리스트 엘리먼트(<code>&#x3C;li></code>)에 <code>NgFor</code>를 사용한다면 다음과 같이 구현할 수 있습니다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (ngfor-li)\" region=\"ngfor-li\">\n&#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">{{hero.name}}&#x3C;/li>\n\n</code-example>\n<p>하지만 호스트 엘리먼트가 하나가 아닌 경우가 있습니다.\n이런 경우라면 네이티브 HTML인 <code>&#x3C;div></code>로 엘리먼트를 감싸고 이 <code>&#x3C;div></code>에 디렉티브를 적용해도 됩니다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (ngif)\" region=\"ngif\">\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero\" class=\"name\">{{hero.name}}&#x3C;/div>\n\n</code-example>\n<p>호스트 엘리먼트 하나 밑에 <code>&#x3C;span></code>이나 <code>&#x3C;div></code> 엘리먼트를 사용하는 것은 일반적으로 문제가 없습니다.\n<em>보통은</em> 그렇죠. 하지만 <em>항상</em> 그런 것은 아닙니다.</p>\n<p>엘리먼트를 묶으면 이 엘리먼트가 템플릿의 어떤 자리에 위치하는지에 따라서 CSS 스타일이 잘못 지정되거나 레이아웃 자체가 틀어질 수 있습니다.\n예를 들어 다음과 같은 문단이 있다고 합시다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (ngif-span)\" region=\"ngif-span\">\n&#x3C;p>\n  I turned the corner\n  &#x3C;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero\">\n    and saw {{hero.name}}. I waved\n  &#x3C;/span>\n  and continued on my way.\n&#x3C;/p>\n\n</code-example>\n<p>그리고 전역 CSS 스타일에는 <code>&#x3C;p></code> 안에 있는 <code>&#x3C;span></code>에 다음과 같은 스타일을 지정하고 있다고 합시다.</p>\n<code-example path=\"structural-directives/src/app/app.component.css\" header=\"src/app/app.component.css (p-span)\" region=\"p-span\">\np span { color: red; font-size: 70%; }\n\n</code-example>\n<p>그러면 다음과 같은 결과물이 표시되지만, 약간 이상합니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/structural-directives/bad-paragraph.png\" alt=\"spanned paragraph with bad style\" width=\"452\" height=\"15\">\n</div>\n<p><code>p span</code> 스타일은 전역에 사용하려고 선언했지만, 이곳에는 적용되지 않는 것이 더 나은 것 같습니다.</p>\n<p>그리고 또 다른 문제도 있습니다. 일부 엘리먼트는 바로 밑 자식 엘리먼트에 특정한 형태를 요구하는 경우도 있습니다.\n예를 들면 <code>&#x3C;select></code> 엘리먼트 안에 <code>&#x3C;option></code> 엘리먼트를 구성해야 하는 경우가 그렇습니다.\n<code>&#x3C;div></code>나 <code>&#x3C;span></code> 엘리먼트에는 <code>&#x3C;option></code> 엘리먼트를 사용하는 것이 적합하지 않습니다.</p>\n<p>다음 코드를 봅시다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (select-span)\" region=\"select-span\">\n&#x3C;div>\n  Pick your favorite hero\n  (&#x3C;label>&#x3C;input type=\"checkbox\" checked (change)=\"showSad = !showSad\">show sad&#x3C;/label>)\n&#x3C;/div>\n&#x3C;select [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero\">\n  &#x3C;span *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let h of heroes\">\n    &#x3C;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"showSad || h.emotion !== 'sad'\">\n      &#x3C;option [ngValue]=\"h\">{{h.name}} ({{h.emotion}})&#x3C;/option>\n    &#x3C;/span>\n  &#x3C;/span>\n&#x3C;/select>\n\n</code-example>\n<p>이 코드를 실행해보면 드롭다운의 내용이 비어있는 것을 확인할 수 있습니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/structural-directives/bad-select.png\" alt=\"spanned options don&#x27;t work\" width=\"290\" height=\"36\">\n</div>\n<p>브라우저는 <code>&#x3C;span></code> 안에 있는 <code>&#x3C;option></code>을 처리하지 않습니다.</p>\n<!--\n### &lt;ng-container&gt; to the rescue\n-->\n<h3 id=\"해결방법--ng-container\">해결방법 : &#x3C;ng-container><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#해결방법--ng-container\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe Angular `<ng-container>` is a grouping element that doesn't interfere with styles or layout\nbecause Angular _doesn't put it in the DOM_.\n\nHere's the conditional paragraph again, this time using `<ng-container>`.\n\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (ngif-ngcontainer)\" region=\"ngif-ngcontainer\">\n&lt;p&gt;\n  I turned the corner\n  &lt;ng-container *ngIf=&quot;hero&quot;&gt;\n    and saw {{hero.name}}. I waved\n  &lt;/ng-container&gt;\n  and continued on my way.\n&lt;/p&gt;\n\n</code-example>\n\n\nIt renders properly.\n\n<div class=\"lightbox\">\n  <img src='generated/images/guide/structural-directives/good-paragraph.png' alt=\"ngcontainer paragraph with proper style\">\n</div>\n\n\nNow conditionally exclude a _select_ `<option>` with `<ng-container>`.\n\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (select-ngcontainer)\" region=\"select-ngcontainer\">\n&lt;div&gt;\n  Pick your favorite hero\n  (&lt;label&gt;&lt;input type=&quot;checkbox&quot; checked (change)=&quot;showSad = !showSad&quot;&gt;show sad&lt;/label&gt;)\n&lt;/div&gt;\n&lt;select [(ngModel)]=&quot;hero&quot;&gt;\n  &lt;ng-container *ngFor=&quot;let h of heroes&quot;&gt;\n    &lt;ng-container *ngIf=&quot;showSad || h.emotion !== &#39;sad&#39;&quot;&gt;\n      &lt;option [ngValue]=&quot;h&quot;&gt;{{h.name}} ({{h.emotion}})&lt;/option&gt;\n    &lt;/ng-container&gt;\n  &lt;/ng-container&gt;\n&lt;/select&gt;\n\n</code-example>\n\n\nThe drop down works properly.\n\n<div class=\"lightbox\">\n  <img src='generated/images/guide/structural-directives/select-ngcontainer-anim.gif' alt=\"ngcontainer options work properly\">\n</div>\n\n<div class=\"alert is-helpful\">\n\n**Note:** Remember that ngModel directive is defined as a part of Angular FormsModule and you need to include FormsModule in the imports: [...] section of the Angular module metadata, in which you want to use it.\n\n</div>\n\nThe `<ng-container>` is a syntax element recognized by the Angular parser.\nIt's not a directive, component, class, or interface.\nIt's more like the curly braces in a JavaScript `if`-block:\n\n<code-example language=\"javascript\">\n  if (someCondition) {\n    statement1;\n    statement2;\n    statement3;\n  }\n\n</code-example>\n\n\nWithout those braces, JavaScript would only execute the first statement\nwhen you intend to conditionally execute all of them as a single block.\nThe `<ng-container>` satisfies a similar need in Angular templates.\n-->\n<p><code>&#x3C;ng-container></code>를 사용하면 스타일이나 레이아웃을 그대로 유지하면서 여러 엘리먼트를 한 그룹으로 묶을 수 있습니다. 왜냐하면 Angular는 이 엘리먼트를 <em>DOM에 직접 추가하지 않기 때문</em> 입니다.</p>\n<p><code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>를 사용하는 <code>&#x3C;p></code> 엘리먼트를 생각해 봅시다. 이 엘리먼트는 <code>&#x3C;ng-container></code>를 사용합니다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (ngif-ngcontainer)\" region=\"ngif-ngcontainer\">\n&#x3C;p>\n  I turned the corner\n  &#x3C;ng-container *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero\">\n    and saw {{hero.name}}. I waved\n  &#x3C;/ng-container>\n  and continued on my way.\n&#x3C;/p>\n\n</code-example>\n<p>이 코드는 제대로 렌더링 됩니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/structural-directives/good-paragraph.png\" alt=\"ngcontainer paragraph with proper style\" width=\"509\" height=\"15\">\n</div>\n<p>그리고 이번에는 <code>&#x3C;select></code>태그 안에 있는 <code>&#x3C;option></code> 엘리먼트를 배열에 따라 반복하고 표시 조건도 지정하는 용도로 <code>&#x3C;ng-container></code>를 사용해 봅시다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (select-ngcontainer)\" region=\"select-ngcontainer\">\n&#x3C;div>\n  Pick your favorite hero\n  (&#x3C;label>&#x3C;input type=\"checkbox\" checked (change)=\"showSad = !showSad\">show sad&#x3C;/label>)\n&#x3C;/div>\n&#x3C;select [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero\">\n  &#x3C;ng-container *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let h of heroes\">\n    &#x3C;ng-container *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"showSad || h.emotion !== 'sad'\">\n      &#x3C;option [ngValue]=\"h\">{{h.name}} ({{h.emotion}})&#x3C;/option>\n    &#x3C;/ng-container>\n  &#x3C;/ng-container>\n&#x3C;/select>\n\n</code-example>\n<p>그러면 드롭다운도 제대로 동작합니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/structural-directives/select-ngcontainer-anim.gif\" alt=\"ngcontainer options work properly\" width=\"312\" height=\"100\">\n</div>\n<div class=\"alert is-helpful\">\n<p><strong>참고:</strong> <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 디렉티브는 Angular <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>이 제공하는 디렉티브입니다. 이 디렉티브를 사용하려면 모듈 메타데이터의 <code>imports</code> 배열에 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>을 추가해야 합니다.</p>\n</div>\n<p><code>&#x3C;ng-container></code>는 Angular 파서용 엘리먼트입니다.\n이 엘리먼트 자체는 디렉티브나 컴포넌트, 클래스, 인터페이스 중 어느 것에도 해당되지 않으며, 오히려 JavaScript의 <code>if</code> 문법에 사용하는 중괄호(<code>{</code>, <code>}</code>)와 비슷하다고 볼 수 있습니다.</p>\n<code-example language=\"javascript\">\n  if (someCondition) {\n    statement1;\n    statement2;\n    statement3;\n  }\n\n</code-example>\n<p>중괄호가 없으면 JavaScript는 실행문 3개 중에 첫번째 하나만 실행합니다.\n의도한 대로 실행문 3개를 한 번에 실행하려면 실행문 전체를 중괄호로 묶어야 합니다.\nAngular 템플릿에서는 <code>&#x3C;ng-container></code>가 이런 역할을 합니다.</p>\n<a id=\"unless\"></a>\n<!--\n## Write a structural directive\n-->\n<h2 id=\"커스텀-구조-디렉티브-작성하기\">커스텀 구조 디렉티브 작성하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#커스텀-구조-디렉티브-작성하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nIn this section, you write an `UnlessDirective` structural directive\nthat does the opposite of `NgIf`.\n`NgIf` displays the template content when the condition is `true`.\n`UnlessDirective` displays the content when the condition is ***false***.\n\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (appUnless-1)\" region=\"appUnless-1\">\n&lt;p *appUnless=&quot;condition&quot;&gt;Show this sentence unless the condition is true.&lt;/p&gt;\n\n</code-example>\n\n\nCreating a directive is similar to creating a component.\n\n* Import the `Directive` decorator (instead of the `Component` decorator).\n\n* Import the `Input`, `TemplateRef`, and `ViewContainerRef` symbols; you'll need them for _any_ structural directive.\n\n* Apply the decorator to the directive class.\n\n* Set the CSS *attribute selector* that identifies the directive when applied to an element in a template.\n\nHere's how you might begin:\n\n\n<code-example path=\"structural-directives/src/app/unless.directive.ts\" header=\"src/app/unless.directive.ts (skeleton)\" region=\"skeleton\">\nimport { Directive, Input, TemplateRef, ViewContainerRef } from &#39;@angular/core&#39;;\n\n@Directive({ selector: &#39;[appUnless]&#39;})\nexport class UnlessDirective {\n}\n\n\n</code-example>\n\n\nThe directive's _selector_ is typically the directive's **attribute name** in square brackets, `[appUnless]`.\nThe brackets define a CSS\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors\" title=\"MDN: Attribute selectors\">attribute selector</a>.\n\nThe directive _attribute name_ should be spelled in _lowerCamelCase_ and begin with a prefix.\nDon't use `ng`. That prefix belongs to Angular.\nPick something short that fits you or your company.\nIn this example, the prefix is `app`.\n\n\nThe directive _class_ name ends in `Directive` per the [style guide](guide/styleguide#02-03 \"Angular Style Guide\").\nAngular's own directives do not.\n-->\n<p>이번에는 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>의 반대 기능을 하는 <code>UnlessDirective</code>를 만들어 봅니다.\n<code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>가 조건이 <code>true</code>일 때 템플릿 내용을 화면에 표시한다면, <code>UnlessDirective</code>는 조건이 <strong><em>false</em></strong>일 때 템플릿 내용을 화면에 표시할 것입니다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (appUnless-1)\" region=\"appUnless-1\">\n&#x3C;p *appUnless=\"condition\">Show this sentence unless the condition is true.&#x3C;/p>\n\n</code-example>\n<p>디렉티브를 작성하는 방법은 컴포넌트를 작성하는 것과 비슷합니다.</p>\n<ul>\n<li>\n<p><code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 데코레이터를 불러오는 것처럼 <code><a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code> 데코레이터를 로ㄷ합니다.</p>\n</li>\n<li>\n<p><code><a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code>, <code><a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a></code>, <code><a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a></code> 심볼을 로드합니다. 구조 디렉티브가 DOM을 조작하려면 이 심볼들이 필요합니다.</p>\n</li>\n<li>\n<p>데코레이터를 디렉티브 클래스에 적용합니다.</p>\n</li>\n<li>\n<p>템플릿 엘리먼트에 적용할 때 사용하는 CSS <em>어트리뷰트 셀렉터</em>를 지정합니다.</p>\n</li>\n</ul>\n<p>이렇게 작성하면 다음과 비슷한 코드가 될 것입니다:</p>\n<code-example path=\"structural-directives/src/app/unless.directive.ts\" header=\"src/app/unless.directive.ts (skeleton)\" region=\"skeleton\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a>, <a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a> } from '@angular/core';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({ selector: '[appUnless]'})\nexport class UnlessDirective {\n}\n\n\n</code-example>\n<p>디렉티브의 <em>셀렉터</em> 는 일반적으로 디렉티브의 <strong>어트리뷰트 이름</strong>을 대괄호로 감싼 형태가 되기 때문에 이 예제에서는 <code>[appUnless]</code>를 지정했습니다.\n대괄호는 CSS <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors\" title=\"MDN: Attribute selectors\">어트리뷰트 셀렉터</a>를 의미합니다.</p>\n<p>디렉티브의 <em>어트리뷰트 이름</em> 은 애플리케이션에서 정의한 접두사로 시작하며 <em>소문자 캐멀 케이스</em> 로 지정합니다.\n이 때 <code>ng</code>는 Angular가 내부적으로 사용하고 있기 때문에 접두사로 사용하면 안됩니다.\n개발 환경이나 회사에 적합한 접두사를 사용하세요.\n이 예제에서는 <code>app</code>을 접두사로 사용했습니다.</p>\n<p>그리고 <a href=\"guide/styleguide#02-03\" title=\"Angular Style Guide\">코딩 가이드</a>에 따라 디렉티브 <em>클래스</em> 이름은 <code><a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code>로 끝나도록 정의했습니다.\n참고로 Angular 기본 디렉티브는 <code><a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code>로 끝나지 않습니다.</p>\n<!--\n### _TemplateRef_ and _ViewContainerRef_\n-->\n<h3 id=\"templateref-와-viewcontainerref\"><em>TemplateRef</em> 와 <em>ViewContainerRef</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#templateref-와-viewcontainerref\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nA simple structural directive like this one creates an\n[_embedded view_](api/core/EmbeddedViewRef \"API: EmbeddedViewRef\")\nfrom the Angular-generated `<ng-template>` and inserts that view in a\n[_view container_](api/core/ViewContainerRef \"API: ViewContainerRef\")\nadjacent to the directive's original `<p>` host element.\n\nYou'll acquire the `<ng-template>` contents with a\n[`TemplateRef`](api/core/TemplateRef \"API: TemplateRef\")\nand access the _view container_ through a\n[`ViewContainerRef`](api/core/ViewContainerRef \"API: ViewContainerRef\").\n\nYou inject both in the directive constructor as private variables of the class.\n\n\n<code-example path=\"structural-directives/src/app/unless.directive.ts\" header=\"src/app/unless.directive.ts (ctor)\" region=\"ctor\">\nconstructor(\n  private templateRef: TemplateRef&lt;any&gt;,\n  private viewContainer: ViewContainerRef) { }\n\n</code-example>\n-->\n<p>구조 디렉티브는 <code>&#x3C;ng-template></code>을 사용하는 <a href=\"api/core/EmbeddedViewRef\" title=\"API: EmbeddedViewRef\"><em>내장 뷰</em></a>를 생성하고, 이 뷰를 <a href=\"api/core/ViewContainerRef\" title=\"API: ViewContainerRef\"><em>뷰 컨테이너</em></a> 로 감싼 후에 호스트 엘리먼트인 <code>&#x3C;p></code> 옆에 추가합니다.</p>\n<p>그러면 <code>&#x3C;ng-template></code>의 내용은 <a href=\"api/core/TemplateRef\" title=\"API: TemplateRef\"><code>TemplateRef</code></a>로 참조할 수 있고, <em>뷰 컨테이너</em> 는 <a href=\"api/core/ViewContainerRef\" title=\"API: ViewContainerRef\"><code>ViewContainerRef</code></a>로 참조할 수 있습니다.</p>\n<p>두 객체를 클래스에서 참조할 수 있도록 디렉티브 생성자에 두 심볼을 의존성으로 주입합니다.</p>\n<code-example path=\"structural-directives/src/app/unless.directive.ts\" header=\"src/app/unless.directive.ts (ctor)\" region=\"ctor\">\nconstructor(\n  private templateRef: <a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a>&#x3C;any>,\n  private viewContainer: <a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a>) { }\n\n</code-example>\n<!--\n### The _appUnless_ property\n-->\n<h3 id=\"appunless-프로퍼티\"><em>appUnless</em> 프로퍼티<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#appunless-프로퍼티\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe directive consumer expects to bind a true/false condition to `[appUnless]`.\nThat means the directive needs an `appUnless` property, decorated with `@Input`\n\n<div class=\"alert is-helpful\">\n\n\nRead about `@Input` in the [`@Input()` and `@Output()` properties](guide/inputs-outputs) guide.\n\n</div>\n\n\n\n<code-example path=\"structural-directives/src/app/unless.directive.ts\" header=\"src/app/unless.directive.ts (set)\" region=\"set\">\n@Input() set appUnless(condition: boolean) {\n  if (!condition &amp;&amp; !this.hasView) {\n    this.viewContainer.createEmbeddedView(this.templateRef);\n    this.hasView = true;\n  } else if (condition &amp;&amp; this.hasView) {\n    this.viewContainer.clear();\n    this.hasView = false;\n  }\n}\n\n</code-example>\n\n\nAngular sets the `appUnless` property whenever the value of the condition changes.\nBecause the `appUnless` property does work, it needs a setter.\n\n* If the condition is falsy and the view hasn't been created previously,\ntell the _view container_ to create the _embedded view_ from the template.\n\n* If the condition is truthy and the view is currently displayed,\nclear the container which also destroys the view.\n\nNobody reads the `appUnless` property so it doesn't need a getter.\n\nThe completed directive code looks like this:\n\n<code-example path=\"structural-directives/src/app/unless.directive.ts\" header=\"src/app/unless.directive.ts (excerpt)\" region=\"no-docs\">\nimport { Directive, Input, TemplateRef, ViewContainerRef } from &#39;@angular/core&#39;;\n\n/**\n * 평가 결과가 참으로 평가되면 DOM에서 템플릿을 제거합니다.\n * 평가 결과가 거짓으로 평가되면 DOM에 템플릿을 추가합니다.\n */\n@Directive({ selector: &#39;[appUnless]&#39;})\nexport class UnlessDirective {\n  private hasView = false;\n\n  constructor(\n    private templateRef: TemplateRef&lt;any&gt;,\n    private viewContainer: ViewContainerRef) { }\n\n  @Input() set appUnless(condition: boolean) {\n    if (!condition &amp;&amp; !this.hasView) {\n      this.viewContainer.createEmbeddedView(this.templateRef);\n      this.hasView = true;\n    } else if (condition &amp;&amp; this.hasView) {\n      this.viewContainer.clear();\n      this.hasView = false;\n    }\n  }\n}\n\n\n</code-example>\n\n\nAdd this directive to the `declarations` array of the AppModule.\n\nThen create some HTML to try it.\n\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (appUnless)\" region=\"appUnless\">\n&lt;p *appUnless=&quot;condition&quot; class=&quot;unless a&quot;&gt;\n  (A) This paragraph is displayed because the condition is false.\n&lt;/p&gt;\n\n&lt;p *appUnless=&quot;!condition&quot; class=&quot;unless b&quot;&gt;\n  (B) Although the condition is true,\n  this paragraph is displayed because appUnless is set to false.\n&lt;/p&gt;\n\n</code-example>\n\n\nWhen the `condition` is falsy, the top (A) paragraph appears and the bottom (B) paragraph disappears.\nWhen the `condition` is truthy, the top (A) paragraph is removed and the bottom (B) paragraph appears.\n\n<div class=\"lightbox\">\n  <img src='generated/images/guide/structural-directives/unless-anim.gif' alt=\"UnlessDirective in action\">\n</div>\n-->\n<p>이 디렉티브는 <code>[appUnless]</code>로 true/false 조건을 받습니다.\n이 말은, 디렉티브에 <code>appUnless</code> 프로퍼티가 있어야 하며, 이 프로퍼티는 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code>로 지정되어야 한다는 것을 의미합니다.</p>\n<div class=\"alert is-helpful\">\n<p><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 데코레이터에 대한 내용은 <a href=\"guide/inputs-outputs\"><code>@Input()</code>, <code>@Output()</code> 데코레이터</a> 문서를 참고하세요.</p>\n</div>\n<code-example path=\"structural-directives/src/app/unless.directive.ts\" header=\"src/app/unless.directive.ts (set)\" region=\"set\">\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() set appUnless(condition: boolean) {\n  if (!condition &#x26;&#x26; !this.hasView) {\n    this.viewContainer.createEmbeddedView(this.templateRef);\n    this.hasView = true;\n  } else if (condition &#x26;&#x26; this.hasView) {\n    this.viewContainer.clear();\n    this.hasView = false;\n  }\n}\n\n</code-example>\n<p><code>appUnless</code> 프로퍼티의 값은 이 프로퍼티에 바인딩 된 값이 바뀔때마다 Angular가 새로 할당합니다.\n그래서 이 프로퍼티 값에 반응하려면 세터(setter)가 필요합니다.</p>\n<ul>\n<li>\n<p>거짓으로 평가되는 값이 전달되고 내장 뷰가 아직 생성되지 않았으면, <em>뷰 컨테이너</em> 를 사용해서 <em>내장 뷰</em> 를 생성합니다.</p>\n</li>\n<li>\n<p>참으로 평가되는 값이 전달되고 뷰가 화면에 표시되고 있으면, 컨테이너의 내용을 비우고 뷰에서 제거합니다.</p>\n</li>\n</ul>\n<p><code>appUnless</code> 프로퍼티를 참조하는 것은 아무것도 없기 때문에 게터(getter)는 따로 정의하지 않습니다.</p>\n<p>그러면 다음과 같은 코드가 됩니다:</p>\n<code-example path=\"structural-directives/src/app/unless.directive.ts\" header=\"src/app/unless.directive.ts (일부)\" region=\"no-docs\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a>, <a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a> } from '@angular/core';\n\n/**\n * 평가 결과가 참으로 평가되면 DOM에서 템플릿을 제거합니다.\n * 평가 결과가 거짓으로 평가되면 DOM에 템플릿을 추가합니다.\n */\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({ selector: '[appUnless]'})\nexport class UnlessDirective {\n  private hasView = false;\n\n  constructor(\n    private templateRef: <a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a>&#x3C;any>,\n    private viewContainer: <a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a>) { }\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() set appUnless(condition: boolean) {\n    if (!condition &#x26;&#x26; !this.hasView) {\n      this.viewContainer.createEmbeddedView(this.templateRef);\n      this.hasView = true;\n    } else if (condition &#x26;&#x26; this.hasView) {\n      this.viewContainer.clear();\n      this.hasView = false;\n    }\n  }\n}\n\n\n</code-example>\n<p>이제 이 디렉티브를 AppModule의 <code>declarations</code> 배열에 추가합니다.</p>\n<p>그러고 HTML에 이 디렉티브를 적용해 봅니다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (appUnless)\" region=\"appUnless\">\n&#x3C;p *appUnless=\"condition\" class=\"unless a\">\n  (A) This paragraph is displayed because the condition is false.\n&#x3C;/p>\n\n&#x3C;p *appUnless=\"!condition\" class=\"unless b\">\n  (B) Although the condition is true,\n  this paragraph is displayed because appUnless is set to false.\n&#x3C;/p>\n\n</code-example>\n<p><code>condition</code> 값이 거짓으로 평가되면 (A) 문단이 화면에 표시되고 (B) 문단은 화면에 표시되지 않습니다.\n그리고 <code>condition</code> 값이 참으로 평가되면 (A) 문단이 화면에 표시되지 않고 (B) 문단이 화면에 표시됩니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/structural-directives/unless-anim.gif\" alt=\"UnlessDirective in action\" width=\"524\" height=\"100\">\n</div>\n<a id=\"directive-type-checks\"></a>\n<!--\n## Improving template type checking for custom directives\n-->\n<h2 id=\"커스텀-디렉티브에-향상된-템플릿-타입-검사-기능-적용하기\">커스텀 디렉티브에 향상된 템플릿 타입 검사 기능 적용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#커스텀-디렉티브에-향상된-템플릿-타입-검사-기능-적용하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nYou can improve template type checking for custom directives by adding template guard properties to your directive definition.\nThese properties help the Angular template type checker find mistakes in the template at compile time, which can avoid runtime errors those mistakes can cause.\n\nUse the type-guard properties to inform the template type checker of an expected type, thus improving compile-time type-checking for that template.\n\n* A property `ngTemplateGuard_(someInputProperty)` lets you specify a more accurate type for an input expression within the template.\n* The `ngTemplateContextGuard` static property declares the type of the template context.\n\nThis section provides example of both kinds of type-guard property.\n\n<div class=\"alert is-helpful\">\n\n   For more information, see [Template type checking guide](guide/template-typecheck \"Template type-checking guide\").\n\n</div>\n-->\n<p>디렉티브를 선언할 때 템플릿 가드 관련 프로퍼티를 추가하면 커스텀 디렉티브에도 향상된 템플릿 타입 검사 기능을 적용할 수 있습니다.\n이 때 추가하는 프로퍼티들은 템플릿이 컴파일되는 시점에 Angular 템플릿 타입 검사 로직에 더 많은 정보를 주는 용도로 활용되기 때문에 Angular 애플리케이션이 실행되는 시점에 발생할 수 있는 에러를 사전에 검출할 수 있습니다.</p>\n<p>타입 가드 프로퍼티를 선언하면 템플릿 타입 검사 로직이 동작할 때 이 정보를 활용합니다.\n따라서 컴파일 시점에 템플릿에서 활용할 수 있는 타입 검사 로직이 더 엄격해집니다.</p>\n<ul>\n<li><code>ngTemplateGuard_(someInputProperty)</code> 프로퍼티는 템플릿에 더 향상된 타입 검사 로직을 적용하도록 지정하는 프로퍼티입니다.</li>\n<li>정적 프로퍼티 <code>ngTemplateContextGuard</code>는 템플릿 컨텍스트에 사용되는 타입을 지정하는 프로퍼티입니다.</li>\n</ul>\n<p>이 섹션에서는 두가지 타입 가드 프로퍼티를 예제와 함께 살펴봅시다.</p>\n<div class=\"alert is-helpful\">\n<p>더 자세한 내용을 확인하려면 <a href=\"guide/template-typecheck\" title=\"Template type-checking guide\">템플릿 타입 검사 가이드</a> 문서를 참고하세요.</p>\n</div>\n<a id=\"narrowing-input-types\"></a>\n<!--\n### Make in-template type requirements more specific with template guards\n-->\n<h3 id=\"템플릿-가드로-타입-구체화하기\">템플릿 가드로 타입 구체화하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#템플릿-가드로-타입-구체화하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nA structural directive in a template controls whether that template is rendered at run time, based on its input expression.\nTo help the compiler catch template type errors, you should specify as closely as possible the required type of a directive's input expression when it occurs inside the template.\n\nA type guard function *narrows* the expected type of an input expression to a subset of types that might be passed to the directive within the template at run time.\nYou can provide such a function to help the type-checker infer the proper type for the expression at compile time.\n\nFor example, the `NgIf` implementation uses type-narrowing to ensure that the\ntemplate is only instantiated if the input expression to `*ngIf` is truthy.\nTo provide the specific type requirement, the `NgIf` directive defines a [static property `ngTemplateGuard_ngIf: 'binding'`](api/common/NgIf#static-properties).\nThe `binding` value is a special case for a common kind of type-narrowing where the input expression is evaluated in order to satisfy the type requirement.\n\nTo provide a more specific type for an input expression to a directive within the template, add a `ngTemplateGuard_xx` property to the directive, where the suffix to the static property name is the `@Input` field name.\nThe value of the property can be either a general type-narrowing function based on its return type, or the string `\"binding\"` as in the case of `NgIf`.\n\nFor example, consider the following structural directive that takes the result of a template expression as an input.\n\n<code-example language=\"ts\" header=\"IfLoadedDirective\">\nexport type Loaded<T> = { type: 'loaded', data: T };\nexport type Loading = { type: 'loading' };\nexport type LoadingState<T> = Loaded<T> | Loading;\nexport class IfLoadedDirective<T> {\n    @Input('ifLoaded') set state(state: LoadingState<T>) {}\n    static ngTemplateGuard_state<T>(dir: IfLoadedDirective<T>, expr: LoadingState<T>): expr is Loaded<T> { return true; };\n}\n\nexport interface Person {\n  name: string;\n}\n\n@Component({\n  template: `&lt;div *ifLoaded=\"state\">{{ state.data }}&lt;/div>`,\n})\nexport class AppComponent {\n  state: LoadingState<Person>;\n}\n</code-example>\n\nIn this example, the `LoadingState<T>` type permits either of two states, `Loaded<T>` or `Loading`. The expression used as the directive’s `state` input is of the umbrella type `LoadingState`, as it’s unknown what the loading state is at that point.\n\nThe `IfLoadedDirective` definition declares the static field `ngTemplateGuard_state`, which expresses the narrowing behavior.\nWithin the `AppComponent` template, the `*ifLoaded` structural directive should render this template only when `state` is actually `Loaded<Person>`.\nThe type guard allows the type checker to infer that the acceptable type of `state` within the template is a `Loaded<T>`, and further infer that `T` must be an instance of `Person`.\n-->\n<p>템플릿에 구조 디렉티브가 사용되면 이 구조 디렉티브는 바인딩된 표현식에 따라 실행 시점에 템플릿을 렌더링할 것인지 결정합니다.\n이 때 발생할 수 있는 타입 관련 에러를 컴파일러가 사전에 검출하는 데 도움을 주려면, 템플릿 안에서 디렉티브에 바인딩되는 표현식의 타입을 명확하게 지정할 수록 좋습니다.</p>\n<p>타입 가드 함수는 애플리케이션이 실행되는 시점에 템플릿에 사용되는 표현식이 반환하는 값의 타입을 더 구체적으로 <em>좁히는(narrows)</em> 역할을 합니다.\n그리고 이런 타입 가드 함수는 컴파일 시점에서 템플릿 타입 검사 로직이 더 정확한 타입을 추론하는 데에도 도움을 줍니다.</p>\n<p><code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 디렉티브는 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>에 바인딩되는 표현식이 참으로 평가될 때만 템플릿을 화면에 렌더링하는데, <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 디렉티브에 <a href=\"api/common/NgIf#static-properties\">정적 프로퍼티 <code>ngTemplateGuard_ngIf: 'binding'</code></a>를 선언하면 요구되는 타입에 대한 정보를 더 구체적으로 지정할 수 있습니다.\n이 때 사용되는 <code>binding</code> 값은 표현식이 반환하는 결과를 더 구체적인 타입으로 제한하기 위해 사용되는 값입니다.</p>\n<p>템플릿 안에서 디렉티브에 바인딩되는 표현식에 더 엄격한 타입을 적용하려면 디렉티브에 <code>ngTemplateGuard_xx</code> 프로퍼티를 정의하면 됩니다. 이 때 <code>xx</code>에 해당하는 접미사는 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 필드에 사용된 정적 프로퍼티 이름으로 선언합니다.\n이 프로퍼티 값은 템플릿이 반환하는 타입을 구체적으로 지정하는 함수이거나, <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>인 경우에는 문자열 <code>\"binding\"</code>을 사용할 수 있습니다.</p>\n<p>아래 구조 디렉티브 예제 코드를 살펴봅시다.</p>\n<code-example language=\"ts\" header=\"IfLoadedDirective\">\nexport type Loaded<t> = { type: 'loaded', data: T };\nexport type Loading = { type: 'loading' };\nexport type LoadingState<t> = Loaded<t> | Loading;\nexport class IfLoadedDirective<t> {\n    @Input('ifLoaded') set state(state: LoadingState<t>) {}\n    static ngTemplateGuard_state<t>(dir: IfLoadedDirective<t>, expr: LoadingState<t>): expr is Loaded<t> { return true; };\n}\n\nexport interface Person {\n  name: string;\n}\n\n@Component({\n  template: `&#x3C;div *ifLoaded=\"state\">{{ state.data }}&#x3C;/div>`,\n})\nexport class AppComponent {\n  state: LoadingState<person>;\n}\n</person></t></t></t></t></t></t></t></t></t></code-example>\n<p>이 예제 코드에서 <code>LoadingState&#x3C;T></code> 타입은 <code>Loaded&#x3C;T></code> 타입이나 <code>Loading</code> 타입이 될 수 있습니다.\n그리고 템플릿에서 디렉티브에 바인딩된 <code><a href=\"api/animations/state\" class=\"code-anchor\">state</a></code>는 <code>LoadingState</code> 타입이기 때문에 이 시점에는 정확히 어떤 타입인지 알 수 없습니다.</p>\n<p>이 때 표현식이 허용하는 타입 범위를 좁히기 위해 <code>IfLoadedDirective</code> 디렉티브에 정적 필드 <code>ngTemplateGuard_state</code>를 선언합니다.\n그러면 <code>AppComponent</code> 템플릿 안에서 구조 디렉티브 <code>*ifLoaded</code>는 <code><a href=\"api/animations/state\" class=\"code-anchor\">state</a></code> 값이 정확히 <code>Loaded&#x3C;Person></code>이 될 때만 템플릿을 화면에 렌더링합니다.\n이제 템플릿에 사용되는 <code><a href=\"api/animations/state\" class=\"code-anchor\">state</a></code>는 <code>Loaded&#x3C;T></code> 타입이라는 정보 외에도, <code>T</code>가 <code>Person</code> 인스턴스라는 정보까지 전달할 수 있습니다.</p>\n<a id=\"narrowing-context-type\"></a>\n<!--\n### Typing the directive's context\n-->\n<h3 id=\"디렉티브-컨텍스트의-타입-지정하기\">디렉티브 컨텍스트의 타입 지정하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#디렉티브-컨텍스트의-타입-지정하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIf your structural directive provides a context to the instantiated template, you can properly type it inside the template by providing a static `ngTemplateContextGuard` function.\nThe following snippet shows an example of such a function.\n\n<code-example language=\"ts\" header=\"myDirective.ts\">\n@Directive({…})\nexport class ExampleDirective {\n    // Make sure the template checker knows the type of the context with which the\n    // template of this directive will be rendered\n    static ngTemplateContextGuard(dir: ExampleDirective, ctx: unknown): ctx is ExampleContext { return true; };\n\n    // …\n}\n</code-example>\n-->\n<p>구조 디렉티브가 템플릿을 인스턴스로 만들어서 컨텍스트에 제공한다면, 정적 함수 <code>ngTemplateContextGuard</code>를 사용해서 이 템플릿의 컨텍스트 타입을 명확하게 지정할 수 있습니다.\n아래 예제를 확인해 보세요.</p>\n<code-example language=\"ts\" header=\"myDirective.ts\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({…})\nexport class ExampleDirective {\n    // 이 함수를 정의하면 디렉티브가 렌더링할 템플릿 템플릿 인스턴스의 타입을\n    // 템플릿 검사기가 정확하게 확인할 수 있습니다.\n    <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> ngTemplateContextGuard(dir: ExampleDirective, ctx: unknown): ctx is ExampleContext { return true; };\n\n    // …\n}\n</code-example>\n<a id=\"summary\"></a>\n<!--\n## Summary\n-->\n<h2 id=\"정리\">정리<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#정리\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nYou can both try and download the source code for this guide in the <live-example></live-example>.\n\nHere is the source from the `src/app/` folder.\n-->\n<p>이 문서에서 설명하는 예제는 <live-example></live-example>에서 직접 확인하거나 다운받아 확인할 수 있습니다.</p>\n<p>그리고 소스 코드 <code>src/app/</code> 폴더의 내용은 다음과 같습니다.</p>\n<code-tabs>\n\n  <code-pane header=\"app.component.ts\" path=\"structural-directives/src/app/app.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\nimport { Hero, heroes } from './hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: [ './app.component.css' ]\n})\nexport class AppComponent {\n  heroes = heroes;\n  hero = this.heroes[0];\n\n  condition = false;\n  logs: string[] = [];\n  showSad = true;\n  status = 'ready';\n\n  trackById(index: number, hero: Hero): number { return hero.id; }\n}\n\n\n</code-pane>\n\n  <code-pane header=\"app.component.html\" path=\"structural-directives/src/app/app.component.html\">\n&#x3C;h1>Structural Directives&#x3C;/h1>\n\n&#x3C;p>Conditional display of hero&#x3C;/p>\n\n&#x3C;blockquote>\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero\" class=\"name\">{{hero.name}}&#x3C;/div>\n&#x3C;/blockquote>\n\n&#x3C;p>List of heroes&#x3C;/p>\n\n&#x3C;ul>\n  &#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">{{hero.name}}&#x3C;/li>\n&#x3C;/ul>\n\n\n&#x3C;hr>\n\n&#x3C;h2 id=\"<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>\"><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a>&#x3C;/h2>\n\n&#x3C;p *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"true\">\n  Expression is true and <a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a> is true.\n  This paragraph is in the DOM.\n&#x3C;/p>\n&#x3C;p *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"false\">\n  Expression is false and <a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a> is false.\n  This paragraph is not in the DOM.\n&#x3C;/p>\n\n&#x3C;p [style.display]=\"'block'\">\n  Expression sets display to \"block\".\n  This paragraph is visible.\n&#x3C;/p>\n&#x3C;p [style.display]=\"'none'\">\n  Expression sets display to \"none\".\n  This paragraph is hidden but still in the DOM.\n&#x3C;/p>\n\n&#x3C;h4><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a> with template&#x3C;/h4>\n&#x3C;p>&#x26;lt;ng-template&#x26;gt; element&#x3C;/p>\n&#x3C;ng-template [<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>]=\"hero\">\n  &#x3C;div class=\"name\">{{hero.name}}&#x3C;/div>\n&#x3C;/ng-template>\n\n&#x3C;hr>\n\n&#x3C;h2 id=\"ng-container\">&#x26;lt;ng-container&#x26;gt;&#x3C;/h2>\n\n&#x3C;h4>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a> with a &#x26;lt;ng-container&#x26;gt;&#x3C;/h4>\n\n&#x3C;button (click)=\"hero = hero ? null : heroes[0]\">Toggle hero&#x3C;/button>\n\n&#x3C;p>\n  I turned the corner\n  &#x3C;ng-container *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero\">\n    and saw {{hero.name}}. I waved\n  &#x3C;/ng-container>\n  and continued on my way.\n&#x3C;/p>\n&#x3C;p>\n  I turned the corner\n  &#x3C;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero\">\n    and saw {{hero.name}}. I waved\n  &#x3C;/span>\n  and continued on my way.\n&#x3C;/p>\n\n&#x3C;p>&#x3C;i>&#x26;lt;select&#x26;gt; with &#x26;lt;span&#x26;gt;&#x3C;/i>&#x3C;/p>\n&#x3C;div>\n  Pick your favorite hero\n  (&#x3C;label>&#x3C;input type=\"checkbox\" checked (change)=\"showSad = !showSad\">show sad&#x3C;/label>)\n&#x3C;/div>\n&#x3C;select [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero\">\n  &#x3C;span *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let h of heroes\">\n    &#x3C;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"showSad || h.emotion !== 'sad'\">\n      &#x3C;option [ngValue]=\"h\">{{h.name}} ({{h.emotion}})&#x3C;/option>\n    &#x3C;/span>\n  &#x3C;/span>\n&#x3C;/select>\n\n&#x3C;p>&#x3C;i>&#x26;lt;select&#x26;gt; with &#x26;lt;ng-container&#x26;gt;&#x3C;/i>&#x3C;/p>\n&#x3C;div>\n  Pick your favorite hero\n  (&#x3C;label>&#x3C;input type=\"checkbox\" checked (change)=\"showSad = !showSad\">show sad&#x3C;/label>)\n&#x3C;/div>\n&#x3C;select [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero\">\n  &#x3C;ng-container *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let h of heroes\">\n    &#x3C;ng-container *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"showSad || h.emotion !== 'sad'\">\n      &#x3C;option [ngValue]=\"h\">{{h.name}} ({{h.emotion}})&#x3C;/option>\n    &#x3C;/ng-container>\n  &#x3C;/ng-container>\n&#x3C;/select>\n&#x3C;br>&#x3C;br>\n\n&#x3C;hr>\n\n&#x3C;h2 id=\"<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>\">NgFor&#x3C;/h2>\n\n&#x3C;div class=\"box\">\n\n&#x3C;p class=\"code\">&#x26;lt;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes; let i=index; let odd=odd; trackBy: trackById\" [class.odd]=\"odd\"&#x26;gt;&#x3C;/p>\n&#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes; let i=index; let odd=odd; trackBy: trackById\" [class.odd]=\"odd\">\n  ({{i}}) {{hero.name}}\n&#x3C;/div>\n\n&#x3C;p class=\"code\">&#x26;lt;ng-template <a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a> let-hero [<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngForOf</a>]=\"heroes\" let-i=\"index\" let-odd=\"odd\" [ngForTrackBy]=\"trackById\"/&#x26;gt;&#x3C;/p>\n&#x3C;ng-template <a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a> let-hero [<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngForOf</a>]=\"heroes\" let-i=\"index\" let-odd=\"odd\" [ngForTrackBy]=\"trackById\">\n  &#x3C;div [class.odd]=\"odd\">({{i}}) {{hero.name}}&#x3C;/div>\n&#x3C;/ng-template>\n\n&#x3C;/div>\n&#x3C;hr>\n\n&#x3C;h2 id=\"<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a>\"><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a>&#x3C;/h2>\n\n&#x3C;div>Pick your favorite hero&#x3C;/div>\n&#x3C;p>\n  &#x3C;label *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let h of heroes\">\n    &#x3C;input type=\"radio\" name=\"heroes\" [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero\" [value]=\"h\">{{h.name}}\n  &#x3C;/label>\n  &#x3C;label>&#x3C;input type=\"radio\" name=\"heroes\" (click)=\"hero = null\">None of the above&#x3C;/label>\n&#x3C;/p>\n\n&#x3C;h4><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a>&#x3C;/h4>\n\n&#x3C;div [<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a>]=\"hero?.emotion\">\n  &#x3C;app-happy-hero    *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'happy'\"    [hero]=\"hero\">&#x3C;/app-happy-hero>\n  &#x3C;app-sad-hero      *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'sad'\"      [hero]=\"hero\">&#x3C;/app-sad-hero>\n  &#x3C;app-confused-hero *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'confused'\" [hero]=\"hero\">&#x3C;/app-confused-hero>\n  &#x3C;app-unknown-hero  *<a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">ngSwitchDefault</a>           [hero]=\"hero\">&#x3C;/app-unknown-hero>\n&#x3C;/div>\n\n&#x3C;h4><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a> with &#x26;lt;ng-template&#x26;gt;&#x3C;/h4>\n&#x3C;div [<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a>]=\"hero?.emotion\">\n  &#x3C;ng-template [<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>]=\"'happy'\">\n    &#x3C;app-happy-hero [hero]=\"hero\">&#x3C;/app-happy-hero>\n  &#x3C;/ng-template>\n  &#x3C;ng-template [<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>]=\"'sad'\">\n    &#x3C;app-sad-hero [hero]=\"hero\">&#x3C;/app-sad-hero>\n  &#x3C;/ng-template>\n  &#x3C;ng-template [<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>]=\"'confused'\">\n    &#x3C;app-confused-hero [hero]=\"hero\">&#x3C;/app-confused-hero>\n  &#x3C;/ng-template >\n  &#x3C;ng-template <a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">ngSwitchDefault</a>>\n    &#x3C;app-unknown-hero [hero]=\"hero\">&#x3C;/app-unknown-hero>\n  &#x3C;/ng-template>\n&#x3C;/div>\n\n&#x3C;hr>\n\n&#x3C;h2>&#x26;lt;ng-template&#x26;gt;&#x3C;/h2>\n&#x3C;p>Hip!&#x3C;/p>\n&#x3C;ng-template>\n  &#x3C;p>Hip!&#x3C;/p>\n&#x3C;/ng-template>\n&#x3C;p>Hooray!&#x3C;/p>\n\n&#x3C;hr>\n\n&#x3C;h2 id=\"appUnless\">UnlessDirective&#x3C;/h2>\n&#x3C;p>\n  The condition is currently\n  &#x3C;span [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"{ 'a': !condition, 'b': condition, 'unless': true }\">{{condition}}&#x3C;/span>.\n  &#x3C;button\n    (click)=\"condition = !condition\"\n    [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>] = \"{ 'a': condition, 'b': !condition }\" >\n    Toggle condition to {{condition ? 'false' : 'true'}}\n  &#x3C;/button>\n&#x3C;/p>\n&#x3C;p *appUnless=\"condition\" class=\"unless a\">\n  (A) This paragraph is displayed because the condition is false.\n&#x3C;/p>\n\n&#x3C;p *appUnless=\"!condition\" class=\"unless b\">\n  (B) Although the condition is true,\n  this paragraph is displayed because appUnless is set to false.\n&#x3C;/p>\n\n\n&#x3C;h4>UnlessDirective with template&#x3C;/h4>\n\n&#x3C;p *appUnless=\"condition\">Show this sentence unless the condition is true.&#x3C;/p>\n\n&#x3C;p *appUnless=\"condition\" class=\"code unless\">\n  (A) &#x26;lt;p *appUnless=\"condition\" class=\"code unless\"&#x26;gt;\n&#x3C;/p>\n\n&#x3C;ng-template [appUnless]=\"condition\">\n  &#x3C;p class=\"code unless\">\n    (A) &#x26;lt;ng-template [appUnless]=\"condition\"&#x26;gt;\n  &#x3C;/p>\n&#x3C;/ng-template>\n\n\n\n</code-pane>\n\n  <code-pane header=\"app.component.css\" path=\"structural-directives/src/app/app.component.css\">\nbutton {\n  min-width: 100px;\n  font-size: 100%;\n}\n\n.box {\n  border: 1px solid gray;\n  max-width: 600px;\n  padding: 4px;\n}\n.choices {\n  font-style: italic;\n}\n\ncode, .code {\n  background-color: #eee;\n  color: black;\n  font-family: Courier, sans-serif;\n  font-size: 85%;\n}\n\ndiv.code {\n  width: 400px;\n}\n\n.heroic {\n  font-size: 150%;\n  font-weight: bold;\n}\n\nhr {\n  margin: 40px 0\n}\n\n.odd {\n  background-color:  palegoldenrod;\n}\n\ntd, th {\n  text-align: left;\n  vertical-align: top;\n}\n\np span { color: red; font-size: 70%; }\n\n.unless {\n  border: 2px solid;\n  padding: 6px;\n}\n\np.unless {\n  width: 500px;\n}\n\nbutton.a, span.a, .unless.a {\n  color: red;\n  border-color: gold;\n  background-color: yellow;\n  font-size: 100%;\n}\n\nbutton.b, span.b, .unless.b {\n  color: black;\n  border-color: green;\n  background-color: lightgreen;\n  font-size: 100%;\n}\n\n\n</code-pane>\n\n  <code-pane header=\"app.module.ts\" path=\"structural-directives/src/app/app.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\n\nimport { AppComponent } from './app.component';\nimport { heroSwitchComponents } from './hero-switch.components';\nimport { UnlessDirective } from './unless.directive';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [ <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>, <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> ],\n  declarations: [\n    AppComponent,\n    heroSwitchComponents,\n    UnlessDirective\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n\n</code-pane>\n\n  <code-pane header=\"hero.ts\" path=\"structural-directives/src/app/hero.ts\">\nexport interface Hero {\n  id: number;\n  name: string;\n  emotion?: string;\n}\n\nexport const heroes: Hero[] = [\n  { id: 1, name: 'Dr Nice',  emotion: 'happy'},\n  { id: 2, name: 'Narco',     emotion: 'sad' },\n  { id: 3, name: 'Windstorm', emotion: 'confused' },\n  { id: 4, name: 'Magneta'}\n];\n\n\n</code-pane>\n\n  <code-pane header=\"hero-switch.components.ts\" path=\"structural-directives/src/app/hero-switch.components.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a> } from '@angular/core';\nimport { Hero } from './hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-happy-hero',\n  template: `Wow. You like {{hero.name}}. What a happy hero ... just like you.`\n})\nexport class HappyHeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-sad-hero',\n  template: `You like {{hero.name}}? Such a sad hero. Are you sad too?`\n})\nexport class SadHeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-confused-hero',\n  template: `Are you as confused as {{hero.name}}?`\n})\nexport class ConfusedHeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-unknown-hero',\n  template: `{{message}}`\n})\nexport class UnknownHeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n  get message() {\n    return this.hero &#x26;&#x26; this.hero.name ?\n      `${this.hero.name} is strange and mysterious.` :\n      'Are you feeling indecisive?';\n  }\n}\n\nexport const heroSwitchComponents =\n  [ HappyHeroComponent, SadHeroComponent, ConfusedHeroComponent, UnknownHeroComponent ];\n\n\n</code-pane>\n\n  <code-pane header=\"unless.directive.ts\" path=\"structural-directives/src/app/unless.directive.ts\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a>, <a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a> } from '@angular/core';\n\n/**\n * 평가 결과가 참으로 평가되면 DOM에서 템플릿을 제거합니다.\n * 평가 결과가 거짓으로 평가되면 DOM에 템플릿을 추가합니다.\n *\n * &#x3C;div *appUnless=\"errorCount\" class=\"success\">\n *   Congrats! Everything is great!\n * &#x3C;/div>\n *\n * ### 사용법\n *\n * - `&#x3C;div *appUnless=\"condition\">...&#x3C;/div>`\n * - `&#x3C;ng-template [appUnless]=\"condition\">&#x3C;div>...&#x3C;/div>&#x3C;/ng-template>`\n *\n */\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({ selector: '[appUnless]'})\nexport class UnlessDirective {\n  private hasView = false;\n\n  constructor(\n    private templateRef: <a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a>&#x3C;any>,\n    private viewContainer: <a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a>) { }\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() set appUnless(condition: boolean) {\n    if (!condition &#x26;&#x26; !this.hasView) {\n      this.viewContainer.createEmbeddedView(this.templateRef);\n      this.hasView = true;\n    } else if (condition &#x26;&#x26; this.hasView) {\n      this.viewContainer.clear();\n      this.hasView = false;\n    }\n  }\n}\n\n\n</code-pane>\n\n</code-tabs>\n<!--\nYou learned:\n-->\n<p>이 문서에서는 다음 내용에 대해 다뤘습니다.</p>\n<!--\n* that structural directives manipulate HTML layout.\n* to use [`<ng-container>`](guide/structural-directives#ngcontainer) as a grouping element when there is no suitable host element.\n* that the Angular desugars [asterisk (*) syntax](guide/structural-directives#asterisk) into a `<ng-template>`.\n* how that works for the `NgIf`, `NgFor` and `NgSwitch` built-in directives.\n* about the [_microsyntax_](guide/structural-directives#microsyntax) that expands into a [`<ng-template>`](guide/structural-directives#template).\n* to write a [custom structural directive](guide/structural-directives#unless), `UnlessDirective`.\n-->\n<ul>\n<li>구조 디렉티브는 HTML 레이아웃을 변경합니다.</li>\n<li>호스트 엘리먼트에 영향을 주지 않으면서 엘리먼트를 묶으려면 <a href=\"guide/structural-directives#ngcontainer\"><code>&#x3C;ng-container></code></a>를 사용하세요.</li>\n<li><a href=\"guide/structural-directives#asterisk\">별표(*)를 사용한</a> 문법을 Angular가 처리하고 나면 <code>&#x3C;ng-template></code>이 됩니다.</li>\n<li>기본 디렉티브인 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>, <code>NgFor</code>, <code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code>가 어떻게 동작하는지 살펴봤습니다.</li>\n<li><a href=\"guide/structural-directives#template\"><code>&#x3C;ng-template></code></a>을 활용하는 <a href=\"guide/structural-directives#microsyntax\">_세부 문법</a>에 대해 알아봤습니다.</li>\n<li><a href=\"guide/structural-directives#unless\">커스텀 구조 디렉티브</a> <code>UnlessDirective</code> 를 만들어 봤습니다.</li>\n</ul>\n\n</div>\n\n<!-- links to this doc:\n - api/common\n - api/common/CommonModule\n - api/common/NgForOf\n - api/common/NgIf\n - api/common/NgSwitch\n - guide/ajs-quick-reference\n - guide/aot-compiler\n - guide/architecture-components\n - guide/attribute-directives\n - guide/bootstrapping\n - guide/built-in-directives\n - guide/example-apps-list\n - guide/glossary\n - guide/template-reference-variables\n - guide/template-typecheck\n-->\n<!-- links from this doc:\n - api/animations/state\n - api/common/NgClass\n - api/common/NgForOf\n - api/common/NgIf\n - api/common/NgIf#static-properties\n - api/common/NgSwitch\n - api/common/NgSwitchCase\n - api/common/NgSwitchDefault\n - api/core/Component\n - api/core/Directive\n - api/core/EmbeddedViewRef\n - api/core/Input\n - api/core/NgModule\n - api/core/TemplateRef\n - api/core/ViewContainerRef\n - api/forms/FormsModule\n - api/forms/NgModel\n - api/platform-browser/BrowserModule\n - api/upgrade/static\n - guide/attribute-directives\n - guide/built-in-directives\n - guide/built-in-directives#ngFor\n - guide/built-in-directives#ngIf\n - guide/built-in-directives#ngStyle\n - guide/built-in-directives#ngSwitch\n - guide/inputs-outputs\n - guide/interpolation#template-expressions\n - guide/structural-directives#appunless-프로퍼티\n - guide/structural-directives#asterisk\n - guide/structural-directives#microsyntax\n - guide/structural-directives#ng-container\n - guide/structural-directives#ng-template\n - guide/structural-directives#ngFor\n - guide/structural-directives#ngSwitch\n - guide/structural-directives#ngcontainer\n - guide/structural-directives#ngfor-내부-동작\n - guide/structural-directives#ngif로-이해하기\n - guide/structural-directives#ngswitch-내부-동작\n - guide/structural-directives#one-per-element\n - guide/structural-directives#template\n - guide/structural-directives#template-input-variable\n - guide/structural-directives#templateref-와-viewcontainerref\n - guide/structural-directives#unless\n - guide/structural-directives#구조-디렉티브-structural-directives\n - guide/structural-directives#구조-디렉티브는-호스트-엘리먼트에-하나만\n - guide/structural-directives#구조-디렉티브란\n - guide/structural-directives#디렉티브-컨텍스트의-타입-지정하기\n - guide/structural-directives#문법\n - guide/structural-directives#변환결과\n - guide/structural-directives#별표-asterisk-접두사\n - guide/structural-directives#별표-문법을-사용하세요\n - guide/structural-directives#비슷한-엘리먼트-묶기--ng-container\n - guide/structural-directives#세부-문법microsyntax\n - guide/structural-directives#세부문법-예제\n - guide/structural-directives#왜-숨기지않고-제거하는-걸까요\n - guide/structural-directives#정리\n - guide/structural-directives#제약사항\n - guide/structural-directives#커스텀-구조-디렉티브-구현하기\n - guide/structural-directives#커스텀-구조-디렉티브-작성하기\n - guide/structural-directives#커스텀-디렉티브에-향상된-템플릿-타입-검사-기능-적용하기\n - guide/structural-directives#템플릿-가드로-타입-구체화하기\n - guide/structural-directives#템플릿-입력-변수-template-input-variable\n - guide/structural-directives#해결방법--ng-container\n - guide/styleguide#02-03\n - guide/template-reference-variables\n - guide/template-typecheck\n - https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors\n - https://github.com/angular/angular/blob/master/packages/common/src/directives/ng_for_of.ts\n - https://github.com/angular/angular/blob/master/packages/common/src/directives/ng_if.ts\n - https://github.com/angular/angular/edit/master/aio/content/guide/structural-directives.md?message=docs%3A%20describe%20your%20change...\n-->"
}