{
  "id": "guide/structural-directives",
  "title": "구조 디렉티브 (Structural Directives)",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/structural-directives.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Structural directives\n-->\n<h1 id=\"구조-디렉티브-structural-directives\">구조 디렉티브 (Structural Directives)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#구조-디렉티브-structural-directives\"><i class=\"material-icons\">link</i></a></h1>\n<style>\n  h4 {font-size: 17px !important; text-transform: none !important;}\n  .syntax { font-family: Consolas, 'Lucida Sans', Courier, sans-serif; color: black; font-size: 85%; }\n\n</style>\n<!--\nThis guide looks at how Angular manipulates the DOM with **structural directives** and\nhow you can write your own structural directives to do the same thing.\n-->\n<p>이 문서는 Angular에서 <strong>구조 디렉티브</strong>가 DOM을 어떻게 조작하는지 알아봅니다. 그리고 커스텀 구조 디렉티브는 어떻게 구현하는지 알아봅니다.</p>\n<!--\nTry the <live-example></live-example>.\n-->\n<p>이 문서에서 다루는 예제는 <live-example></live-example>에서 바로 확인하거나 다운받을 수 있습니다.</p>\n<!--\n<a id=\"definition\"></a>\n-->\n<a id=\"정의\"></a>\n<!--\n## What are structural directives?\n-->\n<h2 id=\"구조-디렉티브란\">구조 디렉티브란?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#구조-디렉티브란\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nStructural directives are responsible for HTML layout.\nThey shape or reshape the DOM's _structure_, typically by adding, removing, or manipulating\nelements.\n-->\n<p>구조 디렉티브는 HTML 문서의 레이아웃과 관계가 있습니다.\n구조 디렉티브는 엘리먼트를 DOM에 추가하거나 제거하면서  DOM의 <em>구조</em> 를 조작합니다.</p>\n<!--\nAs with other directives, you apply a structural directive to a _host element_.\nThe directive then does whatever it's supposed to do with that host element and its descendants.\n-->\n<p>다른 디렉티브와 마찬가지로 구조 디렉티브도 <em>호스트 엘리먼트</em> 에 지정합니다.\n그러면 디렉티브 로직에 따라 호스트 엘리먼트나 자식 엘리먼트를 조작합니다.</p>\n<!--\nStructural directives are easy to recognize.\nAn asterisk (*) precedes the directive attribute name as in this example.\n-->\n<p>구조 디렉티브가 사용된 것은 확인하기 쉽습니다.\n이 디렉티브는 아래 예제처럼 별표(<code>*</code>)로 시작하는 어트리뷰트 이름으로 적용합니다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (ngif)\" region=\"ngif\">\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero\" class=\"name\">{{hero.name}}&#x3C;/div>\n\n</code-example>\n<!--\nNo brackets. No parentheses. Just `*ngIf` set to a string.\n-->\n<p>구조 디렉티브에는 괄호(<code>(</code>, <code>)</code>)도 없고 대괄호(<code>[</code>, <code>]</code>)도 없습니다. <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>는 단순하게 문자열일 뿐입니다.</p>\n<!--\nYou'll learn in this guide that the [asterisk (*) is a convenience notation](guide/structural-directives#asterisk)\nand the string is a [_microsyntax_](guide/structural-directives#microsyntax) rather than the usual\n[template expression](guide/template-syntax#template-expressions).\nAngular desugars this notation into a marked-up `<ng-template>` that surrounds the\nhost element and its descendents.\nEach structural directive does something different with that template.\n-->\n<p>아래 부분에서 좀 더 자세히 설명하겠지만, <a href=\"guide/structural-directives#asterisk\">별표(<code>*</code>)는 구조 디렉티브를 사용하기 편하게 만드는</a> 문법 테크닉이며, 이런 문법은 <a href=\"guide/template-syntax#template-expressions\">템플릿 표현식</a>이라기 보다는 <a href=\"guide/structural-directives#microsyntax\"><em>세부 문법(microsyntax)</em></a>이라고 하는 것이 더 적합합니다.\nAngular가 애플리케이션을 빌드하면 이 문법 테크닉은 호스트 엘리먼트와 자식 엘리먼트 사이에 <code>&#x3C;ng-template></code> 계층의 마크업을 구성하면서 사라집니다.\n이 때 구조 디렉티브를 템플릿에서 어떻게 사용했느냐에 따라 다른 결과물이 될 수도 있습니다.</p>\n<!--\nThree of the common, built-in structural directives&mdash;[NgIf](guide/template-syntax#ngIf),\n[NgFor](guide/template-syntax#ngFor), and [NgSwitch...](guide/template-syntax#ngSwitch)&mdash;are\ndescribed in the [_Template Syntax_](guide/template-syntax) guide and seen in samples throughout the Angular documentation.\nHere's an example of them in a template:\n-->\n<p>Angular의 기본 구조 디렉티브 중 가장 많이 사용하는 것은 <a href=\"guide/template-syntax#ngIf\">NgIf</a>, <a href=\"guide/template-syntax#ngFor\">NgFor</a>, <a href=\"guide/template-syntax#ngSwitch\">NgSwitch...</a> 이렇게 3가지 입니다. 각각은 <a href=\"guide/template-syntax\"><em>템플릿 문법</em></a> 문서에서 자세하게 다루며, 예제도 함께 확인할 수 있습니다.\n이 문서에서는 예제와 함께 간단하게만 알아봅시다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (built-in)\" region=\"built-in\">\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero\" class=\"name\">{{hero.name}}&#x3C;/div>\n\n&#x3C;ul>\n  &#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">{{hero.name}}&#x3C;/li>\n&#x3C;/ul>\n\n&#x3C;div [<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a>]=\"hero?.emotion\">\n  &#x3C;app-happy-hero    *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'happy'\"    [hero]=\"hero\">&#x3C;/app-happy-hero>\n  &#x3C;app-sad-hero      *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'sad'\"      [hero]=\"hero\">&#x3C;/app-sad-hero>\n  &#x3C;app-confused-hero *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'confused'\" [hero]=\"hero\">&#x3C;/app-confused-hero>\n  &#x3C;app-unknown-hero  *<a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">ngSwitchDefault</a>           [hero]=\"hero\">&#x3C;/app-unknown-hero>\n&#x3C;/div>\n\n</code-example>\n<!--\nThis guide won't repeat how to _use_ them. But it does explain _how they work_\nand how to [write your own](guide/structural-directives#unless) structural directive.\n-->\n<p>각각의 디렉티브를 <em>어떻게 사용하는지</em> 에 대해서는 이 문서에서 다루지 않습니다. 대신, 디렉티브가 <em>어떻게 동작하며</em>, 커스텀 구조 디렉티브는 <a href=\"guide/structural-directives#unless\">어떻게 만드는지</a> 알아봅니다.</p>\n<div class=\"callout is-helpful\">\n<header>\n  <!--\n  Directive spelling\n  -->\n  디렉티브의 대소문자 구분\n</header>\n<!--\nThroughout this guide, you'll see a directive spelled in both _UpperCamelCase_ and _lowerCamelCase_.\nAlready you've seen `NgIf` and `ngIf`.\nThere's a reason. `NgIf` refers to the directive _class_;\n`ngIf` refers to the directive's _attribute name_.\n-->\n<p>이 문서에서는 디렉티브를 <em>대문자 캐멀 케이스(UpperCamelCase)</em> 로 언급하기도 하고 <em>소문자 캐멀 케이스(lowerCamelCase)</em> 로 언급하기도 합니다.\n지금까지의 설명에서도 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>라고 하기도 했고 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>라고 하기도 했죠.\n이렇게 사용하는 이유가 있습니다. <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>는 디렉티브 <em>클래스</em> 자체를 가리키며, <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>는 디렉티브를 적용할 때 사용하는 <em>어트리뷰트 이름</em> 을 가리킵니다.</p>\n<!--\nA directive _class_ is spelled in _UpperCamelCase_ (`NgIf`).\nA directive's _attribute name_ is spelled in _lowerCamelCase_ (`ngIf`).\nThe guide refers to the directive _class_ when talking about its properties and what the directive does.\nThe guide refers to the _attribute name_ when describing how\nyou apply the directive to an element in the HTML template.\n-->\n<p>디렉티브의 프로퍼티나 디렉티브의 동작을 설명할 때는 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>와 같이 <em>대문자 캐멀 케이스</em> 로 정의하는 디렉티브 <em>클래스</em> 자체를 가리킵니다.\n그리고 디렉티브를 HTML 템플릿에 있는 엘리먼트에 적용하는 것을 설명할 때는 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>와 같이 <em>소문자 캐멀 케이스</em> 로 정의하는 <em>어트리뷰트 이름</em> 을 가리킵니다.</p>\n</div>\n<div class=\"alert is-helpful\">\n<!--\nThere are two other kinds of Angular directives, described extensively elsewhere:\n(1)&nbsp;components and (2)&nbsp;attribute directives.\n-->\n<p>다른 문서에서도 언급한 것처럼 Angular의 디렉티브는 크게 두 종류입니다. 그 중 하나는 (1) 컴포넌트이고, 다른 하나는 (2) 어트리뷰트 디렉티브 입니다.</p>\n<!--\nA *component* manages a region of HTML in the manner of a native HTML element.\nTechnically it's a directive with a template.\n-->\n<p><em>컴포넌트</em>는 네이티브 HTML 엘리먼트를 사용해서 HTML 문서의 한 부분을 담당합니다.\n문법적으로는 디렉티브에 템플릿이 추가된 것이 컴포넌트입니다.</p>\n<!--\nAn [*attribute* directive](guide/attribute-directives) changes the appearance or behavior\nof an element, component, or another directive.\nFor example, the built-in [`NgStyle`](guide/template-syntax#ngStyle) directive\nchanges several element styles at the same time.\n-->\n<p><a href=\"guide/attribute-directives\"><em>어트리뷰트</em> 디렉티브</a>는 엘리먼트나 컴포넌트, 디렉티브의 모습이나 동작을 변경합니다.\n예를 들어 보면, <a href=\"guide/template-syntax#ngStyle\"><code>NgStyle</code></a> 디렉티브는 엘리먼트에 여러 엘리먼트 스타일을 동시에 지정할 수 있습니다.</p>\n<!--\nYou can apply many _attribute_ directives to one host element.\nYou can [only apply one](guide/structural-directives#one-per-element) _structural_ directive to a host element.\n-->\n<p>호스트 엘리먼트에는 여러 개의 <em>어트리뷰트</em> 디렉티브를 지정할 수도 있습니다.\n하지만 구조 디렉티브는 호스트 엘리먼트에 <a href=\"guide/structural-directives#one-per-element\">하나만</a> 적용할 수 있습니다.</p>\n</div>\n<a id=\"ngIf\"></a>\n<!--\n## NgIf case study\n-->\n<h2 id=\"ngif로-이해하기\">NgIf로 이해하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#ngif로-이해하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\n`NgIf` is the simplest structural directive and the easiest to understand.\nIt takes a boolean expression and makes an entire chunk of the DOM appear or disappear.\n-->\n<p>구조 디렉티브 중에서 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>는 가장 간단하며 이해하기도 쉽습니다.\n이 디렉티브는 표현식의 결과에 따라 DOM 조각을 추가하거나 제거합니다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (ngif-true)\" region=\"ngif-true\">\n&#x3C;p *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"true\">\n  Expression is true and <a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a> is true.\n  This paragraph is in the DOM.\n&#x3C;/p>\n&#x3C;p *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"false\">\n  Expression is false and <a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a> is false.\n  This paragraph is not in the DOM.\n&#x3C;/p>\n\n</code-example>\n<!--\nThe `ngIf` directive doesn't hide elements with CSS. It adds and removes them physically from the DOM.\nConfirm that fact using browser developer tools to inspect the DOM.\n-->\n<p><code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 디렉티브는 CSS처럼 엘리먼트를 숨기는 것이 아닙니다. 이 디렉티브가 <code>false</code> 조건으로 동작하면 DOM에서 엘리먼트를 완전히 제거합니다.\n그래서 브라우저 개발자 도구로 DOM을 직접 보면 다음과 같이 처리되는 것을 확인할 수 있습니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/structural-directives/element-not-in-dom.png\" alt=\"ngIf=false element not in DOM\" width=\"322\" height=\"114\">\n</div>\n<!--\nThe top paragraph is in the DOM. The bottom, disused paragraph is not;\nin its place is a comment about \"bindings\" (more about that [later](guide/structural-directives#asterisk)).\n-->\n<p>위에 있는 <code>&#x3C;p></code> 엘리먼트는 DOM에 존재하는 엘리먼트입니다. 그리고 아래에 있는 <code>&#x3C;p></code> 엘리먼트는 DOM에 존재하지 않습니다. 이 엘리먼트는 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 디렉티브에 의해 처리되고 주석으로만 존재합니다. 이 내용은 <a href=\"guide/structural-directives#asterisk\">아래</a>에서 좀 더 자세하게 설명합니다.</p>\n<!--\nWhen the condition is false, `NgIf` removes its host element from the DOM,\ndetaches it from DOM events (the attachments that it made),\ndetaches the component from Angular change detection, and destroys it.\nThe component and DOM nodes can be garbage-collected and free up memory.\n-->\n<p>평가식의 값이 <code>false</code>이면 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 디렉티브는 호스트 엘리먼트를 DOM에서 완전히 제거하고 DOM 이벤트 대상에서도 제외합니다. 그리고 Angular의 변화 감지 대상에서도 제외한 후에 디렉티브를 종료합니다.\n따라서 이 디렉티브와 DOM 노드 조각은 가비지 콜렉션의 대상이 되어 메모리에서도 완전히 제거됩니다.</p>\n<!--\n### Why *remove* rather than *hide*?\n-->\n<h3 id=\"왜-숨기지않고-제거하는-걸까요\">왜 <em>숨기지</em>않고 <em>제거</em>하는 걸까요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#왜-숨기지않고-제거하는-걸까요\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nA directive could hide the unwanted paragraph instead by setting its `display` style to `none`.\n-->\n<p>디렉티브가 화면에 보일 필요가 없으면 <code>display</code> 스타일을 <code>none</code>으로 지정해서 감추는 방법도 있습니다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (display-none)\" region=\"display-none\">\n&#x3C;p [style.display]=\"'block'\">\n  Expression sets display to \"block\".\n  This paragraph is visible.\n&#x3C;/p>\n&#x3C;p [style.display]=\"'none'\">\n  Expression sets display to \"none\".\n  This paragraph is hidden but still in the DOM.\n&#x3C;/p>\n\n</code-example>\n<!--\nWhile invisible, the element remains in the DOM.\n-->\n<p>하지만 이 경우에 엘리먼트는 DOM에 여전히 존재합니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/structural-directives/element-display-in-dom.png\" alt=\"hidden element still in DOM\" width=\"415\" height=\"185\">\n</div>\n<!--\nThe difference between hiding and removing doesn't matter for a simple paragraph.\nIt does matter when the host element is attached to a resource intensive component.\nSuch a component's behavior continues even when hidden.\nThe component stays attached to its DOM element. It keeps listening to events.\nAngular keeps checking for changes that could affect data bindings.\nWhatever the component was doing, it keeps doing.\n-->\n<p><code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>가 조작하는 엘리먼트가 간단하다면 숨기든 제거하든 큰 문제가 되지 않을 수도 있습니다.\n하지만 복잡한 경우에는 문제가 될 수 있는데, 컴포넌트가 화면에는 보이지 않더라도 이 컴포넌트는 계속 동작하기 때문입니다.\nDOM에 여전히 남아있으면서 이벤트도 계속 받고, 바인딩 된 데이터가 변경되면 변화 감지 로직도 동작합니다.\n컴포넌트는 원래 동작하던 대로 계속 동작할 것입니다.</p>\n<!--\nAlthough invisible, the component&mdash;and all of its descendant components&mdash;tie up resources.\nThe performance and memory burden can be substantial, responsiveness can degrade, and the user sees nothing.\n-->\n<p>컴포넌트가 보이지 않는 상황에서도 이 컴포넌트와 컴포넌트의 자식 컴포넌트 들은 리소스를 계속 사용합니다.\n애플리케이션 성능은 저하되고 가용 메모리는 줄어들 것이며, 사용자의 반응성은 떨어질 것이지만 사용자는 이 컴포넌트를 여전히 볼 수 없습니다.</p>\n<!--\nOn the positive side, showing the element again is quick.\nThe component's previous state is preserved and ready to display.\nThe component doesn't re-initialize&mdash;an operation that could be expensive.\nSo hiding and showing is sometimes the right thing to do.\n-->\n<p>장점이 하나 있다면, 이 엘리먼트를 다시 표시하는 것은 빠릅니다.\n컴포넌트의 이전 상태가 계속 유지되며 화면에 표시될 준비도 이미 끝났기 때문입니다.\n그리고 복잡할수도 있는 컴포넌트 초기화 동작은 이미 실행되었기 때문에 다시 실행되지 않습니다.\n그래서 어떤 경우에는 DOM에서 제거하지 않고 감추기만 하는 것이 좋을 수도 있습니다.</p>\n<!--\nBut in the absence of a compelling reason to keep them around,\nyour preference should be to remove DOM elements that the user can't see\nand recover the unused resources with a structural directive like `NgIf` .\n-->\n<p>하지만 굳이 이런 경우가 아니라면, 사용자에게 표시될 필요가 없는 컴포넌트는 DOM에서 완전히 제거하고 사용하던 자원도 반환하는 것이 좋습니다.</p>\n<!--\n**These same considerations apply to every structural directive, whether built-in or custom.**\nBefore applying a structural directive, you might want to pause for a moment\nto consider the consequences of adding and removing elements and of creating and destroying components.\n-->\n<p><strong>이 개념은 Angular 기본 디렉티브는 물론이고 커스텀 디렉티브에도 적용됩니다.</strong>\n구조 디렉티브를 템플릿에 적용하기 전에, 이 디렉티브를 생성하고 종료하는 비용, 엘리먼트를 DOM에 추가하고 제거하는 비용이 얼마나 필요한지 꼭 고민해 보세요.</p>\n<a id=\"asterisk\"></a>\n<a id=\"the-asterisk--prefix\"></a>\n<!--\n## The asterisk (*) prefix\n-->\n<h2 id=\"별표-asterisk-접두사\">별표(<code>*</code>, asterisk) 접두사<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#별표-asterisk-접두사\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nSurely you noticed the asterisk (*) prefix to the directive name\nand wondered why it is necessary and what it does.\n-->\n<p>지금까지 설명한 예제처럼 디렉티브 이름에는 별표(<code>*</code>) 접두사를 사용하는데, 왜 이 접두사가 필요한지 궁금할 수 있습니다.</p>\n<!--\nHere is `*ngIf` displaying the hero's name if `hero` exists.\n-->\n<p>아래 코드는 <code>hero</code> 프로퍼티에 객체가 할당되었을 때 히어로의 이름을 표시하는 예제입니다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (asterisk)\" region=\"asterisk\">\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero\" class=\"name\">{{hero.name}}&#x3C;/div>\n\n</code-example>\n<!--\nThe asterisk is \"syntactic sugar\" for something a bit more complicated.\nInternally, Angular translates the `*ngIf` _attribute_ into a `<ng-template>` _element_, wrapped around the host element, like this.\n-->\n<p>별표는 복잡한 문법을 단순하게 표현하는 문법 테크닉입니다.\nAngular가 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> <em>어트리뷰트</em> 를 내부적으로 처리할 때는 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 디렉티브가 적용된 호스트 엘리먼트를 감싸도록 <code>&#x3C;ng-template></code> <em>엘리먼트</em> 를 구성합니다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (ngif-template)\" region=\"ngif-template\">\n&#x3C;ng-template [<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>]=\"hero\">\n  &#x3C;div class=\"name\">{{hero.name}}&#x3C;/div>\n&#x3C;/ng-template>\n\n</code-example>\n<!--\n* The `*ngIf` directive moved to the `<ng-template>` element where it became a property binding,`[ngIf]`.\n* The rest of the `<div>`, including its class attribute, moved inside the `<ng-template>` element.\n-->\n<ul>\n<li><code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 디렉티브는 호스트 엘리먼트 대신 <code>&#x3C;ng-template></code> 엘리먼트로 옮겨지며, 프로퍼티 바인딩 형태인 <code>[<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>]</code>로 변환됩니다.</li>\n<li>그리고 호스트 엘리먼트 <code>&#x3C;div></code>는 나머지 어트리뷰트를 그대로 갖고 <code>&#x3C;ng-template></code> 엘리먼트 안으로 이동합니다.</li>\n</ul>\n<!--\nThe first form is not actually rendered, only the finished product ends up in the DOM.\n-->\n<p>DOM에는 원래 엘리먼트 대신 변환된 엘리먼트가 적용됩니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/structural-directives/hero-div-in-dom.png\" alt=\"hero div in DOM\" width=\"330\" height=\"67\">\n</div>\n<!--\nAngular consumed the `<ng-template>` content during its actual rendering and\nreplaced the `<ng-template>` with a diagnostic comment.\n-->\n<p>그리고 이 호스트 엘리먼트가 렌더링될 때는 <code>&#x3C;ng-template></code>가 제거되고 디버깅 주석과 안쪽 내용물만 렌더링 됩니다.</p>\n<!--\nThe [`NgFor`](guide/structural-directives#ngFor) and [`NgSwitch...`](guide/structural-directives#ngSwitch) directives follow the same pattern.\n-->\n<p>이 과정은 <a href=\"guide/structural-directives#ngFor\"><code>NgFor</code></a>나 <a href=\"guide/structural-directives#ngSwitch\"><code>NgSwitch...</code></a>에서도 비슷합니다.</p>\n<a id=\"ngFor\"></a>\n<!--\n## Inside _*ngFor_\n-->\n<h2 id=\"ngfor-내부-동작\"><em>*ngFor</em> 내부 동작<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#ngfor-내부-동작\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAngular transforms the `*ngFor` in similar fashion from asterisk (*) syntax to `<ng-template>` _element_.\n-->\n<p>별표(<code>*</code>) 접두사가 붙는 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>도 이와 비슷하게 <code>&#x3C;ng-template></code> <em>엘리먼트</em> 를 활용합니다.</p>\n<!--\nHere's a full-featured application of `NgFor`, written both ways:\n-->\n<p><code>NgFor</code> 디렉티브의 기능이 다양하게 활용된 예제를 확인해 봅시다:</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (inside-ngfor)\" region=\"inside-ngfor\">\n&#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes; let i=index; let <a href=\"api/common/NgForOfContext#odd\" class=\"code-anchor\">odd</a>=<a href=\"api/common/NgForOfContext#odd\" class=\"code-anchor\">odd</a>; trackBy: <a href=\"api/core/IterableChangeRecord#trackById\" class=\"code-anchor\">trackById</a>\" [class.odd]=\"<a href=\"api/common/NgForOfContext#odd\" class=\"code-anchor\">odd</a>\">\n  ({{i}}) {{hero.name}}\n&#x3C;/div>\n\n&#x3C;ng-template <a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a> let-hero [<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngForOf</a>]=\"heroes\" let-i=\"index\" let-odd=\"<a href=\"api/common/NgForOfContext#odd\" class=\"code-anchor\">odd</a>\" [<a href=\"api/common/NgForOf#ngForTrackBy\" class=\"code-anchor\">ngForTrackBy</a>]=\"<a href=\"api/core/IterableChangeRecord#trackById\" class=\"code-anchor\">trackById</a>\">\n  &#x3C;div [class.odd]=\"<a href=\"api/common/NgForOfContext#odd\" class=\"code-anchor\">odd</a>\">({{i}}) {{hero.name}}&#x3C;/div>\n&#x3C;/ng-template>\n\n</code-example>\n<!--\nThis is manifestly more complicated than `ngIf` and rightly so.\nThe `NgFor` directive has more features, both required and optional, than the `NgIf` shown in this guide.\nAt minimum `NgFor` needs a looping variable (`let hero`) and a list (`heroes`).\n-->\n<p>이 예제는 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 때보다 복잡해 보이고, 실제로도 복잡합니다.\n<code>NgFor</code>는 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>보다 기능이 많습니다. <code>NgFor</code>를 최소한으로 사용하려면 배열(<code>heroes</code>)과 변수(<code>let hero</code>)만 있으면 되지만요.</p>\n<!--\nYou enable these features in the string assigned to `ngFor`, which you write in Angular's [microsyntax](guide/structural-directives#microsyntax).\n-->\n<p><code>NgFor</code>의 기능은 <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>에 적용되는 문자열이 어떻게 구성되느냐에 따라 달라집니다. 이 내용은 <a href=\"guide/structural-directives#microsyntax\">세부 문법</a>에서 자세하게 확인해 보세요.</p>\n<div class=\"alert is-helpful\">\n<!--\nEverything _outside_ the `ngFor` string stays with the host element\n(the `<div>`) as it moves inside the `<ng-template>`.\nIn this example, the `[ngClass]=\"odd\"` stays on the `<div>`.\n-->\n<p><code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>에 적용되는 문자열 이외에는 모두 호스트 엘리먼트 <code>&#x3C;div></code>에 남아 있으며, <code>&#x3C;ng-template></code> 내부로 호스트 엘리먼트가 이동할 때 함께 움직입니다.\n이 예제로 보면 <code>[<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"<a href=\"api/common/NgForOfContext#odd\" class=\"code-anchor\">odd</a>\"</code>는 <code>&#x3C;div></code> 엘리먼트에 그대로 적용되는 것을 확인할 수 있습니다.</p>\n</div>\n<a id=\"microsyntax\"></a>\n<!--\n## Microsyntax\n-->\n<h2 id=\"세부-문법microsyntax\">세부 문법(microsyntax)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#세부-문법microsyntax\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe Angular microsyntax lets you configure a directive in a compact, friendly string.\nThe microsyntax parser translates that string into attributes on the `<ng-template>`:\n-->\n<p>세부 문법을 활용하면 복잡한 디렉티브 설정을 문자열로 간단하게 할 수 있습니다.\n세부 문법은 별도의 파서를 사용해서 문자열을 <code>&#x3C;ng-template></code>의 어트리뷰트로 변환합니다.</p>\n<!--\n* The `let` keyword declares a [_template input variable_](guide/structural-directives#template-input-variable)\nthat you reference within the template. The input variables in this example are `hero`, `i`, and `odd`.\nThe parser translates `let hero`, `let i`, and `let odd` into variables named\n`let-hero`, `let-i`, and `let-odd`.\n-->\n<ul>\n<li><code>let</code> 키워드는 <a href=\"guide/structural-directives#%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%9E%85%EB%A0%A5-%EB%B3%80%EC%88%98\"><em>템플릿 입력 변수</em></a>를 선언합니다. 이 변수는 템플릿 안에서 참조할 수 있으며, <code>hero</code>나 <code>i</code>, <code><a href=\"api/common/NgForOfContext#odd\" class=\"code-anchor\">odd</a></code> 등이 템플릿 변수에 해당합니다.\n문자열에 있던 <code>let hero</code>, <code>let i</code>, <code>let <a href=\"api/common/NgForOfContext#odd\" class=\"code-anchor\">odd</a></code>를 파서가 처리하고 나면 <code>let-hero</code>, <code>let-i</code>, <code>let-odd</code>와 같은 이름으로 변경됩니다.</li>\n</ul>\n<!--\n* The microsyntax parser title-cases all directives and prefixes them with the directive's\nattribute name, such as `ngFor`. For example, the `ngFor` input properties,\n`of` and `trackBy`, become `ngForOf` and `ngForTrackBy`, respectively.\nThat's how the directive learns that the list is `heroes` and the track-by function is `trackById`.\n-->\n<ul>\n<li>The microsyntax parser title-cases all directives and prefixes them with the directive's\nattribute name, such as <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>. For example, the <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> input properties,\n<code>of</code> and <code>trackBy</code>, become <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngForOf</a></code> and <code><a href=\"api/common/NgForOf#ngForTrackBy\" class=\"code-anchor\">ngForTrackBy</a></code>, respectively.\nThat's how the directive learns that the list is <code>heroes</code> and the track-by function is <code><a href=\"api/core/IterableChangeRecord#trackById\" class=\"code-anchor\">trackById</a></code>.</li>\n</ul>\n<!--\n* As the `NgFor` directive loops through the list, it sets and resets properties of its own _context_ object.\nThese properties can include, but aren't limited to, `index`, `odd`, and a special property\nnamed `$implicit`.\n-->\n<ul>\n<li><code>NgFor</code> 디렉티브가 배열을 순회할 때 각 싸이클마다 <code>NgFor</code> 컨텍스트에만 적용되는 프로퍼티가 있습니다.\n<code>index</code>나 <code><a href=\"api/common/NgForOfContext#odd\" class=\"code-anchor\">odd</a></code>, <code>$implicit</code>가 이런 프로퍼티에 해당됩니다.</li>\n</ul>\n<!--\n* The `let-i` and `let-odd` variables were defined as `let i=index` and `let odd=odd`.\nAngular sets them to the current value of the context's `index` and `odd` properties.\n-->\n<ul>\n<li><code>let-i</code>나 <code>let-odd</code>와 같은 변수는 <code>let i=index</code>나 <code>let <a href=\"api/common/NgForOfContext#odd\" class=\"code-anchor\">odd</a>=<a href=\"api/common/NgForOfContext#odd\" class=\"code-anchor\">odd</a></code>를 사용할 때만 선언됩니다.\n그리고 이 때 사용되는 <code>index</code>와 <code><a href=\"api/common/NgForOfContext#odd\" class=\"code-anchor\">odd</a></code> 프로퍼티는 <code>NgFor</code> 컨텍스트에 맞게 Angular가 각각 할당합니다.</li>\n</ul>\n<!--\n* The context property for `let-hero` wasn't specified.\nIts intended source is implicit.\nAngular sets `let-hero` to the value of the context's `$implicit` property,\nwhich `NgFor` has initialized with the hero for the current iteration.\n-->\n<ul>\n<li>\n<p>하지만 <code>let-hero</code> 변수는 소스 코드에 따로 선언되며 외부에서는 확인할 수 없습니다. 좀 더 자세하게 설명하면, <code>let-hero</code> 변수는 컨텍스트의 <code>$implicit</code> 프로퍼티 안에 선언되며, 현재 순회하는 배열에 맞게 Angular가 값을 할당합니다.</p>\n</li>\n<li>\n<p>The <a href=\"api/common/NgForOf\" title=\"API: NgFor\"><code>NgFor</code> API guide</a>\ndescribes additional <code>NgFor</code> directive properties and context properties.</p>\n</li>\n<li>\n<p>The <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> directive implements <code>NgFor</code>. Read more about additional <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> directive properties and context properties in the <a href=\"api/common/NgForOf\">NgForOf API reference</a>.</p>\n</li>\n</ul>\n<h3 id=\"writing-your-own-structural-directives\">Writing your own structural directives<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#writing-your-own-structural-directives\"><i class=\"material-icons\">link</i></a></h3>\n<p>These microsyntax mechanisms are also available to you when you write your own structural directives.\nFor example, microsyntax in Angular allows you to write <code>&#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let <a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a> of items\">{{<a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>}}&#x3C;/div></code>\ninstead of <code>&#x3C;ng-template <a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a> let-item [<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngForOf</a>]=\"items\">&#x3C;div>{{<a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a>}}&#x3C;/div>&#x3C;/ng-template></code>.\nThe following sections provide detailed information on constraints, grammar,\nand translation of microsyntax.</p>\n<h3 id=\"constraints\">Constraints<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#constraints\"><i class=\"material-icons\">link</i></a></h3>\n<p>Microsyntax must meet the following requirements:</p>\n<ul>\n<li>It must be known ahead of time so that IDEs can parse it without knowing the underlying semantics of the directive or what directives are present.</li>\n<li>It must translate to key-value attributes in the DOM.</li>\n</ul>\n<h3 id=\"grammar\">Grammar<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#grammar\"><i class=\"material-icons\">link</i></a></h3>\n<p>When you write your own structural directives, use the following grammar:</p>\n<code-example>\n*:prefix=\"( :let | :expression ) (';' | ',')? ( :let | :as | :keyExp )*\"\n</code-example>\n<p>The following tables describe each portion of the microsyntax grammar.</p>\n<!-- What should I put in the table headers? -->\n<table>\n  <tbody><tr>\n    <th></th>\n    <th></th>\n  </tr>\n  <tr>\n    <td><code>prefix</code></td>\n    <td>HTML attribute key</td>\n  </tr>\n  <tr>\n    <td><code>key</code></td>\n    <td>HTML attribute key</td>\n  </tr>\n  <tr>\n    <td><code>local</code></td>\n    <td>local variable name used in the template</td>\n  </tr>\n  <tr>\n    <td><code>export</code></td>\n    <td>value exported by the directive under a given name</td>\n  </tr>\n  <tr>\n    <td><code>expression</code></td>\n    <td>standard Angular expression</td>\n  </tr>\n</tbody></table>\n<!-- The items in this table seem different. Is there another name for how we should describe them? -->\n<table>\n  <tbody><tr>\n    <th></th>\n  </tr>\n  <tr>\n    <td colspan=\"3\"><code>keyExp = :key \":\"? :expression (\"as\" :local)? \";\"? </code></td>\n  </tr>\n  <tr>\n    <td colspan=\"3\"><code>let = \"let\" :local \"=\" :export \";\"?</code></td>\n  </tr>\n  <tr>\n    <td colspan=\"3\"><code>as = :export \"as\" :local \";\"?</code></td>\n  </tr>\n</tbody></table>\n<h3 id=\"translation\">Translation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#translation\"><i class=\"material-icons\">link</i></a></h3>\n<p>A microsyntax is translated to the normal binding syntax as follows:</p>\n<!-- What to put in the table headers below? Are these correct?-->\n<table>\n  <tbody><tr>\n    <th>Microsyntax</th>\n    <th>Translation</th>\n  </tr>\n  <tr>\n    <td><code>prefix</code> and naked <code>expression</code></td>\n    <td><code>[prefix]=\"expression\"</code></td>\n  </tr>\n  <tr>\n    <td><code>keyExp</code></td>\n    <td><code>[prefixKey] \"expression\"\n    (let-prefixKey=\"export\")</code>\n    <br>\n    Notice that the <code>prefix</code>\n    is added to the <code>key</code>\n    </td>\n  </tr>\n  <tr>\n    <td><code>let</code></td>\n    <td><code>let-local=\"export\"</code></td>\n  </tr>\n</tbody></table>\n<h3 id=\"microsyntax-examples\">Microsyntax examples<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#microsyntax-examples\"><i class=\"material-icons\">link</i></a></h3>\n<p>The following table demonstrates how Angular desugars microsyntax.</p>\n<table>\n  <tbody><tr>\n    <th>Microsyntax</th>\n    <th>Desugared</th>\n  </tr>\n  <tr>\n    <td><code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let <a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a> of [1,2,3]\"</code></td>\n    <td><code>&#x3C;ng-template <a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a> let-item [<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngForOf</a>]=\"[1,2,3]\"></code></td>\n  </tr>\n  <tr>\n    <td><code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let <a href=\"api/core/IterableChangeRecord#item\" class=\"code-anchor\">item</a> of [1,2,3] as items; trackBy: myTrack; index as i\"</code></td>\n    <td><code>&#x3C;ng-template <a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a> let-item [<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngForOf</a>]=\"[1,2,3]\" let-items=\"<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngForOf</a>\" [<a href=\"api/common/NgForOf#ngForTrackBy\" class=\"code-anchor\">ngForTrackBy</a>]=\"myTrack\" let-i=\"index\"></code>\n    </td>\n  </tr>\n  <tr>\n    <td><code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"exp\"</code></td>\n    <td><code>&#x3C;ng-template [<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>]=\"exp\"></code></td>\n  </tr>\n  <tr>\n    <td><code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"exp as value\"</code></td>\n    <td><code>&#x3C;ng-template [<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>]=\"exp\" let-value=\"<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>\"></code></td>\n  </tr>\n</tbody></table>\n<p>Studying the\n<a href=\"https://github.com/angular/angular/blob/master/packages/common/src/directives/ng_if.ts\" title=\"Source: NgIf\">source code for <code>NgIf</code></a>\nand <a href=\"https://github.com/angular/angular/blob/master/packages/common/src/directives/ng_for_of.ts\" title=\"Source: NgForOf\"><code>NgForOf</code></a>\nis a great way to learn more.</p>\n<a id=\"template-input-variable\"></a>\n<!--\n<a id=\"template-input-variables\"></a>\n-->\n<a id=\"템플릿-입력-변수\"></a>\n<!--\n## Template input variable\n-->\n<h2 id=\"템플릿-입력-변수-template-input-variable\">템플릿 입력 변수 (Template input variable)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#템플릿-입력-변수-template-input-variable\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nA _template input variable_ is a variable whose value you can reference _within_ a single instance of the template.\nThere are several such variables in this example: `hero`, `i`, and `odd`.\nAll are preceded by the keyword `let`.\n-->\n<p><em>템플릿 입력 변수</em> 는 템플릿 인스턴스 <em>안에서</em> 참조할 수 있는 변수입니다.\n위에서 살펴본 예제에서는 <code>hero</code>, <code>i</code>, <code><a href=\"api/common/NgForOfContext#odd\" class=\"code-anchor\">odd</a></code>가 템플릿 입력 변수이며, <code>let</code> 키워드를 사용해서 선언합니다.</p>\n<!--\nA _template input variable_ is **_not_** the same as a\n[template _reference_ variable](guide/template-syntax#ref-vars),\nneither _semantically_ nor _syntactically_.\n-->\n<p><em>템플릿 입력 변수</em> 는 <em>용도</em> 나 <em>문법</em> 측면에서 봤을 때 <a href=\"guide/template-syntax#ref-vars\">템플릿 <em>참조</em> 변수</a>와는 <strong><em>다릅니다</em></strong>.</p>\n<!--\nYou declare a template _input_ variable using the `let` keyword (`let hero`).\nThe variable's scope is limited to a _single instance_ of the repeated template.\nYou can use the same variable name again in the definition of other structural directives.\n-->\n<p>템플릿 <em>입력</em> 변수는 <code>let hero</code>와 같이 <code>let</code> 키워드를 사용해서 선언합니다.\n이 변수의 스코프는 반복되는 템플릿 <em>인스턴스 하나</em> 로만 제한되며, 템플릿 안에 있는 다른 구조 디렉티브에도 같은 이름의 변수를 사용할 수 있습니다.</p>\n<!--\nYou declare a template _reference_ variable by prefixing the variable name with `#` (`#var`).\nA _reference_ variable refers to its attached element, component or directive.\nIt can be accessed _anywhere_ in the _entire template_.\n-->\n<p>반면에 템플릿 <em>참조</em> 변수는 <code>#var</code>와 같이 <code>#</code> 접두사를 붙여 선언합니다.\n이 변수는 템플릿 참조 변수가 붙은 엘리먼트나 컴포넌트, 디렉티브를 가리키며, <em>템플릿 전체</em> 범위에서 이 엘리먼트를 자유롭게 참조할 수 있습니다.</p>\n<!--\nTemplate _input_ and _reference_ variable names have their own namespaces. The `hero` in `let hero` is never the same\nvariable as the `hero` declared as `#hero`.\n-->\n<p>템플릿 <em>입력</em> 변수와 <em>참조</em> 변수의 이름은 각각의 네임스페이스 안에 존재합니다. 그래서 <code>let hero</code>라고 선언했을 때의 <code>hero</code>와 <code>#hero</code>라고 선언했을 때의 <code>hero</code>는 다른 변수입니다.</p>\n<a id=\"one-per-element\"></a>\n<a id=\"one-structural-directive-per-host-element\"></a>\n<!--\n## One structural directive per host element\n-->\n<h2 id=\"구조-디렉티브는-호스트-엘리먼트에-하나만\">구조 디렉티브는 호스트 엘리먼트에 하나만<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#구조-디렉티브는-호스트-엘리먼트에-하나만\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nSomeday you'll want to repeat a block of HTML but only when a particular condition is true.\nYou'll _try_ to put both an `*ngFor` and an `*ngIf` on the same host element.\nAngular won't let you. You may apply only one _structural_ directive to an element.\n-->\n<p><code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>로 순회하는 배열의 각 항목이 특정 조건일때만 이 항목을 화면에 사용하도록 하려고 합니다.\n그러면 호스트 엘리먼트에 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>를 사용하면서 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>를 함께 사용하는 것이 맞다고 생각할 수 있습니다.\n하지만 이 문법은 동작하지 않습니다. <em>구조</em> 디렉티브는 한 엘리먼트에 하나만 적용할 수 있습니다.</p>\n<!--\nThe reason is simplicity. Structural directives can do complex things with the host element and its descendents.\nWhen two directives lay claim to the same host element, which one takes precedence?\nWhich should go first, the `NgIf` or the `NgFor`? Can the `NgIf` cancel the effect of the `NgFor`?\nIf so (and it seems like it should be so), how should Angular generalize the ability to cancel for other structural directives?\n-->\n<p>이유는 단순합니다. 구조 디렉티브를 다른 구조 디렉티브와 함께 사용하는 로직은 간단하게 일반화 할 수 없습니다.\n하나의 호스트 엘리먼트에 구조 디렉티브가 여러개 적용되면 어떻게 될까요?\n<code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>와 <code>NgFor</code>중 어떤 것이 먼저 처리되어야 할까요? <code>NgFor</code> 전체에 대해 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>가 적용되는 것이 맞을까요?\n<code>NgFor</code>이외의 구조 디렉티브에도 이 정책을 적용하는 것이 맞을까요?</p>\n<!--\nThere are no easy answers to these questions. Prohibiting multiple structural directives makes them moot.\nThere's an easy solution for this use case: put the `*ngIf` on a container element that wraps the `*ngFor` element.\nOne or both elements can be an [`ng-container`](guide/structural-directives#ngcontainer) so you don't have to introduce extra levels of HTML.\n-->\n<p>답을 내리기는 쉽지 않습니다. 구조 디렉티브가 동시에 여러개 사용된다면 각각의 경우를 모두 따져봐야 합니다.\n하지만 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>를 적용한 엘리먼트 안에 또 다른 엘리먼트를 두고 이 엘리먼트에 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>를 적용하는 경우라면 간단합니다.</p>\n<!--\n하나 또는 두 개의 엘리먼트는 [`ng-container`](guide/structural-directives#ngcontainer)의 대상이 될 수 있기 때문에, 기존에 활용하던 HTML에서 크게 벗어나지 않습니다.\n-->\n<a id=\"ngSwitch\"></a>\n<!--\n## Inside _NgSwitch_ directives\n-->\n<h2 id=\"ngswitch-내부-동작\"><em>NgSwitch</em> 내부 동작<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#ngswitch-내부-동작\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe Angular _NgSwitch_ is actually a set of cooperating directives: `NgSwitch`, `NgSwitchCase`, and `NgSwitchDefault`.\n-->\n<p>Angular 기본 디렉티브인 <em>NgSwitch</em> 를 사용한다는 것은 사실 <code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code>, <code><a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">NgSwitchCase</a></code>, <code><a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">NgSwitchDefault</a></code> 디렉티브를 함께 사용하는 것을 의미합니다.</p>\n<!--\nHere's an example.\n-->\n<p>예제를 확인해 봅시다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (ngswitch)\" region=\"ngswitch\">\n&#x3C;div [<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a>]=\"hero?.emotion\">\n  &#x3C;app-happy-hero    *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'happy'\"    [hero]=\"hero\">&#x3C;/app-happy-hero>\n  &#x3C;app-sad-hero      *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'sad'\"      [hero]=\"hero\">&#x3C;/app-sad-hero>\n  &#x3C;app-confused-hero *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'confused'\" [hero]=\"hero\">&#x3C;/app-confused-hero>\n  &#x3C;app-unknown-hero  *<a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">ngSwitchDefault</a>           [hero]=\"hero\">&#x3C;/app-unknown-hero>\n&#x3C;/div>\n\n</code-example>\n<!--\nThe switch value assigned to `NgSwitch` (`hero.emotion`) determines which\n(if any) of the switch cases are displayed.\n-->\n<p><code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code>는 적용되는 값에 해당되는 템플릿을 화면에 표시합니다. 위 예제의 경우에는 <code>hero.emotion</code>에 의해 결정됩니다.</p>\n<!--\n`NgSwitch` itself is not a structural directive.\nIt's an _attribute_ directive that controls the behavior of the other two switch directives.\nThat's why you write `[ngSwitch]`, never `*ngSwitch`.\n-->\n<p><code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code> 디렉티브 자체는 구조 디렉티브가 아닙니다.\n<code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code> 디렉티브는 <em>어트리뷰트</em> 디렉티브이며, 다른 두 디렉티브의 동작을 조절합니다.\n그래서 <code>*<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a></code>와 같이 지정하지 않고 <code>[<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a>]</code>로 지정합니다.</p>\n<!--\n`NgSwitchCase` and `NgSwitchDefault` _are_ structural directives.\nYou attach them to elements using the asterisk (*) prefix notation.\nAn `NgSwitchCase` displays its host element when its value matches the switch value.\nThe `NgSwitchDefault` displays its host element when no sibling `NgSwitchCase` matches the switch value.\n-->\n<p><code><a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">NgSwitchCase</a></code>와 <code><a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">NgSwitchDefault</a></code>는 구조 디렉티브입니다.\n그래서 이 디렉티브들은 별표(<code>*</code>)를 사용하면서 엘리먼트에 지정합니다.\n그러면 지정된 값에 해당하는 <code><a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">NgSwitchCase</a></code>가 화면에 표시되고, 아무 값도 해당되지 않으면 <code><a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">NgSwitchDefault</a></code>가 화면에 표시됩니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nThe element to which you apply a directive is its _host_ element.\nThe `<happy-hero>` is the host element for the happy `*ngSwitchCase`.\nThe `<unknown-hero>` is the host element for the `*ngSwitchDefault`.\n-->\n<p>각각의 디렉티브가 적용된 엘리먼트가 그 디렉티브의 <em>호스트</em> 엘리먼트입니다.\n그래서 <code>*<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a></code>의 호스트 엘리먼트는 <code>&#x3C;app-happy-hero></code>이고, <code>*<a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">ngSwitchDefault</a></code>의 호스트 엘리먼트는 <code>&#x3C;app-unknown-hero></code>입니다.</p>\n</div>\n<!--\nAs with other structural directives, the `NgSwitchCase` and `NgSwitchDefault`\ncan be desugared into the `<ng-template>` element form.\n-->\n<p>다른 구조 디렉티브와 마찬가지로, <code><a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">NgSwitchCase</a></code>와 <code><a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">NgSwitchDefault</a></code>도 Angular가 렌더링할 때는 <code>&#x3C;ng-template></code> 엘리먼트로 변환됩니다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (ngswitch-template)\" region=\"ngswitch-template\">\n&#x3C;div [<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a>]=\"hero?.emotion\">\n  &#x3C;ng-template [<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>]=\"'happy'\">\n    &#x3C;app-happy-hero [hero]=\"hero\">&#x3C;/app-happy-hero>\n  &#x3C;/ng-template>\n  &#x3C;ng-template [<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>]=\"'sad'\">\n    &#x3C;app-sad-hero [hero]=\"hero\">&#x3C;/app-sad-hero>\n  &#x3C;/ng-template>\n  &#x3C;ng-template [<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>]=\"'confused'\">\n    &#x3C;app-confused-hero [hero]=\"hero\">&#x3C;/app-confused-hero>\n  &#x3C;/ng-template >\n  &#x3C;ng-template <a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">ngSwitchDefault</a>>\n    &#x3C;app-unknown-hero [hero]=\"hero\">&#x3C;/app-unknown-hero>\n  &#x3C;/ng-template>\n&#x3C;/div>\n\n</code-example>\n<a id=\"prefer-asterisk\"></a>\n<!--\n## Prefer the asterisk (*) syntax.\n-->\n<h2 id=\"별표-문법을-사용하세요\">별표(<code>*</code>) 문법을 사용하세요.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#별표-문법을-사용하세요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe asterisk (*) syntax is more clear than the desugared form.\nUse [&lt;ng-container&gt;](guide/structural-directives#ng-container) when there's no single element\nto host the directive.\n\nWhile there's rarely a good reason to apply a structural directive in template _attribute_ or _element_ form,\nit's still important to know that Angular creates a `<ng-template>` and to understand how it works.\nYou'll refer to the `<ng-template>` when you [write your own structural directive](guide/structural-directives#unless).\n-->\n<p><code>&#x3C;ng-template></code>을 직접 사용하는 것보다는 별표(<code>*</code>)를 사용한 문법이 좀 더 간결합니다.\n그리고 별표(<code>*</code>) 문법을 사용하지 않고 <em>어트리뷰트</em> 형태나 <code>&#x3C;ng-template></code> 형태로 구조 디렉티브를 사용했을 때 더 나은 점도 딱히 없습니다.\n그래서 구조 디렉티브는 별표(<code>*</code>)를 붙여 축약된 문법으로 사용하는 것을 권장합니다.</p>\n<p>별표(<code>*</code>) 문법이 사용된 엘리먼트는 Angular가 <code>&#x3C;ng-template></code>으로 변환한다는 것을 알고 넘어가는 것이 중요합니다.\n<code>&#x3C;ng-template></code>은 <a href=\"guide/structural-directives#unless\">커스텀 구조 디렉티브</a>를 정의할 때도 활용됩니다.</p>\n<p>디렉티브가 조작하는 엘리먼트가 여러개라면 <a href=\"guide/structural-directives#ng-container\">&#x3C;ng-container></a>를 사용하는 것도 좋습니다.</p>\n<a id=\"template\"></a>\n<!--\n## The *&lt;ng-template&gt;*\n-->\n<h2 id=\"ng-template\"><em>&#x3C;ng-template></em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#ng-template\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe &lt;ng-template&gt; is an Angular element for rendering HTML.\nIt is never displayed directly.\nIn fact, before rendering the view, Angular _replaces_ the `<ng-template>` and its contents with a comment.\n-->\n<p><code>&#x3C;ng-template></code>은 Angular가 HTML을 렌더링할 때 사용하는 엘리먼트이며, 화면에 직접 노출되지는 않습니다.\n그리고 <code>&#x3C;ng-template></code> 안에 있는 내용은 Angular가 뷰를 렌더링하기 전에 주석으로 변경됩니다.</p>\n<!--\nIf there is no structural directive and you merely wrap some elements in a `<ng-template>`,\nthose elements disappear.\nThat's the fate of the middle \"Hip!\" in the phrase \"Hip! Hip! Hooray!\".\n-->\n<p>구조 디렉티브를 하나도 사용하지 않고 엘리먼트를 <code>&#x3C;ng-template></code>으로 감싸기만 하면, 이 엘리먼트는 화면에 표시되지 않습니다.\n그래서 다음 \"Hip! Hip! Hooray!\" 문단들 중 두 번째 문단인 \"Hip!\"은 표시되지 않습니다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (template-tag)\" region=\"template-tag\">\n&#x3C;p>Hip!&#x3C;/p>\n&#x3C;ng-template>\n  &#x3C;p>Hip!&#x3C;/p>\n&#x3C;/ng-template>\n&#x3C;p>Hooray!&#x3C;/p>\n\n</code-example>\n<!--\nAngular erases the middle \"Hip!\", leaving the cheer a bit less enthusiastic.\n-->\n<p>Angular는 두 번째 문단을 제거하면서 개발자가 보기에는 의미없어 보이는 주석을 남깁니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/structural-directives/template-rendering.png\" alt=\"template tag rendering\" width=\"520\" height=\"94\">\n</div>\n<!--\nA structural directive puts a `<ng-template>` to work\nas you'll see when you [write your own structural directive](guide/structural-directives#unless).\n-->\n<p><code>&#x3C;ng-template></code>는 구조 디렉티브가 적용될 때에만 그 용도에 맞게 동작하며, <a href=\"guide/structural-directives#unless\">커스텀 구조 디렉티브를 구현</a>할 때도 활용됩니다.</p>\n<a id=\"ngcontainer\"></a>\n<a id=\"ng-container\"></a>\n<!--\n## Group sibling elements with &lt;ng-container&gt;\n-->\n<h2 id=\"비슷한-엘리먼트-묶기--ng-container\">비슷한 엘리먼트 묶기 : &#x3C;ng-container><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#비슷한-엘리먼트-묶기--ng-container\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThere's often a _root_ element that can and should host the structural directive.\nThe list element (`<li>`) is a typical host element of an `NgFor` repeater.\n-->\n<p>구조 디렉티브의 호스트 엘리먼트는 보통 엘리먼트 하나입니다.\n예를 들어 리스트 엘리먼트(<code>&#x3C;li></code>)에 <code>NgFor</code>를 사용한다면 다음과 같이 구현할 수 있습니다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (ngfor-li)\" region=\"ngfor-li\">\n&#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">{{hero.name}}&#x3C;/li>\n\n</code-example>\n<!--\nWhen there isn't a host element, you can usually wrap the content in a native HTML container element,\nsuch as a `<div>`, and attach the directive to that wrapper.\n-->\n<p>하지만 호스트 엘리먼트가 하나가 아닌 경우가 있습니다.\n이런 경우라면 네이티브 HTML인 <code>&#x3C;div></code>로 엘리먼트를 감싸고 이 <code>&#x3C;div></code>에 디렉티브를 적용해도 됩니다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (ngif)\" region=\"ngif\">\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero\" class=\"name\">{{hero.name}}&#x3C;/div>\n\n</code-example>\n<!--\nIntroducing another container element&mdash;typically a `<span>` or `<div>`&mdash;to\ngroup the elements under a single _root_ is usually harmless.\n_Usually_ ... but not _always_.\n-->\n<p>호스트 엘리먼트 하나 밑에 <code>&#x3C;span></code>이나 <code>&#x3C;div></code> 엘리먼트를 사용하는 것은 일반적으로 문제가 없습니다.\n<em>보통은</em> 그렇죠. 하지만 <em>항상</em> 그런 것은 아닙니다.</p>\n<!--\nThe grouping element may break the template appearance because CSS styles\nneither expect nor accommodate the new layout.\nFor example, suppose you have the following paragraph layout.\n-->\n<p>엘리먼트를 묶으면 이 엘리먼트가 템플릿의 어떤 자리에 위치하는지에 따라서 CSS 스타일이 잘못 지정되거나 레이아웃 자체가 틀어질 수 있습니다.\n예를 들어 다음과 같은 문단이 있다고 합시다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (ngif-span)\" region=\"ngif-span\">\n&#x3C;p>\n  I turned the corner\n  &#x3C;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero\">\n    and saw {{hero.name}}. I waved\n  &#x3C;/span>\n  and continued on my way.\n&#x3C;/p>\n\n</code-example>\n<!--\nYou also have a CSS style rule that happens to apply to a `<span>` within a `<p>`aragraph.\n-->\n<p>그리고 전역 CSS 스타일에는 <code>&#x3C;p></code> 안에 있는 <code>&#x3C;span></code>에 다음과 같은 스타일을 지정하고 있다고 합시다.</p>\n<code-example path=\"structural-directives/src/app/app.component.css\" header=\"src/app/app.component.css (p-span)\" region=\"p-span\">\np span { color: red; font-size: 70%; }\n\n</code-example>\n<!--\nThe constructed paragraph renders strangely.\n-->\n<p>그러면 다음과 같은 결과물이 표시되지만, 약간 이상합니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/structural-directives/bad-paragraph.png\" alt=\"spanned paragraph with bad style\" width=\"452\" height=\"15\">\n</div>\n<!--\nThe `p span` style, intended for use elsewhere, was inadvertently applied here.\n-->\n<p><code>p span</code> 스타일은 전역에 사용하려고 선언했지만, 이곳에는 적용되지 않는 것이 더 나은 것 같습니다.</p>\n<!--\nAnother problem: some HTML elements require all immediate children to be of a specific type.\nFor example, the `<select>` element requires `<option>` children.\nYou can't wrap the _options_ in a conditional `<div>` or a `<span>`.\n-->\n<p>그리고 또 다른 문제도 있습니다. 일부 엘리먼트는 바로 밑 자식 엘리먼트에 특정한 형태를 요구하는 경우도 있습니다.\n예를 들면 <code>&#x3C;select></code> 엘리먼트 안에 <code>&#x3C;option></code> 엘리먼트를 구성해야 하는 경우가 그렇습니다.\n<code>&#x3C;div></code>나 <code>&#x3C;span></code> 엘리먼트에는 <code>&#x3C;option></code> 엘리먼트를 사용하는 것이 적합하지 않습니다.</p>\n<!--\nWhen you try this,\n-->\n<p>다음 코드를 봅시다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (select-span)\" region=\"select-span\">\n&#x3C;div>\n  Pick your favorite hero\n  (&#x3C;label>&#x3C;input type=\"checkbox\" checked (change)=\"showSad = !showSad\">show sad&#x3C;/label>)\n&#x3C;/div>\n&#x3C;select [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero\">\n  &#x3C;span *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let h of heroes\">\n    &#x3C;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"showSad || h.emotion !== 'sad'\">\n      &#x3C;option [ngValue]=\"h\">{{h.name}} ({{h.emotion}})&#x3C;/option>\n    &#x3C;/span>\n  &#x3C;/span>\n&#x3C;/select>\n\n</code-example>\n<!--\nthe drop down is empty.\n-->\n<p>이 코드를 실행해보면 드롭다운의 내용이 비어있는 것을 확인할 수 있습니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/structural-directives/bad-select.png\" alt=\"spanned options don&#x27;t work\" width=\"290\" height=\"36\">\n</div>\n<!--\nThe browser won't display an `<option>` within a `<span>`.\n-->\n<p>브라우저는 <code>&#x3C;span></code> 안에 있는 <code>&#x3C;option></code>을 처리하지 않습니다.</p>\n<!--\n### &lt;ng-container&gt; to the rescue\n-->\n<h3 id=\"해결방법--ng-container\">해결방법 : &#x3C;ng-container><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#해결방법--ng-container\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe Angular `<ng-container>` is a grouping element that doesn't interfere with styles or layout\nbecause Angular _doesn't put it in the DOM_.\n-->\n<p>Angular가 제공하는 <code>&#x3C;ng-container></code>를 사용하면 스타일이나 레이아웃을 그대로 유지하면서 여러 엘리먼트를 한 그룹으로 묶을 수 있습니다. 왜냐하면 Angular는 이 엘리먼트를 <em>DOM에 직접 추가하지 않기 때문</em> 입니다.</p>\n<!--\nHere's the conditional paragraph again, this time using `<ng-container>`.\n-->\n<p><code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>를 사용하는 <code>&#x3C;p></code> 엘리먼트를 생각해 봅시다. 이 엘리먼트는 <code>&#x3C;ng-container></code>를 사용합니다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (ngif-ngcontainer)\" region=\"ngif-ngcontainer\">\n&#x3C;p>\n  I turned the corner\n  &#x3C;ng-container *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero\">\n    and saw {{hero.name}}. I waved\n  &#x3C;/ng-container>\n  and continued on my way.\n&#x3C;/p>\n\n</code-example>\n<!--\nIt renders properly.\n-->\n<p>이 코드는 제대로 렌더링 됩니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/structural-directives/good-paragraph.png\" alt=\"ngcontainer paragraph with proper style\" width=\"509\" height=\"15\">\n</div>\n<!--\nNow conditionally exclude a _select_ `<option>` with `<ng-container>`.\n-->\n<p>그리고 이번에는 <code>&#x3C;select></code>태그 안에 있는 <code>&#x3C;option></code> 엘리먼트를 배열에 따라 반복하고 표시 조건도 지정하는 용도로 <code>&#x3C;ng-container></code>를 사용해 봅시다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (select-ngcontainer)\" region=\"select-ngcontainer\">\n&#x3C;div>\n  Pick your favorite hero\n  (&#x3C;label>&#x3C;input type=\"checkbox\" checked (change)=\"showSad = !showSad\">show sad&#x3C;/label>)\n&#x3C;/div>\n&#x3C;select [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero\">\n  &#x3C;ng-container *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let h of heroes\">\n    &#x3C;ng-container *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"showSad || h.emotion !== 'sad'\">\n      &#x3C;option [ngValue]=\"h\">{{h.name}} ({{h.emotion}})&#x3C;/option>\n    &#x3C;/ng-container>\n  &#x3C;/ng-container>\n&#x3C;/select>\n\n</code-example>\n<!--\nThe drop down works properly.\n-->\n<p>그러면 드롭다운도 제대로 동작합니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/structural-directives/select-ngcontainer-anim.gif\" alt=\"ngcontainer options work properly\" width=\"312\" height=\"100\">\n</div>\n<div class=\"alert is-helpful\">\n<p><strong>Note:</strong> Remember that ngModel directive is defined as a part of Angular FormsModule and you need to include FormsModule in the imports: [...] section of the Angular module metadata, in which you want to use it.</p>\n</div>\n<!--\nThe `<ng-container>` is a syntax element recognized by the Angular parser.\nIt's not a directive, component, class, or interface.\nIt's more like the curly braces in a JavaScript `if`-block:\n-->\n<p><code>&#x3C;ng-container></code>는 Angular 파서용 엘리먼트입니다.\n이 엘리먼트 자체는 디렉티브나 컴포넌트, 클래스, 인터페이스 중 어느 것에도 해당되지 않으며, 오히려 JavaScript의 <code>if</code> 문법에 사용하는 중괄호(<code>{</code>, <code>}</code>)와 비슷하다고 볼 수 있습니다.</p>\n<code-example language=\"javascript\">\n  if (someCondition) {\n    statement1;\n    statement2;\n    statement3;\n  }\n\n</code-example>\n<!--\nWithout those braces, JavaScript would only execute the first statement\nwhen you intend to conditionally execute all of them as a single block.\nThe `<ng-container>` satisfies a similar need in Angular templates.\n-->\n<p>중괄호가 없으면 JavaScript는 실행문 3개 중에 첫번째 하나만 실행합니다.\n의도한 대로 실행문 3개를 한 번에 실행하려면 실행문 전체를 중괄호로 묶어야 합니다.\nAngular 템플릿에서는 <code>&#x3C;ng-container></code>가 이런 역할을 합니다.</p>\n<a id=\"unless\"></a>\n<!--\n## Write a structural directive\n-->\n<h2 id=\"커스텀-구조-디렉티브-작성하기\">커스텀 구조 디렉티브 작성하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#커스텀-구조-디렉티브-작성하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nIn this section, you write an `UnlessDirective` structural directive\nthat does the opposite of `NgIf`.\n`NgIf` displays the template content when the condition is `true`.\n`UnlessDirective` displays the content when the condition is ***false***.\n-->\n<p>이번에는 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>의 반대 기능을 하는 <code>UnlessDirective</code>를 만들어 봅니다.\n<code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>가 조건이 <code>true</code>일 때 템플릿 내용을 화면에 표시한다면, <code>UnlessDirective</code>는 조건이 <strong><em>false</em></strong>일 때 템플릿 내용을 화면에 표시할 것입니다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (appUnless-1)\" region=\"appUnless-1\">\n&#x3C;p *appUnless=\"condition\">Show this sentence unless the condition is true.&#x3C;/p>\n\n</code-example>\n<!--\nCreating a directive is similar to creating a component.\n\n* Import the `Directive` decorator (instead of the `Component` decorator).\n\n* Import the `Input`, `TemplateRef`, and `ViewContainerRef` symbols; you'll need them for _any_ structural directive.\n\n* Apply the decorator to the directive class.\n\n* Set the CSS *attribute selector* that identifies the directive when applied to an element in a template.\n\nHere's how you might begin:\n-->\n<p>디렉티브를 작성하는 방법은 컴포넌트를 작성하는 것과 비슷합니다.</p>\n<ul>\n<li>\n<p><code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 데코레이터를 불러오는 것처럼 <code><a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code> 데코레이터를 로ㄷ합니다.</p>\n</li>\n<li>\n<p><code><a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code>, <code><a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a></code>, <code><a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a></code> 심볼을 로드합니다. 구조 디렉티브가 DOM을 조작하려면 이 심볼들이 필요합니다.</p>\n</li>\n<li>\n<p>데코레이터를 디렉티브 클래스에 적용합니다.</p>\n</li>\n<li>\n<p>템플릿 엘리먼트에 적용할 때 사용하는 CSS <em>어트리뷰트 셀렉터</em>를 지정합니다.</p>\n</li>\n</ul>\n<p>이렇게 작성하면 다음과 비슷한 코드가 될 것입니다:</p>\n<code-example path=\"structural-directives/src/app/unless.directive.ts\" header=\"src/app/unless.directive.ts (skeleton)\" region=\"skeleton\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a>, <a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a> } from '@angular/core';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({ selector: '[appUnless]'})\nexport class UnlessDirective {\n}\n\n\n</code-example>\n<!--\nThe directive's _selector_ is typically the directive's **attribute name** in square brackets, `[appUnless]`.\nThe brackets define a CSS\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors\" title=\"MDN: Attribute selectors\">attribute selector</a>.\n-->\n<p>디렉티브의 <em>셀렉터</em> 는 일반적으로 디렉티브의 <strong>어트리뷰트 이름</strong>을 대괄호로 감싼 형태가 되기 때문에 이 예제에서는 <code>[appUnless]</code>를 지정했습니다.\n대괄호는 CSS <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors\" title=\"MDN: Attribute selectors\">어트리뷰트 셀렉터</a>를 의미합니다.</p>\n<!--\nThe directive _attribute name_ should be spelled in _lowerCamelCase_ and begin with a prefix.\nDon't use `ng`. That prefix belongs to Angular.\nPick something short that fits you or your company.\nIn this example, the prefix is `app`.\n-->\n<p>디렉티브의 <em>어트리뷰트 이름</em> 은 애플리케이션에서 정의한 접두사로 시작하며 <em>소문자 캐멀 케이스</em> 로 지정합니다.\n이 때 <code>ng</code>는 Angular가 내부적으로 사용하고 있기 때문에 접두사로 사용하면 안됩니다.\n개발 환경이나 회사에 적합한 접두사를 사용하세요.\n이 예제에서는 <code>app</code>을 접두사로 사용했습니다.</p>\n<!--\nThe directive _class_ name ends in `Directive` per the [style guide](guide/styleguide#02-03 \"Angular Style Guide\").\nAngular's own directives do not.\n-->\n<p>그리고 <a href=\"guide/styleguide#02-03\" title=\"Angular Style Guide\">코딩 가이드</a>에 따라 디렉티브 <em>클래스</em> 이름은 <code><a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code>로 끝나도록 정의했습니다.\n참고로 Angular 기본 디렉티브는 <code><a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code>로 끝나지 않습니다.</p>\n<!--\n### _TemplateRef_ and _ViewContainerRef_\n-->\n<h3 id=\"templateref-와-viewcontainerref\"><em>TemplateRef</em> 와 <em>ViewContainerRef</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#templateref-와-viewcontainerref\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nA simple structural directive like this one creates an\n[_embedded view_](api/core/EmbeddedViewRef \"API: EmbeddedViewRef\")\nfrom the Angular-generated `<ng-template>` and inserts that view in a\n[_view container_](api/core/ViewContainerRef \"API: ViewContainerRef\")\nadjacent to the directive's original `<p>` host element.\n-->\n<p>구조 디렉티브는 <code>&#x3C;ng-template></code>을 사용하는 <a href=\"api/core/EmbeddedViewRef\" title=\"API: EmbeddedViewRef\"><em>내장 뷰</em></a>를 생성하고, 이 뷰를 <a href=\"api/core/ViewContainerRef\" title=\"API: ViewContainerRef\"><em>뷰 컨테이너</em></a> 로 감싼 후에 호스트 엘리먼트인 <code>&#x3C;p></code> 옆에 추가합니다.</p>\n<!--\nYou'll acquire the `<ng-template>` contents with a\n[`TemplateRef`](api/core/TemplateRef \"API: TemplateRef\")\nand access the _view container_ through a\n[`ViewContainerRef`](api/core/ViewContainerRef \"API: ViewContainerRef\").\n-->\n<p>그러면 <code>&#x3C;ng-template></code>의 내용은 <a href=\"api/core/TemplateRef\" title=\"API: TemplateRef\"><code>TemplateRef</code></a>로 참조할 수 있고, <em>뷰 컨테이너</em> 는 <a href=\"api/core/ViewContainerRef\" title=\"API: ViewContainerRef\"><code>ViewContainerRef</code></a>로 참조할 수 있습니다.</p>\n<!--\nYou inject both in the directive constructor as private variables of the class.\n-->\n<p>두 객체를 클래스에서 참조할 수 있도록 디렉티브 생성자에 두 심볼을 의존성으로 주입합니다.</p>\n<code-example path=\"structural-directives/src/app/unless.directive.ts\" header=\"src/app/unless.directive.ts (ctor)\" region=\"ctor\">\nconstructor(\n  private templateRef: <a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a>&#x3C;any>,\n  private viewContainer: <a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a>) { }\n\n</code-example>\n<!--\n### The _appUnless_ property\n-->\n<h3 id=\"appunless-프로퍼티\"><em>appUnless</em> 프로퍼티<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#appunless-프로퍼티\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe directive consumer expects to bind a true/false condition to `[appUnless]`.\nThat means the directive needs an `appUnless` property, decorated with `@Input`\n-->\n<p>이 디렉티브는 <code>[appUnless]</code>로 true/false 조건을 받습니다.\n이 말은, 디렉티브에 <code>appUnless</code> 프로퍼티가 있어야 하며, 이 프로퍼티는 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code>로 지정되어야 한다는 것을 의미합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nRead about `@Input` in the [_Template Syntax_](guide/template-syntax#inputs-outputs) guide.\n-->\n<p><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 데코레이터에 대한 내용은 <a href=\"guide/template-syntax#inputs-outputs\"><em>템플릿 문법</em></a> 문서를 참고하세요.</p>\n</div>\n<code-example path=\"structural-directives/src/app/unless.directive.ts\" header=\"src/app/unless.directive.ts (set)\" region=\"set\">\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() set appUnless(condition: boolean) {\n  if (!condition &#x26;&#x26; !this.hasView) {\n    this.viewContainer.createEmbeddedView(this.templateRef);\n    this.hasView = true;\n  } else if (condition &#x26;&#x26; this.hasView) {\n    this.viewContainer.clear();\n    this.hasView = false;\n  }\n}\n\n</code-example>\n<!--\nAngular sets the `appUnless` property whenever the value of the condition changes.\nBecause the `appUnless` property does work, it needs a setter.\n\n* If the condition is falsy and the view hasn't been created previously,\ntell the _view container_ to create the _embedded view_ from the template.\n\n* If the condition is truthy and the view is currently displayed,\nclear the container which also destroys the view.\n\nNobody reads the `appUnless` property so it doesn't need a getter.\n\nThe completed directive code looks like this:\n-->\n<p><code>appUnless</code> 프로퍼티의 값은 이 프로퍼티에 바인딩 된 값이 바뀔때마다 Angular가 새로 할당합니다.\n그래서 이 프로퍼티 값에 반응하려면 세터(setter)가 필요합니다.</p>\n<ul>\n<li>\n<p>거짓으로 평가되는 값이 전달되고 내장 뷰가 아직 생성되지 않았으면, <em>뷰 컨테이너</em> 를 사용해서 <em>내장 뷰</em> 를 생성합니다.</p>\n</li>\n<li>\n<p>참으로 평가되는 값이 전달되고 뷰가 화면에 표시되고 있으면, 컨테이너의 내용을 비우고 뷰에서 제거합니다.</p>\n</li>\n</ul>\n<p><code>appUnless</code> 프로퍼티를 참조하는 것은 아무것도 없기 때문에 게터(getter)는 따로 정의하지 않습니다.</p>\n<p>그러면 다음과 같은 코드가 됩니다:</p>\n<code-example path=\"structural-directives/src/app/unless.directive.ts\" header=\"src/app/unless.directive.ts (excerpt)\" region=\"no-docs\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a>, <a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a> } from '@angular/core';\n\n/**\n * 평가 조건이 true가 아니라면 DOM에 템플릿을 추가합니다.\n */\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({ selector: '[appUnless]'})\nexport class UnlessDirective {\n  private hasView = false;\n\n  constructor(\n    private templateRef: <a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a>&#x3C;any>,\n    private viewContainer: <a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a>) { }\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() set appUnless(condition: boolean) {\n    if (!condition &#x26;&#x26; !this.hasView) {\n      this.viewContainer.createEmbeddedView(this.templateRef);\n      this.hasView = true;\n    } else if (condition &#x26;&#x26; this.hasView) {\n      this.viewContainer.clear();\n      this.hasView = false;\n    }\n  }\n}\n\n\n</code-example>\n<!--\nAdd this directive to the `declarations` array of the AppModule.\n\nThen create some HTML to try it.\n-->\n<p>이제 이 디렉티브를 AppModule의 <code>declarations</code> 배열에 추가합니다.</p>\n<p>그러고 HTML에 이 디렉티브를 적용해 봅니다.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (appUnless)\" region=\"appUnless\">\n&#x3C;p *appUnless=\"condition\" class=\"unless a\">\n  (A) This paragraph is displayed because the condition is false.\n&#x3C;/p>\n\n&#x3C;p *appUnless=\"!condition\" class=\"unless b\">\n  (B) Although the condition is true,\n  this paragraph is displayed because appUnless is set to false.\n&#x3C;/p>\n\n</code-example>\n<!--\nWhen the `condition` is falsy, the top (A) paragraph appears and the bottom (B) paragraph disappears.\nWhen the `condition` is truthy, the top (A) paragraph is removed and the bottom (B) paragraph appears.\n-->\n<p><code>condition</code> 값이 거짓으로 평가되면 (A) 문단이 화면에 표시되고 (B) 문단은 화면에 표시되지 않습니다.\n그리고 <code>condition</code> 값이 참으로 평가되면 (A) 문단이 화면에 표시되지 않고 (B) 문단이 화면에 표시됩니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/structural-directives/unless-anim.gif\" alt=\"UnlessDirective in action\" width=\"524\" height=\"100\">\n</div>\n<!--\n<a id=\"summary\"></a>\n-->\n<a id=\"정리\"></a>\n<!--\n## Summary\n-->\n<h2 id=\"정리\">정리<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#정리\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nYou can both try and download the source code for this guide in the <live-example></live-example>.\n-->\n<p>이 문서에서 설명하는 예제는 <live-example></live-example>에서 직접 확인하거나 다운받을 수 있습니다.</p>\n<!--\nHere is the source from the `src/app/` folder.\n-->\n<p>그리고 소스 코드 <code>src/app/</code> 폴더의 내용은 다음과 같습니다.</p>\n<code-tabs>\n\n  <code-pane header=\"app.component.ts\" path=\"structural-directives/src/app/app.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\nimport { Hero, heroes } from './hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  <a href=\"api/core/Component#templateUrl\" class=\"code-anchor\">templateUrl</a>: './app.component.html',\n  <a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a>: [ './app.component.css' ]\n})\nexport class AppComponent {\n  heroes = heroes;\n  hero = this.heroes[0];\n\n  condition = false;\n  logs: string[] = [];\n  showSad = true;\n  status = 'ready';\n\n  <a href=\"api/core/IterableChangeRecord#trackById\" class=\"code-anchor\">trackById</a>(index: number, hero: Hero): number { return hero.id; }\n}\n\n\n</code-pane>\n\n  <code-pane header=\"app.component.html\" path=\"structural-directives/src/app/app.component.html\">\n&#x3C;h1>Structural Directives&#x3C;/h1>\n\n&#x3C;p>Conditional display of hero&#x3C;/p>\n\n&#x3C;blockquote>\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero\" class=\"name\">{{hero.name}}&#x3C;/div>\n&#x3C;/blockquote>\n\n&#x3C;p><a href=\"api/common/NumberSymbol#List\" class=\"code-anchor\">List</a> of heroes&#x3C;/p>\n\n&#x3C;ul>\n  &#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">{{hero.name}}&#x3C;/li>\n&#x3C;/ul>\n\n\n&#x3C;hr>\n\n&#x3C;h2 id=\"<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>\"><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a>&#x3C;/h2>\n\n&#x3C;p *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"true\">\n  Expression is true and <a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a> is true.\n  This paragraph is in the DOM.\n&#x3C;/p>\n&#x3C;p *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"false\">\n  Expression is false and <a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a> is false.\n  This paragraph is not in the DOM.\n&#x3C;/p>\n\n&#x3C;p [style.display]=\"'block'\">\n  Expression sets display to \"block\".\n  This paragraph is visible.\n&#x3C;/p>\n&#x3C;p [style.display]=\"'none'\">\n  Expression sets display to \"none\".\n  This paragraph is hidden but still in the DOM.\n&#x3C;/p>\n\n&#x3C;h4><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a> with template&#x3C;/h4>\n&#x3C;p>&#x26;lt;ng-template&#x26;gt; element&#x3C;/p>\n&#x3C;ng-template [<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>]=\"hero\">\n  &#x3C;div class=\"name\">{{hero.name}}&#x3C;/div>\n&#x3C;/ng-template>\n\n&#x3C;hr>\n\n&#x3C;h2 id=\"ng-container\">&#x26;lt;ng-container&#x26;gt;&#x3C;/h2>\n\n&#x3C;h4>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a> with a &#x26;lt;ng-container&#x26;gt;&#x3C;/h4>\n\n&#x3C;button (click)=\"hero = hero ? null : heroes[0]\">Toggle hero&#x3C;/button>\n\n&#x3C;p>\n  I turned the corner\n  &#x3C;ng-container *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero\">\n    and saw {{hero.name}}. I waved\n  &#x3C;/ng-container>\n  and continued on my way.\n&#x3C;/p>\n&#x3C;p>\n  I turned the corner\n  &#x3C;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero\">\n    and saw {{hero.name}}. I waved\n  &#x3C;/span>\n  and continued on my way.\n&#x3C;/p>\n\n&#x3C;p>&#x3C;i>&#x26;lt;select&#x26;gt; with &#x26;lt;span&#x26;gt;&#x3C;/i>&#x3C;/p>\n&#x3C;div>\n  Pick your favorite hero\n  (&#x3C;label>&#x3C;input type=\"checkbox\" checked (change)=\"showSad = !showSad\">show sad&#x3C;/label>)\n&#x3C;/div>\n&#x3C;select [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero\">\n  &#x3C;span *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let h of heroes\">\n    &#x3C;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"showSad || h.emotion !== 'sad'\">\n      &#x3C;option [ngValue]=\"h\">{{h.name}} ({{h.emotion}})&#x3C;/option>\n    &#x3C;/span>\n  &#x3C;/span>\n&#x3C;/select>\n\n&#x3C;p>&#x3C;i>&#x26;lt;select&#x26;gt; with &#x26;lt;ng-container&#x26;gt;&#x3C;/i>&#x3C;/p>\n&#x3C;div>\n  Pick your favorite hero\n  (&#x3C;label>&#x3C;input type=\"checkbox\" checked (change)=\"showSad = !showSad\">show sad&#x3C;/label>)\n&#x3C;/div>\n&#x3C;select [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero\">\n  &#x3C;ng-container *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let h of heroes\">\n    &#x3C;ng-container *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"showSad || h.emotion !== 'sad'\">\n      &#x3C;option [ngValue]=\"h\">{{h.name}} ({{h.emotion}})&#x3C;/option>\n    &#x3C;/ng-container>\n  &#x3C;/ng-container>\n&#x3C;/select>\n&#x3C;br>&#x3C;br>\n\n&#x3C;hr>\n\n&#x3C;h2 id=\"<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>\">NgFor&#x3C;/h2>\n\n&#x3C;div class=\"box\">\n\n&#x3C;p class=\"code\">&#x26;lt;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes; let i=index; let <a href=\"api/common/NgForOfContext#odd\" class=\"code-anchor\">odd</a>=<a href=\"api/common/NgForOfContext#odd\" class=\"code-anchor\">odd</a>; trackBy: <a href=\"api/core/IterableChangeRecord#trackById\" class=\"code-anchor\">trackById</a>\" [class.odd]=\"<a href=\"api/common/NgForOfContext#odd\" class=\"code-anchor\">odd</a>\"&#x26;gt;&#x3C;/p>\n&#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes; let i=index; let <a href=\"api/common/NgForOfContext#odd\" class=\"code-anchor\">odd</a>=<a href=\"api/common/NgForOfContext#odd\" class=\"code-anchor\">odd</a>; trackBy: <a href=\"api/core/IterableChangeRecord#trackById\" class=\"code-anchor\">trackById</a>\" [class.odd]=\"<a href=\"api/common/NgForOfContext#odd\" class=\"code-anchor\">odd</a>\">\n  ({{i}}) {{hero.name}}\n&#x3C;/div>\n\n&#x3C;p class=\"code\">&#x26;lt;ng-template <a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a> let-hero [<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngForOf</a>]=\"heroes\" let-i=\"index\" let-odd=\"<a href=\"api/common/NgForOfContext#odd\" class=\"code-anchor\">odd</a>\" [<a href=\"api/common/NgForOf#ngForTrackBy\" class=\"code-anchor\">ngForTrackBy</a>]=\"<a href=\"api/core/IterableChangeRecord#trackById\" class=\"code-anchor\">trackById</a>\"/&#x26;gt;&#x3C;/p>\n&#x3C;ng-template <a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a> let-hero [<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngForOf</a>]=\"heroes\" let-i=\"index\" let-odd=\"<a href=\"api/common/NgForOfContext#odd\" class=\"code-anchor\">odd</a>\" [<a href=\"api/common/NgForOf#ngForTrackBy\" class=\"code-anchor\">ngForTrackBy</a>]=\"<a href=\"api/core/IterableChangeRecord#trackById\" class=\"code-anchor\">trackById</a>\">\n  &#x3C;div [class.odd]=\"<a href=\"api/common/NgForOfContext#odd\" class=\"code-anchor\">odd</a>\">({{i}}) {{hero.name}}&#x3C;/div>\n&#x3C;/ng-template>\n\n&#x3C;/div>\n&#x3C;hr>\n\n&#x3C;h2 id=\"<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a>\"><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a>&#x3C;/h2>\n\n&#x3C;div>Pick your favorite hero&#x3C;/div>\n&#x3C;p>\n  &#x3C;label *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let h of heroes\">\n    &#x3C;input type=\"radio\" name=\"heroes\" [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero\" [value]=\"h\">{{h.name}}\n  &#x3C;/label>\n  &#x3C;label>&#x3C;input type=\"radio\" name=\"heroes\" (click)=\"hero = null\">None of the above&#x3C;/label>\n&#x3C;/p>\n\n&#x3C;h4><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a>&#x3C;/h4>\n\n&#x3C;div [<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a>]=\"hero?.emotion\">\n  &#x3C;app-happy-hero    *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'happy'\"    [hero]=\"hero\">&#x3C;/app-happy-hero>\n  &#x3C;app-sad-hero      *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'sad'\"      [hero]=\"hero\">&#x3C;/app-sad-hero>\n  &#x3C;app-confused-hero *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'confused'\" [hero]=\"hero\">&#x3C;/app-confused-hero>\n  &#x3C;app-unknown-hero  *<a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">ngSwitchDefault</a>           [hero]=\"hero\">&#x3C;/app-unknown-hero>\n&#x3C;/div>\n\n&#x3C;h4><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a> with &#x26;lt;ng-template&#x26;gt;&#x3C;/h4>\n&#x3C;div [<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a>]=\"hero?.emotion\">\n  &#x3C;ng-template [<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>]=\"'happy'\">\n    &#x3C;app-happy-hero [hero]=\"hero\">&#x3C;/app-happy-hero>\n  &#x3C;/ng-template>\n  &#x3C;ng-template [<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>]=\"'sad'\">\n    &#x3C;app-sad-hero [hero]=\"hero\">&#x3C;/app-sad-hero>\n  &#x3C;/ng-template>\n  &#x3C;ng-template [<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>]=\"'confused'\">\n    &#x3C;app-confused-hero [hero]=\"hero\">&#x3C;/app-confused-hero>\n  &#x3C;/ng-template >\n  &#x3C;ng-template <a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">ngSwitchDefault</a>>\n    &#x3C;app-unknown-hero [hero]=\"hero\">&#x3C;/app-unknown-hero>\n  &#x3C;/ng-template>\n&#x3C;/div>\n\n&#x3C;hr>\n\n&#x3C;h2>&#x26;lt;ng-template&#x26;gt;&#x3C;/h2>\n&#x3C;p>Hip!&#x3C;/p>\n&#x3C;ng-template>\n  &#x3C;p>Hip!&#x3C;/p>\n&#x3C;/ng-template>\n&#x3C;p>Hooray!&#x3C;/p>\n\n&#x3C;hr>\n\n&#x3C;h2 id=\"appUnless\">UnlessDirective&#x3C;/h2>\n&#x3C;p>\n  The condition is currently\n  &#x3C;span [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"{ 'a': !condition, 'b': condition, 'unless': true }\">{{condition}}&#x3C;/span>.\n  &#x3C;button\n    (click)=\"condition = !condition\"\n    [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>] = \"{ 'a': condition, 'b': !condition }\" >\n    Toggle condition to {{condition ? 'false' : 'true'}}\n  &#x3C;/button>\n&#x3C;/p>\n&#x3C;p *appUnless=\"condition\" class=\"unless a\">\n  (A) This paragraph is displayed because the condition is false.\n&#x3C;/p>\n\n&#x3C;p *appUnless=\"!condition\" class=\"unless b\">\n  (B) Although the condition is true,\n  this paragraph is displayed because appUnless is set to false.\n&#x3C;/p>\n\n\n&#x3C;h4>UnlessDirective with template&#x3C;/h4>\n\n&#x3C;p *appUnless=\"condition\">Show this sentence unless the condition is true.&#x3C;/p>\n\n&#x3C;p *appUnless=\"condition\" class=\"code unless\">\n  (A) &#x26;lt;p *appUnless=\"condition\" class=\"code unless\"&#x26;gt;\n&#x3C;/p>\n\n&#x3C;ng-template [appUnless]=\"condition\">\n  &#x3C;p class=\"code unless\">\n    (A) &#x26;lt;ng-template [appUnless]=\"condition\"&#x26;gt;\n  &#x3C;/p>\n&#x3C;/ng-template>\n\n\n\n</code-pane>\n\n  <code-pane header=\"app.component.css\" path=\"structural-directives/src/app/app.component.css\">\nbutton {\n  min-width: 100px;\n  font-size: 100%;\n}\n\n.box {\n  border: 1px solid gray;\n  max-width: 600px;\n  padding: 4px;\n}\n.choices {\n  font-style: italic;\n}\n\ncode, .code {\n  background-color: #eee;\n  color: black;\n  font-family: Courier, sans-serif;\n  font-size: 85%;\n}\n\ndiv.code {\n  width: 400px;\n}\n\n.heroic {\n  font-size: 150%;\n  font-weight: bold;\n}\n\nhr {\n  margin: 40px 0\n}\n\n.odd {\n  background-color:  palegoldenrod;\n}\n\ntd, th {\n  text-align: left;\n  vertical-align: top;\n}\n\np span { color: red; font-size: 70%; }\n\n.unless {\n  border: 2px solid;\n  padding: 6px;\n}\n\np.unless {\n  width: 500px;\n}\n\nbutton.a, span.a, .unless.a {\n  color: red;\n  border-color: gold;\n  background-color: yellow;\n  font-size: 100%;\n}\n\nbutton.b, span.b, .unless.b {\n  color: black;\n  border-color: green;\n  background-color: lightgreen;\n  font-size: 100%;\n}\n\n\n</code-pane>\n\n  <code-pane header=\"app.module.ts\" path=\"structural-directives/src/app/app.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }      from '@angular/core';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> }   from '@angular/forms';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\n\nimport { AppComponent }         from './app.component';\nimport { heroSwitchComponents } from './hero-switch.components';\nimport { UnlessDirective }    from './unless.directive';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [ <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>, <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> ],\n  declarations: [\n    AppComponent,\n    heroSwitchComponents,\n    UnlessDirective\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n\n</code-pane>\n\n  <code-pane header=\"hero.ts\" path=\"structural-directives/src/app/hero.ts\">\nexport interface Hero {\n  id: number;\n  name: string;\n  emotion?: string;\n}\n\nexport const heroes: Hero[] = [\n  { id: 1, name: 'Dr Nice',  emotion: 'happy'},\n  { id: 2, name: 'Narco',     emotion: 'sad' },\n  { id: 3, name: 'Windstorm', emotion: 'confused' },\n  { id: 4, name: 'Magneta'}\n];\n\n\n</code-pane>\n\n  <code-pane header=\"hero-switch.components.ts\" path=\"structural-directives/src/app/hero-switch.components.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a> } from '@angular/core';\nimport { Hero } from './hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-happy-hero',\n  template: `Wow. You like {{hero.name}}. What a happy hero ... just like you.`\n})\nexport class HappyHeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-sad-hero',\n  template: `You like {{hero.name}}? Such a sad hero. Are you sad too?`\n})\nexport class SadHeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-confused-hero',\n  template: `Are you as confused as {{hero.name}}?`\n})\nexport class ConfusedHeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-unknown-hero',\n  template: `{{<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>}}`\n})\nexport class UnknownHeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n  get <a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>() {\n    return this.hero &#x26;&#x26; this.hero.name ?\n      `${this.hero.name} is strange and mysterious.` :\n      'Are you feeling indecisive?';\n  }\n}\n\nexport const heroSwitchComponents =\n  [ HappyHeroComponent, SadHeroComponent, ConfusedHeroComponent, UnknownHeroComponent ];\n\n\n</code-pane>\n\n  <code-pane header=\"unless.directive.ts\" path=\"structural-directives/src/app/unless.directive.ts\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a>, <a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a> } from '@angular/core';\n\n/**\n * 평가 조건이 true가 아니라면 DOM에 템플릿을 추가합니다.\n *\n * If the expression assigned to `appUnless` evaluates to a truthy value\n * then the templated elements are removed removed from the DOM,\n * the templated elements are (re)inserted into the DOM.\n *\n * &#x3C;div *appUnless=\"errorCount\" class=\"success\">\n *   Congrats! Everything is great!\n * &#x3C;/div>\n *\n * ### Syntax\n *\n * - `&#x3C;div *appUnless=\"condition\">...&#x3C;/div>`\n * - `&#x3C;ng-template [appUnless]=\"condition\">&#x3C;div>...&#x3C;/div>&#x3C;/ng-template>`\n *\n */\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({ selector: '[appUnless]'})\nexport class UnlessDirective {\n  private hasView = false;\n\n  constructor(\n    private templateRef: <a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a>&#x3C;any>,\n    private viewContainer: <a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a>) { }\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() set appUnless(condition: boolean) {\n    if (!condition &#x26;&#x26; !this.hasView) {\n      this.viewContainer.createEmbeddedView(this.templateRef);\n      this.hasView = true;\n    } else if (condition &#x26;&#x26; this.hasView) {\n      this.viewContainer.clear();\n      this.hasView = false;\n    }\n  }\n}\n\n\n</code-pane>\n\n</code-tabs>\n<!--\nYou learned\n-->\n<p>이 문서에서는 다음 내용에 대해 다뤘습니다.</p>\n<!--\n* that structural directives manipulate HTML layout.\n* to use [`<ng-container>`](guide/structural-directives#ngcontainer) as a grouping element when there is no suitable host element.\n* that the Angular desugars [asterisk (*) syntax](guide/structural-directives#asterisk) into a `<ng-template>`.\n* how that works for the `NgIf`, `NgFor` and `NgSwitch` built-in directives.\n* about the [_microsyntax_](guide/structural-directives#microsyntax) that expands into a [`<ng-template>`](guide/structural-directives#template).\n* to write a [custom structural directive](guide/structural-directives#unless), `UnlessDirective`.\n-->\n<ul>\n<li>구조 디렉티브는 HTML 레이아웃을 변경합니다.</li>\n<li>호스트 엘리먼트에 영향을 주지 않으면서 엘리먼트를 묶으려면 <a href=\"guide/structural-directives#ngcontainer\"><code>&#x3C;ng-container></code></a>를 사용하세요.</li>\n<li><a href=\"guide/structural-directives#asterisk\">별표(*)를 사용한</a> 문법을 Angular가 처리하고 나면 <code>&#x3C;ng-template></code>이 됩니다.</li>\n<li>기본 디렉티브인 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>, <code>NgFor</code>, <code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code>가 어떻게 동작하는지 살펴봤습니다.</li>\n<li><a href=\"guide/structural-directives#template\"><code>&#x3C;ng-template></code></a>을 활용하는 <a href=\"guide/structural-directives#microsyntax\">_세부 문법</a>에 대해 알아봤습니다.</li>\n<li><a href=\"guide/structural-directives#unless\">커스텀 구조 디렉티브</a> <code>UnlessDirective</code> 를 만들어 봤습니다.</li>\n</ul>\n\n</div>\n\n<!-- links to this doc:\n - api/common\n - api/common/CommonModule\n - api/common/NgForOf\n - api/common/NgIf\n - api/common/NgSwitch\n - guide/ajs-quick-reference\n - guide/architecture-components\n - guide/attribute-directives\n - guide/bootstrapping\n - guide/glossary\n - guide/template-syntax\n-->\n<!-- links from this doc:\n - api/common/NgClass\n - api/common/NgForOf\n - api/common/NgForOf#ngForTrackBy\n - api/common/NgForOfContext#odd\n - api/common/NgIf\n - api/common/NgSwitch\n - api/common/NgSwitchCase\n - api/common/NgSwitchDefault\n - api/common/NumberSymbol#List\n - api/common/http/HttpErrorResponse#message\n - api/core/Component\n - api/core/Component#styleUrls\n - api/core/Component#templateUrl\n - api/core/Directive\n - api/core/EmbeddedViewRef\n - api/core/Input\n - api/core/IterableChangeRecord#item\n - api/core/IterableChangeRecord#trackById\n - api/core/NgModule\n - api/core/TemplateRef\n - api/core/ViewContainerRef\n - api/forms/FormsModule\n - api/forms/NgModel\n - api/platform-browser/BrowserModule\n - guide/attribute-directives\n - guide/structural-directives#%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%9E%85%EB%A0%A5-%EB%B3%80%EC%88%98\n - guide/structural-directives#appunless-프로퍼티\n - guide/structural-directives#asterisk\n - guide/structural-directives#constraints\n - guide/structural-directives#grammar\n - guide/structural-directives#microsyntax\n - guide/structural-directives#microsyntax-examples\n - guide/structural-directives#ng-container\n - guide/structural-directives#ng-template\n - guide/structural-directives#ngFor\n - guide/structural-directives#ngSwitch\n - guide/structural-directives#ngcontainer\n - guide/structural-directives#ngfor-내부-동작\n - guide/structural-directives#ngif로-이해하기\n - guide/structural-directives#ngswitch-내부-동작\n - guide/structural-directives#one-per-element\n - guide/structural-directives#template\n - guide/structural-directives#templateref-와-viewcontainerref\n - guide/structural-directives#translation\n - guide/structural-directives#unless\n - guide/structural-directives#writing-your-own-structural-directives\n - guide/structural-directives#구조-디렉티브-structural-directives\n - guide/structural-directives#구조-디렉티브는-호스트-엘리먼트에-하나만\n - guide/structural-directives#구조-디렉티브란\n - guide/structural-directives#별표-asterisk-접두사\n - guide/structural-directives#별표-문법을-사용하세요\n - guide/structural-directives#비슷한-엘리먼트-묶기--ng-container\n - guide/structural-directives#세부-문법microsyntax\n - guide/structural-directives#왜-숨기지않고-제거하는-걸까요\n - guide/structural-directives#정리\n - guide/structural-directives#커스텀-구조-디렉티브-작성하기\n - guide/structural-directives#템플릿-입력-변수-template-input-variable\n - guide/structural-directives#해결방법--ng-container\n - guide/styleguide#02-03\n - guide/template-syntax\n - guide/template-syntax#inputs-outputs\n - guide/template-syntax#ngFor\n - guide/template-syntax#ngIf\n - guide/template-syntax#ngStyle\n - guide/template-syntax#ngSwitch\n - guide/template-syntax#ref-vars\n - guide/template-syntax#template-expressions\n - https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors\n - https://github.com/angular/angular/blob/master/packages/common/src/directives/ng_for_of.ts\n - https://github.com/angular/angular/blob/master/packages/common/src/directives/ng_if.ts\n - https://github.com/angular/angular/edit/master/aio/content/guide/structural-directives.md?message=docs%3A%20describe%20your%20change...\n-->"
}