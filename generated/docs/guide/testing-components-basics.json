{
  "id": "guide/testing-components-basics",
  "title": "컴포넌트 테스트 기본",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/testing-components-basics.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Basics of testing components\n-->\n<h1 id=\"컴포넌트-테스트-기본\">컴포넌트 테스트 기본<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#컴포넌트-테스트-기본\"><i class=\"material-icons\">link</i></a></h1>\n<!--\nA component, unlike all other parts of an Angular application,\ncombines an HTML template and a TypeScript class.\nThe component truly is the template and the class _working together_. To adequately test a component, you should test that they work together\nas intended.\n\nSuch tests require creating the component's host element in the browser DOM,\nas Angular does, and investigating the component class's interaction with\nthe DOM as described by its template.\n\nThe Angular `TestBed` facilitates this kind of testing as you'll see in the sections below.\nBut in many cases, _testing the component class alone_, without DOM involvement,\ncan validate much of the component's behavior in an easier, more obvious way.\n\n<div class=\"alert is-helpful\">\n\n  For the sample app that the testing guides describe, see the <live-example name=\"testing\" embedded-style noDownload>sample app</live-example>.\n\n  For the tests features in the testing guides, see <live-example name=\"testing\" stackblitz=\"specs\" noDownload>tests</live-example>.\n\n</div>\n-->\n<p>Angular 애플리케이션을 구성하는 다른 요소와 다르게, 컴포넌트는 HTML 템플릿과 TypeScript 클래스로 구성됩니다.\n컴포넌트는 사실 템플릿과 클래스가 <em>함께 동작하는</em> 것이라고 볼 수 있습니다.\n그래서 컴포넌트를 테스트한다는 것은 템플릿과 클래스가 의도된 대로 동작하는지 테스트하는 것을 의미합니다.</p>\n<p>컴포넌트를 테스트하려면 Angular가 그랬던 것 처럼 브라우저 DOM에 컴포넌트 호스트 엘리먼트를 추가해야 합니다.\n그래야 호스트 엘리먼트 안으로 컴포넌트 템플릿이 구성되며, 컴포넌트 클래스가 이 템플릿과 상호작용할 수 있습니다.</p>\n<p>컴포넌트 테스트 환경은 Angular <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>로 구성합니다.\n이 내용은 아래 섹션에서 자세하게 알아봅시다.</p>\n<p>보통은 DOM을 신경쓰지 않고 <em>클래스만 따로 테스트</em> 하기도 합니다.\n컴포넌트의 동작만 간단하게 확인한다면 이 방식이 편합니다.</p>\n<div class=\"alert is-helpful\">\n<p>이 문서에서 다루는 예제 앱은 <live-example name=\"testing\" embedded-style=\"\" nodownload=\"\">sample app</live-example>에서 확인할 수 있습니다.</p>\n<p>이 문서에서 다루는 테스트 기능은 <live-example name=\"testing\" stackblitz=\"specs\" nodownload=\"\">tests</live-example>에서 확인할 수 있습니다.</p>\n</div>\n<a id=\"component-class-testing\"></a>\n<!--\n## Component class testing\n-->\n<h2 id=\"컴포넌트-클래스-테스트하기\">컴포넌트 클래스 테스트하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#컴포넌트-클래스-테스트하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nTest a component class on its own as you would test a service class.\n\nComponent class testing should be kept very clean and simple.\nIt should test only a single unit.\nAt first glance, you should be able to understand\nwhat the test is testing.\n\nConsider this `LightswitchComponent` which toggles a light on and off\n(represented by an on-screen message) when the user clicks the button.\n\n<code-example path=\"testing/src/app/demo/demo.ts\" region=\"LightswitchComp\" header=\"app/demo/demo.ts (LightswitchComp)\">\n@Component({\n  selector: &#39;lightswitch-comp&#39;,\n  template: `\n    &lt;button (click)=&quot;clicked()&quot;&gt;Click me!&lt;/button&gt;\n    &lt;span&gt;{{message}}&lt;/span&gt;`\n})\nexport class LightswitchComponent {\n  isOn = false;\n  clicked() { this.isOn = !this.isOn; }\n  get message() { return `The light is ${this.isOn ? &#39;On&#39; : &#39;Off&#39;}`; }\n}\n\n</code-example>\n\nYou might decide only to test that the `clicked()` method\ntoggles the light's _on/off_ state and sets the message appropriately.\n\nThis component class has no dependencies. To test these types of classes, follow the same steps as you would for a service that has no dependencies:\n\n1. Create a component using the new keyword.\n2. Poke at its API.\n3. Assert expectations on its public state.\n\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"Lightswitch\" header=\"app/demo/demo.spec.ts (Lightswitch tests)\">\ndescribe(&#39;LightswitchComp&#39;, () =&gt; {\n  it(&#39;#clicked() should toggle #isOn&#39;, () =&gt; {\n    const comp = new LightswitchComponent();\n    expect(comp.isOn).toBe(false, &#39;off at first&#39;);\n    comp.clicked();\n    expect(comp.isOn).toBe(true, &#39;on after click&#39;);\n    comp.clicked();\n    expect(comp.isOn).toBe(false, &#39;off after second click&#39;);\n  });\n\n  it(&#39;#clicked() should set #message to &quot;is on&quot;&#39;, () =&gt; {\n    const comp = new LightswitchComponent();\n    expect(comp.message).toMatch(/is off/i, &#39;off at first&#39;);\n    comp.clicked();\n    expect(comp.message).toMatch(/is on/i, &#39;on after clicked&#39;);\n  });\n});\n\n</code-example>\n\nHere is the `DashboardHeroComponent` from the _Tour of Heroes_ tutorial.\n\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.ts\" region=\"class\" header=\"app/dashboard/dashboard-hero.component.ts (component)\">\nexport class DashboardHeroComponent {\n  @Input() hero: Hero;\n  @Output() selected = new EventEmitter&lt;Hero&gt;();\n  click() { this.selected.emit(this.hero); }\n}\n\n</code-example>\n\nIt appears within the template of a parent component,\nwhich binds a _hero_ to the `@Input` property and\nlistens for an event raised through the _selected_ `@Output` property.\n\nYou can test that the class code works without creating the `DashboardHeroComponent`\nor its parent component.\n\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"class-only\" header=\"app/dashboard/dashboard-hero.component.spec.ts (class tests)\">\nit(&#39;raises the selected event when clicked&#39;, () =&gt; {\n  const comp = new DashboardHeroComponent();\n  const hero: Hero = {id: 42, name: &#39;Test&#39;};\n  comp.hero = hero;\n\n  comp.selected.subscribe((selectedHero: Hero) =&gt; expect(selectedHero).toBe(hero));\n  comp.click();\n});\n\n</code-example>\n\nWhen a component has dependencies, you may wish to use the `TestBed` to both\ncreate the component and its dependencies.\n\nThe following `WelcomeComponent` depends on the `UserService` to know the name of the user to greet.\n\n<code-example path=\"testing/src/app/welcome/welcome.component.ts\" region=\"class\" header=\"app/welcome/welcome.component.ts\">\nexport class WelcomeComponent implements OnInit {\n  welcome: string;\n  constructor(private userService: UserService) { }\n\n  ngOnInit(): void {\n    this.welcome = this.userService.isLoggedIn ?\n      &#39;Welcome, &#39; + this.userService.user.name : &#39;Please log in.&#39;;\n  }\n}\n\n</code-example>\n\nYou might start by creating a mock of the `UserService` that meets the minimum needs of this component.\n\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"mock-user-service\" header=\"app/welcome/welcome.component.spec.ts (MockUserService)\">\nclass MockUserService {\n  isLoggedIn = true;\n  user = { name: &#39;Test User&#39;};\n}\n\n</code-example>\n\nThen provide and inject _both the_ **component** _and the service_ in the `TestBed` configuration.\n\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"class-only-before-each\" header=\"app/welcome/welcome.component.spec.ts (class-only setup)\">\nbeforeEach(() =&gt; {\n  TestBed.configureTestingModule({\n    // 테스트할 컴포넌트와 의존성으로 주입될 서비스를 프로바이더에 등록합니다.\n    providers: [\n      WelcomeComponent,\n      { provide: UserService, useClass: MockUserService }\n    ]\n  });\n  // TestBed를 사용해서 컴포넌트 인스턴스와 서비스 인스턴스를 참조합니다.\n  comp = TestBed.inject(WelcomeComponent);\n  userService = TestBed.inject(UserService);\n});\n\n</code-example>\n\nThen exercise the component class, remembering to call the [lifecycle hook methods](guide/lifecycle-hooks) as Angular does when running the app.\n\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"class-only-tests\" header=\"app/welcome/welcome.component.spec.ts (class-only tests)\">\nit(&#39;should not have welcome message after construction&#39;, () =&gt; {\n  expect(comp.welcome).toBeUndefined();\n});\n\nit(&#39;should welcome logged in user after Angular calls ngOnInit&#39;, () =&gt; {\n  comp.ngOnInit();\n  expect(comp.welcome).toContain(userService.user.name);\n});\n\nit(&#39;should ask user to log in if not logged in after ngOnInit&#39;, () =&gt; {\n  userService.isLoggedIn = false;\n  comp.ngOnInit();\n  expect(comp.welcome).not.toContain(userService.user.name);\n  expect(comp.welcome).toContain(&#39;log in&#39;);\n});\n\n</code-example>\n-->\n<p>컴포넌트 클래스를 테스트하는 것은 서비스 클래스를 테스트하는 것과 비슷합니다.</p>\n<p>컴포넌트 클래스를 테스트하는 코드는 원하는 동작 하나만 검증할 수 있도록 아주 간단하게 작성해야 합니다.\n코드를 처음 보자마자 이 코드가 무엇을 테스트하는 코드인지 알 수 있어야 합니다.</p>\n<p>사용자가 버튼을 클릭할 때마다 불을 켜고 끄는 <code>LightswitchComponent</code>가 있다고 합시다.\n불이 켜진 상태는 화면에 표시되는 메시지로 표현합니다.</p>\n<code-example path=\"testing/src/app/demo/demo.ts\" region=\"LightswitchComp\" header=\"app/demo/demo.ts (LightswitchComp)\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'lightswitch-comp',\n  template: `\n    &#x3C;button (click)=\"clicked()\">Click me!&#x3C;/button>\n    &#x3C;span>{{message}}&#x3C;/span>`\n})\nexport class LightswitchComponent {\n  isOn = false;\n  clicked() { this.isOn = !this.isOn; }\n  get message() { return `The light is ${this.isOn ? 'On' : 'Off'}`; }\n}\n\n</code-example>\n<p>이 클래스 코드를 보면 <code>clicked()</code> 메서드가 <em>켜지고/꺼진</em> 상태를 토글하면서 메시지를 제대로 출력하는지 검사하면 되겠다고 판단할 수 있습니다.</p>\n<p>이 컴포넌트 클래스에 주입되는 의존성 객체는 없습니다.\n그렇다면 의존성 객체가 없는 서비스 클래스를 테스트했던 것과 비슷하게 진행하면 됩니다:</p>\n<ol>\n<li><code>new</code> 키워드로 컴포넌트 인스턴스를 생성합니다.</li>\n<li>컴포넌트 메서드를 실행합니다.</li>\n<li>컴포넌트 내부 상태가 변경된 것을 확인합니다.</li>\n</ol>\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"Lightswitch\" header=\"app/demo/demo.spec.ts (Lightswitch 테스트)\">\ndescribe('LightswitchComp', () => {\n  it('#clicked() should toggle #isOn', () => {\n    const comp = new LightswitchComponent();\n    expect(comp.isOn).toBe(false, 'off at first');\n    comp.clicked();\n    expect(comp.isOn).toBe(true, 'on after click');\n    comp.clicked();\n    expect(comp.isOn).toBe(false, 'off after second click');\n  });\n\n  it('#clicked() should set #message to \"is on\"', () => {\n    const comp = new LightswitchComponent();\n    expect(comp.message).toMatch(/is off/i, 'off at first');\n    comp.clicked();\n    expect(comp.message).toMatch(/is on/i, 'on after clicked');\n  });\n});\n\n</code-example>\n<p><em>히어로들의 여행</em> 튜토리얼에서 다룬 <code>DashboardHeroComponent</code> 컴포넌트 코드는 이렇습니다.</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.ts\" region=\"class\" header=\"app/dashboard/dashboard-hero.component.ts (컴포넌트)\">\nexport class DashboardHeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() selected = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;Hero>();\n  click() { this.selected.emit(this.hero); }\n}\n\n</code-example>\n<p>이 컴포넌트는 부모 컴포넌트 안에 위치하면서 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> <em>hero</em> 프로퍼티로 데이터를 바인딩 받아오고 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code> <em>selected</em> 프로퍼티로 이벤트를 보냅니다.</p>\n<p>이 컴포넌트 코드를 테스트하려면 부모 컴포넌트 없이 이렇게 구성하면 됩니다.</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"class-only\" header=\"app/dashboard/dashboard-hero.component.spec.ts (클래스 테스트하기)\">\nit('raises the selected event when clicked', () => {\n  const comp = new DashboardHeroComponent();\n  const hero: Hero = {id: 42, name: 'Test'};\n  comp.hero = hero;\n\n  comp.selected.subscribe((selectedHero: Hero) => expect(selectedHero).toBe(hero));\n  comp.click();\n});\n\n</code-example>\n<p>컴포넌트에 주입되는 의존성 객체가 있다면 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>에 해당 컴포넌트와 관련 의존성 객체를 모두 등록해야 합니다.</p>\n<p>아래 <code>WelcomeComponent</code>는 <code>UserService</code>를 의존성으로 주입받습니다.</p>\n<code-example path=\"testing/src/app/welcome/welcome.component.ts\" region=\"class\" header=\"app/welcome/welcome.component.ts\">\nexport class WelcomeComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  welcome: string;\n  constructor(private userService: UserService) { }\n\n  ngOnInit(): void {\n    this.welcome = this.userService.isLoggedIn ?\n      'Welcome, ' + this.userService.user.name : 'Please log in.';\n  }\n}\n\n</code-example>\n<p>이런 경우에는 컴포넌트를 테스트할 때 꼭 필요한 내용만 목으로 구성해서 <code>UserService</code>를 구성하면 됩니다.</p>\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"mock-user-service\" header=\"app/welcome/welcome.component.spec.ts (MockUserService)\">\nclass MockUserService {\n  isLoggedIn = true;\n  user = { name: 'Test User'};\n}\n\n</code-example>\n<p>이렇게 만든 목 서비스를 <strong>컴포넌트</strong> 와 함께 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>에 등록하면 컴포넌트에서 의존성으로 주입받을 수 있습니다.</p>\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"class-only-before-each\" header=\"app/welcome/welcome.component.spec.ts (환경설정)\">\nbeforeEach(() => {\n  TestBed.configureTestingModule({\n    // 테스트할 컴포넌트와 의존성으로 주입될 서비스를 프로바이더에 등록합니다.\n    providers: [\n      WelcomeComponent,\n      { provide: UserService, useClass: MockUserService }\n    ]\n  });\n  // <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>를 사용해서 컴포넌트 인스턴스와 서비스 인스턴스를 참조합니다.\n  comp = TestBed.inject(WelcomeComponent);\n  userService = TestBed.inject(UserService);\n});\n\n</code-example>\n<p>그리고 컴포넌트 클래스가 실제처럼 동작하는 것을 확인하려면 Angular가 자동으로 하는 것처럼 <a href=\"guide/lifecycle-hooks\">라이프싸이클 후킹 함수</a>를 실행하면 됩니다.</p>\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"class-only-tests\" header=\"app/welcome/welcome.component.spec.ts (클래스 테스트하기)\">\nit('should not have welcome message after construction', () => {\n  expect(comp.welcome).toBeUndefined();\n});\n\nit('should welcome logged in user after Angular calls ngOnInit', () => {\n  comp.ngOnInit();\n  expect(comp.welcome).toContain(userService.user.name);\n});\n\nit('should ask user to log in if not logged in after ngOnInit', () => {\n  userService.isLoggedIn = false;\n  comp.ngOnInit();\n  expect(comp.welcome).not.toContain(userService.user.name);\n  expect(comp.welcome).toContain('log in');\n});\n\n</code-example>\n<!--\n## Component DOM testing\n-->\n<h2 id=\"컴포넌트-dom-테스트하기\">컴포넌트 DOM 테스트하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#컴포넌트-dom-테스트하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nTesting the component _class_ is as easy as [testing a service](guide/testing-services).\n\nBut a component is more than just its class.\nA component interacts with the DOM and with other components.\nThe _class-only_ tests can tell you about class behavior.\nThey cannot tell you if the component is going to render properly,\nrespond to user input and gestures, or integrate with its parent and child components.\n\nNone of the _class-only_ tests above can answer key questions about how the\ncomponents actually behave on screen.\n\n- Is `Lightswitch.clicked()` bound to anything such that the user can invoke it?\n- Is the `Lightswitch.message` displayed?\n- Can the user actually select the hero displayed by `DashboardHeroComponent`?\n- Is the hero name displayed as expected (i.e, in uppercase)?\n- Is the welcome message displayed by the template of `WelcomeComponent`?\n\nThese may not be troubling questions for the simple components illustrated above.\nBut many components have complex interactions with the DOM elements\ndescribed in their templates, causing HTML to appear and disappear as\nthe component state changes.\n\nTo answer these kinds of questions, you have to create the DOM elements associated\nwith the components, you must examine the DOM to confirm that component state\ndisplays properly at the appropriate times, and you must simulate user interaction\nwith the screen to determine whether those interactions cause the component to\nbehave as expected.\n\nTo write these kinds of test, you'll use additional features of the `TestBed`\nas well as other testing helpers.\n-->\n<p>컴포넌트 <em>클래스</em> 를 테스트하는 것은 <a href=\"guide/testing-services\">서비스 클래스를 테스트</a>하는 것만큼 쉽습니다.</p>\n<p>하지만 컴포넌트에는 클래스만 있는 것이 아닙니다.\n컴포넌트는 DOM과 상호작용하기도 하고 다른 컴포넌트와 상호작용하기도 합니다.\n그래서 <em>컴포넌트 클래스만</em> 테스트하면 이 컴포넌트가 제대로 렌더링 되는지, 사용자가 입력하는 내용과 이벤트를 제대로 처리하는지, 부모/자식 컴포넌트와 상호작용은 제대로 하는지 확인할 수 없습니다.</p>\n<p>컴포넌트 클래스만 테스트하면 화면에서 실제로 동작하는 이런 동작을 검증할 수 없습니다.</p>\n<ul>\n<li><code>Lightswitch.clicked()</code>는 사용자가 조작할 수 있는 무언가와 바인딩되어 있을까?</li>\n<li><code>Lightswitch.message</code>는 화면에 표시되고 있을까?</li>\n<li><code>DashboardHeroComponent</code>에서 사용자가 히어로 한 명을 선택할 수 있을까?</li>\n<li>히어로 이름은 지정한 형식으로 표시되고 있을까?</li>\n<li><code>WelcomeComponent</code> 템플릿에는 환영 메시지가 제대로 표시되고 있을까?</li>\n</ul>\n<p>컴포넌트가 위에서 살펴본 정도로 간단하다면 간단하게 이 질문에 대답할 수 있습니다.\n하지만 컴포넌트 상태에 따라 HTML 프래그먼트를 표시하거나 감추면서 템플릿에 있는 DOM 엘리먼트와 복잡하게 상호작용하는 경우는 쉽게 대답할 수 없을 것입니다.</p>\n<p>그렇다면 컴포넌트에 해당되는 DOM 엘리먼트를 생성해두고 컴포넌트 상태에 따라 DOM이 제대로 갱신되는지 확인해야 하며, 사용자가 화면을 조작하듯이 상호작용도 시뮬레이션하면서 컴포넌트가 예상대로 동작하는지 확인해야 합니다.</p>\n<p>이런 테스트 코드를 작성하려면 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>와 같은 테스트 유틸을 활용하면 됩니다.</p>\n<!--\n### CLI-generated tests\n-->\n<h3 id=\"angular-cli가-생성한-테스트-코드\">Angular CLI가 생성한 테스트 코드<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#angular-cli가-생성한-테스트-코드\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe CLI creates an initial test file for you by default when you ask it to\ngenerate a new component.\n\nFor example, the following CLI command generates a `BannerComponent` in the `app/banner` folder (with inline template and styles):\n\n<code-example language=\"sh\" class=\"code-shell\">\nng generate component banner --inline-template --inline-style --module app\n</code-example>\n\nIt also generates an initial test file for the component, `banner-external.component.spec.ts`, that looks like this:\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v1\" header=\"app/banner/banner-external.component.spec.ts (initial)\">\nimport { ComponentFixture, TestBed, waitForAsync } from &#39;@angular/core/testing&#39;;\nimport { By } from &#39;@angular/platform-browser&#39;;\n\nimport { BannerComponent } from &#39;./banner.component&#39;;\n\ndescribe(&#39;BannerComponent&#39;, () =&gt; {\n  let component: BannerComponent;\n  let fixture: ComponentFixture&lt;BannerComponent&gt;;\n\n  beforeEach(waitForAsync(() =&gt; {\n    TestBed.configureTestingModule({declarations: [BannerComponent]}).compileComponents();\n  }));\n\n  beforeEach(() =&gt; {\n    fixture = TestBed.createComponent(BannerComponent);\n    component = fixture.componentInstance;\n    fixture.detectChanges();\n  });\n\n  it(&#39;should create&#39;, () =&gt; {\n    expect(component).toBeDefined();\n  });\n});\n\n</code-example>\n\n<div class=\"alert is-helpful\">\n\nBecause `compileComponents` is asynchronous, it uses\nthe [`waitForAsync`](api/core/testing/waitForAsync) utility\nfunction imported from `@angular/core/testing`.\n\nPlease refer to the [waitForAsync](guide/testing-components-scenarios#waitForAsync) section for more details.\n\n</div>\n-->\n<p>Angular CLI로 컴포넌트를 새로 생성하면 기본 테스트 코드도 함께 생성됩니다.</p>\n<p>아래 명령을 실행하면 <code>app/banner</code> 폴더에 <code>BannerComponent</code>가 생성됩니다.\n그리고 명령을 실행할 때 지정한 대로 템플릿과 스타일이 인라인으로 구성됩니다:</p>\n<code-example language=\"sh\" class=\"code-shell\">\nng generate component banner --inline-template --inline-style --module app\n</code-example>\n<p>명령이 실행되고 나면 기본 테스트 코드가 <code>banner-external.component.spec.ts</code> 파일에 생성된 것을 확인할 수 있습니다:</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v1\" header=\"app/banner/banner-external.component.spec.ts (기본 코드)\">\nimport { <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>, <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>, <a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a> } from '@angular/core/testing';\nimport { <a href=\"api/platform-browser/By\" class=\"code-anchor\">By</a> } from '@angular/platform-browser';\n\nimport { BannerComponent } from './banner.component';\n\ndescribe('BannerComponent', () => {\n  let component: BannerComponent;\n  let fixture: <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>&#x3C;BannerComponent>;\n\n  beforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() => {\n    TestBed.configureTestingModule({declarations: [BannerComponent]}).compileComponents();\n  }));\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(BannerComponent);\n    component = fixture.componentInstance;\n    fixture.detectChanges();\n  });\n\n  it('should create', () => {\n    expect(component).toBeDefined();\n  });\n});\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p><code>compileComponents</code>는 비동기로 실행되기 때문에 <code>@angular/core/testing</code> 라이브러리로 제공되는 <a href=\"api/core/testing/waitForAsync\"><code>waitForAsync</code></a>를 사용해야 합니다.</p>\n<p>자세한 내용은 <a href=\"guide/testing-components-scenarios#waitForAsync\">waitForAsync</a> 섹션을 참고하세요.</p>\n</div>\n<!--\n### Reduce the setup\n-->\n<h3 id=\"환경설정-코드-줄이기\">환경설정 코드 줄이기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#환경설정-코드-줄이기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nOnly the last three lines of this file actually test the component\nand all they do is assert that Angular can create the component.\n\nThe rest of the file is boilerplate setup code anticipating more advanced tests that _might_ become necessary if the component evolves into something substantial.\n\nYou'll learn about these advanced test features below.\nFor now, you can radically reduce this test file to a more manageable size:\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v2\" header=\"app/banner/banner-initial.component.spec.ts (minimal)\">\ndescribe(&#39;BannerComponent (minimal)&#39;, () =&gt; {\n  it(&#39;should create&#39;, () =&gt; {\n    TestBed.configureTestingModule({declarations: [BannerComponent]});\n    const fixture = TestBed.createComponent(BannerComponent);\n    const component = fixture.componentInstance;\n    expect(component).toBeDefined();\n  });\n});\n\n</code-example>\n\nIn this example, the metadata object passed to `TestBed.configureTestingModule`\nsimply declares `BannerComponent`, the component to test.\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"configureTestingModule\">\nTestBed.configureTestingModule({declarations: [BannerComponent]});\n\n</code-example>\n\n<div class=\"alert is-helpful\">\n\nThere's no need to declare or import anything else.\nThe default test module is pre-configured with\nsomething like the `BrowserModule` from `@angular/platform-browser`.\n\nLater you'll call `TestBed.configureTestingModule()` with\nimports, providers, and more declarations to suit your testing needs.\nOptional `override` methods can further fine-tune aspects of the configuration.\n\n</div>\n-->\n<p>사실 위 코드에서 컴포넌트가 제대로 생성되었는지 테스트하는 코드는 마지막 세 줄입니다.</p>\n<p>나머지는 이후에 도입할 테스트 유틸리티까지 고려하면서 컴포넌트를 준비하고 특정 상태로 만드는 환경설정 코드입니다.</p>\n<p>테스트 유틸리티에 대해서는 이후 섹션에서 다룹니다.\n지금은 꼭 필요한 내용만 남겨서 환경설정 코드를 줄여봅시다:</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v2\" header=\"app/banner/banner-initial.component.spec.ts (최소 코드)\">\ndescribe('BannerComponent (minimal)', () => {\n  it('should create', () => {\n    TestBed.configureTestingModule({declarations: [BannerComponent]});\n    const fixture = TestBed.createComponent(BannerComponent);\n    const component = fixture.componentInstance;\n    expect(component).toBeDefined();\n  });\n});\n\n</code-example>\n<p>이 예제에서는 <code>TestBed.configureTestingModule</code>에 전달하는 메타데이터 객체로 테스트하려는 컴포넌트 <code>BannerComponent</code>만 등록했습니다.</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"configureTestingModule\">\nTestBed.configureTestingModule({declarations: [BannerComponent]});\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>이 코드에서 추가로 선언하거나 로드해야 하는 것은 없습니다.\n<code>@angular/platform-browser</code>가 제공하는 <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>은 기본 설정이 완료된 상태로 제공됩니다.</p>\n<p>이후에는 <code>TestBed.configureTestingModule()</code>에 다른 모듈을 로드하고, 서비스를 등록하며, 테스트에 필요한 항목들을 추가로 로드해 봅시다.\n이 환경설정을 기반으로 특정 부분만 오버라이드 하는 방법도 있습니다.</p>\n</div>\n<a id=\"create-component\"></a>\n<h3 id=\"createcomponent\"><em>createComponent()</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#createcomponent\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAfter configuring `TestBed`, you call its `createComponent()` method.\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"createComponent\">\nconst fixture = TestBed.createComponent(BannerComponent);\n\n</code-example>\n\n`TestBed.createComponent()` creates an instance of the `BannerComponent`,\nadds a corresponding element to the test-runner DOM,\nand returns a [`ComponentFixture`](#component-fixture).\n\n<div class=\"alert is-important\">\n\nDo not re-configure `TestBed` after calling `createComponent`.\n\nThe `createComponent` method freezes the current `TestBed` definition,\nclosing it to further configuration.\n\nYou cannot call any more `TestBed` configuration methods, not `configureTestingModule()`,\nnor `get()`, nor any of the `override...` methods.\nIf you try, `TestBed` throws an error.\n\n</div>\n-->\n<p><code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 환경설정을 끝내고 나면 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>가 제공하는 <code>createComponent()</code> 메서드를 실행할 수 있습니다.</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"createComponent\">\nconst fixture = TestBed.createComponent(BannerComponent);\n\n</code-example>\n<p><code>TestBed.createComponent()</code> 메서드를 실행하면 <code>BannerComponent</code> 인스턴스가 생성되면서 테스트 환경 DOM에 <code>BannerComponent</code> 엘리먼트를 추가하고 <a href=\"guide/testing-components-basics#component-fixture\"><code>ComponentFixture</code></a>를 반환합니다.</p>\n<div class=\"alert is-important\">\n<p><code>createComponent</code>를 실행하고 난 후에는 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 구성을 변경하지 마세요.</p>\n<p><code>createComponent</code> 메서드는 실행 시점에 지정된 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 환경설정을 참조하며, 이후에 변경되는 사항은 반영하지 않습니다.</p>\n<p>그리고 <code>createComponent</code> 메서드를 실행하고 나면 <code>configureTestingModule()</code>, <code>get()</code>, <code>override...</code> 메소드가 아닌 환경설정 메소드를 실행할 수 없습니다.\n이렇게 사용하면 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>에서 에러가 발생합니다.</p>\n</div>\n<a id=\"component-fixture\"></a>\n<h3 id=\"componentfixture\"><em>ComponentFixture</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#componentfixture\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe [ComponentFixture](api/core/testing/ComponentFixture) is a test harness for interacting with the created component and its corresponding element.\n\nAccess the component instance through the fixture and confirm it exists with a Jasmine expectation:\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"componentInstance\">\nconst component = fixture.componentInstance;\nexpect(component).toBeDefined();\n\n</code-example>\n-->\n<p><a href=\"api/core/testing/ComponentFixture\">ComponentFixture</a>는 생성된 컴포넌트 클래스와 컴포넌트 엘리먼트를 직접 조작할 수 있는 테스트 도구입니다.</p>\n<p>이 객체와 Jasmine 테스트 함수를 사용하면 컴포넌트 인스턴스의 상태를 검사할 수 있습니다:</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"componentInstance\">\nconst component = fixture.componentInstance;\nexpect(component).toBeDefined();\n\n</code-example>\n<h3 id=\"beforeeach\"><em>beforeEach()</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#beforeeach\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou will add more tests as this component evolves.\nRather than duplicate the `TestBed` configuration for each test,\nyou refactor to pull the setup into a Jasmine `beforeEach()` and some supporting variables:\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v3\">\ndescribe(&#39;BannerComponent (with beforeEach)&#39;, () =&gt; {\n  let component: BannerComponent;\n  let fixture: ComponentFixture&lt;BannerComponent&gt;;\n\n  beforeEach(() =&gt; {\n    TestBed.configureTestingModule({declarations: [BannerComponent]});\n    fixture = TestBed.createComponent(BannerComponent);\n    component = fixture.componentInstance;\n  });\n\n  it(&#39;should create&#39;, () =&gt; {\n    expect(component).toBeDefined();\n  });\n});\n\n</code-example>\n\nNow add a test that gets the component's element from `fixture.nativeElement` and\nlooks for the expected text.\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v4-test-2\">\nit(&#39;should contain &quot;banner works!&quot;&#39;, () =&gt; {\n  const bannerElement: HTMLElement = fixture.nativeElement;\n  expect(bannerElement.textContent).toContain(&#39;banner works!&#39;);\n});\n\n</code-example>\n-->\n<p>컴포넌트에 기능을 추가하다 보면 더 많은 테스트를 작성해야 할 수 있습니다.\n이런 경우에 매 테스트 스펙마다 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 환경설정을 반복하는 것보다는 Jasmine이 제공하는 <code>beforeEach()</code>에 환경설정 코드를 작성하는 것이 더 좋습니다:</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v3\">\ndescribe('BannerComponent (with beforeEach)', () => {\n  let component: BannerComponent;\n  let fixture: <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>&#x3C;BannerComponent>;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({declarations: [BannerComponent]});\n    fixture = TestBed.createComponent(BannerComponent);\n    component = fixture.componentInstance;\n  });\n\n  it('should create', () => {\n    expect(component).toBeDefined();\n  });\n});\n\n</code-example>\n<p>이제 <code>fixture.nativeElement</code>로 컴포넌트 엘리먼트를 참조하는 코드와 이 엘리먼트의 텍스트가 제대로 표시되는지 검사하는 테스트 코드를 작성해 봅시다.</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v4-test-2\">\nit('should contain \"banner works!\"', () => {\n  const bannerElement: HTMLElement = fixture.nativeElement;\n  expect(bannerElement.textContent).toContain('banner works!');\n});\n\n</code-example>\n<a id=\"native-element\"></a>\n<h3 id=\"nativeelement\"><em>nativeElement</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#nativeelement\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe value of `ComponentFixture.nativeElement` has the `any` type.\nLater you'll encounter the `DebugElement.nativeElement` and it too has the `any` type.\n\nAngular can't know at compile time what kind of HTML element the `nativeElement` is or\nif it even is an HTML element.\nThe app might be running on a _non-browser platform_, such as the server or a\n[Web Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API),\nwhere the element may have a diminished API or not exist at all.\n\nThe tests in this guide are designed to run in a browser so a\n`nativeElement` value will always be an `HTMLElement` or\none of its derived classes.\n\nKnowing that it is an `HTMLElement` of some sort, you can use\nthe standard HTML `querySelector` to dive deeper into the element tree.\n\nHere's another test that calls `HTMLElement.querySelector` to get the paragraph element and look for the banner text:\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v4-test-3\">\nit(&#39;should have &lt;p&gt; with &quot;banner works!&quot;&#39;, () =&gt; {\n  const bannerElement: HTMLElement = fixture.nativeElement;\n  const p = bannerElement.querySelector(&#39;p&#39;);\n  expect(p.textContent).toEqual(&#39;banner works!&#39;);\n});\n\n</code-example>\n-->\n<p><code><a href=\"api/core/testing/ComponentFixture#nativeElement\" class=\"code-anchor\">ComponentFixture.nativeElement</a></code>는 <code>any</code> 타입입니다.\n그리고 이후에 살펴볼 <code><a href=\"api/core/DebugElement#nativeElement\" class=\"code-anchor\">DebugElement.nativeElement</a></code>도 <code>any</code> 타입입니다.</p>\n<p>Angular는 컴파일 시점에 <code>nativeElement</code>가 어떤 종류인지 알 수 없으며, 심지어 이 객체가 HTML 엘리먼트라는 것도 알 수 없습니다.\n왜냐하면 Angluar 앱은 서버나 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API\">웹 워커(Web Worker)</a> 같이 <em>브라우저가 아닌 플랫폼</em> 에서도 실행될 수 있기 때문에 엘리먼트 API 중 일부나 전체가 없을 수 있기 때문입니다.</p>\n<p>이 문서에서는 테스트하는 Angular 앱이 브라우저에서 실행된다고 간주하고 <code>nativeElement</code>가 <code>HTMLElement</code> 종류 중 하나인 것으로 생각하겠습니다.</p>\n<p>테스트하는 대상이 <code>HTMLElement</code> 종류 중 하나라고 하면 이제 이 엘리먼트를 대상으로 <code>querySelector</code>와 같은 메서드를 사용할 수 있기 때문에 엘리먼트 안쪽으로 자유롭게 들어가 볼 수 있습니다.</p>\n<p>엘리먼트 템플릿에 있는 문구를 <code>HTMLElement.querySelector</code>로 테스트하는 코드는 이렇습니다:</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v4-test-3\">\nit('should have &#x3C;p> with \"banner works!\"', () => {\n  const bannerElement: HTMLElement = fixture.nativeElement;\n  const p = bannerElement.querySelector('p');\n  expect(p.textContent).toEqual('banner works!');\n});\n\n</code-example>\n<a id=\"debug-element\"></a>\n<h3 id=\"debugelement\"><em>DebugElement</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#debugelement\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe Angular _fixture_ provides the component's element directly through the `fixture.nativeElement`.\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"nativeElement\">\nconst bannerElement: HTMLElement = fixture.nativeElement;\n\n</code-example>\n\nThis is actually a convenience method, implemented as `fixture.debugElement.nativeElement`.\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"debugElement-nativeElement\">\nconst bannerDe: DebugElement = fixture.debugElement;\nconst bannerEl: HTMLElement = bannerDe.nativeElement;\n\n</code-example>\n\nThere's a good reason for this circuitous path to the element.\n\nThe properties of the `nativeElement` depend upon the runtime environment.\nYou could be running these tests on a _non-browser_ platform that doesn't have a DOM or\nwhose DOM-emulation doesn't support the full `HTMLElement` API.\n\nAngular relies on the `DebugElement` abstraction to work safely across _all supported platforms_.\nInstead of creating an HTML element tree, Angular creates a `DebugElement` tree that wraps the _native elements_ for the runtime platform.\nThe `nativeElement` property unwraps the `DebugElement` and returns the platform-specific element object.\n\nBecause the sample tests for this guide are designed to run only in a browser,\na `nativeElement` in these tests is always an `HTMLElement`\nwhose familiar methods and properties you can explore within a test.\n\nHere's the previous test, re-implemented with `fixture.debugElement.nativeElement`:\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v4-test-4\">\nit(&#39;should find the &lt;p&gt; with fixture.debugElement.nativeElement)&#39;, () =&gt; {\n  const bannerDe: DebugElement = fixture.debugElement;\n  const bannerEl: HTMLElement = bannerDe.nativeElement;\n  const p = bannerEl.querySelector(&#39;p&#39;);\n  expect(p.textContent).toEqual(&#39;banner works!&#39;);\n});\n\n</code-example>\n\nThe `DebugElement` has other methods and properties that\nare useful in tests, as you'll see elsewhere in this guide.\n\nYou import the `DebugElement` symbol from the Angular core library.\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"import-debug-element\">\nimport { DebugElement } from &#39;@angular/core&#39;;\n\n</code-example>\n-->\n<p><code>fixture.nativeElement</code>를 참조하면 컴포넌트 엘리먼트에 직접 접근할 수 있습니다.</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"nativeElement\">\nconst bannerElement: HTMLElement = fixture.nativeElement;\n\n</code-example>\n<p>이 방법은 확실히 <code>fixture.debugElement.nativeElement</code>라고 참조하는 것보다는 편합니다.</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"debugElement-nativeElement\">\nconst bannerDe: <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> = fixture.debugElement;\nconst bannerEl: HTMLElement = bannerDe.nativeElement;\n\n</code-example>\n<p>참조하는 방식이 약간 혼란스러운 이유가 있습니다.</p>\n<p><code>nativeElement</code> 안에 있는 프로퍼티들은 Angular 앱이 실행되는 환경에 따라 달라집니다.\n<em>브라우저가 아닌</em> 플랫폼에서 테스트를 실행한다면 DOM이 존재하지 않으며, DOM을 대신하는 객체가 있다고 해도 <code>HTMLElement</code>의 모든 API를 제공한다고 보장할 수 없습니다.</p>\n<p>그래서 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>는 <em>모든 플랫폼에</em> 필요한 기능을 제공하기 위해 도입되었습니다.\nAngular는 HTML 엘리먼트 트리를 직접 생성하지 않고 Angular 앱이 실행되는 플랫폼의 <em>네이티브 엘리먼트</em> 를 래핑한 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 트리를 구성합니다.\n그리고 <code>nativeElement</code> 프로퍼티는 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>를 해당 플랫폼에 맞게 풀어 놓은(unwrap) 객체입니다.</p>\n<p>이 문서에서는 테스트하려는 앱이 브라우저에서만 실행된다고 가정하기 때문에 <code>nativeElement</code>는 항상 <code>HTMLElement</code>입니다.\n그래서 테스트 코드를 작성할 때 <code>HTMLElement</code>가 제공하는 메서드를 자유롭게 사용할 수 있습니다.</p>\n<p>이전에 작성한 테스트 코드를 <code>fixture.debugElement.nativeElement</code> 방식으로 다시 작성해보면 이렇습니다:</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v4-test-4\">\nit('should find the &#x3C;p> with fixture.debugElement.nativeElement)', () => {\n  const bannerDe: <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> = fixture.debugElement;\n  const bannerEl: HTMLElement = bannerDe.nativeElement;\n  const p = bannerEl.querySelector('p');\n  expect(p.textContent).toEqual('banner works!');\n});\n\n</code-example>\n<p>이 문서에서 다루는 범위를 벗어나기 때문에 언급하지는 않겠지만, <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>에는 테스트에 활용할만한 메서드와 프로퍼티가 더 있습니다.</p>\n<p><code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 심볼은 <code>@angular/core</code> 라이브러리에서 불러올 수 있습니다.</p>\n<a id=\"by-css\"></a>\n<h3 id=\"bycss\"><em>By.css()</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#bycss\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAlthough the tests in this guide all run in the browser,\nsome apps might run on a different platform at least some of the time.\n\nFor example, the component might render first on the server as part of a strategy to make the application launch faster on poorly connected devices. The server-side renderer might not support the full HTML element API.\nIf it doesn't support `querySelector`, the previous test could fail.\n\nThe `DebugElement` offers query methods that work for all supported platforms.\nThese query methods take a _predicate_ function that returns `true` when a node in the `DebugElement` tree matches the selection criteria.\n\nYou create a _predicate_ with the help of a `By` class imported from a\nlibrary for the runtime platform. Here's the `By` import for the browser platform:\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"import-by\">\nimport { By } from &#39;@angular/platform-browser&#39;;\n\n</code-example>\n\nThe following example re-implements the previous test with\n`DebugElement.query()` and the browser's `By.css` method.\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v4-test-5\">\nit(&#39;should find the &lt;p&gt; with fixture.debugElement.query(By.css)&#39;, () =&gt; {\n  const bannerDe: DebugElement = fixture.debugElement;\n  const paragraphDe = bannerDe.query(By.css(&#39;p&#39;));\n  const p: HTMLElement = paragraphDe.nativeElement;\n  expect(p.textContent).toEqual(&#39;banner works!&#39;);\n});\n\n</code-example>\n\nSome noteworthy observations:\n\n- The `By.css()` static method selects `DebugElement` nodes\n  with a [standard CSS selector](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started/Selectors 'CSS selectors').\n- The query returns a `DebugElement` for the paragraph.\n- You must unwrap that result to get the paragraph element.\n\nWhen you're filtering by CSS selector and only testing properties of a browser's _native element_, the `By.css` approach may be overkill.\n\nIt's often easier and more clear to filter with a standard `HTMLElement` method\nsuch as `querySelector()` or `querySelectorAll()`.\n-->\n<p>이 문서는 브라우저에서 실행되는 Angular 앱을 테스트하는 것으로 간주하고 있지만, 상황에 따라 다른 플랫폼에서 실행해야 하는 경우가 있습니다.</p>\n<p>예를 들면, 인터넷 연결 상태가 좋지 않은 애플리케이션에서 첫 화면을 빠르게 띄우기 위해 서버에서 컴포넌트를 미리 렌더링 하는 경우가 있습니다.\n하지만 서버 사이드 렌더링을 할 때는 HTML 엘리먼트 API를 온전히 사용할 수 없습니다.\n<code>querySelector</code>도 지원되지 않기 때문에 위에서 작성한 테스트는 실패할 것입니다.</p>\n<p>이 때 모든 플랫폼에서 활용할 수 있는 쿼리 메서드를 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>가 제공합니다.\n<code><a href=\"api/animations/query\" class=\"code-anchor\">query</a>()</code> 메서드는 매칭 함수를 인자로 받는데, 이 매칭 함수는 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 트리를 순회하다가 조건에 맞는 노드를 발견하면 <code>true</code>를 반환하는 함수입니다.</p>\n<p>매칭 함수는 런타임 플랫폼에 맞는 <code><a href=\"api/platform-browser/By\" class=\"code-anchor\">By</a></code> 클래스를 활용하면 됩니다.\n브라우저 플랫폼에서는 이렇게 사용합니다:</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"import-by\">\nimport { <a href=\"api/platform-browser/By\" class=\"code-anchor\">By</a> } from '@angular/platform-browser';\n\n</code-example>\n<p>위 예제에서 <code>DebugElement.query()</code>라고 구현했던 것을 <code>By.css</code> 메서드로 바꿔보면 이렇습니다.</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v4-test-5\">\nit('should find the &#x3C;p> with fixture.debugElement.query(By.css)', () => {\n  const bannerDe: <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> = fixture.debugElement;\n  const paragraphDe = bannerDe.query(By.css('p'));\n  const p: HTMLElement = paragraphDe.nativeElement;\n  expect(p.textContent).toEqual('banner works!');\n});\n\n</code-example>\n<p>이런 내용을 확인해 보세요:</p>\n<ul>\n<li>\n<p><code><a href=\"api/platform-browser/By#css\" class=\"code-anchor\">By.css()</a></code> 정적 메서드는 <a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started/Selectors\" title=\"CSS selectors\">표준 CSS 셀렉터</a>에 해당하는 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 노드를 찾습니다.</p>\n</li>\n<li>\n<p><code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 에서 <code>&#x3C;p></code> 엘리먼트를 찾습니다.</p>\n</li>\n<li>\n<p>쿼리 결과는 <code>nativeElement</code>로 참조해야 합니다.</p>\n</li>\n</ul>\n<p>그런데 브라우저에서는 엘리먼트를 찾을 때 <code>By.css</code>를 사용하는 것이 조금 과할 수 있습니다.</p>\n<p>상황에 따라 <code>HTMLElement</code>가 제공하는 <code>querySelector()</code>나 <code>querySelectorAll()</code>을 사용하는 것이 나을 수 있습니다.</p>\n\n</div>\n\n<!-- links to this doc:\n - guide/testing\n - guide/testing-components-scenarios\n-->\n<!-- links from this doc:\n - api/animations/query\n - api/core/Component\n - api/core/DebugElement\n - api/core/DebugElement#nativeElement\n - api/core/EventEmitter\n - api/core/Input\n - api/core/OnInit\n - api/core/Output\n - api/core/testing/ComponentFixture\n - api/core/testing/ComponentFixture#nativeElement\n - api/core/testing/TestBed\n - api/core/testing/waitForAsync\n - api/platform-browser/BrowserModule\n - api/platform-browser/By\n - api/platform-browser/By#css\n - guide/lifecycle-hooks\n - guide/testing-components-basics#angular-cli가-생성한-테스트-코드\n - guide/testing-components-basics#beforeeach\n - guide/testing-components-basics#bycss\n - guide/testing-components-basics#component-fixture\n - guide/testing-components-basics#componentfixture\n - guide/testing-components-basics#createcomponent\n - guide/testing-components-basics#debugelement\n - guide/testing-components-basics#nativeelement\n - guide/testing-components-basics#컴포넌트-dom-테스트하기\n - guide/testing-components-basics#컴포넌트-클래스-테스트하기\n - guide/testing-components-basics#컴포넌트-테스트-기본\n - guide/testing-components-basics#환경설정-코드-줄이기\n - guide/testing-components-scenarios#waitForAsync\n - guide/testing-services\n - https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API\n - https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started/Selectors\n - https://github.com/angular/angular/edit/master/aio/content/guide/testing-components-basics.md?message=docs%3A%20describe%20your%20change...\n-->"
}