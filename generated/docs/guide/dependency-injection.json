{
  "id": "guide/dependency-injection",
  "title": "Angular의 의존성 주입",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/dependency-injection.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Dependency injection in Angular\n-->\n<h1 id=\"angular의-의존성-주입\">Angular의 의존성 주입<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#angular의-의존성-주입\"><i class=\"material-icons\">link</i></a></h1>\n<!--\nDependency injection (DI), is an important application design pattern.\nAngular has its own DI framework, which is typically\nused in the design of Angular applications to increase their efficiency and modularity.\n\nDependencies are services or objects that a class needs to perform its function.\nDI is a coding pattern in which a class asks for dependencies from external sources rather than creating them itself.\n\nIn Angular, the DI framework provides declared dependencies to a class when that class is instantiated. This guide explains how DI works in Angular, and how you use it to make your apps flexible, efficient, and robust, as well as testable and maintainable.\n\n<div class=\"alert is-helpful\">\n\n You can run the <live-example></live-example> of the sample app that accompanies this guide.\n\n</div>\n\nStart by reviewing this simplified version of the _heroes_ feature\nfrom the [The Tour of Heroes](tutorial/). This simple version doesn't use DI; we'll walk through converting it to do so.\n\n<code-tabs>\n  <code-pane header=\"src/app/heroes/heroes.component.ts\" path=\"dependency-injection/src/app/heroes/heroes.component.1.ts\" region=\"v1\">\nimport { Component } from &#39;@angular/core&#39;;\n\n@Component({\n  selector: &#39;app-heroes&#39;,\n  template: `\n    &lt;h2&gt;Heroes&lt;/h2&gt;\n    &lt;app-hero-list&gt;&lt;/app-hero-list&gt;\n  `\n})\nexport class HeroesComponent { }\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/heroes/hero-list.component.ts\" path=\"dependency-injection/src/app/heroes/hero-list.component.1.ts\">\nimport { Component } from &#39;@angular/core&#39;;\nimport { HEROES } from &#39;./mock-heroes&#39;;\n\n@Component({\n  selector: &#39;app-hero-list&#39;,\n  template: `\n    &lt;div *ngFor=&quot;let hero of heroes&quot;&gt;\n      {{hero.id}} - {{hero.name}}\n    &lt;/div&gt;\n  `\n})\nexport class HeroListComponent {\n  heroes = HEROES;\n}\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/heroes/hero.ts\" path=\"dependency-injection/src/app/heroes/hero.ts\">\nexport interface Hero {\n  id: number;\n  name: string;\n  isSecret: boolean;\n}\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/heroes/mock-heroes.ts\" path=\"dependency-injection/src/app/heroes/mock-heroes.ts\">\nimport { Hero } from &#39;./hero&#39;;\n\nexport const HEROES: Hero[] = [\n  { id: 11, isSecret: false, name: &#39;Dr Nice&#39; },\n  { id: 12, isSecret: false, name: &#39;Narco&#39; },\n  { id: 13, isSecret: false, name: &#39;Bombasto&#39; },\n  { id: 14, isSecret: false, name: &#39;Celeritas&#39; },\n  { id: 15, isSecret: false, name: &#39;Magneta&#39; },\n  { id: 16, isSecret: false, name: &#39;RubberMan&#39; },\n  { id: 17, isSecret: false, name: &#39;Dynama&#39; },\n  { id: 18, isSecret: true,  name: &#39;Dr IQ&#39; },\n  { id: 19, isSecret: true,  name: &#39;Magma&#39; },\n  { id: 20, isSecret: true,  name: &#39;Tornado&#39; }\n];\n\n\n</code-pane>\n\n</code-tabs>\n\n`HeroesComponent` is the top-level heroes component.\nIts only purpose is to display `HeroListComponent`, which displays a list of hero names.\n\nThis version of the `HeroListComponent` gets heroes from the `HEROES` array, an in-memory collection\ndefined in a separate `mock-heroes` file.\n\n<code-example header=\"src/app/heroes/hero-list.component.ts (class)\" path=\"dependency-injection/src/app/heroes/hero-list.component.1.ts\" region=\"class\">\nexport class HeroListComponent {\n  heroes = HEROES;\n}\n\n</code-example>\n\nThis approach works for prototyping, but is not robust or maintainable.\nAs soon as you try to test this component or get heroes from a remote server,\nyou have to change the implementation of `HeroesListComponent` and\nreplace every use of the `HEROES` mock data.\n-->\n<p>의존성 주입(Dependency injection, DI)은 애플리케이션 디자인 패턴 중에서도 아주 중요한 패턴입니다.\nAngular는 독자적인 의존성 주입 시스템을 제공하고 있기 때문에, 이 패턴을 활용하면 Angular 애플리케이션을 좀 더 효율적인 모듈 형태로 구성할 수 있습니다.</p>\n<p>의존성 객체(dependencies)는 어떤 클래스가 동작하기 위해 필요한 서비스나 객체를 의미합니다.\n그리고 의존성 주입 패턴은 이 의존성 객체를 직접 생성하지 않고 외부 어딘가에서 받아오도록 요청하는 패턴입니다.</p>\n<p>Angular에서는 클래스의 인스턴스가 생성될 때 이 클래스에 필요한 의존성을 프레임워크가 생성해서 전달합니다. 이 문서는 Angular에서 의존성 주입이 어떻게 동작하는지, 의존성 주입을 활용하면 애플리케이션을 얼마나 효율적이면서 유연한 구조로 작성할 수 있는지 설명합니다. 의존성 주입을 사용하면 테스트하기 편하고 유지보수하기도 좋은 애플리케이션을 구현할 수 있습니다.</p>\n<div class=\"alert is-helpful\">\n<p>이 문서에서 설명하는 예제는 <live-example></live-example>에서 직접 실행하거나 다운받아 확인할 수 있습니다.</p>\n</div>\n<p><a href=\"tutorial/\">히어로들의 여행</a>에서 살펴본 예제를 간단하게 재작성한 코드부터 시작해 봅시다. 이 예제에는 아직 의존성 주입이 사용되지 않았습니다. 이 코드에 의존성 주입을 구현해 봅시다.</p>\n<code-tabs>\n  <code-pane header=\"src/app/heroes/heroes.component.ts\" path=\"dependency-injection/src/app/heroes/heroes.component.1.ts\" region=\"v1\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-heroes',\n  template: `\n    &#x3C;h2>Heroes&#x3C;/h2>\n    &#x3C;app-hero-list>&#x3C;/app-hero-list>\n  `\n})\nexport class HeroesComponent { }\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/heroes/hero-list.component.ts\" path=\"dependency-injection/src/app/heroes/hero-list.component.1.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { HEROES } from './mock-heroes';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-list',\n  template: `\n    &#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">\n      {{hero.id}} - {{hero.name}}\n    &#x3C;/div>\n  `\n})\nexport class HeroListComponent {\n  heroes = HEROES;\n}\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/heroes/hero.ts\" path=\"dependency-injection/src/app/heroes/hero.ts\">\nexport interface Hero {\n  id: number;\n  name: string;\n  isSecret: boolean;\n}\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/heroes/mock-heroes.ts\" path=\"dependency-injection/src/app/heroes/mock-heroes.ts\">\nimport { Hero } from './hero';\n\nexport const HEROES: Hero[] = [\n  { id: 11, isSecret: false, name: 'Dr Nice' },\n  { id: 12, isSecret: false, name: 'Narco' },\n  { id: 13, isSecret: false, name: 'Bombasto' },\n  { id: 14, isSecret: false, name: 'Celeritas' },\n  { id: 15, isSecret: false, name: 'Magneta' },\n  { id: 16, isSecret: false, name: 'RubberMan' },\n  { id: 17, isSecret: false, name: 'Dynama' },\n  { id: 18, isSecret: true,  name: 'Dr IQ' },\n  { id: 19, isSecret: true,  name: 'Magma' },\n  { id: 20, isSecret: true,  name: 'Tornado' }\n];\n\n\n</code-pane>\n\n</code-tabs>\n<p>최상위 컴포넌트는 <code>HeroesComponent</code>입니다.\n이 컴포넌트의 목적은 <code>HeroListComponent</code>를 사용해서 화면에 히어로 목록을 표시하는 것입니다.</p>\n<p>지금 구현한 <code>HeroListComponent</code>는 <code>mock-heroes</code> 파일에 정의된 <code>HEROES</code> 배열을 메모리에 올려서 참조합니다.</p>\n<code-example header=\"src/app/heroes/hero-list.component.ts (클래스)\" path=\"dependency-injection/src/app/heroes/hero-list.component.1.ts\" region=\"class\">\nexport class HeroListComponent {\n  heroes = HEROES;\n}\n\n</code-example>\n<p>이 방식은 프로토타이핑 할 때 적합한 방식이지만 실제 운영환경에는 적합하지 않습니다.\n왜냐하면 이 컴포넌트에 테스트를 적용하거나 리모트 서버에서 데이터를 가져오도록 변경한다면 <code>HeroesListComponent</code>를 반드시 수정해야 하며, 상황에 따라 매번 <code>HEROES</code> 목 데이터를 변경해야 할 수도 있기 때문입니다.</p>\n<!--\n## Create and register an injectable service\n-->\n<h2 id=\"의존성-주입-가능한-서비스-생성하고-등록하기\">의존성 주입 가능한 서비스 생성하고 등록하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#의존성-주입-가능한-서비스-생성하고-등록하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe DI framework lets you supply data to a component from an injectable _service_ class, defined in its own file. To demonstrate, we'll create an injectable service class that provides a list of heroes, and register that class as a provider of that service.\n\n<div class=\"alert is-helpful\">\n\nHaving multiple classes in the same file can be confusing. We generally recommend that you define components and services in separate files.\n\nIf you do combine a component and service in the same file,\nit is important to define the service first, and then the component. If you define the component before the service, you get a run-time null reference error.\n\nIt is possible to define the component first with the help of the `forwardRef()` method as explained in this [blog post](http://blog.thoughtram.io/angular/2015/09/03/forward-references-in-angular-2.html).\n\nYou can also use forward references to break circular dependencies.\nSee an example in the [DI Cookbook](guide/dependency-injection-in-action#forwardref).\n\n</div>\n-->\n<p>파일에 정의해 둔 목 데이터를 <em>서비스</em> 클래스로 감싸서 컴포넌트에 주입할 수 있습니다. 이 내용을 확인해보기 위해 히어로의 목록을 제공하는 서비스 클래스를 정의하고 이 클래스를 의존성 주입할 수 있도록 등록해 봅시다.</p>\n<div class=\"alert is-helpful\">\n<p>한 파일에 클래스를 여러개 정의하면 이 파일을 접하는 많은 사람들에게 혼란을 줄 수 있습니다. 일반적으로 컴포넌트와 서비스는 파일 하나에 하나씩 정의하는 것을 권장합니다.</p>\n<p>그런데 어떤 이유로 컴포넌트와 서비스를 한 파일에 정의해야 한다면 서비스를 먼저 정의하고 컴포넌트를 나중에 정의하세요. 서비스보다 컴포넌트를 먼저 정의하면 런타임 null 참조 에러가 발생합니다.</p>\n<p>그리고 <a href=\"http://blog.thoughtram.io/angular/2015/09/03/forward-references-in-angular-2.html\">이 블로그</a>에서 설명한 것처럼 <code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>()</code> 메소드를 사용하면 컴포넌트를 먼저 정의할 수도 있습니다.</p>\n<p><code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>()</code> 메소드는 순환 참조를 방지할 때도 사용합니다.\n<a href=\"guide/dependency-injection-in-action#forwardref\">DI Cookbook</a>에서 설명하는 예제를 참고하세요.</p>\n</div>\n<!--\n### Create an injectable service class\n-->\n<h3 id=\"의존성으로-주입할-서비스-클래스-정의하기\">의존성으로 주입할 서비스 클래스 정의하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#의존성으로-주입할-서비스-클래스-정의하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe [Angular CLI](cli) can generate a new `HeroService` class in the `src/app/heroes` folder with this command.\n\n<code-example language=\"sh\" class=\"code-shell\">\nng generate service heroes/hero\n</code-example>\n\nThe command creates the following `HeroService` skeleton.\n\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.0.ts\" header=\"src/app/heroes/hero.service.ts (CLI-generated)\">\nimport { Injectable } from &#39;@angular/core&#39;;\n\n@Injectable({\n  providedIn: &#39;root&#39;,\n})\nexport class HeroService {\n  constructor() { }\n}\n\n\n</code-example>\n\nThe `@Injectable()` is an essential ingredient in every Angular service definition. The rest of the class has been written to expose a `getHeroes` method that returns the same mock data as before. (A real app would probably get its data asynchronously from a remote server, but we'll ignore that to focus on the mechanics of injecting the service.)\n\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.3.ts\" header=\"src/app/heroes/hero.service.ts\">\nimport { Injectable } from &#39;@angular/core&#39;;\nimport { HEROES } from &#39;./mock-heroes&#39;;\n\n@Injectable({\n  // 이 서비스를 애플리케이션 최상위 인젝터에 등록합니다.\n  providedIn: &#39;root&#39;,\n})\nexport class HeroService {\n  getHeroes() { return HEROES; }\n}\n\n\n</code-example>\n-->\n<p><a href=\"cli\">Angular CLI</a>를 사용해서 <code>src/app/heroes</code> 폴더에 <code>HeroService</code> 클래스를 생성하려면 다음 명령을 실행하면 됩니다.</p>\n<code-example language=\"sh\" class=\"code-shell\">\nng generate service heroes/hero\n</code-example>\n<p>이 명령을 실행하면 다음과 같은 <code>HeroService</code> 기본 코드가 생성됩니다.</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.0.ts\" header=\"src/app/heroes/hero.service.ts (CLI 실행 결과)\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class HeroService {\n  constructor() { }\n}\n\n\n</code-example>\n<p>Angular 서비스를 정의하는 코드에서 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code>이 가장 중요합니다. 그리고 이전에 목 데이터를 반환하던 로직은 클래스 코드에서 <code>getHeroes</code> 메소드가 제공하도록 하려면 다음과 같이 구현할 수 있습니다. (실제 앱에서는 목 데이터를 반환하는 대신 리모트 서버에서 비동기로 데이터를 가져오게 될 것입니다. 지금은 서비스를 의존성으로 주입하는 것에만 집중하기 위해 이 부분은 생략합니다.)</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.3.ts\" header=\"src/app/heroes/hero.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { HEROES } from './mock-heroes';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  // 이 서비스를 애플리케이션 최상위 인젝터에 등록합니다.\n  providedIn: 'root',\n})\nexport class HeroService {\n  getHeroes() { return HEROES; }\n}\n\n\n</code-example>\n<a id=\"injector-config\"></a>\n<a id=\"bootstrap\"></a>\n<!--\n### Configure an injector with a service provider\n-->\n<h3 id=\"서비스-프로바이더를-인젝터에-등록하기\">서비스 프로바이더를 인젝터에 등록하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#서비스-프로바이더를-인젝터에-등록하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe class we have created provides a service. The `@Injectable()` decorator marks it as a service\nthat can be injected, but Angular can't actually inject it anywhere until you configure\nan Angular [dependency injector](guide/glossary#injector) with a [provider](guide/glossary#provider) of that service.\n\nThe injector is responsible for creating service instances and injecting them into classes like `HeroListComponent`.\nYou rarely create an Angular injector yourself. Angular creates injectors for you as it executes the app, starting with the _root injector_ that it creates during the [bootstrap process](guide/bootstrapping).\n\nA provider tells an injector _how to create the service_.\nYou must configure an injector with a provider before that injector can create a service (or provide any other kind of dependency).\n\nA provider can be the service class itself, so that the injector can use `new` to create an instance.\nYou might also define more than one class to provide the same service in different ways,\nand configure different injectors with different providers.\n\n<div class=\"alert is-helpful\">\n\nInjectors are inherited, which means that if a given injector can't resolve a dependency,\nit asks the parent injector to resolve it.\nA component can get services from its own injector,\nfrom the injectors of its component ancestors,\nfrom the injector of its parent NgModule, or from the `root` injector.\n\n* Learn more about the [different kinds of providers](guide/dependency-injection-providers).\n\n* Learn more about how the [injector hierarchy](guide/hierarchical-dependency-injection) works.\n\n</div>\n\nYou can configure injectors with providers at different levels of your app, by setting a metadata value in one of three places:\n\n* In the `@Injectable()` decorator for the service itself.\n\n* In the `@NgModule()` decorator for an NgModule.\n\n* In the `@Component()` decorator for a component.\n\nThe `@Injectable()` decorator has the `providedIn` metadata option, where you can specify the provider of the decorated service class with the `root` injector, or with the injector for a specific NgModule.\n\nThe `@NgModule()` and `@Component()` decorators have the `providers` metadata option, where you can configure providers for NgModule-level or component-level injectors.\n\n<div class=\"alert is-helpful\">\n\nComponents are directives, and the `providers` option is inherited from `@Directive()`. You can also configure providers for directives and pipes at the same level as the component.\n\nLearn more about [where to configure providers](guide/hierarchical-dependency-injection).\n\n</div>\n-->\n<p>이렇게 만든 클래스는 Angular가 서비스로 인식하고 의존성으로 주입할 수 있도록 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 데코레이터를 사용해서 <a href=\"guide/glossary#injector\">인젝터</a>에 <a href=\"guide/glossary#provider\">프로바이더</a>로 등록해야 합니다.</p>\n<p>서비스의 인스턴스를 생성하고 <code>HeroListComponent</code>와 같은 클래스에 주입하는 것은 인젝터의 역할입니다.\nAngular 애플리케이션을 개발하면서 인젝터를 직접 생성해야 하는 일은 거의 없습니다. 인젝터는 애플리케이션이 <a href=\"guide/bootstrapping\">부트스트랩</a>되는 과정에 <em>최상위 인젝터</em> 부터 트리를 따라가면서 Angular가 생성합니다.</p>\n<p>인젝터는 프로바이더에 등록된 방법으로 서비스의 인스턴스를 생성합니다.\n그래서 서비스나 다른 형태의 의존성 객체를 의존성으로 주입하려면 먼저 인젝터에 프로바이더를 등록해야 합니다.</p>\n<p>프로바이더에 서비스 클래스를 그대로 등록하면 인젝터는 <code>new</code> 키워드를 사용해서 인스턴스를 생성합니다.\n여러 클래스를 같은 서비스 타입으로 인젝터에 등록할 수 있으며, 서로 다른 프로바이더를 각기 다른 인젝터에 등록할 수도 있습니다.</p>\n<div class=\"alert is-helpful\">\n<p>현재 계층에서 인젝터가 의존성 객체를 찾지 못하면 부모 인젝터에서 의존성 객체를 찾기 때문에 인젝터는 상속된다고도 할 수 있습니다.\n컴포넌트의 경우에 의존성으로 주입되는 서비스를 컴포넌트 인젝터에서 찾지 못하면 부모 인젝터에서 다시 찾으며, 이 과정은 부모 NgModule을 거쳐 최상위 인젝터에 도달할 때까지 반복됩니다.</p>\n<ul>\n<li>\n<p>프로바이더의 종류에 대해 알아보려면 <a href=\"guide/dependency-injection-providers\">의존성 주입 프로바이더</a> 문서를 참고하세요.</p>\n</li>\n<li>\n<p>인젝터의 계층에 대해 알아보려면 <a href=\"guide/hierarchical-dependency-injection\">인젝터 계층</a> 문서를 참고하세요.</p>\n</li>\n</ul>\n</div>\n<p>프로바이더는 다음과 같이 다양한 계층에 등록할 수 있습니다:</p>\n<ul>\n<li>\n<p>서비스 클래스에서 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 데코레이터로 직접 등록할 수 있습니다.</p>\n</li>\n<li>\n<p>NgModule의 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> 데코레이터에 등록할 수 있습니다.</p>\n</li>\n<li>\n<p>컴포넌트의 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 데코레이터에 등록할 수 있습니다.</p>\n</li>\n</ul>\n<p><code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 데코레이터를 사용할 때 <code>providedIn</code> 메타데이터 옵션을 지정하면 이 서비스가 <code>root</code> 인젝터에 등록될지, 특정 NgModule에 등록될지 지정할 수 있습니다.</p>\n<p><code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code>이나 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 데코레이터에서 <code>providers</code> 메타데이터 옵션을 사용하면 NgModule 계층이나 컴포넌트 계층의 인젝터에 프로바이더를 등록할 수 있습니다.</p>\n<div class=\"alert is-helpful\">\n<p>컴포넌트도 디렉티브이기 때문에 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code>에서도 <code>providers</code> 옵션을 사용할 수 있으며, 이렇게 등록한 프로바이더도 상속된다고 볼 수 있습니다. 프로바이더는 컴포넌트 계층에 등록하는 것처럼 디렉티브나 파이프 계층에 등록할 수도 있습니다.</p>\n<p>자세한 내용은 <a href=\"guide/hierarchical-dependency-injection\">프로바이더는 어디에 등록해야 할까</a> 문서를 참고하세요.</p>\n</div>\n<a id=\"injector-config\"></a>\n<a id=\"bootstrap\"></a>\n<!--\n## Injecting services\n-->\n<h2 id=\"서비스-주입하기\">서비스 주입하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#서비스-주입하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nIn order for `HeroListComponent` to get heroes from `HeroService`, it needs to ask for `HeroService` to be injected, rather than creating its own `HeroService` instance with `new`.\n\nYou can tell Angular to inject a dependency in a component's constructor by specifying a **constructor parameter with the dependency type**. Here's the `HeroListComponent` constructor, asking for the `HeroService` to be injected.\n\n<code-example header=\"src/app/heroes/hero-list.component (constructor signature)\" path=\"dependency-injection/src/app/heroes/hero-list.component.ts\" region=\"ctor-signature\">\nconstructor(heroService: HeroService)\n\n</code-example>\n\nOf course, `HeroListComponent` should do something with the injected `HeroService`.\nHere's the revised component, making use of the injected service, side-by-side with the previous version for comparison.\n\n<code-tabs>\n  <code-pane header=\"hero-list.component (with DI)\" path=\"dependency-injection/src/app/heroes/hero-list.component.2.ts\">\nimport { Component } from &#39;@angular/core&#39;;\nimport { Hero } from &#39;./hero&#39;;\nimport { HeroService } from &#39;./hero.service&#39;;\n\n@Component({\n  selector: &#39;app-hero-list&#39;,\n  template: `\n    &lt;div *ngFor=&quot;let hero of heroes&quot;&gt;\n      {{hero.id}} - {{hero.name}}\n    &lt;/div&gt;\n  `\n})\nexport class HeroListComponent {\n  heroes: Hero[];\n\n  constructor(heroService: HeroService) {\n    this.heroes = heroService.getHeroes();\n  }\n}\n\n\n</code-pane>\n\n  <code-pane header=\"hero-list.component (without DI)\" path=\"dependency-injection/src/app/heroes/hero-list.component.1.ts\">\nimport { Component } from &#39;@angular/core&#39;;\nimport { HEROES } from &#39;./mock-heroes&#39;;\n\n@Component({\n  selector: &#39;app-hero-list&#39;,\n  template: `\n    &lt;div *ngFor=&quot;let hero of heroes&quot;&gt;\n      {{hero.id}} - {{hero.name}}\n    &lt;/div&gt;\n  `\n})\nexport class HeroListComponent {\n  heroes = HEROES;\n}\n\n\n</code-pane>\n</code-tabs>\n\n`HeroService` must be provided in some parent injector. The code in `HeroListComponent` doesn't depend on where `HeroService` comes from.\nIf you decided to provide `HeroService` in `AppModule`, `HeroListComponent` wouldn't change.\n-->\n<p><code>HeroListComponent</code>가 <code>HeroService</code>에서 히어로 목록을 가져오려면 이 서비스의 인스턴스가 주입되어야 하는데, 의존성 주입 패턴을 사용하면 컴포넌트에서 <code>new</code> 키워드로 <code>HeroService</code> 인스턴스를 직접 생성하는 대신 <code>HeroService</code>가 주입되도록 요청해야 합니다.</p>\n<p>이 때 의존성 객체는 <strong>생성자의 인자에 의존성으로 주입될 객체의 타입</strong>을 지정하는 방식으로 Angular 프레임워크에게 요청합니다. 다음 코드는 <code>HeroListComponent</code>의 생성자로 <code>HeroService</code>를 주입하도록 요청하는 코드입니다.</p>\n<code-example header=\"src/app/heroes/hero-list.component (생성자 선언부)\" path=\"dependency-injection/src/app/heroes/hero-list.component.ts\" region=\"ctor-signature\">\nconstructor(heroService: HeroService)\n\n</code-example>\n<p>당연히 <code>HeroListComponent</code>는 주입받은 <code>HeroService</code>로 무언가를 할 것입니다.\n의존성 주입을 사용하는 컴포넌트와 사용하지 않는 코드를 비교하면서 어떤 점이 다른지 확인해 보세요.</p>\n<code-tabs>\n  <code-pane header=\"hero-list.component (with DI)\" path=\"dependency-injection/src/app/heroes/hero-list.component.2.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { Hero } from './hero';\nimport { HeroService } from './hero.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-list',\n  template: `\n    &#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">\n      {{hero.id}} - {{hero.name}}\n    &#x3C;/div>\n  `\n})\nexport class HeroListComponent {\n  heroes: Hero[];\n\n  constructor(heroService: HeroService) {\n    this.heroes = heroService.getHeroes();\n  }\n}\n\n\n</code-pane>\n\n  <code-pane header=\"hero-list.component (without DI)\" path=\"dependency-injection/src/app/heroes/hero-list.component.1.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { HEROES } from './mock-heroes';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-list',\n  template: `\n    &#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">\n      {{hero.id}} - {{hero.name}}\n    &#x3C;/div>\n  `\n})\nexport class HeroListComponent {\n  heroes = HEROES;\n}\n\n\n</code-pane>\n</code-tabs>\n<p><code>HeroService</code>는 부모 인젝터 중 어딘가에 반드시 등록되어야 하지만, <code>HeroListComponent</code>의 입장에서는 <code>HeroService</code>가 어디에 등록되어 있는지는 중요하지 않습니다.\n<code>HeroService</code>가 등록된 위치를 <code>AppModule</code>로 옮겨도 <code>HeroListComponent</code> 코드는 변경할 필요가 없습니다.</p>\n<a id=\"singleton-services\"></a>\n<a id=\"component-child-injectors\"></a>\n<!--\n### Injector hierarchy and service instances\n-->\n<h3 id=\"인젝터-계층과-서비스-인스턴스\">인젝터 계층과 서비스 인스턴스<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#인젝터-계층과-서비스-인스턴스\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nServices are singletons _within the scope of an injector_. That is, there is at most one instance of a service in a given injector.\n\nThere is only one root injector for an app. Providing `UserService` at the `root` or `AppModule` level means it is registered with the root injector. There is just one `UserService` instance in the entire app and every class that injects `UserService` gets this service instance _unless_ you configure another provider with a _child injector_.\n\nAngular DI has a [hierarchical injection system](guide/hierarchical-dependency-injection), which means that nested injectors can create their own service instances.\nAngular regularly creates nested injectors. Whenever Angular creates a new instance of a component that has `providers` specified in `@Component()`, it also creates a new _child injector_ for that instance.\nSimilarly, when a new NgModule is lazy-loaded at run time, Angular can create an injector for it with its own providers.\n\nChild modules and component injectors are independent of each other, and create their own separate instances of the provided services. When Angular destroys an NgModule or component instance, it also destroys that injector and that injector's service instances.\n\nThanks to [injector inheritance](guide/hierarchical-dependency-injection),\nyou can still inject application-wide services into these components.\nA component's injector is a child of its parent component's injector, and inherits from all ancestor injectors all the way back to the application's _root_ injector. Angular can inject a service provided by any injector in that lineage.\n\nFor example, Angular can inject `HeroListComponent` with both the `HeroService` provided in `HeroComponent` and the `UserService` provided in `AppModule`.\n-->\n<p>서비스는 <em>인젝터의 범위 안에서</em> 싱글턴으로 존재합니다. 그래서 인젝터에 존재하는 서비스의 인스턴스는 언제나 하나씩입니다.</p>\n<p>애플리케이션에 존재하는 최상위 인젝터는 언제나 하나입니다. 그래서 <code>root</code>나 <code>AppModule</code> 계층에 <code>UserService</code>를 등록한다는 것은 모두 서비스 프로바이더를 최상위 인젝터에 등록한다는 것을 의미합니다. 그러면 애플리케이션 전체 범위에서 <code>UserService</code> 인스턴스가 단 하나만 존재하며, <em>자식 인젝터</em> 에 다시 프로바이더를 등록하지 않는 한 모두 같은 <code>UserService</code>를 주입받게 됩니다.</p>\n<p>Angular가 제공하는 의존성 주입 시스템은 <a href=\"guide/hierarchical-dependency-injection\">인젝터를 계층 구조로 구성</a>하기 때문에 자식 인젝터에서 서비스 인스턴스를 별개로 생성할 수도 있습니다.\nAngular는 중첩된 인젝터를 빈번하게 생성합니다. <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 데코레이터에 <code>providers</code>가 지정되어 있으면 컴포넌트의 인스턴스를 새로 만들 때마다 이 컴포넌트 인스턴스에 새로운 <em>자식 인젝터</em> 를 생성하며, 지연로딩되는 NgModule에 새로운 인젝터를 생성하기도 합니다.</p>\n<p>자식 모듈과 컴포넌트에 생성된 인젝터는 모두 독립적이기 때문에 서비스 인스턴스도 인젝터마다 따로 생성됩니다. 이렇게 생성된 서비스 인스턴스는 해당 NgModule이나 해당 컴포넌트가 종료되면서 함께 종료됩니다.</p>\n<p><a href=\"guide/hierarchical-dependency-injection\">인젝터는 계층 구조로 구성</a>되기 때문에 애플리케이션 계층에 등록한 서비스도 컴포넌트에 주입할 수 있습니다.\n왜냐하면 컴포넌트의 인젝터는 부모 컴포넌트 인젝터의 자식 인젝터인데, 이 관계는 애플리케이션의 <em>최상위</em> 인젝터에 도달할 때까지 동일하기 때문입니다. 부모 계층의 인젝터에 등록된 서비스는 자식 계층에 자유롭게 주입될 수 있습니다.</p>\n<p>그래서 <code>AppModule</code>에 등록된 <code>UserService</code>와 <code>HeroComponent</code>에 등록된 <code>HeroService</code> 모두 <code>HeroListComponent</code>에 주입할 수 있습니다.</p>\n<a id=\"testing-the-component\"></a>\n<!--\n## Testing components with dependencies\n-->\n<h2 id=\"의존성-객체가-있는-컴포넌트-테스트하기\">의존성 객체가 있는 컴포넌트 테스트하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#의존성-객체가-있는-컴포넌트-테스트하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nDesigning a class with dependency injection makes the class easier to test.\nListing dependencies as constructor parameters may be all you need to test application parts effectively.\n\nFor example, you can create a new `HeroListComponent` with a mock service that you can manipulate\nunder test.\n\n<code-example path=\"dependency-injection/src/app/test.component.ts\" region=\"spec\" header=\"src/app/test.component.ts\">\nconst expectedHeroes = [{name: &#39;A&#39;}, {name: &#39;B&#39;}]\nconst mockService = &lt;HeroService&gt; {getHeroes: () =&gt; expectedHeroes }\n\nit(&#39;should have heroes when HeroListComponent created&#39;, () =&gt; {\n  // 목 객체를 생성자에 전달하면 Angular 인젝터가 알아서 처리합니다.\n  const component = new HeroListComponent(mockService);\n  expect(component.heroes.length).toEqual(expectedHeroes.length);\n});\n\n</code-example>\n\n<div class=\"alert is-helpful\">\n\nLearn more in the [Testing](guide/testing) guide.\n\n</div>\n-->\n<p>의존성 주입을 활용하면 클래스를 테스트하기도 편합니다.\n의존성으로 주입받을 객체의 타입을 생성자 인자에 지정하기만 하면 프레임워크가 모든 것을 처리합니다.</p>\n<p>예를 들어 테스트 환경에서 <code>HeroListComponent</code>의 새 인스턴스를 생성하는데 목 서비스를 대신 주입하려면 다음과 같이 구성하면 됩니다.</p>\n<code-example path=\"dependency-injection/src/app/test.component.ts\" region=\"spec\" header=\"src/app/test.component.ts\">\nconst expectedHeroes = [{name: 'A'}, {name: 'B'}]\nconst mockService = &#x3C;HeroService> {getHeroes: () => expectedHeroes }\n\nit('should have heroes when HeroListComponent created', () => {\n  // 목 객체를 생성자에 전달하면 Angular 인젝터가 알아서 처리합니다.\n  const component = new HeroListComponent(mockService);\n  expect(component.heroes.length).toEqual(expectedHeroes.length);\n});\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>자세한 내용은 <a href=\"guide/testing\">테스트</a> 문서를 참고하세요.</p>\n</div>\n<a id=\"service-needs-service\"></a>\n<!--\n## Services that need other services\n-->\n<h2 id=\"서비스에-다른-서비스-주입하기\">서비스에 다른 서비스 주입하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#서비스에-다른-서비스-주입하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nServices can have their own dependencies. `HeroService` is very simple and doesn't have any dependencies of its own. Suppose, however, that you want it to report its activities through a logging service. You can apply the same *constructor injection* pattern,\nadding a constructor that takes a `Logger` parameter.\n\nHere is the revised `HeroService` that injects `Logger`, side by side with the previous service for comparison.\n\n<code-tabs>\n\n  <code-pane header=\"src/app/heroes/hero.service (v2)\" path=\"dependency-injection/src/app/heroes/hero.service.2.ts\">\nimport { Injectable } from &#39;@angular/core&#39;;\nimport { HEROES } from &#39;./mock-heroes&#39;;\nimport { Logger } from &#39;../logger.service&#39;;\n\n@Injectable({\n  providedIn: &#39;root&#39;,\n})\nexport class HeroService {\n\n  constructor(private logger: Logger) {  }\n\n  getHeroes() {\n    this.logger.log(&#39;Getting heroes ...&#39;);\n    return HEROES;\n  }\n}\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/heroes/hero.service (v1)\" path=\"dependency-injection/src/app/heroes/hero.service.1.ts\">\nimport { Injectable } from &#39;@angular/core&#39;;\nimport { HEROES } from &#39;./mock-heroes&#39;;\n\n@Injectable({\n  providedIn: &#39;root&#39;,\n})\nexport class HeroService {\n  getHeroes() { return HEROES; }\n}\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/logger.service\" path=\"dependency-injection/src/app/logger.service.ts\">\nimport { Injectable } from &#39;@angular/core&#39;;\n\n@Injectable({\n  providedIn: &#39;root&#39;\n})\nexport class Logger {\n  logs: string[] = []; // 테스트하기 위해 로그를 저장합니다.\n\n  log(message: string) {\n    this.logs.push(message);\n    console.log(message);\n  }\n}\n\n\n</code-pane>\n\n</code-tabs>\n\nThe constructor asks for an injected instance of `Logger` and stores it in a private field called `logger`. The `getHeroes()` method logs a message when asked to fetch heroes.\n\nNotice that the `Logger` service also has the `@Injectable()` decorator, even though it might not need its own dependencies. In fact, the `@Injectable()` decorator is **required for all services**.\n\nWhen Angular creates a class whose constructor has parameters, it looks for type and injection metadata about those parameters so that it can inject the correct service.\nIf Angular can't find that parameter information, it throws an error.\nAngular can only find the parameter information _if the class has a decorator of some kind_.\nThe `@Injectable()` decorator is the standard decorator for service classes.\n\n<div class=\"alert is-helpful\">\n\n The decorator requirement is imposed by TypeScript. TypeScript normally discards parameter type information when it [transpiles](guide/glossary#transpile) the code to JavaScript. TypeScript preserves this information if the class has a decorator and the `emitDecoratorMetadata` compiler option is set `true` in TypeScript's `tsconfig.json` configuration file. The CLI configures `tsconfig.json` with `emitDecoratorMetadata: true`.\n\n This means you're responsible for putting `@Injectable()` on your service classes.\n\n</div>\n-->\n<p>서비스에도 의존성 주입이 필요할 때가 있습니다. 아직은 <code>HeroService</code> 로직이 아주 간단하며 추가 의존성도 필요하지 않지만, 이제 이 서비스에서 로그를 출력해야 한다고 합시다. 그러면 컴포넌트에 작성했던 것과 같은 방식으로 <em>생성자에 의존성을 주입하는</em> 패턴을 사용해서 <code>Logger</code> 서비스를 주입받을 수 있습니다.</p>\n<p><code>Logger</code>를 의존성으로 주입받는 <code>HeroService</code> 코드를 확인해 보세요.</p>\n<code-tabs>\n\n  <code-pane header=\"src/app/heroes/hero.service (v2)\" path=\"dependency-injection/src/app/heroes/hero.service.2.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { HEROES } from './mock-heroes';\nimport { Logger } from '../logger.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class HeroService {\n\n  constructor(private logger: Logger) {  }\n\n  getHeroes() {\n    this.logger.log('Getting heroes ...');\n    return HEROES;\n  }\n}\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/heroes/hero.service (v1)\" path=\"dependency-injection/src/app/heroes/hero.service.1.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { HEROES } from './mock-heroes';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class HeroService {\n  getHeroes() { return HEROES; }\n}\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/logger.service\" path=\"dependency-injection/src/app/logger.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root'\n})\nexport class Logger {\n  logs: string[] = []; // 테스트하기 위해 로그를 저장합니다.\n\n  log(message: string) {\n    this.logs.push(message);\n    console.log(message);\n  }\n}\n\n\n</code-pane>\n\n</code-tabs>\n<p>생성자는 <code>Logger</code> 타입의 객체를 의존성으로 주입하도록 요청한 후에 이 인스턴스를 <code>private</code> 프로퍼티 <code>logger</code>에 할당합니다. 그리고 <code>getHeroes()</code> 메소드에서 로그를 출력할 때 이 프로퍼티를 사용합니다.</p>\n<p>이 때 <code>Logger</code> 서비스에는 의존성 주입이 필요하지 않지만 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 데코레이터가 사용되었습니다. 실제로 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 데코레이터는 <strong>모든 서비스에 지정해야</strong> 합니다.</p>\n<p>Angular가 클래스 인스턴스를 생성하면서 생성자에 객체 타입이 지정된 것을 인식하면 이 타입을 기준으로 메타데이터를 검색하기 때문에 정확한 타입의 서비스가 주입될 수 있습니다.\n인젝터가 이 타입을 찾지 못하면 에러를 발생시킵니다.\nAngular는 의존성 객체를 찾을 때 <em>데코레이터가 사용된 클래스</em> 만 대상으로 합니다.\n그래서 서비스 클래스를 정의할 때 는<code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 데코레이터를 꼭 사용해야 합니다.</p>\n<div class=\"alert is-helpful\">\n<p>데코레이터는 TypeScript 문법을 활용한 것입니다. TypeScript에서 타입을 지정하는 문법은 JavaScript로 <a href=\"guide/glossary#transpile\">트랜스파일(transpile)</a>되면서 모두 사라지지만, <code>tsconfig.json</code> 파일에서 <code>emitDecoratorMetadata</code> 컴파일 옵션을 <code>true</code>로 지정하면 이 정보를 다른 형태로 저장할 수 있습니다.\n그래서 Angular CLI로 생성된 기본 <code>tsconfig.json</code> 파일에는 <code>emitDecoratorMetadata: true</code>가 지정되어 있으며, 이 옵션이 지정되어 있기 때문에 서비스 클래스에 <code>@Injetable()</code> 데코레이터를 지정할 수 있습니다.</p>\n</div>\n<a id=\"token\"></a>\n<a id=\"injection-token\"></a>\n<!--\n### Dependency injection tokens\n-->\n<h3 id=\"의존성-주입-토큰-dependency-injection-tokens\">의존성 주입 토큰 (Dependency injection tokens)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#의존성-주입-토큰-dependency-injection-tokens\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nWhen you configure an injector with a provider, you associate that provider with a [DI token](guide/glossary#di-token).\nThe injector maintains an internal *token-provider* map that it references when\nasked for a dependency. The token is the key to the map.\n\nIn simple examples, the dependency value is an *instance*, and\nthe class *type* serves as its own lookup key.\nHere you get a `HeroService` directly from the injector by supplying the `HeroService` type as the token:\n\n<code-example path=\"dependency-injection/src/app/injector.component.ts\" region=\"get-hero-service\" header=\"src/app/injector.component.ts\">\nheroService: HeroService;\n\n</code-example>\n\nThe behavior is similar when you write a constructor that requires an injected class-based dependency.\nWhen you define a constructor parameter with the `HeroService` class type,\nAngular knows to inject the service associated with that `HeroService` class token:\n\n<code-example path=\"dependency-injection/src/app/heroes/hero-list.component.ts\" region=\"ctor-signature\" header=\"src/app/heroes/hero-list.component.ts\">\nconstructor(heroService: HeroService)\n\n</code-example>\n\nMany dependency values are provided by classes, but not all. The expanded *provide* object lets you associate different kinds of providers with a DI token.\n\n* Learn more about [different kinds of providers](guide/dependency-injection-providers).\n-->\n<p>인젝터에 프로바이더를 등록한다는 것은 프로바이더와 <a href=\"guide/glossary#di-token\">의존성 주입 토큰</a>을 연결한다는 것을 의미합니다.\n인젝터는 인젝터 내부에 <em>토큰-프로바이더</em> 맵(map)을 관리하며 의존성 객체를 찾을 때 이 맵을 사용합니다. 이 때 토큰은 맵의 키(key)로 사용됩니다.</p>\n<p>의존성 주입을 간단하게 살펴볼 때 의존성으로 주입할 클래스의 <em>타입</em>은 키이며, 의존성으로 주입하는 <em>인스턴스</em>는 맵의 값(value)입니다.\n그래서 <code>HeroService</code>라고 타입을 지정하면 이 타입을 토큰으로 사용해서 <code>HeroService</code>의 인스턴스를 인젝터에서 찾을 수 있습니다:</p>\n<code-example path=\"dependency-injection/src/app/injector.component.ts\" region=\"get-hero-service\" header=\"src/app/injector.component.ts\">\nheroService: HeroService;\n\n</code-example>\n<p>의존성으로 주입할 객체가 클래스인 경우에도 비슷합니다.\n생성자의 인자에 타입을 <code>HeroService</code> 클래스 타입으로 지정하면 Angular는 <code>HeroService</code> 클래스 토큰에 해당하는 서비스의 인스턴스를 찾아서 의존성으로 주입합니다.</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero-list.component.ts\" region=\"ctor-signature\" header=\"src/app/heroes/hero-list.component.ts\">\nconstructor(heroService: HeroService)\n\n</code-example>\n<p>의존성 객체는 대부분 클래스로 등록하지만 항상 그런 것은 아닙니다. 하지만 객체를 <em>의존성으로 등록</em>할 때도 의존성 주입 토큰을 사용한다는 것은 동일합니다.</p>\n<ul>\n<li><a href=\"guide/dependency-injection-providers\">프로바이더를 다양한 형태로 등록하는 방법</a>에 대해 자세하게 확인해 보세요.</li>\n</ul>\n<a id=\"optional\"></a>\n<!--\n### Optional dependencies\n-->\n<h3 id=\"생략할-수-있는-의존성\">생략할 수 있는 의존성<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#생략할-수-있는-의존성\"><i class=\"material-icons\">link</i></a></h3>\n<!--\n`HeroService` *requires* a logger, but what if it could get by without\none?\n\nWhen a component or service declares a dependency, the class constructor takes that dependency as a parameter.\nYou can tell Angular that the dependency is optional by annotating the\nconstructor parameter with `@Optional()`.\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"import-optional\">\nimport { Optional } from &#39;@angular/core&#39;;\n\n</code-example>\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"provider-10-ctor\">\nconstructor(@Optional() private logger?: Logger) {\n  if (this.logger) {\n    this.logger.log(someMessage);\n  }\n}\n\n</code-example>\n\nWhen using `@Optional()`, your code must be prepared for a null value. If you\ndon't register a logger provider anywhere, the injector sets the\nvalue of `logger` to null.\n\n<div class=\"alert is-helpful\">\n\n`@Inject()` and `@Optional()` are _parameter decorators_. They alter the way the DI framework provides a dependency, by annotating the dependency parameter on the constructor of the class that requires the dependency.\n\nLearn more about parameter decorators in [Hierarchical Dependency Injectors](guide/hierarchical-dependency-injection).\n\n</div>\n-->\n<p><code>HeroService</code>는 <code>Logger</code> 서비스가 주입되도록 <em>요청</em> 하고 있지만 이 서비스를 생략해도 된다면 어떻게 해야 할까요?</p>\n<p>컴포넌트나 서비스에 의존성 객체 타입을 지정하면 클래스의 생성자로 해당 의존성 객체의 인스턴스가 전달됩니다.\n이 때 인자에 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 데코레이터를 사용하면 의존성 객체를 생략할 수 있다고 지정할 수 있습니다.</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"import-optional\">\nimport { <a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a> } from '@angular/core';\n\n</code-example>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"provider-10-ctor\">\nconstructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() private logger?: Logger) {\n  if (this.logger) {\n    this.logger.log(someMessage);\n  }\n}\n\n</code-example>\n<p><code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 데코레이터를 사용하는 경우에는 주입되는 객체의 인스턴스가 <code>null</code>인 경우도 고려해야 합니다. <code>Logger</code> 서비스가 어디에도 등록되어 있지 않으면 <code>logger</code> 프로퍼티에 <code>null</code> 값이 할당됩니다.</p>\n<div class=\"alert is-helpful\">\n<p><code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>()</code>와 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code>은 <em>인자에 사용하는 데코레이터</em> 입니다. 이 데코레이터를 사용하면 의존성 주입 프레임워크가 의존성을 주입하는 방식을 변경할 수 있습니다.</p>\n<p>인자에 사용하는 데코레이터에 대해 더 자세하게 알아보려면 <a href=\"guide/hierarchical-dependency-injection\">인젝터 계층</a> 문서를 확인하세요.</p>\n</div>\n<!--\n## Summary\n-->\n<h2 id=\"정리\">정리<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#정리\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nYou learned the basics of Angular dependency injection in this page.\nYou can register various kinds of providers,\nand you know how to ask for an injected object (such as a service) by\nadding a parameter to a constructor.\n\nDive deeper into the capabilities and advanced feature of the Angular DI system in the following pages:\n\n* Learn more about nested injectors in\n[Hierarchical Dependency Injection](guide/hierarchical-dependency-injection).\n\n* Learn more about [DI tokens and providers](guide/dependency-injection-providers).\n\n* [Dependency Injection in Action](guide/dependency-injection-in-action) is a cookbook for some of the interesting things you can do with DI.\n-->\n<p>이 문서에서는 Angular의 의존성 주입 체계에 대해 알아봤습니다.\n프로바이더는 여러가지 방법으로 등록할 수 있으며, 의존성으로 주입되는 객체는 생성자 인자에 타입을 지정하는 방식으로 구별합니다.</p>\n<p>Angular의 의존성 주입 시스템에 대해 더 자세하게 알아보려면 다음 문서를 확인해 보세요:</p>\n<ul>\n<li>\n<p>중첩된 인젝터에 대해 알아보려면 <a href=\"guide/hierarchical-dependency-injection\">의존성 주입 계층</a> 문서를 참고하세요.</p>\n</li>\n<li>\n<p><a href=\"guide/dependency-injection-providers\">의존성 주입 토큰과 프로바이더</a> 문서도 확인해 보세요.</p>\n</li>\n<li>\n<p><a href=\"guide/dependency-injection-in-action\">실전 의존성 주입</a> 문서는 의존성 주입을 활용하는 여러가지 방법에 대해 다룹니다.</p>\n</li>\n</ul>\n\n</div>\n\n<!-- links to this doc:\n - api/core/ClassProvider\n - api/core/ClassSansProvider\n - api/core/ConstructorProvider\n - api/core/ConstructorSansProvider\n - api/core/ExistingProvider\n - api/core/ExistingSansProvider\n - api/core/FactoryProvider\n - api/core/FactorySansProvider\n - api/core/Inject\n - api/core/Injectable\n - api/core/Optional\n - api/core/Provider\n - api/core/StaticClassProvider\n - api/core/TypeProvider\n - api/core/ValueProvider\n - guide/architecture-next-steps\n - guide/architecture-services\n - guide/attribute-directives\n - guide/dependency-injection-providers\n - guide/example-apps-list\n - guide/glossary\n - guide/ngmodule-api\n - guide/router\n - guide/sharing-ngmodules\n - guide/testing-services\n - guide/upgrade\n - tutorial/toh-pt4\n-->\n<!-- links from this doc:\n - api/common/NgForOf\n - api/core/Component\n - api/core/Directive\n - api/core/Inject\n - api/core/Injectable\n - api/core/NgModule\n - api/core/Optional\n - api/core/forwardRef\n - cli\n - guide/bootstrapping\n - guide/dependency-injection#angular의-의존성-주입\n - guide/dependency-injection#생략할-수-있는-의존성\n - guide/dependency-injection#서비스-주입하기\n - guide/dependency-injection#서비스-프로바이더를-인젝터에-등록하기\n - guide/dependency-injection#서비스에-다른-서비스-주입하기\n - guide/dependency-injection#의존성-객체가-있는-컴포넌트-테스트하기\n - guide/dependency-injection#의존성-주입-가능한-서비스-생성하고-등록하기\n - guide/dependency-injection#의존성-주입-토큰-dependency-injection-tokens\n - guide/dependency-injection#의존성으로-주입할-서비스-클래스-정의하기\n - guide/dependency-injection#인젝터-계층과-서비스-인스턴스\n - guide/dependency-injection#정리\n - guide/dependency-injection-in-action\n - guide/dependency-injection-in-action#forwardref\n - guide/dependency-injection-providers\n - guide/glossary#di-token\n - guide/glossary#injector\n - guide/glossary#provider\n - guide/glossary#transpile\n - guide/hierarchical-dependency-injection\n - guide/testing\n - tutorial/\n - http://blog.thoughtram.io/angular/2015/09/03/forward-references-in-angular-2.html\n - https://github.com/angular/angular/edit/master/aio/content/guide/dependency-injection.md?message=docs%3A%20describe%20your%20change...\n-->"
}