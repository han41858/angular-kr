{
  "id": "guide/router-tutorial-toh",
  "title": "라우터 튜토리얼: 히어로들의 여행",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/router-tutorial-toh.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<a id=\"router-tutorial\"></a>\n<!--\n# Router tutorial: tour of heroes\n-->\n<h1 id=\"라우터-튜토리얼-히어로들의-여행\">라우터 튜토리얼: 히어로들의 여행<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#라우터-튜토리얼-히어로들의-여행\"><i class=\"material-icons\">link</i></a></h1>\n<!--\nThis tutorial provides an extensive overview of the Angular router.\nIn this tutorial, you will build upon a basic router configuration to explore features such as child routes, route parameters, lazy load NgModules, guard routes, and preloading data to improve the user experience.\n\nFor a working example of the final version of the app, see the <live-example name=\"router\"></live-example>.\n-->\n<p>이번 튜토리얼에서는 Angular 라우터에 대해 깊이있게 알아봅시다.\n기본 라우터 설정을 구성하는 방법부터 시작해서 자식 라우팅 규칙을 정의하는 방법, 라우터 인자를 활용하는 방법, NgModule을 지연로딩하는 방법, 라우터 가드를 사용하는 방법, 데이터를 사전 로딩해서 사용성을 개선하는 방법에 대해 알아봅니다.</p>\n<p>이 문서에서 다루는 예제 앱이 동작하는 것을 직접 확인하려면 <live-example name=\"router\"></live-example>를 참고하세요.</p>\n<a id=\"router-tutorial-objectives\"></a>\n<!--\n## Objectives\n-->\n<h2 id=\"목표\">목표<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#목표\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThis guide describes development of a multi-page routed sample application.\nAlong the way, it highlights key features of the router such as:\n\n* Organizing the application features into modules.\n* Navigating to a component (*Heroes* link to \"Heroes List\").\n* Including a route parameter (passing the Hero `id` while routing to the \"Hero Detail\").\n* Child routes (the *Crisis Center* has its own routes).\n* The `CanActivate` guard (checking route access).\n* The `CanActivateChild` guard (checking child route access).\n* The `CanDeactivate` guard (ask permission to discard unsaved changes).\n* The `Resolve` guard (pre-fetching route data).\n* Lazy loading an `NgModule`.\n* The `CanLoad` guard (check before loading feature module assets).\n\nThis guide proceeds as a sequence of milestones as if you were building the app step-by-step, but assumes you are familiar with basic [Angular concepts](guide/architecture).\nFor a general introduction to angular, see the [Getting Started](start). For a more in-depth overview, see the [Tour of Heroes](tutorial) tutorial.\n-->\n<p>이 가이드 문서에서는 화면이 여러 개인 애플리케이션을 구현해 봅니다.\n이 과정을 진행하면서 라우터와 관련해서 알아둬야 할 내용은 이런 것들이 있습니다:</p>\n<ul>\n<li>애플리케이션 기능을 모듈 단위로 구성합니다.</li>\n<li><em>Heroes</em> 링크를 사용해서 \"Heroes List\" 컴포넌트로 화면을 전환합니다.</li>\n<li>\"Hero Detail\" 화면으로 전환하면서 Hero <code>id</code>를 라우터 인자로 전달합니다.</li>\n<li><em>Crisis Center</em> 안쪽으로 자식 라우팅 규칙을 정의합니다.</li>\n<li>라우팅 규칙을 적용하기 위해 <code><a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a></code> 가드를 사용합니다.</li>\n<li>자식 라우팅 규칙을 적용하기 위해 <code><a href=\"api/router/CanActivateChild\" class=\"code-anchor\">CanActivateChild</a></code> 가드를 사용합니다.</li>\n<li>저장되지 않은 변경사항을 폐기할지 결정하기 위해 <code><a href=\"api/router/CanDeactivate\" class=\"code-anchor\">CanDeactivate</a></code> 가드를 사용합니다.</li>\n<li>라우터 데이터를 미리 가져오기 위해 <code><a href=\"api/router/Resolve\" class=\"code-anchor\">Resolve</a></code> 가드를 사용합니다.</li>\n<li><code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>을 지연로딩합니다.</li>\n<li>기능 모듈을 로딩할지 결정하기 위해 <code><a href=\"api/router/CanLoad\" class=\"code-anchor\">CanLoad</a></code> 가드를 사용합니다.</li>\n</ul>\n<p>이 문서를 읽는 독자가 <a href=\"guide/architecture\">Angular의 기본 개념</a>에 대해 익숙하다고 가정하고 차근차근 라우터에 대해 알아봅시다.\n<a href=\"start\">시작하기</a> 문서를 먼저 보고 이 문서를 보는 것도 좋습니다.\n튜토리얼 전체 개요를 확인하려면 <a href=\"tutorial\">히어로들의 여행 튜토리얼</a> 문서를 참고하세요.</p>\n<!--\n## Prerequisites\n-->\n<h2 id=\"사전지식\">사전지식<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#사전지식\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nTo complete this tutorial, you should have a basic understanding of the following concepts:\n\n* JavaScript\n* HTML\n* CSS\n* [Angular CLI](/cli)\n\nYou might find the [Tour of Heroes tutorial](/tutorial) helpful, but it is not required.\n-->\n<p>이 문서를 제대로 이해하려면 이런 내용을 미리 알고 있는 것이 좋습니다:</p>\n<ul>\n<li>JavaScript</li>\n<li>HTML</li>\n<li>CSS</li>\n<li><a href=\"/cli\">Angular CLI</a></li>\n</ul>\n<p><a href=\"/tutorial\">히어로들의 여행 튜토리얼</a> 문서를 보는 것도 도움이 되지만 꼭 필요한 것은 아닙니다.</p>\n<!--\n## The sample application in action\n-->\n<h2 id=\"예제-애플리케이션이-동작하는-모습\">예제 애플리케이션이 동작하는 모습<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#예제-애플리케이션이-동작하는-모습\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe sample application for this tutorial helps the Hero Employment Agency find crises for heroes to solve.\n\nThe application has three main feature areas:\n\n1. A *Crisis Center* for maintaining the list of crises for assignment to heroes.\n1. A *Heroes* area for maintaining the list of heroes employed by the agency.\n1. An *Admin* area to manage the list of crises and heroes.\n\nTry it by clicking on this <live-example name=\"router\" title=\"Hero Employment Agency Live Example\">live example link</live-example>.\n\nThe app renders with a row of navigation buttons and the *Heroes* view with its list of heroes.\n\n\n<div class=\"lightbox\">\n  <img src='generated/images/guide/router/hero-list.png' alt=\"Hero List\">\n</div>\n\n\n\nSelect one hero and the app takes you to a hero editing screen.\n\n<div class=\"lightbox\">\n  <img src='generated/images/guide/router/hero-detail.png' alt=\"Crisis Center Detail\">\n</div>\n\n\n\nAlter the name.\nClick the \"Back\" button and the app returns to the heroes list which displays the changed hero name.\nNotice that the name change took effect immediately.\n\nHad you clicked the browser's back button instead of the app's \"Back\" button, the app would have returned you to the heroes list as well.\nAngular app navigation updates the browser history as normal web navigation does.\n\nNow click the *Crisis Center* link for a list of ongoing crises.\n\n\n<div class=\"lightbox\">\n  <img src='generated/images/guide/router/crisis-center-list.png' alt=\"Crisis Center List\">\n</div>\n\nSelect a crisis and the application takes you to a crisis editing screen.\nThe _Crisis Detail_ appears in a child component on the same page, beneath the list.\n\nAlter the name of a crisis.\nNotice that the corresponding name in the crisis list does _not_ change.\n\n\n<div class=\"lightbox\">\n  <img src='generated/images/guide/router/crisis-center-detail.png' alt=\"Crisis Center Detail\">\n</div>\n\n\nUnlike *Hero Detail*, which updates as you type, *Crisis Detail* changes are temporary until you either save or discard them by pressing the \"Save\" or \"Cancel\" buttons.\nBoth buttons navigate back to the *Crisis Center* and its list of crises.\n\nClick the browser back button or the \"Heroes\" link to activate a dialog.\n\n\n<div class=\"lightbox\">\n  <img src='generated/images/guide/router/confirm-dialog.png' alt=\"Confirm Dialog\">\n</div>\n\n\n\nYou can say \"OK\" and lose your changes or click \"Cancel\" and continue editing.\n\nBehind this behavior is the router's `CanDeactivate` guard.\nThe guard gives you a chance to clean-up or ask the user's permission before navigating away from the current view.\n\nThe `Admin` and `Login` buttons illustrate other router capabilities covered later in the guide.\n-->\n<p>이 문서에서 다루는 예제 애플리케이션은 히어로를 관리하는 회사가 위기상황에 대응할 수 있는 히어로를 찾는 기능을 제공합니다.</p>\n<p>이 애플리케이션이 제공하는 기능은 크게 3가지입니다:</p>\n<ol>\n<li>히어로에게 할당해서 대처해야 할 위기를 모아 <em>Crisis Center</em> 화면으로 제공합니다.</li>\n<li>회사가 관리하고 있는 히어로들의 목록을 <em>Heroes</em> 화면으로 제공합니다.</li>\n<li>위기 목록과 히어로 목록을 관리하는 <em>Admin</em> 화면을 제공합니다.</li>\n</ol>\n<p><live-example name=\"router\" title=\"Hero Employment Agency Live Example\">라이브 예제 앱</live-example>을 확인해 보세요.</p>\n<p>애플리케이션을 실행해보면 히어로의 목록이 네비게이션 버튼으로 구성된 <em>Heroes</em> 화면이 표시됩니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/router/hero-list.png\" alt=\"Hero List\" width=\"250\" height=\"225\">\n</div>\n<p>화면에 있는 히어로 중 하나를 선택하면 히어로 편집 화면으로 전환됩니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/router/hero-detail.png\" alt=\"Crisis Center Detail\" width=\"250\" height=\"162\">\n</div>\n<p>이름을 변경해 보세요.\n그리고 \"Back\" 버튼을 클릭하면 히어로 목록에 변경한 내용이 반영됩니다.\n이렇게 화면을 전환하면 변경한 이름이 즉시 반영됩니다.</p>\n<p>하지만 \"Back\" 버튼 대신 브라우저 뒤로 가기 버튼을 클릭하면 변경하기 전 이름으로 히어로 목록이 표시됩니다.\nAngular 앱도 일반 웹 네비게이션과 마찬가지로 브라우저 히스토리를 활용해서 화면을 전환합니다.</p>\n<p>그리고 <em>Crisis Center</em> 링크를 클릭하면 현재 발생된 위기 목록이 표시됩니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/router/crisis-center-list.png\" alt=\"Crisis Center List\" width=\"250\" height=\"209\">\n</div>\n<p>위기를 하나 선택하면 수정화면이 표시됩니다.\n이 때 <em>Crisis Detail</em> 화면은 해당 페이지의 목록 아래쪽에 자식 컴포넌트로 표시됩니다.</p>\n<p>위기의 이름을 변경해 보세요.\n변경한 이름은 목록에 <em>즉시</em> 반영되지 않습니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/router/crisis-center-detail.png\" alt=\"Crisis Center Detail\" width=\"250\" height=\"281\">\n</div>\n<p>변경한 내용이 즉시 반영되던 <em>Hero Detail</em> 화면과 다르게, <em>Crisis Detail</em> 화면에서 변경한 내용은 \"Save\" 버튼을 눌러서 저장하거나 \"Cancel\" 버튼을 눌러서 취소하지 않는 이상 목록에 반영되지 않습니다.\n두 버튼 중 하나를 누르면 <em>Crisis Center</em> 화면으로 돌아가면서 위기 목록이 표시됩니다.</p>\n<p>위기 이름을 수정한 다음에 브라우저 뒤로 가기 버튼이나 \"Heroes\" 링크를 눌러서 확인 팝업이 뜨는 것을 확인해 보세요.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/router/confirm-dialog.png\" alt=\"Confirm Dialog\" width=\"250\" height=\"101\">\n</div>\n<p>이 팝업에서 \"OK\"를 선택하면 변경한 내용을 폐기하며 \"Cancel\"을 선택하면 수정을 계속합니다.</p>\n<p>이 동작은 라우터가 제공하는 <code><a href=\"api/router/CanDeactivate\" class=\"code-anchor\">CanDeactivate</a></code> 가드로 구현합니다.\n이 가드는 현재 화면에서 수정한 내용을 정말 폐기할 것인지 사용자에게 확인하는 용도로 사용합니다.</p>\n<p><code>Admin</code> 버튼과 <code>Login</code> 버튼을 활용하는 내용은 다른 가이드 문서에서 자세하게 다룹니다.</p>\n<a id=\"getting-started\"></a>\n<!--\n## Milestone 1: Getting started\n-->\n<h2 id=\"마일스톤-1-시작하기\">마일스톤 1: 시작하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#마일스톤-1-시작하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nBegin with a basic version of the app that navigates between two empty views.\n\n\n<div class=\"lightbox\">\n  <img src='generated/images/guide/router/router-1-anim.gif' alt=\"App in action\">\n</div>\n-->\n<p>빈 화면 두 개를 전환하는 기본 앱부터 만들어 봅시다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/router/router-1-anim.gif\" alt=\"App in action\" width=\"250\" height=\"152\">\n</div>\n<a id=\"import\"></a>\n<!--\nGenerate a sample application with the Angular CLI.\n\n<code-example language=\"none\" class=\"code-shell\">\n  ng new angular-router-sample\n</code-example>\n-->\n<p>Angular CLI로 다음 명령을 실행하면 예제 애플리케이션을 생성할 수 있습니다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng new angular-router-sample\n</code-example>\n<!--\n### Define Routes\n-->\n<h3 id=\"라우팅-규칙-정의하기\">라우팅 규칙 정의하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#라우팅-규칙-정의하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nA router must be configured with a list of route definitions.\n\nEach definition translates to a [Route](api/router/Route) object which has two things: a `path`, the URL path segment for this route; and a `component`, the component associated with this route.\n\nThe router draws upon its registry of definitions when the browser URL changes or when application code tells the router to navigate along a route path.\n\nThe first route does the following:\n\n* When the browser's location URL changes to match the path segment `/crisis-center`, then the router activates an instance of the `CrisisListComponent` and displays its view.\n\n* When the application requests navigation to the path `/crisis-center`, the router activates an instance of `CrisisListComponent`, displays its view, and updates the browser's address location and history with the URL for that path.\n\nThe first configuration defines an array of two routes with minimal paths leading to the `CrisisListComponent` and `HeroListComponent`.\n\nGenerate the `CrisisList` and `HeroList` components so that the router has something to render.\n\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component crisis-list\n</code-example>\n\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component hero-list\n</code-example>\n\nReplace the contents of each component with the sample HTML below.\n\n<code-tabs>\n\n  <code-pane header=\"src/app/crisis-list/crisis-list.component.html\" path=\"router/src/app/crisis-list/crisis-list.component.1.html\">\n&lt;h2&gt;CRISIS CENTER&lt;/h2&gt;\n&lt;p&gt;Get your crisis here&lt;/p&gt;\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/hero-list/hero-list.component.html\" path=\"router/src/app/hero-list/hero-list.component.1.html\" region=\"template\">\n&lt;h2&gt;HEROES&lt;/h2&gt;\n&lt;p&gt;Get your heroes here&lt;/p&gt;\n\n\n</code-pane>\n\n</code-tabs>\n-->\n<p>라우터를 사용하려면 라우팅 규칙을 먼저 정의해야 합니다.</p>\n<p>라우팅 규칙은 <a href=\"api/router/Route\">Route</a> 객체로 정의하는데, 이 객체에는 매칭할 URL을 <code>path</code> 프로퍼티로 지정하고 이 라우팅 규칙이 활성화될 때 표시되는 컴포넌트를 <code>component</code> 프로퍼티로 지정합니다.</p>\n<p>라우터는 라우팅 규칙을 기준으로 브라우저 URL이나 라우터의 주소가 변경되는 것을 감지합니다.</p>\n<p>지금 정의하는 라우팅 규칙은 이런 역할을 합니다:</p>\n<ul>\n<li>\n<p>브라우저 URL이 변경되고 <code>/crisis-center</code>와 매칭되면 라우터가 <code>CrisisListComponent</code> 인스턴스를 생성하고 화면에 표시합니다.</p>\n</li>\n<li>\n<p>애플리케이션 코드가 <code>/crisis-center</code> 주소로 이동하도록 요청하면 라우터가 <code>CrisisListComponent</code> 인스턴스를 생성하고 화면에 표시하며, 브라우저의 주소표시줄과 히스토리를 해당 URL로 변경합니다.</p>\n</li>\n</ul>\n<p>이번 섹션에서는 간단하게 <code>CrisisListComponent</code>와 <code>HeroListComponent</code>와 매칭되는 라우팅 규칙 2개만 배열 형태로 정의했습니다.</p>\n<p>라우터가 화면에 렌더링할 <code>CrisisList</code> 컴포넌트와 <code>HeroList</code> 컴포넌트를 만들어 봅시다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component crisis-list\n</code-example>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component hero-list\n</code-example>\n<p>그리고 각 컴포넌트의 템플릿을 아래 HTML 내용으로 수정합니다.</p>\n<code-tabs>\n\n  <code-pane header=\"src/app/crisis-list/crisis-list.component.html\" path=\"router/src/app/crisis-list/crisis-list.component.1.html\">\n&#x3C;h2>CRISIS CENTER&#x3C;/h2>\n&#x3C;p>Get your crisis here&#x3C;/p>\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/hero-list/hero-list.component.html\" path=\"router/src/app/hero-list/hero-list.component.1.html\" region=\"template\">\n&#x3C;h2>HEROES&#x3C;/h2>\n&#x3C;p>Get your heroes here&#x3C;/p>\n\n\n</code-pane>\n\n</code-tabs>\n<!--\n### Register `Router` and `Routes`\n-->\n<h3 id=\"router-routes-등록하기\"><code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>, <code><a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a></code> 등록하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#router-routes-등록하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn order to use the `Router`, you must first register the `RouterModule` from the `@angular/router` package.\nDefine an array of routes, `appRoutes`, and pass them to the `RouterModule.forRoot()` method.\nThe `RouterModule.forRoot()` method returns a module that contains the configured `Router` service provider, plus other providers that the routing library requires.\nOnce the application is bootstrapped, the `Router` performs the initial navigation based on the current browser URL.\n\n<div class=\"alert is-important\">\n\n  **Note:** The `RouterModule.forRoot()` method is a pattern used to register application-wide providers. Read more about application-wide providers in the [Singleton services](guide/singleton-services#forRoot-router) guide.\n\n</div>\n\n<code-example path=\"router/src/app/app.module.1.ts\" header=\"src/app/app.module.ts (first-config)\" region=\"first-config\">\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { BrowserModule } from &#39;@angular/platform-browser&#39;;\nimport { FormsModule } from &#39;@angular/forms&#39;;\nimport { RouterModule, Routes } from &#39;@angular/router&#39;;\n\nimport { AppComponent } from &#39;./app.component&#39;;\nimport { CrisisListComponent } from &#39;./crisis-list/crisis-list.component&#39;;\nimport { HeroListComponent } from &#39;./hero-list/hero-list.component&#39;;\n\nconst appRoutes: Routes = [\n  { path: &#39;crisis-center&#39;, component: CrisisListComponent },\n  { path: &#39;heroes&#39;, component: HeroListComponent },\n];\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    FormsModule,\n    RouterModule.forRoot(\n      appRoutes,\n      { enableTracing: true } // &lt;-- 디버그 활성화\n    )\n  ],\n  declarations: [\n    AppComponent,\n    HeroListComponent,\n    CrisisListComponent,\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n</code-example>\n\n<div class=\"alert is-helpful\">\n\nAdding the configured `RouterModule` to the `AppModule` is sufficient for minimal route configurations.\nHowever, as the application grows, [refactor the routing configuration](#refactor-the-routing-configuration-into-a-routing-module) into a separate file and create a [Routing Module](#routing-module).\nA routing module is a special type of `Service Module` dedicated to routing.\n\n</div>\n\nRegistering the `RouterModule.forRoot()` in the `AppModule` `imports` array makes the `Router` service available everywhere in the application.\n-->\n<p><code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>를 사용하려면 먼저 <code>@angular/router</code> 패키지로 제공되는 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>을 등록해야 합니다.\n그리고 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 메서드 인자로 라우팅 규칙을 배열 형태로 정의한 <code>appRoutes</code>를 전달하면 됩니다.\n<code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 메서드는 인자로 전달된 라우팅 규칙으로 생성한 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 서비스 프로바이더와 라우터 관련 라이브러리를 모듈 형태로 반환합니다.\n애플리케이션이 부트스트랩되고 나면 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>가 현재 브라우저 URL을 기준으로 초기 네비게이션 동작을 시작합니다.</p>\n<div class=\"alert is-important\">\n<p><strong>참고:</strong> <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 메서드를 사용하는 것은 애플리케이션 전역에 프로바이더를 등록하는 패턴을 사용한 것입니다.\n애플리케이션 전역에 사용되는 프로바이더에 대해 알아보려면 <a href=\"guide/singleton-services#forRoot-router\">싱글턴 서비스</a> 문서를 참고하세요.\n라우팅 모듈은 라우팅만 전담하는 서비스 모듈입니다.</p>\n</div>\n<code-example path=\"router/src/app/app.module.1.ts\" header=\"src/app/app.module.ts (첫 번째 환경설정)\" region=\"first-config\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { AppComponent } from './app.component';\nimport { CrisisListComponent } from './crisis-list/crisis-list.component';\nimport { HeroListComponent } from './hero-list/hero-list.component';\n\nconst appRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'crisis-center', component: CrisisListComponent },\n  { path: 'heroes', component: HeroListComponent },\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    RouterModule.forRoot(\n      appRoutes,\n      { enableTracing: true } // &#x3C;-- 디버그 활성화\n    )\n  ],\n  declarations: [\n    AppComponent,\n    HeroListComponent,\n    CrisisListComponent,\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p><code>AppModule</code>에 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>을 추가하면 라우터를 사용하기 위한 기본 환경설정은 끝납니다.\n하지만 애플리케이션이 점점 커지다 보면 모듈을 나누고 <a href=\"guide/router-tutorial-toh#routing-module\">라우팅 모듈</a>을 따로 둬서 <a href=\"guide/router-tutorial-toh#refactor-the-routing-configuration-into-a-routing-module\">라우터 설정을 리팩토링</a>하는 것도 검토해봐야 합니다.</p>\n</div>\n<p><code>AppModule</code> <code>imports</code> 배열에 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code>를 등록하고 나면 애플리케이션 전역에서 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 서비스를 사용할 수 있습니다.</p>\n<a id=\"shell\"></a>\n<!--\n### Add the Router Outlet\n-->\n<h3 id=\"라우팅-영역-추가하기\">라우팅 영역 추가하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#라우팅-영역-추가하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe root `AppComponent` is the application shell. It has a title, a navigation bar with two links, and a router outlet where the router renders components.\n\n<div class=\"lightbox\">\n  <img src='generated/images/guide/router/shell-and-outlet.png' alt=\"Shell\">\n</div>\n\nThe router outlet serves as a placeholder where the routed components are rendered.\n\n<a id=\"shell-template\"></a>\n\nThe corresponding component template looks like this:\n\n<code-example path=\"router/src/app/app.component.1.html\" header=\"src/app/app.component.html\">\n&lt;h1&gt;Angular Router&lt;/h1&gt;\n&lt;nav&gt;\n  &lt;a routerLink=&quot;/crisis-center&quot; routerLinkActive=&quot;active&quot;&gt;Crisis Center&lt;/a&gt;\n  &lt;a routerLink=&quot;/heroes&quot; routerLinkActive=&quot;active&quot;&gt;Heroes&lt;/a&gt;\n&lt;/nav&gt;\n&lt;router-outlet&gt;&lt;/router-outlet&gt;\n\n</code-example>\n-->\n<p>애플리케이션의 기본 틀은 최상위 컴포넌트인 <code>AppComponent</code> 입니다.\n이 컴포넌트에는 제목이 하나 있으며, 링크가 2개로 구성된 네비게이션 바, 라우터가 컴포넌트를 렌더링하는 라우팅 영역(router outlet)으로 구성됩니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/router/shell-and-outlet.png\" alt=\"Shell\" width=\"300\" height=\"102\">\n</div>\n<p>라우팅 영역은 라우터가 라우팅 규칙과 매칭되는 컴포넌트를 렌더링할 때 컴포넌트의 위치를 지정하는 역할을 합니다.</p>\n<a id=\"shell-template\"></a>\n<p><code>AppComponent</code> 컴포넌트의 템플릿 코드는 이렇게 구성됩니다:</p>\n<code-example path=\"router/src/app/app.component.1.html\" header=\"src/app/app.component.html\">\n&#x3C;h1>Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>&#x3C;/h1>\n&#x3C;nav>\n  &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/crisis-center\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Crisis Center&#x3C;/a>\n  &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/heroes\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Heroes&#x3C;/a>\n&#x3C;/nav>\n&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n\n</code-example>\n<a id=\"wildcard\"></a>\n<!--\n### Define a Wildcard route\n-->\n<h3 id=\"와일드카드-라우팅-규칙-정의하기\">와일드카드 라우팅 규칙 정의하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#와일드카드-라우팅-규칙-정의하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou've created two routes in the app so far, one to `/crisis-center` and the other to `/heroes`.\nAny other URL causes the router to throw an error and crash the app.\n\nAdd a wildcard route to intercept invalid URLs and handle them gracefully.\nA wildcard route has a path consisting of two asterisks.\nIt matches every URL.\nThus, the router selects this wildcard route if it can't match a route earlier in the configuration.\nA wildcard route can navigate to a custom \"404 Not Found\" component or [redirect](#redirect) to an existing route.\n\n\n<div class=\"alert is-helpful\">\n\nThe router selects the route with a [_first match wins_](/guide/router#example-config) strategy.\nBecause a wildcard route is the least specific route, place it last in the route configuration.\n\n</div>\n\nTo test this feature, add a button with a `RouterLink` to the `HeroListComponent` template and set the link to a non-existant route called `\"/sidekicks\"`.\n\n<code-example path=\"router/src/app/hero-list/hero-list.component.1.html\" header=\"src/app/hero-list/hero-list.component.html (excerpt)\">\n&lt;h2&gt;HEROES&lt;/h2&gt;\n&lt;p&gt;Get your heroes here&lt;/p&gt;\n\n&lt;button routerLink=&quot;/sidekicks&quot;&gt;Go to sidekicks&lt;/button&gt;\n\n\n</code-example>\n\nThe application fails if the user clicks that button because you haven't defined a `\"/sidekicks\"` route yet.\n\nInstead of adding the `\"/sidekicks\"` route, define a `wildcard` route and have it navigate to a `PageNotFoundComponent`.\n\n<code-example path=\"router/src/app/app.module.1.ts\" header=\"src/app/app.module.ts (wildcard)\" region=\"wildcard\">\n{ path: &#39;**&#39;, component: PageNotFoundComponent }\n\n</code-example>\n\nCreate the `PageNotFoundComponent` to display when users visit invalid URLs.\n\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component page-not-found\n</code-example>\n\n<code-example path=\"router/src/app/page-not-found/page-not-found.component.html\" header=\"src/app/page-not-found.component.html (404 component)\">\n&lt;h2&gt;Page not found&lt;/h2&gt;\n\n</code-example>\n\nNow when the user visits `/sidekicks`, or any other invalid URL, the browser displays \"Page not found\".\nThe browser address bar continues to point to the invalid URL.\n-->\n<p>이제 애플리케이션에는 <code>/crisis-center</code>와 <code>/heroes</code> 주소에 해당하는 라우팅 규칙 2개가 존재합니다.\n다른 URL로 접근하면 라우터가 에러가 발생시키면서 앱이 비정상 종료됩니다.</p>\n<p>잘못된 URL로 접근하는 것을 자연스럽게 방지하려면 와일드카드 라우팅 규칙(wildecard route)을 추가하면 됩니다.\n와일드카드 라우팅 규칙은 별표(<code>*</code>) 2개를 <code>path</code> 프로퍼티에 지정하는데, 이 주소는 모든 URL과 매칭됩니다.\n그래서 라우터가 라우팅 규칙 중에서 매칭되는 규칙을 찾지 못한 경우에 모두 이 와일드카드 라우팅 규칙을 적용합니다.\n와일드카드 라우팅 규칙는 커스텀 \"404 Not Found\" 컴포넌트를 화면에 표시하거나 다른 라우팅 규칙으로 <a href=\"guide/router-tutorial-toh#redirect\">리다이렉션</a>하는 용도로 사용할 수 있습니다.</p>\n<div class=\"alert is-helpful\">\n<p>라우터는 라우터에 등록된 라우팅 규칙 중 <a href=\"/guide/router#example-config\">첫 번째로 매칭되는 것을 적용</a>하는 정책을 사용합니다.\n그리고 와일드카드 라우팅 규칙은 모든 주소와 매칭되기 때문에 라우팅 규칙 목록에서 가장 마지막에 등록해야 합니다.</p>\n</div>\n<p>이 동작을 테스트하기 위해 <code>HeroListComponent</code> 템플릿에 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 디렉티브가 적용된 버튼을 하나 추가하고 이 버튼과 연결된 주소를 <code>\"/sidekicks\"</code>으로 설정헤 봅시다.</p>\n<code-example path=\"router/src/app/hero-list/hero-list.component.1.html\" header=\"src/app/hero-list/hero-list.component.html (일부)\">\n&#x3C;h2>HEROES&#x3C;/h2>\n&#x3C;p>Get your heroes here&#x3C;/p>\n\n&#x3C;button <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/sidekicks\">Go to sidekicks&#x3C;/button>\n\n\n</code-example>\n<p>이제 사용자가 버튼을 클릭하면 애플리케이션에서 에러가 발생합니다.\n왜냐하면 <code>\"/sidekicks\"</code>와 매칭되는 라우팅 규칙이 등록되지 않았기 때문입니다.</p>\n<p>이 때 <code>\"/sidekicks\"</code> 라우팅 규칙 대신 <code>PageNotFoundComponent</code> 화면으로 이동하는 와일드카드 라우팅 규칙을 정의할 수 있습니다.</p>\n<code-example path=\"router/src/app/app.module.1.ts\" header=\"src/app/app.module.ts (와일드카드 라우팅 규칙)\" region=\"wildcard\">\n{ path: '**', component: PageNotFoundComponent }\n\n</code-example>\n<p>사용자가 등록되지 않은 URL로 접속했을 때 보여줄 <code>PageNotFoundComponent</code>를 생성해 봅시다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component page-not-found\n</code-example>\n<code-example path=\"router/src/app/page-not-found/page-not-found.component.html\" header=\"src/app/page-not-found.component.html (404 컴포넌트)\">\n&#x3C;h2>Page not found&#x3C;/h2>\n\n</code-example>\n<p>이제 사용자가 <code>/sidekicks</code> 과 같이 라우터에 등록되지 않은 주소로 접근하면 브라우저에 \"Page not found\" 문구가 표시됩니다.\n브라우저의 주소표시줄은 여전히 등록되지 않은 URL로 표시됩니다.</p>\n<a id=\"redirect\"></a>\n<!--\n### Set up redirects\n-->\n<h3 id=\"리다이렉션-설정하기\">리다이렉션 설정하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#리다이렉션-설정하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nWhen the application launches, the initial URL in the browser bar is by default:\n\n<code-example>\n  localhost:4200\n</code-example>\n\nThat doesn't match any of the hard-coded routes which means the router falls through to the wildcard route and displays the `PageNotFoundComponent`.\n\nThe application needs a default route to a valid page.\nThe default page for this app is the list of heroes.\nThe app should navigate there as if the user clicked the \"Heroes\" link or pasted `localhost:4200/heroes` into the address bar.\n\nAdd a `redirect` route that translates the initial relative URL (`''`) to the desired default path (`/heroes`).\n\nAdd the default route somewhere _above_ the wildcard route.\nIt's just above the wildcard route in the following excerpt showing the complete `appRoutes` for this milestone.\n\n\n<code-example path=\"router/src/app/app-routing.module.1.ts\" header=\"src/app/app-routing.module.ts (appRoutes)\" region=\"appRoutes\">\nconst appRoutes: Routes = [\n  { path: &#39;crisis-center&#39;, component: CrisisListComponent },\n  { path: &#39;heroes&#39;,        component: HeroListComponent },\n  { path: &#39;&#39;,   redirectTo: &#39;/heroes&#39;, pathMatch: &#39;full&#39; },\n  { path: &#39;**&#39;, component: PageNotFoundComponent }\n];\n\n</code-example>\n\nThe browser address bar shows `.../heroes` as if you'd navigated there directly.\n\nA redirect route requires a `pathMatch` property to tell the router how to match a URL to the path of a route.\nIn this app, the router should select the route to the `HeroListComponent` only when the *entire URL* matches `''`, so set the `pathMatch` value to `'full'`.\n\n<a id=\"pathmatch\"></a>\n\n<div class=\"callout is-helpful\">\n\n  <header>Spotlight on pathMatch</header>\n\n  Technically, `pathMatch = 'full'` results in a route hit when the *remaining*, unmatched  segments of the URL match `''`.\n  In this example, the redirect is in a top level route so the *remaining* URL and the  *entire* URL are the same thing.\n\n  The other possible `pathMatch` value is `'prefix'` which tells the router to match the  redirect route when the remaining URL begins with the redirect route's prefix  path.\n  This doesn't apply to this sample app because if the `pathMatch` value were `'prefix'`,   every URL would match `''`.\n\n  Try setting it to `'prefix'` and clicking the `Go to sidekicks` button.\n  Since that's a bad URL, you should see the \"Page not found\" page.\n  Instead, you're still on the \"Heroes\" page.\n  Enter a bad URL in the browser address bar.\n  You're instantly re-routed to `/heroes`.\n  Every URL, good or bad, that falls through to this route definition is a match.\n\n  The default route should redirect to the `HeroListComponent` only when the entire url is    `''`.\n  Remember to restore the redirect to `pathMatch = 'full'`.\n\n  Learn more in Victor Savkin's\n  [post on redirects](http://vsavkin.tumblr.com/post/146722301646/angular-router-empty-paths-componentless-routes).\n\n</div>\n-->\n<p>애플리케이션이 실행되고 브라우저 주소표시줄에 표시되는 기본 URL은 이렇습니다:</p>\n<code-example>\n  localhost:4200\n</code-example>\n<p>이 주소는 라우터에 등록된 라우팅 규칙 중 어느 것에도 매칭되지 않기 때문에 와일드카드 라우팅 규칙과 매칭되면서 <code>PageNotFoundComponent</code>가 화면에 표시됩니다.</p>\n<p>애플리케이션에는 기본 주소와 매칭되는 화면이 필요합니다.\n기본 화면은 히어로의 목록을 표시하는 화면으로 지정해 봅시다.\n이 화면은 사용자가 \"Heroes\" 링크를 클릭하거나 브라우저 주소표시줄에 <code>localhost:4200/heroes</code>를 입력했을 때 표시되는 화면입니다.</p>\n<p>초기 주소로 상대 URL(<code>''</code>)을 기본 경로(<code>/heroes</code>)로 리다이렉션하는 <code>redirect</code> 라우팅 규칙을 추가해 봅시다.</p>\n<p>기본 라우팅 규칙은 와일드카드 라우팅 규칙 <em>위라면</em> 어디에 추가해도 됩니다.\n예제 앱에서는 <code>appRoutes</code> 배열의 와일드카드 라우팅 규칙 바로 위에 기본 라우팅 규칙을 추가해 봅시다.</p>\n<code-example path=\"router/src/app/app-routing.module.1.ts\" header=\"src/app/app-routing.module.ts (appRoutes)\" region=\"appRoutes\">\nconst appRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'crisis-center', component: CrisisListComponent },\n  { path: 'heroes',        component: HeroListComponent },\n  { path: '',   redirectTo: '/heroes', pathMatch: 'full' },\n  { path: '**', component: PageNotFoundComponent }\n];\n\n</code-example>\n<p>기본 라우팅 규칙이 적용되고 나면 사용자가 직접 이동한 것처럼 브라우저의 주소가 <code>.../heroes</code>로 변경됩니다.</p>\n<p>리다이렉션 라우팅 규칙에는 URL을 매칭하는 방법을 결정하기 위해 <code>pathMatch</code> 프로퍼티를 지정해야 합니다.\n예제 앱에서는 <em>URL이 정확히</em> <code>''</code>와 매칭되었을 때만 <code>HeroListCompnent</code> 라우팅 규칙을 적용하기 위해 <code>pathMatch</code> 값으로 <code>'full'</code>을 지정했습니다.</p>\n<a id=\"pathmatch\"></a>\n<div class=\"callout is-helpful\">\n<header>pathMatch 자세하게 알아보기</header>\n<p><code>pathMatch='full'</code>을 사용하면 <em>매칭되는</em> 주소가 정확히 <code>''</code>이어야 해당 라우팅 규칙이 적용됩니다.\n예제 앱에서도 최상위 라우팅 규칙에서 <em>매칭되는</em> URL이 <em>정확히</em> 빈 문자열과 매칭되기 때문에 이 라우팅 규칙이 적용됩니다.</p>\n<p><code>pathMatch</code>에는 <code>'prefix'</code> 값을 사용할 수도 있습니다.\n이 값을 사용하면 매칭되는 주소가 라우팅 규칙 경로로 시작되면 해당 라우팅 규칙이 적용됩니다.\n이 방식을 사용하면 모든 URL이 <code>''</code>과 매칭되기 때문에 예제 앱에는 사용하지 않았습니다.</p>\n<p><code>pathMatch</code> 프로퍼티 값을 <code>'prefix'</code>로 바꾼 뒤에 <code>Go to sidekicks</code> 버튼을 클릭해 보세요.\n이 URL은 라우팅 규칙에 등록되지 않았기 때문에 \"Page not found\" 화면이 표시되어야 합니다.\n하지만 <code>'prefix'</code> 방식을 사용하면 \"Heroes\" 화면이 표시됩니다.\n브라우저 주소표시줄에 등록되지 않은 URL을 직접 입럭해도 <code>/heroes</code> 주소로 리다이렉션됩니다.\n결국 등록된 주소는 물론, 등록되지 않은 주소도 이 라우팅 규칙과 매칭됩니다.</p>\n<p><code>HeroListComponent</code>를 표시하는 기본 라우팅 규칙은 URL이 정확히 <code>''</code>일 때만 동작해야 합니다.\n<code>pathMatch='full'</code> 설정으로 되돌리는 것을 잊지 마세요.</p>\n<p>이 내용은 Victor Savkin이 <a href=\"http://vsavkin.tumblr.com/post/146722301646/angular-router-empty-paths-componentless-routes\">리다이렉션에 대해 작성한 블로그 글</a>에서도 확인할 수 있습니다.</p>\n</div>\n<!--\n### Milestone 1 wrap up\n-->\n<h3 id=\"마일스톤-1-정리\">마일스톤 1 정리<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#마일스톤-1-정리\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYour sample app can switch between two views when the user clicks a link.\n\nMilestone 1 has covered how to do the following:\n\n* Load the router library.\n* Add a nav bar to the shell template with anchor tags, `routerLink`  and `routerLinkActive` directives.\n* Add a `router-outlet` to the shell template where views are displayed.\n* Configure the router module with `RouterModule.forRoot()`.\n* Set the router to compose HTML5 browser URLs.\n* Handle invalid routes with a `wildcard` route.\n* Navigate to the default route when the app launches with an empty path.\n\nThe starter app's structure looks like this:\n-->\n<p>이제 예제 앱은 사용자가 클릭하는 링크에 따라 화면 2개를 전환합니다.</p>\n<p>마일스톤 1에서는 이런 내용을 다뤘습니다:</p>\n<ul>\n<li>라우터 라이브러리를 로드하는 방법에 대해 알아봤습니다.</li>\n<li>애플리케이션 템플릿에 앵커 태그로 네비게이션 바를 추가하고 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> 디렉티브와 <code><a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a></code> 디렉티브를 적용했습니다.</li>\n<li>라우터가 컴포넌트를 표시할 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a></code>을 추가했습니다.</li>\n<li><code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 메서드로 라우터 모듈을 설정했습니다.</li>\n<li>라우터가 동작하는 방식을 HTML5 브라우저 URL 방식으로 설정했습니다.</li>\n<li>등록되지 않은 주소를 와일드카드 라우팅 규칙으로 처리했습니다.</li>\n<li>빈 주소로 접근했을 때 처리할 기본 라우팅 규칙을 추가했습니다.</li>\n</ul>\n<p>앱 전체 구조는 이렇게 구성됩니다:</p>\n<div class=\"filetree\">\n  <div class=\"file\">\n    angular-router-sample\n  </div>\n  <div class=\"children\">\n    <div class=\"file\">\n      src\n    </div>\n    <div class=\"children\">\n      <div class=\"file\">\n        app\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          crisis-list\n        </div>\n        <div class=\"children\">\n          <div class=\"file\">\n<p>            crisis-list.component.css</p>\n          </div>\n          <div class=\"file\">\n<p>            crisis-list.component.html</p>\n          </div>\n          <div class=\"file\">\n<p>            crisis-list.component.ts</p>\n          </div>\n        </div>\n        <div class=\"file\">\n          hero-list\n        </div>\n        <div class=\"children\">\n          <div class=\"file\">\n<p>            hero-list.component.css</p>\n          </div>\n          <div class=\"file\">\n<p>            hero-list.component.html</p>\n          </div>\n          <div class=\"file\">\n<p>            hero-list.component.ts</p>\n          </div>\n        </div>\n        <div class=\"file\">\n          page-not-found\n        </div>\n        <div class=\"children\">\n          <div class=\"file\">\n<p>            page-not-found.component.css</p>\n          </div>\n          <div class=\"file\">\n<p>            page-not-found.component.html</p>\n          </div>\n          <div class=\"file\">\n<p>            page-not-found.component.ts</p>\n          </div>\n        </div>\n        <div class=\"file\">\n          app.component.css\n        </div>\n        <div class=\"file\">\n          app.component.html\n        </div>\n        <div class=\"file\">\n          app.component.ts\n        </div>\n        <div class=\"file\">\n          app.module.ts\n        </div>\n      </div>\n      <div class=\"file\">\n        main.ts\n      </div>\n      <div class=\"file\">\n        index.html\n      </div>\n      <div class=\"file\">\n        styles.css\n      </div>\n      <div class=\"file\">\n        tsconfig.json\n      </div>\n    </div>\n    <div class=\"file\">\n      node_modules ...\n    </div>\n    <div class=\"file\">\n      package.json\n    </div>\n  </div>\n</div>\n<!--\nHere are the files in this milestone.\n-->\n<p>그리고 이번 마일스톤에서 다룬 파일의 내용은 이렇습니다.</p>\n<code-tabs>\n\n  <code-pane header=\"app.component.html\" path=\"router/src/app/app.component.1.html\">\n&#x3C;h1>Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>&#x3C;/h1>\n&#x3C;nav>\n  &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/crisis-center\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Crisis Center&#x3C;/a>\n  &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/heroes\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Heroes&#x3C;/a>\n&#x3C;/nav>\n&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n\n</code-pane>\n\n  <code-pane header=\"app.module.ts\" path=\"router/src/app/app.module.1.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { AppComponent } from './app.component';\nimport { CrisisListComponent } from './crisis-list/crisis-list.component';\nimport { HeroListComponent } from './hero-list/hero-list.component';\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\n\nconst appRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'crisis-center', component: CrisisListComponent },\n  { path: 'heroes', component: HeroListComponent },\n\n  { path: '',   redirectTo: '/heroes', pathMatch: 'full' },\n  { path: '**', component: PageNotFoundComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    RouterModule.forRoot(\n      appRoutes,\n      { enableTracing: true } // &#x3C;-- 디버그 활성화\n    )\n  ],\n  declarations: [\n    AppComponent,\n    HeroListComponent,\n    CrisisListComponent,\n    PageNotFoundComponent\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n\n</code-pane>\n\n  <code-pane header=\"hero-list/hero-list.component.html\" path=\"router/src/app/hero-list/hero-list.component.1.html\">\n&#x3C;h2>HEROES&#x3C;/h2>\n&#x3C;p>Get your heroes here&#x3C;/p>\n\n&#x3C;button <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/sidekicks\">Go to sidekicks&#x3C;/button>\n\n\n</code-pane>\n\n  <code-pane header=\"crisis-list/crisis-list.component.html\" path=\"router/src/app/crisis-list/crisis-list.component.1.html\">\n&#x3C;h2>CRISIS CENTER&#x3C;/h2>\n&#x3C;p>Get your crisis here&#x3C;/p>\n\n\n</code-pane>\n\n  <code-pane header=\"page-not-found/page-not-found.component.html\" path=\"router/src/app/page-not-found/page-not-found.component.html\">\n&#x3C;h2>Page not found&#x3C;/h2>\n\n</code-pane>\n\n  <code-pane header=\"index.html\" path=\"router/src/index.html\">\n&#x3C;html lang=\"en\">\n  &#x3C;head>\n    &#x3C;!-- Set the base href -->\n    &#x3C;base href=\"/\">\n    &#x3C;title>Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>&#x3C;/title>\n    &#x3C;meta charset=\"UTF-8\">\n    &#x3C;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  &#x3C;/head>\n\n  &#x3C;body>\n    &#x3C;app-root>&#x3C;/app-root>\n  &#x3C;/body>\n\n&#x3C;/html>\n\n</code-pane>\n\n</code-tabs>\n<a id=\"routing-module\"></a>\n<!--\n## Milestone 2: *Routing module*\n-->\n<h2 id=\"마일스톤-2-라우팅-모듈\">마일스톤 2: <em>라우팅 모듈</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#마일스톤-2-라우팅-모듈\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThis milestone shows you how to configure a special-purpose module called a *Routing Module*, which holds your app's routing configuration.\n\nThe Routing Module has several characteristics:\n\n* Separates routing concerns from other application concerns.\n* Provides a module to replace or remove when testing the application.\n* Provides a well-known location for routing service providers such as guards and resolvers.\n* Does not declare components.\n-->\n<p>이번 마일스톤에서는 <em>라우팅 모듈(Routing Module)</em> 이라고 하는 특별한 모듈에 대해 알아봅시다.\n이 모듈은 애플리케이션의 라우팅 환경설정을 담당합니다.</p>\n<p>라우팅 모듈은 이런 특징이 있습니다:</p>\n<ul>\n<li>애플리케이션에서 라우팅 관련 설정을 모아둔 모듈입니다.</li>\n<li>애플리케이션을 테스트할 때는 다른 모듈로 대체할 수 있습니다.</li>\n<li>라우터 가드(guard)나 리졸버(resolver)와 같은 라우팅 관련 서비스 프로바이더를 제공합니다.</li>\n<li>컴포넌트를 제공하지는 않습니다.</li>\n</ul>\n<a id=\"integrate-routing\"></a>\n<!--\n### Integrate routing with your app\n-->\n<h3 id=\"애플리케이션에-있는-라우팅-통합하기\">애플리케이션에 있는 라우팅 통합하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#애플리케이션에-있는-라우팅-통합하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe sample routing application does not include routing by default.\nWhen you use the [Angular CLI](cli) to create a project that does use routing, set the `--routing` option for the project or app, and for each NgModule.\nWhen you create or initialize a new project (using the CLI [`ng new`](cli/new) command) or a new app (using the [`ng generate app`](cli/generate) command), specify the `--routing` option.\nThis tells the CLI to include the `@angular/router` npm package and create a file named `app-routing.module.ts`.\nYou can then use routing in any NgModule that you add to the project or app.\n\nFor example, the following command generates an NgModule that can use routing.\n\n```sh\nng generate module my-module --routing\n```\n\nThis creates a separate file named `my-module-routing.module.ts` to store the NgModule's routes.\nThe file includes an empty `Routes` object that you can fill with routes to different components and NgModules.\n-->\n<p>예제 라우팅 애플리케이션에는 라우팅 관련 환경설정이 없습니다.\n<a href=\"cli\">Angular CLI</a>를 사용해서 프로젝트를 생성할 때 라우팅 관련 기본 코드도 함께 생성하려면 <code>--routing</code> 옵션을 붙여서 실행하면 됩니다.\n이 옵션은 <a href=\"cli/new\"><code>ng new</code></a> 명령을 실행할 때나 <a href=\"cli/generate\"><code>ng generate app</code></a> 명령을 실행할 때 모두 사용할 수 있습니다.\n이 옵션을 붙여 앱을 생성하면 <code>@angular/router</code> npm 패키지를 추가로 설치하며 <code>app-routing.module.ts</code> 파일도 생성합니다.\n이제 NgModule에 라우팅 기능을 추가할 수 있습니다.</p>\n<p>라우팅 모듈을 분리하면서 NgModule을 생성하려면 다음 명령을 실행하면 됩니다:</p>\n<code-example language=\"sh\">\nng generate module my-module --routing\n</code-example>\n<p>이 명령을 실행하면 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>을 생성하면서 이 모듈과 관련된 <code>my-module-routing.module.ts</code> 파일도 함께 생성합니다.\n이 파일에 선언된 <code><a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a></code> 배열에 라우팅 규칙을 추가하면 됩니다.</p>\n<a id=\"routing-refactor\"></a>\n<a id=\"refactor-the-routing-configuration-into-a-routing-module\"></a>\n<!--\n### Refactor the routing configuration into a routing module\n-->\n<h3 id=\"라우팅-환경설정-리팩토링하기\">라우팅 환경설정 리팩토링하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#라우팅-환경설정-리팩토링하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nCreate an `AppRouting` module in the `/app` folder to contain the routing configuration.\n\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate module app-routing --module app --flat\n</code-example>\n\nImport the `CrisisListComponent`, `HeroListComponent`, and `PageNotFoundComponent` symbols\njust like you did in the `app.module.ts`.\nThen move the `Router` imports and routing configuration, including `RouterModule.forRoot()`, into this routing module.\n\nRe-export the Angular `RouterModule` by adding it to the module `exports` array.\nBy re-exporting the `RouterModule` here, the components declared in `AppModule` have access to router directives such as `RouterLink` and `RouterOutlet`.\n\nAfter these steps, the file should look like this.\n\n<code-example path=\"router/src/app/app-routing.module.1.ts\" header=\"src/app/app-routing.module.ts\">\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { RouterModule, Routes } from &#39;@angular/router&#39;;\n\nimport { CrisisListComponent } from &#39;./crisis-list/crisis-list.component&#39;;\nimport { HeroListComponent } from &#39;./hero-list/hero-list.component&#39;;\nimport { PageNotFoundComponent } from &#39;./page-not-found/page-not-found.component&#39;;\n\nconst appRoutes: Routes = [\n  { path: &#39;crisis-center&#39;, component: CrisisListComponent },\n  { path: &#39;heroes&#39;,        component: HeroListComponent },\n  { path: &#39;&#39;,   redirectTo: &#39;/heroes&#39;, pathMatch: &#39;full&#39; },\n  { path: &#39;**&#39;, component: PageNotFoundComponent }\n];\n\n@NgModule({\n  imports: [\n    RouterModule.forRoot(\n      appRoutes,\n      { enableTracing: true } // &lt;-- 디버그 활성화\n    )\n  ],\n  exports: [\n    RouterModule\n  ]\n})\nexport class AppRoutingModule {}\n\n\n</code-example>\n\nNext, update the `app.module.ts` file by removing `RouterModule.forRoot` in the `imports` array.\n\n<code-example path=\"router/src/app/app.module.2.ts\" header=\"src/app/app.module.ts\">\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { BrowserModule } from &#39;@angular/platform-browser&#39;;\nimport { FormsModule } from &#39;@angular/forms&#39;;\n\nimport { AppComponent } from &#39;./app.component&#39;;\nimport { AppRoutingModule } from &#39;./app-routing.module&#39;;\n\nimport { CrisisListComponent } from &#39;./crisis-list/crisis-list.component&#39;;\nimport { HeroListComponent } from &#39;./hero-list/hero-list.component&#39;;\nimport { PageNotFoundComponent } from &#39;./page-not-found/page-not-found.component&#39;;\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    FormsModule,\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    HeroListComponent,\n    CrisisListComponent,\n    PageNotFoundComponent\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n</code-example>\n\n<div class=\"alert is-helpful\">\n\nLater, this guide shows you how to create [multiple routing modules](#heroes-functionality) and import those routing modules [in the correct order](#routing-module-order).\n\n</div>\n\nThe application continues to work just the same, and you can use `AppRoutingModule` as the central place to maintain future routing configuration.\n-->\n<p><code>/app</code> 폴더에 <code>AppRouting</code> 모듈을 생성하는 명령은 이렇습니다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate module app-routing --module app --flat\n</code-example>\n<p>그리고 <code>app.module.ts</code> 파일에 작성했던 것처럼 <code>CrisisListComponent</code>, <code>HeroListComponent</code>, <code>PageNotFoundComponent</code> 심볼을 로드합니다.\n그 다음에는 <code>AppModule</code>에 있는 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 관련 코드를 라우팅 모듈로 옮기면 됩니다.</p>\n<p>라우팅 모듈의 <code>exports</code> 배열에 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>을 추가하면 Angular <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>이 제공하는 기능을 다른 모듈에서도 사용할 수 있습니다.\n그래서 <code>AppModule</code>에서는 Angular <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>을 따로 로드하지 않아도 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>나 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>과 같은 디렉티브를 사용할 수 있습니다.</p>\n<p>여기까지 작성하고 나면 라우팅 모듈의 코드는 이렇습니다.</p>\n<code-example path=\"router/src/app/app-routing.module.1.ts\" header=\"src/app/app-routing.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { CrisisListComponent } from './crisis-list/crisis-list.component';\nimport { HeroListComponent } from './hero-list/hero-list.component';\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\n\nconst appRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'crisis-center', component: CrisisListComponent },\n  { path: 'heroes',        component: HeroListComponent },\n  { path: '',   redirectTo: '/heroes', pathMatch: 'full' },\n  { path: '**', component: PageNotFoundComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forRoot(\n      appRoutes,\n      { enableTracing: true } // &#x3C;-- 디버그 활성화\n    )\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class AppRoutingModule {}\n\n\n</code-example>\n<p>이제 <code>app.module.ts</code> 파일의 <code>imports</code> 배열에서 <code>RouterModule.forRoot</code> 코드를 제거합니다.</p>\n<code-example path=\"router/src/app/app.module.2.ts\" header=\"src/app/app.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\n\nimport { AppComponent } from './app.component';\nimport { AppRoutingModule } from './app-routing.module';\n\nimport { CrisisListComponent } from './crisis-list/crisis-list.component';\nimport { HeroListComponent } from './hero-list/hero-list.component';\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    HeroListComponent,\n    CrisisListComponent,\n    PageNotFoundComponent\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>이후 단계에서는 <a href=\"guide/router-tutorial-toh#heroes-functionality\">라우팅 모듈을 여러개</a> 선언하고 이 모듈들을 <a href=\"guide/router-tutorial-toh#routing-module-order\">올바른 순서로</a> 로드하는 방법에 대해 다룹니다.</p>\n</div>\n<p>애플리케이션은 이전에 작업했던 것과 똑같이 동작합니다.\n그리고 이제부터 라우팅 관련 기능은 모두 <code>AppRoutingModule</code>을 기준으로 확장하면 됩니다.</p>\n<a id=\"why-routing-module\"></a>\n<!--\n### Benefits of a routing module\n-->\n<h3 id=\"라우팅-모듈을-사용하는-이유\">라우팅 모듈을 사용하는 이유<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#라우팅-모듈을-사용하는-이유\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe routing module, often called the `AppRoutingModule`, replaces the routing configuration in the root or feature module.\n\nThe routing module is helpful as your app grows and when the configuration includes specialized guard and resolver services.\n\nSome developers skip the routing module when the configuration is minimal and merge the routing configuration directly into the companion module (for example, `AppModule`).\n\nMost apps should implement a routing module for consistency.\nIt keeps the code clean when configuration becomes complex.\nIt makes testing the feature module easier.\nIts existence calls attention to the fact that a module is routed.\nIt is where developers expect to find and expand routing configuration.\n-->\n<p>최상위 라우팅 모듈이라고도 하는 <code>AppRoutingModule</code>은 최상위 기능 모듈의 라우팅 환경설정을 대신하는 모듈입니다.</p>\n<p>라우팅 모듈을 사용하면 앱이 점점 복잡해지면서 가드와 리졸버가 복잡하게 적용될수록 코드를 효율적으로 관리할 수 있습니다.</p>\n<p>라우터 설정이 복잡하지 않아서 <code>AppModule</code>과 함께 관리하도 복잡하지 않다면 라우팅 모듈을 굳이 사용하지 않아도 됩니다.</p>\n<p>하지만 보통은 라우팅 모듈을 따로 두는 것이 일관성을 유지하기에 좋습니다.\n라우팅 모듈을 따로 두면:</p>\n<ol>\n<li>라우팅 설정이 복잡해지더라도 라우팅 모듈만 수정하면 됩니다.</li>\n<li>기능 모듈을 테스트하기 쉽습니다.</li>\n<li>라우팅 모듈과 관련된 기능 모듈만 집중해서 작업할 수 있습니다.</li>\n<li>라우터 설정이 시작되는 곳을 명확하게 파악할 수 있습니다.</li>\n</ol>\n<a id=\"heroes-feature\"></a>\n<!--\n## Milestone 3: Heroes feature\n-->\n<h2 id=\"마일스톤-3-히어로-관리-모듈\">마일스톤 3: 히어로 관리 모듈<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#마일스톤-3-히어로-관리-모듈\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThis milestone covers the following:\n\n* Organizing the app and routes into feature areas using modules.\n* Navigating imperatively from one component to another.\n* Passing required and optional information in route parameters.\n\nThis sample app recreates the heroes feature in the \"Services\" section of the [Tour of Heroes tutorial](tutorial/toh-pt4 \"Tour of Heroes: Services\"), and reuses much of the code from the <live-example name=\"toh-pt4\" title=\"Tour of Heroes: Services example code\"></live-example>.\n\n<!- KW - this gif isn't ideal for accessibility. Would like to remove it.->\n<!- Here's how the user will experience this version of the app:\n\n\n<div class=\"lightbox\">\n  <img src='generated/images/guide/router/router-2-anim.gif' alt=\"App in action\">\n</div> ->\n\nA typical application has multiple feature areas, each dedicated to a particular business purpose with its own folder.\n\nThis section shows you how refactor the app into different feature modules, import them into the main module and navigate among them.\n-->\n<p>이번 마일스톤에서는 이런 내용을 다룹니다:</p>\n<ul>\n<li>모듈에 있는 라우팅 설정을 기능 모듈로 옮깁니다.</li>\n<li>화면 전환 로직을 수정합니다.</li>\n<li>필수/옵션 정보를 라우팅 인자로 전달합니다.</li>\n</ul>\n<p>이번 마일스톤에서 다루는 예제 앱은 [히어로들의 여행 튜토리얼]<live-example name=\"toh-pt4\" title=\"Tour of Heroes: Services example code\"></live-example> 예제 앱의 <a href=\"tutorial/toh-pt4\" title=\"Tour of Heroes: Services\">\"서비스\" 섹션</a> 코드를 많이 참고했습니다.</p>\n<!-- KW - this gif isn't ideal for accessibility. Would like to remove it.-->\n<!-- Here's how the user will experience this version of the app:\n\n\n<div class=\"lightbox\">\n  <img src='generated/images/guide/router/router-2-anim.gif' alt=\"App in action\">\n</div> ->\n-->\n<p>일반적으로 애플리케이션은 특정 기능들의 묶음으로 구성되며, 용도에 맞게 폴더별로 존재하기도 합니다.</p>\n<p>이번 섹션에서는 애플리케이션을 기능 모듈별로 리팩토링하는 방법에 대해 알아보고, 메인 모듈에서 기능 모듈을 불러온 후에 모듈간 이동하는 방법에 대해 알아봅시다.</p>\n<a id=\"heroes-functionality\"></a>\n<!--\n### Add heroes functionality\n-->\n<h3 id=\"히어로-추가-기능\">히어로 추가 기능<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#히어로-추가-기능\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nFollow these steps:\n\n* To manage the heroes, create a `HeroesModule` with routing in the heroes folder and register it with the root `AppModule`.\n\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate module heroes/heroes --module app --flat --routing\n</code-example>\n\n* Move the placeholder `hero-list` folder that's in the `app` folder into the `heroes` folder.\n* Copy the contents of the `heroes/heroes.component.html` from\n  the <live-example name=\"toh-pt4\" title=\"Tour of Heroes: Services example code\">\"Services\" tutorial</live-example> into the `hero-list.component.html` template.\n\n  * Re-label the `<h2>` to `<h2>HEROES</h2>`.\n  * Delete the `<app-hero-detail>` component at the bottom of the template.\n\n* Copy the contents of the `heroes/heroes.component.css` from the live example into the `hero-list.component.css` file.\n* Copy the contents of the `heroes/heroes.component.ts` from the live example into the `hero-list.component.ts` file.\n\n  * Change the component class name to `HeroListComponent`.\n  * Change the `selector` to `app-hero-list`.\n\n<div class=\"alert is-helpful\">\n\n   Selectors are not required for routed components because components are dynamically inserted when the page is rendered. However, they are useful for identifying and targeting them in your HTML element tree.\n\n</div>\n\n* Copy the `hero-detail` folder, the `hero.ts`, `hero.service.ts`,  and `mock-heroes.ts` files into the `heroes` subfolder.\n* Copy the `message.service.ts` into the `src/app` folder.\n* Update the relative path import to the `message.service` in the `hero.service.ts` file.\n\nNext, update the `HeroesModule` metadata.\n\n  * Import and add the `HeroDetailComponent` and `HeroListComponent` to the `declarations` array in the `HeroesModule`.\n\n<code-example path=\"router/src/app/heroes/heroes.module.ts\" header=\"src/app/heroes/heroes.module.ts\">\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { CommonModule } from &#39;@angular/common&#39;;\nimport { FormsModule } from &#39;@angular/forms&#39;;\n\nimport { HeroListComponent } from &#39;./hero-list/hero-list.component&#39;;\nimport { HeroDetailComponent } from &#39;./hero-detail/hero-detail.component&#39;;\n\nimport { HeroesRoutingModule } from &#39;./heroes-routing.module&#39;;\n\n@NgModule({\n  imports: [\n    CommonModule,\n    FormsModule,\n    HeroesRoutingModule\n  ],\n  declarations: [\n    HeroListComponent,\n    HeroDetailComponent\n  ]\n})\nexport class HeroesModule {}\n\n</code-example>\n\nThe hero management file structure is as follows:\n-->\n<p>이런 순서로 진행합니다:</p>\n<ul>\n<li>히어로를 관리하기 위해 <code>HeroesModule</code> 모듈과 라우팅 모듈을 <code>heroes</code> 폴더에 생성하고 최상위 <code>AppModule</code>에 이 모듈을 등록합니다.</li>\n</ul>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate module heroes/heroes --module app --flat --routing\n</code-example>\n<ul>\n<li>\n<p><code>app</code> 폴더에 있는 <code>hero-list</code> 폴더를 <code>heroes</code> 폴더로 옮깁니다.</p>\n</li>\n<li>\n<p><live-example name=\"toh-pt4\" title=\"Tour of Heroes: Services example code\">\"서비스\" 튜토리얼</live-example> <code>hero-list.component.html</code> 템플릿에 있는 내용을 <code>heroes/heroes.component.html</code> 파일로 옮깁니다.</p>\n<ul>\n<li><code>&#x3C;h2></code> 태그의 내용을 <code>&#x3C;h2>HEROES&#x3C;/h2></code>로 수정합니다.</li>\n<li>템플릿 제일 아래에 있는 <code>&#x3C;app-hero-detail></code> 태그를 제거합니다.</li>\n</ul>\n</li>\n<li>\n<p>예제 링크에 있는 <code>hero-list.component.css</code> 파일의 내용을 <code>heroes/heroes.component.css</code> 파일로 옮깁니다.</p>\n</li>\n<li>\n<p>예제 링크에 있는 <code>hero-list.component.ts</code> 파일의 내용을 <code>heroes/heroes.component.ts</code> 파일로 옮깁니다.</p>\n<ul>\n<li>컴포넌트 클래스의 이름을 <code>HeroListComponent</code>로 변경합니다.</li>\n<li><code>selector</code>를 <code>app-hero-list</code>로 변경합니다.</li>\n</ul>\n</li>\n</ul>\n<div class=\"alert is-helpful\">\n<p>   라우팅 대상이 되는 컴포넌트는 화면이 렌더링되면서 동적으로 추가되기 때문에 셀렉터를 필수로 지정해야 하는 것은 아닙니다.\n하지만 셀렉터를 지정해두면 전체 HTML 엘리먼트 트리에서 해당 컴포넌트를 찾을 때 도움이 됩니다.</p>\n</div>\n<ul>\n<li><code>hero-detail</code> 폴더, <code>hero.ts</code>, <code>hero.service</code>, <code>mock-heroes.ts</code> 파일을 <code>heroes</code> 폴더로 옮깁니다.</li>\n<li><code>message.service.ts</code> 파일을 <code>src/app</code> 폴더로 옮깁니다.</li>\n<li><code>hero.service.ts</code> 파일에서 로드하는 <code>message.service</code>의 주소를 수정합니다.</li>\n</ul>\n<p>이제 <code>HeroesModule</code> 메타데이터를 수정합니다.</p>\n<ul>\n<li><code>HeroesModule</code> 파일에 <code>HeroDetailComponent</code>와 <code>HeroListComponent</code>를 로드하고 <code>declarations</code> 배열에 추가합니다.</li>\n</ul>\n<code-example path=\"router/src/app/heroes/heroes.module.ts\" header=\"src/app/heroes/heroes.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> } from '@angular/common';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\n\nimport { HeroListComponent } from './hero-list/hero-list.component';\nimport { HeroDetailComponent } from './hero-detail/hero-detail.component';\n\nimport { HeroesRoutingModule } from './heroes-routing.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    HeroesRoutingModule\n  ],\n  declarations: [\n    HeroListComponent,\n    HeroDetailComponent\n  ]\n})\nexport class HeroesModule {}\n\n</code-example>\n<p>이제 히어로 모듈의 파일 구조는 이렇습니다:</p>\n<div class=\"filetree\">\n  <div class=\"file\">\n    src/app/heroes\n  </div>\n  <div class=\"children\">\n    <div class=\"file\">\n      hero-detail\n    </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          hero-detail.component.css\n        </div>\n        <div class=\"file\">\n          hero-detail.component.html\n        </div>\n        <div class=\"file\">\n          hero-detail.component.ts\n        </div>\n      </div>\n    <div class=\"file\">\n      hero-list\n    </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          hero-list.component.css\n        </div>\n        <div class=\"file\">\n          hero-list.component.html\n        </div>\n        <div class=\"file\">\n          hero-list.component.ts\n        </div>\n      </div>\n    <div class=\"file\">\n      hero.service.ts\n    </div>\n    <div class=\"file\">\n      hero.ts\n    </div>\n    <div class=\"file\">\n      heroes-routing.module.ts\n    </div>\n    <div class=\"file\">\n      heroes.module.ts\n    </div>\n    <div class=\"file\">\n      mock-heroes.ts\n    </div>\n    </div>\n  </div>\n</div>\n<a id=\"hero-routing-requirements\"></a>\n<!--\n#### Hero feature routing requirements\n-->\n<h4 id=\"히어로-모듈-라우터-설정\">히어로 모듈 라우터 설정<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#히어로-모듈-라우터-설정\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe heroes feature has two interacting components, the hero list and the hero detail.\nWhen you navigate to list view, it gets a list of heroes and displays them.\nWhen you click on a hero, the detail view has to display that particular hero.\n\nYou tell the detail view which hero to display by including the selected hero's id in the route URL.\n\nImport the hero components from their new locations in the `src/app/heroes/` folder and define the two hero routes.\n\nNow that you have routes for the `Heroes` module, register them with the `Router` via the `RouterModule` as you did in the `AppRoutingModule`, with an important difference.\n\nIn the `AppRoutingModule`, you used the static `RouterModule.forRoot()` method to register the routes and application level service providers.\nIn a feature module you use the static `forChild()` method.\n\n\n<div class=\"alert is-helpful\">\n\nOnly call `RouterModule.forRoot()` in the root `AppRoutingModule`\n(or the `AppModule` if that's where you register top level application routes).\nIn any other module, you must call the `RouterModule.forChild()` method to register additional routes.\n\n</div>\n\nThe updated `HeroesRoutingModule` looks like this:\n\n\n<code-example path=\"router/src/app/heroes/heroes-routing.module.1.ts\" header=\"src/app/heroes/heroes-routing.module.ts\">\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { RouterModule, Routes } from &#39;@angular/router&#39;;\n\nimport { HeroListComponent } from &#39;./hero-list/hero-list.component&#39;;\nimport { HeroDetailComponent } from &#39;./hero-detail/hero-detail.component&#39;;\n\nconst heroesRoutes: Routes = [\n  { path: &#39;heroes&#39;,  component: HeroListComponent },\n  { path: &#39;hero/:id&#39;, component: HeroDetailComponent }\n];\n\n@NgModule({\n  imports: [\n    RouterModule.forChild(heroesRoutes)\n  ],\n  exports: [\n    RouterModule\n  ]\n})\nexport class HeroesRoutingModule { }\n\n</code-example>\n\n\n<div class=\"alert is-helpful\">\n\nConsider giving each feature module its own route configuration file.\nThough the feature routes are currently minimal, routes have a tendency to grow more complex even in small apps.\n\n</div>\n-->\n<p>히어로 모듈에서 히어로 목록을 표시하는 컴포넌트와 히어로의 세부정보를 표시하는 컴포넌트는 서로 연동되며 동작합니다.\n목록 화면은 히어로의 목록을 화면에 표시합니다.\n그리고 목록에서 히어로 한 명을 클릭하면 해당 히어로의 세부정보를 화면에 표시합니다.</p>\n<p>이 때 세부정보 화면에서 표시할 히어로를 지정하기 위해 URL에 히어로의 ID를 함께 전달합니다.</p>\n<p>이제 <code>src/app/heroes</code> 폴더로 옮긴 히어로 관련 컴포넌트를 불러와서 라우팅 규칙 2개를 정의합니다.</p>\n<p>그리고 <code>AppRoutingModule</code>에서 작업했던 것처럼 <code>Heroes</code> 모듈에 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>로 라우팅 규칙을 등록합니다.</p>\n<p><code>AppRoutingModule</code>에서는 정적 메서드 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code>를 사용해서 라우팅 규칙을 등록하며, 이 메서드를 실행하면 애플리케이션 계층에 라우터 관련 서비스 프로바이더가 등록됩니다.\n기능 모듈에서는 <code>forRoot()</code> 대신 <code>forChild()</code> 메서드를 사용합니다.</p>\n<div class=\"alert is-helpful\">\n<p><code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 메서드는 최상위 <code>AppRoutingModule</code>에서만 실행합니다.\n애플리케이션 최상위 라우팅 규칙을 <code>AppModule</code>에서 관리한다면 <code>AppModule</code>에서만 실행합니다.\n다른 모듈에서는 <code><a href=\"api/router/RouterModule#forChild\" class=\"code-anchor\">RouterModule.forChild()</a></code> 메서드를 사용해서 라우팅 규칙을 등록해야 합니다.</p>\n</div>\n<p>여기까지 작업하고 나면 <code>HeroesRoutingModule</code>의 코드는 이렇습니다:</p>\n<code-example path=\"router/src/app/heroes/heroes-routing.module.1.ts\" header=\"src/app/heroes/heroes-routing.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { HeroListComponent } from './hero-list/hero-list.component';\nimport { HeroDetailComponent } from './hero-detail/hero-detail.component';\n\nconst heroesRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'heroes',  component: HeroListComponent },\n  { path: 'hero/:id', component: HeroDetailComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forChild(heroesRoutes)\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class HeroesRoutingModule { }\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>라우팅 설정파일은 기능 모듈마다 두는 것을 권장합니다.\n기능 모듈이 관리하는 라우팅 규칙이 지금은 간단하지만 애플리케이션이 복잡해질수록 라우팅 규칙도 금방 복잡해지게 됩니다.</p>\n</div>\n<a id=\"remove-duplicate-hero-routes\"></a>\n<!--\n#### Remove duplicate hero routes\n-->\n<h4 id=\"중복된-라우팅-규칙-제거하기\">중복된 라우팅 규칙 제거하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#중복된-라우팅-규칙-제거하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe hero routes are currently defined in two places: in the `HeroesRoutingModule`,\nby way of the `HeroesModule`, and in the `AppRoutingModule`.\n\nRoutes provided by feature modules are combined together into their imported module's routes by the router.\nThis allows you to continue defining the feature module routes without modifying the main route configuration.\n\nRemove the `HeroListComponent` import and the `/heroes` route from the `app-routing.module.ts`.\n\nLeave the default and the wildcard routes as these are still in use at the top level of the application.\n\n<code-example path=\"router/src/app/app-routing.module.2.ts\" header=\"src/app/app-routing.module.ts (v2)\">\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { RouterModule, Routes } from &#39;@angular/router&#39;;\n\nimport { CrisisListComponent } from &#39;./crisis-list/crisis-list.component&#39;;\n// import { HeroListComponent } from &#39;./hero-list/hero-list.component&#39;;  // &lt;-- 이 줄을 삭제합니다.\nimport { PageNotFoundComponent } from &#39;./page-not-found/page-not-found.component&#39;;\n\nconst appRoutes: Routes = [\n  { path: &#39;crisis-center&#39;, component: CrisisListComponent },\n  // { path: &#39;heroes&#39;,     component: HeroListComponent }, // &lt;-- 이 줄을 삭제합니다.\n  { path: &#39;&#39;,   redirectTo: &#39;/heroes&#39;, pathMatch: &#39;full&#39; },\n  { path: &#39;**&#39;, component: PageNotFoundComponent }\n];\n\n@NgModule({\n  imports: [\n    RouterModule.forRoot(\n      appRoutes,\n      { enableTracing: true } // &lt;-- 디버그 활성화\n    )\n  ],\n  exports: [\n    RouterModule\n  ]\n})\nexport class AppRoutingModule {}\n\n\n</code-example>\n-->\n<p>이 시점에 히어로 기능 모듈의 라우팅 규칙은 <code>HeroesRoutingModule</code>과 <code>AppRoutingModule</code> 두 군데에 정의되어 있습니다.</p>\n<p>기능 모듈을 로드하면 이 기능 모듈에 있는 라우팅 규칙이 전체 라우팅 규칙으로 통합됩니다.\n그래서 기능 모듈에 정의한 라우팅 규칙을 조정하더라도 전체 라우팅 환경설정을 변경할 필요는 없습니다.</p>\n<p>이제 <code>app-routing.module.ts</code> 파일에서 <code>HeroListComponent</code>를 로드하는 코드와 <code>/heroes</code> 경로와 연결되는 라우팅 규칙을 제거합니다.</p>\n<p>기본 라우팅 규칙과 와일드카드 라우팅 규칙은 애플리케이션 최상위 계층에 필요하니 그대로 둡니다.</p>\n<code-example path=\"router/src/app/app-routing.module.2.ts\" header=\"src/app/app-routing.module.ts (v2)\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { CrisisListComponent } from './crisis-list/crisis-list.component';\n// import { HeroListComponent } from './hero-list/hero-list.component';  // &#x3C;-- 이 줄을 삭제합니다.\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\n\nconst appRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'crisis-center', component: CrisisListComponent },\n  // { path: 'heroes',     component: HeroListComponent }, // &#x3C;-- 이 줄을 삭제합니다.\n  { path: '',   redirectTo: '/heroes', pathMatch: 'full' },\n  { path: '**', component: PageNotFoundComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forRoot(\n      appRoutes,\n      { enableTracing: true } // &#x3C;-- 디버그 활성화\n    )\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class AppRoutingModule {}\n\n\n</code-example>\n<a id=\"merge-hero-routes\"></a>\n<!--\n#### Remove heroes declarations\n-->\n<h4 id=\"컴포넌트-등록-코드-제거하기\">컴포넌트 등록 코드 제거하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#컴포넌트-등록-코드-제거하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nBecause the `HeroesModule` now provides the `HeroListComponent`, remove it from the `AppModule`'s `declarations` array.\nNow that you have a separate `HeroesModule`, you can evolve the hero feature with more components and different routes.\n\nAfter these steps, the `AppModule` should look like this:\n\n<code-example path=\"router/src/app/app.module.3.ts\" header=\"src/app/app.module.ts\" region=\"remove-heroes\">\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { BrowserModule } from &#39;@angular/platform-browser&#39;;\nimport { FormsModule } from &#39;@angular/forms&#39;;\nimport { AppComponent } from &#39;./app.component&#39;;\nimport { AppRoutingModule } from &#39;./app-routing.module&#39;;\nimport { HeroesModule } from &#39;./heroes/heroes.module&#39;;\n\nimport { CrisisListComponent } from &#39;./crisis-list/crisis-list.component&#39;;\nimport { PageNotFoundComponent } from &#39;./page-not-found/page-not-found.component&#39;;\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    FormsModule,\n    HeroesModule,\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    CrisisListComponent,\n    PageNotFoundComponent\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n</code-example>\n-->\n<p><code>HeroListComponent</code>는 이제 <code>HeroesModule</code>에서 제공하기 때문에 <code>AppModule</code> <code>declarations</code> 배열에서는 제거합니다.\n그러면 히어로와 관련된 기능은 모두 <code>HeroesModule</code> 안으로 구성되기 때문에, 이제부터 히어로와 관련된 컴포넌트와 라우팅 규칙은 <code>HeroesModule</code>을 기준으로 확장할 수 있습니다.</p>\n<p>여기까지 작업하고 나면 <code>AppModule</code>의 코드는 이렇습니다:</p>\n<code-example path=\"router/src/app/app.module.3.ts\" header=\"src/app/app.module.ts\" region=\"remove-heroes\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { AppComponent } from './app.component';\nimport { AppRoutingModule } from './app-routing.module';\nimport { HeroesModule } from './heroes/heroes.module';\n\nimport { CrisisListComponent } from './crisis-list/crisis-list.component';\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    HeroesModule,\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    CrisisListComponent,\n    PageNotFoundComponent\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n</code-example>\n<a id=\"routing-module-order\"></a>\n<!--\n### Module import order\n-->\n<h3 id=\"모듈을-로드하는-순서\">모듈을 로드하는 순서<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#모듈을-로드하는-순서\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nNotice that in the module `imports` array, the `AppRoutingModule` is last and comes _after_ the `HeroesModule`.\n\n<code-example path=\"router/src/app/app.module.3.ts\" region=\"module-imports\" header=\"src/app/app.module.ts (module-imports)\">\nimports: [\n  BrowserModule,\n  FormsModule,\n  HeroesModule,\n  AppRoutingModule\n],\n\n</code-example>\n\n\nThe order of route configuration is important because the router accepts the first route that matches a navigation request path.\n\nWhen all routes were in one `AppRoutingModule`, you put the default and [wildcard](#wildcard) routes last, after the `/heroes` route, so that the router had a chance to match a URL to the `/heroes` route _before_ hitting the wildcard route and navigating to \"Page not found\".\n\nEach routing module augments the route configuration in the order of import.\nIf you listed `AppRoutingModule` first, the wildcard route would be registered _before_ the hero routes.\nThe wildcard route&mdash;which matches _every_ URL&mdash;would intercept the attempt to navigate to a hero route.\n\n\n<div class=\"alert is-helpful\">\n\nReverse the routing modules to see a click of the heroes link resulting in \"Page not found\".\nLearn about inspecting the runtime router configuration [below](#inspect-config \"Inspect the router config\").\n\n</div>\n-->\n<p><code>AppModule</code>의 <code>imports</code> 배열을 보면 <code>AppRoutingModule</code>이 <code>HeroesModule</code> <em>뒤에</em> 추가된 것을 확인할 수 있습니다.</p>\n<code-example path=\"router/src/app/app.module.3.ts\" region=\"module-imports\" header=\"src/app/app.module.ts (module-imports)\">\nimports: [\n  <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n  <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n  HeroesModule,\n  AppRoutingModule\n],\n\n</code-example>\n<p>라우터는 전체 라우팅 규칙 중에서 첫 번째로 매칭되는 라우팅 규칙을 적용하기 때문에 라우팅 규칙을 등록하는 순서가 중요합니다.</p>\n<p>그리고 모든 라우팅 규칙은 <code>AppRoutingModule</code>로 통합되기 때문에 <a href=\"guide/router-tutorial-toh#wildcard\">와일드카드</a> 라우팅 규칙은 <code>/heroes</code> 라우팅 규칙의 뒤, 전체 라우팅 규칙의 마지막에 등록되어야 합니다.\n그래야 모든 주소와 매칭되는 와일드카드 라우팅 규칙이 매칭되기 <em>전에</em> URL이 <code>/heroes</code> 라우팅과 매칭되는지 검사할 수 있습니다.</p>\n<p>각 라우팅 모듈은 <code>AppRoutingModule</code>에 로드되는 순서대로 통합됩니다.\n그래서 <code>AppRoutingModule</code>을 제일 처음 로드하면 와일드카드 라우팅 규칙이 히어로 모듈의 라우팅 규칙보다 <em>먼저</em> 등록됩니다.\n그러면 와일드카드 라우팅 규칙이 <em>모든</em> URL과 매칭되면서 화면을 찾을 수 없다는 문구만 표시됩니다.</p>\n<div class=\"alert is-helpful\">\n<p>라우팅 모듈을 로드하는 순서를 거꾸로 하면 히어로 목록으로 가는 링크를 클릭했을 때 \"Page not found\"가 표시됩니다.\n실행되고 있는 애플리케이션의 라우팅 환경 설정을 확인하는 방법은 <a href=\"guide/router-tutorial-toh#inspect-config\" title=\"Inspect the router config\">아래</a>에서 다룹니다.</p>\n</div>\n<!--\n### Route Parameters\n-->\n<h3 id=\"라우팅-인자\">라우팅 인자<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#라우팅-인자\"><i class=\"material-icons\">link</i></a></h3>\n<a id=\"route-def-with-parameter\"></a>\n<!--\n#### Route definition with a parameter\n-->\n<h4 id=\"라우팅-인자를-사용하는-라우팅-규칙-정의하기\">라우팅 인자를 사용하는 라우팅 규칙 정의하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#라우팅-인자를-사용하는-라우팅-규칙-정의하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nReturn to the `HeroesRoutingModule` and look at the route definitions again.\nThe route to `HeroDetailComponent` has an `:id` token in the path.\n\n<code-example path=\"router/src/app/heroes/heroes-routing.module.1.ts\" header=\"src/app/heroes/heroes-routing.module.ts (excerpt)\" region=\"hero-detail-route\">\n{ path: &#39;hero/:id&#39;, component: HeroDetailComponent }\n\n</code-example>\n\nThe `:id` token creates a slot in the path for a Route Parameter.\nIn this case,  this configuration causes the router to insert the `id` of a hero into that slot.\n\nIf you tell the router to navigate to the detail component and display \"Magneta\", you expect a hero id to appear in the browser URL like this:\n\n\n<code-example format=\"nocode\">\n  localhost:4200/hero/15\n\n</code-example>\n\n\n\nIf a user enters that URL into the browser address bar, the router should recognize the pattern and go to the same \"Magneta\" detail view.\n\n\n<div class=\"callout is-helpful\">\n\n<header>\n  Route parameter: Required or optional?\n</header>\n\nEmbedding the route parameter token, `:id`, in the route definition path is a good choice for this scenario because the `id` is *required* by the `HeroDetailComponent` and because the value `15` in the path clearly distinguishes the route to \"Magneta\" from a route for some other hero.\n\n</div>\n-->\n<p><code>HeroesRoutingModule</code>로 돌아가서 라우팅 규칙을 정의한 코드를 봅시다.\n<code>HeroDetailComponent</code>와 연결된 주소에 <code>:id</code> 토큰이 사용된 것을 확인할 수 있습니다.</p>\n<code-example path=\"router/src/app/heroes/heroes-routing.module.1.ts\" header=\"src/app/heroes/heroes-routing.module.ts (excerpt)\" region=\"hero-detail-route\">\n{ path: 'hero/:id', component: HeroDetailComponent }\n\n</code-example>\n<p><code>:id</code> 토큰은 라우팅 인자(route parameter)를 선언하는 역할을 합니다.\n이 토큰이 사용되면 나중에 히어로의 <code>id</code>가 인자로 전달됩니다.</p>\n<p><code>id</code>가 <code>15</code>에 해당하는 \"Magneta\" 히어로의 세부정보를 화면에 표시하려면 브라우저 URL을 이렇게 구성하면 됩니다:</p>\n<code-example format=\"nocode\">\n  localhost:4200/hero/15\n\n</code-example>\n<p>사용자가 브라우저 주소표시줄에 이 URL을 입력하면 라우터가 이 주소의 패턴을 인식해서 해당 히어로의 세부정보를 화면에 표시합니다.</p>\n<div class=\"callout is-helpful\">\n<header>\n  라우팅 인자: 필수일까 옵션일까?\n</header>\n<p><code>HeroDetailComponent</code>에 <code>id</code>가 <em>반드시 필요</em> 하다면 <code>:id</code> 라는 토큰을 라우팅 규칙에 심는 것이 좋습니다.\n이 시나리오에서는 원하는 히어로를 확실하게 구별하는 정보가 꼭 필요하기 때문입니다.</p>\n</div>\n<a id=\"route-parameters\"></a>\n<!--\n#### Setting the route parameters in the list view\n-->\n<h4 id=\"목록-화면에서-라우팅-인자-설정하기\">목록 화면에서 라우팅 인자 설정하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#목록-화면에서-라우팅-인자-설정하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nAfter navigating to the `HeroDetailComponent`, you expect to see the details of the selected hero.\nYou need two pieces of information: the routing path to the component and the hero's `id`.\n\nAccordingly, the _link parameters array_ has two items: the routing _path_ and a _route parameter_ that specifies the\n`id` of the selected hero.\n\n<code-example path=\"router/src/app/heroes/hero-list/hero-list.component.1.html\" header=\"src/app/heroes/hero-list/hero-list.component.html (link-parameters-array)\" region=\"link-parameters-array\">\n&lt;a [routerLink]=&quot;[&#39;/hero&#39;, hero.id]&quot;&gt;\n\n</code-example>\n\nThe router composes the destination URL from the array like this: `localhost:4200/hero/15`.\n\nThe router extracts the route parameter (`id:15`) from the URL and supplies it to\nthe `HeroDetailComponent` via the `ActivatedRoute` service.\n-->\n<p><code>HeroDetailComponent</code>로 이동하고 나면 특정 히어로의 세부정보를 볼 수 있어야 합니다.\n이 동작을 위해 두 가지 정보가 필요합니다.\n컴포넌트로 향하는 주소와 히어로의 <code>id</code>입니다.</p>\n<p>그래서 <em>링크 인자 배열(link parameters array)</em> 는 2개 항목으로 구성됩니다.\n첫 번째는 컴포넌트로 이동할 때 사용하는 <em>주소</em> 이고, 두 번째는 원하는 히어로를 지정하기 위한 <code>id</code> 입니다.</p>\n<code-example path=\"router/src/app/heroes/hero-list/hero-list.component.1.html\" header=\"src/app/heroes/hero-list/hero-list.component.html (링브 인자 배열)\" region=\"link-parameters-array\">\n&#x3C;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/hero', hero.id]\">\n\n</code-example>\n<p>그러면 라우터가 최종 URL을 <code>localhost:4200/hero/15</code>와 같이 구성합니다.</p>\n<p>그리고 <code>HeroDetailComponent</code>로 이동하고 나면 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 서비스를 사용해서 라우터가 주소에서 추출한 라우팅 인자(<code>id:15</code>)를 참조할 수 있습니다.</p>\n<a id=\"activated-route-in-action\"></a>\n<!--\n### `Activated Route` in action\n-->\n<h3 id=\"activatedroute-사용하기\"><code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 사용하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#activatedroute-사용하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nImport the `Router`, `ActivatedRoute`, and `ParamMap` tokens from the router package.\n\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.1.ts\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (activated route)\" region=\"imports\">\nimport { Router, ActivatedRoute, ParamMap } from &#39;@angular/router&#39;;\n\n</code-example>\n\nImport the `switchMap` operator because you need it later to process the `Observable` route parameters.\n\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.3.ts\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (switchMap operator import)\" region=\"rxjs-operator-import\">\nimport { switchMap } from &#39;rxjs/operators&#39;;\n\n</code-example>\n\n<a id=\"hero-detail-ctor\"></a>\n\nAdd the services as private variables to the constructor so that Angular injects them (makes them visible to the component).\n\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.3.ts\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (constructor)\" region=\"ctor\">\nconstructor(\n  private route: ActivatedRoute,\n  private router: Router,\n  private service: HeroService\n) {}\n\n</code-example>\n\nIn the `ngOnInit()` method, use the `ActivatedRoute` service to retrieve the parameters for the route, pull the hero `id` from the parameters, and retrieve the hero to display.\n\n\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.3.ts\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (ngOnInit)\" region=\"ngOnInit\">\nngOnInit() {\n  this.hero$ = this.route.paramMap.pipe(\n    switchMap((params: ParamMap) =&gt;\n      this.service.getHero(params.get(&#39;id&#39;)))\n  );\n}\n\n</code-example>\n\nWhen the map changes, `paramMap` gets the `id` parameter from the changed parameters.\n\nThen you tell the `HeroService` to fetch the hero with that `id` and return the result of the `HeroService` request.\n\nThe `switchMap` operator does two things. It flattens the `Observable<Hero>` that `HeroService` returns and cancels previous pending requests.\nIf the user re-navigates to this route with a new `id` while the `HeroService` is still retrieving the old `id`, `switchMap` discards that old request and returns the hero for the new `id`.\n\n`AsyncPipe` handles the observable subscription and the component's `hero` property will be (re)set with the retrieved hero.\n-->\n<p>라우터 패키지로 제공되는 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>, <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>, <code><a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a></code> 토큰을 로드합니다.</p>\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.1.ts\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (활성화된 라우팅 규칙)\" region=\"imports\">\nimport { <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>, <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, <a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a> } from '@angular/router';\n\n</code-example>\n<p>그리고 <code>Observable</code>로 제공되는 라우팅 인자를 처리하기 위해 <code>switchMap</code> 연산자를 로드합니다.</p>\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.3.ts\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (switchMap 연산자 로드하기)\" region=\"rxjs-operator-import\">\nimport { switchMap } from 'rxjs/operators';\n\n</code-example>\n<a id=\"hero-detail-ctor\"></a>\n<p><code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 서비스를 <code>private</code> 변수로 선언해서 생성자에 선언하면 Angular가 이 서비스를 의존성 객체로 주입합니다.</p>\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.3.ts\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (생성자)\" region=\"ctor\">\nconstructor(\n  private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>,\n  private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,\n  private service: HeroService\n) {}\n\n</code-example>\n<p>그리고 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 서비스에서 라우팅 인자를 참조하는 로직은 <code>ngOnInit()</code> 메서드에 작성합니다.</p>\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.3.ts\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (ngOnInit())\" region=\"ngOnInit\">\nngOnInit() {\n  this.hero$ = this.route.paramMap.pipe(\n    switchMap((params: <a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a>) =>\n      this.service.getHero(params.get('id')))\n  );\n}\n\n</code-example>\n<p>접근하는 주소가 변경되면 <code>paramMap</code>이 전달하는 <code>id</code> 인자도 변경됩니다.</p>\n<p><code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 서비스에서 <code>id</code>를 받아오고 나면 <code>HeroService</code>로 해당 히어로 데이터를 가져오면 됩니다.</p>\n<p><code>switchMap</code> 연산자는 두 가지 동작을 합니다.\n<code>switchMap</code> 연산자는 <code>Observable&#x3C;Hero></code> 타입을 <code>HeroService</code>가 반환하는 데이터 타입으로 변경하며, 이전에 완료되지 않은 요청은 취소합니다.\n그래서 아직 <code>HeroService</code>의 동작이 끝나지 않았을 때 다른 <code>id</code>로 다시 컴포넌트를 띄우면 <code>switchMap</code>이 이전에 보냈던 요청을 취소하고 새로운 <code>id</code>로 히어로 데이터를 요청합니다.</p>\n<p>이렇게 받아온 히어로 데이터는 컴포넌트 <code>hero$</code> 프로퍼티에 할당되며, 이 프로퍼티는 <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">AsyncPipe</a></code>를 사용해서 템플릿이 자동으로 구독합니다.</p>\n<h4 id=\"parammap-api\"><em>ParamMap</em> API<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#parammap-api\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe `ParamMap` API is inspired by the [URLSearchParams interface](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams).\nIt provides methods to handle parameter access for both route parameters (`paramMap`) and query parameters (`queryParamMap`).\n\n<table>\n  <tr>\n    <th>\n      Member\n    </th>\n\n    <th>\n      Description\n    </th>\n  </tr>\n\n  <tr>\n    <td>\n      <code>has(name)</code>\n    </td>\n    <td>\n\n    Returns `true` if the parameter name is in the map of parameters.\n\n    </td>\n  </tr>\n\n  <tr>\n    <td>\n      <code>get(name)</code>\n    </td>\n    <td>\n\n    Returns the parameter name value (a `string`) if present, or `null` if the parameter name is not in the map. Returns the _first_ element if the parameter value is actually an array of values.\n\n    </td>\n  </tr>\n\n  <tr>\n    <td>\n      <code>getAll(name)</code>\n    </td>\n    <td>\n\n    Returns a `string array` of the parameter name value if found, or an empty `array` if the parameter name value is not in the map. Use `getAll` when a single parameter could have multiple values.\n\n    </td>\n  </tr>\n\n  <tr>\n    <td>\n      <code>keys</code>\n    </td>\n    <td>\n\n    Returns a `string array` of all parameter names in the map.\n\n    </td>\n  </tr>\n</table>\n-->\n<p><code><a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a></code> API는 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams\">URLSearchParams 인터페이스</a>에서 영감을 받았습니다.\n이 API를 활용하면 라우팅 인자(<code>paramMap</code>)를 참조하거나 쿼리 인자(<code>queryParamMap</code>)을 참조할 수 있습니다.</p>\n<table>\n  <tbody><tr>\n    <th>\n      멤버\n    </th>\n    <th>\n      설명\n    </th>\n  </tr>\n  <tr>\n    <td>\n      <code>has(name)</code>\n    </td>\n    <td>\n<p>    전달된 이름으로 인자가 존재하면 <code>true</code>를 반환합니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>get(name)</code>\n    </td>\n    <td>\n<p>    전달된 이름으로 인자가 존재하면 해당 인자(<code>string</code>)를 반환하고, 존재하지 않으면 <code>null</code>을 반환합니다.\n값이 배열 형태로 존재하면 <em>첫 번째</em> 항목을 반환합니다.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>getAll(name)</code>\n    </td>\n    <td>\n<p>    전달된 이름으로 인자가 존재하면 해당 인자를 모두(<code>string</code> 배열)로 반환하고, 존재하지 않으면 빈 배열(<code>[]</code>)을 반환합니다.\n인자가 여러 개 존재할 수 있는 상황이라면 <code>getAll()</code>를 사용하세요.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>keys</code>\n    </td>\n    <td>\n<p>    맵에 존재하는 모든 인자의 이름을 문자열 배열 형태로 반환합니다.</p>\n    </td>\n  </tr>\n</tbody></table>\n<a id=\"reuse\"></a>\n<!--\n#### Observable <i>paramMap</i> and component reuse\n-->\n<h4 id=\"parammap-옵저버블과-컴포넌트-재사용\"><i>paramMap</i> 옵저버블과 컴포넌트 재사용<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#parammap-옵저버블과-컴포넌트-재사용\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nIn this example, you retrieve the route parameter map from an `Observable`.\nThat implies that the route parameter map can change during the lifetime of this component.\n\nBy default, the router re-uses a component instance when it re-navigates to the same component type\nwithout visiting a different component first. The route parameters could change each time.\n\nSuppose a parent component navigation bar had \"forward\" and \"back\" buttons\nthat scrolled through the list of heroes.\nEach click navigated imperatively to the `HeroDetailComponent` with the next or previous `id`.\n\nYou wouldn't want the router to remove the current `HeroDetailComponent` instance from the DOM only to re-create it for the next `id` as this would re-render the view.\nFor better UX, the router re-uses the same component instance and updates the parameter.\n\nSince `ngOnInit()` is only called once per component instantiation, you can detect when the route parameters change from _within the same instance_ using the observable `paramMap` property.\n\n\n<div class=\"alert is-helpful\">\n\nWhen subscribing to an observable in a component, you almost always unsubscribe when the component is destroyed.\n\nHowever, `ActivatedRoute` observables are among the exceptions because `ActivatedRoute` and its observables are insulated from the `Router` itself.\nThe `Router` destroys a routed component when it is no longer needed along with the injected `ActivatedRoute`.\n\n</div>\n-->\n<p>예제 앱에서 라우팅 인자를 받아오는 맵은 <code>Observable</code> 타입입니다.\n이 옵저버블로 전달되는 인자는 컴포넌트 라이프싸이클에 따라 변경될 수 있습니다.</p>\n<p>기본적으로 라우터는 어떤 컴포넌트가 다른 컴포넌트를 거치지 않고 같은 컴포넌트로 전환하면 해당 컴포넌트 인스턴스를 재사용합니다.\n이 때 라우팅 인자는 변경될 수 있습니다.</p>\n<p>부모 컴포넌트에서 \"forward\", \"back\" 버튼으로 목록에 있는 히어로를 스크롤한다고 합시다.\n그러면 화면이 전환될 때마다 다른 <code>id</code> 값으로 <code>HeroDetailComponent</code>이 재사용될 것입니다.</p>\n<p>어쩌면 현재 DOM에 존재하는 <code>HeroDetailComponent</code> 인스턴스를 제거하고 새로 받는 <code>id</code>로 화면을 다시 렌더링하는 것을 원할 수도 있습니다.\n하지만 더 나은 UX를 위해서라면 컴포넌트 인스턴스는 그대로 재사용하고 인자만 새로 받아서 갱신하는 방식이 더 좋습니다.</p>\n<p>다만, <code>ngOnInit()</code>은 컴포넌트가 초기화된 후에 한번만 실행되기 때문에 <em>같은 컴포넌트 인스턴스에서</em> 라우팅 인자가 변경되는 것을 감지하려면 <code>paramMap</code> 옵저버블을 구독해야 합니다.</p>\n<div class=\"alert is-helpful\">\n<p>컴포넌트 안에서 옵저버블을 구독하면 컴포넌트가 종료될때 이 옵저버블 구독을 반드시 해지해야 합니다.</p>\n<p>하지만 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 옵저버블은 예외인데, <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 인스턴스와 이 인스턴스가 제공하는 옵저버블은 모두 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>와 별개입니다.\n<code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>는 라우팅 대상 컴포넌트에 의존성으로 주입되는 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>를 사용할 필요가 없을 때 해당 컴포넌트를 종료합니다.</p>\n</div>\n<a id=\"snapshot\"></a>\n<a id=\"snapshot-the-no-observable-alternative\"></a>\n<!--\n#### `snapshot`: the no-observable alternative\n-->\n<h4 id=\"snapshot-옵저버블을-사용하지-않는-방식\"><code>snapshot</code>: 옵저버블을 사용하지 않는 방식<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#snapshot-옵저버블을-사용하지-않는-방식\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThis application won't re-use the `HeroDetailComponent`.\nThe user always returns to the hero list to select another hero to view.\nThere's no way to navigate from one hero detail to another hero detail without visiting the list component in between.\nTherefore, the router creates a new `HeroDetailComponent` instance every time.\n\nWhen you know for certain that a `HeroDetailComponent` instance will never be re-used, you can use `snapshot`.\n\n`route.snapshot` provides the initial value of the route parameter map.\nYou can access the parameters directly without subscribing or adding observable operators as in the following:\n\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.2.ts\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (ngOnInit snapshot)\" region=\"snapshot\">\nngOnInit() {\n  const id = this.route.snapshot.paramMap.get(&#39;id&#39;);\n\n  this.hero$ = this.service.getHero(id);\n}\n\n</code-example>\n\n<div class=\"alert is-helpful\">\n\n`snapshot` only gets the initial value of the parameter map with this technique.\nUse the observable `paramMap` approach if there's a possibility that the router could re-use the component.\nThis tutorial sample app uses with the observable `paramMap`.\n\n</div>\n-->\n<p>예제 앱에서는 <code>HeroDetailComponent</code>를 재사용하지 않습니다.\n사용자가 다른 히어로의 상세정보를 보려면 반드시 히어로 목록 화면으로 돌아와야 하며, 히어로 목록을 표시하는 컴포넌트를 건너뛰고 다른 히어로의 상세정보를 확인하는 방법은 없습니다.\n그래서 라우터는 매번 <code>HeroDetailComponent</code>의 인스턴스를 새로 생성합니다.</p>\n<p><code>HeroDetailComponent</code> 인스턴스가 재사용되지 않는다는 것을 확신할 수 있으면 <code>snapshot</code>을 활용하는 방법도 좋습니다.</p>\n<p><code>route.snapshot</code>은 라우팅 인자의 최초값을 제공합니다.\n이 객체는 옵저버블이 아니기 때문에 구독하거나 옵저버블 연산자를 사용하지 않아도 직접 참조할 수 있습니다:</p>\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.2.ts\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (ngOnInit() 스냅샷)\" region=\"snapshot\">\nngOnInit() {\n  const id = this.route.snapshot.paramMap.get('id');\n\n  this.hero$ = this.service.getHero(id);\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p><code>snapshot</code>으로 참조할 수 있는 라우팅 인자는 해당 라우팅 인자의 최초값 뿐입니다.\n라우터가 컴포넌트를 재사용할 가능성이 있다면 <code>paramMap</code> 옵저버블을 사용해야 합니다.\n이 문서에서는 <code>paramMap</code> 옵저버블을 사용하는 방식을 기준으로 설명합니다.</p>\n</div>\n<a id=\"nav-to-list\"></a>\n<!--\n### Navigating back to the list component\n-->\n<h3 id=\"이전-화면으로-전환하기\">이전 화면으로 전환하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#이전-화면으로-전환하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe `HeroDetailComponent` \"Back\" button uses the `gotoHeroes()` method that navigates imperatively back to the `HeroListComponent`.\n\nThe router `navigate()` method takes the same one-item _link parameters array_ that you can bind to a `[routerLink]` directive.\nIt holds the path to the `HeroListComponent`:\n\n\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.1.ts\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (excerpt)\" region=\"gotoHeroes\">\ngotoHeroes() {\n  this.router.navigate([&#39;/heroes&#39;]);\n}\n\n</code-example>\n-->\n<p><code>HeroDetailComponent</code>에 있는 \"Back\" 버튼은 <code>gotoHeroes()</code> 메서드를 실행해서 이전 화면인 <code>HeroListComponent</code>로 이동합니다.</p>\n<p>라우터가 제공하는 <code>navigate()</code> 메서드는 <code>[<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]</code> 디렉티브와 비슷하게 항목이 하나인 <em>링크 인자 배열</em> 을 받습니다.\n이 인자에는 <code>HeroListComponent</code>에 해당하는 주소를 지정하면 됩니다:</p>\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.1.ts\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (일부)\" region=\"gotoHeroes\">\ngotoHeroes() {\n  this.router.navigate(['/heroes']);\n}\n\n</code-example>\n<a id=\"optional-route-parameters\"></a>\n<!--\n#### Route Parameters: Required or optional?\n-->\n<h4 id=\"라우팅-인자-필수일까-옵션일까\">라우팅 인자: 필수일까 옵션일까?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#라우팅-인자-필수일까-옵션일까\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nUse [route parameters](#route-parameters) to specify a required parameter value within the route URL\nas you do when navigating to the `HeroDetailComponent` in order to view the hero with `id` 15:\n\n\n<code-example format=\"nocode\">\n  localhost:4200/hero/15\n\n</code-example>\n\n\n\nYou can also add optional information to a route request.\nFor example, when returning to the `hero-detail.component.ts` list from the hero detail view, it would be nice if the viewed hero were preselected in the list.\n\n<div class=\"lightbox\">\n  <img src='generated/images/guide/router/selected-hero.png' alt=\"Selected hero\">\n</div>\n\nYou implement this feature by including the viewed hero's `id` in the URL as an optional parameter when returning from the `HeroDetailComponent`.\n\nOptional information can also include other forms such as:\n\n* Loosely structured search criteria; for example, `name='wind*'`.\n* Multiple values;  for example, `after='12/31/2015' & before='1/1/2017'`&mdash;in no\nparticular order&mdash;`before='1/1/2017' & after='12/31/2015'`&mdash; in a\nvariety of formats&mdash;`during='currentYear'`.\n\nAs these kinds of parameters don't fit easily in a URL path, you can use optional parameters for conveying arbitrarily complex information during navigation.\nOptional parameters aren't involved in pattern matching and afford flexibility of expression.\n\nThe router supports navigation with optional parameters as well as required route parameters.\nDefine optional parameters in a separate object _after_ you define the required route parameters.\n\nIn general, use a required route parameter when the value is mandatory (for example, if necessary to distinguish one route path from another); and an optional parameter when the value is optional, complex, and/or multivariate.\n-->\n<p><code>HeroDetailComponent</code>를 렌더링할 때 <code>id=15</code>에 해당하는 히어로를 찾아오는 경우와 같이, 화면을 전환하면서 필수 인자를 지정해야 한다면 <a href=\"guide/router-tutorial-toh#route-parameters\">라우팅 인자</a>를 활용해야 합니다.</p>\n<code-example format=\"nocode\">\n  localhost:4200/hero/15\n\n</code-example>\n<p>화면을 전환할 때는 추가 정보를 함께 전달할 수도 있습니다.\n<code>HeroDetailComponent</code> 화면에서 히어로 목록 화면으로 돌아올 때 이전에 선택했던 히어로를 다르게 표시하면 UX에 도움이 될 것입니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/router/selected-hero.png\" alt=\"Selected hero\" width=\"336\" height=\"110\">\n</div>\n<p>이 동작은 <code>HeroDetailComponent</code>에서 봤던 히어로의 <code>id</code>를 이전 화면으로 돌아가는 URL에 옵션 라우팅 인자로 추가하면 됩니다.</p>\n<p>옵션 라우팅 인자는 이런 형식으로 구성합니다:</p>\n<ul>\n<li>타입이 엄격하지 않은 경우: <code>name='wind*'</code></li>\n<li>값이 여러개인 경우: <code>after='12/31/2015' &#x26; before='1/1/2017'</code> — 순서가 정해져있지 않다면 — <code>before='1/1/2017' &#x26; after='12/31/2015'</code> — 정해진 형식에 따라 — <code>during='currentYear'</code></li>\n</ul>\n<p>이런 옵션 라우팅 인자들은 URL 주소와 매칭되지 않기 때문에 아무리 복잡한 정보라도 URL과 함께 자유롭게 전달할 수 있습니다.\n옵션 라우팅 인자는 라우터가 적용하는 URL 패턴 매칭과 별개로 동작하기 때문에 상대적으로 유연합니다.</p>\n<p>옵션 라우팅 인자는 필수 라우팅 인자와 마찬가지로 라우팅하면서 지정할 수도 있습니다.\n링크 배열의 이동하려는 주소 <em>다음에</em> 객체 형태로 지정하면 됩니다.</p>\n<p>일반적으로 화면을 전환하면서 꼭 필요한 값은 필수 라우팅 인자로 사용하고, 생략할 수 있으며 복잡하거나 개수가 변경될 수 있으면 옵션 라우팅 인자로 사용합니다.</p>\n<a id=\"optionally-selecting\"></a>\n<!--\n#### Heroes list: optionally selecting a hero\n-->\n<h4 id=\"히어로-목록-히어로-선택하기옵션\">히어로 목록: 히어로 선택하기(옵션)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#히어로-목록-히어로-선택하기옵션\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nWhen navigating to the `HeroDetailComponent` you specified the required `id` of the hero-to-edit in the\nroute parameter and made it the second item of the [_link parameters array_](#link-parameters-array).\n\n<code-example path=\"router/src/app/heroes/hero-list/hero-list.component.1.html\" header=\"src/app/heroes/hero-list/hero-list.component.html (link-parameters-array)\" region=\"link-parameters-array\">\n&lt;a [routerLink]=&quot;[&#39;/hero&#39;, hero.id]&quot;&gt;\n\n</code-example>\n\nThe router embedded the `id` value in the navigation URL because you had defined it as a route parameter with an `:id` placeholder token in the route `path`:\n\n<code-example path=\"router/src/app/heroes/heroes-routing.module.1.ts\" header=\"src/app/heroes/heroes-routing.module.ts (hero-detail-route)\" region=\"hero-detail-route\">\n{ path: &#39;hero/:id&#39;, component: HeroDetailComponent }\n\n</code-example>\n\nWhen the user clicks the back button, the `HeroDetailComponent` constructs another _link parameters array_\nwhich it uses to navigate back to the `HeroListComponent`.\n\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.1.ts\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (gotoHeroes)\" region=\"gotoHeroes\">\ngotoHeroes() {\n  this.router.navigate([&#39;/heroes&#39;]);\n}\n\n</code-example>\n\nThis array lacks a route parameter because previously you didn't need to send information to the `HeroListComponent`.\n\nNow, send the `id` of the current hero with the navigation request so that the\n`HeroListComponent` can highlight that hero in its list.\n\nSend the `id` with an object that contains an optional `id` parameter.\nFor demonstration purposes, there's an extra junk parameter (`foo`) in the object that the `HeroListComponent` should ignore.\nHere's the revised navigation statement:\n\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.3.ts\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (go to heroes)\" region=\"gotoHeroes\">\ngotoHeroes(hero: Hero) {\n  const heroId = hero ? hero.id : null;\n  // HeroList 컴포넌트에서 히어로를 선택하기 위해 히어로의 id를 전달합니다.\n  // &#39;foo&#39; 프로퍼티는 사용하지 않는 프로퍼티입니다.\n  this.router.navigate([&#39;/heroes&#39;, { id: heroId, foo: &#39;foo&#39; }]);\n}\n\n</code-example>\n\nThe application still works. Clicking \"back\" returns to the hero list view.\n\nLook at the browser address bar.\n\nIt should look something like this, depending on where you run it:\n\n<code-example language=\"bash\">\n  localhost:4200/heroes;id=15;foo=foo\n\n</code-example>\n\nThe `id` value appears in the URL as (`;id=15;foo=foo`), not in the URL path.\nThe path for the \"Heroes\" route doesn't have an `:id` token.\n\nThe optional route parameters are not separated by \"?\" and \"&\" as they would be in the URL query string.\nThey are separated by semicolons \";\".\nThis is matrix URL notation.\n\n<div class=\"alert is-helpful\">\n\nMatrix URL notation is an idea first introduced in a [1996 proposal](http://www.w3.org/DesignIssues/MatrixURIs.html) by the founder of the web, Tim Berners-Lee.\n\nAlthough matrix notation never made it into the HTML standard, it is legal and it became popular among browser routing systems as a way to isolate parameters belonging to parent and child routes.\nAs such, the Router provides support for the matrix notation across browsers.\n\n</div>\n-->\n<p><code>HeroDetailComponent</code>로 화면을 전환할 때는 상세정보 화면에 표시할 히어로의 <code>id</code>를 <a href=\"guide/router-tutorial-toh#link-parameters-array\"><em>링크 인자 배열</em></a>의 두 번째 항목으로 전달할 수 있습니다.</p>\n<code-example path=\"router/src/app/heroes/hero-list/hero-list.component.1.html\" header=\"src/app/heroes/hero-list/hero-list.component.html (link-parameters-array)\" region=\"link-parameters-array\">\n&#x3C;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/hero', hero.id]\">\n\n</code-example>\n<p>그러면 해당 라우팅 규칙의 <code>path</code> 프로퍼티에 <code>:id</code> 토큰이 존재하기 때문에, 라우터는 <code>id</code> 값을 심어서 최종 URL을 구성합니다:</p>\n<code-example path=\"router/src/app/heroes/heroes-routing.module.1.ts\" header=\"src/app/heroes/heroes-routing.module.ts (hero-detail-route)\" region=\"hero-detail-route\">\n{ path: 'hero/:id', component: HeroDetailComponent }\n\n</code-example>\n<p>그리고 사용자가 뒤로가기 버튼을 클릭하면 <code>HeroDetailComponent</code>는 <code>HeroListComponent</code>로 돌아가기 위해 새로운 <em>링크 인자 배열</em> 을 구성합니다.</p>\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.1.ts\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (gotoHeroes())\" region=\"gotoHeroes\">\ngotoHeroes() {\n  this.router.navigate(['/heroes']);\n}\n\n</code-example>\n<p>이 배열에는 라우팅 인자가 없습니다.\n왜냐하면 <code>HeroListComponent</code>에 필요한 필수 라우팅 인자가 없기 때문입니다.</p>\n<p>하지만 이제는 상세정보에서 봤던 히어로의 <code>id</code>를 <code>HeroListComponent</code>로 전달해서 이 히어로를 목록에서 하이라이트 처리해 봅시다.</p>\n<p><code>id</code> 값은 객체 형태로 전달합니다.\n이 객체에 불필요한 인자(<code>foo</code>)가 있더라도 해당 인자는 <code>HeroListComponent</code>에서 무시하면 됩니다.\n이제 라우팅 주소를 이렇게 구성할 수 있습니다:</p>\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.3.ts\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (목록으로 돌아가기)\" region=\"gotoHeroes\">\ngotoHeroes(hero: Hero) {\n  const heroId = hero ? hero.id : null;\n  // HeroList 컴포넌트에서 히어로를 선택하기 위해 히어로의 id를 전달합니다.\n  // 'foo' 프로퍼티는 사용하지 않는 프로퍼티입니다.\n  this.router.navigate(['/heroes', { id: heroId, foo: 'foo' }]);\n}\n\n</code-example>\n<p>애플리케이션에서 직접 확인해보세요.\n\"back\" 버튼을 클릭하면 히어로 목록 화면으로 돌아갑니다.</p>\n<p>이 때 브라우저 주소표시줄을 확인하면 주소가 이런식으로 표시되는 것을 확인할 수 있습니다:</p>\n<code-example language=\"bash\">\n  localhost:4200/heroes;id=15;foo=foo\n\n</code-example>\n<p><code>id</code> 값은 URL에 존재하지만(<code>;id=15;foo=foo</code>) URL 주소 부분에 있는 것은 아닙니다.\n<code>/heroes</code> 주소에 해당하는 라우팅 규칙에는 <code>:id</code> 토큰이 없습니다.</p>\n<p>옵션 라우팅 인자는 URL 쿼리 스트링처럼 \"?\"나 \"&#x26;\"로 구분하지 않고 \";\"로 구분합니다.\n이 방식은 매트릭스 URL 표기법(matrix URL notation)입니다.</p>\n<div class=\"alert is-helpful\">\n<p>매트릭스 URL 표기법은 웹을 개발한 Tim Berners-Lee가 <a href=\"http://www.w3.org/DesignIssues/MatrixURIs.html\">1996년에 처음 제안</a>한 표기법입니다.</p>\n<p>매트릭스 표기법이 HTML 표준이 되진 않았지만, 이 표기법은 앚기 유효하며 부모/자식 사이에서 라우팅 인자를 전달하는 용도로 브라우저 라우팅 체계에 자주 사용됩니다.\nAngular Router도 이 표기법을 지원합니다.</p>\n</div>\n<a id=\"route-parameters-activated-route\"></a>\n<!--\n### Route parameters in the `ActivatedRoute` service\n-->\n<h3 id=\"activatedroute-서비스에-있는-라우팅-인자\"><code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 서비스에 있는 라우팅 인자<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#activatedroute-서비스에-있는-라우팅-인자\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn its current state of development, the list of heroes is unchanged.\nNo hero row is highlighted.\n\nThe `HeroListComponent` needs code that expects parameters.\n\nPreviously, when navigating from the `HeroListComponent` to the `HeroDetailComponent`,\nyou subscribed to the route parameter map `Observable` and made it available to the `HeroDetailComponent`\nin the `ActivatedRoute` service.\nYou injected that service in the constructor of the `HeroDetailComponent`.\n\nThis time you'll be navigating in the opposite direction, from the `HeroDetailComponent` to the `HeroListComponent`.\n\nFirst, extend the router import statement to include the `ActivatedRoute` service symbol:\n\n<code-example path=\"router/src/app/heroes/hero-list/hero-list.component.ts\" header=\"src/app/heroes/hero-list/hero-list.component.ts (import)\" region=\"import-router\">\nimport { ActivatedRoute } from &#39;@angular/router&#39;;\n\n</code-example>\n\nImport the `switchMap` operator to perform an operation on the `Observable` of route parameter map.\n\n<code-example path=\"router/src/app/heroes/hero-list/hero-list.component.ts\" header=\"src/app/heroes/hero-list/hero-list.component.ts (rxjs imports)\" region=\"rxjs-imports\">\nimport { Observable } from &#39;rxjs&#39;;\nimport { switchMap } from &#39;rxjs/operators&#39;;\n\n</code-example>\n\nInject the `ActivatedRoute` in the `HeroListComponent` constructor.\n\n<code-example path=\"router/src/app/heroes/hero-list/hero-list.component.ts\" header=\"src/app/heroes/hero-list/hero-list.component.ts (constructor and ngOnInit)\" region=\"ctor\">\nexport class HeroListComponent implements OnInit {\n  heroes$: Observable&lt;Hero[]&gt;;\n  selectedId: number;\n\n  constructor(\n    private service: HeroService,\n    private route: ActivatedRoute\n  ) {}\n\n  ngOnInit() {\n    this.heroes$ = this.route.paramMap.pipe(\n      switchMap(params =&gt; {\n        // `param.get()` 앞에 붙은 (+)는 문자열을 숫자로 변환합니다.\n        this.selectedId = +params.get(&#39;id&#39;);\n        return this.service.getHeroes();\n      })\n    );\n  }\n}\n\n</code-example>\n\nThe `ActivatedRoute.paramMap` property is an `Observable` map of route parameters.\nThe `paramMap` emits a new map of values that includes `id` when the user navigates to the component.\nIn `ngOnInit()` you subscribe to those values, set the `selectedId`, and get the heroes.\n\nUpdate the template with a [class binding](guide/attribute-binding#class-binding).\nThe binding adds the `selected` CSS class when the comparison returns `true` and removes it when `false`.\nLook for it within the repeated `<li>` tag as shown here:\n\n<code-example path=\"router/src/app/heroes/hero-list/hero-list.component.html\" header=\"src/app/heroes/hero-list/hero-list.component.html\">\n&lt;h2&gt;HEROES&lt;/h2&gt;\n&lt;ul class=&quot;heroes&quot;&gt;\n  &lt;li *ngFor=&quot;let hero of heroes$ | async&quot;\n    [class.selected]=&quot;hero.id === selectedId&quot;&gt;\n    &lt;a [routerLink]=&quot;[&#39;/hero&#39;, hero.id]&quot;&gt;\n      &lt;span class=&quot;badge&quot;&gt;{{ hero.id }}&lt;/span&gt;{{ hero.name }}\n    &lt;/a&gt;\n  &lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;button routerLink=&quot;/sidekicks&quot;&gt;Go to sidekicks&lt;/button&gt;\n\n</code-example>\n\nAdd some styles to apply when the list item is selected.\n\n<code-example path=\"router/src/app/heroes/hero-list/hero-list.component.css\" region=\"selected\" header=\"src/app/heroes/hero-list/hero-list.component.css\">\n.heroes li.selected {\n  background-color: #CFD8DC;\n  color: white;\n}\n.heroes li.selected:hover {\n  background-color: #BBD8DC;\n}\n\n</code-example>\n\nWhen the user navigates from the heroes list to the \"Magneta\" hero and back, \"Magneta\" appears selected:\n\n<div class=\"lightbox\">\n  <img src='generated/images/guide/router/selected-hero.png' alt=\"Selected List\">\n</div>\n\nThe optional `foo` route parameter is harmless and the router continues to ignore it.\n-->\n<p>아직까지는 개발단계이기 때문에 히어로 목록이 변경되지 않습니다.\n하이라이트된 히어로 줄도 없습니다.</p>\n<p>상세정보 화면에서 보고 돌아온 히어로를 하이라이트 처리하려면 <code>HeroListComponent</code>가 라우팅 인자를 활용하도록 수정해야 합니다.</p>\n<p>이전 섹션에서 <code>HeroListComponent</code>에서 <code>HeroDetailComponent</code>로 이동할 때는 라우팅 인자 맵 <code>Observable</code>을 구독하거나 <code>HeroDetailComponent</code> 안에 주입된 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 서비스를 사용했습니다.</p>\n<p>이번에 화면이 전환되는 방향은 이전과 반대로 <code>HeroDetailComponent</code>에서 <code>HeroListComponent</code>로 전환됩니다.</p>\n<p>먼저, <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 서비스 심볼을 로드합니다:</p>\n<code-example path=\"router/src/app/heroes/hero-list/hero-list.component.ts\" header=\"src/app/heroes/hero-list/hero-list.component.ts (ActivatedRoute 로드하기)\" region=\"import-router\">\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\n\n</code-example>\n<p>그리고 <code>Observable</code> 타입으로 제공되는 라우팅 인자 맵을 참조하기 위해 <code>switchMap</code> 연산자를 로드합니다.</p>\n<code-example path=\"router/src/app/heroes/hero-list/hero-list.component.ts\" header=\"src/app/heroes/hero-list/hero-list.component.ts (rxjs 연산자 로드하기)\" region=\"rxjs-imports\">\nimport { Observable } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\n\n</code-example>\n<p>그 다음에는 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>를 <code>HeroListComponent</code> 생성자로 주입합니다.</p>\n<code-example path=\"router/src/app/heroes/hero-list/hero-list.component.ts\" header=\"src/app/heroes/hero-list/hero-list.component.ts (constructor and ngOnInit)\" region=\"ctor\">\nexport class HeroListComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  heroes$: Observable&#x3C;Hero[]>;\n  selectedId: number;\n\n  constructor(\n    private service: HeroService,\n    private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>\n  ) {}\n\n  ngOnInit() {\n    this.heroes$ = this.route.paramMap.pipe(\n      switchMap(params => {\n        // `param.get()` 앞에 붙은 (+)는 문자열을 숫자로 변환합니다.\n        this.selectedId = +params.get('id');\n        return this.service.getHeroes();\n      })\n    );\n  }\n}\n\n</code-example>\n<p><code><a href=\"api/router/ActivatedRoute#paramMap\" class=\"code-anchor\">ActivatedRoute.paramMap</a></code> 프로퍼티는 라우팅 인자 맵을 <code>Observable</code> 타입으로 제공합니다.\n<code>paramMap</code>은 사용자가 컴포넌트에 진입할 때마다 상황에 맞는 라우팅 인자를 전달하며, 이 경우에는 <code>id</code>도 포함됩니다.\n<code>ngOnInit()</code> 메서드에서 이 프로퍼티를 구독해서 받아온 <code>id</code> 값을 <code>selectedId</code>에 할당하고 히어로 정보를 요청해 봅시다.</p>\n<p>이제 템플릿은 <a href=\"guide/attribute-binding#class-binding\">클래스 바인딩</a>이 동작하면서 갱신됩니다.\n그래서 클래스 바인딩에 사용된 평가식이 <code>true</code>를 반환하면 CSS 클래스 <code>selected</code>가 해당 DOM에 추가되고, 평가식이 <code>false</code>를 반환하면 해당 클래스가 제거됩니다.\n클래스 바인딩은 <code>&#x3C;li></code> 태그에 지정합니다:</p>\n<code-example path=\"router/src/app/heroes/hero-list/hero-list.component.html\" header=\"src/app/heroes/hero-list/hero-list.component.html\">\n&#x3C;h2>HEROES&#x3C;/h2>\n&#x3C;ul class=\"heroes\">\n  &#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes$ | async\"\n    [class.selected]=\"hero.id === selectedId\">\n    &#x3C;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/hero', hero.id]\">\n      &#x3C;span class=\"badge\">{{ hero.id }}&#x3C;/span>{{ hero.name }}\n    &#x3C;/a>\n  &#x3C;/li>\n&#x3C;/ul>\n\n&#x3C;button <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/sidekicks\">Go to sidekicks&#x3C;/button>\n\n</code-example>\n<p>항목이 선택되었을 때 적용될 스타일을 추가합니다.</p>\n<code-example path=\"router/src/app/heroes/hero-list/hero-list.component.css\" region=\"selected\" header=\"src/app/heroes/hero-list/hero-list.component.css\">\n.heroes li.selected {\n  background-color: #CFD8DC;\n  color: white;\n}\n.heroes li.selected:hover {\n  background-color: #BBD8DC;\n}\n\n</code-example>\n<p>이제 사용자가 히어로 목록 화면에서 \"Magneta\" 히어로의 상세정보 화면으로 이동한 후에 돌아오면 \"Matneta\" 항목이 선택된 모습으로 표시됩니다:</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/router/selected-hero.png\" alt=\"Selected List\" width=\"336\" height=\"110\">\n</div>\n<p>함께 전달된 라우팅 인자 <code>foo</code>는 사용되지 않았지만 무시해도 문제되지 않습니다.</p>\n<a id=\"route-animation\"></a>\n<!--\n### Adding routable animations\n-->\n<h3 id=\"라우팅-애니메이션-추가하기\">라우팅 애니메이션 추가하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#라우팅-애니메이션-추가하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThis section shows you how to add some [animations](guide/animations) to the `HeroDetailComponent`.\n\nFirst, import the `BrowserAnimationsModule` and add it to the `imports` array:\n\n<code-example path=\"router/src/app/app.module.ts\" header=\"src/app/app.module.ts (animations-module)\" region=\"animations-module\">\nimport { BrowserAnimationsModule } from &#39;@angular/platform-browser/animations&#39;;\n\n@NgModule({\n  imports: [\n    BrowserAnimationsModule,\n  ],\n})\n\n</code-example>\n\nNext, add a `data` object to the routes for `HeroListComponent` and `HeroDetailComponent`.\nTransitions are based on `states` and you use the `animation` data from the route to provide a named animation `state` for the transitions.\n\n<code-example path=\"router/src/app/heroes/heroes-routing.module.2.ts\" header=\"src/app/heroes/heroes-routing.module.ts (animation data)\">\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { RouterModule, Routes } from &#39;@angular/router&#39;;\n\nimport { HeroListComponent } from &#39;./hero-list/hero-list.component&#39;;\nimport { HeroDetailComponent } from &#39;./hero-detail/hero-detail.component&#39;;\n\nconst heroesRoutes: Routes = [\n  { path: &#39;heroes&#39;,  component: HeroListComponent, data: { animation: &#39;heroes&#39; } },\n  { path: &#39;hero/:id&#39;, component: HeroDetailComponent, data: { animation: &#39;hero&#39; } }\n];\n\n@NgModule({\n  imports: [\n    RouterModule.forChild(heroesRoutes)\n  ],\n  exports: [\n    RouterModule\n  ]\n})\nexport class HeroesRoutingModule { }\n\n</code-example>\n\nCreate an `animations.ts` file in the root `src/app/` folder. The contents look like this:\n\n<code-example path=\"router/src/app/animations.ts\" header=\"src/app/animations.ts (excerpt)\">\nimport {\n  trigger, animateChild, group,\n  transition, animate, style, query\n} from &#39;@angular/animations&#39;;\n\n\n// 라우팅할 때 사용하는 애니메이션\nexport const slideInAnimation =\n  trigger(&#39;routeAnimation&#39;, [\n    transition(&#39;heroes &lt;=&gt; hero&#39;, [\n      style({ position: &#39;relative&#39; }),\n      query(&#39;:enter, :leave&#39;, [\n        style({\n          position: &#39;absolute&#39;,\n          top: 0,\n          left: 0,\n          width: &#39;100%&#39;\n        })\n      ]),\n      query(&#39;:enter&#39;, [\n        style({ left: &#39;-100%&#39;})\n      ]),\n      query(&#39;:leave&#39;, animateChild()),\n      group([\n        query(&#39;:leave&#39;, [\n          animate(&#39;300ms ease-out&#39;, style({ left: &#39;100%&#39;}))\n        ]),\n        query(&#39;:enter&#39;, [\n          animate(&#39;300ms ease-out&#39;, style({ left: &#39;0%&#39;}))\n        ])\n      ]),\n      query(&#39;:enter&#39;, animateChild()),\n    ])\n  ]);\n\n\n</code-example>\n\nThis file does the following:\n\n* Imports the animation symbols that build the animation triggers, control state, and manage transitions between states.\n\n* Exports a constant named `slideInAnimation` set to an animation trigger named `routeAnimation`.\n\n* Defines one transition when switching back and forth from the `heroes` and `hero` routes to ease the component in from the left of the screen as it enters the application view (`:enter`), the other to animate the component to the right as it leaves the application view (`:leave`).\n\nBack in the `AppComponent`, import the `RouterOutlet` token from the `@angular/router` package and the `slideInAnimation` from `'./animations.ts`.\n\nAdd an `animations` array to the `@Component` metadata that contains the `slideInAnimation`.\n\n<code-example path=\"router/src/app/app.component.2.ts\" header=\"src/app/app.component.ts (animations)\" region=\"animation-imports\">\nimport { RouterOutlet } from &#39;@angular/router&#39;;\nimport { slideInAnimation } from &#39;./animations&#39;;\n\n@Component({\n  selector: &#39;app-root&#39;,\n  templateUrl: &#39;app.component.html&#39;,\n  styleUrls: [&#39;app.component.css&#39;],\n  animations: [ slideInAnimation ]\n})\n\n</code-example>\n\nIn order to use the routable animations, wrap the `RouterOutlet` inside an element, use the `@routeAnimation` trigger, and bind it to the element.\n\nFor the `@routeAnimation` transitions to key off states, provide it with the `data` from the `ActivatedRoute`.\nThe `RouterOutlet` is exposed as an `outlet` template variable, so you bind a reference to the router outlet.\nThis example uses a variable of `routerOutlet`.\n\n<code-example path=\"router/src/app/app.component.2.html\" header=\"src/app/app.component.html (router outlet)\">\n&lt;h1&gt;Angular Router&lt;/h1&gt;\n&lt;nav&gt;\n  &lt;a routerLink=&quot;/crisis-center&quot; routerLinkActive=&quot;active&quot;&gt;Crisis Center&lt;/a&gt;\n  &lt;a routerLink=&quot;/heroes&quot; routerLinkActive=&quot;active&quot;&gt;Heroes&lt;/a&gt;\n&lt;/nav&gt;\n&lt;div [@routeAnimation]=&quot;getAnimationData(routerOutlet)&quot;&gt;\n  &lt;router-outlet #routerOutlet=&quot;outlet&quot;&gt;&lt;/router-outlet&gt;\n&lt;/div&gt;\n\n</code-example>\n\nThe `@routeAnimation` property is bound to the `getAnimationData()` with the provided `routerOutlet` reference, so the next step is to define that function in the `AppComponent`.\nThe `getAnimationData()` function returns the animation property from the `data` provided through the `ActivatedRoute`. The `animation` property matches the `transition` names you used in the `slideInAnimation` defined in `animations.ts`.\n\n<code-example path=\"router/src/app/app.component.2.ts\" header=\"src/app/app.component.ts (router outlet)\" region=\"function-binding\">\nexport class AppComponent {\n  getAnimationData(outlet: RouterOutlet) {\n    return outlet &amp;&amp; outlet.activatedRouteData &amp;&amp; outlet.activatedRouteData.animation;\n  }\n}\n\n</code-example>\n\nWhen switching between the two routes, the `HeroDetailComponent` and `HeroListComponent` now ease in from the left when routed to and will slide to the right when navigating away.\n-->\n<p>이번 섹션에서는 <code>HeroDetailComponent</code>로 화면을 전환할 때 <a href=\"guide/animations\">애니메이션</a>을 적용하는 방법에 대해 알아봅시다.</p>\n<p>먼저, <code><a href=\"api/platform-browser/animations/BrowserAnimationsModule\" class=\"code-anchor\">BrowserAnimationsModule</a></code>을 로드하고 앱 모듈 <code>imports</code> 배열에 추가합니다:</p>\n<code-example path=\"router/src/app/app.module.ts\" header=\"src/app/app.module.ts (애니메이션 모듈)\" region=\"animations-module\">\nimport { <a href=\"api/platform-browser/animations/BrowserAnimationsModule\" class=\"code-anchor\">BrowserAnimationsModule</a> } from '@angular/platform-browser/animations';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/animations/BrowserAnimationsModule\" class=\"code-anchor\">BrowserAnimationsModule</a>,\n  ],\n})\n\n</code-example>\n<p>그리고 <code>HeroListComponent</code>와 <code>HeroDetailComponent</code>에 해당하는 라우팅 규칙에 <code>data</code> 객체를 추가합니다.\n전환 효과(transition)는 <code>states</code>를 기반으로 동작하기 때문에 애니메이션 <code><a href=\"api/animations/state\" class=\"code-anchor\">state</a></code>에 해당하는 <code><a href=\"api/animations/animation\" class=\"code-anchor\">animation</a></code> 데이터를 라우팅 규칙에 추가해야 합니다.</p>\n<code-example path=\"router/src/app/heroes/heroes-routing.module.2.ts\" header=\"src/app/heroes/heroes-routing.module.ts (애니메이션 데이터)\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { HeroListComponent } from './hero-list/hero-list.component';\nimport { HeroDetailComponent } from './hero-detail/hero-detail.component';\n\nconst heroesRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'heroes',  component: HeroListComponent, data: { <a href=\"api/animations/animation\" class=\"code-anchor\">animation</a>: 'heroes' } },\n  { path: 'hero/:id', component: HeroDetailComponent, data: { <a href=\"api/animations/animation\" class=\"code-anchor\">animation</a>: 'hero' } }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forChild(heroesRoutes)\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class HeroesRoutingModule { }\n\n</code-example>\n<p>그 다음에는 <code>src/app/</code> 폴더에 <code>animations.ts</code> 파일을 생성하고 이런 내용으로 작성합니다:</p>\n<code-example path=\"router/src/app/animations.ts\" header=\"src/app/animations.ts (일부)\">\nimport {\n  <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a>, <a href=\"api/animations/animateChild\" class=\"code-anchor\">animateChild</a>, group,\n  <a href=\"api/animations/transition\" class=\"code-anchor\">transition</a>, <a href=\"api/animations/animate\" class=\"code-anchor\">animate</a>, <a href=\"api/animations/style\" class=\"code-anchor\">style</a>, <a href=\"api/animations/query\" class=\"code-anchor\">query</a>\n} from '@angular/animations';\n\n\n// 라우팅할 때 사용하는 애니메이션\nexport const slideInAnimation =\n  <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a>('routeAnimation', [\n    <a href=\"api/animations/transition\" class=\"code-anchor\">transition</a>('heroes &#x3C;=> hero', [\n      <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({ position: 'relative' }),\n      <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':enter, :leave', [\n        <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%'\n        })\n      ]),\n      <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':enter', [\n        <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({ left: '-100%'})\n      ]),\n      <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':leave', <a href=\"api/animations/animateChild\" class=\"code-anchor\">animateChild</a>()),\n      group([\n        <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':leave', [\n          <a href=\"api/animations/animate\" class=\"code-anchor\">animate</a>('300ms ease-out', <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({ left: '100%'}))\n        ]),\n        <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':enter', [\n          <a href=\"api/animations/animate\" class=\"code-anchor\">animate</a>('300ms ease-out', <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({ left: '0%'}))\n        ])\n      ]),\n      <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':enter', <a href=\"api/animations/animateChild\" class=\"code-anchor\">animateChild</a>()),\n    ])\n  ]);\n\n\n</code-example>\n<p>이 파일의 내용은 이렇습니다:</p>\n<ul>\n<li>\n<p>애니메이션 트리거를 생성하는 심볼, 상태를 조작하는 심볼, 상태 전환을 관리하는 심볼을 로드합니다.</p>\n</li>\n<li>\n<p><code>routeAnimation</code> 트리거를 <code>slideAnimation</code> 상수로 파일 외부로 공개합니다.</p>\n</li>\n<li>\n<p><code>heroes</code>, <code>hero</code> 라우팅 규칙이 적용될 때 사용될 전환 효과를 정의합니다.\n해당 컴포넌트에 진입할 때(<code>:enter</code>)는 컴포넌트가 화면 왼쪽에서 나타나도록 정의하며, 컴포넌트를 벗어날 때(<code>:leave</code>)는 화면 오른쪽으로 사라지도록 정의합니다.</p>\n</li>\n</ul>\n<p>그리고 <code>AppComponent</code> 파일로 돌아가서 <code>@angular/router</code> 패키지에서 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code> 토큰을 로드하고 <code>'./animations.ts'</code> 파일에서 <code>slideInAnimation</code> 상수를 로드합니다.</p>\n<p>이제 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 메타데이터의 <code>animations</code> 배열에 <code>slideInAnimation</code>을 추가합니다.</p>\n<code-example path=\"router/src/app/app.component.2.ts\" header=\"src/app/app.component.ts (animations 배열)\" region=\"animation-imports\">\nimport { <a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a> } from '@angular/router';\nimport { slideInAnimation } from './animations';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  templateUrl: 'app.component.html',\n  styleUrls: ['app.component.css'],\n  animations: [ slideInAnimation ]\n})\n\n</code-example>\n<p>라우팅 애니메이션을 사용하려면 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>을 둘러싸는 엘리먼트를 추가하고 이 엘리먼트에 <code>@routeAnimation</code> 트리거를 바인딩해야 합니다.</p>\n<p>이제 <code>@routeAnimation</code> 전환 효과에 적용되는 상태는 <code>data</code> 객체에 담아서 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>로 전달합니다.\n그리고 <code>outlet</code> 템플릿 변수가 할당된 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>을 바인딩합니다.\n이 예제에서는 <code>outlet</code> 대신 <code>routerOutlet</code>을 바인딩했습니다.</p>\n<code-example path=\"router/src/app/app.component.2.html\" header=\"src/app/app.component.html (라우팅 영역)\">\n&#x3C;h1>Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>&#x3C;/h1>\n&#x3C;nav>\n  &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/crisis-center\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Crisis Center&#x3C;/a>\n  &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/heroes\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Heroes&#x3C;/a>\n&#x3C;/nav>\n&#x3C;div [@routeAnimation]=\"getAnimationData(routerOutlet)\">\n  &#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a> #routerOutlet=\"outlet\">&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n&#x3C;/div>\n\n</code-example>\n<p><code>@routeAnimation</code> 프로퍼티는 <code>routerOutlet</code> 참조와 함께 <code>getAnimationData()</code>와 바인딩되기 때문에 이제 <code>AppComponent</code>에 <code>getAnimationData()</code> 메서드를 정의해야 합니다.\n<code>getAnimationData()</code> 함수는 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 안에 있는 <code>data</code> 객체에서 애니메이션 프로퍼티를 찾아서 반환하는 함수입니다.\n그리고 <code><a href=\"api/animations/animation\" class=\"code-anchor\">animation</a></code> 프로퍼티는는 <code>animations.ts</code> 파일에 정의한 <code>slideInAnimation</code> 안에 있는 상태 이름과 매칭됩니다.</p>\n<code-example path=\"router/src/app/app.component.2.ts\" header=\"src/app/app.component.ts (라우팅 영역)\" region=\"function-binding\">\nexport class AppComponent {\n  getAnimationData(outlet: <a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a>) {\n    return outlet &#x26;&#x26; outlet.activatedRouteData &#x26;&#x26; outlet.activatedRouteData.animation;\n  }\n}\n\n</code-example>\n<p>이제 <code>HeroDetailComponent</code>와 <code>HeroListComponent</code>를 전환해보면 새로 등장하는 컴포넌트가 화면 왼쪽에서 나타나고, 사라지는 컴포넌트가 화면 오른쪽으로 사라지는 애니메이션이 동작하는 것을 확인할 수 있습니다.</p>\n<a id=\"milestone-3-wrap-up\"></a>\n<!--\n### Milestone 3 wrap up\n-->\n<h3 id=\"마일스톤-3-정리\">마일스톤 3 정리<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#마일스톤-3-정리\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThis section has covered the following:\n\n* Organizing the app into feature areas.\n* Navigating imperatively from one component to another.\n* Passing information along in route parameters and subscribe to them in the component.\n* Importing the feature area NgModule into the `AppModule`.\n* Applying routable animations based on the page.\n\nAfter these changes, the folder structure is as follows:\n-->\n<p>이번 섹션에서는 이런 내용을 다뤘습니다:</p>\n<ul>\n<li>애플리케이션을 기능 단위로 재구성했습니다.</li>\n<li>컴포넌트를 전환하는 방법에 대해 다뤘습니다.</li>\n<li>라우팅 인자로 정보를 전달하고 새로 표시되는 컴포넌트에서 이 정보를 구독해서 사용했습니다.</li>\n<li><code>AppModule</code>에 기능 모듈을 로드했습니다.</li>\n<li>라우팅 애니메이션을 적용했습니다.</li>\n</ul>\n<p>여기까지 작업하고 나면 폴더 구조가 이렇게 구성됩니다:</p>\n<div class=\"filetree\">\n  <div class=\"file\">\n    angular-router-sample\n  </div>\n  <div class=\"children\">\n    <div class=\"file\">\n      src\n    </div>\n    <div class=\"children\">\n      <div class=\"file\">\n        app\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          crisis-list\n        </div>\n          <div class=\"children\">\n            <div class=\"file\">\n              crisis-list.component.css\n            </div>\n            <div class=\"file\">\n              crisis-list.component.html\n            </div>\n            <div class=\"file\">\n              crisis-list.component.ts\n            </div>\n          </div>\n        <div class=\"file\">\n          heroes\n        </div>\n        <div class=\"children\">\n          <div class=\"file\">\n            hero-detail\n          </div>\n            <div class=\"children\">\n              <div class=\"file\">\n                hero-detail.component.css\n              </div>\n              <div class=\"file\">\n                hero-detail.component.html\n              </div>\n              <div class=\"file\">\n                hero-detail.component.ts\n              </div>\n            </div>\n          <div class=\"file\">\n            hero-list\n          </div>\n            <div class=\"children\">\n              <div class=\"file\">\n                hero-list.component.css\n              </div>\n              <div class=\"file\">\n                hero-list.component.html\n              </div>\n              <div class=\"file\">\n                hero-list.component.ts\n              </div>\n            </div>\n          <div class=\"file\">\n            hero.service.ts\n          </div>\n          <div class=\"file\">\n            hero.ts\n          </div>\n          <div class=\"file\">\n            heroes-routing.module.ts\n          </div>\n          <div class=\"file\">\n            heroes.module.ts\n          </div>\n          <div class=\"file\">\n            mock-heroes.ts\n          </div>\n        </div>\n        <div class=\"file\">\n          page-not-found\n        </div>\n        <div class=\"children\">\n          <div class=\"file\">\n<p>            page-not-found.component.css</p>\n          </div>\n          <div class=\"file\">\n<p>            page-not-found.component.html</p>\n          </div>\n          <div class=\"file\">\n<p>            page-not-found.component.ts</p>\n          </div>\n        </div>\n      </div>\n      <div class=\"file\">\n        animations.ts\n      </div>\n      <div class=\"file\">\n        app.component.css\n      </div>\n      <div class=\"file\">\n        app.component.html\n      </div>\n      <div class=\"file\">\n        app.component.ts\n      </div>\n      <div class=\"file\">\n        app.module.ts\n      </div>\n      <div class=\"file\">\n        app-routing.module.ts\n      </div>\n      <div class=\"file\">\n        main.ts\n      </div>\n      <div class=\"file\">\n        message.service.ts\n      </div>\n      <div class=\"file\">\n        index.html\n      </div>\n      <div class=\"file\">\n        styles.css\n      </div>\n      <div class=\"file\">\n        tsconfig.json\n      </div>\n    </div>\n    <div class=\"file\">\n      node_modules ...\n    </div>\n    <div class=\"file\">\n      package.json\n    </div>\n  </div>\n</div>\n<!--\nHere are the relevant files for this version of the sample application.\n-->\n<p>그리고 이 시점에 예제 애플리케이션의 코드는 이렇습니다.</p>\n<code-tabs>\n\n  <code-pane header=\"animations.ts\" path=\"router/src/app/animations.ts\">\nimport {\n  <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a>, <a href=\"api/animations/animateChild\" class=\"code-anchor\">animateChild</a>, group,\n  <a href=\"api/animations/transition\" class=\"code-anchor\">transition</a>, <a href=\"api/animations/animate\" class=\"code-anchor\">animate</a>, <a href=\"api/animations/style\" class=\"code-anchor\">style</a>, <a href=\"api/animations/query\" class=\"code-anchor\">query</a>\n} from '@angular/animations';\n\n\n// 라우팅할 때 사용하는 애니메이션\nexport const slideInAnimation =\n  <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a>('routeAnimation', [\n    <a href=\"api/animations/transition\" class=\"code-anchor\">transition</a>('heroes &#x3C;=> hero', [\n      <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({ position: 'relative' }),\n      <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':enter, :leave', [\n        <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%'\n        })\n      ]),\n      <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':enter', [\n        <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({ left: '-100%'})\n      ]),\n      <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':leave', <a href=\"api/animations/animateChild\" class=\"code-anchor\">animateChild</a>()),\n      group([\n        <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':leave', [\n          <a href=\"api/animations/animate\" class=\"code-anchor\">animate</a>('300ms ease-out', <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({ left: '100%'}))\n        ]),\n        <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':enter', [\n          <a href=\"api/animations/animate\" class=\"code-anchor\">animate</a>('300ms ease-out', <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({ left: '0%'}))\n        ])\n      ]),\n      <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':enter', <a href=\"api/animations/animateChild\" class=\"code-anchor\">animateChild</a>()),\n    ])\n  ]);\n\n\n</code-pane>\n\n  <code-pane header=\"app.component.html\" path=\"router/src/app/app.component.2.html\">\n&#x3C;h1>Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>&#x3C;/h1>\n&#x3C;nav>\n  &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/crisis-center\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Crisis Center&#x3C;/a>\n  &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/heroes\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Heroes&#x3C;/a>\n&#x3C;/nav>\n&#x3C;div [@routeAnimation]=\"getAnimationData(routerOutlet)\">\n  &#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a> #routerOutlet=\"outlet\">&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n&#x3C;/div>\n\n</code-pane>\n\n  <code-pane header=\"app.component.ts\" path=\"router/src/app/app.component.2.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { <a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a> } from '@angular/router';\nimport { slideInAnimation } from './animations';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  templateUrl: 'app.component.html',\n  styleUrls: ['app.component.css'],\n  animations: [ slideInAnimation ]\n})\nexport class AppComponent {\n  getAnimationData(outlet: <a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a>) {\n    return outlet &#x26;&#x26; outlet.activatedRouteData &#x26;&#x26; outlet.activatedRouteData.animation;\n  }\n}\n\n\n</code-pane>\n\n  <code-pane header=\"app.module.ts\" path=\"router/src/app/app.module.3.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { <a href=\"api/platform-browser/animations/BrowserAnimationsModule\" class=\"code-anchor\">BrowserAnimationsModule</a> } from '@angular/platform-browser/animations';\n\nimport { AppComponent } from './app.component';\nimport { AppRoutingModule } from './app-routing.module';\nimport { HeroesModule } from './heroes/heroes.module';\n\nimport { CrisisListComponent } from './crisis-list/crisis-list.component';\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/platform-browser/animations/BrowserAnimationsModule\" class=\"code-anchor\">BrowserAnimationsModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    HeroesModule,\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    CrisisListComponent,\n    PageNotFoundComponent\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n</code-pane>\n\n  <code-pane header=\"app-routing.module.ts\" path=\"router/src/app/app-routing.module.2.ts\" region=\"milestone3\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { CrisisListComponent } from './crisis-list/crisis-list.component';\n/* . . . */\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\n\nconst appRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'crisis-center', component: CrisisListComponent },\n/* . . . */\n  { path: '',   redirectTo: '/heroes', pathMatch: 'full' },\n  { path: '**', component: PageNotFoundComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forRoot(\n      appRoutes,\n      { enableTracing: true } // &#x3C;-- 디버그 활성화\n    )\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class AppRoutingModule {}\n\n</code-pane>\n\n  <code-pane header=\"hero-list.component.css\" path=\"router/src/app/heroes/hero-list/hero-list.component.css\">\n/* HeroListComponent에만 적용되는 CSS 스타일 */\n.heroes {\n  margin: 0 0 2em 0;\n  list-style-type: none;\n  padding: 0;\n  width: 15em;\n}\n.heroes li {\n  position: relative;\n  cursor: pointer;\n  background-color: #EEE;\n  margin: .5em;\n  padding: .3em 0;\n  height: 1.6em;\n  border-radius: 4px;\n}\n\n.heroes li:hover {\n  color: #607D8B;\n  background-color: #DDD;\n  left: .1em;\n}\n\n.heroes a {\n  color: #888;\n  text-decoration: none;\n  position: relative;\n  display: block;\n}\n\n.heroes a:hover {\n  color:#607D8B;\n}\n\n.heroes .badge {\n  display: inline-block;\n  font-size: small;\n  color: white;\n  padding: 0.8em 0.7em 0 0.7em;\n  background-color: #607D8B;\n  line-height: 1em;\n  position: relative;\n  left: -1px;\n  top: -4px;\n  height: 1.8em;\n  min-width: 16px;\n  text-align: right;\n  margin-right: .8em;\n  border-radius: 4px 0 0 4px;\n}\n\nbutton {\n  background-color: #eee;\n  border: none;\n  padding: 5px 10px;\n  border-radius: 4px;\n  cursor: pointer;\n  cursor: hand;\n  font-family: Arial;\n}\n\nbutton:hover {\n  background-color: #cfd8dc;\n}\n\nbutton.delete {\n  position: relative;\n  left: 194px;\n  top: -32px;\n  background-color: gray !important;\n  color: white;\n}\n\n.heroes li.selected {\n  background-color: #CFD8DC;\n  color: white;\n}\n.heroes li.selected:hover {\n  background-color: #BBD8DC;\n}\n\n</code-pane>\n\n  <code-pane header=\"hero-list.component.html\" path=\"router/src/app/heroes/hero-list/hero-list.component.html\">\n&#x3C;h2>HEROES&#x3C;/h2>\n&#x3C;ul class=\"heroes\">\n  &#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes$ | async\"\n    [class.selected]=\"hero.id === selectedId\">\n    &#x3C;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/hero', hero.id]\">\n      &#x3C;span class=\"badge\">{{ hero.id }}&#x3C;/span>{{ hero.name }}\n    &#x3C;/a>\n  &#x3C;/li>\n&#x3C;/ul>\n\n&#x3C;button <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/sidekicks\">Go to sidekicks&#x3C;/button>\n\n</code-pane>\n\n  <code-pane header=\"hero-list.component.ts\" path=\"router/src/app/heroes/hero-list/hero-list.component.ts\">\n// TODO: CrisisCenter와 비슷하게 수정\nimport { Observable } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\n\nimport { HeroService } from '../hero.service';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-list',\n  templateUrl: './hero-list.component.html',\n  styleUrls: ['./hero-list.component.css']\n})\nexport class HeroListComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  heroes$: Observable&#x3C;Hero[]>;\n  selectedId: number;\n\n  constructor(\n    private service: HeroService,\n    private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>\n  ) {}\n\n  ngOnInit() {\n    this.heroes$ = this.route.paramMap.pipe(\n      switchMap(params => {\n        // `param.get()` 앞에 붙은 (+)는 문자열을 숫자로 변환합니다.\n        this.selectedId = +params.get('id');\n        return this.service.getHeroes();\n      })\n    );\n  }\n}\n\n\n</code-pane>\n\n  <code-pane header=\"hero-detail.component.html\" path=\"router/src/app/heroes/hero-detail/hero-detail.component.html\">\n&#x3C;h2>HEROES&#x3C;/h2>\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero$ | async as hero\">\n  &#x3C;h3>\"{{ hero.name }}\"&#x3C;/h3>\n  &#x3C;div>\n    &#x3C;label>Id: &#x3C;/label>{{ hero.id }}&#x3C;/div>\n  &#x3C;div>\n    &#x3C;label>Name: &#x3C;/label>\n    &#x3C;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.name\" placeholder=\"name\"/>\n  &#x3C;/div>\n  &#x3C;p>\n    &#x3C;button (click)=\"gotoHeroes(hero)\">Back&#x3C;/button>\n  &#x3C;/p>\n&#x3C;/div>\n\n</code-pane>\n\n  <code-pane header=\"hero-detail.component.ts\" path=\"router/src/app/heroes/hero-detail/hero-detail.component.3.ts\">\nimport { switchMap } from 'rxjs/operators';\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\nimport { <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>, <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, <a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a> } from '@angular/router';\nimport { Observable } from 'rxjs';\n\nimport { HeroService } from '../hero.service';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-detail',\n  templateUrl: './hero-detail.component.html',\n  styleUrls: ['./hero-detail.component.css']\n})\nexport class HeroDetailComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  hero$: Observable&#x3C;Hero>;\n\n  constructor(\n    private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>,\n    private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,\n    private service: HeroService\n  ) {}\n\n  ngOnInit() {\n    this.hero$ = this.route.paramMap.pipe(\n      switchMap((params: <a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a>) =>\n        this.service.getHero(params.get('id')))\n    );\n  }\n\n  gotoHeroes(hero: Hero) {\n    const heroId = hero ? hero.id : null;\n    // HeroList 컴포넌트에서 히어로를 선택하기 위해 히어로의 id를 전달합니다.\n    // 'foo' 프로퍼티는 사용하지 않는 프로퍼티입니다.\n    this.router.navigate(['/heroes', { id: heroId, foo: 'foo' }]);\n  }\n}\n\n/*\n  this.router.navigate(['/superheroes', { id: heroId, foo: 'foo' }]);\n*/\n\n\n</code-pane>\n\n  <code-pane header=\"hero.service.ts\" path=\"router/src/app/heroes/hero.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\nimport { Observable, of } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport { Hero } from './hero';\nimport { HEROES } from './mock-heroes';\nimport { MessageService } from '../message.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class HeroService {\n\n  constructor(private messageService: MessageService) { }\n\n  getHeroes(): Observable&#x3C;Hero[]> {\n    // TODO: 메시지는 히어로 목록을 가져온 _뒤에_ 보내기\n    this.messageService.add('HeroService: fetched heroes');\n    return of(HEROES);\n  }\n\n  getHero(id: number | string) {\n    return this.getHeroes().pipe(\n      // `id` 앞에 사용된 `+`는 문자열을 숫자로 변환합니다.\n      map((heroes: Hero[]) => heroes.find(hero => hero.id === +id))\n    );\n  }\n}\n\n\n\n</code-pane>\n\n  <code-pane header=\"heroes.module.ts\" path=\"router/src/app/heroes/heroes.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> } from '@angular/common';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\n\nimport { HeroListComponent } from './hero-list/hero-list.component';\nimport { HeroDetailComponent } from './hero-detail/hero-detail.component';\n\nimport { HeroesRoutingModule } from './heroes-routing.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    HeroesRoutingModule\n  ],\n  declarations: [\n    HeroListComponent,\n    HeroDetailComponent\n  ]\n})\nexport class HeroesModule {}\n\n</code-pane>\n\n  <code-pane header=\"heroes-routing.module.ts\" path=\"router/src/app/heroes/heroes-routing.module.2.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { HeroListComponent } from './hero-list/hero-list.component';\nimport { HeroDetailComponent } from './hero-detail/hero-detail.component';\n\nconst heroesRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'heroes',  component: HeroListComponent, data: { <a href=\"api/animations/animation\" class=\"code-anchor\">animation</a>: 'heroes' } },\n  { path: 'hero/:id', component: HeroDetailComponent, data: { <a href=\"api/animations/animation\" class=\"code-anchor\">animation</a>: 'hero' } }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forChild(heroesRoutes)\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class HeroesRoutingModule { }\n\n</code-pane>\n\n  <code-pane header=\"message.service.ts\" path=\"router/src/app/message.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class MessageService {\n  messages: string[] = [];\n\n  add(message: string) {\n    this.messages.push(message);\n  }\n\n  clear() {\n    this.messages = [];\n  }\n}\n\n\n</code-pane>\n\n</code-tabs>\n<a id=\"milestone-4\"></a>\n<!--\n## Milestone 4: Crisis center feature\n-->\n<h2 id=\"마일스톤-4-위기대응센터-모듈\">마일스톤 4: 위기대응센터 모듈<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#마일스톤-4-위기대응센터-모듈\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThis section shows you how to add child routes and use relative routing in your app.\n\nTo add more features to the app's current crisis center, take similar steps as for the heroes feature:\n\n* Create a `crisis-center` subfolder in the `src/app` folder.\n* Copy the files and folders from `app/heroes` into the new `crisis-center` folder.\n* In the new files, change every mention of \"hero\" to \"crisis\", and \"heroes\" to \"crises\".\n* Rename the NgModule files to `crisis-center.module.ts` and `crisis-center-routing.module.ts`.\n\nUse mock crises instead of mock heroes:\n\n<code-example path=\"router/src/app/crisis-center/mock-crises.ts\" header=\"src/app/crisis-center/mock-crises.ts\">\nimport { Crisis } from &#39;./crisis&#39;;\n\nexport const CRISES: Crisis[] = [\n  { id: 1, name: &#39;Dragon Burning Cities&#39; },\n  { id: 2, name: &#39;Sky Rains Great White Sharks&#39; },\n  { id: 3, name: &#39;Giant Asteroid Heading For Earth&#39; },\n  { id: 4, name: &#39;Procrastinators Meeting Delayed Again&#39; },\n];\n\n\n</code-example>\n\nThe resulting crisis center is a foundation for introducing a new concept&mdash;child routing.\nYou can leave Heroes in its current state as a contrast with the Crisis Center.\n\n<div class=\"alert is-helpful\">\n\nIn keeping with the <a href=\"https://blog.8thlight.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html\" title=\"Separation of Concerns\">Separation of Concerns principle</a>, changes to the Crisis Center don't affect the `AppModule` or any other feature's component.\n\n</div>\n-->\n<p>이번 섹션에서는 애플리케이션에 자식 라우팅 규칙을 추가하고 상대 주소로 라우팅하는 방법에 대해 알아봅시다.</p>\n<p>지금 앱에 있는 위기대응센터 기능을 좀 더 확장하는 방법은 히어로 관리 기능을 추가했던 것과 비슷합니다:</p>\n<ul>\n<li><code>src/app</code> 폴더 아래 <code>crisis-center</code> 폴더를 만듭니다.</li>\n<li><code>app/heroes</code>에 있는 폴더와 파일을 <code>crisis-center</code> 폴더로 복사합니다.</li>\n<li>복사한 파일에서 \"hero\"라고 언급한 부분을 \"crisis\"로, \"heroes\"라고 언급한 부분을 \"crises\"로 변경합니다.</li>\n<li>새로 복사한 NgModule 파일의 이름을 <code>crisis-center.module.ts</code>, <code>cris-center-routing.module.ts</code>로 변경합니다.</li>\n</ul>\n<p>히어로 목 객체 대신 위기 목 객체를 생성합니다:</p>\n<code-example path=\"router/src/app/crisis-center/mock-crises.ts\" header=\"src/app/crisis-center/mock-crises.ts\">\nimport { Crisis } from './crisis';\n\nexport const CRISES: Crisis[] = [\n  { id: 1, name: 'Dragon Burning Cities' },\n  { id: 2, name: 'Sky Rains Great White Sharks' },\n  { id: 3, name: 'Giant Asteroid Heading For Earth' },\n  { id: 4, name: 'Procrastinators Meeting Delayed Again' },\n];\n\n\n</code-example>\n<p>새로 만든 위기대응센터에는 새로운 개념인 자식 라우팅을 활용해 봅시다.\n그러면 위기대응센터 기능을 사용하면서 히어로 모듈의 상태를 그대로 유지할 수 있습니다.</p>\n<div class=\"alert is-helpful\">\n<p><a href=\"https://blog.8thlight.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html\" title=\"Separation of Concerns\">관심사 분리 원칙</a>에 따라 위기대응센터에서 변경하는 코드는 <code>AppModule</code>이나 다른 기능모듈에 영향을 주지 않아야 합니다.</p>\n</div>\n<a id=\"crisis-child-routes\"></a>\n<a id=\"a-crisis-center-with-child-routes\"></a>\n<!--\n### A crisis center with child routes\n-->\n<h3 id=\"위기대응센터와-자식-라우팅\">위기대응센터와 자식 라우팅<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#위기대응센터와-자식-라우팅\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThis section shows you how to organize the crisis center to conform to the following recommended pattern for Angular applications:\n\n* Each feature area resides in its own folder.\n* Each feature has its own Angular feature module.\n* Each area has its own area root component.\n* Each area root component has its own router outlet and child routes.\n* Feature area routes rarely (if ever) cross with routes of other features.\n\nIf your app had many feature areas, the app component trees might look like this:\n\n\n<div class=\"lightbox\">\n  <img src='generated/images/guide/router/component-tree.png' alt=\"Component Tree\">\n</div>\n-->\n<p>이번 섹션에서는 Angular 애플리케이션에서 권장하는 방식으로 위기대응센터를 구성해 봅시다:</p>\n<ul>\n<li>개별 기능 단위는 개별 폴더에 두세요.</li>\n<li>개별 기능 단위는 개별 Angular 기능 모듈로 구성하세요.</li>\n<li>개별 기능 단위에는 최상위 컴포넌트가 있어야 합니다.</li>\n<li>개별 기능 단위의 최상위 컴포넌트에는 라우팅 영역과 자식 라우팅 규칙이 있어야 합니다.</li>\n<li>개별 기능 단위에서 다른 기능 단위로 라우팅하는 경우도 가끔 있습니다.</li>\n</ul>\n<p>애플리케이션에 기능 단위가 많이 있다면 앱 컴포넌트 트리가 이렇게 구성될 것입니다:</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/router/component-tree.png\" alt=\"Component Tree\" width=\"473\" height=\"258\">\n</div>\n<a id=\"child-routing-component\"></a>\n<!--\n### Child routing component\n-->\n<h3 id=\"자식-라우팅-컴포넌트\">자식 라우팅 컴포넌트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#자식-라우팅-컴포넌트\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nGenerate a `CrisisCenter` component in the `crisis-center` folder:\n\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component crisis-center/crisis-center\n</code-example>\n\nUpdate the component template with the following markup:\n\n<code-example path=\"router/src/app/crisis-center/crisis-center/crisis-center.component.html\" header=\"src/app/crisis-center/crisis-center/crisis-center.component.html\">\n&lt;h2&gt;CRISIS CENTER&lt;/h2&gt;\n&lt;router-outlet&gt;&lt;/router-outlet&gt;\n\n</code-example>\n\nThe `CrisisCenterComponent` has the following in common with the `AppComponent`:\n\n* It is the root of the crisis center area, just as `AppComponent` is the root of the entire application.\n* It is a shell for the crisis management feature area, just as the `AppComponent` is a shell to manage the high-level workflow.\n\nLike most shells, the `CrisisCenterComponent` class is minimal because it has no business logic, and its template has no links, just a title and `<router-outlet>` for the crisis center child component.\n-->\n<p><code>crisis-center</code> 폴더에서 다음 명령을 실행해서 <code>CrisisCenter</code> 컴포넌트를 생성합니다:</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component crisis-center/crisis-center\n</code-example>\n<p>그리고 컴포넌트 템플릿의 내용을 이렇게 수정합니다:</p>\n<code-example path=\"router/src/app/crisis-center/crisis-center/crisis-center.component.html\" header=\"src/app/crisis-center/crisis-center/crisis-center.component.html\">\n&#x3C;h2>CRISIS CENTER&#x3C;/h2>\n&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n\n</code-example>\n<p><code>CrisisCenterComponent</code>는 이런 점에서 <code>AppComponent</code>와 비슷합니다:</p>\n<ul>\n<li>이 컴포넌트는 위기대응센터 기능의 최상위 컴포넌트입니다. <code>AppComponent</code>는 애플리케이션 전체에서 최상위 컴포넌트입니다.</li>\n<li>위기대응센터가 제공하는 기능은 이 컴포넌트 안에 표시됩니다. <code>AppComponent</code>는 그보다 상위 계층에서 동작합니다.</li>\n</ul>\n<p>기본 컴포넌트가 그렇듯, <code>CrisisCenterComponent</code>의 클래스에는 비즈니스 로직이 들어가지 않기 때문에 최소한의 코드만 작성됩니다.\n이 컴포넌트의 템플릿에는 링크도 존재하지 않으며 제목 하나와 자식 컴포넌트를 표시할 <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code>만 존재합니다.</p>\n<a id=\"child-route-config\"></a>\n<!--\n### Child route configuration\n-->\n<h3 id=\"자식-라우팅-환경설정\">자식 라우팅 환경설정<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#자식-라우팅-환경설정\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAs a host page for the \"Crisis Center\" feature, generate a `CrisisCenterHome` component in the `crisis-center` folder.\n\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component crisis-center/crisis-center-home\n</code-example>\n\nUpdate the template with a welcome message to the `Crisis Center`.\n\n<code-example path=\"router/src/app/crisis-center/crisis-center-home/crisis-center-home.component.html\" header=\"src/app/crisis-center/crisis-center-home/crisis-center-home.component.html\">\n&lt;p&gt;Welcome to the Crisis Center&lt;/p&gt;\n\n</code-example>\n\nUpdate the `crisis-center-routing.module.ts` you renamed after copying it from `heroes-routing.module.ts` file.\nThis time, you define child routes within the parent `crisis-center` route.\n\n<code-example path=\"router/src/app/crisis-center/crisis-center-routing.module.1.ts\" header=\"src/app/crisis-center/crisis-center-routing.module.ts (Routes)\" region=\"routes\">\nconst crisisCenterRoutes: Routes = [\n  {\n    path: &#39;crisis-center&#39;,\n    component: CrisisCenterComponent,\n    children: [\n      {\n        path: &#39;&#39;,\n        component: CrisisListComponent,\n        children: [\n          {\n            path: &#39;:id&#39;,\n            component: CrisisDetailComponent\n          },\n          {\n            path: &#39;&#39;,\n            component: CrisisCenterHomeComponent\n          }\n        ]\n      }\n    ]\n  }\n];\n\n</code-example>\n\nNotice that the parent `crisis-center` route has a `children` property with a single route containing the `CrisisListComponent`.\nThe `CrisisListComponent` route also has a `children` array with two routes.\n\nThese two routes navigate to the crisis center child components,\n`CrisisCenterHomeComponent` and `CrisisDetailComponent`, respectively.\n\nThere are important differences in the way the router treats child routes.\n\nThe router displays the components of these routes in the `RouterOutlet` of the `CrisisCenterComponent`, not in the `RouterOutlet` of the `AppComponent` shell.\n\nThe `CrisisListComponent` contains the crisis list and a `RouterOutlet` to display the `Crisis Center Home` and `Crisis Detail` route components.\n\nThe `Crisis Detail` route is a child of the `Crisis List`.\nThe router [reuses components](#reuse) by default, so the `Crisis Detail` component will be re-used as you select different crises.\nIn contrast, back in the `Hero Detail` route, [the component was recreated](#snapshot-the-no-observable-alternative) each time you selected a different hero from the list of heroes.\n\nAt the top level, paths that begin with `/` refer to the root of the application.\nBut child routes extend the path of the parent route.\nWith each step down the route tree,\nyou add a slash followed by the route path, unless the path is empty.\n\nApply that logic to navigation within the crisis center for which the parent path is `/crisis-center`.\n\n* To navigate to the `CrisisCenterHomeComponent`, the full URL is `/crisis-center` (`/crisis-center` + `''` + `''`).\n\n* To navigate to the `CrisisDetailComponent` for a crisis with `id=2`, the full URL is\n`/crisis-center/2` (`/crisis-center` + `''` +  `'/2'`).\n\nThe absolute URL for the latter example, including the `localhost` origin, is as follows:\n\n<code-example>\n  localhost:4200/crisis-center/2\n\n</code-example>\n\nHere's the complete `crisis-center-routing.module.ts` file with its imports.\n\n<code-example path=\"router/src/app/crisis-center/crisis-center-routing.module.1.ts\" header=\"src/app/crisis-center/crisis-center-routing.module.ts (excerpt)\">\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { RouterModule, Routes } from &#39;@angular/router&#39;;\n\nimport { CrisisCenterHomeComponent } from &#39;./crisis-center-home/crisis-center-home.component&#39;;\nimport { CrisisListComponent } from &#39;./crisis-list/crisis-list.component&#39;;\nimport { CrisisCenterComponent } from &#39;./crisis-center/crisis-center.component&#39;;\nimport { CrisisDetailComponent } from &#39;./crisis-detail/crisis-detail.component&#39;;\n\nconst crisisCenterRoutes: Routes = [\n  {\n    path: &#39;crisis-center&#39;,\n    component: CrisisCenterComponent,\n    children: [\n      {\n        path: &#39;&#39;,\n        component: CrisisListComponent,\n        children: [\n          {\n            path: &#39;:id&#39;,\n            component: CrisisDetailComponent\n          },\n          {\n            path: &#39;&#39;,\n            component: CrisisCenterHomeComponent\n          }\n        ]\n      }\n    ]\n  }\n];\n\n@NgModule({\n  imports: [\n    RouterModule.forChild(crisisCenterRoutes)\n  ],\n  exports: [\n    RouterModule\n  ]\n})\nexport class CrisisCenterRoutingModule { }\n\n</code-example>\n-->\n<p>위기대응센터의 기능이 동작할 화면을 마련하기 위해 <code>crisis-center</code>에 <code>CrisisCenterHome</code> 컴포넌트를 생성합니다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component crisis-center/crisis-center-home\n</code-example>\n<p>그리고 컴포넌트의 템플릿에 환영 메시지를 추가합니다.</p>\n<code-example path=\"router/src/app/crisis-center/crisis-center-home/crisis-center-home.component.html\" header=\"src/app/crisis-center/crisis-center-home/crisis-center-home.component.html\">\n&#x3C;p>Welcome to the Crisis Center&#x3C;/p>\n\n</code-example>\n<p><code>heroes-routing.module.ts</code> 파일을 복사해서 만든 <code>crisis-center-routing.module.ts</code> 파일을 수정해 봅시다.\n지금은 <code>crisis-center</code> 라우팅 규칙의 자식 라우팅 규칙을 추가합니다.</p>\n<code-example path=\"router/src/app/crisis-center/crisis-center-routing.module.1.ts\" header=\"src/app/crisis-center/crisis-center-routing.module.ts (라우팅 규칙)\" region=\"routes\">\nconst crisisCenterRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'crisis-center',\n    component: CrisisCenterComponent,\n    children: [\n      {\n        path: '',\n        component: CrisisListComponent,\n        children: [\n          {\n            path: ':id',\n            component: CrisisDetailComponent\n          },\n          {\n            path: '',\n            component: CrisisCenterHomeComponent\n          }\n        ]\n      }\n    ]\n  }\n];\n\n</code-example>\n<p>이 때 <code>crisis-center</code> 주소에 해당하는 라우팅 규칙은 <code>CrisisListComponent</code>와 연결되는 <code>children</code> 프로퍼티로 구성됩니다.\n그리고 <code>CrisisListComponent</code> 라우팅 규칙에는 항목이 2개인 <code>children</code> 배열이 지정되어 있습니다.</p>\n<p>이 라우팅 규칙 2개를 활용하면 위기대응센터의 자식 컴포넌트인 <code>CrisisCenterHomeComponent</code>와 <code>CrisisDetailComponent</code>를 전환할 수 있습니다.</p>\n<p>라우터가 자식 라우팅 규칙을 처리하는 방식은 일반 라우팅 규칙을 처리하는 방식과 조금 다릅니다.</p>\n<p>위기대응센터에서 라우터가 화면에 렌더링하는 컴포넌트는 <code>AppComponent</code>에 있는 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>이 아니라 <code>CrisisCenterComponent</code>에 있는 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code> 입니다.</p>\n<p>그리고 위기 상세정보 화면은 위기 목록의 자식 라우팅 규칙입니다.\n기본적으로 라우터는 <a href=\"guide/router-tutorial-toh#reuse\">컴포넌트를 재사용</a>하기 때문에, 위기 상세정보 컴포넌트는 위기 목록에서 선택하는 항목에 따라 재사용될 것입니다.\n하지만 히어로 상세정보 컴포넌트를 생각해보면, 이 컴포넌트는 목록에서 선택한 히어로마다 <a href=\"guide/router-tutorial-toh#snapshot-the-no-observable-alternative\">계속 다른 컴포넌트 인스턴스를 생성</a>합니다.</p>\n<p>라우팅 규칙에서 사용하는 <code>/</code>는 애플리케이션 최상위 주소를 가리킵니다.\n하지만 자식 라우팅 규칙은 부모 라우팅 규칙을 확장하는 것이기 때문에, 라우팅 규칙 트리를 따라 내려가면서 슬래시(<code>/</code>)를 붙이지 않아도 라우팅 규칙 구조에 맞게 최종 주소가 결정됩니다.</p>\n<p>그래서 위기대응센터 밖에서 위기대응센터로 이동하는 경로는 <code>/crisis-center</code>가 됩니다.</p>\n<ul>\n<li>\n<p><code>CrisisCenterHomeComponent</code>로 이동하는 전체 URL은 <code>/crisis-center</code> (<code>/crisis-center</code> + <code>''</code> + <code>''</code>)입니다.</p>\n</li>\n<li>\n<p><code>id=2</code>에 해당하는 위기 항목을 표시하는 <code>CrisisDetailComponent</code>로 이동하는 전체 URL은 <code>/crisis-center/2</code> (<code>/crisis-center</code> + <code>''</code> +  <code>'/2'</code>)입니다.</p>\n</li>\n</ul>\n<p>그리고 이후 예제에서 다루겠지만, 오리진(origin)이 <code>localhost</code>일 때 절대 URL은 이렇습니다:</p>\n<code-example>\n  localhost:4200/crisis-center/2\n\n</code-example>\n<p>여기까지 구현하고 나면 <code>crisis-center-routing.module.ts</code> 파일의 내용은 이렇습니다.</p>\n<code-example path=\"router/src/app/crisis-center/crisis-center-routing.module.1.ts\" header=\"src/app/crisis-center/crisis-center-routing.module.ts (일부)\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { CrisisCenterHomeComponent } from './crisis-center-home/crisis-center-home.component';\nimport { CrisisListComponent } from './crisis-list/crisis-list.component';\nimport { CrisisCenterComponent } from './crisis-center/crisis-center.component';\nimport { CrisisDetailComponent } from './crisis-detail/crisis-detail.component';\n\nconst crisisCenterRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'crisis-center',\n    component: CrisisCenterComponent,\n    children: [\n      {\n        path: '',\n        component: CrisisListComponent,\n        children: [\n          {\n            path: ':id',\n            component: CrisisDetailComponent\n          },\n          {\n            path: '',\n            component: CrisisCenterHomeComponent\n          }\n        ]\n      }\n    ]\n  }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forChild(crisisCenterRoutes)\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class CrisisCenterRoutingModule { }\n\n</code-example>\n<a id=\"import-crisis-module\"></a>\n<!--\n### Import crisis center module into the `AppModule` routes\n-->\n<h3 id=\"appmodule-라우팅-규칙에-위기대응센터-모듈-로드하기\"><code>AppModule</code> 라우팅 규칙에 위기대응센터 모듈 로드하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#appmodule-라우팅-규칙에-위기대응센터-모듈-로드하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAs with the `HeroesModule`, you must add the `CrisisCenterModule` to the `imports` array of the `AppModule`\n_before_ the `AppRoutingModule`:\n\n<code-tabs>\n\n  <code-pane path=\"router/src/app/crisis-center/crisis-center.module.ts\" header=\"src/app/crisis-center/crisis-center.module.ts\">\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { FormsModule } from &#39;@angular/forms&#39;;\nimport { CommonModule } from &#39;@angular/common&#39;;\n\nimport { CrisisCenterHomeComponent } from &#39;./crisis-center-home/crisis-center-home.component&#39;;\nimport { CrisisListComponent } from &#39;./crisis-list/crisis-list.component&#39;;\nimport { CrisisCenterComponent } from &#39;./crisis-center/crisis-center.component&#39;;\nimport { CrisisDetailComponent } from &#39;./crisis-detail/crisis-detail.component&#39;;\n\nimport { CrisisCenterRoutingModule } from &#39;./crisis-center-routing.module&#39;;\n\n@NgModule({\n  imports: [\n    CommonModule,\n    FormsModule,\n    CrisisCenterRoutingModule\n  ],\n  declarations: [\n    CrisisCenterComponent,\n    CrisisListComponent,\n    CrisisCenterHomeComponent,\n    CrisisDetailComponent\n  ]\n})\nexport class CrisisCenterModule {}\n\n\n</code-pane>\n\n  <code-pane path=\"router/src/app/app.module.4.ts\" header=\"src/app/app.module.ts (import CrisisCenterModule)\" region=\"crisis-center-module\">\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { CommonModule } from &#39;@angular/common&#39;;\nimport { FormsModule } from &#39;@angular/forms&#39;;\n\nimport { AppComponent } from &#39;./app.component&#39;;\nimport { PageNotFoundComponent } from &#39;./page-not-found/page-not-found.component&#39;;\nimport { ComposeMessageComponent } from &#39;./compose-message/compose-message.component&#39;;\n\nimport { AppRoutingModule } from &#39;./app-routing.module&#39;;\nimport { HeroesModule } from &#39;./heroes/heroes.module&#39;;\nimport { CrisisCenterModule } from &#39;./crisis-center/crisis-center.module&#39;;\n\n@NgModule({\n  imports: [\n    CommonModule,\n    FormsModule,\n    HeroesModule,\n    CrisisCenterModule,\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    PageNotFoundComponent\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n</code-pane>\n\n</code-tabs>\n\nRemove the initial crisis center route from the `app-routing.module.ts` because now the `HeroesModule` and the `CrisisCenter` modules provide the feature routes.\n\nThe `app-routing.module.ts` file retains the top-level application routes such as the default and wildcard routes.\n\n<code-example path=\"router/src/app/app-routing.module.3.ts\" header=\"src/app/app-routing.module.ts (v3)\" region=\"v3\">\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { RouterModule, Routes } from &#39;@angular/router&#39;;\n\nimport { PageNotFoundComponent } from &#39;./page-not-found/page-not-found.component&#39;;\n\nconst appRoutes: Routes = [\n  { path: &#39;&#39;,   redirectTo: &#39;/heroes&#39;, pathMatch: &#39;full&#39; },\n  { path: &#39;**&#39;, component: PageNotFoundComponent }\n];\n\n@NgModule({\n  imports: [\n    RouterModule.forRoot(\n      appRoutes,\n      { enableTracing: true } // &lt;-- 디버그 활성화\n    )\n  ],\n  exports: [\n    RouterModule\n  ]\n})\nexport class AppRoutingModule {}\n\n\n</code-example>\n-->\n<p><code>HeroesModule</code>과 마찬가지로 <code>CrisisCenterModule</code>도 <code>AppModule</code> <code>imports</code> 배열에 <code>AppRoutingModule</code> <em>보다 먼저</em> 등록해야 합니다:</p>\n<code-tabs>\n\n  <code-pane path=\"router/src/app/crisis-center/crisis-center.module.ts\" header=\"src/app/crisis-center/crisis-center.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> } from '@angular/common';\n\nimport { CrisisCenterHomeComponent } from './crisis-center-home/crisis-center-home.component';\nimport { CrisisListComponent } from './crisis-list/crisis-list.component';\nimport { CrisisCenterComponent } from './crisis-center/crisis-center.component';\nimport { CrisisDetailComponent } from './crisis-detail/crisis-detail.component';\n\nimport { CrisisCenterRoutingModule } from './crisis-center-routing.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    CrisisCenterRoutingModule\n  ],\n  declarations: [\n    CrisisCenterComponent,\n    CrisisListComponent,\n    CrisisCenterHomeComponent,\n    CrisisDetailComponent\n  ]\n})\nexport class CrisisCenterModule {}\n\n\n</code-pane>\n\n  <code-pane path=\"router/src/app/app.module.4.ts\" header=\"src/app/app.module.ts (CrisisCenterModule 로드하기)\" region=\"crisis-center-module\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> } from '@angular/common';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\n\nimport { AppComponent } from './app.component';\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\nimport { ComposeMessageComponent } from './compose-message/compose-message.component';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { HeroesModule } from './heroes/heroes.module';\nimport { CrisisCenterModule } from './crisis-center/crisis-center.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    HeroesModule,\n    CrisisCenterModule,\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    PageNotFoundComponent\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n</code-pane>\n\n</code-tabs>\n<p><code>app-routing.module.ts</code> 파일에 이전에 만들었던 위기대응센터 라우팅 규칙은 제거해도 됩니다.\n이제는 <code>HeroesModule</code>과 <code>CrisisCenterModule</code>이 관련 라우팅 규칙을 관리합니다.</p>\n<p>여기까지 작업하면 <code>app-routing.module.ts</code> 파일에는 애플리케이션 최상위 라우팅 규칙인 기본 라우팅 규칙과 와일드카드 라우팅 규칙만 존재합니다.</p>\n<code-example path=\"router/src/app/app-routing.module.3.ts\" header=\"src/app/app-routing.module.ts (v3)\" region=\"v3\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\n\nconst appRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: '',   redirectTo: '/heroes', pathMatch: 'full' },\n  { path: '**', component: PageNotFoundComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forRoot(\n      appRoutes,\n      { enableTracing: true } // &#x3C;-- 디버그 활성화\n    )\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class AppRoutingModule {}\n\n\n</code-example>\n<a id=\"relative-navigation\"></a>\n<!--\n### Relative navigation\n-->\n<h3 id=\"상대주소로-이동하기\">상대주소로 이동하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#상대주소로-이동하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nWhile building out the crisis center feature, you navigated to the\ncrisis detail route using an absolute path that begins with a slash.\n\nThe router matches such absolute paths to routes starting from the top of the route configuration.\n\nYou could continue to use absolute paths like this to navigate inside the Crisis Center feature, but that pins the links to the parent routing structure.\nIf you changed the parent `/crisis-center` path, you would have to change the link parameters array.\n\nYou can free the links from this dependency by defining paths that are relative to the current URL segment.\nNavigation within the feature area remains intact even if you change the parent route path to the feature.\n\n<div class=\"alert is-helpful\">\n\nThe router supports directory-like syntax in a _link parameters list_ to help guide route name lookup:\n\n`./` or `no leading slash` is relative to the current level.\n\n`../` to go up one level in the route path.\n\nYou can combine relative navigation syntax with an ancestor path.\nIf you must navigate to a sibling route, you could use the `../<sibling>` convention to go up\none level, then over and down the sibling route path.\n\n</div>\n\nTo navigate a relative path with the `Router.navigate` method, you must supply the `ActivatedRoute`\nto give the router knowledge of where you are in the current route tree.\n\nAfter the _link parameters array_, add an object with a `relativeTo` property set to the `ActivatedRoute`.\nThe router then calculates the target URL based on the active route's location.\n\n<div class=\"alert is-helpful\">\n\nAlways specify the complete absolute path when calling router's `navigateByUrl()` method.\n\n</div>\n-->\n<p>위기대응센터 모듈을 빌드하고 나면 슬래시(<code>/</code>)로 시작하는 절대주소를 사용해서 위기 상세정보 화면으로 이동할 수 있습니다.</p>\n<p>절대주소가 사용되면 라우터는 라우팅 규칙 환경설정의 최상위 계층부터 주소를 찾기 시작합니다.</p>\n<p>물론 절대주소를 사용해도 위기대응센터 안에 있는 화면을 모두 사용할 수 있지만, 이 방식은 모듈 밖에 있는 라우팅 규칙의 전체 구조도 알아야 하기 때문에 불편합니다.\n부모 계층에서 <code>/crisis-center</code> 라는 주소를 변경하면 이 모듈 안에서 사용하는 링크 인자 배열도 모두 변경해야 합니다.</p>\n<p>이런 경우에는 현재 URL 세그먼트의 상대주소로 원하는 주소를 지정할 수 있습니다.\n상대주소를 사용하면 모듈 밖에서 화면 주소를 변경하더라도 모듈 안에서 변경할 내용은 없습니다.</p>\n<div class=\"alert is-helpful\">\n<p>라우터는 <em>링크 인자 배열</em> 을 처리할 때 폴더 구조와 비슷한 문법을 사용합니다:</p>\n<p><code>./</code>나 슬래시 없이 시작하는 주소는 현재 라우팅 계층을 기준으로 합니다.</p>\n<p><code>../</code>는 현재 라우팅 계층의 한단계 위를 의미합니다.</p>\n<p>상대주소를 사용하면 부모 계층에 정의된 라우팅 규칙을 활용할 수도 있습니다.\n그리고 같은 계층에서 이웃한 라우팅 규칙으로 이동하려면 한단계 위로 올라가서 이웃 주소를 가리키는 <code>../&#x3C;이웃 주소></code>라고 사용하면 됩니다.</p>\n</div>\n<p><code>Router.navigate</code> 메서드에 상대주소를 사용하려면 현재 라우팅 트리를 확인하기 위해 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>를 인자로 함께 전달해야 합니다.</p>\n<p><em>링크 인자 배열</em> 뒤에 객체를 추가하고 <code>relativeTo</code> 프로퍼티에 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>를 지정하면 됩니다.\n그러면 라우터는 인자로 전달된 라우팅 규칙을 기준으로 최종 URL을 결정합니다.</p>\n<div class=\"alert is-helpful\">\n<p><code>navigateByUrl()</code> 메서드를 사용한다면 반드시 절대주소를 사용해야 합니다.</p>\n</div>\n<a id=\"nav-to-crisis\"></a>\n<!--\n### Navigate to crisis list with a relative URL\n-->\n<h3 id=\"상대주소로-위기대응센터로-이동하기\">상대주소로 위기대응센터로 이동하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#상대주소로-위기대응센터로-이동하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou've already injected the `ActivatedRoute` that you need to compose the relative navigation path.\n\nWhen using a `RouterLink` to navigate instead of the `Router` service, you'd use the same link parameters array, but you wouldn't provide the object with the `relativeTo` property.\nThe `ActivatedRoute` is implicit in a `RouterLink` directive.\n\nUpdate the `gotoCrises()` method of the `CrisisDetailComponent` to navigate back to the Crisis Center list using relative path navigation.\n\n<code-example path=\"router/src/app/crisis-center/crisis-detail/crisis-detail.component.ts\" header=\"src/app/crisis-center/crisis-detail/crisis-detail.component.ts (relative navigation)\" region=\"gotoCrises-navigate\">\n// 상대주소를 사용해서 목록 화면으로 돌아갑니다.\nthis.router.navigate([&#39;../&#39;, { id: crisisId, foo: &#39;foo&#39; }], { relativeTo: this.route });\n\n</code-example>\n\nNotice that the path goes up a level using the `../` syntax.\nIf the current crisis `id` is `3`, the resulting path back to the crisis list is  `/crisis-center/;id=3;foo=foo`.\n-->\n<p>상대주소를 사용하기 위한 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>는 이미 의존성으로 주입되고 있습니다.</p>\n<p><code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>를 직접 사용하지 않고 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>로 화면을 전환하려면 메서드를 사용할 때와 비슷하게 링크 인자 배열을 사용하면 되지만, 이 경우에는 <code>relativeTo</code> 프로퍼티를 사용할 수 없습니다.\n<code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 디렉티브에는 <code>relativeTo</code>를 따로 지정하지 않아도 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>가 적용됩니다.</p>\n<p>이제 <code>CrisisDetailComponent</code>에 있는 <code>gotoCrises()</code> 메서드가 위기 목록으로 이동할 때 상대주소를 사용하도록 수정해 봅시다.</p>\n<code-example path=\"router/src/app/crisis-center/crisis-detail/crisis-detail.component.ts\" header=\"src/app/crisis-center/crisis-detail/crisis-detail.component.ts (상대주소로 이동하기)\" region=\"gotoCrises-navigate\">\n// 상대주소를 사용해서 목록 화면으로 돌아갑니다.\nthis.router.navigate(['../', { id: crisisId, foo: 'foo' }], { relativeTo: this.route });\n\n</code-example>\n<p>이 코드를 보면 <code>../</code>가 사용되었기 때문에 먼저 한단계 위 라우팅 계층으로 올라갑니다.\n그리고 다음 이어지는 객체에 따라 최종 주소는 <code>/crisis-center/;id=3;foo=foo</code>가 됩니다.</p>\n<a id=\"named-outlets\"></a>\n<!--\n### Displaying multiple routes in named outlets\n-->\n<h3 id=\"이름이-지정된-라우팅-영역으로-라우팅-규칙-여러개-표시하기\">이름이 지정된 라우팅 영역으로 라우팅 규칙 여러개 표시하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#이름이-지정된-라우팅-영역으로-라우팅-규칙-여러개-표시하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou decide to give users a way to contact the crisis center.\nWhen a user clicks a \"Contact\" button, you want to display a message in a popup view.\n\nThe popup should stay open, even when switching between pages in the application, until the user closes it\nby sending the message or canceling.\nClearly you can't put the popup in the same outlet as the other pages.\n\nUntil now, you've defined a single outlet and you've nested child routes under that outlet to group routes together.\nThe router only supports one primary unnamed outlet per template.\n\nA template can also have any number of named outlets.\nEach named outlet has its own set of routes with their own components.\nMultiple outlets can display different content, determined by different routes, all at the same time.\n\nAdd an outlet named \"popup\" in the `AppComponent`, directly below the unnamed outlet.\n\n<code-example path=\"router/src/app/app.component.4.html\" header=\"src/app/app.component.html (outlets)\" region=\"outlets\">\n&lt;div [@routeAnimation]=&quot;getAnimationData(routerOutlet)&quot;&gt;\n  &lt;router-outlet #routerOutlet=&quot;outlet&quot;&gt;&lt;/router-outlet&gt;\n&lt;/div&gt;\n&lt;router-outlet name=&quot;popup&quot;&gt;&lt;/router-outlet&gt;\n\n</code-example>\n\nThat's where a popup will go, once you learn how to route a popup component to it.\n-->\n<p>이제부터는 사용자가 위기대응센터와 연락할 수 있는 기능을 만들어 봅시다.\n사용자가 \"Contact\" 버튼을 클릭하면 팝업에 메시지를 표시하려고 합니다.</p>\n<p>이 팝업은 애플리케이션에서 화면을 전환하더라도 계속 떠있으며, 사용자가 메시지를 보내거나 취소했을 때만 닫힙니다.\n그리고 이 팝업에 들어가는 컴포넌트는 일반 화면처럼 사용하지는 않습니다.</p>\n<p>지금은 라우팅 영역을 하나 더 정의한 후에 자식 라우팅 규칙에 해당하는 컴포넌트를 이 라우팅 영역에 표시해 봅시다.\n이름없이 사용할 수 있는 1차(primary) 라우팅 영역은 템플릿에 하나만 존재할 수 있습니다.</p>\n<p>라우팅 영역에 이름을 지정하면 한 템플릿 안에 라우팅 영역을 여러개 추가할 수도 있으며, 개별 라우팅 영역은 라우팅 규칙에 맞는 컴포넌트를 표시합니다.\n그리고 개별 라우팅 영역은 서로 다른 라우팅 규칙을 적용받기 때문에 서로 다른 내용을 표시할 수 있으며, 한번에 다른 내용으로 변경할 수도 있습니다.</p>\n<p><code>AppComponent</code> 템플릿의 이름없는 라우팅 영역 바로 아래에 \"popup\"이라는 이름으로 라우팅 영역을 추가합시다.</p>\n<code-example path=\"router/src/app/app.component.4.html\" header=\"src/app/app.component.html (여러 라우팅 영역)\" region=\"outlets\">\n&#x3C;div [@routeAnimation]=\"getAnimationData(routerOutlet)\">\n  &#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a> #routerOutlet=\"outlet\">&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n&#x3C;/div>\n&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a> name=\"popup\">&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n\n</code-example>\n<p>팝업이 표시되는 위치는 새로 추가한 라우팅 영역입니다.</p>\n<a id=\"secondary-routes\"></a>\n<!--\n#### Secondary routes\n-->\n<h4 id=\"2차-라우팅-규칙\">2차 라우팅 규칙<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#2차-라우팅-규칙\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nNamed outlets are the targets of  _secondary routes_.\n\nSecondary routes look like primary routes and you configure them the same way.\nThey differ in a few key respects.\n\n* They are independent of each other.\n* They work in combination with other routes.\n* They are displayed in named outlets.\n\nGenerate a new component to compose the message.\n\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component compose-message\n</code-example>\n\nIt displays a short form with a header, an input box for the message,\nand two buttons, \"Send\" and \"Cancel\".\n\n<div class=\"lightbox\">\n  <img src='generated/images/guide/router/contact-popup.png' alt=\"Contact popup\">\n</div>\n\nHere's the component, its template and styles:\n\n<code-tabs>\n\n  <code-pane header=\"src/app/compose-message/compose-message.component.css\" path=\"router/src/app/compose-message/compose-message.component.css\">\n:host {\n  position: relative; bottom: 10%;\n}\n\n</code-pane>\n\n  <code-pane header=\"src/app/compose-message/compose-message.component.html\" path=\"router/src/app/compose-message/compose-message.component.html\">\n&lt;h3&gt;Contact Crisis Center&lt;/h3&gt;\n&lt;div *ngIf=&quot;details&quot;&gt;\n  {{ details }}\n&lt;/div&gt;\n&lt;div&gt;\n  &lt;div&gt;\n    &lt;label&gt;Message: &lt;/label&gt;\n  &lt;/div&gt;\n  &lt;div&gt;\n    &lt;textarea [(ngModel)]=&quot;message&quot; rows=&quot;10&quot; cols=&quot;35&quot; [disabled]=&quot;sending&quot;&gt;&lt;/textarea&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n&lt;p *ngIf=&quot;!sending&quot;&gt;\n  &lt;button (click)=&quot;send()&quot;&gt;Send&lt;/button&gt;\n  &lt;button (click)=&quot;cancel()&quot;&gt;Cancel&lt;/button&gt;\n&lt;/p&gt;\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/compose-message/compose-message.component.ts\" path=\"router/src/app/compose-message/compose-message.component.ts\">\nimport { Component, HostBinding } from &#39;@angular/core&#39;;\nimport { Router } from &#39;@angular/router&#39;;\n\n@Component({\n  selector: &#39;app-compose-message&#39;,\n  templateUrl: &#39;./compose-message.component.html&#39;,\n  styleUrls: [&#39;./compose-message.component.css&#39;]\n})\nexport class ComposeMessageComponent {\n  details: string;\n  message: string;\n  sending = false;\n\n  constructor(private router: Router) {}\n\n  send() {\n    this.sending = true;\n    this.details = &#39;Sending Message...&#39;;\n\n    setTimeout(() =&gt; {\n      this.sending = false;\n      this.closePopup();\n    }, 1000);\n  }\n\n  cancel() {\n    this.closePopup();\n  }\n\n  closePopup() {\n    // 이름을 지정한 라우팅 영역에 `null` 값을 지정하면 라우팅 영역의 내용을 모두 비웁니다.\n    this.router.navigate([{ outlets: { popup: null }}]);\n  }\n}\n\n\n</code-pane>\n\n</code-tabs>\n\nIt looks similar to any other component in this guide, but there are two key differences.\n\nNote that the `send()` method simulates latency by waiting a second before \"sending\" the message and closing the popup.\n\nThe `closePopup()` method closes the popup view by navigating to the popup outlet with a `null` which the section on [clearing secondary routes](#clear-secondary-routes) covers.\n-->\n<p>이름이 지정된 라우팅 규칙은 <em>2차 라우팅 규칙(secondary routes)</em> 대상이 될 수 있습니다.</p>\n<p>2차 라우팅 규칙은 1차(primary) 라우팅 규칙과 비슷해 보이며, 설정하는 방법도 같습니다.\n다만 다른 점이 몇가지 있습니다.</p>\n<ul>\n<li>각 라우팅 규칙은 서로 독립적입니다.</li>\n<li>다른 라우팅 규칙과 결합해서 사용합니다.</li>\n<li>이름이 지정된 라우팅 영역에 표시됩니다.</li>\n</ul>\n<p>메시지를 보낼 수 있는 컴포넌트를 새로 생성합시다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component compose-message\n</code-example>\n<p>이 컴포넌트에는 헤더와 메시지를 입력받는 필드 \"Send\", \"Cancel\" 버튼이 존재합니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/router/contact-popup.png\" alt=\"Contact popup\" width=\"250\" height=\"262\">\n</div>\n<p>컴포넌트를 구성하는 파일의 내용은 이렇습니다:</p>\n<code-tabs>\n\n  <code-pane header=\"src/app/compose-message/compose-message.component.css\" path=\"router/src/app/compose-message/compose-message.component.css\">\n:host {\n  position: relative; bottom: 10%;\n}\n\n</code-pane>\n\n  <code-pane header=\"src/app/compose-message/compose-message.component.html\" path=\"router/src/app/compose-message/compose-message.component.html\">\n&#x3C;h3>Contact Crisis Center&#x3C;/h3>\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"details\">\n  {{ details }}\n&#x3C;/div>\n&#x3C;div>\n  &#x3C;div>\n    &#x3C;label>Message: &#x3C;/label>\n  &#x3C;/div>\n  &#x3C;div>\n    &#x3C;<a href=\"api/forms/DefaultValueAccessor\" class=\"code-anchor\">textarea</a> [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"message\" rows=\"10\" cols=\"35\" [disabled]=\"sending\">&#x3C;/<a href=\"api/forms/DefaultValueAccessor\" class=\"code-anchor\">textarea</a>>\n  &#x3C;/div>\n&#x3C;/div>\n&#x3C;p *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"!sending\">\n  &#x3C;button (click)=\"send()\">Send&#x3C;/button>\n  &#x3C;button (click)=\"cancel()\">Cancel&#x3C;/button>\n&#x3C;/p>\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/compose-message/compose-message.component.ts\" path=\"router/src/app/compose-message/compose-message.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/HostBinding\" class=\"code-anchor\">HostBinding</a> } from '@angular/core';\nimport { <a href=\"api/router/Router\" class=\"code-anchor\">Router</a> } from '@angular/router';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-compose-message',\n  templateUrl: './compose-message.component.html',\n  styleUrls: ['./compose-message.component.css']\n})\nexport class ComposeMessageComponent {\n  details: string;\n  message: string;\n  sending = false;\n\n  constructor(private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {}\n\n  send() {\n    this.sending = true;\n    this.details = 'Sending Message...';\n\n    setTimeout(() => {\n      this.sending = false;\n      this.closePopup();\n    }, 1000);\n  }\n\n  cancel() {\n    this.closePopup();\n  }\n\n  closePopup() {\n    // 이름을 지정한 라우팅 영역에 `null` 값을 지정하면 라우팅 영역의 내용을 모두 비웁니다.\n    this.router.navigate([{ outlets: { popup: null }}]);\n  }\n}\n\n\n</code-pane>\n\n</code-tabs>\n<p>이 컴포넌트는 다른 컴포넌트들과 거의 비슷하지만 다른 점이 두가지 있습니다.</p>\n<p><code>send()</code> 메서드는 메시지를 보낸 것을 시뮬레이션하기 위해 \"sending\" 문구를 표시하고 1초 있다가 팝업을 닫습니다.</p>\n<p><code>closePopup()</code> 메서드는 2차 라우팅 규칙에 해당하는 주소에 <code>null</code>을 지정해서 팝업을 닫습니다.\n이 내용은 <a href=\"guide/router-tutorial-toh#clear-secondary-routes\">2차 라우팅 규칙 해제하기</a> 섹션에서 다룹니다.</p>\n<a id=\"add-secondary-route\"></a>\n<!--\n#### Add a secondary route\n-->\n<h4 id=\"2차-라우팅-규칙-추가하기\">2차 라우팅 규칙 추가하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#2차-라우팅-규칙-추가하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nOpen the `AppRoutingModule` and add a new `compose` route to the `appRoutes`.\n\n<code-example path=\"router/src/app/app-routing.module.3.ts\" header=\"src/app/app-routing.module.ts (compose route)\" region=\"compose\">\n{\n  path: &#39;compose&#39;,\n  component: ComposeMessageComponent,\n  outlet: &#39;popup&#39;\n},\n\n</code-example>\n\nIn addition to the `path` and `component` properties, there's a new property called `outlet`, which is set to `'popup'`.\nThis route now targets the popup outlet and the `ComposeMessageComponent` will display there.\n\nTo give users a way to open the popup, add a \"Contact\" link to the `AppComponent` template.\n\n<code-example path=\"router/src/app/app.component.4.html\" header=\"src/app/app.component.html (contact-link)\" region=\"contact-link\">\n&lt;a [routerLink]=&quot;[{ outlets: { popup: [&#39;compose&#39;] } }]&quot;&gt;Contact&lt;/a&gt;\n\n</code-example>\n\nAlthough the `compose` route is configured to the \"popup\" outlet, that's not sufficient for connecting the route to a `RouterLink` directive.\nYou have to specify the named outlet in a _link parameters array_ and bind it to the `RouterLink` with a property binding.\n\nThe _link parameters array_ contains an object with a single `outlets` property whose value is another object keyed by one (or more) outlet names.\nIn this case there is only the \"popup\" outlet property and its value is another _link parameters array_ that specifies the `compose` route.\n\nIn other words, when the user clicks this link, the router displays the component associated with the `compose` route in the `popup` outlet.\n\n<div class=\"alert is-helpful\">\n\nThis `outlets` object within an outer object was unnecessary when there was only one route and one unnamed outlet.\n\nThe router assumed that your route specification targeted the unnamed primary outlet and created these objects for you.\n\nRouting to a named outlet has revealed a router feature:\nyou can target multiple outlets with multiple routes in the same `RouterLink` directive.\n\n</div>\n-->\n<p><code>AppRoutingModule</code>를 열고 <code>appRoutes</code> 배열에 <code>compose</code> 라우팅 규칙을 추가합니다.</p>\n<code-example path=\"router/src/app/app-routing.module.3.ts\" header=\"src/app/app-routing.module.ts (compose 라우팅 규칙)\" region=\"compose\">\n{\n  path: 'compose',\n  component: ComposeMessageComponent,\n  outlet: 'popup'\n},\n\n</code-example>\n<p>그리고 <code>path</code>, <code>component</code> 프로퍼티 외에 <code>outlet</code> 프로퍼티를 추가하고 이 프로퍼티의 값을 <code>'popup'</code>로 지정합니다.\n라우팅 규칙을 이렇게 지정하면 <code>ComposeMessageComponent</code>이 팝업 라우팅 영역에 표시됩니다.</p>\n<p>이제 사용자가 팝업을 열 수 있도록 <code>AppComponent</code> 템플릿에 \"Contact\" 링크를 추가합니다.</p>\n<code-example path=\"router/src/app/app.component.4.html\" header=\"src/app/app.component.html (Contact 링크)\" region=\"contact-link\">\n&#x3C;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"[{ outlets: { popup: ['compose'] } }]\">Contact&#x3C;/a>\n\n</code-example>\n<p><code>compose</code> 주소에 해당하는 라우팅 규칙은 \"popup\" 라우팅 영역을 사용하도록 설정했지만, <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 디렉티브에도 추가 설정이 필요합니다.\n<code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 디렉티브에 바인딩하는 <em>링크 인자 배열</em> 에 원하는 라우팅 영역 이름을 지정해야 합니다.</p>\n<p>지금 작성한 <em>링크 인자 배열</em> 에는 객체가 추가되었고 이 객체에는 <code>outlets</code> 프로퍼티 값이 하나지만, 라우팅 영역이 여러개라면 객체 키를 더 추가할 수도 있습니다.\n지금은 \"popup\" 라우팅 영역만 지정했습니다.</p>\n<p>이렇게 작성하면 사용자가 링크를 클릭했을 때 라우터가 <code>compose</code>에 해당하는 라우팅 규칙을 <code>popup</code> 라우팅 영역에 적용합니다.</p>\n<div class=\"alert is-helpful\">\n<p>라우팅 규칙를 하나만 적용하면서 이름을 지정하지 않은 라우팅 영역이 하나만 있다면 <code>outlets</code> 객체는 필요없습니다.</p>\n<p>이 경우에는 이름이 지정되지 않은 1차 라우팅 영역을 대상으로 라우터가 동작하며, <code>outlets</code> 객체는 라우터가 자동으로 생성합니다.</p>\n<p>이 예제를 통해 라우터가 제공하는 기능을 확인할 수 있습니다:\n<code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 디렉티브를 활용하면 라우팅 영역 여러개에 라우팅 규칙 여러개를 동시에 적용할 수 있습니다.</p>\n</div>\n<a id=\"secondary-route-navigation\"></a>\n<!--\n#### Secondary route navigation: merging routes during navigation\n-->\n<h4 id=\"2차-라우팅-규칙-적용하기-라우팅-규칙-병합하기\">2차 라우팅 규칙 적용하기: 라우팅 규칙 병합하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#2차-라우팅-규칙-적용하기-라우팅-규칙-병합하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nNavigate to the _Crisis Center_ and click \"Contact\".\nyou should see something like the following URL in the browser address bar.\n\n<code-example>\n  http://.../crisis-center(popup:compose)\n\n</code-example>\n\nThe relevant part of the URL follows the `...`:\n\n* The `crisis-center` is the primary navigation.\n* Parentheses surround the secondary route.\n* The secondary route consists of an outlet name (`popup`), a `colon` separator, and the secondary route path (`compose`).\n\nClick the _Heroes_ link and look at the URL again.\n\n<code-example>\n  http://.../heroes(popup:compose)\n</code-example>\n\nThe primary navigation part has changed; the secondary route is the same.\n\nThe router is keeping track of two separate branches in a navigation tree and generating a representation of that tree in the URL.\n\nYou can add many more outlets and routes, at the top level and in nested levels, creating a navigation tree with many branches and the router will generate the URLs to go with it.\n\nYou can tell the router to navigate an entire tree at once by filling out the `outlets` object and then pass that object inside a _link parameters array_  to the `router.navigate` method.\n-->\n<p><em>위기대응센터</em> 로 이동해서 \"Contact\" 링크를 클릭해 봅시다.\n그러면 브라우저 주소표시줄에 이런 URL이 표시될 것입니다.</p>\n<code-example>\n  http://.../crisis-center(popup:compose)\n\n</code-example>\n<p><code>...</code> 뒤에 붙는 URL은 이런 의미입니다:</p>\n<ul>\n<li><code>crisis-center</code>는 1차 네비게이션 경로입니다.</li>\n<li>1차 라우팅 규칙은 소괄호(<code>()</code>) 안에 들어갑니다.</li>\n<li>2차 라우팅 규칙은 라우팅 영역의 이름(<code>popup</code>)과 구분자(<code>:</code>), 2차 라우팅 규칙의 경로(<code>compose</code>)로 구성됩니다.</li>\n</ul>\n<p>히어로 목록으로 이동하는 링크를 클릭하고 브라우저 주소표시줄을 다시 봅시다.</p>\n<code-example>\n  http://.../heroes(popup:compose)\n</code-example>\n<p>1차 라우팅 규칙의 주소는 변경되었지만 2차 라우팅 규칙의 주소는 변경되지 않았습니다.</p>\n<p>라우팅 규칙이 동시에 여러개 사용되면 라우터는 각 라우팅 규칙을 별개로 관리합니다.</p>\n<p>라우팅 영역과 라우팅 규칙은 최상위 계층부터 계층 구조로 얼마든지 자유롭게 구성할 수 있으며, 네비게이션 트리도 이 구조에 맞게 브랜치를 구성된 후에 최종 URL을 생성합니다.</p>\n<p>그래서 <code>outlets</code> 객체를 사용하면서 전체 네비게이션 트리 중 어떤 경로로 이동할 지 한번에 지정할 수 있습니다.\n이 객체는 <code>router.navigate</code> 메서드에 전달하는 <em>링크 인자 배열</em> 안에 객체 형태로 전달합니다.</p>\n<a id=\"clear-secondary-routes\"></a>\n<!--\n#### Clearing secondary routes\n-->\n<h4 id=\"2차-라우팅-규칙-해제하기\">2차 라우팅 규칙 해제하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#2차-라우팅-규칙-해제하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nLike regular outlets, secondary outlets persists until you navigate away to a new component.\n\nEach secondary outlet has its own navigation, independent of the navigation driving the primary outlet.\nChanging a current route that displays in the primary outlet has no effect on the popup outlet.\nThat's why the popup stays visible as you navigate among the crises and heroes.\n\nThe `closePopup()` method again:\n\n<code-example path=\"router/src/app/compose-message/compose-message.component.ts\" header=\"src/app/compose-message/compose-message.component.ts (closePopup)\" region=\"closePopup\">\nclosePopup() {\n  // 이름을 지정한 라우팅 영역에 `null` 값을 지정하면 라우팅 영역의 내용을 모두 비웁니다.\n  this.router.navigate([{ outlets: { popup: null }}]);\n}\n\n</code-example>\n\nClicking the \"send\" or \"cancel\" buttons clears the popup view.\nThe `closePopup()` function navigates imperatively with the `Router.navigate()` method, passing in a [link parameters array](#link-parameters-array).\n\nLike the array bound to the _Contact_ `RouterLink` in the `AppComponent`, this one includes an object with an `outlets` property.\nThe `outlets` property value is another object with outlet names for keys.\nThe only named outlet is `'popup'`.\n\nThis time, the value of `'popup'` is `null`.\nThat's not a route, but it is a legitimate value.\nSetting the popup `RouterOutlet` to `null` clears the outlet and removes the secondary popup route from the current URL.\n-->\n<p>보통 라우팅 영역과 비슷하게, 2차 라우팅 영역도 컴포넌트 밖으로 이동할 때까지 유지됩니다.</p>\n<p>2차 라우팅 영역은 네비게이션을 직접 관리하며, 이 네비게이션 동작은 1차 라우팅 영역과는 별개로 동작합니다.\n그래서 1차 라우팅 영역에 적용되는 라우팅 규칙이 변경되어도 팝업이 표시되는 라우팅 영역은 영향을 받지 않습니다.\n위기대응센터 모듈과 히어로 모듈을 전환하더라도 팝업이 계속 표시되는 것은 이때문입니다.</p>\n<p><code>closePopup()</code> 메서드를 다시 봅시다:</p>\n<code-example path=\"router/src/app/compose-message/compose-message.component.ts\" header=\"src/app/compose-message/compose-message.component.ts (closePopup())\" region=\"closePopup\">\nclosePopup() {\n  // 이름을 지정한 라우팅 영역에 `null` 값을 지정하면 라우팅 영역의 내용을 모두 비웁니다.\n  this.router.navigate([{ outlets: { popup: null }}]);\n}\n\n</code-example>\n<p>\"send\" 버튼이나 \"cancel\" 버튼을 클릭하면 팝업 화면을 비웁니다.\n<code>closePopup()</code> 함수는 <a href=\"guide/router-tutorial-toh#link-parameters-array\">링크 인자 배열</a>을 <code><a href=\"api/router/Router#navigate\" class=\"code-anchor\">Router.navigate()</a></code> 메서드에 인자로 전달해서 이 동작을 처리합니다.</p>\n<p><code>AppComponent</code>에 있는 <em>Contact</em> <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>에 바인딩된 배열과 비슷하게, 이 링크 인자 배열에도 <code>outlets</code> 프로퍼티가 존재하는 객체가 사용되었습니다.\n<code>outlets</code> 프로퍼티의 값은 라우팅 영역을 키로 하는 객체로 구성됩니다.\n이 예제에서는 <code>'popup'</code> 이라는 라우팅 영역만 사용되었습니다.</p>\n<p>그런데 <code>closePopup()</code> 함수에 사용된 <code>'popoup'</code> 라우팅 영역의 값은 <code>null</code>입니다.\n이 값이 라우팅 규칙과 매칭되지는 않지만, 사용할 수 있는 값은 맞습니다.\n팝업이 표시되는 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>에 <code>null</code> 값을 지정하면 라우터가 라우팅 영역의 내용을 비우며, 현재 URL에서 2차 라우팅 규칙에 해당하는 부분도 제거합니다.</p>\n<a id=\"guards\"></a>\n<a id=\"milestone-5-route-guards\"></a>\n<!--\n## Milestone 5: Route guards\n-->\n<h2 id=\"마일스톤-5-라우팅-가드\">마일스톤 5: 라우팅 가드<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#마일스톤-5-라우팅-가드\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAt the moment, any user can navigate anywhere in the application anytime, but sometimes you need to control access to different parts of your app for various reasons. Some of which may include the following:\n\n* Perhaps the user is not authorized to navigate to the target component.\n* Maybe the user must login (authenticate) first.\n* Maybe you should fetch some data before you display the target component.\n* You might want to save pending changes before leaving a component.\n* You might ask the user if it's OK to discard pending changes rather than save them.\n\nYou add guards to the route configuration to handle these scenarios.\n\nA guard's return value controls the router's behavior:\n\n* If it returns `true`, the navigation process continues.\n* If it returns `false`, the navigation process stops and the user stays put.\n* If it returns a `UrlTree`, the current navigation cancels and a new navigation is initiated to the `UrlTree` returned.\n\n<div class=\"alert is-helpful\">\n\n**Note:** The guard can also tell the router to navigate elsewhere, effectively canceling the current navigation.\nWhen doing so inside a guard, the guard should return `false`;\n\n</div>\n\nThe guard might return its boolean answer synchronously.\nBut in many cases, the guard can't produce an answer synchronously.\nThe guard could ask the user a question, save changes to the server, or fetch fresh data.\nThese are all asynchronous operations.\n\nAccordingly, a routing guard can return an `Observable<boolean>` or a `Promise<boolean>` and the\nrouter will wait for the observable to resolve to `true` or `false`.\n\n<div class=\"alert is-critical\">\n\n**Note:** The observable provided to the `Router` must also complete. If the observable does not complete, the navigation does not continue.\n\n</div>\n\nThe router supports multiple guard interfaces:\n\n* [`CanActivate`](api/router/CanActivate) to mediate navigation *to* a route.\n\n* [`CanActivateChild`](api/router/CanActivateChild) to mediate navigation *to* a child route.\n\n* [`CanDeactivate`](api/router/CanDeactivate) to mediate navigation *away* from the current route.\n\n* [`Resolve`](api/router/Resolve) to perform route data retrieval *before* route activation.\n\n* [`CanLoad`](api/router/CanLoad) to mediate navigation *to* a feature module loaded _asynchronously_.\n\n\nYou can have multiple guards at every level of a routing hierarchy.\nThe router checks the `CanDeactivate` and `CanActivateChild` guards first, from the deepest child route to the top.\nThen it checks the `CanActivate` guards from the top down to the deepest child route.\nIf the feature module is loaded asynchronously, the `CanLoad` guard is checked before the module is loaded.\nIf _any_ guard returns false, pending guards that have not completed will be canceled, and the entire navigation is canceled.\n\nThere are several examples over the next few sections.\n-->\n<p>지금까지 작성한 앱에서는 사용자가 애플리케이션이 제공하는 화면을 어디든 자유롭게 이동할 수 있지만, 때로는 이 과정을 제어해야 하는 경우도 있습니다.\n이런 경우가 그렇습니다:</p>\n<ul>\n<li>로그인하지 않은 사용자가 어떤 컴포넌트로 이동하려는 경우</li>\n<li>로그인 한 사용자가 권한이 있는지 확인해야 하는 경우</li>\n<li>컴포넌트를 표시하기 전에 데이터를 먼저 불러와야 하는 경우</li>\n<li>컴포넌트를 벗어나기 전에 변경한 내용을 저장해야 하는 경우</li>\n<li>저장하지 않는다면 변경한 내용을 폐기할지 사용자에게 확인을 받아야 하는 경우</li>\n</ul>\n<p>이런 경우는 라우팅 규칙 환경설정에 가드를 추가해서 처리할 수 있습니다.</p>\n<p>라우터는 가드가 반환하는 값에 따라 이런 동작을 합니다:</p>\n<ul>\n<li>가드가 <code>true</code>를 반환하면 화면 이동을 계속 진행합니다.</li>\n<li>가드가 <code>false</code>를 반환하면 화면 이동을 멈춥니다.</li>\n<li>가드가 <code><a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a></code>를 반환하면 화면 이동을 취소하고 <code><a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a></code>에 해당하는 주소로 이동합니다.</li>\n</ul>\n<div class=\"alert is-helpful\">\n<p><strong>참고</strong>: 라우터 가드가 다른 곳으로 이동하도록 지정하면 현재 진행되는 네비게이션 동작은 취소됩니다.\n라우터 가드 안에서 이 동작을 직접 처리한다면 가드가 반환하는 값이 <code>false</code>여야 합니다.</p>\n</div>\n<p>라우터 가드는 불리언 결과값을 동기 방식으로 반환할 수 있습니다.\n하지만 대부분의 경우에 라우터 가드는 결과값을 동기 방식으로 반환할 수 없습니다.\n라우터 가드는 사용자에게 물어보거나, 변경된 내용을 저장하기 위해 서버와 통신해야 하고, 데이터를 받아오기도 해야 합니다.\n이 동작은 모두 비동기로 이루어집니다.</p>\n<p>그래서 라우팅 가드는 결과값으로 <code>Observable&#x3C;boolean></code>이나 <code>Promise&#x3C;boolean></code>을 반환할 수 있으며, 이 옵저버블이나 프라미스가 결과값을 보내기 전까지 라우터가 동작을 멈춥니다.</p>\n<div class=\"alert is-critical\">\n<p><strong>참고:</strong> 라우터 가드에 옵저버블이 사용되면 이 옵저버블은 반드시 종료되어야 합니다.\n옵저버블이 종료되지 않으면 네비게이션 동작도 멈춘 상태로 유지됩니다.</p>\n</div>\n<p>라우터가 제공하는 가드 인터페이스는 이런 것들이 있습니다:</p>\n<ul>\n<li><a href=\"api/router/CanActivate\"><code>CanActivate</code></a>: <em>앞으로 적용될</em> 라우팅 규칙에 개입합니다.</li>\n<li><a href=\"api/router/CanActivateChild\"><code>CanActivateChild</code></a>: <em>앞으로 적용될</em> 자식 라우팅 규칙에 개입합니다.</li>\n<li><a href=\"api/router/CanDeactivate\"><code>CanDeactivate</code></a>: 현재 적용된 라우팅 규칙을 <em>벗어날 때</em> 개입합니다.</li>\n<li><a href=\"api/router/Resolve\"><code>Resolve</code></a>: <em>앞으로 적용될</em> 라우팅 규칙에 필요한 데이터를 먼저 처리할 때 사용합니다.</li>\n<li><a href=\"api/router/CanLoad\"><code>CanLoad</code></a>: <em>비동기로</em> 로드되는 기능 모듈로 <em>이동할 때</em> 개입합니다.</li>\n</ul>\n<p>라우팅 가드는 라우팅 규칙 계층 구조 어디에라도 자유롭게 여러개씩도 적용할 수 있습니다.\n라우터는 가장 안쪽에 있는 자식 라우팅 규칙부터 위쪽 계층으로 향하면서 <code>CanDeactivated</code>, <code><a href=\"api/router/CanActivateChild\" class=\"code-anchor\">CanActivateChild</a></code> 가드가 먼저 실행됩니다.\n그리고 최상위 계층부터 자식 라우팅 규칙으로 향하면서 <code><a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a></code> 가드가 실행됩니다.\n이 때 기능 모듈이 비동기로 로드된다면 이 모듈을 로드하기 전에 <code><a href=\"api/router/CanLoad\" class=\"code-anchor\">CanLoad</a></code> 가드가 실행됩니다.\n이 과정 중에 <code>false</code>를 반환하는 가드가 있으면 아직 실행되지 않은 가드 실행은 모두 취소되며 네비게이션 동작도 취소됩니다.</p>\n<p>다음 섹션에서는 예제를 보면서 자세하게 알아봅시다.</p>\n<a id=\"can-activate-guard\"></a>\n<!--\n### `CanActivate`: requiring authentication\n-->\n<h3 id=\"canactivate-인증을-확인할-때\"><code><a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a></code>: 인증을 확인할 때<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#canactivate-인증을-확인할-때\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nApplications often restrict access to a feature area based on who the user is.\nYou could permit access only to authenticated users or to users with a specific role.\nYou might block or limit access until the user's account is activated.\n\nThe `CanActivate` guard is the tool to manage these navigation business rules.\n-->\n<p>사용자에 따라 애플리케이션 일부 영역에 접근하는 것을 제한해야 하는 경우가 있습니다.\n로그인 한 사용자나 해당 영역과 관련된 사용자만 접근을 허락하는 경우가 그렇습니다.\n이런 사용자가 아니라면 접근을 제한할 수도 있습니다.</p>\n<p><code><a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a></code> 가드는 이런 경우에 사용합니다.</p>\n<!--\n#### Add an admin feature module\n-->\n<h4 id=\"관리자-기능-모듈-추가하기\">관리자 기능 모듈 추가하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#관리자-기능-모듈-추가하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThis section guides you through extending the crisis center with some new administrative features.\nStart by adding a new feature module named `AdminModule`.\n\nGenerate an `admin` folder with a feature module file and a routing configuration file.\n\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate module admin --routing\n</code-example>\n\nNext, generate the supporting components.\n\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component admin/admin-dashboard\n</code-example>\n\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component admin/admin\n</code-example>\n\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component admin/manage-crises\n</code-example>\n\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component admin/manage-heroes\n</code-example>\n\nThe admin feature file structure looks like this:\n-->\n<p>이번 섹션에서는 위기대응센터 기능을 확장해서 관리자용 기능 모듈을 만들어 봅시다.\n먼저 <code>AdminModule</code>이라는 이름으로 기능 모듈을 생성합니다.</p>\n<p><code>admin</code> 폴더에 기능 모듈 파일과 라우팅 환경설정 파일을 생성합니다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate module admin --routing\n</code-example>\n<p>그리고 컴포넌트를 몇개 생성합니다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component admin/admin-dashboard\n</code-example>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component admin/admin\n</code-example>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component admin/manage-crises\n</code-example>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component admin/manage-heroes\n</code-example>\n<p>그러면 관리자 모듈이 이렇게 구성됩니다:</p>\n<div class=\"filetree\">\n  <div class=\"file\">\n    src/app/admin\n  </div>\n  <div class=\"children\">\n    <div class=\"file\">\n      admin\n    </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          admin.component.css\n        </div>\n        <div class=\"file\">\n          admin.component.html\n        </div>\n        <div class=\"file\">\n          admin.component.ts\n        </div>\n      </div>\n    <div class=\"file\">\n      admin-dashboard\n    </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          admin-dashboard.component.css\n        </div>\n        <div class=\"file\">\n          admin-dashboard.component.html\n        </div>\n        <div class=\"file\">\n          admin-dashboard.component.ts\n        </div>\n      </div>\n    <div class=\"file\">\n      manage-crises\n    </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          manage-crises.component.css\n        </div>\n        <div class=\"file\">\n          manage-crises.component.html\n        </div>\n        <div class=\"file\">\n          manage-crises.component.ts\n        </div>\n      </div>\n    <div class=\"file\">\n      manage-heroes\n    </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          manage-heroes.component.css\n        </div>\n        <div class=\"file\">\n          manage-heroes.component.html\n        </div>\n        <div class=\"file\">\n          manage-heroes.component.ts\n        </div>\n      </div>\n    <div class=\"file\">\n      admin.module.ts\n    </div>\n    <div class=\"file\">\n      admin-routing.module.ts\n    </div>\n  </div>\n</div>\n<!--\nThe admin feature module contains the `AdminComponent` used for routing within the\nfeature module, a dashboard route and two unfinished components to manage crises and heroes.\n\n<code-tabs>\n\n  <code-pane header=\"src/app/admin/admin/admin.component.html\" path=\"router/src/app/admin/admin/admin.component.html\">\n&lt;h3&gt;ADMIN&lt;/h3&gt;\n&lt;nav&gt;\n  &lt;a routerLink=&quot;./&quot; routerLinkActive=&quot;active&quot;\n    [routerLinkActiveOptions]=&quot;{ exact: true }&quot;&gt;Dashboard&lt;/a&gt;\n  &lt;a routerLink=&quot;./crises&quot; routerLinkActive=&quot;active&quot;&gt;Manage Crises&lt;/a&gt;\n  &lt;a routerLink=&quot;./heroes&quot; routerLinkActive=&quot;active&quot;&gt;Manage Heroes&lt;/a&gt;\n&lt;/nav&gt;\n&lt;router-outlet&gt;&lt;/router-outlet&gt;\n\n</code-pane>\n\n  <code-pane header=\"src/app/admin/admin-dashboard/admin-dashboard.component.html\" path=\"router/src/app/admin/admin-dashboard/admin-dashboard.component.1.html\">\n&lt;p&gt;Dashboard&lt;/p&gt;\n\n</code-pane>\n\n  <code-pane header=\"src/app/admin/admin.module.ts\" path=\"router/src/app/admin/admin.module.ts\">\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { CommonModule } from &#39;@angular/common&#39;;\n\nimport { AdminComponent } from &#39;./admin/admin.component&#39;;\nimport { AdminDashboardComponent } from &#39;./admin-dashboard/admin-dashboard.component&#39;;\nimport { ManageCrisesComponent } from &#39;./manage-crises/manage-crises.component&#39;;\nimport { ManageHeroesComponent } from &#39;./manage-heroes/manage-heroes.component&#39;;\n\nimport { AdminRoutingModule } from &#39;./admin-routing.module&#39;;\n\n@NgModule({\n  imports: [\n    CommonModule,\n    AdminRoutingModule\n  ],\n  declarations: [\n    AdminComponent,\n    AdminDashboardComponent,\n    ManageCrisesComponent,\n    ManageHeroesComponent\n  ]\n})\nexport class AdminModule {}\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/admin/manage-crises/manage-crises.component.html\" path=\"router/src/app/admin/manage-crises/manage-crises.component.html\">\n&lt;p&gt;Manage your crises here&lt;/p&gt;\n\n</code-pane>\n\n  <code-pane header=\"src/app/admin/manage-heroes/manage-heroes.component.html\" path=\"router/src/app/admin/manage-heroes/manage-heroes.component.html\">\n&lt;p&gt;Manage your heroes here&lt;/p&gt;\n\n</code-pane>\n\n</code-tabs>\n\n<div class=\"alert is-helpful\">\n\nAlthough the admin dashboard `RouterLink` only contains a relative slash without an additional URL segment, it is a match to any route within the admin feature area.\nYou only want the `Dashboard` link to be active when the user visits that route.\nAdding an additional binding to the `Dashboard` routerLink,`[routerLinkActiveOptions]=\"{ exact: true }\"`, marks the `./` link as active when the user navigates to the `/admin` URL and not when navigating to any of the child routes.\n\n</div>\n-->\n<p>관리자 기능 모듈에서 라우팅은 <code>AdminComponent</code>가 담당하며, 이 컴포넌트에는 위기 목록과 히어로 목록을 관리하는 컴포넌트가 표시됩니다.</p>\n<code-tabs>\n\n  <code-pane header=\"src/app/admin/admin/admin.component.html\" path=\"router/src/app/admin/admin/admin.component.html\">\n&#x3C;h3>ADMIN&#x3C;/h3>\n&#x3C;nav>\n  &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"./\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\"\n    [routerLinkActiveOptions]=\"{ exact: true }\">Dashboard&#x3C;/a>\n  &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"./crises\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Manage Crises&#x3C;/a>\n  &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"./heroes\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Manage Heroes&#x3C;/a>\n&#x3C;/nav>\n&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n\n</code-pane>\n\n  <code-pane header=\"src/app/admin/admin-dashboard/admin-dashboard.component.html\" path=\"router/src/app/admin/admin-dashboard/admin-dashboard.component.1.html\">\n&#x3C;p>Dashboard&#x3C;/p>\n\n</code-pane>\n\n  <code-pane header=\"src/app/admin/admin.module.ts\" path=\"router/src/app/admin/admin.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> } from '@angular/common';\n\nimport { AdminComponent } from './admin/admin.component';\nimport { AdminDashboardComponent } from './admin-dashboard/admin-dashboard.component';\nimport { ManageCrisesComponent } from './manage-crises/manage-crises.component';\nimport { ManageHeroesComponent } from './manage-heroes/manage-heroes.component';\n\nimport { AdminRoutingModule } from './admin-routing.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>,\n    AdminRoutingModule\n  ],\n  declarations: [\n    AdminComponent,\n    AdminDashboardComponent,\n    ManageCrisesComponent,\n    ManageHeroesComponent\n  ]\n})\nexport class AdminModule {}\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/admin/manage-crises/manage-crises.component.html\" path=\"router/src/app/admin/manage-crises/manage-crises.component.html\">\n&#x3C;p>Manage your crises here&#x3C;/p>\n\n</code-pane>\n\n  <code-pane header=\"src/app/admin/manage-heroes/manage-heroes.component.html\" path=\"router/src/app/admin/manage-heroes/manage-heroes.component.html\">\n&#x3C;p>Manage your heroes here&#x3C;/p>\n\n</code-pane>\n\n</code-tabs>\n<div class=\"alert is-helpful\">\n<p>관리자 대시보드로 이동하는 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>에는 주소가 <code>./</code> 라고만 사용되었는데, 이 주소는 관리자 기능 모듈에 있는 모든 주소와 매칭됩니다.\n하지만 대시보드 링크는 현재 주소가 정확히 <code>./</code>과 매칭될 때만 하이라이트 되는 것을 의도했기 때문에 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 디렉티브에 <code>[routerLinkActiveOptions]=\"{ exact: true }\"</code> 바인딩을 추가했습니다.\n이렇게 구현하면 사용자가 <code>/admin</code> 주소로 접근했을 때만 대시보드 링크가 하이라이트 처리되며, 관리자 모듈 안에 있는 자식 라우팅 규칙에 접근했을 때는 대시보드 링크가 하이라이트되지 않습니다.</p>\n</div>\n<a id=\"component-less-route\"></a>\n<!--\n##### Component-less route: grouping routes without a component\n-->\n<h5 id=\"컴포넌트가-없는-라우팅-규칙-라우팅-규칙을-그룹으로-묶기\">컴포넌트가 없는 라우팅 규칙: 라우팅 규칙을 그룹으로 묶기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#컴포넌트가-없는-라우팅-규칙-라우팅-규칙을-그룹으로-묶기\"><i class=\"material-icons\">link</i></a></h5>\n<!--\nThe initial admin routing configuration:\n\n<code-example path=\"router/src/app/admin/admin-routing.module.1.ts\" header=\"src/app/admin/admin-routing.module.ts (admin routing)\" region=\"admin-routes\">\nconst adminRoutes: Routes = [\n  {\n    path: &#39;admin&#39;,\n    component: AdminComponent,\n    children: [\n      {\n        path: &#39;&#39;,\n        children: [\n          { path: &#39;crises&#39;, component: ManageCrisesComponent },\n          { path: &#39;heroes&#39;, component: ManageHeroesComponent },\n          { path: &#39;&#39;, component: AdminDashboardComponent }\n        ]\n      }\n    ]\n  }\n];\n\n@NgModule({\n  imports: [\n    RouterModule.forChild(adminRoutes)\n  ],\n  exports: [\n    RouterModule\n  ]\n})\nexport class AdminRoutingModule {}\n\n</code-example>\n\nThe child route under the `AdminComponent` has a `path` and a `children` property but it's not using a `component`.\nThis defines a _component-less_ route.\n\nTo group the `Crisis Center` management routes under the `admin` path a component is unnecessary.\nAdditionally, a _component-less_ route makes it easier to [guard child routes](#can-activate-child-guard).\n\nNext, import the `AdminModule` into `app.module.ts` and add it to the `imports` array\nto register the admin routes.\n\n<code-example path=\"router/src/app/app.module.4.ts\" header=\"src/app/app.module.ts (admin module)\" region=\"admin-module\">\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { CommonModule } from &#39;@angular/common&#39;;\nimport { FormsModule } from &#39;@angular/forms&#39;;\n\nimport { AppComponent } from &#39;./app.component&#39;;\nimport { PageNotFoundComponent } from &#39;./page-not-found/page-not-found.component&#39;;\nimport { ComposeMessageComponent } from &#39;./compose-message/compose-message.component&#39;;\n\nimport { AppRoutingModule } from &#39;./app-routing.module&#39;;\nimport { HeroesModule } from &#39;./heroes/heroes.module&#39;;\nimport { CrisisCenterModule } from &#39;./crisis-center/crisis-center.module&#39;;\n\nimport { AdminModule } from &#39;./admin/admin.module&#39;;\n\n@NgModule({\n  imports: [\n    CommonModule,\n    FormsModule,\n    HeroesModule,\n    CrisisCenterModule,\n    AdminModule,\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    ComposeMessageComponent,\n    PageNotFoundComponent\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n\n</code-example>\n\nAdd an \"Admin\" link to the `AppComponent` shell so that users can get to this feature.\n\n<code-example path=\"router/src/app/app.component.5.html\" header=\"src/app/app.component.html (template)\">\n&lt;h1 class=&quot;title&quot;&gt;Angular Router&lt;/h1&gt;\n&lt;nav&gt;\n  &lt;a routerLink=&quot;/crisis-center&quot; routerLinkActive=&quot;active&quot;&gt;Crisis Center&lt;/a&gt;\n  &lt;a routerLink=&quot;/heroes&quot; routerLinkActive=&quot;active&quot;&gt;Heroes&lt;/a&gt;\n  &lt;a routerLink=&quot;/admin&quot; routerLinkActive=&quot;active&quot;&gt;Admin&lt;/a&gt;\n  &lt;a [routerLink]=&quot;[{ outlets: { popup: [&#39;compose&#39;] } }]&quot;&gt;Contact&lt;/a&gt;\n&lt;/nav&gt;\n&lt;div [@routeAnimation]=&quot;getAnimationData(routerOutlet)&quot;&gt;\n  &lt;router-outlet #routerOutlet=&quot;outlet&quot;&gt;&lt;/router-outlet&gt;\n&lt;/div&gt;\n&lt;router-outlet name=&quot;popup&quot;&gt;&lt;/router-outlet&gt;\n\n</code-example>\n-->\n<p>관리자 모듈의 초기 라우팅 환경설정은 이렇습니다:</p>\n<code-example path=\"router/src/app/admin/admin-routing.module.1.ts\" header=\"src/app/admin/admin-routing.module.ts (관리자 모듈 라우팅 설정)\" region=\"admin-routes\">\nconst adminRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'admin',\n    component: AdminComponent,\n    children: [\n      {\n        path: '',\n        children: [\n          { path: 'crises', component: ManageCrisesComponent },\n          { path: 'heroes', component: ManageHeroesComponent },\n          { path: '', component: AdminDashboardComponent }\n        ]\n      }\n    ]\n  }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forChild(adminRoutes)\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class AdminRoutingModule {}\n\n</code-example>\n<p><code>AdminComponent</code> 안쪽에 있는 자식 라우팅 규칙은 <code>path</code> 프로퍼티와 <code>children</code> 프로퍼티가 있지만 <code>component</code> 프로퍼티는 없습니다.\n이런 라우팅 규칙을 <em>컴포넌트가 없는(component-less)</em> 라우팅 규칙이라고 합니다.</p>\n<p>위기대응센터를 관리하는 라우팅 규칙을 <code>admin</code> 경로 안으로 넣을 때 컴포넌트가 추가로 필요하지는 않습니다.\n<em>컴포넌트가 없는</em> 라우팅 규칙은 <a href=\"guide/router-tutorial-toh#can-activate-child-guard\">자식 라우팅 규칙에 적용하는 가드</a>를 좀 더 편하게 사용하기 위한 것입니다.</p>\n<p>이제 <code>app.module.ts</code> 파일에 <code>AdminModule</code>을 로드하고 관리자 라우팅 모듈을 <code>imports</code> 배열에 추가합니다.</p>\n<code-example path=\"router/src/app/app.module.4.ts\" header=\"src/app/app.module.ts (관리자 모듈 추가하기)\" region=\"admin-module\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> } from '@angular/common';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\n\nimport { AppComponent } from './app.component';\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\nimport { ComposeMessageComponent } from './compose-message/compose-message.component';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { HeroesModule } from './heroes/heroes.module';\nimport { CrisisCenterModule } from './crisis-center/crisis-center.module';\n\nimport { AdminModule } from './admin/admin.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    HeroesModule,\n    CrisisCenterModule,\n    AdminModule,\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    ComposeMessageComponent,\n    PageNotFoundComponent\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n\n</code-example>\n<p>그리고 사용자가 관리자 모듈로 이동할 수 있도록 <code>AppComponent</code> 템플릿에 \"Admin\" 링크를 추가합니다.</p>\n<code-example path=\"router/src/app/app.component.5.html\" header=\"src/app/app.component.html (템플릿)\">\n&#x3C;h1 class=\"title\">Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>&#x3C;/h1>\n&#x3C;nav>\n  &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/crisis-center\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Crisis Center&#x3C;/a>\n  &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/heroes\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Heroes&#x3C;/a>\n  &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/admin\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Admin&#x3C;/a>\n  &#x3C;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"[{ outlets: { popup: ['compose'] } }]\">Contact&#x3C;/a>\n&#x3C;/nav>\n&#x3C;div [@routeAnimation]=\"getAnimationData(routerOutlet)\">\n  &#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a> #routerOutlet=\"outlet\">&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n&#x3C;/div>\n&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a> name=\"popup\">&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n\n</code-example>\n<a id=\"guard-admin-feature\"></a>\n<!--\n#### Guard the admin feature\n-->\n<h4 id=\"관리자-모듈-사용-제한하기\">관리자 모듈 사용 제한하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#관리자-모듈-사용-제한하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nCurrently, every route within the Crisis Center is open to everyone.\nThe new admin feature should be accessible only to authenticated users.\n\nWrite a `canActivate()` guard method to redirect anonymous users to the\nlogin page when they try to enter the admin area.\n\nGenerate an `AuthGuard` in the `auth` folder.\n\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate guard auth/auth\n</code-example>\n\nTo demonstrate the fundamentals, this example only logs to the console, `returns` true immediately, and allows navigation to proceed:\n\n<code-example path=\"router/src/app/auth/auth.guard.1.ts\" header=\"src/app/auth/auth.guard.ts (excerpt)\">\nimport { Injectable } from &#39;@angular/core&#39;;\nimport { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot } from &#39;@angular/router&#39;;\n\n@Injectable({\n  providedIn: &#39;root&#39;,\n})\nexport class AuthGuard implements CanActivate {\n  canActivate(\n    next: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot): boolean {\n    console.log(&#39;AuthGuard#canActivate called&#39;);\n    return true;\n  }\n}\n\n\n</code-example>\n\nNext, open `admin-routing.module.ts `, import the `AuthGuard` class, and\nupdate the admin route with a `canActivate` guard property that references it:\n\n<code-example path=\"router/src/app/admin/admin-routing.module.2.ts\" header=\"src/app/admin/admin-routing.module.ts (guarded admin route)\" region=\"admin-route\">\nimport { AuthGuard } from &#39;../auth/auth.guard&#39;;\n\nconst adminRoutes: Routes = [\n  {\n    path: &#39;admin&#39;,\n    component: AdminComponent,\n    canActivate: [AuthGuard],\n    children: [\n      {\n        path: &#39;&#39;,\n        children: [\n          { path: &#39;crises&#39;, component: ManageCrisesComponent },\n          { path: &#39;heroes&#39;, component: ManageHeroesComponent },\n          { path: &#39;&#39;, component: AdminDashboardComponent }\n        ],\n      }\n    ]\n  }\n];\n\n@NgModule({\n  imports: [\n    RouterModule.forChild(adminRoutes)\n  ],\n  exports: [\n    RouterModule\n  ]\n})\nexport class AdminRoutingModule {}\n\n</code-example>\n\nThe admin feature is now protected by the guard, but the guard requires more customization to work fully.\n-->\n<p>아직까지는 모든 사용자가 위기대응센터로 이동하는 라우팅 규칙을 사용할 수 있습니다.\n새로 만든 관리자 기능에는 일부 사용자만 접근할 수 있도록 만들어 봅시다.</p>\n<p>먼저 로그인하지 않은 사용자가 관리자 모듈로 접근하면 로그인 화면으로 리다이렉션하는 <code>canActivate()</code> 가드 메서드를 구현해 봅시다.</p>\n<p>다음 명령을 실행해서 <code>auth</code> 폴더에 <code>AuthGuard</code>를 생성합니다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate guard auth/auth\n</code-example>\n<p>이 문서에서는 가드가 동작하는 개념을 설명하기 위해 콘솔에 로그를 하나 출력하고 <code>true</code>를 즉시 반환합니다.\n라우팅 가드가 <code>true</code>를 반환했기 때문에 네비게이션 동작은 그대로 진행됩니다:</p>\n<code-example path=\"router/src/app/auth/auth.guard.1.ts\" header=\"src/app/auth/auth.guard.ts (일부)\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { <a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a>, <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>, <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a> } from '@angular/router';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class AuthGuard implements <a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a> {\n  canActivate(\n    next: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>,\n    <a href=\"api/animations/state\" class=\"code-anchor\">state</a>: <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>): boolean {\n    console.log('AuthGuard#canActivate called');\n    return true;\n  }\n}\n\n\n</code-example>\n<p>그 다음에는 <code>admin-routing.module.ts</code> 파일을 열고 <code>AuthGuard</code> 클래스를 로드한 후에 <code>admin</code>에 해당하는 라우팅 규칙에 <code>canActivate</code> 가드 프로퍼티를 다음과 같이 연결합니다:</p>\n<code-example path=\"router/src/app/admin/admin-routing.module.2.ts\" header=\"src/app/admin/admin-routing.module.ts (관리자용 라우팅 규칙 제한하기)\" region=\"admin-route\">\nimport { AuthGuard } from '../auth/auth.guard';\n\nconst adminRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'admin',\n    component: AdminComponent,\n    canActivate: [AuthGuard],\n    children: [\n      {\n        path: '',\n        children: [\n          { path: 'crises', component: ManageCrisesComponent },\n          { path: 'heroes', component: ManageHeroesComponent },\n          { path: '', component: AdminDashboardComponent }\n        ],\n      }\n    ]\n  }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forChild(adminRoutes)\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class AdminRoutingModule {}\n\n</code-example>\n<p>이제 관리자 모듈은 라우팅 가드로 보호됩니다.\n하지만 이 가드가 제대로 동작하려면 작업을 좀 더 해야 합니다.</p>\n<a id=\"teach-auth\"></a>\n<!--\n#### Authenticate with `AuthGuard`\n-->\n<h4 id=\"authguard에-인증기능-넣기\"><code>AuthGuard</code>에 인증기능 넣기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#authguard에-인증기능-넣기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nMake the `AuthGuard` mimic authentication.\n\nThe `AuthGuard` should call an application service that can login a user and retain information about the current user. Generate a new `AuthService` in the `auth` folder:\n\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate service auth/auth\n</code-example>\n\nUpdate the `AuthService` to log in the user:\n\n<code-example path=\"router/src/app/auth/auth.service.ts\" header=\"src/app/auth/auth.service.ts (excerpt)\">\nimport { Injectable } from &#39;@angular/core&#39;;\n\nimport { Observable, of } from &#39;rxjs&#39;;\nimport { tap, delay } from &#39;rxjs/operators&#39;;\n\n@Injectable({\n  providedIn: &#39;root&#39;,\n})\nexport class AuthService {\n  isLoggedIn = false;\n\n  // 사용자가 로그인한 후에 이동할 URL을 저장합니다.\n  redirectUrl: string;\n\n  login(): Observable&lt;boolean&gt; {\n    return of(true).pipe(\n      delay(1000),\n      tap(val =&gt; this.isLoggedIn = true)\n    );\n  }\n\n  logout(): void {\n    this.isLoggedIn = false;\n  }\n}\n\n\n</code-example>\n\nAlthough it doesn't actually log in, it has an `isLoggedIn` flag to tell you whether the user is authenticated.\nIts `login()` method simulates an API call to an external service by returning an observable that resolves successfully after a short pause.\nThe `redirectUrl` property stores the URL that the user wanted to access so you can navigate to it after authentication.\n\n<div class=\"alert is-helpful\">\n\nTo keep things minimal, this example redirects unauthenticated users to `/admin`.\n\n</div>\n\nRevise the `AuthGuard` to call the `AuthService`.\n\n<code-example path=\"router/src/app/auth/auth.guard.2.ts\" header=\"src/app/auth/auth.guard.ts (v2)\">\nimport { Injectable } from &#39;@angular/core&#39;;\nimport { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, Router, UrlTree } from &#39;@angular/router&#39;;\n\nimport { AuthService } from &#39;./auth.service&#39;;\n\n@Injectable({\n  providedIn: &#39;root&#39;,\n})\nexport class AuthGuard implements CanActivate {\n  constructor(private authService: AuthService, private router: Router) {}\n\n  canActivate(\n    next: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot): true|UrlTree {\n    const url: string = state.url;\n\n    return this.checkLogin(url);\n  }\n\n  checkLogin(url: string): true|UrlTree {\n    if (this.authService.isLoggedIn) { return true; }\n\n    // 로그인한 후 리다이렉트할 수 있도록 URL을 저장합니다.\n    this.authService.redirectUrl = url;\n\n    // 로그인하지 않았기 때문에 로그인 페이지로 이동합니다.\n    return this.router.parseUrl(&#39;/login&#39;);\n  }\n}\n\n</code-example>\n\nNotice that you inject the `AuthService` and the `Router` in the constructor.\nYou haven't provided the `AuthService` yet but it's good to know that you can inject helpful services into routing guards.\n\nThis guard returns a synchronous boolean result.\nIf the user is logged in, it returns true and the navigation continues.\n\nThe `ActivatedRouteSnapshot` contains the _future_ route that will be activated and the `RouterStateSnapshot` contains the _future_ `RouterState` of the application, should you pass through the guard check.\n\nIf the user is not logged in, you store the attempted URL the user came from using the `RouterStateSnapshot.url` and tell the router to redirect to a login page&mdash;a page you haven't created yet.\nReturning a `UrlTree` tells the `Router` to cancel the current navigation and schedule a new one to redirect the user.\n-->\n<p><code>AuthGuard</code>에 인증 기능을 임시로 구현해 봅시다.</p>\n<p><code>AuthGuard</code>는 애플리케이션 서비스를 활용해서 사용자를 로그인시키고 로그인 한 사용자의 정보를 받아옵니다.\n다음 명령을 실행해서 <code>auth</code> 폴더에 <code>AuthService</code>를 생성합니다:</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate service auth/auth\n</code-example>\n<p>그리고 <code>AuthService</code>에 로그인 기능을 추가합니다:</p>\n<code-example path=\"router/src/app/auth/auth.service.ts\" header=\"src/app/auth/auth.service.ts (일부)\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\nimport { Observable, of } from 'rxjs';\nimport { tap, delay } from 'rxjs/operators';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class AuthService {\n  isLoggedIn = false;\n\n  // 사용자가 로그인한 후에 이동할 URL을 저장합니다.\n  redirectUrl: string;\n\n  login(): Observable&#x3C;boolean> {\n    return of(true).pipe(\n      delay(1000),\n      tap(val => this.isLoggedIn = true)\n    );\n  }\n\n  logout(): void {\n    this.isLoggedIn = false;\n  }\n}\n\n\n</code-example>\n<p>이 코드가 실제로 로그인을 하는 것은 아니기 때문에 사용자가 로그인했는지는 <code>isLoggedIn</code> 플래그로 판단합니다.\n그리고 <code>login()</code> 메서드는 API가 실행된 것을 흉내내기 위해 옵저버블을 사용해서 약간 시연을 지연한 후에 결과를 반환합니다.\n<code>redirectUrl</code> 프로퍼티는 사용자가 로그인한 후에 이동할 URL을 잠시 보관하는 프로퍼티입니다.</p>\n<div class=\"alert is-helpful\">\n<p>코드를 간단하게 작성하기 위해 이 예제에서는 로그인한 사용자를 <code>/admin</code>으로 리다이렉션합니다.</p>\n</div>\n<p><code>AuthGuard</code>가 <code>AuthService</code>를 사용하도록 수정해 봅시다.</p>\n<code-example path=\"router/src/app/auth/auth.guard.2.ts\" header=\"src/app/auth/auth.guard.ts (v2)\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { <a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a>, <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>, <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>, <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>, <a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a> } from '@angular/router';\n\nimport { AuthService } from './auth.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class AuthGuard implements <a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a> {\n  constructor(private authService: AuthService, private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {}\n\n  canActivate(\n    next: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>,\n    <a href=\"api/animations/state\" class=\"code-anchor\">state</a>: <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>): true|<a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a> {\n    const url: string = state.url;\n\n    return this.checkLogin(url);\n  }\n\n  checkLogin(url: string): true|<a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a> {\n    if (this.authService.isLoggedIn) { return true; }\n\n    // 로그인한 후 리다이렉트할 수 있도록 URL을 저장합니다.\n    this.authService.redirectUrl = url;\n\n    // 로그인하지 않았기 때문에 로그인 페이지로 이동합니다.\n    return this.router.parseUrl('/login');\n  }\n}\n\n</code-example>\n<p><code>AuthGuard</code>에는 <code>AuthService</code>와 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>가 의존성 객체로 주입됩니다.\n라우팅 가드에 필요하다면 다른 서비스도 의존성으로 주입해서 활용할 수 있습니다.</p>\n<p>이 라우팅 가드는 불리언 결과값을 즉시 반환합니다.\n사용자가 로그인한 상태라면 <code>true</code>를 반환하고 네비게이션 동작도 계속 진행될 것입니다.</p>\n<p><code><a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a></code>에서는 <em>앞으로 적용될</em> 라우팅 규칙에 대한 정보를 참조할 수 있으며, <code><a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a></code>에서는 <em>앞으로 적용될</em> 애플리케이션의 <code><a href=\"api/router/RouterState\" class=\"code-anchor\">RouterState</a></code> 정보를 참조할 수 있기 때문에, 라우팅 가드 로직에 필요하다면 이 객체들을 활용하는 것도 좋습니다.</p>\n<p>그리고 사용자가 로그인하지 않은 상태라면 이동하려는 주소를 <code>AuthService.redirectUrl</code> 프로퍼티에 저장한 후에 로그인 페이지로 리다이렉션합니다—이 화면은 아직 만들지 않았습니다.\n라우팅 가드가 <code><a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a></code>를 반환하면 라우터는 현재 진행되고 있는 네비게이션 동작을 취소하고 반환하는 <code><a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a></code>로 사용자를 리다이렉션합니다.</p>\n<a id=\"add-login-component\"></a>\n<!--\n#### Add the `LoginComponent`\n-->\n<h4 id=\"logincomponent-추가하기\"><code>LoginComponent</code> 추가하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#logincomponent-추가하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nYou need a `LoginComponent` for the user to log in to the app. After logging in, you'll redirect to the stored URL if available, or use the default URL.\nThere is nothing new about this component or the way you use it in the router configuration.\n\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component auth/login\n</code-example>\n\nRegister a `/login` route in the `auth/auth-routing.module.ts`.\nIn `app.module.ts`, import and add the `AuthModule` to the `AppModule` imports.\n\n\n<code-tabs>\n\n  <code-pane header=\"src/app/app.module.ts\" path=\"router/src/app/app.module.ts\" region=\"auth\">\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { BrowserModule } from &#39;@angular/platform-browser&#39;;\nimport { FormsModule } from &#39;@angular/forms&#39;;\nimport { BrowserAnimationsModule } from &#39;@angular/platform-browser/animations&#39;;\n\nimport { AppComponent } from &#39;./app.component&#39;;\nimport { PageNotFoundComponent } from &#39;./page-not-found/page-not-found.component&#39;;\nimport { ComposeMessageComponent } from &#39;./compose-message/compose-message.component&#39;;\n\nimport { AppRoutingModule } from &#39;./app-routing.module&#39;;\nimport { HeroesModule } from &#39;./heroes/heroes.module&#39;;\nimport { AuthModule } from &#39;./auth/auth.module&#39;;\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    BrowserAnimationsModule,\n    FormsModule,\n    HeroesModule,\n    AuthModule,\n    AppRoutingModule,\n  ],\n  declarations: [\n    AppComponent,\n    ComposeMessageComponent,\n    PageNotFoundComponent\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule {\n}\n\n</code-pane>\n\n  <code-pane header=\"src/app/auth/login/login.component.html\" path=\"router/src/app/auth/login/login.component.html\">\n&lt;h2&gt;LOGIN&lt;/h2&gt;\n&lt;p&gt;{{message}}&lt;/p&gt;\n&lt;p&gt;\n  &lt;button (click)=&quot;login()&quot;  *ngIf=&quot;!authService.isLoggedIn&quot;&gt;Login&lt;/button&gt;\n  &lt;button (click)=&quot;logout()&quot; *ngIf=&quot;authService.isLoggedIn&quot;&gt;Logout&lt;/button&gt;\n&lt;/p&gt;\n\n</code-pane>\n\n  <code-pane header=\"src/app/auth/login/login.component.ts\" path=\"router/src/app/auth/login/login.component.1.ts\">\nimport { Component } from &#39;@angular/core&#39;;\nimport { Router } from &#39;@angular/router&#39;;\nimport { AuthService } from &#39;../auth.service&#39;;\n\n@Component({\n  selector: &#39;app-login&#39;,\n  templateUrl: &#39;./login.component.html&#39;,\n  styleUrls: [&#39;./login.component.css&#39;]\n})\nexport class LoginComponent {\n  message: string;\n\n  constructor(public authService: AuthService, public router: Router) {\n    this.setMessage();\n  }\n\n  setMessage() {\n    this.message = &#39;Logged &#39; + (this.authService.isLoggedIn ? &#39;in&#39; : &#39;out&#39;);\n  }\n\n  login() {\n    this.message = &#39;Trying to log in ...&#39;;\n\n    this.authService.login().subscribe(() =&gt; {\n      this.setMessage();\n      if (this.authService.isLoggedIn) {\n        // 보통은 AuthService에서 리다이렉트할 URL을 가져옵니다.\n        // 하지만 예제를 간단하게 구성하기 위해 `/admin`으로 리다이렉트 합시다.\n        const redirectUrl = &#39;/admin&#39;;\n\n        // 최종 주소로 이동합니다.\n        this.router.navigate([redirectUrl]);\n      }\n    });\n  }\n\n  logout() {\n    this.authService.logout();\n    this.setMessage();\n  }\n}\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/auth/auth.module.ts\" path=\"router/src/app/auth/auth.module.ts\">\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { CommonModule } from &#39;@angular/common&#39;;\nimport { FormsModule } from &#39;@angular/forms&#39;;\n\nimport { LoginComponent } from &#39;./login/login.component&#39;;\nimport { AuthRoutingModule } from &#39;./auth-routing.module&#39;;\n\n@NgModule({\n  imports: [\n    CommonModule,\n    FormsModule,\n    AuthRoutingModule\n  ],\n  declarations: [\n    LoginComponent\n  ]\n})\nexport class AuthModule {}\n\n</code-pane>\n\n</code-tabs>\n-->\n<p>사용자가 로그인하려면 <code>LoginComponent</code>가 필요합니다.\n이 컴포넌트는 사용자가 로그인한 후에 저장된 URL로 이동하거나 기본 주소로 리다이렉션하면 됩니다.\n컴포넌트를 새로 만들고 라우터 환경설정에 추가하는 방법은 이전과 같습니다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate component auth/login\n</code-example>\n<p><code>/login</code> 라우팅 규칙은 <code>auth/auth-routing.module.ts</code>에 등록합니다.\n그리고 <code>app.module.ts</code> 파일에 <code>AuthModule</code>을 로드하면 됩니다.</p>\n<code-tabs>\n\n  <code-pane header=\"src/app/app.module.ts\" path=\"router/src/app/app.module.ts\" region=\"auth\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { <a href=\"api/platform-browser/animations/BrowserAnimationsModule\" class=\"code-anchor\">BrowserAnimationsModule</a> } from '@angular/platform-browser/animations';\n\nimport { AppComponent } from './app.component';\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\nimport { ComposeMessageComponent } from './compose-message/compose-message.component';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { HeroesModule } from './heroes/heroes.module';\nimport { AuthModule } from './auth/auth.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/platform-browser/animations/BrowserAnimationsModule\" class=\"code-anchor\">BrowserAnimationsModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    HeroesModule,\n    AuthModule,\n    AppRoutingModule,\n  ],\n  declarations: [\n    AppComponent,\n    ComposeMessageComponent,\n    PageNotFoundComponent\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule {\n}\n\n</code-pane>\n\n  <code-pane header=\"src/app/auth/login/login.component.html\" path=\"router/src/app/auth/login/login.component.html\">\n&#x3C;h2>LOGIN&#x3C;/h2>\n&#x3C;p>{{message}}&#x3C;/p>\n&#x3C;p>\n  &#x3C;button (click)=\"login()\"  *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"!authService.isLoggedIn\">Login&#x3C;/button>\n  &#x3C;button (click)=\"logout()\" *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"authService.isLoggedIn\">Logout&#x3C;/button>\n&#x3C;/p>\n\n</code-pane>\n\n  <code-pane header=\"src/app/auth/login/login.component.ts\" path=\"router/src/app/auth/login/login.component.1.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { <a href=\"api/router/Router\" class=\"code-anchor\">Router</a> } from '@angular/router';\nimport { AuthService } from '../auth.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-login',\n  templateUrl: './login.component.html',\n  styleUrls: ['./login.component.css']\n})\nexport class LoginComponent {\n  message: string;\n\n  constructor(public authService: AuthService, public router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {\n    this.setMessage();\n  }\n\n  setMessage() {\n    this.message = 'Logged ' + (this.authService.isLoggedIn ? 'in' : 'out');\n  }\n\n  login() {\n    this.message = 'Trying to log in ...';\n\n    this.authService.login().subscribe(() => {\n      this.setMessage();\n      if (this.authService.isLoggedIn) {\n        // 보통은 AuthService에서 리다이렉트할 URL을 가져옵니다.\n        // 하지만 예제를 간단하게 구성하기 위해 `/admin`으로 리다이렉트 합시다.\n        const redirectUrl = '/admin';\n\n        // 최종 주소로 이동합니다.\n        this.router.navigate([redirectUrl]);\n      }\n    });\n  }\n\n  logout() {\n    this.authService.logout();\n    this.setMessage();\n  }\n}\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/auth/auth.module.ts\" path=\"router/src/app/auth/auth.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> } from '@angular/common';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\n\nimport { LoginComponent } from './login/login.component';\nimport { AuthRoutingModule } from './auth-routing.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    AuthRoutingModule\n  ],\n  declarations: [\n    LoginComponent\n  ]\n})\nexport class AuthModule {}\n\n</code-pane>\n\n</code-tabs>\n<a id=\"can-activate-child-guard\"></a>\n<!--\n### `CanActivateChild`: guarding child routes\n-->\n<h3 id=\"canactivatechild-자식-라우팅-규칙-제한하기\"><code><a href=\"api/router/CanActivateChild\" class=\"code-anchor\">CanActivateChild</a></code>: 자식 라우팅 규칙 제한하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#canactivatechild-자식-라우팅-규칙-제한하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou can also protect child routes with the `CanActivateChild` guard.\nThe `CanActivateChild` guard is similar to the `CanActivate` guard.\nThe key difference is that it runs before any child route is activated.\n\nYou protected the admin feature module from unauthorized access.\nYou should also protect child routes _within_ the feature module.\n\nExtend the `AuthGuard` to protect when navigating between the `admin` routes.\nOpen `auth.guard.ts` and add the `CanActivateChild` interface to the imported tokens from the router package.\n\nNext, implement the `canActivateChild()` method which takes the same arguments as the `canActivate()` method: an `ActivatedRouteSnapshot` and `RouterStateSnapshot`.\nThe `canActivateChild()` method can return an `Observable<boolean|UrlTree>` or `Promise<boolean|UrlTree>` for async checks and a `boolean` or `UrlTree` for sync checks.\nThis one returns either `true` to allow the user to access the admin feature module or `UrlTree` to redirect the user to the login page instead:\n\n<code-example path=\"router/src/app/auth/auth.guard.3.ts\" header=\"src/app/auth/auth.guard.ts (excerpt)\" region=\"can-activate-child\">\nimport { Injectable } from &#39;@angular/core&#39;;\nimport {\n  CanActivate, Router,\n  ActivatedRouteSnapshot,\n  RouterStateSnapshot,\n  CanActivateChild,\n  UrlTree\n} from &#39;@angular/router&#39;;\nimport { AuthService } from &#39;./auth.service&#39;;\n\n@Injectable({\n  providedIn: &#39;root&#39;,\n})\nexport class AuthGuard implements CanActivate, CanActivateChild {\n  constructor(private authService: AuthService, private router: Router) {}\n\n  canActivate(\n    route: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot): true|UrlTree {\n    const url: string = state.url;\n\n    return this.checkLogin(url);\n  }\n\n  canActivateChild(\n    route: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot): true|UrlTree {\n    return this.canActivate(route, state);\n  }\n\n/* . . . */\n}\n\n</code-example>\n\nAdd the same `AuthGuard` to the `component-less` admin route to protect all other child routes at one time\ninstead of adding the `AuthGuard` to each route individually.\n\n<code-example path=\"router/src/app/admin/admin-routing.module.3.ts\" header=\"src/app/admin/admin-routing.module.ts (excerpt)\" region=\"can-activate-child\">\nconst adminRoutes: Routes = [\n  {\n    path: &#39;admin&#39;,\n    component: AdminComponent,\n    canActivate: [AuthGuard],\n    children: [\n      {\n        path: &#39;&#39;,\n        canActivateChild: [AuthGuard],\n        children: [\n          { path: &#39;crises&#39;, component: ManageCrisesComponent },\n          { path: &#39;heroes&#39;, component: ManageHeroesComponent },\n          { path: &#39;&#39;, component: AdminDashboardComponent }\n        ]\n      }\n    ]\n  }\n];\n\n@NgModule({\n  imports: [\n    RouterModule.forChild(adminRoutes)\n  ],\n  exports: [\n    RouterModule\n  ]\n})\nexport class AdminRoutingModule {}\n\n</code-example>\n-->\n<p>자식 라우팅 규칙은 <code><a href=\"api/router/CanActivateChild\" class=\"code-anchor\">CanActivateChild</a></code> 가드로 보호할 수 있습니다.\n<code><a href=\"api/router/CanActivateChild\" class=\"code-anchor\">CanActivateChild</a></code> 가드는 <code><a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a></code> 가드와 비슷합니다.\n라우팅 규칙이 아니라 자식 라우팅 규칙이 활성화되기 실행된다는 점만 다릅니다.</p>\n<p>관리자 모듈은 이제 로그인하지 않은 사용자가 접근할 수 없도록 보호처리 되었습니다.\n기능 모듈 사용을 이렇게 제한하면 <em>그 안에 있는</em> 자식 라우팅 규칙도 함께 제한해야 합니다.</p>\n<p><code>AuthGuard</code>를 수정해서 <code>admin</code> 라우팅 규칙 안에서 발생하는 네비게이션을 제한해 봅시다.\n<code>auth.guard.ts</code> 파일을 열고 <code>CanActivatedChild</code> 인터페이스를 불러옵니다.</p>\n<p>그 다음에는 <code>canActivate()</code> 메서드와 같은 인자 형식으로 <code>canActivateChild()</code> 메서드를 선언합니다.\n인자는 <code><a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a></code>과 <code><a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a></code> 입니다.\n<code>canActivateChild()</code> 메서드도 <code>Observable&#x3C;boolean|<a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a>></code>나 <code>Promise&#x3C;boolean|<a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a>></code>를 비동기로 반환할 수 있으며, <code>boolean</code> 타임이나 <code><a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a></code> 객체를 동기 방식으로 반환할 수도 있습니다.\n어떤 방식이던지 <code>true</code>를 반환하면 진행 중인 네비게이션 동작을 계속 진행하며, <code><a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a></code>를 반환하면 로그인 페이지로 이동합니다:</p>\n<code-example path=\"router/src/app/auth/auth.guard.3.ts\" header=\"src/app/auth/auth.guard.ts (일부)\" region=\"can-activate-child\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport {\n  <a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a>, <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,\n  <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>,\n  <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>,\n  <a href=\"api/router/CanActivateChild\" class=\"code-anchor\">CanActivateChild</a>,\n  <a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a>\n} from '@angular/router';\nimport { AuthService } from './auth.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class AuthGuard implements <a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a>, <a href=\"api/router/CanActivateChild\" class=\"code-anchor\">CanActivateChild</a> {\n  constructor(private authService: AuthService, private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {}\n\n  canActivate(\n    route: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>,\n    <a href=\"api/animations/state\" class=\"code-anchor\">state</a>: <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>): true|<a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a> {\n    const url: string = state.url;\n\n    return this.checkLogin(url);\n  }\n\n  canActivateChild(\n    route: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>,\n    <a href=\"api/animations/state\" class=\"code-anchor\">state</a>: <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>): true|<a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a> {\n    return this.canActivate(route, <a href=\"api/animations/state\" class=\"code-anchor\">state</a>);\n  }\n\n/* . . . */\n}\n\n</code-example>\n<p>이제 <code>AuthGuard</code>는 개별 라우팅 규칙에 지정하지 않고 그 상위 계층에 추가해도 자식 라우팅 규칙을 모두 보호할 수 있습니다.</p>\n<code-example path=\"router/src/app/admin/admin-routing.module.3.ts\" header=\"src/app/admin/admin-routing.module.ts (일부)\" region=\"can-activate-child\">\nconst adminRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'admin',\n    component: AdminComponent,\n    canActivate: [AuthGuard],\n    children: [\n      {\n        path: '',\n        canActivateChild: [AuthGuard],\n        children: [\n          { path: 'crises', component: ManageCrisesComponent },\n          { path: 'heroes', component: ManageHeroesComponent },\n          { path: '', component: AdminDashboardComponent }\n        ]\n      }\n    ]\n  }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forChild(adminRoutes)\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class AdminRoutingModule {}\n\n</code-example>\n<a id=\"can-deactivate-guard\"></a>\n<!--\n### `CanDeactivate`: handling unsaved changes\n-->\n<h3 id=\"candeactivate-저장하지-않은-변경사항을-처리할-때\"><code><a href=\"api/router/CanDeactivate\" class=\"code-anchor\">CanDeactivate</a></code>: 저장하지 않은 변경사항을 처리할 때<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#candeactivate-저장하지-않은-변경사항을-처리할-때\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nBack in the \"Heroes\" workflow, the app accepts every change to a hero immediately without validation.\n\nIn the real world, you might have to accumulate the users changes, validate across fields, validate on the server, or hold changes in a pending state until the user confirms them as a group or cancels and reverts all changes.\n\nWhen the user navigates away, you can let the user decide what to do with unsaved changes.\nIf the user cancels, you'll stay put and allow more changes.\nIf the user approves, the app can save.\n\nYou still might delay navigation until the save succeeds.\nIf you let the user move to the next screen immediately and saving were to fail (perhaps the data is ruled invalid), you would lose the context of the error.\n\nYou need to stop the navigation while you wait, asynchronously, for the server to return with its answer.\n\nThe `CanDeactivate` guard helps you decide what to do with unsaved changes and how to proceed.\n-->\n<p>히어로 목록으로 돌아가는 과정을 보면 예재 앱에서 히어로의 정보를 수정하면 이 내용이 즉시 반영됩니다.</p>\n<p>하지만 실제로 운영되는 앱이라면 사용자가 변경한 내용은 한번에 모았다가 각 필드값의 유효성을 검사해야 하고, 서버에서도 검사해야 합니다.\n아니면 사용자가 데이터를 한 번에 처리할 것인지, 한번에 취소할 것인지, 실행한 내용을 되돌릴지 결정할때까지 변경사항을 임시로 들고있어야 할 수도 있습니다.</p>\n<p>그래서 사용자가 현재 화면을 벗어난다면, 저장하지 않은 변경사항을 어떻게 처리할지 사용자에게 물어볼 수 있습니다.\n이 때 사용자가 결정하는 것에 따라 화면을 벗어나지 않고 수정을 계속하거나, 저장하고 넘어갈 수도 있습니다.</p>\n<p>그리고 변경사항을 저장하는 경우에는 저장이 끝날때까지 화면 전환 동작을 잠시 멈춰야 할 수도 있습니다.\n저장이 되었는지 확인하지 않고 바로 다음 화면으로 넘어가면 데이터에 문제가 있어서 저장이 실패하더라도 이 에러를 처리하기 어렵습니다.</p>\n<p>그래서 화면을 전환하기 전에 잠시 기다렸다가, 서버가 응답을 보냈을 때 비동기로 화면을 전환하는 방식이 더 안전합니다.</p>\n<p>저장하지 않은 변경사항을 어떻게 처리할지 확인받거나 이후 동작을 처리하려면 <code><a href=\"api/router/CanDeactivate\" class=\"code-anchor\">CanDeactivate</a></code> 가드를 사용하면 됩니다.</p>\n<a id=\"cancel-save\"></a>\n<!--\n#### Cancel and save\n-->\n<h4 id=\"취소하거나-저장하기\">취소하거나 저장하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#취소하거나-저장하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nUsers update crisis information in the `CrisisDetailComponent`.\nUnlike the `HeroDetailComponent`, the user changes do not update the crisis entity immediately.\nInstead, the app updates the entity when the user presses the Save button and discards the changes when the user presses the Cancel button.\n\nBoth buttons navigate back to the crisis list after save or cancel.\n\n<code-example path=\"router/src/app/crisis-center/crisis-detail/crisis-detail.component.ts\" header=\"src/app/crisis-center/crisis-detail/crisis-detail.component.ts (cancel and save methods)\" region=\"cancel-save\">\ncancel() {\n  this.gotoCrises();\n}\n\nsave() {\n  this.crisis.name = this.editName;\n  this.gotoCrises();\n}\n\n</code-example>\n\nIn this scenario, the user could click the heroes link, cancel, push the browser back button, or navigate away without saving.\n\nThis example app asks the user to be explicit with a confirmation dialog box that waits asynchronously for the user's\nresponse.\n\n<div class=\"alert is-helpful\">\n\nYou could wait for the user's answer with synchronous, blocking code, however, the app is more responsive&mdash;and can do other work&mdash;by waiting for the user's answer asynchronously.\n\n</div>\n\nGenerate a `Dialog` service to handle user confirmation.\n\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate service dialog\n</code-example>\n\nAdd a `confirm()` method to the `DialogService` to prompt the user to confirm their intent.\nThe `window.confirm` is a blocking action that displays a modal dialog and waits for user interaction.\n\n<code-example path=\"router/src/app/dialog.service.ts\" header=\"src/app/dialog.service.ts\">\nimport { Injectable } from &#39;@angular/core&#39;;\nimport { Observable, of } from &#39;rxjs&#39;;\n\n/**\n * 비동기 모달 팝업 서비스\n * DialogService는 예제를 확인하기 위해 간단하게 구현한 서비스입니다.\n * TODO: window.confirm을 사용하지 않는 방식이 더 좋습니다.\n */\n@Injectable({\n  providedIn: &#39;root&#39;,\n})\nexport class DialogService {\n  /**\n   * 어떤 행동을 할지 사용자에게 물어봅니다. `message`는 사용자에게 안내할 문구입니다.\n   * `true`를 반환하면 사용자가 확정한 것으로 처리하고, `false`를 반환하면 취소한 것으로 처리합니다.\n   * 결과는 Observable 타입으로 반환합니다.\n   */\n  confirm(message?: string): Observable&lt;boolean&gt; {\n    const confirmation = window.confirm(message || &#39;Is it OK?&#39;);\n\n    return of(confirmation);\n  }\n}\n\n\n</code-example>\n\nIt returns an `Observable` that resolves when the user eventually decides what to do: either to discard changes and navigate away (`true`) or to preserve the pending changes and stay in the crisis editor (`false`).\n\n<a id=\"CanDeactivate\"></a>\n\nGenerate a guard that checks for the presence of a `canDeactivate()` method in a component&mdash;any component.\n\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate guard can-deactivate\n</code-example>\n\nPaste the following code into your guard.\n\n<code-example path=\"router/src/app/can-deactivate.guard.ts\" header=\"src/app/can-deactivate.guard.ts\">\nimport { Injectable } from &#39;@angular/core&#39;;\nimport { CanDeactivate } from &#39;@angular/router&#39;;\nimport { Observable } from &#39;rxjs&#39;;\n\nexport interface CanComponentDeactivate {\n canDeactivate: () =&gt; Observable&lt;boolean&gt; | Promise&lt;boolean&gt; | boolean;\n}\n\n@Injectable({\n  providedIn: &#39;root&#39;,\n})\nexport class CanDeactivateGuard implements CanDeactivate&lt;CanComponentDeactivate&gt; {\n  canDeactivate(component: CanComponentDeactivate) {\n    return component.canDeactivate ? component.canDeactivate() : true;\n  }\n}\n\n\n</code-example>\n\nWhile the guard doesn't have to know which component has a deactivate method, it can detect that the `CrisisDetailComponent` component has the `canDeactivate()` method and call it.\nThe guard not knowing the details of any component's deactivation method makes the guard reusable.\n\nAlternatively, you could make a component-specific `CanDeactivate` guard for the `CrisisDetailComponent`.\nThe `canDeactivate()` method provides you with the current instance of the `component`, the current `ActivatedRoute`, and `RouterStateSnapshot` in case you needed to access some external information.\nThis would be useful if you only wanted to use this guard for this component and needed to get the component's properties or confirm whether the router should allow navigation away from it.\n\n<code-example path=\"router/src/app/can-deactivate.guard.1.ts\" header=\"src/app/can-deactivate.guard.ts (component-specific)\">\nimport { Injectable } from &#39;@angular/core&#39;;\nimport { Observable } from &#39;rxjs&#39;;\nimport { CanDeactivate,\n         ActivatedRouteSnapshot,\n         RouterStateSnapshot } from &#39;@angular/router&#39;;\n\nimport { CrisisDetailComponent } from &#39;./crisis-center/crisis-detail/crisis-detail.component&#39;;\n\n@Injectable({\n  providedIn: &#39;root&#39;,\n})\nexport class CanDeactivateGuard implements CanDeactivate&lt;CrisisDetailComponent&gt; {\n\n  canDeactivate(\n    component: CrisisDetailComponent,\n    route: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot\n  ): Observable&lt;boolean&gt; | boolean {\n    // 위기 관리 센터의 ID를 가져옵니다.\n    console.log(route.paramMap.get(&#39;id&#39;));\n\n    // 현재 URL을 확인합니다.\n    console.log(state.url);\n\n    // 위기 목록이 없거나 변경되지 않았으면 `true`를 바로 반환합니다.\n    if (!component.crisis || component.crisis.name === component.editName) {\n      return true;\n    }\n    // 내용이 변경된 경우에는 사용자에게 물어보는 팝업을 띄웁니다.\n    // 그리고 사용자가 응답한 값을 Observable 타입으로 반환합니다.\n    return component.dialogService.confirm(&#39;Discard changes?&#39;);\n  }\n}\n\n\n</code-example>\n\nLooking back at the `CrisisDetailComponent`, it implements the confirmation workflow for unsaved changes.\n\n<code-example path=\"router/src/app/crisis-center/crisis-detail/crisis-detail.component.ts\" header=\"src/app/crisis-center/crisis-detail/crisis-detail.component.ts (excerpt)\" region=\"canDeactivate\">\ncanDeactivate(): Observable&lt;boolean&gt; | boolean {\n  // 위기 목록이 없거나 변경되지 않았으면 `true`를 바로 반환합니다.\n  if (!this.crisis || this.crisis.name === this.editName) {\n    return true;\n  }\n  // 내용이 변경된 경우에는 사용자에게 물어보는 팝업을 띄웁니다.\n  // 그리고 사용자가 응답한 값을 Observable 타입으로 반환합니다.\n  return this.dialogService.confirm(&#39;Discard changes?&#39;);\n}\n\n</code-example>\n\nNotice that the `canDeactivate()` method can return synchronously; it returns `true` immediately if there is no crisis or there are no pending changes.\nBut it can also return a `Promise` or an `Observable` and the router will wait for that to resolve to truthy (navigate) or falsy (stay on the current route).\n\nAdd the `Guard` to the crisis detail route in `crisis-center-routing.module.ts` using the `canDeactivate` array property.\n\n<code-example path=\"router/src/app/crisis-center/crisis-center-routing.module.3.ts\" header=\"src/app/crisis-center/crisis-center-routing.module.ts (can deactivate guard)\">\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { RouterModule, Routes } from &#39;@angular/router&#39;;\n\nimport { CrisisCenterHomeComponent } from &#39;./crisis-center-home/crisis-center-home.component&#39;;\nimport { CrisisListComponent } from &#39;./crisis-list/crisis-list.component&#39;;\nimport { CrisisCenterComponent } from &#39;./crisis-center/crisis-center.component&#39;;\nimport { CrisisDetailComponent } from &#39;./crisis-detail/crisis-detail.component&#39;;\n\nimport { CanDeactivateGuard } from &#39;../can-deactivate.guard&#39;;\n\nconst crisisCenterRoutes: Routes = [\n  {\n    path: &#39;crisis-center&#39;,\n    component: CrisisCenterComponent,\n    children: [\n      {\n        path: &#39;&#39;,\n        component: CrisisListComponent,\n        children: [\n          {\n            path: &#39;:id&#39;,\n            component: CrisisDetailComponent,\n            canDeactivate: [CanDeactivateGuard]\n          },\n          {\n            path: &#39;&#39;,\n            component: CrisisCenterHomeComponent\n          }\n        ]\n      }\n    ]\n  }\n];\n\n@NgModule({\n  imports: [\n    RouterModule.forChild(crisisCenterRoutes)\n  ],\n  exports: [\n    RouterModule\n  ]\n})\nexport class CrisisCenterRoutingModule { }\n\n\n</code-example>\n\nNow you have given the user a safeguard against unsaved changes.\n-->\n<p>앱 사용자는 <code>CrisisDetailComponent</code>에서 위기 정보를 수정합니다.\n그런데 <code>HeroDetailComponent</code>와는 다르게, 이 컴포넌트는 사용자가 변경한 내용을 즉시 반영하지 않습니다.\n이 컴포넌트에서는 사용자가 \"Save\" 버튼을 눌렀을 때 전체 내용을 갱신하고, \"Cancel\" 버튼을 누르면 모든 변경사항을 폐기합니다.</p>\n<p>어떤 버튼이든 누른 후에는 위기 목록 화면으로 돌아갑니다.</p>\n<code-example path=\"router/src/app/crisis-center/crisis-detail/crisis-detail.component.ts\" header=\"src/app/crisis-center/crisis-detail/crisis-detail.component.ts (취소하거나 저장하는 메서드)\" region=\"cancel-save\">\ncancel() {\n  this.gotoCrises();\n}\n\nsave() {\n  this.crisis.name = this.editName;\n  this.gotoCrises();\n}\n\n</code-example>\n<p>기본 시나리오는 이렇지만 사용자는 변경사항을 저장하지 않은 상태에서 히어로 목록 링크를 클릭할 수 있고, 브라우저에서 뒤로 가기 버튼을 누를수도 있습니다.</p>\n<p>이런 경우에 다이얼로그를 하나 띄워서 사용자가 어떤 결정을 할 것인지 명확하게 결정하고, 사용자가 결정할 때까지 비동기로 기다리는 방식을 활용할 수 있습니다.</p>\n<div class=\"alert is-helpful\">\n<p>동기 코드로 사용자의 응답을 기다릴 수도 있지만, 이 방식은 코드 실행을 중단시킵니다.\n좀 더 나은 사용성을 제공하고 백그라운드에서 다른 작업을 계속 할 수 있는 비동기 방식이 더 좋습니다.</p>\n</div>\n<p>사용자의 결정을 받을 <code>Dialog</code> 서비스를 생성합니다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate service dialog\n</code-example>\n<p>그리고 사용자의 결정을 받을 <code>confirm()</code> 메서드를 <code>DialogService</code>에 추가합니다.\n<code>window.confirm</code>는 모달 팝업을 띄우면서 사용자의 응답을 기다리는 메서드입니다.</p>\n<code-example path=\"router/src/app/dialog.service.ts\" header=\"src/app/dialog.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { Observable, of } from 'rxjs';\n\n/**\n * 비동기 모달 팝업 서비스\n * DialogService는 예제를 확인하기 위해 간단하게 구현한 서비스입니다.\n * TODO: window.confirm을 사용하지 않는 방식이 더 좋습니다.\n */\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class DialogService {\n  /**\n   * 어떤 행동을 할지 사용자에게 물어봅니다. `message`는 사용자에게 안내할 문구입니다.\n   * `true`를 반환하면 사용자가 확정한 것으로 처리하고, `false`를 반환하면 취소한 것으로 처리합니다.\n   * 결과는 Observable 타입으로 반환합니다.\n   */\n  confirm(message?: string): Observable&#x3C;boolean> {\n    const confirmation = window.confirm(message || 'Is it OK?');\n\n    return of(confirmation);\n  }\n}\n\n\n</code-example>\n<p><code>confirm()</code> 메서드는 사용자가 결정한 것을 <code>Observable</code>로 반환하기 때문에 이 값을 활용하면 변경사항을 폐기하거나 저장할 수 있고, 이후에 화면을 벗어나거나(<code>true</code>인 경우) 수정화면에 그대로 남아있을 수(<code>false</code>인 경우) 있습니다.</p>\n<a id=\"CanDeactivate\"></a>\n<p>컴포넌트에 <code>canDeactivate()</code> 메서드가 있는지 검사하는 가드를 생성합니다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate guard can-deactivate\n</code-example>\n<p>그리고 아래 코드를 가드에 붙여넣습니다.</p>\n<code-example path=\"router/src/app/can-deactivate.guard.ts\" header=\"src/app/can-deactivate.guard.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { <a href=\"api/router/CanDeactivate\" class=\"code-anchor\">CanDeactivate</a> } from '@angular/router';\nimport { Observable } from 'rxjs';\n\nexport interface CanComponentDeactivate {\n canDeactivate: () => Observable&#x3C;boolean> | Promise&#x3C;boolean> | boolean;\n}\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class CanDeactivateGuard implements <a href=\"api/router/CanDeactivate\" class=\"code-anchor\">CanDeactivate</a>&#x3C;CanComponentDeactivate> {\n  canDeactivate(component: CanComponentDeactivate) {\n    return component.canDeactivate ? component.canDeactivate() : true;\n  }\n}\n\n\n</code-example>\n<p>이 가드는 어떤 컴포넌트에 <code>canDeactivate</code> 메서드가 있는지 미리 알 필요가 없으며, 컴포넌트에 <code>canDeactivate()</code> 메서드가 있을 때만 이 메서드를 실행합니다.\n이렇게 구현하면 가드를 재사용하기도 편합니다.</p>\n<p>이 방법 대신 <code>CrisisDetailComponent</code>를 대상으로만 동작하는 <code><a href=\"api/router/CanDeactivate\" class=\"code-anchor\">CanDeactivate</a></code> 가드를 만들 수도 있습니다.\n이 방식은 컴포넌트 인스턴스를 <code>canDeactivate()</code> 메서드로 전달해야 하며, 추가 정보가 필요하다면 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>나 <code><a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a></code>을 추가로 전달해서 활용하면 됩니다.\n이 컴포넌트에만 동작하는 라우팅 가드를 만들거나, 컴포넌트에 있는 프로퍼티를 더 활용해야 한다면 이 방식이 유용할 수도 있습니다.</p>\n<code-example path=\"router/src/app/can-deactivate.guard.1.ts\" header=\"src/app/can-deactivate.guard.ts (컴포넌트 전용 가드)\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { <a href=\"api/router/CanDeactivate\" class=\"code-anchor\">CanDeactivate</a>,\n         <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>,\n         <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a> } from '@angular/router';\n\nimport { CrisisDetailComponent } from './crisis-center/crisis-detail/crisis-detail.component';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class CanDeactivateGuard implements <a href=\"api/router/CanDeactivate\" class=\"code-anchor\">CanDeactivate</a>&#x3C;CrisisDetailComponent> {\n\n  canDeactivate(\n    component: CrisisDetailComponent,\n    route: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>,\n    <a href=\"api/animations/state\" class=\"code-anchor\">state</a>: <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>\n  ): Observable&#x3C;boolean> | boolean {\n    // 위기 관리 센터의 ID를 가져옵니다.\n    console.log(route.paramMap.get('id'));\n\n    // 현재 URL을 확인합니다.\n    console.log(state.url);\n\n    // 위기 목록이 없거나 변경되지 않았으면 `true`를 바로 반환합니다.\n    if (!component.crisis || component.crisis.name === component.editName) {\n      return true;\n    }\n    // 내용이 변경된 경우에는 사용자에게 물어보는 팝업을 띄웁니다.\n    // 그리고 사용자가 응답한 값을 Observable 타입으로 반환합니다.\n    return component.dialogService.confirm('Discard changes?');\n  }\n}\n\n\n</code-example>\n<p><code>CrisisDetailComponent</code>를 다시 보면, 이 컴포넌트는 사용자의 결정을 이렇게 받습니다.</p>\n<code-example path=\"router/src/app/crisis-center/crisis-detail/crisis-detail.component.ts\" header=\"src/app/crisis-center/crisis-detail/crisis-detail.component.ts (일부)\" region=\"canDeactivate\">\ncanDeactivate(): Observable&#x3C;boolean> | boolean {\n  // 위기 목록이 없거나 변경되지 않았으면 `true`를 바로 반환합니다.\n  if (!this.crisis || this.crisis.name === this.editName) {\n    return true;\n  }\n  // 내용이 변경된 경우에는 사용자에게 물어보는 팝업을 띄웁니다.\n  // 그리고 사용자가 응답한 값을 Observable 타입으로 반환합니다.\n  return this.dialogService.confirm('Discard changes?');\n}\n\n</code-example>\n<p><code>canDeactivate()</code> 메서드는 결과값을 동기 방식으로 반환할 수 있습니다.\n변경된 내용이 없어서 화면을 벗어나도 문제되지 않으면 <code>true</code>를 즉시 반환합니다.\n하지만 변경된 내용을 어떻게 해야 할지 결정해야 하는 상황이라면 <code>Promise</code>나 <code>Observable</code>을 반환해서 라우터의 실행을 잠시 멈출 수 있습니다.</p>\n<p>이 가드를 적용하려면 <code>crisis-center-routing.module.ts</code> 파일에서 위기 상세정보에 해당하는 라우팅 규칙의 <code>canDeactivate</code> 배열에 추가하면 됩니다.</p>\n<code-example path=\"router/src/app/crisis-center/crisis-center-routing.module.3.ts\" header=\"src/app/crisis-center/crisis-center-routing.module.ts (가드 추가하기)\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { CrisisCenterHomeComponent } from './crisis-center-home/crisis-center-home.component';\nimport { CrisisListComponent } from './crisis-list/crisis-list.component';\nimport { CrisisCenterComponent } from './crisis-center/crisis-center.component';\nimport { CrisisDetailComponent } from './crisis-detail/crisis-detail.component';\n\nimport { CanDeactivateGuard } from '../can-deactivate.guard';\n\nconst crisisCenterRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'crisis-center',\n    component: CrisisCenterComponent,\n    children: [\n      {\n        path: '',\n        component: CrisisListComponent,\n        children: [\n          {\n            path: ':id',\n            component: CrisisDetailComponent,\n            canDeactivate: [CanDeactivateGuard]\n          },\n          {\n            path: '',\n            component: CrisisCenterHomeComponent\n          }\n        ]\n      }\n    ]\n  }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forChild(crisisCenterRoutes)\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class CrisisCenterRoutingModule { }\n\n\n</code-example>\n<p>이제 사용자가 변경한 내용을 어떻게 처리할지 보호하는 가드가 추가되었습니다.</p>\n<a id=\"Resolve\"></a>\n<a id=\"resolve-guard\"></a>\n<!--\n### _Resolve_: pre-fetching component data\n-->\n<h3 id=\"resolve-컴포넌트-데이터-미리-받아오기\"><em>Resolve</em>: 컴포넌트 데이터 미리 받아오기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#resolve-컴포넌트-데이터-미리-받아오기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn the `Hero Detail` and `Crisis Detail`, the app waited until the route was activated to fetch the respective hero or crisis.\n\nIf you were using a real world API, there might be some delay before the data to display is returned from the server.\nYou don't want to display a blank component while waiting for the data.\n\nTo improve this behavior, you can pre-fetch data from the server using a resolver so it's ready the\nmoment the route is activated.\nThis also allows you to handle errors before routing to the component.\nThere's no point in navigating to a crisis detail for an `id` that doesn't have a record.\nIt'd be better to send the user back to the `Crisis List` that shows only valid crisis centers.\n\nIn summary, you want to delay rendering the routed component until all necessary data has been fetched.\n-->\n<p>히어로 상세정보 컴포넌트와 위기 상세정보 컴포넌트는 라우팅 규칙이 적용된 후에 해당 컴포넌트에 필요한 데이터를 다 받아와야 컴포넌트가 표시됩니다.</p>\n<p>실제 운영환경에서 서버가 제공하는 API를 사용한다면 데이터를 받아와서 표시하기까지 시간이 좀 걸릴 것입니다.\n이 때 데이터가 표시되기까지 빈 화면이 표시되는데, 이 동작을 개선해 봅시다.</p>\n<p>리졸버(resolver)를 사용하면 서버에서 데이터를 미리 받아올 수 있기 때문에 라우팅 규칙이 적용되는 시점에 바로 컴포넌트 내용을 표시할 수 있습니다.\n만약 데이터를 받아올 때 에러가 발생한다면 이 에러도 컴포넌트로 이동하기 전에 처리할 수 있습니다.\n실제로 존재하지 않는 <code>id</code>를 가지고 위기 상세정보 화면으로 이동할 필요는 없습니다.\n이런 경우에는 사용자를 위기 목록 화면으로 다시 이동시켜서 올바른 목록이 무엇인지 다시 확인하게 하는 것이 좋습니다.</p>\n<p>간단하게 설명하자면, 컴포넌트를 화면에 표시하기 전에 해당 컴포넌트에 필요한 데이터를 다 받아올 때까지 렌더링을 지연시킬 수 있습니다.</p>\n<a id=\"fetch-before-navigating\"></a>\n<!--\n#### Fetch data before navigating\n-->\n<h4 id=\"화면을-전환하기-전에-데이터-받아오기\">화면을 전환하기 전에 데이터 받아오기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#화면을-전환하기-전에-데이터-받아오기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nAt the moment, the `CrisisDetailComponent` retrieves the selected crisis.\nIf the crisis is not found, the router navigates back to the crisis list view.\n\nThe experience might be better if all of this were handled first, before the route is activated.\nA `CrisisDetailResolver` service could retrieve a `Crisis` or navigate away, if the `Crisis` did not exist, _before_ activating the route and creating the `CrisisDetailComponent`.\n\nGenerate a `CrisisDetailResolver` service file within the `Crisis Center` feature area.\n\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate service crisis-center/crisis-detail-resolver\n</code-example>\n\n<code-example path=\"router/src/app/crisis-center/crisis-detail-resolver.service.1.ts\" header=\"src/app/crisis-center/crisis-detail-resolver.service.ts (generated)\">\nimport { Injectable } from &#39;@angular/core&#39;;\n\n@Injectable({\n  providedIn: &#39;root&#39;,\n})\nexport class CrisisDetailResolverService {\n\n  constructor() { }\n\n}\n\n\n</code-example>\n\nMove the relevant parts of the crisis retrieval logic in `CrisisDetailComponent.ngOnInit()` into the `CrisisDetailResolverService`.\nImport the `Crisis` model, `CrisisService`, and the `Router` so you can navigate elsewhere if you can't fetch the crisis.\n\nBe explicit and implement the `Resolve` interface with a type of `Crisis`.\n\nInject the `CrisisService` and `Router` and implement the `resolve()` method.\nThat method could return a `Promise`, an `Observable`, or a synchronous return value.\n\nThe `CrisisService.getCrisis()` method returns an observable in order to prevent the route from loading until the data is fetched.\nThe `Router` guards require an observable to `complete`, which means it has emitted all\nof its values.\nYou use the `take` operator with an argument of `1` to ensure that the `Observable` completes after retrieving the first value from the Observable returned by the `getCrisis()` method.\n\nIf it doesn't return a valid `Crisis`, then return an empty `Observable`, cancel the previous in-progress navigation to the `CrisisDetailComponent`, and navigate the user back to the `CrisisListComponent`.\nThe updated resolver service looks like this:\n\n<code-example path=\"router/src/app/crisis-center/crisis-detail-resolver.service.ts\" header=\"src/app/crisis-center/crisis-detail-resolver.service.ts\">\nimport { Injectable } from &#39;@angular/core&#39;;\nimport {\n  Router, Resolve,\n  RouterStateSnapshot,\n  ActivatedRouteSnapshot\n} from &#39;@angular/router&#39;;\nimport { Observable, of, EMPTY } from &#39;rxjs&#39;;\nimport { mergeMap, take } from &#39;rxjs/operators&#39;;\n\nimport { CrisisService } from &#39;./crisis.service&#39;;\nimport { Crisis } from &#39;./crisis&#39;;\n\n@Injectable({\n  providedIn: &#39;root&#39;,\n})\nexport class CrisisDetailResolverService implements Resolve&lt;Crisis&gt; {\n  constructor(private cs: CrisisService, private router: Router) {}\n\n  resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable&lt;Crisis&gt; | Observable&lt;never&gt; {\n    const id = route.paramMap.get(&#39;id&#39;);\n\n    return this.cs.getCrisis(id).pipe(\n      take(1),\n      mergeMap(crisis =&gt; {\n        if (crisis) {\n          return of(crisis);\n        } else { // id에 해당하는 데이터를 찾지 못한 경우\n          this.router.navigate([&#39;/crisis-center&#39;]);\n          return EMPTY;\n        }\n      })\n    );\n  }\n}\n\n\n</code-example>\n\nImport this resolver in the `crisis-center-routing.module.ts` and add a `resolve` object to the `CrisisDetailComponent` route configuration.\n\n<code-example path=\"router/src/app/crisis-center/crisis-center-routing.module.4.ts\" header=\"src/app/crisis-center/crisis-center-routing.module.ts (resolver)\">\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { RouterModule, Routes } from &#39;@angular/router&#39;;\n\nimport { CrisisCenterHomeComponent } from &#39;./crisis-center-home/crisis-center-home.component&#39;;\nimport { CrisisListComponent } from &#39;./crisis-list/crisis-list.component&#39;;\nimport { CrisisCenterComponent } from &#39;./crisis-center/crisis-center.component&#39;;\nimport { CrisisDetailComponent } from &#39;./crisis-detail/crisis-detail.component&#39;;\n\nimport { CanDeactivateGuard } from &#39;../can-deactivate.guard&#39;;\nimport { CrisisDetailResolverService } from &#39;./crisis-detail-resolver.service&#39;;\n\nconst crisisCenterRoutes: Routes = [\n  {\n    path: &#39;crisis-center&#39;,\n    component: CrisisCenterComponent,\n    children: [\n      {\n        path: &#39;&#39;,\n        component: CrisisListComponent,\n        children: [\n          {\n            path: &#39;:id&#39;,\n            component: CrisisDetailComponent,\n            canDeactivate: [CanDeactivateGuard],\n            resolve: {\n              crisis: CrisisDetailResolverService\n            }\n          },\n          {\n            path: &#39;&#39;,\n            component: CrisisCenterHomeComponent\n          }\n        ]\n      }\n    ]\n  }\n];\n\n@NgModule({\n  imports: [\n    RouterModule.forChild(crisisCenterRoutes)\n  ],\n  exports: [\n    RouterModule\n  ]\n})\nexport class CrisisCenterRoutingModule { }\n\n</code-example>\n\nThe `CrisisDetailComponent` should no longer fetch the crisis.\nWhen you re-configured the route, you changed where the crisis is.\nUpdate the `CrisisDetailComponent` to get the crisis from the  `ActivatedRoute.data.crisis` property instead;\n\n<code-example path=\"router/src/app/crisis-center/crisis-detail/crisis-detail.component.ts\" header=\"src/app/crisis-center/crisis-detail/crisis-detail.component.ts (ngOnInit v2)\" region=\"ngOnInit\">\nngOnInit() {\n  this.route.data\n    .subscribe((data: { crisis: Crisis }) =&gt; {\n      this.editName = data.crisis.name;\n      this.crisis = data.crisis;\n    });\n}\n\n</code-example>\n\nNote the following three important points:\n\n1. The router's `Resolve` interface is optional.\nThe `CrisisDetailResolverService` doesn't inherit from a base class.\nThe router looks for that method and calls it if found.\n\n1. The router calls the resolver in any case where the the user could navigate away so you don't have to code for each use case.\n\n1. Returning an empty `Observable` in at least one resolver will cancel navigation.\n\nThe relevant Crisis Center code for this milestone follows.\n-->\n<p>지금까지 구현한 대로라면 <code>CrisisDetailComponent</code>는 목록에서 선택한 위기 정보를 직접 받아옵니다.\n이 때 위기 항목이 실제로 존재하지 않으면 목록 화면으로 다시 이동합니다.</p>\n<p>그런데 UX 측면에서 생각해보면, 이 컴포넌트에 필요한 것들을 모두 준비해둔 후에 라우팅 규칙을 적용하는 것이 더 나을 수 있습니다.\n새로 만들 <code>CrisisDetailResolver</code> 서비스는 원하는 위기 항목을 받아온 후에, 이 항목이 실제로 존재하지 않으면 <code>CrisisDetailComponent</code> 인스턴스를 생성하고 라우팅 규칙을 적용하기 <em>전에</em> 다른 화면으로 이동하는 서비스입니다.</p>\n<p>위기대응센터 모듈 폴더에서 다음 명령을 실행해서 <code>CrisisDetailResolver</code> 서비스를 생성합니다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate service crisis-center/crisis-detail-resolver\n</code-example>\n<code-example path=\"router/src/app/crisis-center/crisis-detail-resolver.service.1.ts\" header=\"src/app/crisis-center/crisis-detail-resolver.service.ts (생성된 서비스)\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class CrisisDetailResolverService {\n\n  constructor() { }\n\n}\n\n\n</code-example>\n<p>이제 <code>CrisisDetailComponent.ngOnInit()</code>에서 데이터를 받아오는 코드를 <code>CrisisDetailResolverService</code>로 옮깁니다.\n데이터를 받아오려면 <code>Crisis</code> 모델, <code>CrisisService</code>를 로드해야 하고, 원하는 데이터를 받아오지 못했을 때 사용하기 위해 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>도 로드해야 합니다.</p>\n<p>이번 예제에서는 <code><a href=\"api/router/Resolve\" class=\"code-anchor\">Resolve</a></code> 인터페이스를 <code>Crisis</code> 타입으로만 명시적으로 구현해 봅시다.</p>\n<p><code>CrisisService</code>와 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>는 생성자에 주입하고 <code>resolve()</code> 메서드를 정의합니다.\n이 메서드는 상황에 따라 <code>Promise</code>나 <code>Observable</code>, 또는 동기 방식으로 결과값을 반환합니다.</p>\n<p><code>CrisisService.getCrisis()</code> 메서드는 데이터를 받아오기 전까지 라우팅 규칙이 적용되는 것을 지연시키기 위해 옵저버블을 반환합니다.\n이 때 옵저버블은 반드시 종료되어야 라우터가 그 다음 작업을 처리할 수 있습니다.\n<code>take</code> 연산자에 <code>1</code>을 인자를 사용하면 <code>getCrisis()</code> 메서드로 첫 번째 데이터를 받은 후에 옵저버블을 확실하게 종료할 수 있습니다.</p>\n<p>원하는 위기 항목을 받아오지 못해서 옵저버블이 빈 값이 전달하면 <code>CrisisDetailComponent</code>로 이동하던 네비게이션 동작을 취소하고 <code>CrisisListComponent</code>로 돌아갑니다.\n여기까지 구현하고 나면 리졸버 서비스 코드는 이렇습니다:</p>\n<code-example path=\"router/src/app/crisis-center/crisis-detail-resolver.service.ts\" header=\"src/app/crisis-center/crisis-detail-resolver.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport {\n  <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>, <a href=\"api/router/Resolve\" class=\"code-anchor\">Resolve</a>,\n  <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>,\n  <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>\n} from '@angular/router';\nimport { Observable, of, EMPTY } from 'rxjs';\nimport { mergeMap, take } from 'rxjs/operators';\n\nimport { CrisisService } from './crisis.service';\nimport { Crisis } from './crisis';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class CrisisDetailResolverService implements <a href=\"api/router/Resolve\" class=\"code-anchor\">Resolve</a>&#x3C;Crisis> {\n  constructor(private cs: CrisisService, private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {}\n\n  resolve(route: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>, <a href=\"api/animations/state\" class=\"code-anchor\">state</a>: <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>): Observable&#x3C;Crisis> | Observable&#x3C;never> {\n    const id = route.paramMap.get('id');\n\n    return this.cs.getCrisis(id).pipe(\n      take(1),\n      mergeMap(crisis => {\n        if (crisis) {\n          return of(crisis);\n        } else { // id에 해당하는 데이터를 찾지 못한 경우\n          this.router.navigate(['/crisis-center']);\n          return EMPTY;\n        }\n      })\n    );\n  }\n}\n\n\n</code-example>\n<p>그리고 이 리졸버는 <code>crisis-center-routing.module.ts</code> 파일에 로드하고 <code>CrisisDetailComponent</code>에 해당하는 라우팅 규칙의 <code>resolve</code> 객체에 추가하면 됩니다.</p>\n<code-example path=\"router/src/app/crisis-center/crisis-center-routing.module.4.ts\" header=\"src/app/crisis-center/crisis-center-routing.module.ts (resolver)\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { CrisisCenterHomeComponent } from './crisis-center-home/crisis-center-home.component';\nimport { CrisisListComponent } from './crisis-list/crisis-list.component';\nimport { CrisisCenterComponent } from './crisis-center/crisis-center.component';\nimport { CrisisDetailComponent } from './crisis-detail/crisis-detail.component';\n\nimport { CanDeactivateGuard } from '../can-deactivate.guard';\nimport { CrisisDetailResolverService } from './crisis-detail-resolver.service';\n\nconst crisisCenterRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'crisis-center',\n    component: CrisisCenterComponent,\n    children: [\n      {\n        path: '',\n        component: CrisisListComponent,\n        children: [\n          {\n            path: ':id',\n            component: CrisisDetailComponent,\n            canDeactivate: [CanDeactivateGuard],\n            resolve: {\n              crisis: CrisisDetailResolverService\n            }\n          },\n          {\n            path: '',\n            component: CrisisCenterHomeComponent\n          }\n        ]\n      }\n    ]\n  }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forChild(crisisCenterRoutes)\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class CrisisCenterRoutingModule { }\n\n</code-example>\n<p>이제 <code>CrisisDetailComponent</code>는 데이터를 직접 받아오지 않습니다.\n그래서 이 컴포넌트에 해당하는 라우팅 규칙을 수정해서 데이터를 어디에서 받아오는지 지정해야 합니다.\n<code>CrisisDetailComponent</code> 안에서는 <code>ActivatedRoute.data.crisis</code> 프로퍼티에서 데이터를 받아오도록 수정합니다.</p>\n<code-example path=\"router/src/app/crisis-center/crisis-detail/crisis-detail.component.ts\" header=\"src/app/crisis-center/crisis-detail/crisis-detail.component.ts (ngOnInit v2)\" region=\"ngOnInit\">\nngOnInit() {\n  this.route.data\n    .subscribe((data: { crisis: Crisis }) => {\n      this.editName = data.crisis.name;\n      this.crisis = data.crisis;\n    });\n}\n\n</code-example>\n<p>이런 점이 중요합니다:</p>\n<ol>\n<li>\n<p>라우터가 제공하는 <code><a href=\"api/router/Resolve\" class=\"code-anchor\">Resolve</a></code> 인터페이스는 생략할 수 있습니다.\n<code>CrisisDetailResolverService</code>도 어떤 클래스를 상속하지 않습니다.\n라우터는 관련 메서드가 존재할 때만 해당 메서드를 실행합니다.</p>\n</li>\n<li>\n<p>라우터는 필요한 상황마다 자동으로 리졸버를 실행합니다.\n리졸버가 필요한 경우를 직접 찾아서 추가할 필요는 없습니다.</p>\n</li>\n<li>\n<p>옵저버블로 빈 값을 전달하면 리졸버가 화면 전환 동작을 취소합니다.</p>\n</li>\n</ol>\n<p>여기까지 구현하고 나면 위기대응센터의 코드는 이렇게 구성됩니다.</p>\n<code-tabs>\n\n  <code-pane header=\"app.component.html\" path=\"router/src/app/app.component.html\">\n&#x3C;h1 class=\"title\">Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>&#x3C;/h1>\n&#x3C;nav>\n  &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/crisis-center\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Crisis Center&#x3C;/a>\n  &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/superheroes\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Heroes&#x3C;/a>\n  &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/admin\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Admin&#x3C;/a>\n  &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/login\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Login&#x3C;/a>\n  &#x3C;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"[{ outlets: { popup: ['compose'] } }]\">Contact&#x3C;/a>\n&#x3C;/nav>\n&#x3C;div [@routeAnimation]=\"getAnimationData(routerOutlet)\">\n  &#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a> #routerOutlet=\"outlet\">&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n&#x3C;/div>\n&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a> name=\"popup\">&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n\n</code-pane>\n\n  <code-pane header=\"crisis-center-home.component.html\" path=\"router/src/app/crisis-center/crisis-center-home/crisis-center-home.component.html\">\n&#x3C;p>Welcome to the Crisis Center&#x3C;/p>\n\n</code-pane>\n\n  <code-pane header=\"crisis-center.component.html\" path=\"router/src/app/crisis-center/crisis-center/crisis-center.component.html\">\n&#x3C;h2>CRISIS CENTER&#x3C;/h2>\n&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n\n</code-pane>\n\n  <code-pane header=\"crisis-center-routing.module.ts\" path=\"router/src/app/crisis-center/crisis-center-routing.module.4.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { CrisisCenterHomeComponent } from './crisis-center-home/crisis-center-home.component';\nimport { CrisisListComponent } from './crisis-list/crisis-list.component';\nimport { CrisisCenterComponent } from './crisis-center/crisis-center.component';\nimport { CrisisDetailComponent } from './crisis-detail/crisis-detail.component';\n\nimport { CanDeactivateGuard } from '../can-deactivate.guard';\nimport { CrisisDetailResolverService } from './crisis-detail-resolver.service';\n\nconst crisisCenterRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'crisis-center',\n    component: CrisisCenterComponent,\n    children: [\n      {\n        path: '',\n        component: CrisisListComponent,\n        children: [\n          {\n            path: ':id',\n            component: CrisisDetailComponent,\n            canDeactivate: [CanDeactivateGuard],\n            resolve: {\n              crisis: CrisisDetailResolverService\n            }\n          },\n          {\n            path: '',\n            component: CrisisCenterHomeComponent\n          }\n        ]\n      }\n    ]\n  }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forChild(crisisCenterRoutes)\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class CrisisCenterRoutingModule { }\n\n</code-pane>\n\n  <code-pane header=\"crisis-list.component.html\" path=\"router/src/app/crisis-center/crisis-list/crisis-list.component.html\">\n&#x3C;ul class=\"crises\">\n  &#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let crisis of crises$ | async\"\n    [class.selected]=\"crisis.id === selectedId\">\n    &#x3C;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"[crisis.id]\">\n      &#x3C;span class=\"badge\">{{ crisis.id }}&#x3C;/span>{{ crisis.name }}\n    &#x3C;/a>\n  &#x3C;/li>\n&#x3C;/ul>\n\n&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n\n</code-pane>\n\n  <code-pane header=\"crisis-list.component.ts\" path=\"router/src/app/crisis-center/crisis-list/crisis-list.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\n\nimport { CrisisService } from '../crisis.service';\nimport { Crisis } from '../crisis';\nimport { Observable } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-crisis-list',\n  templateUrl: './crisis-list.component.html',\n  styleUrls: ['./crisis-list.component.css']\n})\nexport class CrisisListComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  crises$: Observable&#x3C;Crisis[]>;\n  selectedId: number;\n\n  constructor(\n    private service: CrisisService,\n    private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>\n  ) {}\n\n  ngOnInit() {\n    this.crises$ = this.route.paramMap.pipe(\n      switchMap(params => {\n        this.selectedId = +params.get('id');\n        return this.service.getCrises();\n      })\n    );\n  }\n}\n\n\n</code-pane>\n\n  <code-pane header=\"crisis-detail.component.html\" path=\"router/src/app/crisis-center/crisis-detail/crisis-detail.component.html\">\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"crisis\">\n  &#x3C;h3>\"{{ editName }}\"&#x3C;/h3>\n  &#x3C;div>\n    &#x3C;label>Id: &#x3C;/label>{{ crisis.id }}&#x3C;/div>\n  &#x3C;div>\n    &#x3C;label>Name: &#x3C;/label>\n    &#x3C;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"editName\" placeholder=\"name\"/>\n  &#x3C;/div>\n  &#x3C;p>\n    &#x3C;button (click)=\"save()\">Save&#x3C;/button>\n    &#x3C;button (click)=\"cancel()\">Cancel&#x3C;/button>\n  &#x3C;/p>\n&#x3C;/div>\n\n</code-pane>\n\n  <code-pane header=\"crisis-detail.component.ts\" path=\"router/src/app/crisis-center/crisis-detail/crisis-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>, <a href=\"api/core/HostBinding\" class=\"code-anchor\">HostBinding</a> } from '@angular/core';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, <a href=\"api/router/Router\" class=\"code-anchor\">Router</a> } from '@angular/router';\nimport { Observable } from 'rxjs';\n\nimport { Crisis } from '../crisis';\nimport { DialogService } from '../../dialog.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-crisis-detail',\n  templateUrl: './crisis-detail.component.html',\n  styleUrls: ['./crisis-detail.component.css']\n})\nexport class CrisisDetailComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  crisis: Crisis;\n  editName: string;\n\n  constructor(\n    private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>,\n    private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,\n    public dialogService: DialogService\n  ) {}\n\n  ngOnInit() {\n    this.route.data\n      .subscribe((data: { crisis: Crisis }) => {\n        this.editName = data.crisis.name;\n        this.crisis = data.crisis;\n      });\n  }\n\n  cancel() {\n    this.gotoCrises();\n  }\n\n  save() {\n    this.crisis.name = this.editName;\n    this.gotoCrises();\n  }\n\n  canDeactivate(): Observable&#x3C;boolean> | boolean {\n    // 위기 목록이 없거나 변경되지 않았으면 `true`를 바로 반환합니다.\n    if (!this.crisis || this.crisis.name === this.editName) {\n      return true;\n    }\n    // 내용이 변경된 경우에는 사용자에게 물어보는 팝업을 띄웁니다.\n    // 그리고 사용자가 응답한 값을 Observable 타입으로 반환합니다.\n    return this.dialogService.confirm('Discard changes?');\n  }\n\n  gotoCrises() {\n    const crisisId = this.crisis ? this.crisis.id : null;\n    // 화면에 표시한 위기 항목의 id를 전달해서\n    // CrisisListComponent에서 해당 위기 항목을 하이라이트 처리합니다.\n    // `foo` 인자는 사용하지 않지만 문제가 발생하지 않습니다.\n    // 상대주소를 사용해서 목록 화면으로 돌아갑니다.\n    this.router.navigate(['../', { id: crisisId, foo: 'foo' }], { relativeTo: this.route });\n  }\n}\n\n\n</code-pane>\n\n  <code-pane header=\"crisis-detail-resolver.service.ts\" path=\"router/src/app/crisis-center/crisis-detail-resolver.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport {\n  <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>, <a href=\"api/router/Resolve\" class=\"code-anchor\">Resolve</a>,\n  <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>,\n  <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>\n} from '@angular/router';\nimport { Observable, of, EMPTY } from 'rxjs';\nimport { mergeMap, take } from 'rxjs/operators';\n\nimport { CrisisService } from './crisis.service';\nimport { Crisis } from './crisis';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class CrisisDetailResolverService implements <a href=\"api/router/Resolve\" class=\"code-anchor\">Resolve</a>&#x3C;Crisis> {\n  constructor(private cs: CrisisService, private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {}\n\n  resolve(route: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>, <a href=\"api/animations/state\" class=\"code-anchor\">state</a>: <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>): Observable&#x3C;Crisis> | Observable&#x3C;never> {\n    const id = route.paramMap.get('id');\n\n    return this.cs.getCrisis(id).pipe(\n      take(1),\n      mergeMap(crisis => {\n        if (crisis) {\n          return of(crisis);\n        } else { // id에 해당하는 데이터를 찾지 못한 경우\n          this.router.navigate(['/crisis-center']);\n          return EMPTY;\n        }\n      })\n    );\n  }\n}\n\n\n</code-pane>\n\n  <code-pane header=\"crisis.service.ts\" path=\"router/src/app/crisis-center/crisis.service.ts\">\nimport { BehaviorSubject } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { MessageService } from '../message.service';\nimport { Crisis } from './crisis';\nimport { CRISES } from './mock-crises';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class CrisisService {\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> nextCrisisId = 100;\n  private crises$: BehaviorSubject&#x3C;Crisis[]> = new BehaviorSubject&#x3C;Crisis[]>(CRISES);\n\n  constructor(private messageService: MessageService) { }\n\n  getCrises() { return this.crises$; }\n\n  getCrisis(id: number | string) {\n    return this.getCrises().pipe(\n      map(crises => crises.find(crisis => crisis.id === +id))\n    );\n  }\n\n}\n\n\n</code-pane>\n\n  <code-pane header=\"dialog.service.ts\" path=\"router/src/app/dialog.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { Observable, of } from 'rxjs';\n\n/**\n * 비동기 모달 팝업 서비스\n * DialogService는 예제를 확인하기 위해 간단하게 구현한 서비스입니다.\n * TODO: window.confirm을 사용하지 않는 방식이 더 좋습니다.\n */\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class DialogService {\n  /**\n   * 어떤 행동을 할지 사용자에게 물어봅니다. `message`는 사용자에게 안내할 문구입니다.\n   * `true`를 반환하면 사용자가 확정한 것으로 처리하고, `false`를 반환하면 취소한 것으로 처리합니다.\n   * 결과는 Observable 타입으로 반환합니다.\n   */\n  confirm(message?: string): Observable&#x3C;boolean> {\n    const confirmation = window.confirm(message || 'Is it OK?');\n\n    return of(confirmation);\n  }\n}\n\n\n</code-pane>\n\n</code-tabs>\n<!--\nGuards\n-->\n<p>그리고 가드 코드는 이렇습니다.</p>\n<code-tabs>\n\n  <code-pane header=\"auth.guard.ts\" path=\"router/src/app/auth/auth.guard.3.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport {\n  <a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a>, <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,\n  <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>,\n  <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>,\n  <a href=\"api/router/CanActivateChild\" class=\"code-anchor\">CanActivateChild</a>,\n  <a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a>\n} from '@angular/router';\nimport { AuthService } from './auth.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class AuthGuard implements <a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a>, <a href=\"api/router/CanActivateChild\" class=\"code-anchor\">CanActivateChild</a> {\n  constructor(private authService: AuthService, private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {}\n\n  canActivate(\n    route: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>,\n    <a href=\"api/animations/state\" class=\"code-anchor\">state</a>: <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>): true|<a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a> {\n    const url: string = state.url;\n\n    return this.checkLogin(url);\n  }\n\n  canActivateChild(\n    route: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>,\n    <a href=\"api/animations/state\" class=\"code-anchor\">state</a>: <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>): true|<a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a> {\n    return this.canActivate(route, <a href=\"api/animations/state\" class=\"code-anchor\">state</a>);\n  }\n\n  checkLogin(url: string): true|<a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a> {\n    if (this.authService.isLoggedIn) { return true; }\n\n    // 로그인한 후에 이동할 URL을 저장해 둡니다.\n    this.authService.redirectUrl = url;\n\n    // 로그인 페이지로 이동합니다.\n    return this.router.parseUrl('/login');\n  }\n}\n\n\n</code-pane>\n\n  <code-pane header=\"can-deactivate.guard.ts\" path=\"router/src/app/can-deactivate.guard.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { <a href=\"api/router/CanDeactivate\" class=\"code-anchor\">CanDeactivate</a> } from '@angular/router';\nimport { Observable } from 'rxjs';\n\nexport interface CanComponentDeactivate {\n canDeactivate: () => Observable&#x3C;boolean> | Promise&#x3C;boolean> | boolean;\n}\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class CanDeactivateGuard implements <a href=\"api/router/CanDeactivate\" class=\"code-anchor\">CanDeactivate</a>&#x3C;CanComponentDeactivate> {\n  canDeactivate(component: CanComponentDeactivate) {\n    return component.canDeactivate ? component.canDeactivate() : true;\n  }\n}\n\n\n</code-pane>\n\n</code-tabs>\n<a id=\"query-parameters\"></a>\n<a id=\"fragment\"></a>\n<!--\n### Query parameters and fragments\n-->\n<h3 id=\"쿼리-인자와-프래그먼트\">쿼리 인자와 프래그먼트<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#쿼리-인자와-프래그먼트\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn the [route parameters](#optional-route-parameters) section, you only dealt with parameters specific to the route.\nHowever, you can use query parameters to get optional parameters available to all routes.\n\n[Fragments](https://en.wikipedia.org/wiki/Fragment_identifier) refer to certain elements on the page\nidentified with an `id` attribute.\n\nUpdate the `AuthGuard` to provide a `session_id` query that will remain after navigating to another route.\n\nAdd an `anchor` element so you can jump to a certain point on the page.\n\nAdd the `NavigationExtras` object to the `router.navigate()` method that navigates you to the `/login` route.\n\n<code-example path=\"router/src/app/auth/auth.guard.4.ts\" header=\"src/app/auth/auth.guard.ts (v3)\">\nimport { Injectable } from &#39;@angular/core&#39;;\nimport {\n  CanActivate, Router,\n  ActivatedRouteSnapshot,\n  RouterStateSnapshot,\n  CanActivateChild,\n  NavigationExtras,\n  UrlTree\n} from &#39;@angular/router&#39;;\nimport { AuthService } from &#39;./auth.service&#39;;\n\n@Injectable({\n  providedIn: &#39;root&#39;,\n})\nexport class AuthGuard implements CanActivate, CanActivateChild {\n  constructor(private authService: AuthService, private router: Router) {}\n\n  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): true|UrlTree {\n    const url: string = state.url;\n\n    return this.checkLogin(url);\n  }\n\n  canActivateChild(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): true|UrlTree {\n    return this.canActivate(route, state);\n  }\n\n  checkLogin(url: string): true|UrlTree {\n    if (this.authService.isLoggedIn) { return true; }\n\n    // 리다이렉트할 URL을 저장해 둡니다.\n    this.authService.redirectUrl = url;\n\n    // 더미 세션 ID를 생성합니다.\n    const sessionId = 123456789;\n\n    // 전역 쿼리 파라미터와 프래그먼트를 NavigationExtras 객체타입으로 전달합니다.\n    const navigationExtras: NavigationExtras = {\n      queryParams: { session_id: sessionId },\n      fragment: &#39;anchor&#39;\n    };\n\n    // 로그인 페이지로 이동하면서 인자를 함께 전달합니다.\n    return this.router.createUrlTree([&#39;/login&#39;], navigationExtras);\n  }\n}\n\n\n</code-example>\n\nYou can also preserve query parameters and fragments across navigations without having to provide them again when navigating.\nIn the `LoginComponent`, you'll add an *object* as the second argument in the `router.navigateUrl()` function and provide the `queryParamsHandling` and `preserveFragment` to pass along the current query parameters and fragment to the next route.\n\n<code-example path=\"router/src/app/auth/login/login.component.ts\" header=\"src/app/auth/login/login.component.ts (preserve)\" region=\"preserve\">\n// 전역 쿼리 파라미터와 프래그먼트를 NavigationExtras 객체타입으로 전달합니다.\nconst navigationExtras: NavigationExtras = {\n  queryParamsHandling: &#39;preserve&#39;,\n  preserveFragment: true\n};\n\n// 리다이렉트 합니다.\nthis.router.navigate([redirectUrl], navigationExtras);\n\n</code-example>\n\n<div class=\"alert is-helpful\">\n\nThe `queryParamsHandling` feature also provides a `merge` option, which preserves and combines the current query parameters with any provided query parameters when navigating.\n\n</div>\n\nTo navigate to the Admin Dashboard route after logging in, update `admin-dashboard.component.ts` to handle the\nquery parameters and fragment.\n\n<code-example path=\"router/src/app/admin/admin-dashboard/admin-dashboard.component.1.ts\" header=\"src/app/admin/admin-dashboard/admin-dashboard.component.ts (v2)\">\nimport { Component, OnInit } from &#39;@angular/core&#39;;\nimport { ActivatedRoute } from &#39;@angular/router&#39;;\nimport { Observable } from &#39;rxjs&#39;;\nimport { map } from &#39;rxjs/operators&#39;;\n\n@Component({\n  selector: &#39;app-admin-dashboard&#39;,\n  templateUrl: &#39;./admin-dashboard.component.html&#39;,\n  styleUrls: [&#39;./admin-dashboard.component.css&#39;]\n})\nexport class AdminDashboardComponent implements OnInit {\n  sessionId: Observable&lt;string&gt;;\n  token: Observable&lt;string&gt;;\n\n  constructor(private route: ActivatedRoute) {}\n\n  ngOnInit() {\n    // 세션 ID가 있으면 가져옵니다.\n    this.sessionId = this.route\n      .queryParamMap\n      .pipe(map(params =&gt; params.get(&#39;session_id&#39;) || &#39;None&#39;));\n\n    // 프래그먼트가 있으면 가져옵니다.\n    this.token = this.route\n      .fragment\n      .pipe(map(fragment =&gt; fragment || &#39;None&#39;));\n  }\n}\n\n\n</code-example>\n\nQuery parameters and fragments are also available through the `ActivatedRoute` service.\nJust like route parameters, the query parameters and fragments are provided as an `Observable`.\nThe updated Crisis Admin component feeds the `Observable` directly into the template using the `AsyncPipe`.\n\nNow, you can click on the Admin button, which takes you to the Login page with the provided `queryParamMap` and `fragment`.\nAfter you click the login button, notice that you have been redirected to the `Admin Dashboard` page with the query parameters and fragment still intact in the address bar.\n\nYou can use these persistent bits of information for things that need to be provided across pages like authentication tokens or session ids.\n\n<div class=\"alert is-helpful\">\n\nThe `query params` and `fragment` can also be preserved using a `RouterLink` with\nthe `queryParamsHandling` and `preserveFragment` bindings respectively.\n\n</div>\n-->\n<p><a href=\"guide/router-tutorial-toh#optional-route-parameters\">라우팅 인자</a> 섹션에서는 라우팅 규칙에서 인자를 받아오는 방법만 다뤘습니다.\n하지만 쿼리 인자를 사용해도 라우팅 규칙에서 원하는 인자를 받아올 수 있습니다.</p>\n<p>화면에 있는 엘리먼트 중 <code>id</code> 어트리븉를 추출할 수 있는 엘리먼트를  <a href=\"https://en.wikipedia.org/wiki/Fragment_identifier\">프래그먼트(Fragments)</a>로 전달할 수도 있습니다.</p>\n<p>새로 적용되는 라우팅 규칙에 <code>session_id</code> 쿼리를 활용할 수 있도록 <code>AuthGuard</code>를 수정해 봅시다.</p>\n<p>화면에 표시되는 특정 지점으로 이동하기 위해 앵커(<code>&#x3C;a></code>) 엘리먼트를 추가할 수 있습니다.</p>\n<p><code>/login</code> 라우팅 규칙으로 이동하는 <code>router.navigate()</code> 메서드에 <code><a href=\"api/router/NavigationExtras\" class=\"code-anchor\">NavigationExtras</a></code> 객체를 전달하면 됩니다.</p>\n<code-example path=\"router/src/app/auth/auth.guard.4.ts\" header=\"src/app/auth/auth.guard.ts (v3)\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport {\n  <a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a>, <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,\n  <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>,\n  <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>,\n  <a href=\"api/router/CanActivateChild\" class=\"code-anchor\">CanActivateChild</a>,\n  <a href=\"api/router/NavigationExtras\" class=\"code-anchor\">NavigationExtras</a>,\n  <a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a>\n} from '@angular/router';\nimport { AuthService } from './auth.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class AuthGuard implements <a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a>, <a href=\"api/router/CanActivateChild\" class=\"code-anchor\">CanActivateChild</a> {\n  constructor(private authService: AuthService, private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {}\n\n  canActivate(route: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>, <a href=\"api/animations/state\" class=\"code-anchor\">state</a>: <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>): true|<a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a> {\n    const url: string = state.url;\n\n    return this.checkLogin(url);\n  }\n\n  canActivateChild(route: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>, <a href=\"api/animations/state\" class=\"code-anchor\">state</a>: <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>): true|<a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a> {\n    return this.canActivate(route, <a href=\"api/animations/state\" class=\"code-anchor\">state</a>);\n  }\n\n  checkLogin(url: string): true|<a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a> {\n    if (this.authService.isLoggedIn) { return true; }\n\n    // 리다이렉트할 URL을 저장해 둡니다.\n    this.authService.redirectUrl = url;\n\n    // 더미 세션 ID를 생성합니다.\n    const sessionId = 123456789;\n\n    // 전역 쿼리 파라미터와 프래그먼트를 <a href=\"api/router/NavigationExtras\" class=\"code-anchor\">NavigationExtras</a> 객체타입으로 전달합니다.\n    const navigationExtras: <a href=\"api/router/NavigationExtras\" class=\"code-anchor\">NavigationExtras</a> = {\n      queryParams: { session_id: sessionId },\n      fragment: 'anchor'\n    };\n\n    // 로그인 페이지로 이동하면서 인자를 함께 전달합니다.\n    return this.router.createUrlTree(['/login'], navigationExtras);\n  }\n}\n\n\n</code-example>\n<p>쿼리 인자와 프래그먼트는 네비게이션이 끝나도 없애지 않고 그대로 유지할 수도 있습니다.\n<code>LoginComponent</code>에서 사용하는 <code>router.navigateUrl()</code> 함수의 두 번째 인자로 객체를 전달하면서, 이 객체의 <code>queryParamsHandling</code> 프로퍼티와 <code>preserveFragment</code> 프로퍼티를 지정하면 현재 화면에 진입하면서 사용된 쿼리 인자와 프래그먼트를 다음 라우팅 규칙에도 적용하도록 유지할 수 있습니다.</p>\n<code-example path=\"router/src/app/auth/login/login.component.ts\" header=\"src/app/auth/login/login.component.ts (쿼리 인자 유지하기)\" region=\"preserve\">\n// 전역 쿼리 파라미터와 프래그먼트를 <a href=\"api/router/NavigationExtras\" class=\"code-anchor\">NavigationExtras</a> 객체타입으로 전달합니다.\nconst navigationExtras: <a href=\"api/router/NavigationExtras\" class=\"code-anchor\">NavigationExtras</a> = {\n  queryParamsHandling: 'preserve',\n  preserveFragment: true\n};\n\n// 리다이렉트 합니다.\nthis.router.navigate([redirectUrl], navigationExtras);\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p><code>queryParamsHandling</code> 기능을 사용할 때 기존에 존재하는 쿼리 인자와 현재 쿼리 인자를 합치는 <code>merge</code> 옵션을 사용할 수도 있습니다.</p>\n</div>\n<p>로그인한 후에 관리자 대시보드로 이동하기 할 때 쿼리 인자와 프래그먼트를 처리할 수 있도록 <code>admin-dashboard.component.ts</code> 코드를 수정해 봅시다.</p>\n<code-example path=\"router/src/app/admin/admin-dashboard/admin-dashboard.component.1.ts\" header=\"src/app/admin/admin-dashboard/admin-dashboard.component.ts (v2)\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-admin-dashboard',\n  templateUrl: './admin-dashboard.component.html',\n  styleUrls: ['./admin-dashboard.component.css']\n})\nexport class AdminDashboardComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  sessionId: Observable&#x3C;string>;\n  token: Observable&#x3C;string>;\n\n  constructor(private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>) {}\n\n  ngOnInit() {\n    // 세션 ID가 있으면 가져옵니다.\n    this.sessionId = this.route\n      .queryParamMap\n      .pipe(map(params => params.get('session_id') || 'None'));\n\n    // 프래그먼트가 있으면 가져옵니다.\n    this.token = this.route\n      .fragment\n      .pipe(map(fragment => fragment || 'None'));\n  }\n}\n\n\n</code-example>\n<p>쿼리 인자와 프랙먼트는 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 서비스 안에서도 참조할 수 있습니다.\n라우팅 인자와 비슷하게, 쿼리 인자와 프래그먼트도 <code>Observable</code> 타입으로 제공됩니다.\n위기대응센터 관리자 컴포넌트에서는 템플릿에서 <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">AsyncPipe</a></code>를 사용해서 옵저버블을 직접 처리합니다.</p>\n<p>이제 사용자가 \"Admin\" 버튼을 클릭하면 로그인 화면으로 이동하면서 <code>queryParamMap</code>과 <code>fragment</code>에 접근합니다.\n그리고 로그인 화면에서 로그인 버튼을 클릭하면 저장해둔 쿼리 인자와 프래그먼트를 사용해서 관리자 대시보드로 이동하며, 이 정보는 브라우저 주소표시줄에서도 확인할 수 있습니다.</p>\n<p>인증 토큰이나 세션 ID와 같이 여러 화면에 사용되는 정보라면 이런 식으로 유지하는 것도 좋습니다.</p>\n<div class=\"alert is-helpful\">\n<p>쿼리 인자와 프래그먼트를 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>에 사용하려면 각각 <code>queryParamsHandling</code>, <code>preserveFragment</code> 바인딩을 추가하면 됩니다.</p>\n</div>\n<a id=\"asynchronous-routing\"></a>\n<!--\n## Milestone 6: Asynchronous routing\n-->\n<h2 id=\"마일스톤-6-비동기-라우팅\">마일스톤 6: 비동기 라우팅<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#마일스톤-6-비동기-라우팅\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nAs you've worked through the milestones, the application has naturally gotten larger.\nAt some point you'll reach a point where the application takes a long time to load.\n\nTo remedy this issue, use asynchronous routing, which loads feature modules lazily, on request.\nLazy loading has multiple benefits.\n\n* You can load feature areas only when requested by the user.\n* You can speed up load time for users that only visit certain areas of the application.\n* You can continue expanding lazy loaded feature areas without increasing the size of the initial load bundle.\n\nYou're already part of the way there.\nBy organizing the application into modules&mdash;`AppModule`,\n`HeroesModule`, `AdminModule` and `CrisisCenterModule`&mdash;you\nhave natural candidates for lazy loading.\n\nSome modules, like `AppModule`, must be loaded from the start.\nBut others can and should be lazy loaded.\nThe `AdminModule`, for example, is needed by a few authorized users, so\nyou should only load it when requested by the right people.\n-->\n<p>지금까지 몇 개 마일스톤을 거쳐오면서 애플리케이션의 크기는 자연스럽게 커졌습니다.\n이제는 애플리케이션이 실행되기까지 시간이 좀 더 걸린다는 것을 느낄 수도 있습니다.</p>\n<p>이 문제를 해결하려면 비동기 라우팅을 활용해서 기능 모듈을 필요할 때 지연로딩하면 됩니다.\n모듈을 지연로딩하면 얻는 장점이 몇가지 있습니다.</p>\n<ul>\n<li>사용자에게 필요한 기능 모듈만 로드할 수 있습니다.</li>\n<li>애플리케이션 특정 기능만 사용하는 사용자라면 애플리케이션 실행 속도를 향상시킬 수 있습니다.</li>\n<li>초기 실행에 필요한 빌드 결과물을 기반으로 이후에 필요한 모듈을 확장하는 방식으로 실행할 수 있습니다.</li>\n</ul>\n<p>이 방식은 이미 일부 다뤘습니다.\n애플리케이션을 <code>AppModule</code>, <code>HeroesModule</code>, <code>AdminModule</code>, <code>CrisisCenterModule</code>로 나누고 나면, 각 모듈을 지연로딩할 것인지 자연스럽게 지정할 수 있습니다.</p>\n<p><code>AppModule</code>은 애플리케이션이 시작될 때 로딩되어야 합니다.\n하지만 나머지 모듈은 지연로딩할 수 있으며, 지연로딩을 권장하기도 합니다.\n<code>AdminModule</code>을 생각해보면, 이 모듈은 권한이 있는 일부 사용자에게만 필요한 모듈입니다.\n그렇다면 권한이 있는 사용자만 이 모듈을 로드하는 것이 합리적입니다.</p>\n<a id=\"lazy-loading-route-config\"></a>\n<!--\n### Lazy Loading route configuration\n-->\n<h3 id=\"지연로딩-라우팅-환경설정\">지연로딩 라우팅 환경설정<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#지연로딩-라우팅-환경설정\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nChange the `admin` path in the `admin-routing.module.ts` from `'admin'` to an empty string, `''`, the empty path.\n\nUse empty path routes to group routes together without adding any additional path segments to the URL.\nUsers will still visit `/admin` and the `AdminComponent` still serves as the Routing Component containing child routes.\n\nOpen the `AppRoutingModule` and add a new `admin` route to its `appRoutes` array.\n\nGive it a `loadChildren` property instead of a `children` property.\nThe `loadChildren` property takes a function that returns a promise using the browser's built-in syntax for lazy loading code using dynamic imports `import('...')`.\nThe path is the location of the `AdminModule` (relative to the app root).\nAfter the code is requested and loaded, the `Promise` resolves an object that contains the `NgModule`, in this case the `AdminModule`.\n\n<code-example path=\"router/src/app/app-routing.module.5.ts\" region=\"admin-1\" header=\"app-routing.module.ts (load children)\">\n{\n  path: &#39;admin&#39;,\n  loadChildren: () =&gt; import(&#39;./admin/admin.module&#39;).then(m =&gt; m.AdminModule),\n},\n\n</code-example>\n\n<div class=\"alert is-important\">\n\n*Note*: When using absolute paths, the `NgModule` file location must begin with `src/app` in order to resolve correctly. For custom [path mapping with absolute paths](https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping), you must configure the `baseUrl` and `paths` properties in the project `tsconfig.json`.\n\n</div>\n\nWhen the router navigates to this route, it uses the `loadChildren` string to dynamically load the `AdminModule`.\nThen it adds the `AdminModule` routes to its current route configuration.\nFinally, it loads the requested route to the destination admin component.\n\nThe lazy loading and re-configuration happen just once, when the route is first requested; the module and routes are available immediately for subsequent requests.\n\n\n<div class=\"alert is-helpful\">\n\nAngular provides a built-in module loader that supports SystemJS to load modules asynchronously. If you were\nusing another bundling tool, such as Webpack, you would use the Webpack mechanism for asynchronously loading modules.\n\n</div>\n\nTake the final step and detach the admin feature set from the main application.\nThe root `AppModule` must neither load nor reference the `AdminModule` or its files.\n\nIn `app.module.ts`, remove the `AdminModule` import statement from the top of the file\nand remove the `AdminModule` from the NgModule's `imports` array.\n-->\n<p><code>admin-routing.module.ts</code> 파일에서 <code>admin</code>에 해당하는 경로를 빈 문자열 <code>''</code> 주소로 변경해 봅시다.</p>\n<p>라우팅 규칙에 빈 문자열을 주소로 사용하는 방식은 해당 라우팅 규칙 하위 계층에 있는 라우팅 규칙을 그룹화 하는 방식입니다.\n주소를 바꿔도 사용자는 여전히 <code>/admin</code> 주소에 접근해서 <code>AdminComponent</code>를 확인할 수 있으며, 관리자 모듈의 자식 컴포넌트도 이 컴포넌트에 표시됩니다.</p>\n<p><code>AppRoutingModule</code> 파일을 열고 <code>admin</code>으로 연결되는 라우팅 규칙을 <code>appRoutes</code> 배열에 추가해 봅시다.</p>\n<p>이 때 <code>children</code> 프로퍼티 대신 <code>loadChildren</code> 프로퍼티를 사용해 봅시다.\n<code>loadChildren</code> 프로퍼티는 함수는 인자로 받는데, 이 함수는 브라우저가 제공하는 동적 로딩 기능을 활용해서 <code>import('...')</code>라는 코드를 프라미스 형태로 반환합니다.\n이 라우팅 규칙의 주소는 <code>AdminModule</code>에 해당하는 주소를 지정합니다.\n앱 최상위 주소를 기준으로 상대주소로 지정합니다.\n이제 이 코드가 사용되면 <code>Promise</code>가 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>을 반환합니다.\n이 경우에 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>은 <code>AdminModule</code>입니다.</p>\n<code-example path=\"router/src/app/app-routing.module.5.ts\" region=\"admin-1\" header=\"app-routing.module.ts (모듈 지연 로딩)\">\n{\n  path: 'admin',\n  loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule),\n},\n\n</code-example>\n<div class=\"alert is-important\">\n<p><em>참고</em>: 절대주소를 사용하면 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 파일 위치를 지정할 때 <code>src/app</code>부터 시작하는 경로로 지정해야 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>을 제대로 로드할 수 있습니다.\n<a href=\"https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping\">절대주소로 경로 맵핑하기</a> 문서에서 확인할 수 있듯이, <code>baseUrl</code>과 <code>paths</code> 프로퍼티는 프로젝트의 <code>tsconfig.json</code> 설정의 영향을 받습니다.</p>\n</div>\n<p>이제 라우터가 해당 라우팅 규칙을 적용하는 시점이 되면 <code>loadChildren</code> 설정에 따라 <code>AdminModule</code>을 동적으로 로드합니다.\n그리고 <code>AdminModule</code>을 로드한 이후에는 <code>AdminModule</code>의 라우팅 규칙이 현재 애플리케이션의 라우팅 규칙 환경설정에 통합됩니다.\n결국 최종 목적지는 <code>AdminComponent</code>가 됩니다.</p>\n<p>모듈을 지연로딩하고 기존 라우팅 규칙과 합치는 과정은 해당 라우팅 규칙이 요청되었을 때 딱 한 번만 실행됩니다.\n이후에는 원래부터 있던 모듈처럼 동작합니다.</p>\n<div class=\"alert is-helpful\">\n<p>Angular도 SystemJS를 활용해서 모듈을 비동기로 로드하는 방식을 기본으로 제공합니다.\nWebpack과 같은 번들링 툴을 사용한다면 해당 번들링 툴에 맞는 방식으로 모듈을 지연로딩하는 것이 좋습니다.</p>\n</div>\n<p>이제 마지막 단계로 관리자 모듈을 메인 애플리케이션에서 완전히 분리해 봅시다.\n최상위 <code>AppModule</code>은 이제 더이상 <code>AdminModule</code>이나 이 모듈에 있는 파일을 참조하지 않습니다.</p>\n<p><code>app.module.ts</code> 파일에서 <code>AdminModule</code>을 로드하는 코드를 제거하고 <code>imports</code> 배열에도 <code>AdminModule</code>을 제거하세요.</p>\n<a id=\"can-load-guard\"></a>\n<!--\n### `CanLoad`: guarding unauthorized loading of feature modules\n-->\n<h3 id=\"canload-권한없는-사용자가-모듈-로딩하는-것을-제한하기\"><code><a href=\"api/router/CanLoad\" class=\"code-anchor\">CanLoad</a></code>: 권한없는 사용자가 모듈 로딩하는 것을 제한하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#canload-권한없는-사용자가-모듈-로딩하는-것을-제한하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou're already protecting the `AdminModule` with a `CanActivate` guard that prevents unauthorized users from accessing the admin feature area.\nIt redirects to the login page if the user is not authorized.\n\nBut the router is still loading the `AdminModule` even if the user can't visit any of its components.\nIdeally, you'd only load the `AdminModule` if the user is logged in.\n\nAdd a `CanLoad` guard that only loads the `AdminModule` once the user is logged in _and_ attempts to access the admin feature area.\n\nThe existing `AuthGuard` already has the essential logic in its `checkLogin()` method to support the `CanLoad` guard.\n\nOpen `auth.guard.ts`.\nImport the `CanLoad` interface from `@angular/router`.\nAdd it to the `AuthGuard` class's `implements` list.\nThen implement `canLoad()` as follows:\n\n<code-example path=\"router/src/app/auth/auth.guard.ts\" header=\"src/app/auth/auth.guard.ts (CanLoad guard)\" region=\"canLoad\">\ncanLoad(route: Route): boolean {\n  const url = `/${route.path}`;\n\n  return this.checkLogin(url);\n}\n\n</code-example>\n\nThe router sets the `canLoad()` method's `route` parameter to the intended destination URL.\nThe `checkLogin()` method redirects to that URL once the user has logged in.\n\nNow import the `AuthGuard` into the `AppRoutingModule` and add the `AuthGuard` to the `canLoad`\narray property for the `admin` route.\nThe completed admin route looks like this:\n\n<code-example path=\"router/src/app/app-routing.module.5.ts\" region=\"admin\" header=\"app-routing.module.ts (lazy admin route)\">\n{\n  path: &#39;admin&#39;,\n  loadChildren: () =&gt; import(&#39;./admin/admin.module&#39;).then(m =&gt; m.AdminModule),\n  canLoad: [AuthGuard]\n},\n\n</code-example>\n-->\n<p>지금도 <code>AdminModule</code>이 <code><a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a></code> 가드로 보호되고 있긴 합니다.\n<code><a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a></code> 가드는 권한이 없는 사용자가 관리자 모듈에 접근하는 것을 막는 라우팅 가드입니다.</p>\n<p>하지만 <code><a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a></code>만 사용하면 사용자가 <code>AdminModule</code>에 있는 컴포넌트를 사용하지 않아도 <code>AdminModule</code>을 로드합니다.\n사용자가 로그인하지 않은 상태라면 <code>AdminModule</code>을 아예 로드하지 않는 것이 가장 좋습니다.</p>\n<p>이런 경우에 <code><a href=\"api/router/CanLoad\" class=\"code-anchor\">CanLoad</a></code> 가드를 사용하면 사용자가 로그인하고, 관리자 모듈에 대한 권한이 있을 때만 <code>AdminModule</code>을 로드합니다.</p>\n<p>이전에 작성한 <code>AuthGuard</code>에는 <code><a href=\"api/router/CanLoad\" class=\"code-anchor\">CanLoad</a></code> 가드를 사용에 사용할 수 있는 <code>checkLogin()</code> 메서드가 이미 구현되어 있습니다.</p>\n<p><code>auth.guard.ts</code> 파일을 엽니다.\n<code>@angular/router</code> 패키지로 제공되는 <code><a href=\"api/router/CanLoad\" class=\"code-anchor\">CanLoad</a></code> 인터페이스를 로드합니다.\n이 인터페이스를 <code>AuthGuard</code> 클래스의 <code>implements</code> 목록에 추가합니다.\n그리고 <code>canLoad()</code> 메서드를 이렇게 정의하면 됩니다:</p>\n<code-example path=\"router/src/app/auth/auth.guard.ts\" header=\"src/app/auth/auth.guard.ts (CanLoad 가드)\" region=\"canLoad\">\ncanLoad(route: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>): boolean {\n  const url = `/${route.path}`;\n\n  return this.checkLogin(url);\n}\n\n</code-example>\n<p>라우터는 <code>canLoad()</code> 메서드가 정의한대로 <code>route</code>로 전달되는 인자에 따라 최종 URL을 결정합니다.\n<code>checkLogin()</code> 메서드는 사용자가 로그인했을 때 해당 URL로 리다이렉션하는 메서드입니다.</p>\n<p>이제 <code>AppRoutingModule</code>에 <code>AuthGuard</code>를 로드하고 <code>AuthGuard</code>를 <code>canLoad</code> 배열에 추가합니다.\n여기까지 작성하고 나면 <code>admin</code> 주소에 해당하는 라우팅 규칙이 이렇게 마무리됩니다:</p>\n<code-example path=\"router/src/app/app-routing.module.5.ts\" region=\"admin\" header=\"app-routing.module.ts (지연로딩되는 admin 라우팅 규칙)\">\n{\n  path: 'admin',\n  loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule),\n  canLoad: [AuthGuard]\n},\n\n</code-example>\n<a id=\"preloading\"></a>\n<a id=\"preloading-background-loading-of-feature-areas\"></a>\n<!--\n### Preloading: background loading of feature areas\n-->\n<h3 id=\"사전로딩-백그라운드에서-모듈-로딩하기\">사전로딩: 백그라운드에서 모듈 로딩하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#사전로딩-백그라운드에서-모듈-로딩하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn addition to loading modules on-demand, you can load modules asynchronously with preloading.\n\nThe `AppModule` is eagerly loaded when the application starts, meaning that it loads right away.\nNow the `AdminModule` loads only when the user clicks on a link, which is called lazy loading.\n\nPreloading allows you to load modules in the background so that the data is ready to render when the user activates a particular route.\nConsider the Crisis Center.\nIt isn't the first view that a user sees.\nBy default, the Heroes are the first view.\nFor the smallest initial payload and fastest launch time, you should eagerly load the `AppModule` and the `HeroesModule`.\n\nYou could lazy load the Crisis Center.\nBut you're almost certain that the user will visit the Crisis Center within minutes of launching the app.\nIdeally, the app would launch with just the `AppModule` and the `HeroesModule` loaded and then, almost immediately, load the `CrisisCenterModule` in the background.\nBy the time the user navigates to the Crisis Center, its module will have been loaded and ready.\n-->\n<p>모듈이 필요할 때 지연로딩할 수 있는 것처럼, 모듈을 미리 로드해둘 수도 있습니다.</p>\n<p><code>AppModule</code>은 애플리케이션이 시작되는 시점에 로드되기 때문에 즉시 로드된다고 볼 수 있습니다.\n하지만 <code>AdminModule</code>은 사용자가 링크를 클릭했을 때 지연로딩됩니다.</p>\n<p>모듈을 백그라운드에서 사전에 로딩하는 것은 사용자가 해당 모듈로 화면을 전환할 때 필요한 데이터를 미리 로딩해두는 것과 같습니다.\n위기대응센터를 생각해 봅시다.\n이 모듈은 사용자가 제일 처음 접하는 화면이 아닙니다.\n사용자가 처음 보는 화면은 히어로 목록이 표시되는 화면입니다.\n따라서 실행에 필요한 애플리케이션 용량을 최소한으로 유지하면서 빠르게 실행하려면 <code>AppModule</code>과 <code>HeroesModule</code>을 즉시 로드하는 것이 타당합니다.</p>\n<p>위기대응센터 모듈은 지연로딩할 수 있습니다.\n그런데 대부분의 사용자가 위기대응센터에 방문한다고 하면 <code>AppModule</code>과 <code>HeroesModule</code>을 로드한 채로 애플리케이션을 실행한 직후에 <code>CrisisCenterModule</code>을 백그라운드에서 로드하는 것이 좋습니다.\n애플리케이션을 실행한 후에 사용자가 위기대응센터로 이동하게 되면 모듈은 이미 로드된 상태이기 때문에 화면 전환을 요청한 시점에 바로 접근할 수 있습니다.</p>\n<a id=\"how-preloading\"></a>\n<!--\n#### How preloading works\n-->\n<h4 id=\"사전로딩이-동작하는-방식\">사전로딩이 동작하는 방식<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#사전로딩이-동작하는-방식\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nAfter each successful navigation, the router looks in its configuration for an unloaded module that it can preload.\nWhether it preloads a module, and which modules it preloads, depends upon the preload strategy.\n\nThe `Router` offers two preloading strategies:\n\n* No preloading, which is the default. Lazy loaded feature areas are still loaded on-demand.\n* Preloading of all lazy loaded feature areas.\n\nThe router either never preloads, or preloads every lazy loaded module.\nThe `Router` also supports [custom preloading strategies](#custom-preloading) for fine control over which modules to preload and when.\n\nThis section guides you through updating the `CrisisCenterModule` to load lazily by default and use the `PreloadAllModules` strategy to load all lazy loaded modules.\n-->\n<p>네비게이션 동작이 성공적으로 끝나면 라우터는 환경설정을 살펴보고 사전로딩해야 하는 모듈 중에 아직 로드되지 않은 모듈을 찾습니다.\n이 때 사전로딩해야 하는 모듈을 찾으면 사전로딩 정책에 따라 모듈을 사전로딩합니다.</p>\n<p><code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>가 제공하는 사전로딩 정책은 2가지 입니다:</p>\n<ul>\n<li>기본값은 사전로딩하지 않습니다. 지연로딩 대상 모듈은 필요할 때만 로드됩니다.</li>\n<li>지연로딩 대상 모듈을 모두 사전로딩합니다.</li>\n</ul>\n<p>라우터는 사전로딩을 사용하지 않거나 모든 지연로딩 대상 모듈을 사전로딩합니다.\n그리고 특별한 조작이 필요한 경우를 위해 <a href=\"guide/router-tutorial-toh#custom-preloading\">커스텀 사전로딩 정책</a>을 사용할 수도 있습니다.</p>\n<p>이번 섹션에서는 <code>CrisisCenterModule</code>이 지연로딩되도록 수정한 후에 <code><a href=\"api/router/PreloadAllModules\" class=\"code-anchor\">PreloadAllModules</a></code> 정책을 사용해서 지연로딩 대상 모듈을 모두 사전로딩해 봅시다.</p>\n<a id=\"lazy-load-crisis-center\"></a>\n<!--\n#### Lazy load the crisis center\n-->\n<h4 id=\"위기대응센터-지연로딩하기\">위기대응센터 지연로딩하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#위기대응센터-지연로딩하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nUpdate the route configuration to lazy load the `CrisisCenterModule`.\nTake the same steps you used to configure `AdminModule` for lazy loading.\n\n1. Change the `crisis-center` path in the `CrisisCenterRoutingModule` to an empty string.\n\n1. Add a `crisis-center` route to the `AppRoutingModule`.\n\n1. Set the `loadChildren` string to load the `CrisisCenterModule`.\n\n1. Remove all mention of the `CrisisCenterModule` from `app.module.ts`.\n\n\nHere are the updated modules _before enabling preload_:\n\n\n<code-tabs>\n\n  <code-pane header=\"app.module.ts\" path=\"router/src/app/app.module.ts\" region=\"preload\">\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { BrowserModule } from &#39;@angular/platform-browser&#39;;\nimport { FormsModule } from &#39;@angular/forms&#39;;\nimport { BrowserAnimationsModule } from &#39;@angular/platform-browser/animations&#39;;\n\nimport { Router } from &#39;@angular/router&#39;;\n\nimport { AppComponent } from &#39;./app.component&#39;;\nimport { PageNotFoundComponent } from &#39;./page-not-found/page-not-found.component&#39;;\nimport { ComposeMessageComponent } from &#39;./compose-message/compose-message.component&#39;;\n\nimport { AppRoutingModule } from &#39;./app-routing.module&#39;;\nimport { HeroesModule } from &#39;./heroes/heroes.module&#39;;\nimport { AuthModule } from &#39;./auth/auth.module&#39;;\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    BrowserAnimationsModule,\n    FormsModule,\n    HeroesModule,\n    AuthModule,\n    AppRoutingModule,\n  ],\n  declarations: [\n    AppComponent,\n    ComposeMessageComponent,\n    PageNotFoundComponent\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule {\n}\n\n</code-pane>\n\n  <code-pane header=\"app-routing.module.ts\" path=\"router/src/app/app-routing.module.6.ts\" region=\"preload-v1\">\nimport { NgModule } from &#39;@angular/core&#39;;\nimport {\n  RouterModule, Routes,\n} from &#39;@angular/router&#39;;\n\nimport { ComposeMessageComponent } from &#39;./compose-message/compose-message.component&#39;;\nimport { PageNotFoundComponent } from &#39;./page-not-found/page-not-found.component&#39;;\n\nimport { AuthGuard } from &#39;./auth/auth.guard&#39;;\n\nconst appRoutes: Routes = [\n  {\n    path: &#39;compose&#39;,\n    component: ComposeMessageComponent,\n    outlet: &#39;popup&#39;\n  },\n  {\n    path: &#39;admin&#39;,\n    loadChildren: () =&gt; import(&#39;./admin/admin.module&#39;).then(m =&gt; m.AdminModule),\n    canLoad: [AuthGuard]\n  },\n  {\n    path: &#39;crisis-center&#39;,\n    loadChildren: () =&gt; import(&#39;./crisis-center/crisis-center.module&#39;).then(m =&gt; m.CrisisCenterModule)\n  },\n  { path: &#39;&#39;,   redirectTo: &#39;/heroes&#39;, pathMatch: &#39;full&#39; },\n  { path: &#39;**&#39;, component: PageNotFoundComponent }\n];\n\n@NgModule({\n  imports: [\n    RouterModule.forRoot(\n      appRoutes,\n    )\n  ],\n  exports: [\n    RouterModule\n  ]\n})\nexport class AppRoutingModule {}\n\n\n</code-pane>\n\n  <code-pane header=\"crisis-center-routing.module.ts\" path=\"router/src/app/crisis-center/crisis-center-routing.module.ts\">\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { RouterModule, Routes } from &#39;@angular/router&#39;;\n\nimport { CrisisCenterHomeComponent } from &#39;./crisis-center-home/crisis-center-home.component&#39;;\nimport { CrisisListComponent } from &#39;./crisis-list/crisis-list.component&#39;;\nimport { CrisisCenterComponent } from &#39;./crisis-center/crisis-center.component&#39;;\nimport { CrisisDetailComponent } from &#39;./crisis-detail/crisis-detail.component&#39;;\n\nimport { CanDeactivateGuard } from &#39;../can-deactivate.guard&#39;;\nimport { CrisisDetailResolverService } from &#39;./crisis-detail-resolver.service&#39;;\n\nconst crisisCenterRoutes: Routes = [\n  {\n    path: &#39;&#39;,\n    component: CrisisCenterComponent,\n    children: [\n      {\n        path: &#39;&#39;,\n        component: CrisisListComponent,\n        children: [\n          {\n            path: &#39;:id&#39;,\n            component: CrisisDetailComponent,\n            canDeactivate: [CanDeactivateGuard],\n            resolve: {\n              crisis: CrisisDetailResolverService\n            }\n          },\n          {\n            path: &#39;&#39;,\n            component: CrisisCenterHomeComponent\n          }\n        ]\n      }\n    ]\n  }\n];\n\n@NgModule({\n  imports: [\n    RouterModule.forChild(crisisCenterRoutes)\n  ],\n  exports: [\n    RouterModule\n  ]\n})\nexport class CrisisCenterRoutingModule { }\n\n</code-pane>\n\n</code-tabs>\n\nYou could try this now and confirm that the  `CrisisCenterModule` loads after you click the \"Crisis Center\" button.\n\nTo enable preloading of all lazy loaded modules, import the `PreloadAllModules` token from the Angular router package.\n\nThe second argument in the `RouterModule.forRoot()` method takes an object for additional configuration options.\nThe `preloadingStrategy` is one of those options.\nAdd the `PreloadAllModules` token to the `forRoot()` call:\n\n<code-example path=\"router/src/app/app-routing.module.6.ts\" header=\"src/app/app-routing.module.ts (preload all)\" region=\"forRoot\">\nRouterModule.forRoot(\n  appRoutes,\n  {\n    enableTracing: true, // &lt;-- 디버그 활성화\n    preloadingStrategy: PreloadAllModules\n  }\n)\n\n</code-example>\n\nThis configures the `Router` preloader to immediately load all lazy loaded routes (routes with a `loadChildren` property).\n\nWhen you visit `http://localhost:4200`, the `/heroes` route loads immediately upon launch and the router starts loading the `CrisisCenterModule` right after the `HeroesModule` loads.\n\nCurrently, the `AdminModule` does not preload because `CanLoad` is blocking it.\n-->\n<p>라우팅 규칙을 변경해서 <code>CrisisCenterModule</code>를 지연로딩하도록 수정해 봅시다.\n이 과정은 <code>AdminModule</code>에 지연로딩을 적용할 때와 같습니다.</p>\n<ol>\n<li>\n<p><code>CrisisCenterRoutingModule</code>에 지정한 <code>crisis-center</code> 주소를 빈 문자열로 변경합니다.</p>\n</li>\n<li>\n<p><code>AppRoutingModule</code>에 <code>crisis-center</code> 라우팅 규칙을 추가합니다.</p>\n</li>\n<li>\n<p><code>loadChildren</code> 프로퍼티를 추가하고 <code>CrisisCenterModule</code>을 지정합니다.</p>\n</li>\n<li>\n<p><code>app.module.ts</code> 파일에 있는 <code>CrisisCenterModule</code> 관련 코드를 제거합니다.</p>\n</li>\n</ol>\n<p>여기까지 작성하면 <em>사전로딩을 할 준비</em> 는 끝났습니다:</p>\n<code-tabs>\n\n  <code-pane header=\"app.module.ts\" path=\"router/src/app/app.module.ts\" region=\"preload\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { <a href=\"api/platform-browser/animations/BrowserAnimationsModule\" class=\"code-anchor\">BrowserAnimationsModule</a> } from '@angular/platform-browser/animations';\n\nimport { <a href=\"api/router/Router\" class=\"code-anchor\">Router</a> } from '@angular/router';\n\nimport { AppComponent } from './app.component';\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\nimport { ComposeMessageComponent } from './compose-message/compose-message.component';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { HeroesModule } from './heroes/heroes.module';\nimport { AuthModule } from './auth/auth.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/platform-browser/animations/BrowserAnimationsModule\" class=\"code-anchor\">BrowserAnimationsModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    HeroesModule,\n    AuthModule,\n    AppRoutingModule,\n  ],\n  declarations: [\n    AppComponent,\n    ComposeMessageComponent,\n    PageNotFoundComponent\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule {\n}\n\n</code-pane>\n\n  <code-pane header=\"app-routing.module.ts\" path=\"router/src/app/app-routing.module.6.ts\" region=\"preload-v1\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport {\n  <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a>,\n} from '@angular/router';\n\nimport { ComposeMessageComponent } from './compose-message/compose-message.component';\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\n\nimport { AuthGuard } from './auth/auth.guard';\n\nconst appRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'compose',\n    component: ComposeMessageComponent,\n    outlet: 'popup'\n  },\n  {\n    path: 'admin',\n    loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule),\n    canLoad: [AuthGuard]\n  },\n  {\n    path: 'crisis-center',\n    loadChildren: () => import('./crisis-center/crisis-center.module').then(m => m.CrisisCenterModule)\n  },\n  { path: '',   redirectTo: '/heroes', pathMatch: 'full' },\n  { path: '**', component: PageNotFoundComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forRoot(\n      appRoutes,\n    )\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class AppRoutingModule {}\n\n\n</code-pane>\n\n  <code-pane header=\"crisis-center-routing.module.ts\" path=\"router/src/app/crisis-center/crisis-center-routing.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { CrisisCenterHomeComponent } from './crisis-center-home/crisis-center-home.component';\nimport { CrisisListComponent } from './crisis-list/crisis-list.component';\nimport { CrisisCenterComponent } from './crisis-center/crisis-center.component';\nimport { CrisisDetailComponent } from './crisis-detail/crisis-detail.component';\n\nimport { CanDeactivateGuard } from '../can-deactivate.guard';\nimport { CrisisDetailResolverService } from './crisis-detail-resolver.service';\n\nconst crisisCenterRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: '',\n    component: CrisisCenterComponent,\n    children: [\n      {\n        path: '',\n        component: CrisisListComponent,\n        children: [\n          {\n            path: ':id',\n            component: CrisisDetailComponent,\n            canDeactivate: [CanDeactivateGuard],\n            resolve: {\n              crisis: CrisisDetailResolverService\n            }\n          },\n          {\n            path: '',\n            component: CrisisCenterHomeComponent\n          }\n        ]\n      }\n    ]\n  }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forChild(crisisCenterRoutes)\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class CrisisCenterRoutingModule { }\n\n</code-pane>\n\n</code-tabs>\n<p>이렇게 수정하면 사용자가 \"Crisis Center\" 버튼을 클릭했을 때 <code>CrisisCenterModule</code>을 동적으로 로드하고 화면을 전환합니다.</p>\n<p>이제 지연로딩 대상 모듈을 모두 사전로딩하기 위해 Angular 라우터 패키지로 제공되는 <code><a href=\"api/router/PreloadAllModules\" class=\"code-anchor\">PreloadAllModules</a></code> 토큰을 로드합니다.</p>\n<p><code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 메서드는 두 번째 인자로 추가 환경설정 옵션을 받습니다.\n<code>preloadingStrategy</code>도 이 때 설정할 수 있는 옵션 중 하나입니다.\n<code>forRoot()</code>를 실행할 때 이렇게 인자를 지정하면 됩니다:</p>\n<code-example path=\"router/src/app/app-routing.module.6.ts\" header=\"src/app/app-routing.module.ts (모두 사전로딩하기)\" region=\"forRoot\">\nRouterModule.forRoot(\n  appRoutes,\n  {\n    enableTracing: true, // &#x3C;-- 디버그 활성화\n    preloadingStrategy: <a href=\"api/router/PreloadAllModules\" class=\"code-anchor\">PreloadAllModules</a>\n  }\n)\n\n</code-example>\n<p>이렇게 설정하면 애플리케이션이 실행된 후에 지연로딩해야 하는 모듈을 모두 사전로딩합니다.</p>\n<p>그래서 <code>http://localhost:4200</code>이나 <code>/heroes</code> 주소에 접근하면 라우터가 <code>HeroesModule</code>을 로드한 후에 <code>CrisisCenterModule</code>을 로드합니다.</p>\n<p>다만, <code>AdminModule</code>은 <code><a href=\"api/router/CanLoad\" class=\"code-anchor\">CanLoad</a></code>로 보호되고 있기 때문에 사전로딩되지 않습니다.</p>\n<a id=\"preload-canload\"></a>\n<!--\n#### `CanLoad` blocks preload\n-->\n<h4 id=\"canload는-사전로딩을-막습니다\"><code><a href=\"api/router/CanLoad\" class=\"code-anchor\">CanLoad</a></code>는 사전로딩을 막습니다.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#canload는-사전로딩을-막습니다\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe `PreloadAllModules` strategy does not load feature areas protected by a [CanLoad](#can-load-guard) guard.\n\nYou added a `CanLoad` guard to the route in the `AdminModule` a few steps back to block loading of that module until the user is authorized.\nThat `CanLoad` guard takes precedence over the preload strategy.\n\nIf you want to preload a module as well as guard against unauthorized access, remove the `canLoad()` guard method and rely on the [canActivate()](#can-activate-guard) guard alone.\n-->\n<p><code><a href=\"api/router/PreloadAllModules\" class=\"code-anchor\">PreloadAllModules</a></code> 정책을 지정해도 <a href=\"guide/router-tutorial-toh#can-load-guard\">CanLoad</a> 가드가 보호하는 모듈은 사전로딩하지 않습니다.</p>\n<p><code>AdminModule</code> 라우팅 규칙은 로그인하지 않은 사용자가 접근하는 것을 막기 위해 <code><a href=\"api/router/CanLoad\" class=\"code-anchor\">CanLoad</a></code> 가드가 사용되었습니다.\n이 때 <code><a href=\"api/router/CanLoad\" class=\"code-anchor\">CanLoad</a></code> 가드는 사전로딩 정책보다 우선 순위로 동작합니다.</p>\n<p>그래서 로그인하지 않은 사용자를 막으면서 사전로딩도 하려면 <code>canLoad()</code> 가드 메서드를 제거하고 <a href=\"guide/router-tutorial-toh#can-activate-guard\"><code>canActivate()</code></a> 가드만 사용해야 합니다.</p>\n<a id=\"custom-preloading\"></a>\n<!--\n### Custom Preloading Strategy\n-->\n<h3 id=\"커스텀-사전로딩-정책\">커스텀 사전로딩 정책<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#커스텀-사전로딩-정책\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nPreloading every lazy loaded module works well in many situations.\nHowever, in consideration of things such as low bandwidth and user metrics, you can use a custom preloading strategy for specific feature modules.\n\nThis section guides you through adding a custom strategy that only preloads routes whose `data.preload` flag is set to `true`.\nRecall that you can add anything to the `data` property of a route.\n\nSet the `data.preload` flag in the `crisis-center` route in the `AppRoutingModule`.\n\n<code-example path=\"router/src/app/app-routing.module.ts\" header=\"src/app/app-routing.module.ts (route data preload)\" region=\"preload-v2\">\n{\n  path: &#39;crisis-center&#39;,\n  loadChildren: () =&gt; import(&#39;./crisis-center/crisis-center.module&#39;).then(m =&gt; m.CrisisCenterModule),\n  data: { preload: true }\n},\n\n</code-example>\n\nGenerate a new `SelectivePreloadingStrategy` service.\n\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate service selective-preloading-strategy\n</code-example>\n\nReplace the contents of `selective-preloading-strategy.service.ts` with the following:\n\n<code-example path=\"router/src/app/selective-preloading-strategy.service.ts\" header=\"src/app/selective-preloading-strategy.service.ts\">\nimport { Injectable } from &#39;@angular/core&#39;;\nimport { PreloadingStrategy, Route } from &#39;@angular/router&#39;;\nimport { Observable, of } from &#39;rxjs&#39;;\n\n@Injectable({\n  providedIn: &#39;root&#39;,\n})\nexport class SelectivePreloadingStrategyService implements PreloadingStrategy {\n  preloadedModules: string[] = [];\n\n  preload(route: Route, load: () =&gt; Observable&lt;any&gt;): Observable&lt;any&gt; {\n    if (route.data &amp;&amp; route.data.preload) {\n      // 사전로딩할 모듈의 라우팅 규칙을 배열에 추가합니다.\n      this.preloadedModules.push(route.path);\n\n      // 라우팅 규칙을 확인하기 위해 콘솔에 출력합니다.\n      console.log(&#39;Preloaded: &#39; + route.path);\n\n      return load();\n    } else {\n      return of(null);\n    }\n  }\n}\n\n\n</code-example>\n\n`SelectivePreloadingStrategyService` implements the `PreloadingStrategy`, which has one method, `preload()`.\n\nThe router calls the `preload()` method with two arguments:\n\n1. The route to consider.\n1. A loader function that can load the routed module asynchronously.\n\nAn implementation of `preload` must return an `Observable`.\nIf the route does preload, it returns the observable returned by calling the loader function.\nIf the route does not preload, it returns an `Observable` of `null`.\n\nIn this sample, the  `preload()` method loads the route if the route's `data.preload` flag is truthy.\n\nAs a side-effect, `SelectivePreloadingStrategyService` logs the `path` of a selected route in its public `preloadedModules` array.\n\nShortly, you'll extend the `AdminDashboardComponent` to inject this service and display its `preloadedModules` array.\n\nBut first, make a few changes to the `AppRoutingModule`.\n\n1. Import `SelectivePreloadingStrategyService` into `AppRoutingModule`.\n1. Replace the `PreloadAllModules` strategy in the call to `forRoot()` with this `SelectivePreloadingStrategyService`.\n1. Add the `SelectivePreloadingStrategyService` strategy to the `AppRoutingModule` providers array so you can inject it elsewhere in the app.\n\nNow edit the `AdminDashboardComponent` to display the log of preloaded routes.\n\n1. Import the `SelectivePreloadingStrategyService`.\n1. Inject it into the dashboard's constructor.\n1. Update the template to display the strategy service's `preloadedModules` array.\n\nNow the file is as follows:\n\n<code-example path=\"router/src/app/admin/admin-dashboard/admin-dashboard.component.ts\" header=\"src/app/admin/admin-dashboard/admin-dashboard.component.ts (preloaded modules)\">\nimport { Component, OnInit } from &#39;@angular/core&#39;;\nimport { ActivatedRoute } from &#39;@angular/router&#39;;\nimport { Observable } from &#39;rxjs&#39;;\nimport { map } from &#39;rxjs/operators&#39;;\n\nimport { SelectivePreloadingStrategyService } from &#39;../../selective-preloading-strategy.service&#39;;\n\n@Component({\n  selector: &#39;app-admin-dashboard&#39;,\n  templateUrl: &#39;./admin-dashboard.component.html&#39;,\n  styleUrls: [&#39;./admin-dashboard.component.css&#39;]\n})\nexport class AdminDashboardComponent implements OnInit {\n  sessionId: Observable&lt;string&gt;;\n  token: Observable&lt;string&gt;;\n  modules: string[];\n\n  constructor(\n    private route: ActivatedRoute,\n    preloadStrategy: SelectivePreloadingStrategyService\n  ) {\n    this.modules = preloadStrategy.preloadedModules;\n  }\n\n  ngOnInit() {\n    // 세션 ID가 있으면 가져옵니다.\n    this.sessionId = this.route\n      .queryParamMap\n      .pipe(map(params =&gt; params.get(&#39;session_id&#39;) || &#39;None&#39;));\n\n    // 프래그먼트가 있으면 가져옵니다.\n    this.token = this.route\n      .fragment\n      .pipe(map(fragment =&gt; fragment || &#39;None&#39;));\n  }\n}\n\n\n</code-example>\n\nOnce the application loads the initial route, the `CrisisCenterModule` is preloaded.\nVerify this by logging in to the `Admin` feature area and noting that the `crisis-center` is listed in the `Preloaded Modules`.\nIt also logs to the browser's console.\n-->\n<p>지연로딩 대상 모듈을 사전로딩하는 동작은 웬만해서는 문제가 발생하지 않습니다.\n하지만 사용자 디바이스의 네트워크 상황이 좋지 않거나 데이터 소모를 줄이는 방법을 고려한다면 모듈마다 적합한 커스텀 사전로딩 정책을 사용할 수도 있습니다.</p>\n<p>이번 섹셔넹서는 라우팅 규칙에 <code>data.preload</code> 플래그가 <code>true</code>일때만 모듈을 사전로딩하는 커스텀 사전로딩 정책을 정의하는 방법에 대해 알아봅시다.\n라우팅 규칙에 있는 <code>data</code> 프로퍼티에는 어떤 모양의 객체라도 자유롭게 지정할 수 있습니다.</p>\n<p><code>AppRoutingModule</code>에 등록한 <code>crisis-center</code> 라우팅 규칙에 <code>data.preload</code> 플래그를 추가합니다.</p>\n<code-example path=\"router/src/app/app-routing.module.ts\" header=\"src/app/app-routing.module.ts (route data preload)\" region=\"preload-v2\">\n{\n  path: 'crisis-center',\n  loadChildren: () => import('./crisis-center/crisis-center.module').then(m => m.CrisisCenterModule),\n  data: { preload: true }\n},\n\n</code-example>\n<p>그리고 <code>SelectivePreloadingStrategy</code> 서비스를 생성합니다.</p>\n<code-example language=\"none\" class=\"code-shell\">\n  ng generate service selective-preloading-strategy\n</code-example>\n<p><code>selective-preloading-strategy.service.ts</code> 파일의 내용을 이렇게 수정합니다:</p>\n<code-example path=\"router/src/app/selective-preloading-strategy.service.ts\" header=\"src/app/selective-preloading-strategy.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { <a href=\"api/router/PreloadingStrategy\" class=\"code-anchor\">PreloadingStrategy</a>, <a href=\"api/router/Route\" class=\"code-anchor\">Route</a> } from '@angular/router';\nimport { Observable, of } from 'rxjs';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class SelectivePreloadingStrategyService implements <a href=\"api/router/PreloadingStrategy\" class=\"code-anchor\">PreloadingStrategy</a> {\n  preloadedModules: string[] = [];\n\n  preload(route: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>, load: () => Observable&#x3C;any>): Observable&#x3C;any> {\n    if (route.data &#x26;&#x26; route.data.preload) {\n      // 사전로딩할 모듈의 라우팅 규칙을 배열에 추가합니다.\n      this.preloadedModules.push(route.path);\n\n      // 라우팅 규칙을 확인하기 위해 콘솔에 출력합니다.\n      console.log('Preloaded: ' + route.path);\n\n      return load();\n    } else {\n      return of(null);\n    }\n  }\n}\n\n\n</code-example>\n<p><code>SelectivePreloadingStrategyService</code>는 <code><a href=\"api/router/PreloadingStrategy\" class=\"code-anchor\">PreloadingStrategy</a></code> 인터페이스를 확장해서 구현하며, <code>preload()</code> 메서드 하나만 정의합니다.</p>\n<p>라우터는 <code>preload()</code> 메서드를 실행할 때 인자를 2개 전달합니다:</p>\n<ol>\n<li>참고할 라우팅 규칙</li>\n<li>비동기 모듈 로더 함수</li>\n</ol>\n<p><code>preload()</code> 함수는 반드시 <code>Observable</code>을 반환해야 합니다.\n해당 라우팅 규칙이 모듈을 사전로딩해야 한다면 로더 함수를 실행해서 옵저버블을 반환하면 됩니다.\n그리고 사전로딩하지 않아야 한다면 <code>of(null)</code> 옵저버블을 반환하면 됩니다.</p>\n<p>이번 예제에서는 라우팅 규칙에 있는 <code>data.preload</code> 플래그가 참으로 평가될 때 모듈을 사전로딩하도록 구현했습니다.</p>\n<p>이 동작과 함께 <code>SelectivePreloadingStrategyService</code>는 사전로딩하는 라우팅 규칙의 주소를 콘솔에 출력하고 <code>public preloadedModules</code> 배열 프로퍼티에 추가합니다.</p>\n<p>이렇게 배열에 추가한 정보는 <code>AdminDashboardComponent</code>와 같은 화면에서 관리자용 정보로 표시할 수 있습니다.</p>\n<p>하지만 그전에, <code>AppRoutingModule</code> 코드를 약간 수정해야 합니다.</p>\n<ol>\n<li><code>AppRoutingModule</code>에 <code>SelectivePreloadingStrategyService</code>를 로드합니다.</li>\n<li><code>forRoot()</code>에 사용한 <code><a href=\"api/router/PreloadAllModules\" class=\"code-anchor\">PreloadAllModules</a></code> 정책을 <code>SelectivePreloadingStrategyService</code>로 변경합니다.</li>\n<li><code>AppRoutingModule</code> 프로바이더 배열에 <code>SelectivePreloadingStrategyService</code> 정책을 추가하면 이제 앱 전체에서 이 사전로딩 정책을 자유롭게 사용할 수 있습니다.</li>\n</ol>\n<p>이제 사전로딩한 라우팅 규칙을 확인하도록 <code>AdminDashboardComponent</code>를 수정해 봅시다.</p>\n<ol>\n<li><code>SelectivePreloadingStrategyService</code>를 로드합니다.</li>\n<li>이 정책을 생성자로 주입합니다.</li>\n<li>사전로딩 정책 서비스의 <code>preloadedModules</code> 배열을 화면에 표시하도록 템플릿을 수정합니다.</li>\n</ol>\n<p>그러면 컴포넌트 클래스 파일의 내용이 이렇게 구성됩니다:</p>\n<code-example path=\"router/src/app/admin/admin-dashboard/admin-dashboard.component.ts\" header=\"src/app/admin/admin-dashboard/admin-dashboard.component.ts (사전로딩된 모듈 확인하기)\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport { SelectivePreloadingStrategyService } from '../../selective-preloading-strategy.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-admin-dashboard',\n  templateUrl: './admin-dashboard.component.html',\n  styleUrls: ['./admin-dashboard.component.css']\n})\nexport class AdminDashboardComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  sessionId: Observable&#x3C;string>;\n  token: Observable&#x3C;string>;\n  modules: string[];\n\n  constructor(\n    private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>,\n    preloadStrategy: SelectivePreloadingStrategyService\n  ) {\n    this.modules = preloadStrategy.preloadedModules;\n  }\n\n  ngOnInit() {\n    // 세션 ID가 있으면 가져옵니다.\n    this.sessionId = this.route\n      .queryParamMap\n      .pipe(map(params => params.get('session_id') || 'None'));\n\n    // 프래그먼트가 있으면 가져옵니다.\n    this.token = this.route\n      .fragment\n      .pipe(map(fragment => fragment || 'None'));\n  }\n}\n\n\n</code-example>\n<p>이제 애플리케이션이 첫 번째 라우팅 규칙을 로드하면 그 뒤에 바로 <code>CrisisCenterModule</code>이 사전로딩됩니다.\n이 모듈이 정말 사전로딩 되었는지 관리자 모듈로 이동해서 확인해 보세요.\n모듈이 사전로딩되면 브라우저 콘솔에도 로그가 출력됩니다.</p>\n<a id=\"redirect-advanced\"></a>\n<!--\n### Migrating URLs with redirects\n-->\n<h3 id=\"리다이렉션으로-기존-url-마이그레이션하기\">리다이렉션으로 기존 URL 마이그레이션하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#리다이렉션으로-기존-url-마이그레이션하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nYou've setup the routes for navigating around your application and used navigation imperatively and declaratively.\nBut like any application, requirements change over time.\nYou've setup links and navigation to `/heroes` and `/hero/:id` from the `HeroListComponent` and `HeroDetailComponent` components.\nIf there were a requirement that links to `heroes` become `superheroes`, you would still want the previous URLs to navigate correctly.\nYou also don't want to update every link in your application, so redirects makes refactoring routes trivial.\n-->\n<p>지금까지 애플리케이션에 활용하는 라우팅 규칙을 다양하게 수정해봤습니다.\n하지만 모든 애플리케이션이 그렇듯, 요구사항은 때에 따라 변경될 수 있습니다.\n지금은 <code>/heroes</code>, <code>/hero/:id</code>라는 주소가 <code>HeroListComponent</code>나 <code>HeroDetailComponent</code>와 연결됩니다.\n<code>heroes</code>라는 주소가 <code>superheroes</code>로 변경되더라도 이전 주소를 그대로 유지하는 경우를 생각해 봅시다.\n리다이렉션을 활용하면 애플리케이션에 존재하는 링크를 매번 변경하지 않아도 라우팅 규칙 수정사항을 최소화 할 수 있습니다.</p>\n<a id=\"url-refactor\"></a>\n<!--\n#### Changing `/heroes` to `/superheroes`\n-->\n<h4 id=\"heroes-주소를-superheroes로-변경하기\"><code>/heroes</code> 주소를 <code>/superheroes</code>로 변경하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#heroes-주소를-superheroes로-변경하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThis section guides you through migrating the `Hero` routes to new URLs.\nThe `Router` checks for redirects in your configuration before navigating, so each redirect is triggered when needed. To support this change, add redirects from the old routes to the new routes in the `heroes-routing.module`.\n\n<code-example path=\"router/src/app/heroes/heroes-routing.module.ts\" header=\"src/app/heroes/heroes-routing.module.ts (heroes redirects)\">\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { RouterModule, Routes } from &#39;@angular/router&#39;;\n\nimport { HeroListComponent } from &#39;./hero-list/hero-list.component&#39;;\nimport { HeroDetailComponent } from &#39;./hero-detail/hero-detail.component&#39;;\n\nconst heroesRoutes: Routes = [\n  { path: &#39;heroes&#39;, redirectTo: &#39;/superheroes&#39; },\n  { path: &#39;hero/:id&#39;, redirectTo: &#39;/superhero/:id&#39; },\n  { path: &#39;superheroes&#39;,  component: HeroListComponent, data: { animation: &#39;heroes&#39; } },\n  { path: &#39;superhero/:id&#39;, component: HeroDetailComponent, data: { animation: &#39;hero&#39; } }\n];\n\n@NgModule({\n  imports: [\n    RouterModule.forChild(heroesRoutes)\n  ],\n  exports: [\n    RouterModule\n  ]\n})\nexport class HeroesRoutingModule { }\n\n</code-example>\n\nNotice two different types of redirects.\nThe first change is from  `/heroes` to `/superheroes` without any parameters.\nThe second change is from `/hero/:id` to `/superhero/:id`, which includes the `:id` route parameter.\nRouter redirects also use powerful pattern-matching, so the `Router` inspects the URL and replaces route parameters in the `path` with their appropriate destination.\nPreviously, you navigated to a URL such as `/hero/15` with a route parameter `id` of `15`.\n\n<div class=\"alert is-helpful\">\n\nThe `Router` also supports [query parameters](#query-parameters) and the [fragment](#fragment) when using redirects.\n\n* When using absolute redirects, the `Router` will use the query parameters and the fragment from the `redirectTo` in the route config.\n* When using relative redirects, the `Router` use the query params and the fragment from the source URL.\n\n</div>\n\nCurrently, the empty path route redirects to `/heroes`, which redirects to `/superheroes`.\nThis won't work because the `Router` handles redirects once at each level of routing configuration.\nThis prevents chaining of redirects, which can lead to endless redirect loops.\n\nInstead, update the empty path route in `app-routing.module.ts` to redirect to `/superheroes`.\n\n<code-example path=\"router/src/app/app-routing.module.ts\" header=\"src/app/app-routing.module.ts (superheroes redirect)\">\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { RouterModule, Routes } from &#39;@angular/router&#39;;\n\nimport { ComposeMessageComponent } from &#39;./compose-message/compose-message.component&#39;;\nimport { PageNotFoundComponent } from &#39;./page-not-found/page-not-found.component&#39;;\n\nimport { AuthGuard } from &#39;./auth/auth.guard&#39;;\nimport { SelectivePreloadingStrategyService } from &#39;./selective-preloading-strategy.service&#39;;\n\nconst appRoutes: Routes = [\n  {\n    path: &#39;compose&#39;,\n    component: ComposeMessageComponent,\n    outlet: &#39;popup&#39;\n  },\n  {\n    path: &#39;admin&#39;,\n    loadChildren: () =&gt; import(&#39;./admin/admin.module&#39;).then(m =&gt; m.AdminModule),\n    canLoad: [AuthGuard]\n  },\n  {\n    path: &#39;crisis-center&#39;,\n    loadChildren: () =&gt; import(&#39;./crisis-center/crisis-center.module&#39;).then(m =&gt; m.CrisisCenterModule),\n    data: { preload: true }\n  },\n  { path: &#39;&#39;,   redirectTo: &#39;/superheroes&#39;, pathMatch: &#39;full&#39; },\n  { path: &#39;**&#39;, component: PageNotFoundComponent }\n];\n\n@NgModule({\n  imports: [\n    RouterModule.forRoot(\n      appRoutes,\n      {\n        enableTracing: false, // &lt;-- 디버그 활성화\n        preloadingStrategy: SelectivePreloadingStrategyService,\n      }\n    )\n  ],\n  exports: [\n    RouterModule\n  ]\n})\nexport class AppRoutingModule { }\n\n\n</code-example>\n\nA `routerLink` isn't tied to route configuration, so update the associated router links to remain active when the new route is active.\nUpdate the `app.component.ts` template for the `/heroes` `routerLink`.\n\n<code-example path=\"router/src/app/app.component.html\" header=\"src/app/app.component.html (superheroes active routerLink)\">\n&lt;h1 class=&quot;title&quot;&gt;Angular Router&lt;/h1&gt;\n&lt;nav&gt;\n  &lt;a routerLink=&quot;/crisis-center&quot; routerLinkActive=&quot;active&quot;&gt;Crisis Center&lt;/a&gt;\n  &lt;a routerLink=&quot;/superheroes&quot; routerLinkActive=&quot;active&quot;&gt;Heroes&lt;/a&gt;\n  &lt;a routerLink=&quot;/admin&quot; routerLinkActive=&quot;active&quot;&gt;Admin&lt;/a&gt;\n  &lt;a routerLink=&quot;/login&quot; routerLinkActive=&quot;active&quot;&gt;Login&lt;/a&gt;\n  &lt;a [routerLink]=&quot;[{ outlets: { popup: [&#39;compose&#39;] } }]&quot;&gt;Contact&lt;/a&gt;\n&lt;/nav&gt;\n&lt;div [@routeAnimation]=&quot;getAnimationData(routerOutlet)&quot;&gt;\n  &lt;router-outlet #routerOutlet=&quot;outlet&quot;&gt;&lt;/router-outlet&gt;\n&lt;/div&gt;\n&lt;router-outlet name=&quot;popup&quot;&gt;&lt;/router-outlet&gt;\n\n</code-example>\n\nUpdate the `goToHeroes()` method in the `hero-detail.component.ts` to navigate back to `/superheroes` with the optional route parameters.\n\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.ts\" region=\"redirect\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (goToHeroes)\">\ngotoHeroes(hero: Hero) {\n  const heroId = hero ? hero.id : null;\n  // HeroList 컴포넌트에 하이라이트를 표시하기 위해 히어로의 id가 존재하면 전달합니다.\n  // &#39;foo&#39; 프로퍼티는 사용하지 않지만 이렇게 전달할 수도 있습니다.\n  this.router.navigate([&#39;/superheroes&#39;, { id: heroId, foo: &#39;foo&#39; }]);\n}\n\n</code-example>\n\nWith the redirects setup, all previous routes now point to their new destinations and both URLs still function as intended.\n-->\n<p>이번 섹션에서는 <code>/heroes</code>에 해당하는 라우팅 규칙을 다른 URL로 마이그레이션하는 방법에 대해 알아봅시다.\n라우터는 화면을 전환하기 전에 일반 라우팅 규칙보다 리다이렉션을 먼저 검사합니다.\n그래서 화면에 접근하는 URL이 변경된다면 이전 라우팅 규칙을 그대로 두고 리다이렉션 라우팅 규칙을 추가하면 됩니다.</p>\n<code-example path=\"router/src/app/heroes/heroes-routing.module.ts\" header=\"src/app/heroes/heroes-routing.module.ts (heroes 리다이렉션)\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { HeroListComponent } from './hero-list/hero-list.component';\nimport { HeroDetailComponent } from './hero-detail/hero-detail.component';\n\nconst heroesRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'heroes', redirectTo: '/superheroes' },\n  { path: 'hero/:id', redirectTo: '/superhero/:id' },\n  { path: 'superheroes',  component: HeroListComponent, data: { <a href=\"api/animations/animation\" class=\"code-anchor\">animation</a>: 'heroes' } },\n  { path: 'superhero/:id', component: HeroDetailComponent, data: { <a href=\"api/animations/animation\" class=\"code-anchor\">animation</a>: 'hero' } }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forChild(heroesRoutes)\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class HeroesRoutingModule { }\n\n</code-example>\n<p>리다이렉션 타입이 2개인 것을 유심히 봅시다.\n첫 번째는 라우팅 인자 없이 <code>/heroes</code> 주소가 <code>/superheroes</code> 주소로 변경된 것입니다.\n그리고 두 번째는 <code>:id</code> 라우팅 인자가 포함된 <code>/hero/:id</code> 주소가 <code>/superhero/:id</code> 주소로 변경된 것입니다.\n라우터가 제공하는 패턴 매칭은 <code>path</code> 프로퍼티 안에 있는 라우팅 인자도 모두 처리할 수 있기 때문에 리다이렉션 주소에 라우팅 인자가 있더라도 최종 주소를 원하는 대로 처리할 수 있습니다.\n이전에 언급했듯이, <code>/hero/15</code>라는 주소가 있을 때 라우팅 인자 <code>id</code>에 해당하는 값은 <code>15</code>입니다.</p>\n<div class=\"alert is-helpful\">\n<p>라우터는 리다이렉션할 때 <a href=\"guide/router-tutorial-toh#query-parameters\">쿼리 인자</a>와 <a href=\"guide/router-tutorial-toh#fragment\">프래그먼트</a>도 그대로 처리합니다.</p>\n<ul>\n<li>절대주소로 리다이렉션하면 <code>redirectTo</code>에 지정된 쿼리 인자와 프래그먼트를 활용합니다.</li>\n<li>상대주소로 리다이렉션하면 소스 URL에 있는 쿼리 인자와 프래그먼트를 활용합니다.</li>\n</ul>\n</div>\n<p>이제 <code>HeroesModule</code>에 빈 주소가 사용되면 <code>/heroes</code>로 이동한 후에 <code>/superheroes</code>로 이동한다고 생각할 수 있습니다.\n하지만 라우터는 리다이렉션을 한 계층에서 한 번만 처리합니다.\n이 정책은 리다이렉션이 끝나지 않고 계속되는 상황을 막기 위한 것입니다.</p>\n<p>이 상황을 해결하려면 <code>app-routing.module.ts</code> 파일에 지정된 주소를 <code>/superheroes</code>로 변경해야 합니다.</p>\n<code-example path=\"router/src/app/app-routing.module.ts\" header=\"src/app/app-routing.module.ts (superheroes로 리다이렉션 하기)\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { ComposeMessageComponent } from './compose-message/compose-message.component';\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\n\nimport { AuthGuard } from './auth/auth.guard';\nimport { SelectivePreloadingStrategyService } from './selective-preloading-strategy.service';\n\nconst appRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'compose',\n    component: ComposeMessageComponent,\n    outlet: 'popup'\n  },\n  {\n    path: 'admin',\n    loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule),\n    canLoad: [AuthGuard]\n  },\n  {\n    path: 'crisis-center',\n    loadChildren: () => import('./crisis-center/crisis-center.module').then(m => m.CrisisCenterModule),\n    data: { preload: true }\n  },\n  { path: '',   redirectTo: '/superheroes', pathMatch: 'full' },\n  { path: '**', component: PageNotFoundComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forRoot(\n      appRoutes,\n      {\n        enableTracing: false, // &#x3C;-- 디버그 활성화\n        preloadingStrategy: SelectivePreloadingStrategyService,\n      }\n    )\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class AppRoutingModule { }\n\n\n</code-example>\n<p><code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code>는 라우팅 규칙과 직접 연결되지 않기 때문에 라우팅 규칙의 주소가 변경되면 관련 링크도 모두 수정해야 합니다.\n<code>app.component.ts</code> 템플릿에 있는 <code>/heroes</code> 링크를 수정합니다.</p>\n<code-example path=\"router/src/app/app.component.html\" header=\"src/app/app.component.html (superheroes 라우터 링크 수정)\">\n&#x3C;h1 class=\"title\">Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>&#x3C;/h1>\n&#x3C;nav>\n  &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/crisis-center\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Crisis Center&#x3C;/a>\n  &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/superheroes\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Heroes&#x3C;/a>\n  &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/admin\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Admin&#x3C;/a>\n  &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/login\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Login&#x3C;/a>\n  &#x3C;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"[{ outlets: { popup: ['compose'] } }]\">Contact&#x3C;/a>\n&#x3C;/nav>\n&#x3C;div [@routeAnimation]=\"getAnimationData(routerOutlet)\">\n  &#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a> #routerOutlet=\"outlet\">&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n&#x3C;/div>\n&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a> name=\"popup\">&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n\n</code-example>\n<p>그리고 <code>hero-detail.component.ts</code> 파일의 <code>goToHeroes()</code> 메서드도 <code>/superheroes</code>로 이동하도록 수정합니다.</p>\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.ts\" region=\"redirect\" header=\"src/app/heroes/hero-detail/hero-detail.component.ts (goToHeroes())\">\ngotoHeroes(hero: Hero) {\n  const heroId = hero ? hero.id : null;\n  // HeroList 컴포넌트에 하이라이트를 표시하기 위해 히어로의 id가 존재하면 전달합니다.\n  // 'foo' 프로퍼티는 사용하지 않지만 이렇게 전달할 수도 있습니다.\n  this.router.navigate(['/superheroes', { id: heroId, foo: 'foo' }]);\n}\n\n</code-example>\n<p>여기까지 작업하고 나면 이전에 사용하던 주소와 새로 변경된 주소가 모두 원하는 화면으로 도앚ㄱ합니다.</p>\n<a id=\"inspect-config\"></a>\n<!--\n### Inspect the router's configuration\n-->\n<h3 id=\"라우터-환경설정-확인하기\">라우터 환경설정 확인하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#라우터-환경설정-확인하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nTo determine if your routes are actually evaluated [in the proper order](#routing-module-order), you can inspect the router's configuration.\n\nDo this by injecting the router and logging to the console its `config` property.\nFor example, update the `AppModule` as follows and look in the browser console window\nto see the finished route configuration.\n\n<code-example path=\"router/src/app/app.module.7.ts\" header=\"src/app/app.module.ts (inspect the router config)\" region=\"inspect-config\">\nexport class AppModule {\n  // 디버그용: 라우터 설정값 확인하기\n  constructor(router: Router) {\n    // 라우터 설정 객체의 프로퍼티 중 함수는 이름만 출력하도록 조정합니다.\n    const replacer = (key, value) =&gt; (typeof value === &#39;function&#39;) ? value.name : value;\n\n    console.log(&#39;Routes: &#39;, JSON.stringify(router.config, replacer, 2));\n  }\n}\n\n</code-example>\n-->\n<p>라우팅 규칙이 <a href=\"guide/router-tutorial-toh#routing-module-order\">어떤 순서로</a> 최종결정되었는지 확인하려면 라우터 환경설정을 직접 확인하면 됩니다.</p>\n<p>라우터 설정을 확인하려면 라우터를 의존성 객체로 주입하고 이 객체의 <code>config</code> 프로퍼티를 확인하면 됩니다.\n<code>AppModule</code>의 경우라면 아래 코드처럼 작성하면 최종 라우터 설정을 확인할 수 있습니다.</p>\n<code-example path=\"router/src/app/app.module.7.ts\" header=\"src/app/app.module.ts (라우터 환경설정 확인하기)\" region=\"inspect-config\">\nexport class AppModule {\n  // 디버그용: 라우터 설정값 확인하기\n  constructor(router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {\n    // 라우터 설정 객체의 프로퍼티 중 함수는 이름만 출력하도록 조정합니다.\n    const replacer = (key, value) => (typeof value === 'function') ? value.name : value;\n\n    console.log('<a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a>: ', JSON.stringify(router.config, replacer, 2));\n  }\n}\n\n</code-example>\n<a id=\"final-app\"></a>\n<!--\n## Final app\n-->\n<h2 id=\"최종-결과\">최종 결과<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#최종-결과\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nFor the completed router app, see the <live-example name=\"router\"></live-example> for the final source code.\n-->\n<p>여기까지 작업한 내용을 확인하려면 <live-example name=\"router\"></live-example>를 참고하세요.</p>\n<a id=\"link-parameters-array\"></a>\n\n\n\n<!-- links to this doc:\n - api/router/RouterOutlet\n - guide/deployment\n - guide/glossary\n - guide/lazy-loading-ngmodules\n - guide/router\n - guide/testing-components-scenarios\n-->\n<!-- links from this doc:\n - /cli\n - /guide/router#example-config\n - /tutorial\n - api/animations/animate\n - api/animations/animateChild\n - api/animations/animation\n - api/animations/query\n - api/animations/state\n - api/animations/style\n - api/animations/transition\n - api/animations/trigger\n - api/common/AsyncPipe\n - api/common/CommonModule\n - api/common/NgForOf\n - api/common/NgIf\n - api/core/Component\n - api/core/HostBinding\n - api/core/Injectable\n - api/core/NgModule\n - api/core/OnInit\n - api/forms/DefaultValueAccessor\n - api/forms/FormsModule\n - api/forms/NgModel\n - api/platform-browser/BrowserModule\n - api/platform-browser/animations/BrowserAnimationsModule\n - api/router/ActivatedRoute\n - api/router/ActivatedRoute#paramMap\n - api/router/ActivatedRouteSnapshot\n - api/router/CanActivate\n - api/router/CanActivateChild\n - api/router/CanDeactivate\n - api/router/CanLoad\n - api/router/NavigationExtras\n - api/router/ParamMap\n - api/router/PreloadAllModules\n - api/router/PreloadingStrategy\n - api/router/Resolve\n - api/router/Route\n - api/router/Router\n - api/router/Router#navigate\n - api/router/RouterLink\n - api/router/RouterLinkActive\n - api/router/RouterModule\n - api/router/RouterModule#forChild\n - api/router/RouterModule#forRoot\n - api/router/RouterOutlet\n - api/router/RouterState\n - api/router/RouterStateSnapshot\n - api/router/Routes\n - api/router/UrlTree\n - api/upgrade/static\n - cli\n - cli/generate\n - cli/new\n - guide/animations\n - guide/architecture\n - guide/attribute-binding#class-binding\n - guide/router-tutorial-toh#2차-라우팅-규칙\n - guide/router-tutorial-toh#2차-라우팅-규칙-적용하기-라우팅-규칙-병합하기\n - guide/router-tutorial-toh#2차-라우팅-규칙-추가하기\n - guide/router-tutorial-toh#2차-라우팅-규칙-해제하기\n - guide/router-tutorial-toh#activatedroute-사용하기\n - guide/router-tutorial-toh#activatedroute-서비스에-있는-라우팅-인자\n - guide/router-tutorial-toh#appmodule-라우팅-규칙에-위기대응센터-모듈-로드하기\n - guide/router-tutorial-toh#authguard에-인증기능-넣기\n - guide/router-tutorial-toh#can-activate-child-guard\n - guide/router-tutorial-toh#can-activate-guard\n - guide/router-tutorial-toh#can-load-guard\n - guide/router-tutorial-toh#canactivate-인증을-확인할-때\n - guide/router-tutorial-toh#canactivatechild-자식-라우팅-규칙-제한하기\n - guide/router-tutorial-toh#candeactivate-저장하지-않은-변경사항을-처리할-때\n - guide/router-tutorial-toh#canload-권한없는-사용자가-모듈-로딩하는-것을-제한하기\n - guide/router-tutorial-toh#canload는-사전로딩을-막습니다\n - guide/router-tutorial-toh#clear-secondary-routes\n - guide/router-tutorial-toh#custom-preloading\n - guide/router-tutorial-toh#fragment\n - guide/router-tutorial-toh#heroes-functionality\n - guide/router-tutorial-toh#heroes-주소를-superheroes로-변경하기\n - guide/router-tutorial-toh#inspect-config\n - guide/router-tutorial-toh#link-parameters-array\n - guide/router-tutorial-toh#logincomponent-추가하기\n - guide/router-tutorial-toh#optional-route-parameters\n - guide/router-tutorial-toh#parammap-api\n - guide/router-tutorial-toh#parammap-옵저버블과-컴포넌트-재사용\n - guide/router-tutorial-toh#query-parameters\n - guide/router-tutorial-toh#redirect\n - guide/router-tutorial-toh#refactor-the-routing-configuration-into-a-routing-module\n - guide/router-tutorial-toh#resolve-컴포넌트-데이터-미리-받아오기\n - guide/router-tutorial-toh#reuse\n - guide/router-tutorial-toh#route-parameters\n - guide/router-tutorial-toh#router-routes-등록하기\n - guide/router-tutorial-toh#routing-module\n - guide/router-tutorial-toh#routing-module-order\n - guide/router-tutorial-toh#snapshot-the-no-observable-alternative\n - guide/router-tutorial-toh#snapshot-옵저버블을-사용하지-않는-방식\n - guide/router-tutorial-toh#wildcard\n - guide/router-tutorial-toh#관리자-기능-모듈-추가하기\n - guide/router-tutorial-toh#관리자-모듈-사용-제한하기\n - guide/router-tutorial-toh#라우터-튜토리얼-히어로들의-여행\n - guide/router-tutorial-toh#라우터-환경설정-확인하기\n - guide/router-tutorial-toh#라우팅-규칙-정의하기\n - guide/router-tutorial-toh#라우팅-모듈을-사용하는-이유\n - guide/router-tutorial-toh#라우팅-애니메이션-추가하기\n - guide/router-tutorial-toh#라우팅-영역-추가하기\n - guide/router-tutorial-toh#라우팅-인자\n - guide/router-tutorial-toh#라우팅-인자-필수일까-옵션일까\n - guide/router-tutorial-toh#라우팅-인자를-사용하는-라우팅-규칙-정의하기\n - guide/router-tutorial-toh#라우팅-환경설정-리팩토링하기\n - guide/router-tutorial-toh#리다이렉션-설정하기\n - guide/router-tutorial-toh#리다이렉션으로-기존-url-마이그레이션하기\n - guide/router-tutorial-toh#마일스톤-1-시작하기\n - guide/router-tutorial-toh#마일스톤-1-정리\n - guide/router-tutorial-toh#마일스톤-2-라우팅-모듈\n - guide/router-tutorial-toh#마일스톤-3-정리\n - guide/router-tutorial-toh#마일스톤-3-히어로-관리-모듈\n - guide/router-tutorial-toh#마일스톤-4-위기대응센터-모듈\n - guide/router-tutorial-toh#마일스톤-5-라우팅-가드\n - guide/router-tutorial-toh#마일스톤-6-비동기-라우팅\n - guide/router-tutorial-toh#모듈을-로드하는-순서\n - guide/router-tutorial-toh#목록-화면에서-라우팅-인자-설정하기\n - guide/router-tutorial-toh#목표\n - guide/router-tutorial-toh#사전로딩-백그라운드에서-모듈-로딩하기\n - guide/router-tutorial-toh#사전로딩이-동작하는-방식\n - guide/router-tutorial-toh#사전지식\n - guide/router-tutorial-toh#상대주소로-위기대응센터로-이동하기\n - guide/router-tutorial-toh#상대주소로-이동하기\n - guide/router-tutorial-toh#애플리케이션에-있는-라우팅-통합하기\n - guide/router-tutorial-toh#예제-애플리케이션이-동작하는-모습\n - guide/router-tutorial-toh#와일드카드-라우팅-규칙-정의하기\n - guide/router-tutorial-toh#위기대응센터-지연로딩하기\n - guide/router-tutorial-toh#위기대응센터와-자식-라우팅\n - guide/router-tutorial-toh#이름이-지정된-라우팅-영역으로-라우팅-규칙-여러개-표시하기\n - guide/router-tutorial-toh#이전-화면으로-전환하기\n - guide/router-tutorial-toh#자식-라우팅-컴포넌트\n - guide/router-tutorial-toh#자식-라우팅-환경설정\n - guide/router-tutorial-toh#중복된-라우팅-규칙-제거하기\n - guide/router-tutorial-toh#지연로딩-라우팅-환경설정\n - guide/router-tutorial-toh#최종-결과\n - guide/router-tutorial-toh#취소하거나-저장하기\n - guide/router-tutorial-toh#커스텀-사전로딩-정책\n - guide/router-tutorial-toh#컴포넌트-등록-코드-제거하기\n - guide/router-tutorial-toh#컴포넌트가-없는-라우팅-규칙-라우팅-규칙을-그룹으로-묶기\n - guide/router-tutorial-toh#쿼리-인자와-프래그먼트\n - guide/router-tutorial-toh#화면을-전환하기-전에-데이터-받아오기\n - guide/router-tutorial-toh#히어로-모듈-라우터-설정\n - guide/router-tutorial-toh#히어로-목록-히어로-선택하기옵션\n - guide/router-tutorial-toh#히어로-추가-기능\n - guide/singleton-services#forRoot-router\n - start\n - tutorial\n - tutorial/toh-pt4\n - http://vsavkin.tumblr.com/post/146722301646/angular-router-empty-paths-componentless-routes\n - http://www.w3.org/DesignIssues/MatrixURIs.html\n - https://blog.8thlight.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html\n - https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams\n - https://en.wikipedia.org/wiki/Fragment_identifier\n - https://github.com/angular/angular/edit/master/aio/content/guide/router-tutorial-toh.md?message=docs%3A%20describe%20your%20change...\n - https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping\n-->"
}