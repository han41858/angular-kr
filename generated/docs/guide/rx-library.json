{
  "id": "guide/rx-library",
  "title": "RxJS 라이브러리",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/rx-library.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# The RxJS library\n-->\n<h1 id=\"rxjs-라이브러리\">RxJS 라이브러리<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#rxjs-라이브러리\"><i class=\"material-icons\">link</i></a></h1>\n<!--\nReactive programming is an asynchronous programming paradigm concerned with data streams and the propagation of change ([Wikipedia](https://en.wikipedia.org/wiki/Reactive_programming)). RxJS (Reactive Extensions for JavaScript) is a library for reactive programming using observables that makes it easier to compose asynchronous or callback-based code ([RxJS Docs](http://reactivex.io/rxjs/)).\n-->\n<p>반응형 프로그래밍은 비동기 프로그래밍 패러다임중 하나로, 데이터 스트림과 데이터의 변화를 감지하는 것에 집중하는  패러다임입니다 (<a href=\"https://en.wikipedia.org/wiki/Reactive_programming\">Wikipedia</a>).\n그리고 RxJS(Reactive Extensions for JavaScript)는 옵저버블을 활용해서 이 패러다임을 구현할 수 있도록 돕는 JavaScript 라이브러리입니다 (<a href=\"http://reactivex.io/rxjs/\">RxJS Docs</a>).</p>\n<!--\nRxJS provides an implementation of the `Observable` type, which is needed until the type becomes part of the language and until browsers support it. The library also provides utility functions for creating and working with observables. These utility functions can be used for:\n-->\n<p>아직까지 JavaScript와 브라우저는 옵저버블을 정식으로 지원하지 않습니다. 그래서 RxJS는 <code>Observable</code> 타입의 구현체를 라이브러리로 제공하며, 옵저버블을 생성하거나 활용하는 함수들도 함께 제공합니다.\n이 함수들은 다음과 같은 용도로 사용합니다:</p>\n<!--\n* Converting existing code for async operations into observables\n* Iterating through the values in a stream\n* Mapping values to different types\n* Filtering streams\n* Composing multiple streams\n-->\n<ul>\n<li>비동기 코드를 옵저버블로 변환할 때</li>\n<li>이터러블 객체를 순회하면서 스트림으로 변환할 때</li>\n<li>데이터를 다른 타입으로 변환할 때</li>\n<li>스트림 일부만 필터링할 때</li>\n<li>여러 스트림을 하나로 합쳐서 처리할 때</li>\n</ul>\n<!--\n## Observable creation functions\n-->\n<h2 id=\"옵저버블-생성-함수\">옵저버블 생성 함수<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#옵저버블-생성-함수\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nRxJS offers a number of functions that can be used to create new observables. These functions can simplify the process of creating observables from things such as events, timers, promises, and so on. For example:\n-->\n<p>RxJS는 옵저버블을 생성하는 함수를 다양하게 제공합니다. 이 함수를 사용하면 이벤트나 타이머, Promise 등 다양한 타입의 옵저버블을 생성할 수 있습니다.</p>\n<!--\n<code-example path=\"rx-library/src/simple-creation.ts\" region=\"promise\" header=\"Create an observable from a promise\">\n\nimport { from } from &#39;rxjs&#39;;\n\n// Promise를 옵저버블로 변환합니다.\nconst data = from(fetch(&#39;/api/endpoint&#39;));\n// 구독을 시작하고 Promise가 반환하는 객체를 처리합니다.\ndata.subscribe({\n next(response) { console.log(response); },\n error(err) { console.error(&#39;Error: &#39; + err); },\n complete() { console.log(&#39;Completed&#39;); }\n});\n\n\n</code-example>\n-->\n<code-example path=\"rx-library/src/simple-creation.ts\" region=\"promise\" header=\"Promise를 옵저버블로 변환하기\">\n\nimport { from } from 'rxjs';\n\n// Promise를 옵저버블로 변환합니다.\nconst data = from(fetch('/api/endpoint'));\n// 구독을 시작하고 Promise가 반환하는 객체를 처리합니다.\ndata.subscribe({\n next(response) { console.log(response); },\n error(err) { console.error('<a href=\"api/core/MissingTranslationStrategy#Error\" class=\"code-anchor\">Error</a>: ' + err); },\n complete() { console.log('Completed'); }\n});\n\n\n</code-example>\n<!--\n<code-example path=\"rx-library/src/simple-creation.ts\" region=\"interval\" header=\"Create an observable from a counter\">\n\nimport { interval } from &#39;rxjs&#39;;\n\n// 타이머를 옵저버블로 변환합니다.\nconst secondsCounter = interval(1000);\n// 구독을 시작하고 타이머가 반환하는 값을 처리합니다.\nsecondsCounter.subscribe(n =&gt;\n  console.log(`It&#39;s been ${n} seconds since subscribing!`));\n\n\n</code-example>\n-->\n<code-example path=\"rx-library/src/simple-creation.ts\" region=\"interval\" header=\"카운터를 옵저버블로 변환하기\">\n\nimport { interval } from 'rxjs';\n\n// 타이머를 옵저버블로 변환합니다.\nconst secondsCounter = interval(1000);\n// 구독을 시작하고 타이머가 반환하는 값을 처리합니다.\nsecondsCounter.subscribe(n =>\n  console.log(`It's been ${n} seconds since subscribing!`));\n\n\n</code-example>\n<!--\n<code-example path=\"rx-library/src/simple-creation.ts\" region=\"event\" header=\"Create an observable from an event\">\n\nimport { fromEvent } from &#39;rxjs&#39;;\n\nconst el = document.getElementById(&#39;my-element&#39;);\n\n// 마우스가 움직이는 이벤트를 옵저버블로 변환합니다.\nconst mouseMoves = fromEvent(el, &#39;mousemove&#39;);\n\n// 구독을 시작하고 마우스가 움직이는 이벤트를 처리합니다.\nconst subscription = mouseMoves.subscribe((evt: MouseEvent) =&gt; {\n  // 마우스의 위치를 로그로 출력합니다.\n  console.log(`Coords: ${evt.clientX} X ${evt.clientY}`);\n\n  // 마우스가 화면 왼쪽 위로 움직이면 구독을 해지합니다.\n  if (evt.clientX &lt; 40 &amp;&amp; evt.clientY &lt; 40) {\n    subscription.unsubscribe();\n  }\n});\n\n\n</code-example>\n-->\n<code-example path=\"rx-library/src/simple-creation.ts\" region=\"event\" header=\"이벤트를 옵저버블로 변환하기\">\n\nimport { fromEvent } from 'rxjs';\n\nconst el = document.getElementById('my-element');\n\n// 마우스가 움직이는 이벤트를 옵저버블로 변환합니다.\nconst mouseMoves = fromEvent(el, 'mousemove');\n\n// 구독을 시작하고 마우스가 움직이는 이벤트를 처리합니다.\nconst <a href=\"api/service-worker/SwPush#subscription\" class=\"code-anchor\">subscription</a> = mouseMoves.subscribe((evt: MouseEvent) => {\n  // 마우스의 위치를 로그로 출력합니다.\n  console.log(`Coords: ${evt.clientX} X ${evt.clientY}`);\n\n  // 마우스가 화면 왼쪽 위로 움직이면 구독을 해지합니다.\n  if (evt.clientX &#x3C; 40 &#x26;&#x26; evt.clientY &#x3C; 40) {\n    subscription.unsubscribe();\n  }\n});\n\n\n</code-example>\n<!--\n<code-example path=\"rx-library/src/simple-creation.ts\" region=\"ajax\" header=\"Create an observable that creates an AJAX request\">\n\nimport { ajax } from &#39;rxjs/ajax&#39;;\n\n// AJAX 요청을 옵저버블로 변환합니다.\nconst apiData = ajax(&#39;/api/data&#39;);\n// 구독을 시작하고 AJAX 요청을 보냅니다.\napiData.subscribe(res =&gt; console.log(res.status, res.response));\n\n\n</code-example>\n-->\n<code-example path=\"rx-library/src/simple-creation.ts\" region=\"ajax\" header=\"AJAX 요청을 옵저버블로 변환하기\">\n\nimport { ajax } from 'rxjs/ajax';\n\n// AJAX 요청을 옵저버블로 변환합니다.\nconst apiData = ajax('/api/data');\n// 구독을 시작하고 AJAX 요청을 보냅니다.\napiData.subscribe(res => console.log(res.status, res.response));\n\n\n</code-example>\n<!--\n## Operators\n-->\n<h2 id=\"연산자-operators\">연산자 (Operators)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#연산자-operators\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nOperators are functions that build on the observables foundation to enable sophisticated manipulation of collections. For example, RxJS defines operators such as `map()`, `filter()`, `concat()`, and `flatMap()`.\n-->\n<p>RxJS에서 제공하는 연산자는 옵저버블의 기본 철학을 그대로 유지하면서 옵저버블을 다른 형태로 변환하는 함수입니다. RxJS는 <code><a href=\"api/core/QueryList#map\" class=\"code-anchor\">map()</a></code>나 <code><a href=\"api/core/QueryList#filter\" class=\"code-anchor\">filter()</a></code>, <code>concat()</code>, <code>flatMap()</code>과 같은 연산자를 제공합니다.</p>\n<!--\nOperators take configuration options, and they return a function that takes a source observable. When executing this returned function, the operator observes the source observable’s emitted values, transforms them, and returns a new observable of those transformed values. Here is a simple example:\n-->\n<p>연산자를 사용할 때는 옵저버블을 어떻게 변환할지 정의하는 함수를 함께 전달합니다. 이 함수는 옵저버블에서 데이터가 전달될 때마다 실행되고, 원래 옵저버블 데이터를 변환하며, 변환된 값을 새로운 옵저버블로 전달합니다. 간단한 예제를 봅시다:</p>\n<!--\n<code-example path=\"rx-library/src/operators.ts\" header=\"Map operator\">\n\nimport { map } from &#39;rxjs/operators&#39;;\n\nconst nums = of(1, 2, 3);\n\nconst squareValues = map((val: number) =&gt; val * val);\nconst squaredNums = squareValues(nums);\n\nsquaredNums.subscribe(x =&gt; console.log(x));\n\n// 로그\n// 1\n// 4\n// 9\n\n\n</code-example>\n-->\n<code-example path=\"rx-library/src/operators.ts\" header=\"Map 연산자\">\n\nimport { map } from 'rxjs/operators';\n\nconst nums = of(1, 2, 3);\n\nconst squareValues = map((val: number) => val * val);\nconst squaredNums = squareValues(nums);\n\nsquaredNums.subscribe(x => console.log(x));\n\n// 로그\n// 1\n// 4\n// 9\n\n\n</code-example>\n<!--\nYou can use _pipes_ to link operators together. Pipes let you combine multiple functions into a single function. The `pipe()` function takes as its arguments the functions you want to combine, and returns a new function that, when executed, runs the composed functions in sequence.\n-->\n<p>연산자는 <em>파이프</em> 를 사용해서 조합할 수도 있습니다. 이 때 파이프는 함수 여러개를 함수 하나인 것처럼 변환하는 함수입니다. 그래서 <code>pipe()</code> 함수는 인자로 조합할 함수를 받아서 이 함수들을 조합한 새로운 함수를 생성하고, 옵저버블에서 데이터가 전달될 때 순서대로 실행합니다.</p>\n<!--\nA set of operators applied to an observable is a recipe&mdash;that is, a set of instructions for producing the values you’re interested in. By itself, the recipe doesn’t do anything. You need to call `subscribe()` to produce a result through the recipe.\n-->\n<p>옵저버블에서 제공하는 연산자는 자유롭게 조합할 수 있지만, 이 연산자 그 자체로는 아무것도 하지 않습니다. 조합된 함수를 실행하려면 <code>subscribe()</code>를 실행해서 구독해야 합니다.</p>\n<!--\nHere’s an example:\n-->\n<p>예제를 봅시다:</p>\n<!--\n<code-example path=\"rx-library/src/operators.1.ts\" header=\"Standalone pipe function\">\n\nimport { filter, map } from &#39;rxjs/operators&#39;;\n\nconst nums = of(1, 2, 3, 4, 5);\n\n// 옵저버블을 처리하는 함수를 정의합니다.\nconst squareOddVals = pipe(\n  filter((n: number) =&gt; n % 2 !== 0),\n  map(n =&gt; n * n)\n);\n\n// filter()와 map()을 실행하는 옵저버블을 생성합니다.\nconst squareOdd = squareOddVals(nums);\n\n// 구독을 시작합니다.\nsquareOdd.subscribe(x =&gt; console.log(x));\n\n\n</code-example>\n-->\n<code-example path=\"rx-library/src/operators.1.ts\" header=\"함수로 제공되는 파이프\">\n\nimport { filter, map } from 'rxjs/operators';\n\nconst nums = of(1, 2, 3, 4, 5);\n\n// 옵저버블을 처리하는 함수를 정의합니다.\nconst squareOddVals = pipe(\n  filter((n: number) => n % 2 !== 0),\n  map(n => n * n)\n);\n\n// filter()와 map()을 실행하는 옵저버블을 생성합니다.\nconst squareOdd = squareOddVals(nums);\n\n// 구독을 시작합니다.\nsquareOdd.subscribe(x => console.log(x));\n\n\n</code-example>\n<!--\nThe `pipe()` function is also a method on the RxJS `Observable`, so you use this shorter form to define the same operation:\n-->\n<p>그리고 <code>pipe()</code> 함수는 RxJS <code>Observable</code> 클래스의 메소드로도 제공됩니다. 그래서 위 코드와 같은 동작을 다음과 같이 간단하게 구현할 수도 있습니다:</p>\n<!--\n<code-example path=\"rx-library/src/operators.2.ts\" header=\"Observable.pipe function\">\n\nimport { filter, map } from &#39;rxjs/operators&#39;;\n\nconst squareOdd = of(1, 2, 3, 4, 5)\n  .pipe(\n    filter(n =&gt; n % 2 !== 0),\n    map(n =&gt; n * n)\n  );\n\n// 구독을 시작합니다.\nsquareOdd.subscribe(x =&gt; console.log(x));\n\n\n</code-example>\n-->\n<code-example path=\"rx-library/src/operators.2.ts\" header=\"Observable.pipe 함수\">\n\nimport { filter, map } from 'rxjs/operators';\n\nconst squareOdd = of(1, 2, 3, 4, 5)\n  .pipe(\n    filter(n => n % 2 !== 0),\n    map(n => n * n)\n  );\n\n// 구독을 시작합니다.\nsquareOdd.subscribe(x => console.log(x));\n\n\n</code-example>\n<!--\n### Common operators\n-->\n<h3 id=\"공통-연산자\">공통 연산자<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#공통-연산자\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nRxJS provides many operators, but only a handful are used frequently. For a list of operators and usage samples, visit the [RxJS API Documentation](https://rxjs-dev.firebaseapp.com/api).\n-->\n<p>RxJS는 수많은 연산자를 제공하지만, 이 중 자주 사용하는 연산자는 일부입니다. RxJS가 제공하는 모든 연산자의 목록과 사용 방법을 보려면 <a href=\"https://rxjs-dev.firebaseapp.com/api\">RxJS API 문서</a>를 참고하세요.</p>\n<div class=\"alert is-helpful\">\n  <!--\n  Note that, for Angular apps, we prefer combining operators with pipes, rather than chaining. Chaining is used in many RxJS examples.\n  -->\n  Angular 애플리케이션에서는 연산자를 체이닝하는 것보다 Angular 파이프를 사용하는 것을 권장합니다.\n</div>\n<!--\n| Area | Operators |\n| :------------| :----------|\n| Creation |  `from`,`fromEvent`, `of` |\n| Combination | `combineLatest`, `concat`, `merge`, `startWith` , `withLatestFrom`, `zip` |\n| Filtering | `debounceTime`, `distinctUntilChanged`, `filter`, `take`, `takeUntil` |\n| Transformation | `bufferTime`, `concatMap`, `map`, `mergeMap`, `scan`, `switchMap` |\n| Utility | `tap` |\n| Multicasting | `share` |\n-->\n<table>\n<thead>\n<tr>\n<th align=\"left\">용도</th>\n<th align=\"left\">연산자</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">생성</td>\n<td align=\"left\"><code>from</code>, <code>fromPromise</code>,<code>fromEvent</code>, <code>of</code></td>\n</tr>\n<tr>\n<td align=\"left\">조합</td>\n<td align=\"left\"><code>combineLatest</code>, <code>concat</code>, <code>merge</code>, <code>startWith</code> , <code>withLatestFrom</code>, <code>zip</code></td>\n</tr>\n<tr>\n<td align=\"left\">필터링</td>\n<td align=\"left\"><code>debounceTime</code>, <code>distinctUntilChanged</code>, <code>filter</code>, <code>take</code>, <code>takeUntil</code></td>\n</tr>\n<tr>\n<td align=\"left\">변환</td>\n<td align=\"left\"><code>bufferTime</code>, <code>concatMap</code>, <code>map</code>, <code>mergeMap</code>, <code>scan</code>, <code>switchMap</code></td>\n</tr>\n<tr>\n<td align=\"left\">유틸</td>\n<td align=\"left\"><code>tap</code></td>\n</tr>\n<tr>\n<td align=\"left\">멀티캐스팅</td>\n<td align=\"left\"><code>share</code></td>\n</tr>\n</tbody>\n</table>\n<!--\n## Error handling\n-->\n<h2 id=\"에러-처리\">에러 처리<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#에러-처리\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nIn addition to the `error()` handler that you provide on subscription, RxJS provides the `catchError` operator that lets you handle known errors in the observable recipe.\n-->\n<p>옵저버블을 생성할 때 지정하는 <code>error</code> 핸들러와 비슷하게, RxJS에서 제공하는 <code>catchError</code> 연산자를 사용해서 에러를 처리할 수도 있습니다.</p>\n<!--\nFor instance, suppose you have an observable that makes an API request and maps to the response from the server. If the server returns an error or the value doesn’t exist, an error is produced. If you catch this error and supply a default value, your stream continues to process values rather than erroring out.\n-->\n<p>예를 들어, 서버로 API 요청을 보내고 서버에서 온 응답을 원하는 형태로 변환하는 옵저버블이 있다고 합시다. 그리고 서버에서 에러를 반환하거나 서버가 반환한 값이 없을 때 에러가 발생한다고 합시다. 이런 경우에 에러 대신 사용할 기본값을 지정하면 옵저버블이 에러로 중단되는 상황을 방지하면서 처리 로직을 계속 실행할 수 있습니다.</p>\n<!--\nHere's an example of using the `catchError` operator to do this:\n-->\n<p><code>catchError</code> 연산자는 다음과 같이 사용합니다:</p>\n<!--\n<code-example path=\"rx-library/src/error-handling.ts\" header=\"catchError operator\">\n\nimport { ajax } from &#39;rxjs/ajax&#39;;\nimport { map, catchError } from &#39;rxjs/operators&#39;;\n// API 요청 결과로 받은 객체에서 &quot;response&quot;를 반환합니다.\n// 에러가 발생하면 빈 배열을 반환합니다.\nconst apiData = ajax(&#39;/api/data&#39;).pipe(\n  map(res =&gt; {\n    if (!res.response) {\n      throw new Error(&#39;Value expected!&#39;);\n    }\n    return res.response;\n  }),\n  catchError(err =&gt; of([]))\n);\n\napiData.subscribe({\n  next(x) { console.log(&#39;data: &#39;, x); },\n  error(err) { console.log(&#39;errors already caught... will not run&#39;); }\n});\n\n\n</code-example>\n-->\n<code-example path=\"rx-library/src/error-handling.ts\" header=\"catchError 연산자\">\n\nimport { ajax } from 'rxjs/ajax';\nimport { map, catchError } from 'rxjs/operators';\n// API 요청 결과로 받은 객체에서 \"response\"를 반환합니다.\n// 에러가 발생하면 빈 배열을 반환합니다.\nconst apiData = ajax('/api/data').pipe(\n  map(res => {\n    if (!res.response) {\n      throw new <a href=\"api/core/MissingTranslationStrategy#Error\" class=\"code-anchor\">Error</a>('<a href=\"\" class=\"code-anchor\">Value</a> expected!');\n    }\n    return res.response;\n  }),\n  catchError(err => of([]))\n);\n\napiData.subscribe({\n  next(x) { console.log('data: ', x); },\n  error(err) { console.log('errors already caught... will not run'); }\n});\n\n\n</code-example>\n<!--\n### Retry failed observable\n-->\n<h3 id=\"실패한-옵저버블-재시도하기\">실패한 옵저버블 재시도하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#실패한-옵저버블-재시도하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nWhere the `catchError` operator provides a simple path of recovery, the `retry` operator lets you retry a failed request.\n-->\n<p><code>catchError</code> 연산자는 에러가 발생한 옵저버블을 복구할 때 간단하게 사용할 수 있으며, 이번에 알아볼 <code>retry</code> 연산자는 실패한 요청을 다시 시도합니다.</p>\n<!--\nUse the `retry` operator before the `catchError` operator. It resubscribes to the original source observable, which can then re-run the full sequence of actions that resulted in the error. If this includes an HTTP request, it will retry that HTTP request.\n-->\n<p><code>retry</code> 연산자는 <code>catchError</code> 를 실행하기 전에 먼저 지정합니다. 그러면 <code>retry</code> 연산자는 원래 옵저버블이 실패했을 때 옵저버블 생성을 다시 시도합니다.</p>\n<!--\nThe following converts the previous example to retry the request before catching the error:\n-->\n<p>아래 예제는 에러를 처리하기 전에 재시도하도록 수정한 예제 코드입니다:</p>\n<!--\n<code-example path=\"rx-library/src/retry-on-error.ts\" header=\"retry operator\">\n\nimport { ajax } from &#39;rxjs/ajax&#39;;\nimport { map, retry, catchError } from &#39;rxjs/operators&#39;;\n\nconst apiData = ajax(&#39;/api/data&#39;).pipe(\n  retry(3), // 옵저버블에 에러가 발생하면 3번 재시도합니다.\n  map(res =&gt; {\n    if (!res.response) {\n      throw new Error(&#39;Value expected!&#39;);\n    }\n    return res.response;\n  }),\n  catchError(err =&gt; of([]))\n);\n\napiData.subscribe({\n  next(x) { console.log(&#39;data: &#39;, x); },\n  error(err) { console.log(&#39;errors already caught... will not run&#39;); }\n});\n\n\n</code-example>\n-->\n<code-example path=\"rx-library/src/retry-on-error.ts\" header=\"retry 연산자\">\n\nimport { ajax } from 'rxjs/ajax';\nimport { map, retry, catchError } from 'rxjs/operators';\n\nconst apiData = ajax('/api/data').pipe(\n  retry(3), // 옵저버블에 에러가 발생하면 3번 재시도합니다.\n  map(res => {\n    if (!res.response) {\n      throw new <a href=\"api/core/MissingTranslationStrategy#Error\" class=\"code-anchor\">Error</a>('<a href=\"\" class=\"code-anchor\">Value</a> expected!');\n    }\n    return res.response;\n  }),\n  catchError(err => of([]))\n);\n\napiData.subscribe({\n  next(x) { console.log('data: ', x); },\n  error(err) { console.log('errors already caught... will not run'); }\n});\n\n\n</code-example>\n<div class=\"alert is-helpful\">\n   <!--\n   Do not retry **authentication** requests, since these should only be initiated by user action. We don't want to lock out user accounts with repeated login requests that the user has not initiated.\n   -->\n<p>   <strong>사용자 인증이 필요한</strong> 요청은 재시도하지 마세요. 이 동작은 사용자에 의해서만 수행되어야 합니다. 사용자가 요청하지 않은 상태에서 계속 로그인 시도가 된다면 비정상적인 공격 시도로 처리될 수 잇습니다.</p>\n</div>\n<!--\n## Naming conventions for observables\n-->\n<h2 id=\"옵저버블-변수-명명-규칙\">옵저버블 변수 명명 규칙<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#옵저버블-변수-명명-규칙\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nBecause Angular applications are mostly written in TypeScript, you will typically know when a variable is an observable. Although the Angular framework does not enforce a naming convention for observables, you will often see observables named with a trailing “$” sign.\n-->\n<p>Angular 애플리케이션은 TypeScript로 작성하기 때문에 어떤 변수가 옵저버블인지는 쉽게 구분할 수 있습니다. 이런 옵저버블 변수의 이름을 지을 때 특별한 규칙을 강요하지는 않지만, 옵저버블 변수는 이름 뒤에 \"$\"를 붙이는 것이 좋습니다.</p>\n<!--\nThis can be useful when scanning through code and looking for observable values. Also, if you want a property to store the most recent value from an observable, it can be convenient to simply use the same name with or without the “$”.\n-->\n<p>변수 이름을 이렇게 지으면 코드를 보면서 어떤 것이 옵저버블인지 좀 더 확실하게 확인할 수 있습니다. 그리고 옵저버블에서 받은 데이터 중에 자주 사용하는 것이 있으면 \"$\"를 뺀 프로퍼티를 따로 선언하는 것이 사용하기 편합니다.</p>\n<!--\nFor example:\n-->\n<p>예제 코드를 봅시다:</p>\n<code-example path=\"rx-library/src/naming-convention.ts\" header=\"Naming observables\">\n\n\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { Observable } from 'rxjs';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-stopwatch',\n  templateUrl: './stopwatch.component.html'\n})\nexport class StopwatchComponent {\n\n  stopwatchValue: number;\n  stopwatchValue$: Observable&#x3C;number>;\n\n  start() {\n    this.stopwatchValue$.subscribe(num =>\n      this.stopwatchValue = num\n    );\n  }\n}\n\n\n</code-example>\n\n</div>\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/core/Component\n - api/core/MissingTranslationStrategy#Error\n - api/core/QueryList#filter\n - api/core/QueryList#map\n - api/service-worker/SwPush#subscription\n - guide/rx-library#rxjs-라이브러리\n - guide/rx-library#공통-연산자\n - guide/rx-library#실패한-옵저버블-재시도하기\n - guide/rx-library#에러-처리\n - guide/rx-library#연산자-operators\n - guide/rx-library#옵저버블-변수-명명-규칙\n - guide/rx-library#옵저버블-생성-함수\n - http://reactivex.io/rxjs/\n - https://en.wikipedia.org/wiki/Reactive_programming\n - https://github.com/angular/angular/edit/master/aio/content/guide/rx-library.md?message=docs%3A%20describe%20your%20change...\n - https://rxjs-dev.firebaseapp.com/api\n-->"
}