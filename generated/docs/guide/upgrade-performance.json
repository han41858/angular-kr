{
  "id": "guide/upgrade-performance",
  "title": "Upgrading for Performance",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/upgrade-performance.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"upgrading-for-performance\">Upgrading for Performance<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#upgrading-for-performance\"><i class=\"material-icons\">link</i></a></h1>\n<div class=\"alert is-helpful\">\n<p>  <em>Angular</em> is the name for the Angular of today and tomorrow.<br>\n<em>AngularJS</em> is the name for all 1.x versions of Angular.</p>\n</div>\n<p>This guide describes some of the built-in tools for efficiently migrating AngularJS projects over to\nthe Angular platform, one piece at a time. It is very similar to\n<a href=\"guide/upgrade\">Upgrading from AngularJS</a> with the exception that this one uses the <a href=\"api/upgrade/static/downgradeModule\">downgradeModule()</a> helper function instead of the <a href=\"api/upgrade/static/UpgradeModule\">UpgradeModule</a> class. This affects how the app is bootstrapped and how change detection is\npropagated between the two frameworks. It allows you to upgrade incrementally while improving the\nspeed of your hybrid apps and leveraging the latest of Angular in AngularJS apps early in the\nprocess of upgrading.</p>\n<h2 id=\"preparation\">Preparation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#preparation\"><i class=\"material-icons\">link</i></a></h2>\n<p>Before discussing how you can use <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> to create hybrid apps, there are things that\nyou can do to ease the upgrade process even before you begin upgrading. Because the steps are the\nsame regardless of how you upgrade, refer to the <a href=\"guide/upgrade#preparation\">Preparation</a> section of\n<a href=\"guide/upgrade\">Upgrading from AngularJS</a>.</p>\n<h2 id=\"upgrading-with-ngupgrade\">Upgrading with <code>ngUpgrade</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#upgrading-with-ngupgrade\"><i class=\"material-icons\">link</i></a></h2>\n<p>With the <code>ngUpgrade</code> library in Angular you can upgrade an existing AngularJS app incrementally by\nbuilding a hybrid app where you can run both frameworks side-by-side. In these hybrid apps you can\nmix and match AngularJS and Angular components and services and have them interoperate seamlessly.\nThat means you don't have to do the upgrade work all at once as there is a natural coexistence\nbetween the two frameworks during the transition period.</p>\n<h3 id=\"how-ngupgrade-works\">How <code>ngUpgrade</code> Works<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#how-ngupgrade-works\"><i class=\"material-icons\">link</i></a></h3>\n<p>Regardless of whether you choose <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> or <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>, the basic principles of\nupgrading, the mental model behind hybrid apps, and how you use the <a href=\"api/upgrade/static\">upgrade/static</a> utilities remain the same. For more information, see the\n<a href=\"guide/upgrade#how-ngupgrade-works\">How <code>ngUpgrade</code> Works</a> section of\n<a href=\"guide/upgrade\">Upgrading from AngularJS</a>.</p>\n<div class=\"alert is-helpful\">\n<p>  The <a href=\"guide/upgrade#change-detection\">Change Detection</a> section of\n<a href=\"guide/upgrade\">Upgrading from AngularJS</a> only applies to apps that use <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>. Though\nyou handle change detection differently with <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code>, which is the focus of this\nguide, reading the <a href=\"guide/upgrade#change-detection\">Change Detection</a> section provides helpful\ncontext for what follows.</p>\n</div>\n<h4 id=\"change-detection-with-downgrademodule\">Change Detection with <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#change-detection-with-downgrademodule\"><i class=\"material-icons\">link</i></a></h4>\n<p>As mentioned before, one of the key differences between <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> and <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> has\nto do with change detection and how it is propagated between the two frameworks.</p>\n<p>With <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>, the two change detection systems are tied together more tightly. Whenever\nsomething happens in the AngularJS part of the app, change detection is automatically triggered on\nthe Angular part and vice versa. This is convenient as it ensures that neither framework misses an\nimportant change. Most of the time, though, these extra change detection runs are unnecessary.</p>\n<p><code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code>, on the other side, avoids explicitly triggering change detection unless it\nknows the other part of the app is interested in the changes. For example, if a downgraded component\ndefines an <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>, chances are that the app needs to be aware when that value changes. Thus,\n<code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> automatically triggers change detection on that component.</p>\n<p>In most cases, though, the changes made locally in a particular component are of no interest to the\nrest of the app. For example, if the user clicks a button that submits a form, the component usually\nhandles the result of this action. That being said, there <em>are</em> cases where you want to propagate\nchanges to some other part of the app that may be controlled by the other framework. In such cases,\nyou are responsible for notifying the interested parties by manually triggering change detection.</p>\n<p>If you want a particular piece of code to trigger change detection in the AngularJS part of the app,\nyou need to wrap it in\n<a href=\"https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$apply\">scope.$apply()</a>. Similarly, for\ntriggering change detection in Angular you would use <a href=\"api/core/NgZone#run\">ngZone.run()</a>.</p>\n<p>In many cases, a few extra change detection runs may not matter much. However, on larger or\nchange-detection-heavy apps they can have a noticeable impact. By giving you more fine-grained\ncontrol over the change detection propagation, <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> allows you to achieve better\nperformance for your hybrid apps.</p>\n<h2 id=\"using-downgrademodule\">Using <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#using-downgrademodule\"><i class=\"material-icons\">link</i></a></h2>\n<p>Both AngularJS and Angular have their own concept of modules to help organize an app into cohesive\nblocks of functionality.</p>\n<p>Their details are quite different in architecture and implementation. In AngularJS, you create a\nmodule by specifying its name and dependencies with\n<a href=\"https://docs.angularjs.org/api/ng/function/angular.module\">angular.module()</a>. Then you can add\nassets using its various methods. In Angular, you create a class adorned with an <a href=\"api/core/NgModule\">NgModule</a> decorator that describes assets in metadata.</p>\n<p>In a hybrid app you run both frameworks at the same time. This means that you need at least one\nmodule each from both AngularJS and Angular.</p>\n<p>For the most part, you specify the modules in the same way you would for a regular app. Then, you\nuse the <code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> helpers to let the two frameworks know about assets they can use from each\nother. This is known as \"upgrading\" and \"downgrading\".</p>\n<div class=\"alert is-helpful\">\n<p>  <b>Definitions:</b></p>\n<ul>\n<li><em>Upgrading</em>: The act of making an AngularJS asset, such as a component or service, available to\nthe Angular part of the app.</li>\n<li><em>Downgrading</em>: The act of making an Angular asset, such as a component or service, available to\nthe AngularJS part of the app.</li>\n</ul>\n</div>\n<p>An important part of inter-linking dependencies is linking the two main modules together. This is\nwhere <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> comes in. Use it to create an AngularJS module—one that you can use\nas a dependency in your main AngularJS module—that will bootstrap your main Angular module and\nkick off the Angular part of the hybrid app. In a sense, it \"downgrades\" an Angular module to an\nAngularJS module.</p>\n<p>There are a few things to note, though:</p>\n<ol>\n<li>\n<p>You don't pass the Angular module directly to <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code>. All <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> needs\nis a \"recipe\", for example, a factory function, to create an instance for your module.</p>\n</li>\n<li>\n<p>The Angular module is not instantiated until the app actually needs it.</p>\n</li>\n</ol>\n<p>The following is an example of how you can use <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> to link the two modules.</p>\n<code-example language=\"ts\">\n// Import `<a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()`.\nimport { <a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\n// Use it to downgrade the Angular module to an AngularJS module.\nconst downgradedModule = <a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>(MainAngularModuleFactory);\n\n// Use the downgraded module as <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> dependency to the main AngularJS module.\nangular.module('mainAngularJsModule', [\n  downgradedModule\n]);\n</code-example>\n<h4 id=\"specifying-a-factory-for-the-angular-module\">Specifying a factory for the Angular module<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#specifying-a-factory-for-the-angular-module\"><i class=\"material-icons\">link</i></a></h4>\n<p>As mentioned earlier, <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> needs to know how to instantiate the Angular module. It\nneeds a recipe. You define that recipe by providing a factory function that can create an instance\nof the Angular module. <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> accepts two types of factory functions:</p>\n<ol>\n<li><code><a href=\"api/core/NgModuleFactory\" class=\"code-anchor\">NgModuleFactory</a></code></li>\n<li><code>(extraProviders: <a href=\"api/core/StaticProvider\" class=\"code-anchor\">StaticProvider</a>[]) => Promise&#x3C;<a href=\"api/core/NgModuleRef\" class=\"code-anchor\">NgModuleRef</a>></code></li>\n</ol>\n<p>When you pass an <code><a href=\"api/core/NgModuleFactory\" class=\"code-anchor\">NgModuleFactory</a></code>, <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> uses it to instantiate the module using\n<a href=\"api/platform-browser/platformBrowser\">platformBrowser</a>'s <a href=\"api/core/PlatformRef#bootstrapModuleFactory\">bootstrapModuleFactory()</a>, which is compatible with ahead-of-time (AOT) compilation. AOT compilation\nhelps make your apps load faster. For more about AOT and how to create an <code><a href=\"api/core/NgModuleFactory\" class=\"code-anchor\">NgModuleFactory</a></code>, see the\n<a href=\"guide/aot-compiler\">Ahead-of-Time Compilation</a> guide.</p>\n<p>Alternatively, you can pass a plain function, which is expected to return a promise resolving to an\n<a href=\"api/core/NgModuleRef\">NgModuleRef</a> (i.e. an instance of your Angular module). The function is called\nwith an array of extra <a href=\"api/core/StaticProvider\">Providers</a> that are expected to be available on the\nreturned <code><a href=\"api/core/NgModuleRef\" class=\"code-anchor\">NgModuleRef</a></code>'s <a href=\"api/core/Injector\">Injector</a>. For example, if you are using <a href=\"api/platform-browser/platformBrowser\">platformBrowser</a> or <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\">platformBrowserDynamic</a>, you can\npass the <code>extraProviders</code> array to them:</p>\n<code-example language=\"ts\">\nconst bootstrapFn = (extraProviders: <a href=\"api/core/StaticProvider\" class=\"code-anchor\">StaticProvider</a>[]) => {\n  const platformRef = <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>(extraProviders);\n  return platformRef.bootstrapModule(MainAngularModule);\n};\n// or\nconst bootstrapFn = (extraProviders: <a href=\"api/core/StaticProvider\" class=\"code-anchor\">StaticProvider</a>[]) => {\n  const platformRef = <a href=\"api/platform-browser/platformBrowser\" class=\"code-anchor\">platformBrowser</a>(extraProviders);\n  return platformRef.bootstrapModuleFactory(MainAngularModuleFactory);\n};\n</code-example>\n<p>Using an <code><a href=\"api/core/NgModuleFactory\" class=\"code-anchor\">NgModuleFactory</a></code> requires less boilerplate and is a good default option as it supports AOT\nout-of-the-box. Using a custom function requires slightly more code, but gives you greater\nflexibility.</p>\n<h4 id=\"instantiating-the-angular-module-on-demand\">Instantiating the Angular module on-demand<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#instantiating-the-angular-module-on-demand\"><i class=\"material-icons\">link</i></a></h4>\n<p>Another key difference between <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> and <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> is that the latter requires\nyou to instantiate both the AngularJS and Angular modules up-front. This means that you have to pay\nthe cost of instantiating the Angular part of the app, even if you don't use any Angular assets\nuntil later. <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> is again less aggressive. It will only instantiate the Angular part\nwhen it is required for the first time; that is, as soon as it needs to create a downgraded\ncomponent.</p>\n<p>You could go a step further and not even download the code for the Angular part of the app to the\nuser's browser until it is needed. This is especially useful when you use Angular on parts of the\nhybrid app that are not necessary for the initial rendering or that the user doesn't reach.</p>\n<p>A few examples are:</p>\n<ul>\n<li>You use Angular on specific routes only and you don't need it until/if a user visits such a route.</li>\n<li>You use Angular for features that are only visible to specific types of users; for example,\nlogged-in users, administrators, or VIP members. You don't need to load Angular until a user is\nauthenticated.</li>\n<li>You use Angular for a feature that is not critical for the initial rendering of the app and you\ncan afford a small delay in favor of better initial load performance.</li>\n</ul>\n<h3 id=\"bootstrapping-with-downgrademodule\">Bootstrapping with <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#bootstrapping-with-downgrademodule\"><i class=\"material-icons\">link</i></a></h3>\n<p>As you might have guessed, you don't need to change anything in the way you bootstrap your existing\nAngularJS app. Unlike <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>—which requires some extra steps—\n<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> is able to take care of bootstrapping the Angular module, as long as you provide\nthe recipe.</p>\n<p>In order to start using any <code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> APIs, you still need to load the Angular framework as\nyou would in a normal Angular app. You can see how this can be done with SystemJS by following the\ninstructions in the <a href=\"guide/setup\">Setup</a> guide, selectively copying code from the\n<a href=\"https://github.com/angular/quickstart\">QuickStart github repository</a>.</p>\n<p>You also need to install the <code>@angular/upgrade</code> package via <code>npm install @angular/upgrade --save</code>\nand add a mapping for the <code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> package:</p>\n<code-example header=\"system.config.js\">\n'@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>': 'npm:@angular/upgrade/bundles/upgrade-static.umd.js',\n</code-example>\n<p>Next, create an <code>app.module.ts</code> file and add the following <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> class:</p>\n<code-example header=\"app.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>\n  ]\n})\nexport class MainAngularModule {\n  // Empty placeholder method to satisfy the `<a href=\"api/core/Compiler\" class=\"code-anchor\">Compiler</a>`.\n  ngDoBootstrap() {}\n}\n</code-example>\n<p>This bare minimum <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> imports <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>, the module every Angular browser-based app\nmust have. It also defines an empty <code>ngDoBootstrap()</code> method, to prevent the <a href=\"api/core/Compiler\">Compiler</a> from returning errors. This is necessary because the module will not have a <code>bootstrap</code>\ndeclaration on its <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> decorator.</p>\n<div class=\"alert is-important\">\n<p>  You do not add a <code>bootstrap</code> declaration to the <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> decorator since AngularJS owns the root\ntemplate of the app and <code>ngUpgrade</code> bootstraps the necessary components.</p>\n</div>\n<p>You can now link the AngularJS and Angular modules together using <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code>.</p>\n<code-example header=\"app.module.ts\">\nimport { <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a> } from '@angular/platform-browser-dynamic';\nimport { <a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nconst bootstrapFn = (extraProviders: <a href=\"api/core/StaticProvider\" class=\"code-anchor\">StaticProvider</a>[]) => {\n  const platformRef = <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>(extraProviders);\n  return platformRef.bootstrapModule(MainAngularModule);\n};\nconst downgradedModule = <a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>(bootstrapFn);\n\nangular.module('mainAngularJsModule', [\n  downgradedModule\n]);\n</code-example>\n<p>The existing AngularJS code works as before <em>and</em> you are ready to start adding Angular code.</p>\n<h3 id=\"using-components-and-injectables\">Using Components and Injectables<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#using-components-and-injectables\"><i class=\"material-icons\">link</i></a></h3>\n<p>The differences between <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> and <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> end here. The rest of the\n<code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> APIs and concepts work in the exact same way for both types of hybrid apps.\nSee <a href=\"guide/upgrade\">Upgrading from AngularJS</a> to learn about:</p>\n<ul>\n<li><a href=\"guide/upgrade#using-angular-components-from-angularjs-code\">Using Angular Components from AngularJS Code</a>.<br>\n<em>NOTE: If you are downgrading multiple modules, you need to specify the name of the downgraded\nmodule each component belongs to, when calling <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code>.</em></li>\n<li><a href=\"guide/upgrade#using-angularjs-component-directives-from-angular-code\">Using AngularJS Component Directives from Angular Code</a>.</li>\n<li><a href=\"guide/upgrade#projecting-angularjs-content-into-angular-components\">Projecting AngularJS Content into Angular Components</a>.</li>\n<li><a href=\"guide/upgrade#transcluding-angular-content-into-angularjs-component-directives\">Transcluding Angular Content into AngularJS Component Directives</a>.</li>\n<li><a href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\">Making AngularJS Dependencies Injectable to Angular</a>.</li>\n<li><a href=\"guide/upgrade#making-angular-dependencies-injectable-to-angularjs\">Making Angular Dependencies Injectable to AngularJS</a>.<br>\n<em>NOTE: If you are downgrading multiple modules, you need to specify the name of the downgraded\nmodule each injectable belongs to, when calling <code><a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>()</code>.</em></li>\n</ul>\n<div class=\"alert is-important\">\n<p>  While it is possible to downgrade injectables, downgraded injectables will not be available until\nthe Angular module that provides them is instantiated. In order to be safe, you need to ensure\nthat the downgraded injectables are not used anywhere <em>outside</em> the part of the app where it is\nguaranteed that their module has been instantiated.</p>\n<p>  For example, it is <em>OK</em> to use a downgraded service in an upgraded component that is only used\nfrom a downgraded Angular component provided by the same Angular module as the injectable, but it\nis <em>not OK</em> to use it in an AngularJS component that may be used independently of Angular or use\nit in a downgraded Angular component from a different module.</p>\n</div>\n<h2 id=\"using-ahead-of-time-compilation-with-hybrid-apps\">Using ahead-of-time compilation with hybrid apps<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#using-ahead-of-time-compilation-with-hybrid-apps\"><i class=\"material-icons\">link</i></a></h2>\n<p>You can take advantage of ahead-of-time (AOT) compilation in hybrid apps just like in any other\nAngular app. The setup for a hybrid app is mostly the same as described in the\n<a href=\"guide/aot-compiler\">Ahead-of-Time Compilation</a> guide save for differences in <code>index.html</code> and\n<code>main-aot.ts</code>.</p>\n<p>AOT needs to load any AngularJS files that are in the <code>&#x3C;script></code> tags in the AngularJS <code>index.html</code>.\nAn easy way to copy them is to add each to the <code>copy-dist-files.js</code>file.</p>\n<p>You also need to pass the generated <code>MainAngularModuleFactory</code> to <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> instead of the\ncustom bootstrap function:</p>\n<code-example header=\"app/main-aot.ts\">\nimport { <a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\nimport { MainAngularModuleNgFactory } from '../aot/app/app.module.ngfactory';\n\nconst downgradedModule = <a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>(MainAngularModuleNgFactory);\n\nangular.module('mainAngularJsModule', [\n  downgradedModule\n]);\n</code-example>\n<p>And that is all you need to do to get the full benefit of AOT for hybrid Angular apps.</p>\n<h2 id=\"conclusion\">Conclusion<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#conclusion\"><i class=\"material-icons\">link</i></a></h2>\n<p>This page covered how to use the <a href=\"api/upgrade/static\">upgrade/static</a> package to incrementally\nupgrade existing AngularJS apps at your own pace and without impeding further development of the app\nfor the duration of the upgrade process.</p>\n<p>Specifically, this guide showed how you can achieve better performance and greater flexibility in\nyour hybrid apps by using <a href=\"api/upgrade/static/downgradeModule\">downgradeModule()</a> instead of <a href=\"api/upgrade/static/UpgradeModule\">UpgradeModule</a>.</p>\n<p>To summarize, the key differentiating factors of <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> are:</p>\n<ol>\n<li>It allows instantiating or even loading the Angular part lazily, which improves the initial\nloading time. In some cases this may waive the cost of running a second framework altogether.</li>\n<li>It improves performance by avoiding unnecessary change detection runs while giving the developer\ngreater ability to customize.</li>\n<li>It does not require you to change how you bootstrap your AngularJS app.</li>\n</ol>\n<p>Using <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> is a good option for hybrid apps when you want to keep the AngularJS and\nAngular parts less coupled. You can still mix and match components and services from both\nframeworks, but you might need to manually propagate change detection. In return,\n<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> offers more control and better performance.</p>\n\n</div>\n\n<!-- links to this doc:\n - api/upgrade/static/downgradeModule\n - guide/setup\n-->\n<!-- links from this doc:\n - api/core/Compiler\n - api/core/Injector\n - api/core/Input\n - api/core/NgModule\n - api/core/NgModuleFactory\n - api/core/NgModuleRef\n - api/core/NgZone#run\n - api/core/PlatformRef#bootstrapModuleFactory\n - api/core/StaticProvider\n - api/platform-browser-dynamic/platformBrowserDynamic\n - api/platform-browser/BrowserModule\n - api/platform-browser/platformBrowser\n - api/router/RouterLinkWithHref\n - api/upgrade/static\n - api/upgrade/static/UpgradeModule\n - api/upgrade/static/downgradeComponent\n - api/upgrade/static/downgradeInjectable\n - api/upgrade/static/downgradeModule\n - guide/aot-compiler\n - guide/setup\n - guide/upgrade\n - guide/upgrade#change-detection\n - guide/upgrade#how-ngupgrade-works\n - guide/upgrade#making-angular-dependencies-injectable-to-angularjs\n - guide/upgrade#making-angularjs-dependencies-injectable-to-angular\n - guide/upgrade#preparation\n - guide/upgrade#projecting-angularjs-content-into-angular-components\n - guide/upgrade#transcluding-angular-content-into-angularjs-component-directives\n - guide/upgrade#using-angular-components-from-angularjs-code\n - guide/upgrade#using-angularjs-component-directives-from-angular-code\n - guide/upgrade-performance#bootstrapping-with-downgrademodule\n - guide/upgrade-performance#change-detection-with-downgrademodule\n - guide/upgrade-performance#conclusion\n - guide/upgrade-performance#how-ngupgrade-works\n - guide/upgrade-performance#instantiating-the-angular-module-on-demand\n - guide/upgrade-performance#preparation\n - guide/upgrade-performance#specifying-a-factory-for-the-angular-module\n - guide/upgrade-performance#upgrading-for-performance\n - guide/upgrade-performance#upgrading-with-ngupgrade\n - guide/upgrade-performance#using-ahead-of-time-compilation-with-hybrid-apps\n - guide/upgrade-performance#using-components-and-injectables\n - guide/upgrade-performance#using-downgrademodule\n - https://docs.angularjs.org/api/ng/function/angular.module\n - https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$apply\n - https://github.com/angular/angular/edit/master/aio/content/guide/upgrade-performance.md?message=docs%3A%20describe%20your%20change...\n - https://github.com/angular/quickstart\n-->"
}