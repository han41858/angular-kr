{
  "id": "guide/template-typecheck",
  "title": "템플릿 타입 검사",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/template-typecheck.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Template type checking\n-->\n<h1 id=\"템플릿-타입-검사\">템플릿 타입 검사<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#템플릿-타입-검사\"><i class=\"material-icons\">link</i></a></h1>\n<!--\n## Overview of template type checking\n-->\n<h2 id=\"개요\">개요<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#개요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nJust as TypeScript catches type errors in your code, Angular checks the expressions and bindings within the templates of your application and can report any type errors it finds.\nAngular currently has three modes of doing this, depending on the value of the `fullTemplateTypeCheck` and `strictTemplates` flags in the [TypeScript configuration file](guide/typescript-configuration).\n-->\n<p>TypeScript 컴파일러가 TypeScript 코드에서 타입 에러를 찾아내는 것과 마찬가지로, Angular 컴파일러도 템플릿에 사용된 표현식이나 바인딩 문법에서 에러를 찾아냅니다.\n현재 Angular가 제공하는 타입 검사 모드는 3종류인데, <a href=\"guide/typescript-configuration\">TypeScript 환경설정 파일</a>에서 <code>fullTemplateTypeCheck</code>, <code>strictTemplates</code> 플래그로 지정합니다.</p>\n<!--\n### Basic mode\n-->\n<h3 id=\"기본basic-모드\">기본(Basic) 모드<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#기본basic-모드\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn the most basic type-checking mode, with the `fullTemplateTypeCheck` flag set to `false`, Angular validates only top-level expressions in a template.\n\nIf you write `<map [city]=\"user.address.city\">`, the compiler verifies the following:\n\n* `user` is a property on the component class.\n* `user` is an object with an address property.\n* `user.address` is an object with a city property.\n\nThe compiler does not verify that the value of `user.address.city` is assignable to the city input of the `<map>` component.\n\nThe compiler also has some major limitations in this mode:\n\n* Importantly, it doesn't check embedded views, such as `*ngIf`, `*ngFor`, other `<ng-template>` embedded view.\n* It doesn't figure out the types of `#refs`, the results of pipes, the type of `$event` in event bindings, and so on.\n\nIn many cases, these things end up as type `any`, which can cause subsequent parts of the expression to go unchecked.\n-->\n<p><code>fullTemplateTypeCheck</code> 플래그 값을 <code>false</code>로 설정하면 가장 기본적인 타입 검사 모드가 동작합니다.\n이 모드에서는 Angular가 템플릿 표현식을 아주 간단하게만 검사합니다.</p>\n<p>이 모드는 <code>&#x3C;map [city]=\"user.address.city\"></code>라는 코드가 다음 기준에 적합한지 판단합니다:</p>\n<ul>\n<li><code>user</code>는 컴포넌트 클래스의 프로퍼티입니다.</li>\n<li><code>user</code>는 객체이며 이 객체에는 <code>address</code> 프로퍼티가 존재합니다.</li>\n<li><code>user.address</code>는 객체이며 이 객체에는 <code>city</code> 프로퍼티가 존재합니다.</li>\n</ul>\n<p>컴파일러는 <code>user.address.city</code> 값이 <code>&#x3C;map></code> 컴포넌트의 입력값으로 적합한지는 검사하지 않습니다.</p>\n<p>그리고 다음과 같은 기능도 동작하지 않습니다:</p>\n<ul>\n<li><code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>, <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>, <code>&#x3C;ng-template></code>과 같은 임베디드 뷰(embedded view)는 검사하지 않습니다.</li>\n<li><code>#refs</code>로 참조하는 타입, 파이프 처리 결과, 이벤트 바인딩에 사용된 <code>$event</code>의 타입도 검사하지 않습니다.</li>\n</ul>\n<p>기본 모드에서는 이 항목들을 <code>any</code> 타입으로 처리하며, 표현식 나머지 부분의 타입 검사는 생략합니다.</p>\n<!--\n### Full mode\n-->\n<h3 id=\"전체검사full-모드\">전체검사(Full) 모드<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#전체검사full-모드\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIf the `fullTemplateTypeCheck` flag is set to `true`, Angular is more aggressive in its type-checking within templates.\nIn particular:\n\n* Embedded views (such as those within an `*ngIf` or `*ngFor`) are checked.\n* Pipes have the correct return type.\n* Local references to directives and pipes have the correct type (except for any generic parameters, which will be `any`).\n\nThe following still have type `any`.\n\n* Local references to DOM elements.\n* The `$event` object.\n* Safe navigation expressions.\n-->\n<p><code>fullTemplateTypeCheck</code> 플래그 값을 <code>true</code>로 설정하면 조금 더 강력한 타입 검사 모드가 동작합니다.\n이런 기능이 추가됩니다:</p>\n<ul>\n<li><code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>, <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 안에 사용된 임베디드 뷰도 검사합니다.</li>\n<li>파이프가 처리한 결과도 적절한 타입이어야 합니다.</li>\n<li>디렉티브나 파이프에 사용하는 로컬 참조 변수 적절한 타입이어야 합니다. 다만, 제네릭은 <code>any</code> 타입으로 간주합니다.</li>\n</ul>\n<p>하지만 다음 항목들은 여전히 <code>any</code> 타입으로 처리합니다.</p>\n<ul>\n<li>DOM 엘리먼트에 사용된 로컬 참조 변수</li>\n<li><code>$event</code> 객체</li>\n<li>안전 참조 연산자</li>\n</ul>\n<a id=\"strict-mode\"></a>\n<!--\n### Strict mode\n-->\n<h3 id=\"엄격한strict-모드\">엄격한(Strict) 모드<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#엄격한strict-모드\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAngular version 9 maintains the behavior of the `fullTemplateTypeCheck` flag, and introduces a third \"strict mode\".\nStrict mode is a superset of full mode, and is accessed by setting the `strictTemplates` flag to true. This flag supersedes the `fullTemplateTypeCheck` flag.\nIn strict mode, Angular version 9 adds checks that go beyond the version 8 type-checker.\nNote that strict mode is only available if using Ivy.\n\nIn addition to the full mode behavior, Angular version 9:\n\n* Verifies that component/directive bindings are assignable to their `@Input()`s.\n* Obeys TypeScript's `strictNullChecks` flag when validating the above.\n* Infers the correct type of components/directives, including generics.\n* Infers template context types where configured (for example, allowing correct type-checking of `NgFor`).\n* Infers the correct type of `$event` in component/directive, DOM, and animation event bindings.\n* Infers the correct type of local references to DOM elements, based on the tag name (for example, the type that `document.createElement` would return for that tag).\n-->\n<p>Angular 9버전부터는 <code>fullTemplateTypeCheck</code> 플래그 외에 엄격한 모드를 추가로 도입했습니다.\n엄격한 모드는 <code>strictTemplates</code> 플래그 값을 <code>true</code>로 설정하면 활성화되는데, 이렇게 설정하면 <code>fullTemplateTypeCheck</code> 플래그의 값은 어떤값이든 관계없습니다.\n이 모드는 전체검사 모드의 검사 기능을 모두 포함합니다.\n하지만 Ivy를 사용할 때만 동작한다는 것을 명심하세요.</p>\n<p>이 모드에서는 전체검사 모드에 추가로 다음과 같은 내용을 검사합니다:</p>\n<ul>\n<li>컴포넌트/디렉티브에 바인딩 된 객체의 타입이 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>과 맞는지 검사합니다. 이 과정에 TypeScript <code>strictNullChecks</code> 플래그도 활용합니다.</li>\n<li>컴포넌트/디렉티브에 적절한 타입이 사용되었는지 검사하며, 이 때 제네릭도 검사합니다.</li>\n<li>템플릿 컨텍스트에 사용된 객체의 타입도 검사합니다. <code>NgFor</code>도 검사 대상입니다.</li>\n<li>컴포넌트/디렉티브, DOM, 애니메이션 이벤트 바인딩에 사용되는 <code>$event</code> 객체의 타입이 적절한지 검사합니다.</li>\n<li>DOM 엘리먼트를 참조하는 로컬 참조 변수가 적절한 타입인지 검사합니다. <code>document.createElement</code>를 쓴 경우에도 마찬가지입니다.</li>\n</ul>\n<!--\n## Checking of `*ngFor`\n-->\n<h2 id=\"ngfor로-비교해보기\"><code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>로 비교해보기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#ngfor로-비교해보기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe three modes of type-checking treat embedded views differently. Consider the following example.\n-->\n<p>세가지 타입 검사 모드는 각각 임베디드 뷰에서 타입을 검사하는 방식이 조금씩 다릅니다. 예제를 보면서 알아봅시다.</p>\n<code-example language=\"ts\" header=\"User interface\">\n\ninterface User {\n  name: string;\n  address: {\n    city: string;\n    <a href=\"api/animations/state\" class=\"code-anchor\">state</a>: string;\n  }\n}\n\n</code-example>\n<code-example language=\"html\">\n  &#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let user of users\">\n    &#x3C;h2>{{config.title}}&#x3C;/h2>\n    &#x3C;span>City: {{user.address.city}}&#x3C;/span>\n  &#x3C;/div>\n</code-example>\n<!--\nThe `<h2>` and the `<span>` are in the `*ngFor` embedded view.\nIn basic mode, Angular doesn't check either of them.\nHowever, in full mode, Angular checks that `config` and `user` exist and assumes a type of `any`.\nIn strict mode, Angular knows that the `user` in the `<span>` has a type of `User`, and that `address` is an object with a `city` property of type `string`.\n-->\n<p>이 코드에서 <code>&#x3C;h2></code>와 <code>&#x3C;span></code>은 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 임베디드 뷰 안에 있는 엘리먼트입니다.\n기본 모드에서는 이 엘리먼트를 검사하지 않습니다.\n그리고 전체검사 모드에서는 <code>config</code>와 <code>user</code> 객체가 있는지는 검사하지만 <code>any</code> 타입으로 처리합니다.\n엄격한 검사 모드에서는 <code>&#x3C;span></code>에 사용된 <code>user</code> 객체가 <code>User</code> 타입인지 검사하며, 이 객체 안에 <code>address</code>가 있고 또 <code>city</code> 프로퍼티가 있는지 검사합니다. <code>user.address.city</code>의 타입이 <code>string</code>인지도 검사합니다.</p>\n<a id=\"troubleshooting-template-errors\"></a>\n<!--\n## Troubleshooting template errors\n-->\n<h2 id=\"템플릿-에러-해결하기\">템플릿 에러 해결하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#템플릿-에러-해결하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nWhen enabling the new strict mode in version 9, you might encounter template errors that didn't arise in either of the previous modes.\nThese errors often represent genuine type mismatches in the templates that were not caught by the previous tooling.\nIf this is the case, the error message should make it clear where in the template the problem occurs.\n\nThere can also be false positives when the typings of an Angular library are either incomplete or incorrect, or when the typings don't quite line up with expectations as in the following cases.\n\n* When a library's typings are wrong or incomplete (for example, missing `null | undefined` if the library was not written with `strictNullChecks` in mind).\n* When a library's input types are too narrow and the library hasn't added appropriate metadata for Angular to figure this out. This usually occurs with disabled or other common Boolean inputs used as attributes, for example, `<input disabled>`.\n* When using `$event.target` for DOM events (because of the possibility of event bubbling, `$event.target` in the DOM typings doesn't have the type you might expect).\n\nIn case of a false positive like these, there are a few options:\n\n* Use the [`$any()` type-cast function](guide/template-expression-operators#any-type-cast-function) in certain contexts to opt out of type-checking for a part of the expression.\n* You can disable strict checks entirely by setting `strictTemplates: false` in the application's TypeScript configuration file, `tsconfig.json`.\n* You can disable certain type-checking operations individually, while maintaining strictness in other aspects, by setting a _strictness flag_ to `false`.\n* If you want to use `strictTemplates` and `strictNullChecks` together, you can opt out of strict null type checking specifically for input bindings via `strictNullInputTypes`.\n\n|Strictness flag|Effect|\n|-|-|\n|`strictInputTypes`|Whether the assignability of a binding expression to the `@Input()` field is checked. Also affects the inference of directive generic types. |\n|`strictInputAccessModifiers`|Whether access modifiers such as `private`/`protected`/`readonly` are honored when assigning a binding expression to an `@Input()`. If disabled, the access modifiers of the `@Input` are ignored; only the type is checked.|\n|`strictNullInputTypes`|Whether `strictNullChecks` is honored when checking `@Input()` bindings (per `strictInputTypes`). Turning this off can be useful when using a library that was not built with `strictNullChecks` in mind.|\n|`strictAttributeTypes`|Whether to check `@Input()` bindings that are made using text attributes (for example, `<mat-tab label=\"Step 1\">` vs `<mat-tab [label]=\"'Step 1'\">`).\n|`strictSafeNavigationTypes`|Whether the return type of safe navigation operations (for example, `user?.name`) will be correctly inferred based on the type of `user`). If disabled, `user?.name` will be of type `any`.\n|`strictDomLocalRefTypes`|Whether local references to DOM elements will have the correct type. If disabled `ref` will be of type `any` for `<input #ref>`.|\n|`strictOutputEventTypes`|Whether `$event` will have the correct type for event bindings to component/directive an `@Output()`, or to animation events. If disabled, it will be `any`.|\n|`strictDomEventTypes`|Whether `$event` will have the correct type for event bindings to DOM events. If disabled, it will be `any`.|\n|`strictContextGenerics`|Whether the type parameters of generic components will be inferred correctly (including any generic bounds). If disabled, any type parameters will be `any`.|\n|`strictLiteralTypes`|Whether object and array literals declared in the template will have their type inferred. If disabled, the type of such literals will be `any`.|\n\n\nIf you still have issues after troubleshooting with these flags, you can fall back to full mode by disabling `strictTemplates`.\n\nIf that doesn't work, an option of last resort is to turn off full mode entirely with `fullTemplateTypeCheck: false`, as we've made a special effort to make Angular version 9 backwards compatible in this case.\n\nA type-checking error that you cannot resolve with any of the recommended methods can be the result of a bug in the template type-checker itself.\nIf you get errors that require falling back to basic mode, it is likely to be such a bug.\nIf this happens, please [file an issue](https://github.com/angular/angular/issues) so the team can address it.\n-->\n<p>Angular 9버전부터 도입된 엄격한 타입 검사 모드를 활성화하면 이전까지 확인하지 못했던 템플릿 에러가 발생할 것입니다.\n새로 확인된 에러 중 대부분은 템플릿에서 타입을 잘못 사용했던 것이 엄격한 타입 검사 모드에서 검출된 것입니다.\n이런 경우는 문제가 발생한 부분을 에러 메시지에서 쉽게 확인할 수 있습니다.</p>\n<p>그리고 Angular 라이브러리의 타입 정의가 불완전하거나 잘못된 경우, 컴파일러의 판단과 달라지는 다음과 같은 경우에는 오탐지가 발생할 수도 있습니다.</p>\n<ul>\n<li>라이브러리의 타입 정의가 잘못되었거나 불완전한 경우. 라이브러리가 <code>strictNullChecks</code>를 고려하지 않아 <code>null | undefined</code>를 빠뜨린 경우일 수 있습니다.</li>\n<li>입력 프로퍼티의 타입이 너무 제한된 경우. <code>&#x3C;input disabled></code>와 같이 <code>disabled</code> 어트리뷰트나 불리언 값이 사용되는 어트리뷰트에서 발생할 수 있습니다.</li>\n<li>DOM 이벤트를 바인딩하면서 <code>$event.target</code>을 사용한 경우. 이벤트는 버블링(bubbling)될 수 있기 때문에 특정 DOM에서 감지한 <code>$event.target</code>의 타입은 보장할 수 없습니다.</li>\n</ul>\n<p>이런 경우는 다음과 같은 방법으로 해결할 수 있습니다:</p>\n<ul>\n<li>표현식의 일부분을 검사하지 않으려면 <a href=\"guide/template-expression-operators#any-type-cast-function\"><code>$any()</code> 타입 캐스팅 함수</a>를 사용하세요.</li>\n<li>애플리케이션 TypeScript 환경설정 파일에서 <code>strictTemplates</code> 값을 <code>false</code>로 설정해서 엄격한 타입 검사 모드를 비활성화 하세요.</li>\n<li>특정 규칙만 비활성화할 수 있습니다. 해당 <em>strictness flag</em>를 <code>false</code>로 설정하면 됩니다.</li>\n<li><code>strictTemplates</code> 옵션과 <code>strictNullChecks</code> 옵션을 그대로 사용하려면 <code>strictNullInputTypes</code> 옵션을 추가로 사용해서 입력 프로퍼티로 바인딩되는 객체의 타입 검사 옵션을 조정할 수 있습니다.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>플래그</th>\n<th>효과</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>strictInputTypes</code></td>\n<td><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 필드로 바인딩되는 표현식이 적절한지 검사합니다. 디렉티브의 제네릭 타입도 함께 검사합니다.</td>\n</tr>\n<tr>\n<td><code>strictNullInputTypes</code></td>\n<td><code>strictInputTypes</code>를 활성화했을 때 <code>strictNullChecks</code> 옵션도 적용할지 지정합니다. 사용하는 라이브러리가 <code>strictNullChecks</code>를 고려하지 않았다면 이 옵션값을 <code>false</code>로 지정하는 것이 좋습니다.</td>\n</tr>\n<tr>\n<td><code>strictAttributeTypes</code></td>\n<td>바인딩없이 문자열로 지정한 어트리뷰트도 검사할지 지정합니다. <code>true</code>로 설정하면 <code>&#x3C;mat-tab label=\"Step 1\"></code>도 검사하며 <code>false</code>로 설정하면 <code>&#x3C;mat-tab [label]=\"'Step 1'\"></code>만 검사합니다.</td>\n</tr>\n<tr>\n<td><code>strictSafeNavigationTypes</code></td>\n<td>안전참조 연산자 이후에 있는 프로퍼티의 타입을 검사할지 지정합니다. <code>false</code>로 설정하면 <code>user?.name</code>이라고 사용했을 때 <code>name</code>을 <code>any</code> 타입으로 처리합니다.</td>\n</tr>\n<tr>\n<td><code>strictDomLocalRefTypes</code></td>\n<td>DOM 엘리먼트를 참조하는 템플릿 로컬 변수의 타입을 검사할지 지정합니다. <code>false</code>로 설정하면 <code>&#x3C;input #ref></code>라고 사용했을 때 <code>ref</code>를 <code>any</code> 타입으로 처리합니다.</td>\n</tr>\n<tr>\n<td><code>strictOutputEventTypes</code></td>\n<td>컴포넌트/디렉티브가 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code>으로 보내는 <code>$event</code>의 타입과 애니메이션 이벤트의 타입을 검사할지 지정합니다. <code>false</code>로 설정하면 이벤트를 <code>any</code> 타입으로 처리합니다.</td>\n</tr>\n<tr>\n<td><code>strictDomEventTypes</code></td>\n<td>이벤트 바인딩으로 연결한 DOM 이벤트의 타입을 검사할지 지정합니다. <code>false</code>로 설정하면 이벤트 객체를 <code>any</code> 타입으로 처리합니다.</td>\n</tr>\n<tr>\n<td><code>strictContextGenerics</code></td>\n<td>제네릭 컴포넌트에 사용되는 인자 타입을 검사할지 지정합니다. <code>false</code>로 설정하면 <code>any</code>로 처리합니다.</td>\n</tr>\n<tr>\n<td><code>strictLiteralTypes</code></td>\n<td>Whether object and array literals declared in the template will have their type inferred. If disabled, the type of such literals will be <code>any</code>.</td>\n</tr>\n</tbody>\n</table>\n<p>플래그를 조정하더라도 문제가 계속 발생하면 언제라도 <code>strictTemplates</code>를 비활성화해서 전체검사 모드로 변경할 수 있습니다.</p>\n<p>하지만 전체검사 모드에서도 계속 에러가 발생하면 <code>fullTemplateTypeCheck</code> 값을 <code>false</code>로 설정해서 전체검사 모드도 비활성화할 수 있습니다.\n전체검사 모드를 비활성화하면 Angular 9 이전 버전처럼 잘 동작할 것입니다.</p>\n<p>기본 검사모드에서도 문제가 해결되지 않는다면 어쩌면 템플릿 타입 검사 기능의 버그일 수도 있습니다.\n이런 상황이 발생하면 꼭 저희에게 <a href=\"https://github.com/angular/angular/issues\">이슈</a>로 제보해 주세요.\n자세하게 검토해 보겠습니다.</p>\n<!--\n## Inputs and type-checking\n-->\n<h2 id=\"입력-프로퍼티-타입-검사\">입력 프로퍼티 타입 검사<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#입력-프로퍼티-타입-검사\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nIn Angular version 9, the template type checker checks whether a binding expression's type is compatible with that of the corresponding directive input.\nAs an example, consider the following component:\n\n```typescript\nexport interface User {\n  name: string;\n}\n\n@Component({\n  selector: 'user-detail',\n  template: '{{ user.name }}',\n})\nexport class UserDetailComponent {\n  @Input() user: User;\n}\n```\n\nThe `AppComponent` template uses this component as follows:\n\n```ts\n@Component({\n  selector: 'my-app',\n  template: '<user-detail [user]=\"selectedUser\" />',\n})\nexport class AppComponent {\n  selectedUser: User | null = null;\n}\n```\n\nHere, during type checking of the template for `AppComponent`, the `[user]=\"selectedUser\"` binding corresponds with the `UserDetailComponent.user` input.\nTherefore, Angular assigns the `selectedUser` property to `UserDetailComponent.user`, which would result in an error if their types were incompatible.\nTypeScript checks the assignment according to its type system, obeying flags such as `strictNullChecks` as they are configured in the application.\n\nYou can avoid run-time type errors by providing more specific in-template type requirements to the template type checker. Make the input type requirements for your own directives as specific as possible by providing template-guard functions in the directive definition. See [Improving template type checking for custom directives](guide/structural-directives#directive-type-checks), and [Input setter coercion](#input-setter-coercion) in this guide.\n-->\n<p>Angular 9버전부터는 템플릿 타입 검사 로직이 바인딩 표현식 결과값의 타입과 디렉티브 입력 프로퍼티의 타입이 적절한지 검사합니다.\n다음과 같은 컴포넌트가 있다고 합시다:</p>\n<code-example language=\"typescript\">\nexport interface User {\n  name: string;\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'user-detail',\n  template: '{{ user.name }}',\n})\nexport class UserDetailComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() user: User;\n}\n</code-example>\n<p>이 컴포넌트는 <code>AppComponent</code> 템플릿에 다음과 같이 사용됩니다:</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-app',\n  template: '&#x3C;user-detail [user]=\"selectedUser\" />',\n})\nexport class AppComponent {\n  selectedUser: User | null = null;\n}\n</code-example>\n<p>이제 <code>AppComponent</code>를 대상으로 타입 검사 로직이 동작하면 템플릿에 사용된 <code>[user]=\"selectedUser\"</code>와 <code>UserDetailComponent.user</code> 프로퍼티의 타입이 적절한지 검사합니다.\n그런데 이 예제 코드에서는 <code>AppComponent</code>의 <code>selectedUser</code> 프로퍼티가 <code>UserDetailComponent</code>의 <code>user</code> 타입과 맞지 않기 때문에 에러가 발생합니다.\n이 때 실행되는 타입 검사 로직은 <code>strictNullChecks</code>와 같은 플래그의 영향을 받습니다.</p>\n<p>You can avoid run-time type errors by providing more specific in-template type requirements to the template type checker. Make the input type requirements for your own directives as specific as possible by providing template-guard functions in the directive definition. See <a href=\"guide/structural-directives#directive-type-checks\">Improving template type checking for custom directives</a>, and <a href=\"guide/template-typecheck#input-setter-coercion\">Input setter coercion</a> in this guide.</p>\n<!--\n### Strict null checks\n-->\n<h3 id=\"엄격한-null-검사\">엄격한 null 검사<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#엄격한-null-검사\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nWhen you enable `strictTemplates` and the TypeScript flag `strictNullChecks`, typecheck errors may occur for certain situations that may not easily be avoided. For example:\n\n  * A nullable value that is bound to a directive from a library which did not have `strictNullChecks` enabled.\n\n  For a library compiled without `strictNullChecks`, its declaration files will not indicate whether a field can be `null` or not.\n  For situations where the library handles `null` correctly, this is problematic, as the compiler will check a nullable value against the declaration files which omit the `null` type.\n  As such, the compiler produces a type-check error because it adheres to `strictNullChecks`.\n\n  * Using the `async` pipe with an Observable which you know will emit synchronously.\n\n  The `async` pipe currently assumes that the Observable it subscribes to can be asynchronous, which means that it's possible that there is no value available yet.\n  In that case, it still has to return something&mdash;which is `null`.\n  In other words, the return type of the `async` pipe includes `null`, which may result in errors in situations where the Observable is known to emit a non-nullable value synchronously.\n\nThere are two potential workarounds to the above issues:\n\n  1. In the template, include the non-null assertion operator `!` at the end of a nullable expression, such as  `<user-detail [user]=\"user!\" />`.\n\n  In this example, the compiler disregards type incompatibilities in nullability, just as in TypeScript code.\n  In the case of the `async` pipe, note that the expression needs to be wrapped in parentheses, as in `<user-detail [user]=\"(user$ | async)!\" />`.\n\n  1. Disable strict null checks in Angular templates completely.\n\n  When `strictTemplates` is enabled, it is still possible to disable certain aspects of type checking.\n  Setting the option `strictNullInputTypes` to `false` disables strict null checks within Angular templates.\n  This flag applies for all components that are part of the application.\n-->\n<p><code>strictTemplates</code> 옵션과 TypeScript <code>strictNullChecks</code> 옵션을 활성화하면 처리하기 까다로운 타입 에러가 발생할 수 있습니다.</p>\n<ul>\n<li>\n<p><code>strictNullChecks</code>를 고려하지 않은 라이브러리에서 <code>null</code> 값이 전달될 수 있습니다.</p>\n<p>라이브러리를 개발할 때 <code>strictNullChecks</code> 옵션을 고려하지 않으면 타입 정의 파일에 <code>null</code>과 관련된 내용이 포함되지 않습니다.\n그래서 컴파일러가 <code>null</code> 값이 될 수 있는 코드를 발견하면 에러가 발생할 수 있습니다.</p>\n</li>\n<li>\n<p>동기 방식으로 값을 전달하는 옵저버블에 <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">async</a></code> 파이프를 사용한 경우</p>\n<p><code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">async</a></code> 파이프는 비동기 옵저버블에 사용하기 때문에 당장은 스트림으로 전달되는 데이터가 없다는 것을 간주합니다.\n그래서 이 시점에 <code>null</code>을 반환하는 경우가 있습니다.\n다르게 표현하면, <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">async</a></code> 파이프가 동기 방식으로 <code>null</code>을 반환할 수 있다는 것을 의미합니다.</p>\n</li>\n</ul>\n<p>위 두 상황은 다음 방법을 적용하면 해결될 수 있습니다:</p>\n<ol>\n<li>\n<p><code>null</code>이 될 수 있는 표현식에 null값 아님 보장 연산자 <code>!</code>를 사용하면 됩니다. ex) <code>&#x3C;user-detail [user]=\"user!\" /></code></p>\n<p>이렇게 작성하면 컴파일러가 <code>null</code>이 될 수 있는 상황을 고려하지 않습니다. TypeScript 코드에서 동작하는 것과 마찬가지입니다.\n그리고 <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">async</a></code> 파이프의 경우에는 전체 표현식을 소괄호로 감싸고 null값 아님 보장 연산자를 사용하면 됩니다. ex) <code>&#x3C;user-detail [user]=\"(user$ | async)!\" /></code></p>\n</li>\n<li>\n<p>Angular 템플릿을 검사할 때 엄격한 null 검사 모드를 해제하면 됩니다.</p>\n<p><code>strictTemplates</code> 옵션을 활성화하더라도 특정 문법에서는 타입 검사 기능을 끌 수 있습니다.\n예를 들어 <code>strictNullInputTypes</code> 옵션을 <code>false</code>로 설정하면 입력 프로퍼티로 전달되는 객체의 타입 검사를 생략합니다.\n이런 옵션은 애플리케이션 전체 컴포넌트에 적용되는 것에 주의하세요.</p>\n</li>\n</ol>\n<!--\n### Advice for library authors\n-->\n<h3 id=\"라이브러리-개발자분들께\">라이브러리 개발자분들께<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#라이브러리-개발자분들께\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAs a library author, you can take several measures to provide an optimal experience for your users.\nFirst, enabling `strictNullChecks` and including `null` in an input's type, as appropriate, communicates to your consumers whether they can provide a nullable value or not.\nAdditionally, it is possible to provide type hints that are specific to the template type checker. See [Improving template type checking for custom directives](guide/structural-directives#directive-type-checks), and [Input setter coercion](#input-setter-coercion) below.\n-->\n<p>라이브러리 개발자라면 라이브러리 사용자의 편의를 위해 검토할 수 있는 내용이 있습니다.\n먼저, <code>strictNullChecks</code> 옵션을 활성화하고 입력으로 받을 수 있는 타입에 <code>null</code>을 추가하세요.\n라이브러리 사용자가 <code>null</code> 값을 입력값으로 전달하더라도 문제가 생기지 않을 것입니다.\n템플릿 타입 검사 로직에 힌트를 제공할 수도 있습니다.\nSee <a href=\"guide/structural-directives#directive-type-checks\">Improving template type checking for custom directives</a>, and <a href=\"guide/template-typecheck#input-setter-coercion\">Input setter coercion</a> below.</p>\n<a id=\"input-setter-coercion\"></a>\n<!--\n## Input setter coercion\n-->\n<h2 id=\"입력값-보정하기\">입력값 보정하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#입력값-보정하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nOccasionally it is desirable for the `@Input()` of a directive or component to alter the value bound to it, typically using a getter/setter pair for the input.\nAs an example, consider this custom button component:\n\nConsider the following directive:\n-->\n<p>디렉티브나 컴포넌트에 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>으로 바인딩하는 값의 타입을 변환하기 위해 게터(getter)와 세터(setter)를 활용하는 방법도 고려해볼만 합니다.\n다음과 같은 커스텀 버튼 컴포넌트가 있다고 합시다:</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'submit-button',\n  template: `\n    &#x3C;div class=\"wrapper\">\n      &#x3C;button [disabled]=\"disabled\">Submit&#x3C;/button>'\n    &#x3C;/div>\n  `,\n})\nclass SubmitButton {\n  private _disabled: boolean;\n\n  get disabled(): boolean {\n    return this._disabled;\n  }\n\n  set disabled(value: boolean) {\n    this._disabled = value;\n  }\n}\n</code-example>\n<!--\nHere, the `disabled` input of the component is being passed on to the `<button>` in the template. All of this works as expected, as long as a `boolean` value is bound to the input. But, suppose a consumer uses this input in the template as an attribute:\n-->\n<p>이 컴포넌트의 입력 프로퍼티 <code>disabled</code>는 템플릿에 있는 <code>&#x3C;button></code>에 지정되는데, 이 로직이 제대로 동작하려면 입력으로 받는 값이 <code>boolean</code> 타입이어야 합니다.\n하지만 다음과 같이 사용했다고 합시다:</p>\n<code-example language=\"html\">\n&#x3C;submit-button disabled>&#x3C;/submit-button>\n</code-example>\n<!--\nThis has the same effect as the binding:\n-->\n<p>그러면 이 바인딩이 이렇게 연결됩니다:</p>\n<code-example language=\"html\">\n&#x3C;submit-button [disabled]=\"''\">&#x3C;/submit-button>\n</code-example>\n<!--\nAt runtime, the input will be set to the empty string, which is not a `boolean` value. Angular component libraries that deal with this problem often \"coerce\" the value into the right type in the setter:\n-->\n<p>그래서 이 프로퍼티 값은 <code>boolean</code> 타입이 아니라 빈 문자열로 지정됩니다.\n이런 오류를 방지하려면 세터를 사용해서 값을 보정해주면 됩니다:</p>\n<code-example language=\"typescript\">\nset disabled(value: boolean) {\n  this._disabled = (value === '') || value;\n}\n</code-example>\n<!--\nIt would be ideal to change the type of `value` here, from `boolean` to `boolean|''`, to match the set of values which are actually accepted by the setter.\nTypeScript requires that both the getter and setter have the same type, so if the getter should return a `boolean` then the setter is stuck with the narrower type.\n\nIf the consumer has Angular's strictest type checking for templates enabled, this creates a problem: the empty string `''` is not actually assignable to the `disabled` field, which will create a type error when the attribute form is used.\n\nAs a workaround for this problem, Angular supports checking a wider, more permissive type for `@Input()` than is declared for the input field itself. Enable this by adding a static property with the `ngAcceptInputType_` prefix to the component class:\n-->\n<p>이런식으로 구현한다면 세터로 전달되는 <code>value</code> 타입이 <code>boolean</code>가 아니라 <code>boolean|''</code>라고 지정하는 것이 더 정확합니다.\nTypeScript에서는 게터와 세터를 같은 타입으로 지정해야 하기 때문에 게터에서 <code>boolean</code> 타입만 반환한다면 게터는 세터에 지정된 타입보다 더 제한된 타입을 사용하는 것이 됩니다.</p>\n<p>이 컴포넌트를 사용하는 개발자가 템플릿에서 엄격한 타입 검사 모드를 활성화하면 <code>disabled</code> 필드에 빈 문자열 <code>''</code>을 할당했기 때문에 에러가 발생합니다.</p>\n<p>이 문제를 해결하려면 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>으로 전달되는 값의 타입을 실제로 사용할 수 있는 타입만큼 추가해야 합니다.\n컴포넌트 클래스에 <code>ngAcceptInputType_</code>이라는 접두사를 붙여 정적 프로퍼티를 추가해주면 됩니다:</p>\n<code-example language=\"typescript\">\nclass SubmitButton {\n  private _disabled: boolean;\n\n  get disabled(): boolean {\n    return this._disabled;\n  }\n\n  set disabled(value: boolean) {\n    this._disabled = (value === '') || value;\n  }\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> ngAcceptInputType_disabled: boolean|'';\n}\n</code-example>\n<!--\nThis field does not need to have a value. Its existence communicates to the Angular type checker that the `disabled` input should be considered as accepting bindings that match the type `boolean|''`. The suffix should be the `@Input` _field_ name.\n\nCare should be taken that if an `ngAcceptInputType_` override is present for a given input, then the setter should be able to handle any values of the overridden type.\n-->\n<p>새로 추가한 정적 필드는 실제 값을 가질 필요가 없습니다.\n이 필드는 실제로 사용되는 필드가 아니라 <code>disabled</code> 프로퍼티의 타입이 <code>boolean|''</code>라는 것을 Angular 타입 검사 로직에게 알리는 역할을 합니다.\n<code>ngAcceptInputType_</code> 뒤에 붙는 이름은 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 으로 지정된 필드 이름과 같아야 합니다.</p>\n<p>이렇게 작성하면 입력 프로퍼티에 지정된 타입을 <code>ngAcceptInputType_</code>이 오버라이드하기 때문에 세터로 받는 값도 오버라이드된 타입으로 사용할 수 있습니다.</p>\n<!--\n## Disabling type checking using `$any()`\n-->\n<h2 id=\"any로-타입-검사-우회하기\"><code>$any()</code>로 타입 검사 우회하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#any로-타입-검사-우회하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nDisable checking of a binding expression by surrounding the expression in a call to the [`$any()` cast pseudo-function](guide/template-expression-operators).\nThe compiler treats it as a cast to the `any` type just like in TypeScript when a `<any>` or `as any` cast is used.\n\nIn the following example, casting `person` to the `any` type suppresses the error `Property address does not exist`.\n-->\n<p><a href=\"guide/template-expression-operators\"><code>$any()</code> 타입 캐스팅 함수</a>를 사용하면 바인딩 표현식의 타입 검사를 우회할 수 있습니다.\n<code>$any()</code> 함수를 실행하고 나면 이 함수의 인자로 전달한 객체는 TypeScript 코드에서 <code>&#x3C;any></code>나 <code>as any</code>를 사용한 것과 같은 효과를 받습니다.</p>\n<p>그래서 아래 예제처럼 <code>person</code> 객체를 <code>any</code> 타입으로 캐스팅하면 <code>Property address does not exist</code>와 같은 타입 에러가 발생하지 않습니다.\n-->\n<a href=\"guide/template-expression-operators\"><code>$any()</code> 타입 캐스팅 함수</a>를 사용하면 바인딩 표현식의 타입 검사를 우회할 수 있습니다.\n<code>$any()</code> 함수를 실행하고 나면 이 함수의 인자로 전달한 객체는 TypeScript 코드에서 <code>&#x3C;any></code>나 <code>as any</code>를 사용한 것과 같은 효과를 받습니다.</p>\n<p>그래서 아래 예제처럼 <code>person</code> 객체를 <code>any</code> 타입으로 캐스팅하면 <code>Property address does not exist</code>와 같은 타입 에러가 발생하지 않습니다.</p>\n<code-example language=\"typescript\">\n  @<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n    selector: 'my-component',\n    template: '{{$any(person).addresss.street}}'\n  })\n  class MyComponent {\n    person?: Person;\n  }\n</code-example>\n\n</div>\n\n<!-- links to this doc:\n - guide/angular-compiler-options\n - guide/aot-compiler\n - guide/ivy-compatibility\n - guide/strict-mode\n - guide/structural-directives\n - guide/typescript-configuration\n - guide/updating-to-version-11\n-->\n<!-- links from this doc:\n - api/animations/state\n - api/common/AsyncPipe\n - api/common/NgForOf\n - api/common/NgIf\n - api/core/Component\n - api/core/Input\n - api/core/Output\n - api/upgrade/static\n - guide/structural-directives#directive-type-checks\n - guide/template-expression-operators\n - guide/template-expression-operators#any-type-cast-function\n - guide/template-typecheck#any로-타입-검사-우회하기\n - guide/template-typecheck#input-setter-coercion\n - guide/template-typecheck#ngfor로-비교해보기\n - guide/template-typecheck#개요\n - guide/template-typecheck#기본basic-모드\n - guide/template-typecheck#라이브러리-개발자분들께\n - guide/template-typecheck#엄격한-null-검사\n - guide/template-typecheck#엄격한strict-모드\n - guide/template-typecheck#입력-프로퍼티-타입-검사\n - guide/template-typecheck#입력값-보정하기\n - guide/template-typecheck#전체검사full-모드\n - guide/template-typecheck#템플릿-에러-해결하기\n - guide/template-typecheck#템플릿-타입-검사\n - guide/typescript-configuration\n - https://github.com/angular/angular/edit/master/aio/content/guide/template-typecheck.md?message=docs%3A%20describe%20your%20change...\n - https://github.com/angular/angular/issues\n-->"
}