{
  "id": "tutorial/toh-pt6",
  "title": "서버에서 데이터 받아오기",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/tutorial/toh-pt6.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Get data from a server\n-->\n<h1 id=\"서버에서-데이터-받아오기\">서버에서 데이터 받아오기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#서버에서-데이터-받아오기\"><i class=\"material-icons\">link</i></a></h1>\n<!--\nIn this tutorial, you'll add the following data persistence features with help from\nAngular's `HttpClient`.\n\n* The `HeroService` gets hero data with HTTP requests.\n* Users can add, edit, and delete heroes and save these changes over HTTP.\n* Users can search for heroes by name.\n\n<div class=\"alert is-helpful\">\n\n  For the sample app that this page describes, see the <live-example></live-example>.\n\n</div>\n-->\n<p>이번 튜토리얼에서는 Angular가 제공하는 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>를 사용해서 데이터를 처리하는 기능에 대해 알아봅니다.</p>\n<ul>\n<li><code>HeroService</code>가 히어로 데이터를 가져올 때 HTTP 요청을 통해 가져올 것입니다.</li>\n<li>사용자가 추가, 변경, 삭제한 히어로 데이터는 HTTP 요청을 보내서 서버에 저장할 것입니다.</li>\n<li>사용자가 히어로의 이름으로 검색할 수 있는 기능을 만들어 봅니다.</li>\n</ul>\n<div class=\"alert is-helpful\">\n<p>  이 문서에서 설명하는 앱은 <live-example></live-example>에서 직접 확인하거나 다운받아 확인할 수 있습니다.</p>\n</div>\n<!--\n## Enable HTTP services\n-->\n<h2 id=\"http-서비스-추가하기\">HTTP 서비스 추가하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#http-서비스-추가하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\n`HttpClient` is Angular's mechanism for communicating with a remote server over HTTP.\n\nMake `HttpClient` available everywhere in the app in two steps. First, add it to the root `AppModule` by importing it:\n\n<code-example path=\"toh-pt6/src/app/app.module.ts\" region=\"import-http-client\" header=\"src/app/app.module.ts (HttpClientModule import)\">\nimport { HttpClientModule } from &#39;@angular/common/http&#39;;\n\n</code-example>\n\nNext, still in the `AppModule`, add `HttpClient` to the `imports` array:\n\n<code-example path=\"toh-pt6/src/app/app.module.ts\" region=\"import-httpclientmodule\" header=\"src/app/app.module.ts (imports array excerpt)\">\n@NgModule({\n  imports: [\n    HttpClientModule,\n  ],\n})\n\n</code-example>\n-->\n<p><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>는 리모트 서버와 HTTP 통신을 하기 위해 Angular가 제공하는 서비스입니다.\n애플리케이션 전역 범위에서 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>를 사용하려면 다음과 같이 설정합니다:</p>\n<code-example path=\"toh-pt6/src/app/app.module.ts\" region=\"import-http-client\" header=\"src/app/app.module.ts (HttpClientModule 로드하기)\">\nimport { <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\n</code-example>\n<p>그리고 <code>AppModule</code>의 <code>imports</code> 배열에 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>을 추가합니다.</p>\n<code-example path=\"toh-pt6/src/app/app.module.ts\" region=\"import-httpclientmodule\" header=\"src/app/app.module.ts (imports 배열 일부)\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n  ],\n})\n\n</code-example>\n<!--\n## Simulate a data server\n-->\n<h2 id=\"데이터-서버-목킹하기\">데이터 서버 목킹하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#데이터-서버-목킹하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThis tutorial sample mimics communication with a remote data server by using the\n[In-memory Web API](https://github.com/angular/in-memory-web-api \"In-memory Web API\") module.\n\nAfter installing the module, the app will make requests to and receive responses from the `HttpClient`\nwithout knowing that the *In-memory Web API* is intercepting those requests,\napplying them to an in-memory data store, and returning simulated responses.\n\nBy using the In-memory Web API, you won't have to set up a server to learn about `HttpClient`.\n-->\n<p>이번 예제에서는 <a href=\"https://github.com/angular/in-memory-web-api\" title=\"In-memory Web API\">인-메모리(in-memory) Web API</a> 모듈로 리모트 데이터 서버와 통신하는 부분을 대신합니다.</p>\n<p>이 모듈을 설치하고나면 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>로 보내는 요청이나 받는 요청이 <em>인-메모리 Web API</em>로 처리되며, 데이터가 저장되고 반환하는 것도 이 모듈을 활용합니다.</p>\n<p>인-메모리 Web API를 사용하면 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>와 통신할 서버를 준비하지 않아도 됩니다.</p>\n<div class=\"alert is-important\">\n<!--\n**Important:** the In-memory Web API module has nothing to do with HTTP in Angular.\n\nIf you're just reading this tutorial to learn about `HttpClient`, you can [skip over](#import-heroes) this step.\nIf you're coding along with this tutorial, stay here and add the In-memory Web API now.\n-->\n<p><strong>중요:</strong> 인-메모리 Web API 모듈은 Angular가 제공하는 기능이 아닙니다.</p>\n<p><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>에 대해서만 학습하려면 <a href=\"tutorial/toh-pt6#import-heroes\">다음 단계</a>로 넘어가세요.\n이 튜토리얼의 진행을 그대로 따라가려면 지금 인-메모리 Web API를 설정하는 것이 좋습니다.</p>\n</div>\n<!--\nInstall the In-memory Web API package from npm with the following command:\n\n<code-example language=\"sh\" class=\"code-shell\">\n  npm install angular-in-memory-web-api --save\n</code-example>\n\nIn the `AppModule`, import the `HttpClientInMemoryWebApiModule` and the `InMemoryDataService` class,\nwhich you will create in a moment.\n\n<code-example path=\"toh-pt6/src/app/app.module.ts\" region=\"import-in-mem-stuff\" header=\"src/app/app.module.ts (In-memory Web API imports)\">\nimport { HttpClientInMemoryWebApiModule } from &#39;angular-in-memory-web-api&#39;;\nimport { InMemoryDataService } from &#39;./in-memory-data.service&#39;;\n\n</code-example>\n\nAfter the `HttpClientModule`, add the `HttpClientInMemoryWebApiModule`\nto the `AppModule` `imports` array and configure it with the `InMemoryDataService`.\n\n<code-example path=\"toh-pt6/src/app/app.module.ts\" header=\"src/app/app.module.ts (imports array excerpt)\" region=\"in-mem-web-api-imports\">\nHttpClientModule,\n\n// HttpClientInMemoryWebApiModule 모듈은 HTTP 요청을 가로채고 서버의 응답을 흉내냅니다.\n// 실제 서버가 준비되면 이 부분을 제거하면 됩니다.\nHttpClientInMemoryWebApiModule.forRoot(\n  InMemoryDataService, { dataEncapsulation: false }\n)\n\n</code-example>\n\nThe `forRoot()` configuration method takes an `InMemoryDataService` class\nthat primes the in-memory database.\n\nGenerate the class `src/app/in-memory-data.service.ts` with the following command:\n\n<code-example language=\"sh\" class=\"code-shell\">\n  ng generate service InMemoryData\n</code-example>\n\nReplace the default contents of `in-memory-data.service.ts` with the following:\n\n<code-example path=\"toh-pt6/src/app/in-memory-data.service.ts\" region=\"init\" header=\"src/app/in-memory-data.service.ts\">\nimport { Injectable } from &#39;@angular/core&#39;;\nimport { InMemoryDbService } from &#39;angular-in-memory-web-api&#39;;\nimport { Hero } from &#39;./hero&#39;;\n\n@Injectable({\n  providedIn: &#39;root&#39;,\n})\nexport class InMemoryDataService implements InMemoryDbService {\n  createDb() {\n    const heroes = [\n      { id: 11, name: &#39;Dr Nice&#39; },\n      { id: 12, name: &#39;Narco&#39; },\n      { id: 13, name: &#39;Bombasto&#39; },\n      { id: 14, name: &#39;Celeritas&#39; },\n      { id: 15, name: &#39;Magneta&#39; },\n      { id: 16, name: &#39;RubberMan&#39; },\n      { id: 17, name: &#39;Dynama&#39; },\n      { id: 18, name: &#39;Dr IQ&#39; },\n      { id: 19, name: &#39;Magma&#39; },\n      { id: 20, name: &#39;Tornado&#39; }\n    ];\n    return {heroes};\n  }\n\n  // 히어로 객체가 항상 id 프로퍼티를 갖도록 getId 메소드를 오버라이드 합니다.\n  // 히어로 목록이 비어있다면 이 메소드는 초기값(11)을 반환합니다.\n  // 히어로 목록이 비어있지 않으면 히어로 id의 최대값에 1을 더해서 반환합니다.\n  genId(heroes: Hero[]): number {\n    return heroes.length &gt; 0 ? Math.max(...heroes.map(hero =&gt; hero.id)) + 1 : 11;\n  }\n}\n\n\n</code-example>\n\nThe `in-memory-data.service.ts` file will take over the function of `mock-heroes.ts`.\nHowever, don't delete `mock-heroes.ts` yet, as you still need it for a few more steps of this tutorial.\n\nWhen the server is ready, you'll detach the In-memory Web API, and the app's requests will go through to the server.\n-->\n<p>다음 명령을 실행해서 npm 저장소에 있는 인-메모리 Web API 패키지를 설치합니다:</p>\n<code-example language=\"sh\" class=\"code-shell\">\n  npm install angular-in-memory-web-api --save\n</code-example>\n<p><code>AppModule</code>에서 <code>HttpClientInMemoryWebApiModule</code>과 <code>InMemoryDataService</code> 클래스를 로드합니다.</p>\n<code-example path=\"toh-pt6/src/app/app.module.ts\" region=\"import-in-mem-stuff\" header=\"src/app/app.module.ts (인-메모리 Web API 로드하기)\">\nimport { HttpClientInMemoryWebApiModule } from 'angular-in-memory-web-api';\nimport { InMemoryDataService } from './in-memory-data.service';\n\n</code-example>\n<p><code>AppModule</code>의 <code>imports</code> 배열 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code> 뒤에 <code>HttpClientInMemoryWebApiModule</code>을 추가하고 <code>InMemoryDataservice</code>를 사용할 수 있도록 다음과 같이 작성합니다.</p>\n<code-example path=\"toh-pt6/src/app/app.module.ts\" header=\"src/app/app.module.ts (imports 배열 일부)\" region=\"in-mem-web-api-imports\">\n<a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n\n// HttpClientInMemoryWebApiModule 모듈은 HTTP 요청을 가로채고 서버의 응답을 흉내냅니다.\n// 실제 서버가 준비되면 이 부분을 제거하면 됩니다.\nHttpClientInMemoryWebApiModule.forRoot(\n  InMemoryDataService, { dataEncapsulation: false }\n)\n\n</code-example>\n<p><code>forRoot()</code> 메소드는 <code>InMemoryDataService</code> 클래스를 인자로 받아서 인-메모리 데이터베이스의 실행환경을 구성하는 메소드입니다.</p>\n<p>다음 명령을 실행해서 <code>src/app/in-memory-data.service.ts</code> 클래스를 생성합니다:</p>\n<code-example language=\"sh\" class=\"code-shell\">\n  ng generate service InMemoryData\n</code-example>\n<p>그리고 이 파일의 내용을 다음과 같이 수정합니다:</p>\n<code-example path=\"toh-pt6/src/app/in-memory-data.service.ts\" region=\"init\" header=\"src/app/in-memory-data.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { InMemoryDbService } from 'angular-in-memory-web-api';\nimport { Hero } from './hero';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class InMemoryDataService implements InMemoryDbService {\n  createDb() {\n    const heroes = [\n      { id: 11, name: 'Dr Nice' },\n      { id: 12, name: 'Narco' },\n      { id: 13, name: 'Bombasto' },\n      { id: 14, name: 'Celeritas' },\n      { id: 15, name: 'Magneta' },\n      { id: 16, name: 'RubberMan' },\n      { id: 17, name: 'Dynama' },\n      { id: 18, name: 'Dr IQ' },\n      { id: 19, name: 'Magma' },\n      { id: 20, name: 'Tornado' }\n    ];\n    return {heroes};\n  }\n\n  // 히어로 객체가 항상 id 프로퍼티를 갖도록 getId 메소드를 오버라이드 합니다.\n  // 히어로 목록이 비어있다면 이 메소드는 초기값(11)을 반환합니다.\n  // 히어로 목록이 비어있지 않으면 히어로 id의 최대값에 1을 더해서 반환합니다.\n  genId(heroes: Hero[]): number {\n    return heroes.length > 0 ? Math.max(...heroes.map(hero => hero.id)) + 1 : 11;\n  }\n}\n\n\n</code-example>\n<p>The <code>in-memory-data.service.ts</code> file will take over the function of <code>mock-heroes.ts</code>.\nHowever, don't delete <code>mock-heroes.ts</code> yet, as you still need it for a few more steps of this tutorial.</p>\n<p>나중에 서버가 준비되면 인-메모리 Web API를 제거하기만 하면 클라이언트가 보내는 요청이 서버에서 이전과 같이 처리될 것입니다.</p>\n<a id=\"import-heroes\"></a>\n<!--\n## Heroes and HTTP\n-->\n<h2 id=\"히어로-데이터와-http\">히어로 데이터와 HTTP<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#히어로-데이터와-http\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nIn the `HeroService`, import `HttpClient` and `HttpHeaders`:\n\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"import-httpclient\" header=\"src/app/hero.service.ts (import HTTP symbols)\">\nimport { HttpClient, HttpHeaders } from &#39;@angular/common/http&#39;;\n\n</code-example>\n\nStill in the `HeroService`, inject `HttpClient` into the constructor in a private property called `http`.\n\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" header=\"src/app/hero.service.ts\" region=\"ctor\">\nconstructor(\n  private http: HttpClient,\n  private messageService: MessageService) { }\n\n</code-example>\n\nNotice that you keep injecting the `MessageService` but since you'll call it so frequently, wrap it in a private `log()` method:\n\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" header=\"src/app/hero.service.ts\" region=\"log\">\n/** HeroService에서 보내는 메시지는 MessageService가 화면에 표시합니다. */\nprivate log(message: string) {\n  this.messageService.add(`HeroService: ${message}`);\n}\n\n</code-example>\n\nDefine the `heroesUrl` of the form `:base/:collectionName` with the address of the heroes resource on the server.\n Here `base` is the resource to which requests are made,\n and `collectionName` is the heroes data object in the `in-memory-data-service.ts`.\n\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" header=\"src/app/hero.service.ts\" region=\"heroesUrl\">\nprivate heroesUrl = &#39;api/heroes&#39;;  // 웹 API 형식의 URL로 사용\n\n</code-example>\n-->\n<p><code>HeroService</code>에서 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 심볼과 <code><a href=\"api/common/http/HttpHeaders\" class=\"code-anchor\">HttpHeaders</a></code> 심볼을 로드합니다:</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"import-httpclient\" header=\"src/app/hero.service.ts (HTTP 심볼 로드하기)\">\nimport { <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>, <a href=\"api/common/http/HttpHeaders\" class=\"code-anchor\">HttpHeaders</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\n</code-example>\n<p>그리고 <code>HeroService</code>의 생성자에서 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>를 <code><a href=\"api/common/http\" class=\"code-anchor\">http</a></code> 프로퍼티로 주입합니다.</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" header=\"src/app/hero.service.ts\" region=\"ctor\">\nconstructor(\n  private <a href=\"api/common/http\" class=\"code-anchor\">http</a>: <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>,\n  private messageService: MessageService) { }\n\n</code-example>\n<p><code>MessageService</code>도 의존성으로 주입되지만, 이 서비스는 가끔 사용하기 때문에 private <code>log()</code> 메소드로 랩핑합니다.</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" header=\"src/app/hero.service.ts\" region=\"log\">\n/** HeroService에서 보내는 메시지는 MessageService가 화면에 표시합니다. */\nprivate log(message: string) {\n  this.messageService.add(`HeroService: ${message}`);\n}\n\n</code-example>\n<p><code>heroesUrl</code>을 <code>:base/:collectionName</code>과 같은 형태로 정의합니다. 이 주소는 서버의 리소스 위치에 따라 달라질 수 있습니다.\n이 주소에서 <code>base</code>는 어떤 종류의 요청인지 구별하는 변수이며, <code>collectionName</code>은 <code>in-memory-data-service.ts</code> 파일에 있는 콜렉션을 구별하는 변수입니다.</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" header=\"src/app/hero.service.ts\" region=\"heroesUrl\">\nprivate heroesUrl = 'api/heroes';  // 웹 API 형식의 URL로 사용\n\n</code-example>\n<!--\n### Get heroes with `HttpClient`\n-->\n<h3 id=\"httpclient-로-히어로-목록-가져오기\"><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 로 히어로 목록 가져오기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#httpclient-로-히어로-목록-가져오기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe current `HeroService.getHeroes()`\nuses the RxJS `of()` function to return an array of mock heroes\nas an `Observable<Hero[]>`.\n\n<code-example path=\"toh-pt4/src/app/hero.service.ts\" region=\"getHeroes-1\" header=\"src/app/hero.service.ts (getHeroes with RxJs 'of()')\">\ngetHeroes(): Observable&lt;Hero[]&gt; {\n  return of(HEROES);\n}\n\n</code-example>\n\nConvert that method to use `HttpClient` as follows:\n\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" header=\"src/app/hero.service.ts\" region=\"getHeroes-1\">\n/** GET: 서버에서 히어로 목록 가져오기 */\ngetHeroes(): Observable&lt;Hero[]&gt; {\n  return this.http.get&lt;Hero[]&gt;(this.heroesUrl)\n}\n\n</code-example>\n\nRefresh the browser. The hero data should successfully load from the\nmock server.\n\nYou've swapped `of()` for `http.get()` and the app keeps working without any other changes\nbecause both functions return an `Observable<Hero[]>`.\n-->\n<p>지금까지 <code>HeroService.getHeroes()</code> 메소드는 히어로 목록 목 데이터를 <code>Observable&#x3C;Hero[]></code> 타입으로 반환하기 위해 RxJs <code>of()</code> 함수를 사용했습니다.</p>\n<code-example path=\"toh-pt4/src/app/hero.service.ts\" region=\"getHeroes-1\" header=\"src/app/hero.service.ts (RxJs &#x27;of()&#x27;를 사용하는 getHeroes)\">\ngetHeroes(): Observable&#x3C;Hero[]> {\n  return of(HEROES);\n}\n\n</code-example>\n<p>이 메소드가 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>로 동작하도록 다음과 같이 수정합니다:</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" header=\"src/app/hero.service.ts\" region=\"getHeroes-1\">\n/** GET: 서버에서 히어로 목록 가져오기 */\ngetHeroes(): Observable&#x3C;Hero[]> {\n  return this.http.get&#x3C;Hero[]>(this.heroesUrl)\n}\n\n</code-example>\n<p>브라우저가 갱신되면 이제 히어로 데이터는 목 서버에서 받아옵니다.</p>\n<p><code>of</code> 함수를 <code>http.get</code>으로 변경했지만 이 서비스 외의 다른 부분은 변경하지 않아도 됩니다.\n두 함수는 모두 <code>Observable&#x3C;Hero[]></code> 타입을 반환합니다.</p>\n<!--\n### `HttpClient` methods return one value\n-->\n<h3 id=\"httpclient-메소드는-데이터를-하나만-반환합니다\"><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 메소드는 데이터를 하나만 반환합니다.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#httpclient-메소드는-데이터를-하나만-반환합니다\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAll `HttpClient` methods return an RxJS `Observable` of something.\n\nHTTP is a request/response protocol.\nYou make a request, it returns a single response.\n\nIn general, an observable _can_ return multiple values over time.\nAn observable from `HttpClient` always emits a single value and then completes, never to emit again.\n\nThis particular `HttpClient.get()` call returns an `Observable<Hero[]>`; that is, \"_an observable of hero arrays_\". In practice, it will only return a single hero array.\n-->\n<p><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>가 제공하는 메소드는 모두 RxJs <code>Observable</code> 타입을 한 번만 반환합니다.</p>\n<p>HTTP는 요청과 응답으로 구성되는 프로토콜입니다.\n그래서 요청이 한 번 있으면 응답도 한 번입니다.</p>\n<p>일반적으로 옵저버블은 여러 번에 걸쳐 여러 데이터를 반환할 수 있습니다.\n하지만 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>가 반환하는 옵저버블은 데이터를 한번만 반환하고 종료되며, 다시 사용되지 않습니다.</p>\n<p>예제에서 사용한 <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code>도 <code>Observable&#x3C;Hero[]></code> 데이터를 한번만 반환합니다.</p>\n<!--\n### `HttpClient.get()` returns response data\n-->\n<h3 id=\"httpclientget-함수는-응답으로-받은-데이터를-반환합니다\"><em>HttpClient.get</em> 함수는 응답으로 받은 데이터를 반환합니다.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#httpclientget-함수는-응답으로-받은-데이터를-반환합니다\"><i class=\"material-icons\">link</i></a></h3>\n<!--\n`HttpClient.get()` returns the body of the response as an untyped JSON object by default.\nApplying the optional type specifier, `<Hero[]>` , adds TypeScript capabilities, which reduce errors during compile time.\n\nThe server's data API determines the shape of the JSON data.\nThe _Tour of Heroes_ data API returns the hero data as an array.\n\n<div class=\"alert is-helpful\">\n\nOther APIs may bury the data that you want within an object.\nYou might have to dig that data out by processing the `Observable` result\nwith the RxJS `map()` operator.\n\nAlthough not discussed here, there's an example of `map()` in the `getHeroNo404()`\nmethod included in the sample source code.\n\n</div>\n-->\n<p><code>HttpClient.get</code> 함수는 HTTP 응답으로 받은 <em>몸체(body)</em> 를 반환하는데, 이 객체는 타입이 지정되지 않은 JSON 객체로 처리됩니다.\n그래서 이 객체에 타입을 지정하려면 <code>&#x3C;Hero[]></code>와 같이 제네릭을 지정하면 됩니다.</p>\n<p>JSON 데이터의 형식은 서버에 정의된 데이터 API에 따라 달라집니다.\n<em>히어로들의 여행</em> 에서 사용하는 데이터 API는 모두 히어로 데이터를 배열로 반환합니다.</p>\n<div class=\"alert is-helpful\">\n<p>데이터는 HTTP 응답으로 받은 객체 안에 깊숙히 들어있을 수도 있습니다.\n이런 경우에는 원하는 데이터를 추출하기 위해 RxJS <code>map</code> 연산자를 사용해야 합니다.</p>\n<p>이 내용은 이 문서에서 다루지 않지만 예제 코드에 구현된 <code>getHeroNo404()</code> 메소드를 보면 <code>map</code> 연산자를 사용하는 코드를 확인할 수 있습니다.</p>\n</div>\n<!--\n### Error handling\n-->\n<h3 id=\"에러-처리하기\">에러 처리하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#에러-처리하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThings go wrong, especially when you're getting data from a remote server.\nThe `HeroService.getHeroes()` method should catch errors and do something appropriate.\n\nTo catch errors, you **\"pipe\" the observable** result from `http.get()` through an RxJS `catchError()` operator.\n\nImport the `catchError` symbol from `rxjs/operators`, along with some other operators you'll need later.\n\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" header=\"src/app/hero.service.ts\" region=\"import-rxjs-operators\">\nimport { catchError, map, tap } from &#39;rxjs/operators&#39;;\n\n</code-example>\n\nNow extend the observable result with the `pipe()` method and\ngive it a `catchError()` operator.\n\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"getHeroes-2\" header=\"src/app/hero.service.ts\">\ngetHeroes(): Observable&lt;Hero[]&gt; {\n  return this.http.get&lt;Hero[]&gt;(this.heroesUrl)\n    .pipe(\n      catchError(this.handleError&lt;Hero[]&gt;(&#39;getHeroes&#39;, []))\n    );\n}\n\n</code-example>\n\nThe `catchError()` operator intercepts an **`Observable` that failed**.\nIt passes the error an error handler that can do what it wants with the error.\n\nThe following `handleError()` method reports the error and then returns an\ninnocuous result so that the application keeps working.\n-->\n<p>리모트 서버에서 데이터를 가져오는 과정은 얼마든지 잘못될 수 있습니다.\n그래서 <code>HeroService.getHeroes()</code> 메소드에는 에러가 발생했을 때 처리하는 로직이 필요합니다.</p>\n<p>에러를 처리하려면 <code>http.get()</code>으로 받은 옵저버블에 <strong>\"pipe\"를 사용해서</strong> <code>catchError()</code> 연산자를 연결하면 됩니다.</p>\n<p><code>rxjs/operators</code>에서 <code>catchError</code> 심볼을 로드합니다.\n이 때 앞으로 사용할 연산자 몇 개도 함께 로드했습니다.</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" header=\"src/app/hero.service.ts\" region=\"import-rxjs-operators\">\nimport { catchError, map, tap } from 'rxjs/operators';\n\n</code-example>\n<p>이제 옵저버블로 받은 데이터를 <code>pipe()</code> 메소드로 확장하고 이 파이프에 <code>catchError()</code> 연산자를 연결합니다.</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"getHeroes-2\" header=\"src/app/hero.service.ts\">\ngetHeroes(): Observable&#x3C;Hero[]> {\n  return this.http.get&#x3C;Hero[]>(this.heroesUrl)\n    .pipe(\n      catchError(this.handleError&#x3C;Hero[]>('getHeroes', []))\n    );\n}\n\n</code-example>\n<p><code>catchError()</code> 연산자는 <strong><code>Observable</code>이 실패했을 때</strong> 실행되는 연산자입니다.\n이 연산자에는 에러가 발생했을 때 실행할 <em>에러 핸들러 함수</em> 를 인자로 전달합니다.</p>\n<p>다음 섹션에서 구현할 <code>handleError()</code> 메소드는 에러를 콘솔에 출력한 뒤에 빈 배열을 반환합니다.\n그래서 서버에 보낸 요청이 실패하는 에러가 발생하더라도 애플리케이션은 계속 동작할 수 있습니다.</p>\n<h4 id=\"handleerror\"><code>handleError</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#handleerror\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe following `handleError()` will be shared by many `HeroService` methods\nso it's generalized to meet their different needs.\n\nInstead of handling the error directly, it returns an error handler function to `catchError` that it\nhas configured with both the name of the operation that failed and a safe return value.\n\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" header=\"src/app/hero.service.ts\" region=\"handleError\">\n/**\n * HTTP 요청이 실패한 경우를 처리합니다.\n * 애플리케이션 로직 흐름은 그대로 유지됩니다.\n * @param operation - 실패한 동작의 이름\n * @param result - 기본값으로 반환할 객체\n */\nprivate handleError&lt;T&gt;(operation = &#39;operation&#39;, result?: T) {\n  return (error: any): Observable&lt;T&gt; =&gt; {\n\n    // TODO: 리모트 서버로 에러 메시지 보내기\n    console.error(error); // 지금은 콘솔에 로그를 출력합니다.\n\n    // TODO: 사용자가 이해할 수 있는 형태로 변환하기\n    this.log(`${operation} failed: ${error.message}`);\n\n    // 애플리케이션 로직이 끊기지 않도록 기본값으로 받은 객체를 반환합니다.\n    return of(result as T);\n  };\n}\n\n</code-example>\n\nAfter reporting the error to the console, the handler constructs\na user friendly message and returns a safe value to the app so the app can keep working.\n\nBecause each service method returns a different kind of `Observable` result,\n`handleError()` takes a type parameter so it can return the safe value as the type that the app expects.\n-->\n<p><code>HeroService</code>의 메소드들은 에러 처리로직이 비슷하기 때문에 <code>handleError()</code> 메소드에 이 로직을 정의합니다.</p>\n<p>이렇게 구현하면 각 메소드에서 에러를 직접 처리하는 대신 <code>catchError</code>에 이 핸들러 함수의 반환값을 처리하기 때문에, 옵저버블이 처리되는 도중 데이터가 잘못되어 발생하는 오류를 방지할 수 있습니다.</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" header=\"src/app/hero.service.ts\" region=\"handleError\">\n/**\n * HTTP 요청이 실패한 경우를 처리합니다.\n * 애플리케이션 로직 흐름은 그대로 유지됩니다.\n * @param operation - 실패한 동작의 이름\n * @param result - 기본값으로 반환할 객체\n */\nprivate handleError&#x3C;T>(operation = 'operation', result?: T) {\n  return (error: any): Observable&#x3C;T> => {\n\n    // TODO: 리모트 서버로 에러 메시지 보내기\n    console.error(error); // 지금은 콘솔에 로그를 출력합니다.\n\n    // TODO: 사용자가 이해할 수 있는 형태로 변환하기\n    this.log(`${operation} failed: ${error.message}`);\n\n    // 애플리케이션 로직이 끊기지 않도록 기본값으로 받은 객체를 반환합니다.\n    return of(result as T);\n  };\n}\n\n</code-example>\n<p>에러를 콘솔에 출력하고나면 핸들러 함수는 사용자가 이해하기 쉬운 형식의 메시지를 반환하면서 앱이 중단되지 않도록 기본값을 반환합니다.</p>\n<p>이 때 서비스의 각 메소드는 서로 다른 타입으로 <code>Observable</code> 결과를 반환하기 때문에 <code>handleError()</code> 메소드는 각 메소드의 기본값을 인자로 받을수 있도록 정의했습니다.</p>\n<!--\n### Tap into the Observable\n-->\n<h3 id=\"observable-확인하기\"><code>Observable</code> 확인하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#observable-확인하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe `HeroService` methods will **tap** into the flow of observable values\nand send a message, via the `log()` method, to the message area at the bottom of the page.\n\nThey'll do that with the RxJS `tap()` operator,\nwhich looks at the observable values, does something with those values,\nand passes them along.\nThe `tap()` call back doesn't touch the values themselves.\n\nHere is the final version of `getHeroes()` with the `tap()` that logs the operation.\n\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" header=\"src/app/hero.service.ts\" region=\"getHeroes\">\n/** GET: 서버에서 히어로 목록 가져오기 */\ngetHeroes(): Observable&lt;Hero[]&gt; {\n  return this.http.get&lt;Hero[]&gt;(this.heroesUrl)\n    .pipe(\n      tap(_ =&gt; this.log(&#39;fetched heroes&#39;)),\n      catchError(this.handleError&lt;Hero[]&gt;(&#39;getHeroes&#39;, []))\n    );\n}\n\n</code-example>\n-->\n<p><code>HeroService</code>에 정의하는 메소드는 옵저버블 데이터를 살짝 참조해서(<code>tap</code>) <code>log()</code> 함수로 메시지를 화면에 출력합니다.</p>\n<p>옵저버블 데이터를 <em>확인하려면</em> RxJS가 제공하는 <code>tap</code> 연산자를 사용하면 됩니다.\n이 연산자는 옵저버블 데이터를 사용해서 <em>어떤 동작을 수행</em> 하는데, 옵저버블 데이터는 변경하지 않고 그대로 전달합니다.</p>\n<p><code>getHeroes()</code> 메소드에 <code>tap</code>을 활용하는 로직을 넣으면  다음과 같이 구현할 수 있습니다.</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" header=\"src/app/hero.service.ts\" region=\"getHeroes\">\n/** GET: 서버에서 히어로 목록 가져오기 */\ngetHeroes(): Observable&#x3C;Hero[]> {\n  return this.http.get&#x3C;Hero[]>(this.heroesUrl)\n    .pipe(\n      tap(_ => this.log('fetched heroes')),\n      catchError(this.handleError&#x3C;Hero[]>('getHeroes', []))\n    );\n}\n\n</code-example>\n<!--\n### Get hero by id\n-->\n<h3 id=\"id로-히어로-데이터-가져오기\">id로 히어로 데이터 가져오기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#id로-히어로-데이터-가져오기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nMost web APIs support a _get by id_ request in the form `:baseURL/:id`.\n\nHere, the _base URL_ is the `heroesURL` defined in the [Heroes and HTTP](tutorial/toh-pt6#heroes-and-http) section (`api/heroes`) and _id_ is\nthe number of the hero that you want to retrieve. For example, `api/heroes/11`.\n\nUpdate the `HeroService` `getHero()` method with the following to make that request:\n\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"getHero\" header=\"src/app/hero.service.ts\">\n/** GET: id에 해당하는 히어로 데이터 가져오기. 존재하지 않으면 404를 반환합니다. */\ngetHero(id: number): Observable&lt;Hero&gt; {\n  const url = `${this.heroesUrl}/${id}`;\n  return this.http.get&lt;Hero&gt;(url).pipe(\n    tap(_ =&gt; this.log(`fetched hero id=${id}`)),\n    catchError(this.handleError&lt;Hero&gt;(`getHero id=${id}`))\n  );\n}\n\n</code-example>\n\nThere are three significant differences from  `getHeroes()`:\n\n* `getHero()` constructs a request URL with the desired hero's id.\n* The server should respond with a single hero rather than an array of heroes.\n* `getHero()` returns an `Observable<Hero>` (\"_an observable of Hero objects_\")\n rather than an observable of hero _arrays_ .\n-->\n<p>일반적으로 웹 API는 <em>id로 데이터를 검색하는 기능을</em> <code>:baseURL/:id</code>와 같은 방식으로 제공합니다.</p>\n<p>이번에는 <a href=\"http://localhost:4800/tutorial/toh-pt6#heroes-and-http\">히어로 데이터와 HTTP</a> 섹션에서 정의한 <code>heroesURL</code>에 <em>기본 URL</em> 과 히어로 id에 해당하는 숫자를 사용해서 <code>api/heroes/11</code>라는 주소로 히어로 데이터를 요청해 봅시다.</p>\n<p><code>HeroService</code>의 <code>getHero()</code> 메소드를 다음과 같이 수정합니다:</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"getHero\" header=\"src/app/hero.service.ts\">\n/** GET: id에 해당하는 히어로 데이터 가져오기. 존재하지 않으면 404를 반환합니다. */\ngetHero(id: number): Observable&#x3C;Hero> {\n  const url = `${this.heroesUrl}/${id}`;\n  return this.http.get&#x3C;Hero>(url).pipe(\n    tap(_ => this.log(`fetched hero id=${id}`)),\n    catchError(this.handleError&#x3C;Hero>(`getHero id=${id}`))\n  );\n}\n\n</code-example>\n<p>이 메소드는 <code>getHeroes</code>와 다른 점이 3가지 있습니다.</p>\n<ul>\n<li>인자로 받은 히어로 id로 URL을 구성합니다.</li>\n<li>서버가 반환하는 응답은 배열 형태의 히어로 목록이 아니라 히어로 한 명의 데이터입니다.</li>\n<li>그래서 <code>getHero</code>가 반환하는 결과물은 <code>Observable&#x3C;Hero></code> 타입으로 \"<em>히어로 객체를 표현하는 옵저버블</em>\" 입니다. 배열이 아닙니다.</li>\n</ul>\n<!--\n## Update heroes\n-->\n<h2 id=\"히어로-데이터-수정하기\">히어로 데이터 수정하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#히어로-데이터-수정하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nEdit a hero's name in the hero detail view.\nAs you type, the hero name updates the heading at the top of the page.\nBut when you click the \"go back button\", the changes are lost.\n\nIf you want changes to persist, you must write them back to\nthe server.\n\nAt the end of the hero detail template, add a save button with a `click` event\nbinding that invokes a new component method named `save()`.\n\n<code-example path=\"toh-pt6/src/app/hero-detail/hero-detail.component.html\" region=\"save\" header=\"src/app/hero-detail/hero-detail.component.html (save)\">\n&lt;button (click)=&quot;save()&quot;&gt;save&lt;/button&gt;\n\n</code-example>\n\nIn the `HeroDetail` component class, add the following `save()` method, which persists hero name changes using the hero service\n`updateHero()` method and then navigates back to the previous view.\n\n<code-example path=\"toh-pt6/src/app/hero-detail/hero-detail.component.ts\" region=\"save\" header=\"src/app/hero-detail/hero-detail.component.ts (save)\">\nsave(): void {\n  this.heroService.updateHero(this.hero)\n    .subscribe(() =&gt; this.goBack());\n}\n\n</code-example>\n-->\n<p>히어로 상세정보 화면에서는 히어로의 이름을 수정할 수 있습니다.\n그런데 사용자가 히어로의 이름을 입력하면 이 내용이 페이지 위쪽에 표시되지만 \"뒤로 가기 버튼\"을 누르면 변경된 내용이 폐기됩니다.</p>\n<p>히어로의 이름을 영구적으로 저장하려면 사용자가 입력한 내용을 서버로 보내서 저장해야 합니다.</p>\n<p>히어로 상세정보 화면을 정의하는 템플릿 제일 아래에 저장 버튼을 추가하고 이 버튼에 <code>click</code> 이벤트를 바인딩해 봅시다.\n이 이벤트는 컴포넌트 클래스의 <code>save()</code> 메소드로 연결할 것입니다.</p>\n<code-example path=\"toh-pt6/src/app/hero-detail/hero-detail.component.html\" region=\"save\" header=\"src/app/hero-detail/hero-detail.component.html (저장하기)\">\n&#x3C;button (click)=\"save()\">save&#x3C;/button>\n\n</code-example>\n<p>그리고 아래 내용으로 <code>HeroDetail</code> 컴포넌트에 <code>save()</code> 메소드를 구현합니다.\n이 메소드는 <code>HeroService.updateHero()</code> 메소드를 실행해서 변경된 내용을 저장하고 이전 화면으로 돌아가는 동작을 합니다.</p>\n<code-example path=\"toh-pt6/src/app/hero-detail/hero-detail.component.ts\" region=\"save\" header=\"src/app/hero-detail/hero-detail.component.ts (저장하기)\">\nsave(): void {\n  this.heroService.updateHero(this.hero)\n    .subscribe(() => this.goBack());\n}\n\n</code-example>\n<!--\n#### Add `HeroService.updateHero()`\n-->\n<h4 id=\"heroserviceupdatehero-추가하기\"><code>HeroService.updateHero()</code> 추가하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#heroserviceupdatehero-추가하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe overall structure of the `updateHero()` method is similar to that of\n`getHeroes()`, but it uses `http.put()` to persist the changed hero\non the server. Add the following to the `HeroService`.\n\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"updateHero\" header=\"src/app/hero.service.ts (update)\">\n/** PUT: 서버에 저장된 히어로 데이터를 변경합니다. */\nupdateHero(hero: Hero): Observable&lt;any&gt; {\n  return this.http.put(this.heroesUrl, hero, this.httpOptions).pipe(\n    tap(_ =&gt; this.log(`updated hero id=${hero.id}`)),\n    catchError(this.handleError&lt;any&gt;(&#39;updateHero&#39;))\n  );\n}\n\n</code-example>\n\nThe `HttpClient.put()` method takes three parameters:\n* the URL\n* the data to update (the modified hero in this case)\n* options\n\nThe URL is unchanged. The heroes web API knows which hero to update by looking at the hero's `id`.\n\nThe heroes web API expects a special header in HTTP save requests.\nThat header is in the `httpOptions` constant defined in the `HeroService`. Add the following to the `HeroService` class.\n\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"http-options\" header=\"src/app/hero.service.ts\">\nhttpOptions = {\n  headers: new HttpHeaders({ &#39;Content-Type&#39;: &#39;application/json&#39; })\n};\n\n</code-example>\n\nRefresh the browser, change a hero name and save your change. The `save()`\nmethod in `HeroDetailComponent` navigates to the previous view.\nThe hero now appears in the list with the changed name.\n-->\n<p><code>updateHero()</code> 메소드는 <code>getHeroes()</code> 메소드와 거의 비슷합니다. 대신 <code>updateHero()</code> 메소드는 <code>http.get()</code>이 아니라 <code>http.put()</code> 함수를 사용합니다.</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"updateHero\" header=\"src/app/hero.service.ts (수정하기)\">\n/** PUT: 서버에 저장된 히어로 데이터를 변경합니다. */\nupdateHero(hero: Hero): Observable&#x3C;any> {\n  return this.http.put(this.heroesUrl, hero, this.httpOptions).pipe(\n    tap(_ => this.log(`updated hero id=${hero.id}`)),\n    catchError(this.handleError&#x3C;any>('updateHero'))\n  );\n}\n\n</code-example>\n<p><code><a href=\"api/common/http/HttpClient#put\" class=\"code-anchor\">HttpClient.put()</a></code> 메소드는 3개의 인자를 받습니다:</p>\n<ul>\n<li>URL</li>\n<li>수정할 데이터 (수정된 히어로 데이터)</li>\n<li>옵션</li>\n</ul>\n<p>URL은 변경되지 않았습니다. 이 예제에 정의한 웹 API는 히어로의 <code>id</code>를 기준으로 수정할 히어로를 찾습니다.</p>\n<p>이번 예제에서 사용하는 웹 API에는 헤더가 존재합니다.\n이 헤더는 <code>HeroService</code> 안에 <code>httpOptions</code> 프로퍼티에 저장하고 상수처럼 사용할 것입니다.\n<code>HeroService</code> 클래스에 다음 코드를 추가합니다.</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"http-options\" header=\"src/app/hero.service.ts\">\nhttpOptions = {\n  headers: new <a href=\"api/common/http/HttpHeaders\" class=\"code-anchor\">HttpHeaders</a>({ 'Content-Type': 'application/json' })\n};\n\n</code-example>\n<p>이제 브라우저가 갱신된 후에 히어로의 이름을 변경하고 저장해보세요.\n그러면 <code>HeroDetailComponent</code>에 정의한 대로 이전 페이지로 돌아가는데, 전환된 화면에는 변경된 내용이 반영되어 표시될 것입니다.</p>\n<!--\n## Add a new hero\n-->\n<h2 id=\"새-히어로-추가하기\">새 히어로 추가하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#새-히어로-추가하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nTo add a hero, this app only needs the hero's name. You can use an `<input>`\nelement paired with an add button.\n\nInsert the following into the `HeroesComponent` template, just after\nthe heading:\n\n<code-example path=\"toh-pt6/src/app/heroes/heroes.component.html\" region=\"add\" header=\"src/app/heroes/heroes.component.html (add)\">\n&lt;div&gt;\n  &lt;label&gt;Hero name:\n    &lt;input #heroName /&gt;\n  &lt;/label&gt;\n  &lt;!-- (click) 이벤트를 감지하면 현재값을 인자로 전달하면서 add() 함수를 실행하고, 입력 필드를 비웁니다. --&gt;\n  &lt;button (click)=&quot;add(heroName.value); heroName.value=&#39;&#39;&quot;&gt;\n    add\n  &lt;/button&gt;\n&lt;/div&gt;\n\n</code-example>\n\nIn response to a click event, call the component's click handler, `add()`, and then\nclear the input field so that it's ready for another name. Add the following to the\n`HeroesComponent` class:\n\n<code-example path=\"toh-pt6/src/app/heroes/heroes.component.ts\" region=\"add\" header=\"src/app/heroes/heroes.component.ts (add)\">\nadd(name: string): void {\n  name = name.trim();\n  if (!name) { return; }\n  this.heroService.addHero({ name } as Hero)\n    .subscribe(hero =&gt; {\n      this.heroes.push(hero);\n    });\n}\n\n</code-example>\n\nWhen the given name is non-blank, the handler creates a `Hero`-like object\nfrom the name (it's only missing the `id`) and passes it to the services `addHero()` method.\n\nWhen `addHero()` saves successfully, the `subscribe()` callback\nreceives the new hero and pushes it into to the `heroes` list for display.\n\nAdd the following `addHero()` method to the `HeroService` class.\n\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"addHero\" header=\"src/app/hero.service.ts (addHero)\">\n/** POST: 서버에 새로운 히어로를 추가합니다. */\naddHero(hero: Hero): Observable&lt;Hero&gt; {\n  return this.http.post&lt;Hero&gt;(this.heroesUrl, hero, this.httpOptions).pipe(\n    tap((newHero: Hero) =&gt; this.log(`added hero w/ id=${newHero.id}`)),\n    catchError(this.handleError&lt;Hero&gt;(&#39;addHero&#39;))\n  );\n}\n\n</code-example>\n\n`addHero()` differs from `updateHero()` in two ways:\n\n* It calls `HttpClient.post()` instead of `put()`.\n* It expects the server to generate an id for the new hero,\nwhich it returns in the `Observable<Hero>` to the caller.\n\nRefresh the browser and add some heroes.\n-->\n<p>이 문서에서 만들고 있는 앱은 히어로를 추가할 때 이름만 있으면 됩니다.\n화면에 <code>&#x3C;input></code> 엘리먼트 하나와 버튼 하나만 추가해 봅시다.</p>\n<p><code>HeroesComponent</code> 템플릿의 헤더 아래에 아래 내용을 추가합니다:</p>\n<code-example path=\"toh-pt6/src/app/heroes/heroes.component.html\" region=\"add\" header=\"src/app/heroes/heroes.component.html (추가하기)\">\n&#x3C;div>\n  &#x3C;label>Hero name:\n    &#x3C;input #heroName />\n  &#x3C;/label>\n  &#x3C;!-- (click) 이벤트를 감지하면 현재값을 인자로 전달하면서 add() 함수를 실행하고, 입력 필드를 비웁니다. -->\n  &#x3C;button (click)=\"add(heroName.value); heroName.value=''\">\n    add\n  &#x3C;/button>\n&#x3C;/div>\n\n</code-example>\n<p>클릭 이벤트가 발생하면 컴포넌트의 클릭 핸들러인 <code>add()</code> 메소드를 실행하고 입력 필드를 비우면서 다른 이름을 받을 준비를 합니다.\n이 로직을 <code>HeroesComponent</code> 클래스에 정의합니다:</p>\n<code-example path=\"toh-pt6/src/app/heroes/heroes.component.ts\" region=\"add\" header=\"src/app/heroes/heroes.component.ts (추가하기)\">\nadd(name: string): void {\n  name = name.trim();\n  if (!name) { return; }\n  this.heroService.addHero({ name } as Hero)\n    .subscribe(hero => {\n      this.heroes.push(hero);\n    });\n}\n\n</code-example>\n<p>사용자가 입력한 이름이 유효하다면 핸들러 함수는 이름을 사용해서 <code>Hero</code>와 호환되는 객체를 생성하고(<code>id</code>는 생략되었습니다) 이 객체를 <code>addHero()</code> 메소드로 전달합니다.</p>\n<p>그리고 <code>addHero()</code>가 문제없이 실행되면 <code>subscribe()</code> 콜백함수가 새 히어로 객체를 받고 이 객체를 <code>heroes</code> 목록에 추가하기 때문에 화면에도 표시됩니다.</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"addHero\" header=\"src/app/hero.service.ts (addHero)\">\n/** POST: 서버에 새로운 히어로를 추가합니다. */\naddHero(hero: Hero): Observable&#x3C;Hero> {\n  return this.http.post&#x3C;Hero>(this.heroesUrl, hero, this.httpOptions).pipe(\n    tap((newHero: Hero) => this.log(`added hero w/ id=${newHero.id}`)),\n    catchError(this.handleError&#x3C;Hero>('addHero'))\n  );\n}\n\n</code-example>\n<p><code>addHero()</code>는 <code>updateHero()</code>와 두 가지가 다릅니다:</p>\n<ul>\n<li><code><a href=\"api/common/http/HttpClient#put\" class=\"code-anchor\">HttpClient.put()</a></code> 대신 <code>post()</code>를 실행합니다.</li>\n<li>이 함수를 실행하면 새로운 히어로에 대한 id가 생성되어야 하며, <code>Observable&#x3C;Hero></code> 타입으로 반환됩니다.</li>\n</ul>\n<p>브라우저를 새로고침하고 히어로를 추가해 보세요.</p>\n<!--\n## Delete a hero\n-->\n<h2 id=\"히어로-삭제하기\">히어로 삭제하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#히어로-삭제하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nEach hero in the heroes list should have a delete button.\n\nAdd the following button element to the `HeroesComponent` template, after the hero\nname in the repeated `<li>` element.\n\n<code-example path=\"toh-pt6/src/app/heroes/heroes.component.html\" header=\"src/app/heroes/heroes.component.html\" region=\"delete\">\n&lt;button class=&quot;delete&quot; title=&quot;delete hero&quot;\n  (click)=&quot;delete(hero)&quot;&gt;x&lt;/button&gt;\n\n</code-example>\n\nThe HTML for the list of heroes should look like this:\n\n<code-example path=\"toh-pt6/src/app/heroes/heroes.component.html\" region=\"list\" header=\"src/app/heroes/heroes.component.html (list of heroes)\">\n&lt;ul class=&quot;heroes&quot;&gt;\n  &lt;li *ngFor=&quot;let hero of heroes&quot;&gt;\n    &lt;a routerLink=&quot;/detail/{{hero.id}}&quot;&gt;\n      &lt;span class=&quot;badge&quot;&gt;{{hero.id}}&lt;/span&gt; {{hero.name}}\n    &lt;/a&gt;\n    &lt;button class=&quot;delete&quot; title=&quot;delete hero&quot;\n      (click)=&quot;delete(hero)&quot;&gt;x&lt;/button&gt;\n  &lt;/li&gt;\n&lt;/ul&gt;\n\n</code-example>\n\nTo position the delete button at the far right of the hero entry,\nadd some CSS to the `heroes.component.css`. You'll find that CSS\nin the [final review code](#heroescomponent) below.\n\nAdd the `delete()` handler to the component class.\n\n<code-example path=\"toh-pt6/src/app/heroes/heroes.component.ts\" region=\"delete\" header=\"src/app/heroes/heroes.component.ts (delete)\">\ndelete(hero: Hero): void {\n  this.heroes = this.heroes.filter(h =&gt; h !== hero);\n  this.heroService.deleteHero(hero).subscribe();\n}\n\n</code-example>\n\nAlthough the component delegates hero deletion to the `HeroService`,\nit remains responsible for updating its own list of heroes.\nThe component's `delete()` method immediately removes the _hero-to-delete_ from that list,\nanticipating that the `HeroService` will succeed on the server.\n\nThere's really nothing for the component to do with the `Observable` returned by\n`heroService.delete()` **but it must subscribe anyway**.\n\n<div class=\"alert is-important\">\n\n  If you neglect to `subscribe()`, the service will not send the delete request to the server.\n  As a rule, an `Observable` _does nothing_ until something subscribes.\n\n  Confirm this for yourself by temporarily removing the `subscribe()`,\n  clicking \"Dashboard\", then clicking \"Heroes\".\n  You'll see the full list of heroes again.\n\n</div>\n\nNext, add a `deleteHero()` method to `HeroService` like this.\n\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"deleteHero\" header=\"src/app/hero.service.ts (delete)\">\n/** DELETE: 서버에서 히어로를 제거합니다. */\ndeleteHero(hero: Hero | number): Observable&lt;Hero&gt; {\n  const id = typeof hero === &#39;number&#39; ? hero : hero.id;\n  const url = `${this.heroesUrl}/${id}`;\n\n  return this.http.delete&lt;Hero&gt;(url, this.httpOptions).pipe(\n    tap(_ =&gt; this.log(`deleted hero id=${id}`)),\n    catchError(this.handleError&lt;Hero&gt;(&#39;deleteHero&#39;))\n  );\n}\n\n</code-example>\n\nNote the following key points:\n\n* `deleteHero()` calls `HttpClient.delete()`.\n* The URL is the heroes resource URL plus the `id` of the hero to delete.\n* You don't send data as you did with `put()` and `post()`.\n* You still send the `httpOptions`.\n\nRefresh the browser and try the new delete functionality.\n-->\n<p>히어로 목록에 있는 각 항목에는 제거 버튼이 있어야 합니다.</p>\n<p>그래서 <code>HeroesComponent</code> 템플릿의 <code>&#x3C;li></code> 엘리먼트로 반복되는 히어로 이름 뒤에 다음과 같은 버튼 엘리먼트를 추가합니다.</p>\n<code-example path=\"toh-pt6/src/app/heroes/heroes.component.html\" header=\"src/app/heroes/heroes.component.html\" region=\"delete\">\n&#x3C;button class=\"delete\" title=\"delete hero\"\n  (click)=\"delete(hero)\">x&#x3C;/button>\n\n</code-example>\n<p>그러면 히어로 목록을 표시하는 템플릿이 다음과 같이 구성될 것입니다:</p>\n<code-example path=\"toh-pt6/src/app/heroes/heroes.component.html\" region=\"list\" header=\"src/app/heroes/heroes.component.html (히어로 목록)\">\n&#x3C;ul class=\"heroes\">\n  &#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">\n    &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/detail/{{hero.id}}\">\n      &#x3C;span class=\"badge\">{{hero.id}}&#x3C;/span> {{hero.name}}\n    &#x3C;/a>\n    &#x3C;button class=\"delete\" title=\"delete hero\"\n      (click)=\"delete(hero)\">x&#x3C;/button>\n  &#x3C;/li>\n&#x3C;/ul>\n\n</code-example>\n<p>제거 버튼을 원하는 곳에 두려면 <code>heroes.component.css</code> 파일에 CSS 스타일을 추가해야 합니다.\n이 내용은 <a href=\"tutorial/toh-pt6#heroescomponent\">최종코드 리뷰</a> 섹션에서 확인할 수 있습니다.</p>\n<p>그 다음에는 컴포넌트 클래스에 <code>delete()</code> 핸들러를 추가합니다.</p>\n<code-example path=\"toh-pt6/src/app/heroes/heroes.component.ts\" region=\"delete\" header=\"src/app/heroes/heroes.component.ts (delete)\">\ndelete(hero: Hero): void {\n  this.heroes = this.heroes.filter(h => h !== hero);\n  this.heroService.deleteHero(hero).subscribe();\n}\n\n</code-example>\n<p>히어로를 제거하는 기능은 <code>HeroService</code>가 담당하지만, 변경된 내용으로 화면을 갱신하는 것은 컴포넌트가 처리해야 합니다.\n그래서 컴포넌트에 정의된 <code>delete()</code> 메소드는 서버로 보내는 요청이 성공할 것으로 간주하고 <em>이 히어로</em> 를 목록에서 바로 제거합니다.</p>\n<p><code>heroService.delete()</code> 메소드를 실행하고 받은 <code>Observable</code>로는 아무것도 하지 않습니다.\n함수를 실행하기 위해 <strong>단순하게 구독만 할 뿐입니다.</strong></p>\n<div class=\"alert is-important\">\n<p>  <code>subscribe()</code>를 생략하면 서버로 제거 요청을 보내지 않습니다!\n왜냐하면 아무도 구독하지 않은 <code>Observable</code>은 <em>아무 동작도</em> 하지 않기 때문입니다!</p>\n<p>  이 내용을 확인해 보려면 <code>subscribe()</code> 부분을 제거하고 앱을 다시 실행해 보세요.\n히어로를 제거한 뒤 다른 페이지로 이동했다가 돌아오면 이전에 표시되었던 히어로 목록이 그대로 표시되는 것을 확인할 수 있습니다.</p>\n</div>\n<p>그리고 <code>HeroService</code>에 다음과 같이 <code>deleteHero()</code> 메소드를 추가합니다.</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"deleteHero\" header=\"src/app/hero.service.ts (delete)\">\n/** DELETE: 서버에서 히어로를 제거합니다. */\ndeleteHero(hero: Hero | <a href=\"api/common/DecimalPipe\" class=\"code-anchor\">number</a>): Observable&#x3C;Hero> {\n  const id = typeof hero === 'number' ? hero : hero.id;\n  const url = `${this.heroesUrl}/${id}`;\n\n  return this.http.delete&#x3C;Hero>(url, this.httpOptions).pipe(\n    tap(_ => this.log(`deleted hero id=${id}`)),\n    catchError(this.handleError&#x3C;Hero>('deleteHero'))\n  );\n}\n\n</code-example>\n<p>이런 점을 주목하세요:</p>\n<ul>\n<li><code>deleteHero()</code>는 <code><a href=\"api/common/http/HttpClient#delete\" class=\"code-anchor\">HttpClient.delete()</a></code>를 실행합니다.</li>\n<li>URL은 리소스 URL 뒤에 제거하려는 히어로의 <code>id</code>가 붙은 형태입니다.</li>\n<li><code>put()</code>이나 <code>post()</code>를 실행할 때처럼 데이터를 보내지는 않습니다.</li>\n<li><code>httpOptions</code>는 그대로 사용합니다.</li>\n</ul>\n<p>이제 브라우저를 새로 고침하고 제거 기능이 제대로 동작하는지 확인해 보세요.</p>\n<!--\n## Search by name\n-->\n<h2 id=\"이름으로-검색하기\">이름으로 검색하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#이름으로-검색하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nIn this last exercise, you learn to chain `Observable` operators together\nso you can minimize the number of similar HTTP requests\nand consume network bandwidth economically.\n\nYou will add a heroes search feature to the Dashboard.\nAs the user types a name into a search box,\nyou'll make repeated HTTP requests for heroes filtered by that name.\nYour goal is to issue only as many requests as necessary.\n-->\n<p>이전 섹션에서 알아본 것처럼 <code>Observable</code> 연산자를 체이닝하면 HTTP 요청을 최적화할 수 있으며, 결과적으로 네트워크 사용량을 절약할 수 있습니다.</p>\n<p>이번에는 <em>대시보드</em> 화면에 <em>히어로를 검색하는</em> 기능을 추가해 봅시다.\n사용자가 검색창에 히어로 이름을 입력하면 입력한 내용이 포함된 히어로의 목록을 받아오도록 HTTP 요청을 보낼 것입니다.\n이 때 진짜 필요할 때만 실제로 요청을 보내는 방법에 대해 알아봅시다.</p>\n<h4 id=\"heroservicesearchheroes\"><code>HeroService.searchHeroes()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#heroservicesearchheroes\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nStart by adding a `searchHeroes()` method to the `HeroService`.\n\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"searchHeroes\" header=\"src/app/hero.service.ts\">\n/* GET: 입력된 문구가 이름에 포함된 히어로 목록을 반환합니다. */\nsearchHeroes(term: string): Observable&lt;Hero[]&gt; {\n  if (!term.trim()) {\n    // 입력된 내용이 없으면 빈 배열을 반환합니다.\n    return of([]);\n  }\n  return this.http.get&lt;Hero[]&gt;(`${this.heroesUrl}/?name=${term}`).pipe(\n    tap(x =&gt; x.length ?\n       this.log(`found heroes matching &quot;${term}&quot;`) :\n       this.log(`no heroes matching &quot;${term}&quot;`)),\n    catchError(this.handleError&lt;Hero[]&gt;(&#39;searchHeroes&#39;, []))\n  );\n}\n\n</code-example>\n\nThe method returns immediately with an empty array if there is no search term.\nThe rest of it closely resembles `getHeroes()`, the only significant difference being\nthe URL, which includes a query string with the search term.\n-->\n<p>아래 내용으로 <code>HeroService</code>에 <code>searchHeroes()</code> 메소드를 추가합니다.</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"searchHeroes\" header=\"src/app/hero.service.ts\">\n/* GET: 입력된 문구가 이름에 포함된 히어로 목록을 반환합니다. */\nsearchHeroes(term: string): Observable&#x3C;Hero[]> {\n  if (!term.trim()) {\n    // 입력된 내용이 없으면 빈 배열을 반환합니다.\n    return of([]);\n  }\n  return this.http.get&#x3C;Hero[]>(`${this.heroesUrl}/?name=${term}`).pipe(\n    tap(x => x.length ?\n       this.log(`found heroes matching \"${term}\"`) :\n       this.log(`no heroes matching \"${term}\"`)),\n    catchError(this.handleError&#x3C;Hero[]>('searchHeroes', []))\n  );\n}\n\n</code-example>\n<p>이 메소드는 입력된 내용이 없을 때 빈 배열을 즉시 반환합니다.\n이 경우가 아니라면 <code>getHeroes()</code>와 거의 비슷합니다.\n사용자가 입력한 문구가 URL에 쿼리 스트링으로 포함된다는 것만 다릅니다.</p>\n<!--\n### Add search to the Dashboard\n-->\n<h3 id=\"대시보드에-검색-기능-추가하기\">대시보드에 검색 기능 추가하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#대시보드에-검색-기능-추가하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nOpen the `DashboardComponent` template and\nadd the hero search element, `<app-hero-search>`, to the bottom of the markup.\n\n<code-example path=\"toh-pt6/src/app/dashboard/dashboard.component.html\" header=\"src/app/dashboard/dashboard.component.html\">\n&lt;h3&gt;Top Heroes&lt;/h3&gt;\n&lt;div class=&quot;grid grid-pad&quot;&gt;\n  &lt;a *ngFor=&quot;let hero of heroes&quot; class=&quot;col-1-4&quot;\n      routerLink=&quot;/detail/{{hero.id}}&quot;&gt;\n    &lt;div class=&quot;module hero&quot;&gt;\n      &lt;h4&gt;{{hero.name}}&lt;/h4&gt;\n    &lt;/div&gt;\n  &lt;/a&gt;\n&lt;/div&gt;\n\n&lt;app-hero-search&gt;&lt;/app-hero-search&gt;\n\n\n</code-example>\n\nThis template looks a lot like the `*ngFor` repeater in the `HeroesComponent` template.\n\nFor this to work, the next step is to add a component with a selector that matches `<app-hero-search>`.\n-->\n<p><code>DashboardComponent</code> <em>템플릿</em> 을 열고 이 템플릿 제일 아래에 <code>&#x3C;app-hero-search></code>를 추가합니다.</p>\n<code-example path=\"toh-pt6/src/app/dashboard/dashboard.component.html\" header=\"src/app/dashboard/dashboard.component.html\">\n&#x3C;h3>Top Heroes&#x3C;/h3>\n&#x3C;div class=\"grid grid-pad\">\n  &#x3C;a *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\" class=\"col-1-4\"\n      <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/detail/{{hero.id}}\">\n    &#x3C;div class=\"module hero\">\n      &#x3C;h4>{{hero.name}}&#x3C;/h4>\n    &#x3C;/div>\n  &#x3C;/a>\n&#x3C;/div>\n\n&#x3C;app-hero-search>&#x3C;/app-hero-search>\n\n\n</code-example>\n<p>이 템플릿은 <code>HeroesComponent</code> 템플릿에서 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 반복자가 사용된 부분과 거의 비슷합니다.</p>\n<p>이 부분을 구현하기 위해 다음 단계에서는 컴포넌트에 <code>&#x3C;app-hero-search></code> 컴포넌트를 추가해 봅시다.</p>\n<!--\n### Create `HeroSearchComponent`\n-->\n<h3 id=\"herosearchcomponent-생성하기\"><code>HeroSearchComponent</code> 생성하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#herosearchcomponent-생성하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nCreate a `HeroSearchComponent` with the CLI.\n\n<code-example language=\"sh\" class=\"code-shell\">\n  ng generate component hero-search\n</code-example>\n\nThe CLI generates the three `HeroSearchComponent` files and adds the component to the `AppModule` declarations.\n\nReplace the generated `HeroSearchComponent` template with an `<input>` and a list of matching search results, as follows.\n\n<code-example path=\"toh-pt6/src/app/hero-search/hero-search.component.html\" header=\"src/app/hero-search/hero-search.component.html\">\n&lt;div id=&quot;search-component&quot;&gt;\n  &lt;h4&gt;&lt;label for=&quot;search-box&quot;&gt;Hero Search&lt;/label&gt;&lt;/h4&gt;\n\n  &lt;input #searchBox id=&quot;search-box&quot; (input)=&quot;search(searchBox.value)&quot; /&gt;\n\n  &lt;ul class=&quot;search-result&quot;&gt;\n    &lt;li *ngFor=&quot;let hero of heroes$ | async&quot; &gt;\n      &lt;a routerLink=&quot;/detail/{{hero.id}}&quot;&gt;\n        {{hero.name}}\n      &lt;/a&gt;\n    &lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/div&gt;\n\n\n</code-example>\n\nAdd private CSS styles to `hero-search.component.css`\nas listed in the [final code review](#herosearchcomponent) below.\n\nAs the user types in the search box, an input event binding calls the\ncomponent's `search()` method with the new search box value.\n-->\n<p>Angular CLI로 다음 명령을 실행해서 <code>HeroSearchComponent</code>를 생성합니다.</p>\n<code-example language=\"sh\" class=\"code-shell\">\n  ng generate component hero-search\n</code-example>\n<p>그러면 Angular CLI가 <code>HeroSearchComponent</code>를 구성하는 파일을 생성하면서 <code>AppModule</code>에 이 컴포넌트를 자동으로 등록합니다.</p>\n<p>이렇게 생성된 <code>HeroSearchComponent</code>의 <em>템플릿</em> 을 다음과 같이 수정합니다. 이 템플릿에는 사용자가 내용을 입력할 수 있는 텍스트 박스가 하나 있고, 검색 결과를 표시하는 목록이 있습니다.</p>\n<code-example path=\"toh-pt6/src/app/hero-search/hero-search.component.html\" header=\"src/app/hero-search/hero-search.component.html\">\n&#x3C;div id=\"search-component\">\n  &#x3C;h4>&#x3C;label for=\"search-box\">Hero Search&#x3C;/label>&#x3C;/h4>\n\n  &#x3C;input #searchBox id=\"search-box\" (input)=\"search(searchBox.value)\" />\n\n  &#x3C;ul class=\"search-result\">\n    &#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes$ | async\" >\n      &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/detail/{{hero.id}}\">\n        {{hero.name}}\n      &#x3C;/a>\n    &#x3C;/li>\n  &#x3C;/ul>\n&#x3C;/div>\n\n\n</code-example>\n<p>그리고 <a href=\"tutorial/toh-pt6#herosearchcomponent\">최종코드 리뷰</a>에 있는 내용처럼 <code>hero-search.component.css</code> 파일에 컴포넌트 CSS 스타일을 추가합니다.</p>\n<p>이제 사용자가 검색창에 내용을 입력하면 <em>입력</em> 이벤트에 바인딩된 <code>search()</code> 메소드가 실행될 것입니다.</p>\n<a id=\"asyncpipe\"></a>\n<h3 id=\"asyncpipe\"><code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">AsyncPipe</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#asyncpipe\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe `*ngFor` repeats hero objects. Notice that the `*ngFor` iterates over a list called `heroes$`, not `heroes`. The `$` is a convention that indicates `heroes$` is an `Observable`, not an array.\n\n\n<code-example path=\"toh-pt6/src/app/hero-search/hero-search.component.html\" header=\"src/app/hero-search/hero-search.component.html\" region=\"async\">\n&lt;li *ngFor=&quot;let hero of heroes$ | async&quot; &gt;\n\n</code-example>\n\nSince `*ngFor` can't do anything with an `Observable`, use the\npipe character (`|`) followed by `async`. This identifies Angular's `AsyncPipe` and subscribes to an `Observable` automatically so you won't have to\ndo so in the component class.\n-->\n<p><code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>는 히어로 객체를 순회하는데, 이 때 <code>heroes</code> 배열대신 <code>heroes$</code>를 사용합니다.\n<code>$</code>는 <code>Observable</code>을 뜻하는 관용적 표현입니다.</p>\n<code-example path=\"toh-pt6/src/app/hero-search/hero-search.component.html\" header=\"src/app/hero-search/hero-search.component.html\" region=\"async\">\n&#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes$ | async\" >\n\n</code-example>\n<p><code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 자체로는 <code>Observable</code>을 대상으로 어떤 작업도 수행하지 않기 때문에 파이프 문자(<code>|</code>)를 붙이고 <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">async</a></code> 파이프를 연결해 줍니다.\n이 파이프는 <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">AsyncPipe</a></code>에 정의된 파이프이며, <code>Observable</code>을 자동으로 구독하는 역할을 합니다. 컴포넌트에서 따로 구독할 필요는 없습니다.</p>\n<!--\n### Edit the `HeroSearchComponent` class\n-->\n<h3 id=\"herosearchcomponent-클래스-수정하기\"><code>HeroSearchComponent</code> 클래스 수정하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#herosearchcomponent-클래스-수정하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nReplace the generated `HeroSearchComponent` class and metadata as follows.\n\n<code-example path=\"toh-pt6/src/app/hero-search/hero-search.component.ts\" header=\"src/app/hero-search/hero-search.component.ts\">\nimport { Component, OnInit } from &#39;@angular/core&#39;;\n\nimport { Observable, Subject } from &#39;rxjs&#39;;\n\nimport {\n   debounceTime, distinctUntilChanged, switchMap\n } from &#39;rxjs/operators&#39;;\n\nimport { Hero } from &#39;../hero&#39;;\nimport { HeroService } from &#39;../hero.service&#39;;\n\n@Component({\n  selector: &#39;app-hero-search&#39;,\n  templateUrl: &#39;./hero-search.component.html&#39;,\n  styleUrls: [ &#39;./hero-search.component.css&#39; ]\n})\nexport class HeroSearchComponent implements OnInit {\n  heroes$: Observable&lt;Hero[]&gt;;\n  private searchTerms = new Subject&lt;string&gt;();\n\n  constructor(private heroService: HeroService) {}\n\n  // 사용자가 입력한 검색어를 옵저버블 스트림으로 보냅니다.\n  search(term: string): void {\n    this.searchTerms.next(term);\n  }\n\n  ngOnInit(): void {\n    this.heroes$ = this.searchTerms.pipe(\n      // 연속된 키입력을 처리하기 위해 300ms 대기합니다.\n      debounceTime(300),\n\n      // 이전에 입력한 검색어와 같으면 무시합니다.\n      distinctUntilChanged(),\n\n      // 검색어가 변경되면 새로운 옵저버블을 생성합니다.\n      switchMap((term: string) =&gt; this.heroService.searchHeroes(term)),\n    );\n  }\n}\n\n\n</code-example>\n\nNotice the declaration of `heroes$` as an `Observable`:\n\n<code-example path=\"toh-pt6/src/app/hero-search/hero-search.component.ts\" header=\"src/app/hero-search/hero-search.component.ts\" region=\"heroes-stream\">\nheroes$: Observable&lt;Hero[]&gt;;\n\n</code-example>\n\nYou'll set it in [`ngOnInit()`](#search-pipe).\nBefore you do, focus on the definition of `searchTerms`.\n-->\n<p>Angular CLI가 생성한 <code>HeroSearchComponent</code> 클래스와 메타데이터의 내용을 다음과 같이 수정합니다.</p>\n<code-example path=\"toh-pt6/src/app/hero-search/hero-search.component.ts\" header=\"src/app/hero-search/hero-search.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\n\nimport { Observable, Subject } from 'rxjs';\n\nimport {\n   debounceTime, distinctUntilChanged, switchMap\n } from 'rxjs/operators';\n\nimport { Hero } from '../hero';\nimport { HeroService } from '../hero.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-search',\n  templateUrl: './hero-search.component.html',\n  styleUrls: [ './hero-search.component.css' ]\n})\nexport class HeroSearchComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  heroes$: Observable&#x3C;Hero[]>;\n  private searchTerms = new Subject&#x3C;string>();\n\n  constructor(private heroService: HeroService) {}\n\n  // 사용자가 입력한 검색어를 옵저버블 스트림으로 보냅니다.\n  search(term: string): void {\n    this.searchTerms.next(term);\n  }\n\n  ngOnInit(): void {\n    this.heroes$ = this.searchTerms.pipe(\n      // 연속된 키입력을 처리하기 위해 300ms 대기합니다.\n      debounceTime(300),\n\n      // 이전에 입력한 검색어와 같으면 무시합니다.\n      distinctUntilChanged(),\n\n      // 검색어가 변경되면 새로운 옵저버블을 생성합니다.\n      switchMap((term: string) => this.heroService.searchHeroes(term)),\n    );\n  }\n}\n\n\n</code-example>\n<p><code>heroes$</code> 프로퍼티는 <code>Observable</code> 타입으로 선언하는 것을 잊지 마세요.</p>\n<code-example path=\"toh-pt6/src/app/hero-search/hero-search.component.ts\" header=\"src/app/hero-search/hero-search.component.ts\" region=\"heroes-stream\">\nheroes$: Observable&#x3C;Hero[]>;\n\n</code-example>\n<p>이 옵저버블 구독은 <a href=\"tutorial/toh-pt6#search-pipe\"><code>ngOnInit()</code></a>에서 시작됩니다.\n지금은 <code>searchTerms</code>을 선언하는 방법에 대해 먼저 알아봅시다.</p>\n<!--\n### The `searchTerms` RxJS subject\n-->\n<h3 id=\"searchterms-rxjs-subject\"><code>searchTerms</code> RxJS subject<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#searchterms-rxjs-subject\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe `searchTerms` property is an RxJS `Subject`.\n\n<code-example path=\"toh-pt6/src/app/hero-search/hero-search.component.ts\" header=\"src/app/hero-search/hero-search.component.ts\" region=\"searchTerms\">\nprivate searchTerms = new Subject&lt;string&gt;();\n\n// 사용자가 입력한 검색어를 옵저버블 스트림으로 보냅니다.\nsearch(term: string): void {\n  this.searchTerms.next(term);\n}\n\n</code-example>\n\nA `Subject` is both a source of observable values and an `Observable` itself.\nYou can subscribe to a `Subject` as you would any `Observable`.\n\nYou can also push values into that `Observable` by calling its `next(value)` method\nas the `search()` method does.\n\nThe event binding to the textbox's `input` event calls the `search()` method.\n\n<code-example path=\"toh-pt6/src/app/hero-search/hero-search.component.html\" header=\"src/app/hero-search/hero-search.component.html\" region=\"input\">\n&lt;input #searchBox id=&quot;search-box&quot; (input)=&quot;search(searchBox.value)&quot; /&gt;\n\n</code-example>\n\nEvery time the user types in the textbox, the binding calls `search()` with the textbox value, a \"search term\".\nThe `searchTerms` becomes an `Observable` emitting a steady stream of search terms.\n-->\n<p><code>searchTerms</code> 프로퍼티는 RxJS가 제공하는 <code>Subject</code> 객체로 선언합니다.</p>\n<code-example path=\"toh-pt6/src/app/hero-search/hero-search.component.ts\" header=\"src/app/hero-search/hero-search.component.ts\" region=\"searchTerms\">\nprivate searchTerms = new Subject&#x3C;string>();\n\n// 사용자가 입력한 검색어를 옵저버블 스트림으로 보냅니다.\nsearch(term: string): void {\n  this.searchTerms.next(term);\n}\n\n</code-example>\n<p><code>Subject</code>는 옵저버블의 원천 소스이며 <code>Observable</code> 그 자체이기도 합니다.\n그래서 <code>Subject</code> 객체는 <code>Observable</code> 객체처럼 구독할 수도 있습니다.</p>\n<p>그리고 <code>Observable</code>로 값을 보내기 위해 <code>next(value)</code> 메소드를 실행할 수도 있습니다.\n<code>search()</code> 메소드에서 이 함수를 사용했습니다.</p>\n<p><code>&#x3C;input></code> 엘리먼트와 이벤트 바인딩된 <code>search()</code> 메소드가 이런 방식으로 동작합니다.</p>\n<code-example path=\"toh-pt6/src/app/hero-search/hero-search.component.html\" header=\"src/app/hero-search/hero-search.component.html\" region=\"input\">\n&#x3C;input #searchBox id=\"search-box\" (input)=\"search(searchBox.value)\" />\n\n</code-example>\n<p>사용자가 텍스트박스에 키보드를 입력할 때마다 입력된 내용이 인자로 전달되면서 <code>search()</code> 메소드가 실행됩니다.\n이 메소드에서 <code>searchTerms</code> 프로퍼티는 <code>Observable</code>로 동작하며, 사용자가 입력한 내용을 옵저버블 스트림으로 보냅니다.</p>\n<a id=\"search-pipe\"></a>\n<!--\n### Chaining RxJS operators\n-->\n<h3 id=\"rxjs-연산자-체이닝하기\">RxJS 연산자 체이닝하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#rxjs-연산자-체이닝하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nPassing a new search term directly to the `searchHeroes()` after every user keystroke would create an excessive amount of HTTP requests,\ntaxing server resources and burning through data plans.\n\nInstead, the `ngOnInit()` method pipes the `searchTerms` observable through a sequence of RxJS operators that reduce the number of calls to the `searchHeroes()`,\nultimately returning an observable of timely hero search results (each a `Hero[]`).\n\nHere's a closer look at the code.\n\n<code-example path=\"toh-pt6/src/app/hero-search/hero-search.component.ts\" header=\"src/app/hero-search/hero-search.component.ts\" region=\"search\">\nthis.heroes$ = this.searchTerms.pipe(\n  // 연속된 키입력을 처리하기 위해 300ms 대기합니다.\n  debounceTime(300),\n\n  // 이전에 입력한 검색어와 같으면 무시합니다.\n  distinctUntilChanged(),\n\n  // 검색어가 변경되면 새로운 옵저버블을 생성합니다.\n  switchMap((term: string) =&gt; this.heroService.searchHeroes(term)),\n);\n\n</code-example>\n\nEach operator works as follows:\n\n* `debounceTime(300)` waits until the flow of new string events pauses for 300 milliseconds\nbefore passing along the latest string. You'll never make requests more frequently than 300ms.\n\n* `distinctUntilChanged()` ensures that a request is sent only if the filter text changed.\n\n* `switchMap()` calls the search service for each search term that makes it through `debounce()` and `distinctUntilChanged()`.\nIt cancels and discards previous search observables, returning only the latest search service observable.\n-->\n<p>사용자가 입력한 검색어가 <code>searchHeroes()</code>로 바로 넘어간다면 사용자의 키입력마다 HTTP 요청이 발생하기 때문에 수많은 HTTP 요청이 발생할 것입니다.\n이렇게 되면 서버에 과도한 부하가 걸릴 수 있으며 모바일 장비의 네트워크 요금도 빠르게 올라갈 것입니다.</p>\n<p>이 방법보다는 <code>ngOnInit()</code> 메소드에서 <code>searchTerms</code> 옵저버블로 데이터를 보낼 때 RxJS 연산자로 체이닝해서 <code>searchHeroes()</code>로 전달되는 것을 최적화하는 것이 더 좋습니다.</p>\n<p>코드를 자세하게 봅시다.</p>\n<code-example path=\"toh-pt6/src/app/hero-search/hero-search.component.ts\" header=\"src/app/hero-search/hero-search.component.ts\" region=\"search\">\nthis.heroes$ = this.searchTerms.pipe(\n  // 연속된 키입력을 처리하기 위해 300ms 대기합니다.\n  debounceTime(300),\n\n  // 이전에 입력한 검색어와 같으면 무시합니다.\n  distinctUntilChanged(),\n\n  // 검색어가 변경되면 새로운 옵저버블을 생성합니다.\n  switchMap((term: string) => this.heroService.searchHeroes(term)),\n);\n\n</code-example>\n<p>각 연산자는 이렇게 동작합니다:</p>\n<ul>\n<li>\n<p><code>debounceTime(300)</code>는 옵저버블로 전달된 문자열을 바로 보내지 않고 다음 이벤트가 올 떄까지 300 밀리초 기다립니다. 사용자가 보내는 요청은 300ms에 하나로 제한됩니다.</p>\n</li>\n<li>\n<p><code>distinctUntilChanged()</code>는 사용자가 입력한 문자열의 내용이 변경되었을 때만 옵저버블 스트림을 전달합니다.</p>\n</li>\n<li>\n<p><code>switchMap()</code>는 옵저버블 스트림이 <code>debounce</code>와 <code>distinctUntilChanged</code>를 통과했을 때 서비스에 있는 검색 기능을 호출합니다.\n이 때 이전에 발생했던 옵저버블은 취소되며, <code>HeroService</code>가 생성한 옵저버블만 반환합니다.</p>\n</li>\n</ul>\n<div class=\"alert is-helpful\">\n  <!--\n  With the [switchMap operator](http://www.learnrxjs.io/operators/transformation/switchmap.html),\n  every qualifying key event can trigger an `HttpClient.get()` method call.\n  Even with a 300ms pause between requests, you could have multiple HTTP requests in flight\n  and they may not return in the order sent.\n\n  `switchMap()` preserves the original request order while returning only the observable from the most recent HTTP method call.\n  Results from prior calls are canceled and discarded.\n\n  Note that canceling a previous `searchHeroes()` Observable\n  doesn't actually abort a pending HTTP request.\n  Unwanted results are simply discarded before they reach your application code.\n  -->\n<p>  <a href=\"http://www.learnrxjs.io/operators/transformation/switchmap.html\">switchMap 연산자</a>를 사용하면 옵저버블 체이닝을 통과한 키이벤트마다 <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 메소드가 실행됩니다.\n그런데 요청을 300ms 당 한 번으로 제한하더라도 동작중인 HTTP 요청은 여러개가 될 수 있으며, 응답이 돌아오는 순서도 보낸 순서와 다를 수 있습니다.</p>\n<p>  이 때 <code>switchMap()</code> 연산자를 활용하면 이전에 보낸 HTTP 요청을 취소하고 제일 마지막에 보낸 HTTP 요청만 남겨둘 수 있습니다.</p>\n<p>  하지만 이전에 발생한 <code>searchHeroes()</code> <em>Observable</em> 을 취소했다고 해서 이미 보낸 HTTP 요청을 취소하지는 않습니다.\n이미 보낸 HTTP 요청에 대한 응답은 애플리케이션 코드에 도달하지 못하고 그냥 폐기됩니다.</p>\n</div>\n<!--\nRemember that the component _class_ does not subscribe to the `heroes$` _observable_.\nThat's the job of the [`AsyncPipe`](#asyncpipe) in the template.\n-->\n<p>컴포넌트 <em>클래스</em> 에서 <code>heroes$</code> <em>옵저버블</em> 을 구독하지 않는 것에 주의하세요.\n<a href=\"tutorial/toh-pt6#asyncpipe\"><code>AsyncPipe</code></a>는 템플릿에서 옵저버블을 구독하기 위해 사용되었습니다.</p>\n<!--\n#### Try it\n-->\n<h4 id=\"동작-확인하기\">동작 확인하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#동작-확인하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nRun the app again. In the *Dashboard*, enter some text in the search box.\nIf you enter characters that match any existing hero names, you'll see something like this.\n\n<div class=\"lightbox\">\n  <img src='generated/images/guide/toh/toh-hero-search.png' alt=\"Hero Search Component\">\n</div>\n-->\n<p>애플리케이션을 다시 실행해 보세요.\n<em>대시보드</em> 화면에 있는 검색창에 무언가를 입력했을 때 이 입력값이 포함된 히어로의 이름이 있으면 다음과 같은 모습으로 화면에 표시될 것입니다.</p>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/toh/toh-hero-search.png\" alt=\"Hero Search Component\" width=\"240\" height=\"224\">\n</div>\n<!--\n## Final code review\n-->\n<h2 id=\"최종코드-리뷰\">최종코드 리뷰<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#최종코드-리뷰\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nHere are the code files discussed on this page (all in the `src/app/` folder).\n-->\n<p>이 문서에서 다룬 코드들을 확인해 보세요.</p>\n<a id=\"heroservice\"></a>\n<a id=\"inmemorydataservice\"></a>\n<a id=\"appmodule\"></a>\n<h4 id=\"heroservice-inmemorydataservice-appmodule\"><code>HeroService</code>, <code>InMemoryDataService</code>, <code>AppModule</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#heroservice-inmemorydataservice-appmodule\"><i class=\"material-icons\">link</i></a></h4>\n<code-tabs>\n  <code-pane header=\"hero.service.ts\" path=\"toh-pt6/src/app/hero.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>, <a href=\"api/common/http/HttpHeaders\" class=\"code-anchor\">HttpHeaders</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\nimport { Observable, of } from 'rxjs';\nimport { catchError, map, tap } from 'rxjs/operators';\n\nimport { Hero } from './hero';\nimport { MessageService } from './message.service';\n\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({ providedIn: 'root' })\nexport class HeroService {\n\n  private heroesUrl = 'api/heroes';  // 웹 API 형식의 URL로 사용\n\n  httpOptions = {\n    headers: new <a href=\"api/common/http/HttpHeaders\" class=\"code-anchor\">HttpHeaders</a>({ 'Content-Type': 'application/json' })\n  };\n\n  constructor(\n    private <a href=\"api/common/http\" class=\"code-anchor\">http</a>: <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>,\n    private messageService: MessageService) { }\n\n  /** GET: 서버에서 히어로 목록 가져오기 */\n  getHeroes(): Observable&#x3C;Hero[]> {\n    return this.http.get&#x3C;Hero[]>(this.heroesUrl)\n      .pipe(\n        tap(_ => this.log('fetched heroes')),\n        catchError(this.handleError&#x3C;Hero[]>('getHeroes', []))\n      );\n  }\n\n  /** GET: id에 해당하는 히어로 데이터를 가져옵니다. 존재하지 않으면 `undefined`를 반환합니다. */\n  getHeroNo404&#x3C;Hero>(id: number): Observable&#x3C;Hero> {\n    const url = `${this.heroesUrl}/?id=${id}`;\n    return this.http.get&#x3C;Hero[]>(url)\n      .pipe(\n        map(heroes => heroes[0]), // 배열에 있는 항목 중 하나만 반환합니다.\n        tap(h => {\n          const outcome = h ? `fetched` : `did not find`;\n          this.log(`${outcome} hero id=${id}`);\n        }),\n        catchError(this.handleError&#x3C;Hero>(`getHero id=${id}`))\n      );\n  }\n\n  /** GET: id에 해당하는 히어로 데이터 가져오기. 존재하지 않으면 404를 반환합니다. */\n  getHero(id: number): Observable&#x3C;Hero> {\n    const url = `${this.heroesUrl}/${id}`;\n    return this.http.get&#x3C;Hero>(url).pipe(\n      tap(_ => this.log(`fetched hero id=${id}`)),\n      catchError(this.handleError&#x3C;Hero>(`getHero id=${id}`))\n    );\n  }\n\n  /* GET: 입력된 문구가 이름에 포함된 히어로 목록을 반환합니다. */\n  searchHeroes(term: string): Observable&#x3C;Hero[]> {\n    if (!term.trim()) {\n      // 입력된 내용이 없으면 빈 배열을 반환합니다.\n      return of([]);\n    }\n    return this.http.get&#x3C;Hero[]>(`${this.heroesUrl}/?name=${term}`).pipe(\n      tap(x => x.length ?\n         this.log(`found heroes matching \"${term}\"`) :\n         this.log(`no heroes matching \"${term}\"`)),\n      catchError(this.handleError&#x3C;Hero[]>('searchHeroes', []))\n    );\n  }\n\n  //////// 저장 기능 //////////\n\n  /** POST: 서버에 새로운 히어로를 추가합니다. */\n  addHero(hero: Hero): Observable&#x3C;Hero> {\n    return this.http.post&#x3C;Hero>(this.heroesUrl, hero, this.httpOptions).pipe(\n      tap((newHero: Hero) => this.log(`added hero w/ id=${newHero.id}`)),\n      catchError(this.handleError&#x3C;Hero>('addHero'))\n    );\n  }\n\n  /** DELETE: 서버에서 히어로를 제거합니다. */\n  deleteHero(hero: Hero | <a href=\"api/common/DecimalPipe\" class=\"code-anchor\">number</a>): Observable&#x3C;Hero> {\n    const id = typeof hero === 'number' ? hero : hero.id;\n    const url = `${this.heroesUrl}/${id}`;\n\n    return this.http.delete&#x3C;Hero>(url, this.httpOptions).pipe(\n      tap(_ => this.log(`deleted hero id=${id}`)),\n      catchError(this.handleError&#x3C;Hero>('deleteHero'))\n    );\n  }\n\n  /** PUT: 서버에 저장된 히어로 데이터를 변경합니다. */\n  updateHero(hero: Hero): Observable&#x3C;any> {\n    return this.http.put(this.heroesUrl, hero, this.httpOptions).pipe(\n      tap(_ => this.log(`updated hero id=${hero.id}`)),\n      catchError(this.handleError&#x3C;any>('updateHero'))\n    );\n  }\n\n  /**\n   * HTTP 요청이 실패한 경우를 처리합니다.\n   * 애플리케이션 로직 흐름은 그대로 유지됩니다.\n   * @param operation - 실패한 동작의 이름\n   * @param result - 기본값으로 반환할 객체\n   */\n  private handleError&#x3C;T>(operation = 'operation', result?: T) {\n    return (error: any): Observable&#x3C;T> => {\n\n      // TODO: 리모트 서버로 에러 메시지 보내기\n      console.error(error); // 지금은 콘솔에 로그를 출력합니다.\n\n      // TODO: 사용자가 이해할 수 있는 형태로 변환하기\n      this.log(`${operation} failed: ${error.message}`);\n\n      // 애플리케이션 로직이 끊기지 않도록 기본값으로 받은 객체를 반환합니다.\n      return of(result as T);\n    };\n  }\n\n  /** HeroService에서 보내는 메시지는 MessageService가 화면에 표시합니다. */\n  private log(message: string) {\n    this.messageService.add(`HeroService: ${message}`);\n  }\n}\n\n\n</code-pane>\n  <code-pane header=\"in-memory-data.service.ts\" path=\"toh-pt6/src/app/in-memory-data.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { InMemoryDbService } from 'angular-in-memory-web-api';\nimport { Hero } from './hero';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class InMemoryDataService implements InMemoryDbService {\n  createDb() {\n    const heroes = [\n      { id: 11, name: 'Dr Nice' },\n      { id: 12, name: 'Narco' },\n      { id: 13, name: 'Bombasto' },\n      { id: 14, name: 'Celeritas' },\n      { id: 15, name: 'Magneta' },\n      { id: 16, name: 'RubberMan' },\n      { id: 17, name: 'Dynama' },\n      { id: 18, name: 'Dr IQ' },\n      { id: 19, name: 'Magma' },\n      { id: 20, name: 'Tornado' }\n    ];\n    return {heroes};\n  }\n\n  // 히어로 객체가 항상 id 프로퍼티를 갖도록 getId 메소드를 오버라이드 합니다.\n  // 히어로 목록이 비어있다면 이 메소드는 초기값(11)을 반환합니다.\n  // 히어로 목록이 비어있지 않으면 히어로 id의 최대값에 1을 더해서 반환합니다.\n  genId(heroes: Hero[]): number {\n    return heroes.length > 0 ? Math.max(...heroes.map(hero => hero.id)) + 1 : 11;\n  }\n}\n\n\n</code-pane>\n  <code-pane header=\"app.module.ts\" path=\"toh-pt6/src/app/app.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\nimport { HttpClientInMemoryWebApiModule } from 'angular-in-memory-web-api';\nimport { InMemoryDataService } from './in-memory-data.service';\n\nimport { AppRoutingModule } from './app-routing.module';\n\nimport { AppComponent } from './app.component';\nimport { DashboardComponent } from './dashboard/dashboard.component';\nimport { HeroDetailComponent } from './hero-detail/hero-detail.component';\nimport { HeroesComponent } from './heroes/heroes.component';\nimport { HeroSearchComponent } from './hero-search/hero-search.component';\nimport { MessagesComponent } from './messages/messages.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    AppRoutingModule,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n\n    // HttpClientInMemoryWebApiModule 모듈은 HTTP 요청을 가로채고 서버의 응답을 흉내냅니다.\n    // 실제 서버가 준비되면 이 부분을 제거하면 됩니다.\n    HttpClientInMemoryWebApiModule.forRoot(\n      InMemoryDataService, { dataEncapsulation: false }\n    )\n  ],\n  declarations: [\n    AppComponent,\n    DashboardComponent,\n    HeroesComponent,\n    HeroDetailComponent,\n    MessagesComponent,\n    HeroSearchComponent\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n</code-pane>\n</code-tabs>\n<a id=\"heroescomponent\"></a>\n<h4 id=\"heroescomponent\"><code>HeroesComponent</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#heroescomponent\"><i class=\"material-icons\">link</i></a></h4>\n<code-tabs>\n  <code-pane header=\"heroes/heroes.component.html\" path=\"toh-pt6/src/app/heroes/heroes.component.html\">\n&#x3C;h2>My Heroes&#x3C;/h2>\n\n&#x3C;div>\n  &#x3C;label>Hero name:\n    &#x3C;input #heroName />\n  &#x3C;/label>\n  &#x3C;!-- (click) 이벤트를 감지하면 현재값을 인자로 전달하면서 add() 함수를 실행하고, 입력 필드를 비웁니다. -->\n  &#x3C;button (click)=\"add(heroName.value); heroName.value=''\">\n    add\n  &#x3C;/button>\n&#x3C;/div>\n\n&#x3C;ul class=\"heroes\">\n  &#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">\n    &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/detail/{{hero.id}}\">\n      &#x3C;span class=\"badge\">{{hero.id}}&#x3C;/span> {{hero.name}}\n    &#x3C;/a>\n    &#x3C;button class=\"delete\" title=\"delete hero\"\n      (click)=\"delete(hero)\">x&#x3C;/button>\n  &#x3C;/li>\n&#x3C;/ul>\n\n\n</code-pane>\n  <code-pane header=\"heroes/heroes.component.ts\" path=\"toh-pt6/src/app/heroes/heroes.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\n\nimport { Hero } from '../hero';\nimport { HeroService } from '../hero.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-heroes',\n  templateUrl: './heroes.component.html',\n  styleUrls: ['./heroes.component.css']\n})\nexport class HeroesComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  heroes: Hero[];\n\n  constructor(private heroService: HeroService) { }\n\n  ngOnInit() {\n    this.getHeroes();\n  }\n\n  getHeroes(): void {\n    this.heroService.getHeroes()\n    .subscribe(heroes => this.heroes = heroes);\n  }\n\n  add(name: string): void {\n    name = name.trim();\n    if (!name) { return; }\n    this.heroService.addHero({ name } as Hero)\n      .subscribe(hero => {\n        this.heroes.push(hero);\n      });\n  }\n\n  delete(hero: Hero): void {\n    this.heroes = this.heroes.filter(h => h !== hero);\n    this.heroService.deleteHero(hero).subscribe();\n  }\n\n}\n\n\n</code-pane>\n  <code-pane header=\"heroes/heroes.component.css\" path=\"toh-pt6/src/app/heroes/heroes.component.css\">\n/* HeroesComponent 컴포넌트에 적용되는 CSS 스타일 */\n.heroes {\n  margin: 0 0 2em 0;\n  list-style-type: none;\n  padding: 0;\n  width: 15em;\n}\n.heroes li {\n  position: relative;\n  cursor: pointer;\n  background-color: #EEE;\n  margin: .5em;\n  padding: .3em 0;\n  height: 1.6em;\n  border-radius: 4px;\n}\n\n.heroes li:hover {\n  color: #607D8B;\n  background-color: #DDD;\n  left: .1em;\n}\n\n.heroes a {\n  color: #333;\n  text-decoration: none;\n  position: relative;\n  display: block;\n  width: 250px;\n}\n\n.heroes a:hover {\n  color: #607D8B;\n}\n\n.heroes .badge {\n  display: inline-block;\n  font-size: small;\n  color: white;\n  padding: 0.8em 0.7em 0 0.7em;\n  background-color: #405061;\n  line-height: 1em;\n  position: relative;\n  left: -1px;\n  top: -4px;\n  height: 1.8em;\n  min-width: 16px;\n  text-align: right;\n  margin-right: .8em;\n  border-radius: 4px 0 0 4px;\n}\n\nbutton {\n  background-color: #eee;\n  border: none;\n  padding: 5px 10px;\n  border-radius: 4px;\n  cursor: pointer;\n  cursor: hand;\n  font-family: Arial;\n}\n\nbutton:hover {\n  background-color: #cfd8dc;\n}\n\nbutton.delete {\n  position: relative;\n  left: 194px;\n  top: -32px;\n  background-color: gray !important;\n  color: white;\n}\n\n\n\n</code-pane>\n</code-tabs>\n<a id=\"herodetailcomponent\"></a>\n<h4 id=\"herodetailcomponent\"><code>HeroDetailComponent</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#herodetailcomponent\"><i class=\"material-icons\">link</i></a></h4>\n<code-tabs>\n  <code-pane header=\"hero-detail/hero-detail.component.html\" path=\"toh-pt6/src/app/hero-detail/hero-detail.component.html\">\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero\">\n  &#x3C;h2>{{hero.name | <a href=\"api/common/UpperCasePipe\" class=\"code-anchor\">uppercase</a>}} Details&#x3C;/h2>\n  &#x3C;div>&#x3C;span>id: &#x3C;/span>{{hero.id}}&#x3C;/div>\n  &#x3C;div>\n    &#x3C;label>name:\n      &#x3C;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.name\" placeholder=\"name\"/>\n    &#x3C;/label>\n  &#x3C;/div>\n  &#x3C;button (click)=\"goBack()\">go back&#x3C;/button>\n  &#x3C;button (click)=\"save()\">save&#x3C;/button>\n&#x3C;/div>\n\n\n</code-pane>\n  <code-pane header=\"hero-detail/hero-detail.component.ts\" path=\"toh-pt6/src/app/hero-detail/hero-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\nimport { <a href=\"api/common/Location\" class=\"code-anchor\">Location</a> } from '@angular/common';\n\nimport { Hero } from '../hero';\nimport { HeroService } from '../hero.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-detail',\n  templateUrl: './hero-detail.component.html',\n  styleUrls: [ './hero-detail.component.css' ]\n})\nexport class HeroDetailComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  hero: Hero;\n\n  constructor(\n    private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>,\n    private heroService: HeroService,\n    private location: <a href=\"api/common/Location\" class=\"code-anchor\">Location</a>\n  ) {}\n\n  ngOnInit(): void {\n    this.getHero();\n  }\n\n  getHero(): void {\n    const id = +this.route.snapshot.paramMap.get('id');\n    this.heroService.getHero(id)\n      .subscribe(hero => this.hero = hero);\n  }\n\n  goBack(): void {\n    this.location.back();\n  }\n\n  save(): void {\n    this.heroService.updateHero(this.hero)\n      .subscribe(() => this.goBack());\n  }\n}\n\n\n</code-pane>\n</code-tabs>\n<a id=\"dashboardcomponent\"></a>\n<h4 id=\"dashboardcomponent\"><code>DashboardComponent</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#dashboardcomponent\"><i class=\"material-icons\">link</i></a></h4>\n<code-tabs>\n  <code-pane header=\"src/app/dashboard/dashboard.component.html\" path=\"toh-pt6/src/app/dashboard/dashboard.component.html\">\n&#x3C;h3>Top Heroes&#x3C;/h3>\n&#x3C;div class=\"grid grid-pad\">\n  &#x3C;a *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\" class=\"col-1-4\"\n      <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/detail/{{hero.id}}\">\n    &#x3C;div class=\"module hero\">\n      &#x3C;h4>{{hero.name}}&#x3C;/h4>\n    &#x3C;/div>\n  &#x3C;/a>\n&#x3C;/div>\n\n&#x3C;app-hero-search>&#x3C;/app-hero-search>\n\n\n</code-pane>\n</code-tabs>\n<a id=\"herosearchcomponent\"></a>\n<h4 id=\"herosearchcomponent\"><code>HeroSearchComponent</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#herosearchcomponent\"><i class=\"material-icons\">link</i></a></h4>\n<code-tabs>\n  <code-pane header=\"hero-search/hero-search.component.html\" path=\"toh-pt6/src/app/hero-search/hero-search.component.html\">\n&#x3C;div id=\"search-component\">\n  &#x3C;h4>&#x3C;label for=\"search-box\">Hero Search&#x3C;/label>&#x3C;/h4>\n\n  &#x3C;input #searchBox id=\"search-box\" (input)=\"search(searchBox.value)\" />\n\n  &#x3C;ul class=\"search-result\">\n    &#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes$ | async\" >\n      &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/detail/{{hero.id}}\">\n        {{hero.name}}\n      &#x3C;/a>\n    &#x3C;/li>\n  &#x3C;/ul>\n&#x3C;/div>\n\n\n</code-pane>\n  <code-pane header=\"hero-search/hero-search.component.ts\" path=\"toh-pt6/src/app/hero-search/hero-search.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\n\nimport { Observable, Subject } from 'rxjs';\n\nimport {\n   debounceTime, distinctUntilChanged, switchMap\n } from 'rxjs/operators';\n\nimport { Hero } from '../hero';\nimport { HeroService } from '../hero.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-search',\n  templateUrl: './hero-search.component.html',\n  styleUrls: [ './hero-search.component.css' ]\n})\nexport class HeroSearchComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  heroes$: Observable&#x3C;Hero[]>;\n  private searchTerms = new Subject&#x3C;string>();\n\n  constructor(private heroService: HeroService) {}\n\n  // 사용자가 입력한 검색어를 옵저버블 스트림으로 보냅니다.\n  search(term: string): void {\n    this.searchTerms.next(term);\n  }\n\n  ngOnInit(): void {\n    this.heroes$ = this.searchTerms.pipe(\n      // 연속된 키입력을 처리하기 위해 300ms 대기합니다.\n      debounceTime(300),\n\n      // 이전에 입력한 검색어와 같으면 무시합니다.\n      distinctUntilChanged(),\n\n      // 검색어가 변경되면 새로운 옵저버블을 생성합니다.\n      switchMap((term: string) => this.heroService.searchHeroes(term)),\n    );\n  }\n}\n\n\n</code-pane>\n  <code-pane header=\"hero-search/hero-search.component.css\" path=\"toh-pt6/src/app/hero-search/hero-search.component.css\">\n/* HeroSearch 컴포넌트에 적용되는 CSS 스타일 */\n.search-result li {\n  border-bottom: 1px solid gray;\n  border-left: 1px solid gray;\n  border-right: 1px solid gray;\n  width: 195px;\n  height: 16px;\n  padding: 5px;\n  background-color: white;\n  cursor: pointer;\n  list-style-type: none;\n}\n\n.search-result li:hover {\n  background-color: #607D8B;\n}\n\n.search-result li a {\n  color: #888;\n  display: block;\n  text-decoration: none;\n}\n\n.search-result li a:hover {\n  color: white;\n}\n.search-result li a:active {\n  color: white;\n}\n#search-box {\n  width: 200px;\n  height: 20px;\n}\n\n\nul.search-result {\n  margin-top: 0;\n  padding-left: 0;\n}\n\n\n</code-pane>\n</code-tabs>\n<!--\n## Summary\n-->\n<h2 id=\"정리\">정리<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#정리\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nYou're at the end of your journey, and you've accomplished a lot.\n* You added the necessary dependencies to use HTTP in the app.\n* You refactored `HeroService` to load heroes from a web API.\n* You extended `HeroService` to support `post()`, `put()`, and `delete()` methods.\n* You updated the components to allow adding, editing, and deleting of heroes.\n* You configured an in-memory web API.\n* You learned how to use observables.\n\nThis concludes the \"Tour of Heroes\" tutorial.\nYou're ready to learn more about Angular development in the fundamentals section,\nstarting with the [Architecture](guide/architecture \"Architecture\") guide.\n-->\n<p>이번 튜토리얼을 진행하면서 다음과 같은 내용에 대해 알아봤습니다.</p>\n<ul>\n<li>HTTP 요청을 보내는 방법에 대해 알아봤습니다. HTTP 요청은 꼭 필요한 경우에만 보내는 것이 좋습니다.</li>\n<li><code>HeroService</code>가 웹 API를 사용해서 히어로 데이터를 가져오도록 리팩토링했습니다.</li>\n<li><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>가 제공하는 <code>post()</code>, <code>put()</code>, <code>delete()</code> 메소드를 사용해서 <code>HeroService</code>를 확장했습니다.</li>\n<li>히어로를 추가하고, 수정하고, 제거할 수 있도록 컴포넌트를 수정했습니다.</li>\n<li>인-메모리 웹 API를 설정하는 방법에 대해 알아봤습니다.</li>\n<li>옵저버블을 사용하는 방법에 대해 알아봤습니다.</li>\n</ul>\n<p>\"히어로들의 여행\" 튜토리얼에서 다루는 내용은 여기까지입니다.\n이어지는 \"기초 지식\" 문서에서는 Angular를 개발할 때 필요한 내용을 자세하게 설명합니다.\n<a href=\"guide/architecture\" title=\"Architecture\">아키텍처</a> 내용부터 확인해 보세요.</p>\n\n</div>\n\n<!-- links to this doc:\n - tutorial/toh-pt4\n-->\n<!-- links from this doc:\n - api/common/AsyncPipe\n - api/common/DecimalPipe\n - api/common/Location\n - api/common/NgForOf\n - api/common/NgIf\n - api/common/UpperCasePipe\n - api/common/http\n - api/common/http/HttpClient\n - api/common/http/HttpClient#delete\n - api/common/http/HttpClient#get\n - api/common/http/HttpClient#put\n - api/common/http/HttpClientModule\n - api/common/http/HttpHeaders\n - api/core/Component\n - api/core/Injectable\n - api/core/NgModule\n - api/core/OnInit\n - api/forms/FormsModule\n - api/forms/NgModel\n - api/platform-browser/BrowserModule\n - api/router/ActivatedRoute\n - api/router/RouterLink\n - guide/architecture\n - tutorial/toh-pt6#asyncpipe\n - tutorial/toh-pt6#dashboardcomponent\n - tutorial/toh-pt6#handleerror\n - tutorial/toh-pt6#herodetailcomponent\n - tutorial/toh-pt6#heroescomponent\n - tutorial/toh-pt6#herosearchcomponent\n - tutorial/toh-pt6#herosearchcomponent-생성하기\n - tutorial/toh-pt6#herosearchcomponent-클래스-수정하기\n - tutorial/toh-pt6#heroservice-inmemorydataservice-appmodule\n - tutorial/toh-pt6#heroservicesearchheroes\n - tutorial/toh-pt6#heroserviceupdatehero-추가하기\n - tutorial/toh-pt6#http-서비스-추가하기\n - tutorial/toh-pt6#httpclient-로-히어로-목록-가져오기\n - tutorial/toh-pt6#httpclient-메소드는-데이터를-하나만-반환합니다\n - tutorial/toh-pt6#httpclientget-함수는-응답으로-받은-데이터를-반환합니다\n - tutorial/toh-pt6#id로-히어로-데이터-가져오기\n - tutorial/toh-pt6#import-heroes\n - tutorial/toh-pt6#observable-확인하기\n - tutorial/toh-pt6#rxjs-연산자-체이닝하기\n - tutorial/toh-pt6#search-pipe\n - tutorial/toh-pt6#searchterms-rxjs-subject\n - tutorial/toh-pt6#대시보드에-검색-기능-추가하기\n - tutorial/toh-pt6#데이터-서버-목킹하기\n - tutorial/toh-pt6#동작-확인하기\n - tutorial/toh-pt6#새-히어로-추가하기\n - tutorial/toh-pt6#서버에서-데이터-받아오기\n - tutorial/toh-pt6#에러-처리하기\n - tutorial/toh-pt6#이름으로-검색하기\n - tutorial/toh-pt6#정리\n - tutorial/toh-pt6#최종코드-리뷰\n - tutorial/toh-pt6#히어로-데이터-수정하기\n - tutorial/toh-pt6#히어로-데이터와-http\n - tutorial/toh-pt6#히어로-삭제하기\n - http://localhost:4800/tutorial/toh-pt6#heroes-and-http\n - http://www.learnrxjs.io/operators/transformation/switchmap.html\n - https://github.com/angular/angular/edit/master/aio/content/tutorial/toh-pt6.md?message=docs%3A%20describe%20your%20change...\n - https://github.com/angular/in-memory-web-api\n-->"
}