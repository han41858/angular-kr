{
  "id": "tutorial/toh-pt6",
  "title": "HTTP",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/tutorial/toh-pt6.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"http\">HTTP<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#http\"><i class=\"material-icons\">link</i></a></h1>\n<!--\nIn this tutorial, you'll add the following data persistence features with help from\nAngular's `HttpClient`.\n\n* The `HeroService` gets hero data with HTTP requests.\n* Users can add, edit, and delete heroes and save these changes over HTTP.\n* Users can search for heroes by name.\n\nWhen you're done with this page, the app should look like this <live-example></live-example>.\n-->\n<p>이번 튜토리얼에서는 Angular가 제공하는 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>를 사용해서 데이터를 처리하는 기능에 대해 알아봅니다.</p>\n<ul>\n<li><code>HeroService</code>가 히어로 데이터를 가져올 때 HTTP 요청을 통해 가져올 것입니다.</li>\n<li>사용자가 추가, 변경, 삭제한 히어로 데이터는 HTTP 요청을 보내서 서버에 저장할 것입니다.</li>\n<li>사용자가 히어로의 이름으로 검색할 수 있는 기능을 만들어 봅니다.</li>\n</ul>\n<p>이번 튜토리얼에서 만들 앱은 <live-example></live-example>에서 직접 확인하거나 다운받아 확인할 수 있습니다.</p>\n<!--\n## Enable HTTP services\n-->\n<h2 id=\"http-서비스-추가하기\">HTTP 서비스 추가하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#http-서비스-추가하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\n`HttpClient` is Angular's mechanism for communicating with a remote server over HTTP. \n\nTo make `HttpClient` available everywhere in the app:\n\n* open the root `AppModule` \n* import the `HttpClientModule` symbol from `@angular/common/http`\n-->\n<p><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>는 리모트 서버와 HTTP 통신을 하기 위해 Angular가 제공하는 서비스입니다.</p>\n<p>애플리케이션 전역 범위에서 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>를 사용하려면 다음과 같이 설정합니다:</p>\n<ul>\n<li>최상위 모듈인 <code>AppModule</code>을 엽니다.</li>\n<li><code>@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a></code> 패키지에서 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code> 심볼을 로드합니다.</li>\n</ul>\n<!--\n<code-example path=\"toh-pt6/src/app/app.module.ts\" region=\"import-http-client\" header=\"src/app/app.module.ts (Http Client import)\">\nimport { HttpClientModule }    from &#39;@angular/common/http&#39;;\n\n</code-example>\n-->\n<code-example path=\"toh-pt6/src/app/app.module.ts\" region=\"import-http-client\" header=\"src/app/app.module.ts (Http Client 로드하기)\">\nimport { <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a> }    from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\n</code-example>\n<!--\n* add it to the `@NgModule.imports` array\n-->\n<ul>\n<li>이 심볼을 <code>@<a href=\"api/core/NgModule#imports\" class=\"code-anchor\">NgModule.imports</a></code> 배열에 추가합니다.</li>\n</ul>\n<!--\n## Simulate a data server\n-->\n<h2 id=\"데이터-서버-목킹하기\">데이터 서버 목킹하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#데이터-서버-목킹하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThis tutorial sample _mimics_ communication with a remote data server by using the\n[_In-memory Web API_](https://github.com/angular/in-memory-web-api \"In-memory Web API\") module.\n\nAfter installing the module, the app will make requests to and receive responses from the `HttpClient`\nwithout knowing that the *In-memory Web API* is intercepting those requests,\napplying them to an in-memory data store, and returning simulated responses.\n\nThis facility is a great convenience for the tutorial.\nYou won't have to set up a server to learn about `HttpClient`.\n\nIt may also be convenient in the early stages of your own app development when\nthe server's web api is ill-defined or not yet implemented.\n-->\n<p>이 튜토리얼에서는 <a href=\"https://github.com/angular/in-memory-web-api\" title=\"In-memory Web API\"><em>인-메모리 Web API</em></a> 모듈을 사용해서 리모트 데이터 서버의 동작을 목킹하는 방식으로 진행합니다.</p>\n<p>이 모듈을 사용해도 애플리케이션이 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>를 사용해서 요청을 보내고 받는 것은 동일하지만, 이 요청은 <em>인-메모리 Web API</em>가 가로채서 실제 HTTP 요청을 보내지 않고 인-메모리 데이터 스토어로 처리합니다.</p>\n<p>이 모듈을 사용하면  실제 HTTP 요청으로 동작하는 서버를 준비하지 않아도 되기 때문에 이번 튜토리얼에 필요한 로직을 굉장히 편하게 구현할 수 있습니다.</p>\n<p>개발 초기에 서버가 준비되지 않았을 때에도 이런 방식을 사용할 수 있습니다.</p>\n<div class=\"alert is-important\">\n<!--\n**Important:** the *In-memory Web API* module has nothing to do with HTTP in Angular.\n\nIf you're just _reading_ this tutorial to learn about `HttpClient`, you can [skip over](#import-heroes) this step.\nIf you're _coding along_ with this tutorial, stay here and add the *In-memory Web API* now.\n-->\n<p><strong>중요:</strong> <em>인-메모리 Web API</em> 모듈은 사실 Angular가 제공하는 HTTP와 큰 관련이 없습니다.</p>\n<p>그래서 이 튜토리얼의 핵심 내용인 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>에 대해 알아보려면 이 단계를 건너뛰고 <a href=\"tutorial/toh-pt6#import-heroes\">여기로</a> 넘어가는 것이 좋습니다.\n이 튜토리얼을 단계별로 따라가면서 직접 <em>코딩하고 있는 경우에만</em> <em>인-메모리 Web API</em> 설정을 진행하세요.</p>\n</div>\n<!--\nInstall the *In-memory Web API* package from _npm_\n-->\n<p><em>npm</em> 으로 <em>인-메모리 웹 API</em> 패키지를 설치합니다.</p>\n<code-example language=\"sh\" class=\"code-shell\">\n  npm install angular-in-memory-web-api --save\n</code-example>\n<!--\nThe class `src/app/in-memory-data.service.ts` is generated by the following command:\n-->\n<p>그리고 다음 명령을 실행해서 <code>src/app/in-memory-data.service.ts</code> 파일을 생성합니다:</p>\n<code-example language=\"sh\" class=\"code-shell\">\n  ng generate service InMemoryData\n</code-example>\n<!--\nThis class has the following content:\n-->\n<p>이 클래스는 다음과 같은 내용으로 작성합니다:</p>\n<code-example path=\"toh-pt6/src/app/in-memory-data.service.ts\" region=\"init\" header=\"src/app/in-memory-data.service.ts\" linenums=\"false\">\nimport { InMemoryDbService } from 'angular-in-memory-web-api';\nimport { Hero } from './hero';\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class InMemoryDataService implements InMemoryDbService {\n  createDb() {\n    const heroes = [\n      { id: 11, name: 'Dr Nice' },\n      { id: 12, name: 'Narco' },\n      { id: 13, name: 'Bombasto' },\n      { id: 14, name: 'Celeritas' },\n      { id: 15, name: 'Magneta' },\n      { id: 16, name: 'RubberMan' },\n      { id: 17, name: 'Dynama' },\n      { id: 18, name: 'Dr IQ' },\n      { id: 19, name: 'Magma' },\n      { id: 20, name: 'Tornado' }\n    ];\n    return {heroes};\n  }\n\n  // 히어로 객체가 항상 id 프로퍼티를 갖도록 getId 메소드를 오버라이드 합니다.\n  // 히어로 목록이 비어있다면 이 메소드는 초기값(11)을 반환합니다.\n  // 히어로 목록이 비어있지 않으면 히어로 id의 최대값에 1을 더해서 반환합니다.\n  genId(heroes: Hero[]): number {\n    return heroes.length > 0 ? Math.max(...heroes.map(hero => hero.id)) + 1 : 11;\n  }\n}\n\n\n</code-example>\n<!--\nThis file replaces `mock-heroes.ts`, which is now safe to delete.\n\nWhen your server is ready, detach the *In-memory Web API*, and the app's requests will go through to the server.\n\nNow back to the `HttpClient` story.\n\nImport the `HttpClientInMemoryWebApiModule` and the `InMemoryDataService` class.\n-->\n<p>이제 <code>mock-heroes.ts</code> 파일은 사용하지 않기 때문에 삭제해도 됩니다.</p>\n<p>그리고 서버가 준비되면 <em>인-메모리 Web API</em> 를 제거해서 애플리케이션이 보내는 요청을 실제 서버로 전달하면 됩니다.</p>\n<p>다시 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>에 대해 알아봅시다.</p>\n<p><code>HttpClientInMemoryWebApiModule</code>과 <code>InMemoryDataService</code> 클래스를 로드합니다.</p>\n<!--\n<code-example path=\"toh-pt6/src/app/app.module.ts\" region=\"import-in-mem-stuff\" header=\"src/app/app.module.ts (In-memory Web API imports)\">\nimport { HttpClientInMemoryWebApiModule } from &#39;angular-in-memory-web-api&#39;;\nimport { InMemoryDataService }  from &#39;./in-memory-data.service&#39;;\n\n</code-example>\n-->\n<code-example path=\"toh-pt6/src/app/app.module.ts\" region=\"import-in-mem-stuff\" header=\"src/app/app.module.ts (In-memory Web API 로드하기)\">\nimport { HttpClientInMemoryWebApiModule } from 'angular-in-memory-web-api';\nimport { InMemoryDataService }  from './in-memory-data.service';\n\n</code-example>\n<!--\nAdd the `HttpClientInMemoryWebApiModule` to the `@NgModule.imports` array&mdash;\n_after importing the `HttpClientModule`_,\n&mdash;while configuring it with the `InMemoryDataService`.\n-->\n<p>그 다음에는 <code>@<a href=\"api/core/NgModule#imports\" class=\"code-anchor\">NgModule.imports</a></code> 배열의 <em><code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code> 뒤에</em> <code>HttpClientInMemoryWebApiModule</code>을 추가합니다.\n이 때 <code>InMemoryDataService</code>를 인자로 전달합니다.</p>\n<code-example path=\"toh-pt6/src/app/app.module.ts\" region=\"in-mem-web-api-imports\">\n<a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n\n// HttpClientInMemoryWebApiModule 모듈은 HTTP 요청을 가로채고 서버의 응답을 흉내냅니다.\n// 실제 서버가 준비되면 이 부분을 제거하면 됩니다.\nHttpClientInMemoryWebApiModule.forRoot(\n  InMemoryDataService, { dataEncapsulation: false }\n)\n\n</code-example>\n<!--\nThe `forRoot()` configuration method takes an `InMemoryDataService` class\nthat primes the in-memory database.\n-->\n<p>라우터 동작 환경을 설정하는 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">forRoot()</a></code> 메소드는 <code>InMemoryDataService</code> 클래스를 인자로 받아서 인메모리 데이터베이스를 구성합니다.</p>\n<a id=\"import-heroes\"></a>\n<!--\n## Heroes and HTTP\n-->\n<h2 id=\"히어로-데이터와-http\">히어로 데이터와 HTTP<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#히어로-데이터와-http\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nImport some HTTP symbols that you'll need:\n-->\n<p>먼저 HTTP 요청을 보낼 때 필요한 심볼을 로드합니다:</p>\n<!--\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"import-httpclient\" header=\"src/app/hero.service.ts (import HTTP symbols)\">\nimport { HttpClient, HttpHeaders } from &#39;@angular/common/http&#39;;\n\n</code-example>\n-->\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"import-httpclient\" header=\"src/app/hero.service.ts (HTTP 심볼 로드하기)\">\nimport { <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>, <a href=\"api/common/http/HttpHeaders\" class=\"code-anchor\">HttpHeaders</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\n</code-example>\n<!--\nInject `HttpClient` into the constructor in a private property called `http`.\n-->\n<p><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>는 <code>HeroService</code>의 생성자에 의존성으로 주입하는데, 의존성으로 주입하는 동시에 이 인스턴스를 <code>private <a href=\"api/common/http\" class=\"code-anchor\">http</a></code> 프로퍼티에 할당합니다.</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"ctor\">\nconstructor(\n  private <a href=\"api/common/http\" class=\"code-anchor\">http</a>: <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>,\n  private messageService: MessageService) { }\n\n</code-example>\n<!--\nKeep injecting the `MessageService`. You'll call it so frequently that\nyou'll wrap it in a private `log()` method.\n-->\n<p><code>HeroService</code>에는 <code>MessageService</code>도 주입합니다.\n이 때 <code>MessageService.add()</code> 메소드는 <code>HeroService</code> 안에서 자주 사용하기 때문에 private <code><a href=\"api/animations/browser/testing/MockAnimationDriver#log\" class=\"code-anchor\">log</a>()</code> 메소드로 한 번 랩핑합니다.</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"log\">\n/** HeroService에서 보내는 메시지는 MessageService가 화면에 표시합니다. */\nprivate <a href=\"api/animations/browser/testing/MockAnimationDriver#log\" class=\"code-anchor\">log</a>(<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>: string) {\n  this.messageService.add(`HeroService: ${<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>}`);\n}\n\n</code-example>\n<!--\nDefine the `heroesUrl` of the form `:base/:collectionName` with the address of the heroes resource on the server.\n Here `base` is the resource to which requests are made,\n and `collectionName` is the heroes data object in the `in-memory-data-service.ts`.\n-->\n<p>서버에 요청할 <code>heroesUrl</code>을 <code>:base/:collectionName</code>과 같이 정의합니다.\n이 문자열에서 <code>base</code>는 요청으로 보내는 주소의 기본 위치를 의미하며, <code>collectionName</code>은 <code>in-memory-data-service.ts</code>에 있는 히어로 데이터가 저장되는 위치를 가리킵니다.</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"heroesUrl\">\nprivate heroesUrl = 'api/heroes';  // 웹 API 형식의 <a href=\"api/core/SecurityContext#URL\" class=\"code-anchor\">URL</a>로 사용\n\n</code-example>\n<!--\n### Get heroes with _HttpClient_\n-->\n<h3 id=\"httpclient-로-히어로-목록-가져오기\"><em>HttpClient</em> 로 히어로 목록 가져오기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#httpclient-로-히어로-목록-가져오기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe current `HeroService.getHeroes()` \nuses the RxJS `of()` function to return an array of mock heroes\nas an `Observable<Hero[]>`.\n-->\n<p>지금까지 작성한 <code>HeroService.getHeroes()</code> 함수는 RxJS <code>of()</code> 함수를 사용해서 <code>Observable&#x3C;Hero[]></code> 타입으로 목 히어로 데이터를 반환합니다.</p>\n<!--\n<code-example path=\"toh-pt4/src/app/hero.service.ts\" region=\"getHeroes-1\" header=\"src/app/hero.service.ts (getHeroes with RxJs 'of()')\">\ngetHeroes(): Observable&lt;Hero[]&gt; {\n  return of(HEROES);\n}\n\n</code-example>\n-->\n<code-example path=\"toh-pt4/src/app/hero.service.ts\" region=\"getHeroes-1\" header=\"src/app/hero.service.ts (RxJS &#x27;of()&#x27;를 사용하는 getHeroes)\">\ngetHeroes(): Observable&#x3C;Hero[]> {\n  return of(HEROES);\n}\n\n</code-example>\n<!--\nConvert that method to use `HttpClient`\n-->\n<p>이 함수가 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>를 사용하도록 변경합니다.</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"getHeroes-1\">\n/** GET: 서버에서 히어로 목록 가져오기 */\ngetHeroes (): Observable&#x3C;Hero[]> {\n  return this.http.get&#x3C;Hero[]>(this.heroesUrl)\n}\n\n</code-example>\n<!--\nRefresh the browser. The hero data should successfully load from the\nmock server.\n\nYou've swapped `of` for `http.get` and the app keeps working without any other changes\nbecause both functions return an `Observable<Hero[]>`.\n-->\n<p>브라우저가 갱신되면 이제 히어로 데이터는 목 서버에서 받아옵니다.</p>\n<p><code>of</code> 함수를 <code>http.get</code>으로 변경했지만 이 서비스 외의 다른 부분은 변경하지 않아도 됩니다.\n두 함수는 모두 <code>Observable&#x3C;Hero[]></code> 타입을 반환합니다.</p>\n<!--\n### Http methods return one value\n-->\n<h3 id=\"http-메소드는-데이터를-하나만-반환합니다\">Http 메소드는 데이터를 하나만 반환합니다.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#http-메소드는-데이터를-하나만-반환합니다\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAll `HttpClient` methods return an RxJS `Observable` of something.\n\nHTTP is a request/response protocol. \nYou make a request, it returns a single response.\n\nIn general, an observable _can_ return multiple values over time.\nAn observable from `HttpClient` always emits a single value and then completes, never to emit again.\n\nThis particular `HttpClient.get` call returns an `Observable<Hero[]>`, literally \"_an observable of hero arrays_\". In practice, it will only return a single hero array.\n-->\n<p><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>가 제공하는 모든 메소드는 RxJS <code>Observable</code> 타입으로 무언가를 반환합니다.</p>\n<p>HTTP는 요청을 보내고 응답을 받는 프로토콜입니다.\n이 때 요청이 한 번 있었다면 응답도 한 번입니다.</p>\n<p>일반적으로 옵저버블은 여러 번에 걸쳐 데이터를 여러개 반환합니다.\n하지만 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>가 반환하는 옵저버블은 데이터를 하나만 반환하고 종료되며, 데이터를 추가로 보내지 않습니다.</p>\n<p>그래서 <code>HttpClient.get</code> 함수는 히어로 데이터를 배열로 묶어서 <code>Observable&#x3C;Hero[]></code> 타입으로 반환합니다.</p>\n<!--\n### _HttpClient.get_ returns response data\n-->\n<h3 id=\"httpclientget-함수는-응답으로-받은-데이터를-반환합니다\"><em>HttpClient.get</em> 함수는 응답으로 받은 데이터를 반환합니다.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#httpclientget-함수는-응답으로-받은-데이터를-반환합니다\"><i class=\"material-icons\">link</i></a></h3>\n<!--\n`HttpClient.get` returns the _body_ of the response as an untyped JSON object by default.\nApplying the optional type specifier, `<Hero[]>` , gives you a typed result object.\n\nThe shape of the JSON data is determined by the server's data API.\nThe _Tour of Heroes_ data API returns the hero data as an array.\n-->\n<p><code>HttpClient.get</code> 함수는 HTTP 응답으로 받은 <em>몸체(body)</em> 를 반환하는데, 이 객체는 타입이 지정되지 않은 JSON 객체로 처리됩니다.\n그래서 이 객체에 타입을 지정하려면 <code>&#x3C;Hero[]></code>와 같이 제네릭을 지정하면 됩니다.</p>\n<p>JSON 데이터의 형식은 서버에 정의된 데이터 API에 따라 달라집니다.\n<em>히어로들의 여행</em> 에서 사용하는 데이터 API는 모두 히어로 데이터를 배열로 반환합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nOther APIs may bury the data that you want within an object.\nYou might have to dig that data out by processing the `Observable` result\nwith the RxJS `map` operator.\n\nAlthough not discussed here, there's an example of `map` in the `getHeroNo404()`\nmethod included in the sample source code.\n-->\n<p>데이터는 HTTP 응답으로 받은 객체 안에 깊숙히 들어있을 수도 있습니다.\n이런 경우에는 원하는 데이터를 추출하기 위해 RxJS <code>map</code> 연산자를 사용해야 합니다.</p>\n<p>이 내용은 이 문서에서 다루지 않지만 예제 코드에 구현된 <code>getHeroNo404()</code> 메소드를 보면 <code>map</code> 연산자를 사용하는 코드를 확인할 수 있습니다.</p>\n</div>\n<!--\n### Error handling\n-->\n<h3 id=\"에러-처리하기\">에러 처리하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#에러-처리하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThings go wrong, especially when you're getting data from a remote server.\nThe `HeroService.getHeroes()` method should catch errors and do something appropriate.\n\nTo catch errors, you **\"pipe\" the observable** result from `http.get()` through an RxJS `catchError()` operator.\n\nImport the `catchError` symbol from `rxjs/operators`, along with some other operators you'll need later.\n-->\n<p>리모트 서버에서 데이터를 가져오는 과정은 얼마든지 잘못될 수 있습니다.\n그래서 <code>HeroService.getHeroes()</code> 메소드에는 에러가 발생했을 때 처리하는 로직이 필요합니다.</p>\n<p>에러를 처리하려면 <code>http.get()</code>으로 받은 옵저버블에 <strong>\"pipe\"를 사용해서</strong> <code>catchError()</code> 연산자를 연결하면 됩니다.</p>\n<p><code>rxjs/operators</code>에서 <code>catchError</code> 심볼을 로드합니다.\n이 때 앞으로 사용할 연산자 몇 개도 함께 로드했습니다.</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"import-rxjs-operators\">\nimport { catchError, map, tap } from 'rxjs/operators';\n\n</code-example>\n<!--\nNow extend the observable result with the `.pipe()` method and\ngive it a `catchError()` operator.\n-->\n<p>이제 옵저버블로 받은 데이터를 <code>.pipe()</code> 메소드로 확장하고 이 파이프에 <code>catchError()</code> 연산자를 연결합니다.</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"getHeroes-2\">\ngetHeroes (): Observable&#x3C;Hero[]> {\n  return this.http.get&#x3C;Hero[]>(this.heroesUrl)\n    .pipe(\n      catchError(this.handleError&#x3C;Hero[]>('getHeroes', []))\n    );\n}\n\n</code-example>\n<!--\nThe `catchError()` operator intercepts an **`Observable` that failed**.\nIt passes the error an _error handler_ that can do what it wants with the error.\n\nThe following `handleError()` method reports the error and then returns an\ninnocuous result so that the application keeps working.\n-->\n<p><code>catchError()</code> 연산자는 <strong><code>Observable</code>이 실패했을 때</strong> 실행되는 연산자입니다.\n이 연산자에는 에러가 발생했을 때 실행할 <em>에러 핸들러 함수</em> 를 인자로 전달합니다.</p>\n<p>다음 섹션에서 구현할 <code><a href=\"api/core/ErrorHandler#handleError\" class=\"code-anchor\">handleError()</a></code> 메소드는 에러를 콘솔에 출력한 뒤에 빈 배열을 반환합니다.\n그래서 서버에 보낸 요청이 실패하는 에러가 발생하더라도 애플리케이션은 계속 동작할 수 있습니다.</p>\n<h4 id=\"handleerror\"><em>handleError</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#handleerror\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe following `handleError()` will be shared by many `HeroService` methods\nso it's generalized to meet their different needs.\n\nInstead of handling the error directly, it returns an _error handler_ function to `catchError` that it \nhas configured with both the name of the operation that failed and a safe return value.\n-->\n<p>이제부터 구현할 <code><a href=\"api/core/ErrorHandler#handleError\" class=\"code-anchor\">handleError()</a></code> 메소드는 <code>HeroService</code> 안에 있는 메소드들이 모두 사용하기 때문에 일반적인 로직으로 구현해야 합니다.</p>\n<p>그래서 에러가 발생했을 때 이 에러를 바로 처리하지 않고, <em>에러 핸들러</em> 함수를 정의해서 이 함수를 <code>catchError</code> 연산자로 연결하는 방식으로 구현합니다.\n그러면 오류가 발생해도 오류가 발생하지 않았을 때와 동일한 로직 흐름을 유지할 수 있습니다.</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"handleError\">\n/**\n * HTTP 요청이 실패한 경우를 처리합니다.\n * 애플리케이션 로직 흐름은 그대로 유지됩니다.\n * @param operation - 실패한 동작의 이름\n * @param result - 기본값으로 반환할 객체\n */\nprivate handleError&#x3C;T> (operation = 'operation', result?: T) {\n  return (error: any): Observable&#x3C;T> => {\n\n    // TODO: 리모트 서버로 에러 메시지 보내기\n    console.error(error); // 지금은 콘솔에 로그를 출력합니다.\n\n    // TODO: 사용자가 이해할 수 있는 형태로 변환하기\n    this.log(`${operation} failed: ${error.message}`);\n\n    // 애플리케이션 로직이 끊기지 않도록 기본값으로 받은 객체를 반환합니다.\n    return of(result as T);\n  };\n}\n\n</code-example>\n<!--\nAfter reporting the error to console, the handler constructs\na user friendly message and returns a safe value to the app so it can keep working.\n\nBecause each service method returns a different kind of `Observable` result,\n`handleError()` takes a type parameter so it can return the safe value as the type that the app expects.\n-->\n<p>에러 핸들러 함수는 사용자가 이해하기 쉬운 형태로 에러를 콘솔에 출력하고 나면 애플리케이션 로직 흐름을 유지하기 위해 기본값을 반환합니다.</p>\n<p>이 때 <code>HeroService</code>에 정의된 메소드마다 반환하는 <code>Observable</code> 결과물의 타입이 다르기 때문에 메소드가 반환하는 기본값은 <code><a href=\"api/core/ErrorHandler#handleError\" class=\"code-anchor\">handleError()</a></code>를 실행할 때 전달하며 타입도 제네릭으로 지정했습니다.</p>\n<!--\n### Tap into the _Observable_\n-->\n<h3 id=\"observable-확인하기\"><em>Observable</em> 확인하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#observable-확인하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe `HeroService` methods will **tap** into the flow of observable values\nand send a message (via `log()`) to the message area at the bottom of the page.\n\nThey'll do that with the RxJS `tap` operator,\nwhich _looks_ at the observable values, does _something_ with those values,\nand passes them along.\nThe `tap` call back doesn't touch the values themselves.\n\nHere is the final version of `getHeroes` with the `tap` that logs the operation.\n-->\n<p><code>HeroService</code>에 정의하는 메소드는 옵저버블 데이터를 살짝 참조해서(<code>tap</code>) <code><a href=\"api/animations/browser/testing/MockAnimationDriver#log\" class=\"code-anchor\">log</a>()</code> 함수로 메시지를 화면에 출력합니다.</p>\n<p>옵저버블 데이터를 <em>확인하려면</em> RxJS가 제공하는 <code>tap</code> 연산자를 사용하면 됩니다.\n이 연산자는 옵저버블 데이터를 사용해서 <em>어떤 동작을 수행</em> 하는데, 옵저버블 데이터는 변경하지 않고 그대로 전달합니다.</p>\n<p><code>getHeroes</code> 메소드에 <code>tap</code>을 활용하는 로직을 넣으면  다음과 같이 구현할 수 있습니다.</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"getHeroes\">\n/** GET: 서버에서 히어로 목록 가져오기 */\ngetHeroes (): Observable&#x3C;Hero[]> {\n  return this.http.get&#x3C;Hero[]>(this.heroesUrl)\n    .pipe(\n      tap(<a href=\"\" class=\"code-anchor\">_</a> => this.log('fetched heroes')),\n      catchError(this.handleError&#x3C;Hero[]>('getHeroes', []))\n    );\n}\n\n</code-example>\n<!--\n### Get hero by id\n-->\n<h3 id=\"id로-히어로-데이터-가져오기\">id로 히어로 데이터 가져오기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#id로-히어로-데이터-가져오기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nMost web APIs support a _get by id_ request in the form `:baseURL/:id`.\n\nHere, the _base URL_ is the `heroesURL` defined in the [Heroes and HTTP](tutorial/toh-pt6#heroes-and-http) section (`api/heroes`) and _id_ is\nthe number of the hero that you want to retrieve. For example, `api/heroes/11`.\n\nAdd a `HeroService.getHero()` method to make that request:\n-->\n<p>일반적으로 웹 API는 <em>id로 데이터를 검색하는 기능을</em> <code>:baseURL/:id</code>와 같은 방식으로 제공합니다.</p>\n<p>이번에는 <a href=\"http://localhost:4800/tutorial/toh-pt6#heroes-and-http\">히어로 데이터와 HTTP</a> 섹션에서 정의한 <code>heroesURL</code>에 <em>기본 URL</em> 과 히어로 id에 해당하는 숫자를 사용해서 <code>api/heroes/11</code>라는 주소로 히어로 데이터를 요청해 봅시다.</p>\n<p><code>HeroService.getHero()</code> 메소드를 다음과 같이 구현합니다:</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"getHero\" header=\"src/app/hero.service.ts\">\n/** GET: id에 해당하는 히어로 데이터 가져오기. 존재하지 않으면 404를 반환합니다. */\ngetHero(id: number): Observable&#x3C;Hero> {\n  const url = `${this.heroesUrl}/${id}`;\n  return this.http.get&#x3C;Hero>(url).pipe(\n    tap(<a href=\"\" class=\"code-anchor\">_</a> => this.log(`fetched hero id=${id}`)),\n    catchError(this.handleError&#x3C;Hero>(`getHero id=${id}`))\n  );\n}\n\n</code-example>\n<!--\nThere are three significant differences from  `getHeroes()`.\n\n* it constructs a request URL with the desired hero's id.\n* the server should respond with a single hero rather than an array of heroes.\n* therefore, `getHero` returns an `Observable<Hero>` (\"_an observable of Hero objects_\")\n rather than an observable of hero _arrays_ .\n-->\n<p>이 메소드는 <code>getHeroes</code>와 다른 점이 몇가지 있습니다.</p>\n<ul>\n<li>인자로 받은 히어로 id로 URL을 구성합니다.</li>\n<li>서버가 반환하는 응답은 배열 형태의 히어로 목록이 아니라 히어로 한 명의 데이터입니다.</li>\n<li>그래서 <code>getHero</code>가 반환하는 결과물은 <code>Observable&#x3C;Hero></code> 타입으로 \"<em>히어로 객체를 표현하는 옵저버블</em>\" 입니다. 배열이 아닙니다.</li>\n</ul>\n<!--\n## Update heroes\n-->\n<h2 id=\"히어로-데이터-수정하기\">히어로 데이터 수정하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#히어로-데이터-수정하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nEdit a hero's name in the _hero detail_ view.\nAs you type, the hero name updates the heading at the top of the page.\nBut when you click the \"go back button\", the changes are lost.\n\nIf you want changes to persist, you must write them back to\nthe server.\n\nAt the end of the hero detail template, add a save button with a `click` event\nbinding that invokes a new component method named `save()`.\n-->\n<p><em>히어로 상세정보</em> 화면에서는 히어로의 이름을 수정할 수 있습니다.\n그런데 사용자가 히어로의 이름을 입력하면 이 내용이 페이지 위쪽에 표시되지만 \"뒤로 가기 버튼\"을 누르면 변경된 내용이 폐기됩니다.</p>\n<p>히어로의 이름을 영구적으로 저장하려면 사용자가 입력한 내용을 서버로 보내서 저장해야 합니다.</p>\n<p>히어로 상세정보 화면을 정의하는 템플릿 제일 아래에 저장 버튼을 추가하고 이 버튼에 <code>click</code> 이벤트를 바인딩해 봅시다. 이 이벤트는 컴포넌트 클래스의 <code>save()</code> 메소드로 연결할 것입니다.</p>\n<!--\n<code-example path=\"toh-pt6/src/app/hero-detail/hero-detail.component.html\" region=\"save\" header=\"src/app/hero-detail/hero-detail.component.html (save)\">\n&lt;button (click)=&quot;save()&quot;&gt;save&lt;/button&gt;\n\n</code-example>\n-->\n<code-example path=\"toh-pt6/src/app/hero-detail/hero-detail.component.html\" region=\"save\" header=\"src/app/hero-detail/hero-detail.component.html (저장하기e)\">\n&#x3C;button (click)=\"save()\">save&#x3C;/button>\n\n</code-example>\n<!--\nAdd the following `save()` method, which persists hero name changes using the hero service\n`updateHero()` method and then navigates back to the previous view.\n-->\n<p>그리고 아래 내용으로 <code>save()</code> 메소드를 구현합니다. 이 메소드는 <code>HeroService.updateHero()</code> 메소드를 실행해서 변경된 내용을 저장하고 이전 화면으로 돌아가는 동작을 합니다.</p>\n<!--\n<code-example path=\"toh-pt6/src/app/hero-detail/hero-detail.component.ts\" region=\"save\" header=\"src/app/hero-detail/hero-detail.component.ts (save)\">\nsave(): void {\n   this.heroService.updateHero(this.hero)\n     .subscribe(() =&gt; this.goBack());\n }\n\n</code-example>\n-->\n<code-example path=\"toh-pt6/src/app/hero-detail/hero-detail.component.ts\" region=\"save\" header=\"src/app/hero-detail/hero-detail.component.ts (저장하기)\">\nsave(): void {\n   this.heroService.updateHero(this.hero)\n     .subscribe(() => this.goBack());\n }\n\n</code-example>\n<!--\n#### Add _HeroService.updateHero()_\n-->\n<h4 id=\"heroserviceupdatehero-추가하기\"><em>HeroService.updateHero()</em> 추가하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#heroserviceupdatehero-추가하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nThe overall structure of the `updateHero()` method is similar to that of\n`getHeroes()`, but it uses `http.put()` to persist the changed hero\non the server.\n-->\n<p><code>updateHero()</code> 메소드는 <code>getHeroes()</code> 메소드와 거의 비슷합니다. 대신 <code>updateHero()</code> 메소드는 <code>http.get()</code>이 아니라 <code>http.put()</code> 함수를 사용합니다.</p>\n<!--\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"updateHero\" header=\"src/app/hero.service.ts (update)\">\n/** PUT: 서버에 저장된 히어로 데이터를 변경합니다. */\nupdateHero (hero: Hero): Observable&lt;any&gt; {\n  return this.http.put(this.heroesUrl, hero, httpOptions).pipe(\n    tap(_ =&gt; this.log(`updated hero id=${hero.id}`)),\n    catchError(this.handleError&lt;any&gt;(&#39;updateHero&#39;))\n  );\n}\n\n</code-example>\n-->\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"updateHero\" header=\"src/app/hero.service.ts (수정하기)\">\n/** PUT: 서버에 저장된 히어로 데이터를 변경합니다. */\nupdateHero (hero: Hero): Observable&#x3C;any> {\n  return this.http.put(this.heroesUrl, hero, httpOptions).pipe(\n    tap(<a href=\"\" class=\"code-anchor\">_</a> => this.log(`updated hero id=${hero.id}`)),\n    catchError(this.handleError&#x3C;any>('updateHero'))\n  );\n}\n\n</code-example>\n<!--\nThe `HttpClient.put()` method takes three parameters\n* the URL\n* the data to update (the modified hero in this case)\n* options\n\nThe URL is unchanged. The heroes web API knows which hero to update by looking at the hero's `id`.\n\nThe heroes web API expects a special header in HTTP save requests.\nThat header is in the `httpOptions` constant defined in the `HeroService`.\n-->\n<p><code><a href=\"api/common/http/HttpClient#put\" class=\"code-anchor\">HttpClient.put()</a></code> 메소드는 3개의 인자를 받습니다.</p>\n<ul>\n<li>URL</li>\n<li>수정할 데이터 (수정된 히어로 데이터)</li>\n<li>옵션</li>\n</ul>\n<p>URL은 변경되지 않았습니다. 이 예제에 정의한 웹 API는 히어로의 <code>id</code>를 기준으로 수정할 히어로를 찾습니다.</p>\n<p>이번 예제에서 사용하는 웹 API에는 헤더가 존재합니다. 히어로 데이터가 JSON 타입으로 전달된다는 것을 지정하기 위해 다음과 같이 <code>httpOptions</code> 상수를 선언합니다.</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"http-options\" header=\"src/app/hero.service.ts\">\nconst httpOptions = {\n  headers: new <a href=\"api/common/http/HttpHeaders\" class=\"code-anchor\">HttpHeaders</a>({ 'Content-Type': 'application/json' })\n};\n\n</code-example>\n<!--\nRefresh the browser, change a hero name and save your change. Navigating to the previous view is implemented in the `save()` method defined in `HeroDetailComponent`.\nThe hero now appears in the list with the changed name.\n-->\n<p>이제 브라우저가 갱신된 후에 히어로의 이름을 변경하고 저장해보세요.\n그러면 <code>HeroDetailComponent</code>에 정의한 대로 이전 페이지로 돌아가는데, 전환된 화면에는 변경된 내용이 반영되어 표시될 것입니다.</p>\n<!--\n## Add a new hero\n-->\n<h2 id=\"새-히어로-추가하기\">새 히어로 추가하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#새-히어로-추가하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nTo add a hero, this app only needs the hero's name. You can use an `input`\nelement paired with an add button.\n\nInsert the following into the `HeroesComponent` template, just after\nthe heading:\n-->\n<p>이 문서에서 만들고 있는 앱은 히어로를 추가할 때 이름만 있으면 됩니다.\n화면에 <code>input</code> 엘리먼트 하나와 버튼 하나만 추가해 봅시다.</p>\n<p><code>HeroesComponent</code> 템플릿에 아래 내용을 추가합니다:</p>\n<!--\n<code-example path=\"toh-pt6/src/app/heroes/heroes.component.html\" region=\"add\" header=\"src/app/heroes/heroes.component.html (add)\">\n&lt;div&gt;\n  &lt;label&gt;Hero name:\n    &lt;input #heroName /&gt;\n  &lt;/label&gt;\n  &lt;!-- (click) 이벤트를 감지하면 현재값을 인자로 전달하면서 add() 함수를 실행하고, 입력 필드를 비웁니다. --&gt;\n  &lt;button (click)=&quot;add(heroName.value); heroName.value=&#39;&#39;&quot;&gt;\n    add\n  &lt;/button&gt;\n&lt;/div&gt;\n\n</code-example>\n-->\n<code-example path=\"toh-pt6/src/app/heroes/heroes.component.html\" region=\"add\" header=\"src/app/heroes/heroes.component.html (추가하기)\">\n&#x3C;div>\n  &#x3C;label>Hero name:\n    &#x3C;input #heroName />\n  &#x3C;/label>\n  &#x3C;!-- (click) 이벤트를 감지하면 현재값을 인자로 전달하면서 add() 함수를 실행하고, 입력 필드를 비웁니다. -->\n  &#x3C;button (click)=\"add(heroName.value); heroName.value=''\">\n    add\n  &#x3C;/button>\n&#x3C;/div>\n\n</code-example>\n<!--\nIn response to a click event, call the component's click handler and then\nclear the input field so that it's ready for another name.\n-->\n<p>이제 클릭 이벤트가 발생하면 컴포넌트에 정의된 클릭 핸들러가 실행되고, 다른 히어로의 이름을 입력받기 위해 입력 필드의 내용이 비워집니다.</p>\n<!--\n<code-example path=\"toh-pt6/src/app/heroes/heroes.component.ts\" region=\"add\" header=\"src/app/heroes/heroes.component.ts (add)\">\nadd(name: string): void {\n  name = name.trim();\n  if (!name) { return; }\n  this.heroService.addHero({ name } as Hero)\n    .subscribe(hero =&gt; {\n      this.heroes.push(hero);\n    });\n}\n\n</code-example>\n-->\n<code-example path=\"toh-pt6/src/app/heroes/heroes.component.ts\" region=\"add\" header=\"src/app/heroes/heroes.component.ts (추가하기)\">\nadd(name: string): void {\n  name = name.trim();\n  if (!name) { return; }\n  this.heroService.addHero({ name } as Hero)\n    .subscribe(hero => {\n      this.heroes.push(hero);\n    });\n}\n\n</code-example>\n<!--\nWhen the given name is non-blank, the handler creates a `Hero`-like object\nfrom the name (it's only missing the `id`) and passes it to the services `addHero()` method.\n\nWhen `addHero` saves successfully, the `subscribe` callback\nreceives the new hero and pushes it into to the `heroes` list for display.\n\nYou'll write `HeroService.addHero` in the next section.\n-->\n<p>인자로 받은 이름이 빈 문자열이 아니라면 이 이름을 <code>Hero</code> 타입으로 처리할 수 있는 객체로 변환합니다.\n그리고 이렇게 만든 객체를 <code>HeroService.addHero()</code> 메소드로 전달합니다.</p>\n<p>서비스의 <code>addHero</code> 메소드가 정상적으로 실행되고 나면 <code>subscribe</code> 콜백 함수가 실행됩니다.\n새로 받아온 히어로는 <code>heroes</code> 배열에 추가되어 화면에 표시될 것입니다.</p>\n<p><code>HeroService.addHero()</code> 함수는 다음 섹션에서 구현합니다.</p>\n<!--\n#### Add _HeroService.addHero()_\n-->\n<h4 id=\"heroserviceaddhero-추가하기\"><em>HeroService.addHero()</em> 추가하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#heroserviceaddhero-추가하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nAdd the following `addHero()` method to the `HeroService` class.\n-->\n<p><code>HeroService</code> 클래스에 아래 내용으로 <code>addHero()</code> 메소드를 추가합니다.</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"addHero\" header=\"src/app/hero.service.ts (addHero)\">\n/** POST: 서버에 새로운 히어로를 추가합니다. */\naddHero (hero: Hero): Observable&#x3C;Hero> {\n  return this.http.post&#x3C;Hero>(this.heroesUrl, hero, httpOptions).pipe(\n    tap((newHero: Hero) => this.log(`added hero w/ id=${newHero.id}`)),\n    catchError(this.handleError&#x3C;Hero>('addHero'))\n  );\n}\n\n</code-example>\n<!--\n`HeroService.addHero()` differs from `updateHero` in two ways.\n\n* it calls `HttpClient.post()` instead of `put()`.\n* it expects the server to generate an id for the new hero, \nwhich it returns in the `Observable<Hero>` to the caller.\n\nRefresh the browser and add some heroes.\n-->\n<p><code>HeroService.addHero()</code> 메소드는 <code>updateHero</code>와 다른 점이 두 개 있습니다.</p>\n<ul>\n<li><code><a href=\"api/common/http/HttpClient#post\" class=\"code-anchor\">HttpClient.post()</a></code> 대신 <code><a href=\"api/common/http/HttpClient#put\" class=\"code-anchor\">put()</a></code> 메소드를 사용합니다.</li>\n<li>서버의 응답으로 받은 데이터에는 히어로의 id가 포함되어 있습니다. 이 객체는 이 메소드를 실행한 함수에 <code>Observable&#x3C;Hero></code> 타입으로 반환합니다.</li>\n</ul>\n<p>브라우저를 갱신하고 히어로를 추가해 보세요.</p>\n<!--\n## Delete a hero\n-->\n<h2 id=\"히어로-제거하기\">히어로 제거하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#히어로-제거하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nEach hero in the heroes list should have a delete button.\n\nAdd the following button element to the `HeroesComponent` template, after the hero\nname in the repeated `<li>` element.\n-->\n<p>히어로 목록에 있는 각 항목에는 제거 버튼이 있어야 합니다.</p>\n<p>그래서 <code>HeroesComponent</code> 템플릿의 <code>&#x3C;li></code> 엘리먼트로 반복되는 히어로 이름 뒤에 다음과 같은 버튼 엘리먼트를 추가합니다.</p>\n<code-example path=\"toh-pt6/src/app/heroes/heroes.component.html\" region=\"delete\">\n&#x3C;button class=\"delete\" title=\"delete hero\"\n  (click)=\"delete(hero)\">x&#x3C;/button>\n\n</code-example>\n<!--\nThe HTML for the list of heroes should look like this:\n-->\n<p>그러면 히어로 목록을 표시하는 템플릿이 다음과 같이 구성될 것입니다:</p>\n<!--\n<code-example path=\"toh-pt6/src/app/heroes/heroes.component.html\" region=\"list\" header=\"src/app/heroes/heroes.component.html (list of heroes)\">\n&lt;ul class=&quot;heroes&quot;&gt;\n  &lt;li *ngFor=&quot;let hero of heroes&quot;&gt;\n    &lt;a routerLink=&quot;/detail/{{hero.id}}&quot;&gt;\n      &lt;span class=&quot;badge&quot;&gt;{{hero.id}}&lt;/span&gt; {{hero.name}}\n    &lt;/a&gt;\n    &lt;button class=&quot;delete&quot; title=&quot;delete hero&quot;\n      (click)=&quot;delete(hero)&quot;&gt;x&lt;/button&gt;\n  &lt;/li&gt;\n&lt;/ul&gt;\n\n</code-example>\n-->\n<code-example path=\"toh-pt6/src/app/heroes/heroes.component.html\" region=\"list\" header=\"src/app/heroes/heroes.component.html (히어로 목록)\">\n&#x3C;ul class=\"heroes\">\n  &#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">\n    &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/detail/{{hero.id}}\">\n      &#x3C;span class=\"badge\">{{hero.id}}&#x3C;/span> {{hero.name}}\n    &#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n    &#x3C;button class=\"delete\" title=\"delete hero\"\n      (click)=\"delete(hero)\">x&#x3C;/button>\n  &#x3C;/li>\n&#x3C;/ul>\n\n</code-example>\n<!--\nTo position the delete button at the far right of the hero entry,\nadd some CSS to the `heroes.component.css`.  You'll find that CSS\nin the [final review code](#heroescomponent) below.\n\nAdd the `delete()` handler to the component.\n-->\n<p>제거 버튼을 원하는 곳에 두려면 <code>heroes.component.css</code> 파일에 CSS 스타일을 추가해야 합니다.\n이 내용은 <a href=\"tutorial/toh-pt6#heroescomponent\">최종코드 리뷰</a> 섹션에서 확인할 수 있습니다.</p>\n<p>그 다음에는 컴포넌트 클래스에 <code>delete()</code> 핸들러를 추가합니다.</p>\n<code-example path=\"toh-pt6/src/app/heroes/heroes.component.ts\" region=\"delete\" header=\"src/app/heroes/heroes.component.ts (delete)\">\ndelete(hero: Hero): void {\n  this.heroes = this.heroes.filter(h => h !== hero);\n  this.heroService.deleteHero(hero).subscribe();\n}\n\n</code-example>\n<!--\nAlthough the component delegates hero deletion to the `HeroService`,\nit remains responsible for updating its own list of heroes.\nThe component's `delete()` method immediately removes the _hero-to-delete_ from that list,\nanticipating that the `HeroService` will succeed on the server.\n\nThere's really nothing for the component to do with the `Observable` returned by\n`heroService.delete()`. **It must subscribe anyway**.\n-->\n<p>히어로를 제거하는 기능은 <code>HeroService</code>가 담당하지만, 변경된 내용으로 화면을 갱신하는 것은 컴포넌트가 처리해야 합니다.\n그래서 컴포넌트에 정의된 <code>delete()</code> 메소드는 서버로 보내는 요청이 성공할 것으로 간주하고 <em>이 히어로</em> 를 목록에서 바로 제거합니다.</p>\n<p><code>heroService.delete()</code> 메소드를 실행하고 받은 <code>Observable</code>로는 아무것도 하지 않습니다.\n함수를 실행하기 위해 <strong>단순하게 구독만 할 뿐입니다.</strong></p>\n<div class=\"alert is-important\">\n  <!--\n  If you neglect to `subscribe()`, the service will not send the delete request to the server!\n  As a rule, an `Observable` _does nothing_ until something subscribes!\n  \n  Confirm this for yourself by temporarily removing the `subscribe()`,\n  clicking \"Dashboard\", then clicking \"Heroes\".\n  You'll see the full list of heroes again.\n  -->\n<p>  <code>subscribe()</code>를 생략하면 서버로 제거 요청을 보내지 않습니다!\n왜냐하면 아무도 구독하지 않은 <code>Observable</code>은 <em>아무 동작도</em> 하지 않기 때문입니다!</p>\n<p>  이 내용을 확인해 보려면 <code>subscribe()</code> 부분을 제거하고 앱을 다시 실행해 보세요.\n히어로를 제거한 뒤 다른 페이지로 이동했다가 돌아오면 이전에 표시되었던 히어로 목록이 그대로 표시되는 것을 확인할 수 있습니다.</p>\n</div>\n<!--\n#### Add _HeroService.deleteHero()_\n-->\n<h4 id=\"heroservicedeletehero-추가하기\"><em>HeroService.deleteHero()</em> 추가하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#heroservicedeletehero-추가하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nAdd a `deleteHero()` method to `HeroService` like this.\n-->\n<p><code>HeroService</code>에 다음 내용으로 <code>deleteHero()</code> 메소드를 추가합니다.</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"deleteHero\" header=\"src/app/hero.service.ts (delete)\">\n/** DELETE: 서버에서 히어로를 제거합니다. */\ndeleteHero (hero: Hero | number): Observable&#x3C;Hero> {\n  const id = typeof hero === 'number' ? hero : hero.id;\n  const url = `${this.heroesUrl}/${id}`;\n\n  return this.http.delete&#x3C;Hero>(url, httpOptions).pipe(\n    tap(<a href=\"\" class=\"code-anchor\">_</a> => this.log(`deleted hero id=${id}`)),\n    catchError(this.handleError&#x3C;Hero>('deleteHero'))\n  );\n}\n\n</code-example>\n<!--\nNote that\n\n* it calls `HttpClient.delete`.\n* the URL is the heroes resource URL plus the `id` of the hero to delete\n* you don't send data as you did with `put` and `post`.\n* you still send the `httpOptions`.\n\nRefresh the browser and try the new delete functionality.\n-->\n<ul>\n<li>이 메소드는 <code>HttpClient.delete</code> 메소드를 사용합니다.</li>\n<li>제거할 히어로의 <code>id</code>는 URL을 구성할 때 사용됩니다.</li>\n<li><code>put</code>이나 <code>post</code>을 사용했을 때와는 다르게, 추가 데이터는 보내지 않습니다.</li>\n<li><code>httpOptions</code>는 동일한 방식으로 사용합니다.</li>\n</ul>\n<p>이제 브라우저가 갱신되고 나면 히어로를 제거하는 로직이 제대로 동작하는 것을 확인할 수 있습니다.</p>\n<!--\n## Search by name\n-->\n<h2 id=\"이름으로-검색하기\">이름으로 검색하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#이름으로-검색하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nIn this last exercise, you learn to chain `Observable` operators together\nso you can minimize the number of similar HTTP requests\nand consume network bandwidth economically.\n\nYou will add a *heroes search* feature to the *Dashboard*.\nAs the user types a name into a search box, \nyou'll make repeated HTTP requests for heroes filtered by that name.\nYour goal is to issue only as many requests as necessary.\n-->\n<p>이전 섹션에서 알아본 것처럼 <code>Observable</code> 연산자를 체이닝하면 HTTP 요청을 최적화할 수 있으며, 결과적으로 네트워크 사용량을 절약할 수 있습니다.</p>\n<p>이번에는 <em>대시보드</em> 화면에 <em>히어로를 검색하는</em> 기능을 추가해 봅시다.\n사용자가 검색창에 히어로 이름을 입력하면 입력한 내용이 포함된 히어로의 목록을 받아오도록 HTTP 요청을 보낼 것입니다.\n이 때 진짜 필요할 때만 실제로 요청을 보내는 방법에 대해 알아봅시다.</p>\n<h4 id=\"heroservicesearchheroes\"><em>HeroService.searchHeroes</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#heroservicesearchheroes\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nStart by adding a `searchHeroes` method to the `HeroService`.\n-->\n<p>아래 내용으로 <code>HeroService</code>에 <code>searchHeroes</code> 메소드를 추가합니다.</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"searchHeroes\" header=\"src/app/hero.service.ts\">\n/* GET: 입력된 문구가 이름에 포함된 히어로 목록을 반환합니다. */\nsearchHeroes(term: string): Observable&#x3C;Hero[]> {\n  if (!term.trim()) {\n    // 입력된 내용이 없으면 빈 배열을 반환합니다.\n    return of([]);\n  }\n  return this.http.get&#x3C;Hero[]>(`${this.heroesUrl}/?name=${term}`).pipe(\n    tap(<a href=\"\" class=\"code-anchor\">_</a> => this.log(`found heroes matching \"${term}\"`)),\n    catchError(this.handleError&#x3C;Hero[]>('searchHeroes', []))\n  );\n}\n\n</code-example>\n<!--\nThe method returns immediately with an empty array if there is no search term.\nThe rest of it closely resembles `getHeroes()`.\nThe only significant difference is the URL, \nwhich includes a query string with the search term.\n-->\n<p>이 메소드는 입력된 내용이 없을 때 빈 배열을 즉시 반환합니다.\n이 경우가 아니라면 <code>getHeroes()</code>와 거의 비슷합니다.\n사용자가 입력한 문구가 URL에 쿼리 스트링으로 포함된다는 것만 다릅니다.</p>\n<!--\n### Add search to the Dashboard\n-->\n<h3 id=\"대시보드에-검색-기능-추가하기\">대시보드에 검색 기능 추가하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#대시보드에-검색-기능-추가하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nOpen the `DashboardComponent` _template_ and\nAdd the hero search element, `<app-hero-search>`, to the bottom of the `DashboardComponent` template.\n-->\n<p><code>DashboardComponent</code> <em>템플릿</em> 을 열고 이 템플릿 제일 아래에 <code>&#x3C;app-hero-search></code>를 추가합니다.</p>\n<code-example path=\"toh-pt6/src/app/dashboard/dashboard.component.html\" header=\"src/app/dashboard/dashboard.component.html\" linenums=\"false\">\n&#x3C;h3>Top Heroes&#x3C;/h3>\n&#x3C;div class=\"grid grid-pad\">\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\" class=\"col-1-4\"\n      <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/detail/{{hero.id}}\">\n    &#x3C;div class=\"module hero\">\n      &#x3C;h4>{{hero.name}}&#x3C;/h4>\n    &#x3C;/div>\n  &#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n&#x3C;/div>\n\n&#x3C;app-hero-search>&#x3C;/app-hero-search>\n\n\n</code-example>\n<!--\nThis template looks a lot like the `*ngFor` repeater in the `HeroesComponent` template.\n\nUnfortunately, adding this element breaks the app.\nAngular can't find a component with a selector that matches `<app-hero-search>`.\n\nThe `HeroSearchComponent` doesn't exist yet. Fix that.\n-->\n<p>이 템플릿은 <code>HeroesComponent</code> 템플릿에 사용한 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 부분과 거의 비슷합니다.</p>\n<p>하지만 이제 애플리케이션은 동작하지 않습니다.\n왜냐하면 Angular가 <code>&#x3C;app-hero-search></code> 셀렉터에 해당하는 컴포넌트를 찾지 못했기 때문입니다.</p>\n<p>아직 <code>HeroSearchComponent</code>는 만들지 않았습니다. 이제 만들어 봅시다.</p>\n<!--\n### Create _HeroSearchComponent_\n-->\n<h3 id=\"herosearchcomponent-생성하기\"><em>HeroSearchComponent</em> 생성하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#herosearchcomponent-생성하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nCreate a `HeroSearchComponent` with the CLI.\n-->\n<p>Angular CLI로 다음 명령을 실행해서 <code>HeroSearchComponent</code>를 생성합니다.</p>\n<code-example language=\"sh\" class=\"code-shell\">\n  ng generate component hero-search\n</code-example>\n<!--\nThe CLI generates the three `HeroSearchComponent` files and adds the component to the `AppModule` declarations\n\nReplace the generated `HeroSearchComponent` _template_ with a text box and a list of matching search results like this.\n-->\n<p>그러면 Angular CLI가 <code>HeroSearchComponent</code>를 구성하는 파일을 생성하면서 <code>AppModule</code>에 이 컴포넌트를 자동으로 등록합니다.</p>\n<p>이렇게 생성된 <code>HeroSearchComponent</code>의 <em>템플릿</em> 을 다음과 같이 수정합니다. 이 템플릿에는 사용자가 내용을 입력할 수 있는 텍스트 박스가 하나 있고, 검색 결과를 표시하는 목록이 있습니다.</p>\n<code-example path=\"toh-pt6/src/app/hero-search/hero-search.component.html\" header=\"src/app/hero-search/hero-search.component.html\">\n&#x3C;div id=\"search-component\">\n  &#x3C;h4>&#x3C;label for=\"search-box\">Hero Search&#x3C;/label>&#x3C;/h4>\n\n  &#x3C;input #searchBox id=\"search-box\" (input)=\"search(searchBox.value)\" />\n\n  &#x3C;ul class=\"search-result\">\n    &#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes$ | <a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>\" >\n      &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/detail/{{hero.id}}\">\n        {{hero.name}}\n      &#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n    &#x3C;/li>\n  &#x3C;/ul>\n&#x3C;/div>\n\n\n</code-example>\n<!--\nAdd private CSS styles to `hero-search.component.css`\nas listed in the [final code review](#herosearchcomponent) below.\n\nAs the user types in the search box, an *input* event binding calls the component's `search()`\nmethod with the new search box value.\n-->\n<p>그리고 <a href=\"tutorial/toh-pt6#herosearchcomponent\">최종코드 리뷰</a>에 있는 내용처럼 <code>hero-search.component.css</code> 파일에 컴포넌트 CSS 스타일을 추가합니다.</p>\n<p>이제 사용자가 검색창에 내용을 입력하면 <em>입력</em> 이벤트에 바인딩된 <code><a href=\"api/common/upgrade/$locationShim#search\" class=\"code-anchor\">search()</a></code> 메소드가 실행될 것입니다.</p>\n<a id=\"asyncpipe\"></a>\n<h3 id=\"asyncpipe\"><em>AsyncPipe</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#asyncpipe\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAs expected, the `*ngFor` repeats hero objects.\n\nLook closely and you'll see that the `*ngFor` iterates over a list called `heroes$`, not `heroes`.\n-->\n<p><code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>는 히어로 객체가 담긴 배열을 순회합니다.</p>\n<p>그런데 좀 더 자세하게 보면 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>는 <code>heroes</code>가 아니라 <code>heroes$</code>을 순회하는 것을 확인할 수 있습니다.</p>\n<code-example path=\"toh-pt6/src/app/hero-search/hero-search.component.html\" region=\"async\">\n&#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes$ | <a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>\" >\n\n</code-example>\n<!--\nThe `$` is a convention that indicates `heroes$` is an `Observable`, not an array.\n\nThe `*ngFor` can't do anything with an `Observable`.\nBut there's also a pipe character (`|`) followed by `async`,\nwhich identifies Angular's `AsyncPipe`.\n\nThe `AsyncPipe` subscribes to an `Observable` automatically so you won't have to\ndo so in the component class.\n-->\n<p>변수의 타입이 단순한 배열이 아니라 <code>Observable</code>이라는 것을 표현할 때 일반적으로 <code>$</code> 접미사를 붙입니다.</p>\n<p><code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>가 <code>Observable</code>을 직접 처리할 수는 없습니다.\n그래서 Angular가 제공하는 <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">AsyncPipe</a></code>를 함께 사용하는데, 이 파이프를 사용하려면 파이프 문자(<code>|</code>) 뒤에 <code><a href=\"api/core/testing/async\" class=\"code-anchor\">async</a></code> 파이프를 지정하면 됩니다.</p>\n<p><code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">AsyncPipe</a></code>는 <code>Observable</code>을 자동으로 구독하기 때문에 컴포넌트 클래스에서 따로 구독하지 않아도 됩니다.</p>\n<!--\n### Fix the _HeroSearchComponent_ class\n-->\n<h3 id=\"herosearchcomponent-클래스-수정하기\"><em>HeroSearchComponent</em> 클래스 수정하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#herosearchcomponent-클래스-수정하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nReplace the generated `HeroSearchComponent` class and metadata as follows.\n-->\n<p>Angular CLI가 생성한 <code>HeroSearchComponent</code> 클래스와 메타데이터의 내용을 다음과 같이 수정합니다.</p>\n<code-example path=\"toh-pt6/src/app/hero-search/hero-search.component.ts\" header=\"src/app/hero-search/hero-search.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\n\nimport { Observable, Subject } from 'rxjs';\n\nimport {\n   debounceTime, distinctUntilChanged, switchMap\n } from 'rxjs/operators';\n\nimport { Hero } from '../hero';\nimport { HeroService } from '../hero.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-search',\n  templateUrl: './hero-search.component.html',\n  <a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a>: [ './hero-search.component.css' ]\n})\nexport class HeroSearchComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  heroes$: Observable&#x3C;Hero[]>;\n  private searchTerms = new Subject&#x3C;string>();\n\n  constructor(private heroService: HeroService) {}\n\n  // 사용자가 입력한 검색어를 옵저버블 스트림으로 보냅니다.\n  search(term: string): void {\n    this.searchTerms.next(term);\n  }\n\n  ngOnInit(): void {\n    this.heroes$ = this.searchTerms.pipe(\n      // 연속된 키입력을 처리하기 위해 300ms 대기합니다.\n      debounceTime(300),\n\n      // 이전에 입력한 검색어와 같으면 무시합니다.\n      distinctUntilChanged(),\n\n      // 검색어가 변경되면 새로운 옵저버블을 생성합니다.\n      switchMap((term: string) => this.heroService.searchHeroes(term)),\n    );\n  }\n}\n\n\n</code-example>\n<!--\nNotice the declaration of `heroes$` as an `Observable`\n-->\n<p><code>heroes$</code> 프로퍼티는 <code>Observable</code> 타입으로 선언하는 것을 잊지 마세요.</p>\n<code-example path=\"toh-pt6/src/app/hero-search/hero-search.component.ts\" region=\"heroes-stream\">\nheroes$: Observable&#x3C;Hero[]>;\n\n</code-example>\n<!--\nYou'll set it in [`ngOnInit()`](#search-pipe). \nBefore you do, focus on the definition of `searchTerms`.\n-->\n<p>이 옵저버블 구독은 <a href=\"tutorial/toh-pt6#search-pipe\"><code>ngOnInit()</code></a>에서 시작됩니다.\n지금은 <code>searchTerms</code>을 선언하는 방법에 대해 먼저 알아봅시다.</p>\n<!--\n### The _searchTerms_ RxJS subject\n-->\n<h3 id=\"searchterms-rxjs-subject\"><em>searchTerms</em> RxJS subject<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#searchterms-rxjs-subject\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe `searchTerms` property is declared as an RxJS `Subject`.\n-->\n<p><code>searchTerms</code> 프로퍼티는 RxJS가 제공하는 <code>Subject</code> 객체로 선언합니다.</p>\n<code-example path=\"toh-pt6/src/app/hero-search/hero-search.component.ts\" region=\"searchTerms\">\nprivate searchTerms = new Subject&#x3C;string>();\n\n// 사용자가 입력한 검색어를 옵저버블 스트림으로 보냅니다.\nsearch(term: string): void {\n  this.searchTerms.next(term);\n}\n\n</code-example>\n<!--\nA `Subject` is both a source of _observable_ values and an `Observable` itself.\nYou can subscribe to a `Subject` as you would any `Observable`.\n\nYou can also push values into that `Observable` by calling its `next(value)` method\nas the `search()` method does.\n\nThe `search()` method is called via an _event binding_ to the\ntextbox's `input` event.\n-->\n<p><code>Subject</code>는 <em>옵저버블</em> 의 소스로 사용되기도 하지만 그 자체로 <code>Observable</code> 이기도 합니다.\n<code>Subject</code> 객체는 <code>Observable</code>을 사용할 때와 마찬가지로 구독할 수 있습니다.</p>\n<p>그리고 <code><a href=\"api/common/upgrade/$locationShim#search\" class=\"code-anchor\">search()</a></code> 메소드에 사용한 것처럼 <code>Subject</code> 객체가 제공하는 <code>next(value)</code> 메소드를 사용하면 <code>Observable</code>로 데이터를 보낼 수도 있습니다.</p>\n<p><code><a href=\"api/common/upgrade/$locationShim#search\" class=\"code-anchor\">search()</a></code> 메소드는 텍스트 입력박스에서 발생하는 <code>입력</code> 이벤트와 바인딩되었기 때문에, <code>입력</code> 이벤트가 발생할 때마다 실행됩니다.</p>\n<code-example path=\"toh-pt6/src/app/hero-search/hero-search.component.html\" region=\"input\">\n&#x3C;input #searchBox id=\"search-box\" (input)=\"search(searchBox.value)\" />\n\n</code-example>\n<!--\nEvery time the user types in the textbox, the binding calls `search()` with the textbox value, a \"search term\". \nThe `searchTerms` becomes an `Observable` emitting a steady stream of search terms.\n-->\n<p>사용자가 텍스트박스에 키보드를 입력할 때마다 입력된 내용이 인자로 전달되면서 <code><a href=\"api/common/upgrade/$locationShim#search\" class=\"code-anchor\">search()</a></code> 메소드가 실행됩니다.\n이 메소드에서 <code>searchTerms</code> 프로퍼티는 <code>Observable</code>로 동작하며, 사용자가 입력한 내용을 옵저버블 스트림으로 보냅니다.</p>\n<a id=\"search-pipe\"></a>\n<!--\n### Chaining RxJS operators\n-->\n<h3 id=\"rxjs-연산자-체이닝하기\">RxJS 연산자 체이닝하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#rxjs-연산자-체이닝하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nPassing a new search term directly to the `searchHeroes()` after every user keystroke would create an excessive amount of HTTP requests,\ntaxing server resources and burning through the cellular network data plan.\n\nInstead, the `ngOnInit()` method pipes the `searchTerms` observable through a sequence of RxJS operators that reduce the number of calls to the `searchHeroes()`,\nultimately returning an observable of timely hero search results (each a `Hero[]`).\n\nHere's the code.\n-->\n<p>사용자가 입력한 검색어가 <code>searchHeroes()</code>로 바로 넘어간다면 사용자의 키입력마다 HTTP 요청이 발생하기 때문에 수많은 HTTP 요청이 발생할 것입니다.\n이렇게 되면 서버에 과도한 부하가 걸릴 수 있으며 모바일 장비의 네트워크 요금도 빠르게 올라갈 것입니다.</p>\n<p>이 방법보다는 <code>ngOnInit()</code> 메소드에서 <code>searchTerms</code> 옵저버블로 데이터를 보낼 때 RxJS 연산자로 체이닝해서 <code>searchHeroes()</code>로 전달되는 것을 최적화하는 것이 더 좋습니다.</p>\n<p>이 내용은 이렇게 구현합니다.</p>\n<code-example path=\"toh-pt6/src/app/hero-search/hero-search.component.ts\" region=\"search\">\nthis.heroes$ = this.searchTerms.pipe(\n  // 연속된 키입력을 처리하기 위해 300ms 대기합니다.\n  debounceTime(300),\n\n  // 이전에 입력한 검색어와 같으면 무시합니다.\n  distinctUntilChanged(),\n\n  // 검색어가 변경되면 새로운 옵저버블을 생성합니다.\n  switchMap((term: string) => this.heroService.searchHeroes(term)),\n);\n\n</code-example>\n<!--\n* `debounceTime(300)` waits until the flow of new string events pauses for 300 milliseconds\nbefore passing along the latest string. You'll never make requests more frequently than 300ms.\n\n\n* `distinctUntilChanged()` ensures that a request is sent only if the filter text changed.\n\n\n* `switchMap()` calls the search service for each search term that makes it through `debounce` and `distinctUntilChanged`.\nIt cancels and discards previous search observables, returning only the latest search service observable.\n-->\n<ul>\n<li>\n<p><code>debounceTime(300)</code>을 사용하면 옵저버블로 전달된 문자열을 바로 보내지 않고 다음 이벤트가 올 떄까지 300 밀리초 기다립니다. 사용자가 보내는 요청은 300ms에 하나로 제한됩니다.</p>\n</li>\n<li>\n<p><code>distinctUntilChanged()</code>를 사용하면 사용자가 입력한 문자열의 내용이 변경되었을 때만 옵저버블 스트림을 전달합니다.</p>\n</li>\n<li>\n<p><code>switchMap()</code>을 사용하면 옵저버블 스트림이 <code>debounce</code>와 <code>distinctUntilChanged</code>를 통과했을 때 서비스에 있는 검색 기능을 호출합니다.\n이 때 이전에 발생했던 옵저버블은 취소되며, <code>HeroService</code>가 생성한 옵저버블만 반환합니다.</p>\n</li>\n</ul>\n<div class=\"alert is-helpful\">\n  <!--\n  With the [switchMap operator](http://www.learnrxjs.io/operators/transformation/switchmap.html),\n  every qualifying key event can trigger an `HttpClient.get()` method call.\n  Even with a 300ms pause between requests, you could have multiple HTTP requests in flight\n  and they may not return in the order sent.\n\n  `switchMap()` preserves the original request order while returning only the observable from the most recent HTTP method call.\n  Results from prior calls are canceled and discarded.\n\n  Note that _canceling_ a previous `searchHeroes()` _Observable_\n  doesn't actually abort a pending HTTP request.\n  Unwanted results are simply discarded before they reach your application code.\n  -->\n<p>  <a href=\"http://www.learnrxjs.io/operators/transformation/switchmap.html\">switchMap 연산자</a>를 사용하면 옵저버블 체이닝을 통과한 키이벤트마다 <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 메소드가 실행됩니다.\n그런데 요청을 300ms 당 한 번으로 제한하더라도 동작중인 HTTP 요청은 여러개가 될 수 있으며, 응답이 돌아오는 순서도 보낸 순서와 다를 수 있습니다.</p>\n<p>  이 때 <code>switchMap()</code> 연산자를 활용하면 이전에 보낸 HTTP 요청을 취소하고 제일 마지막에 보낸 HTTP 요청만 남겨둘 수 있습니다.</p>\n<p>  하지만 이전에 발생한 <code>searchHeroes()</code> <em>Observable</em> 을 취소했다고 해서 이미 보낸 HTTP 요청을 취소하지는 않습니다.\n이미 보낸 HTTP 요청에 대한 응답은 애플리케이션 코드에 도달하지 못하고 그냥 폐기됩니다.</p>\n</div>\n<!--\nRemember that the component _class_ does not subscribe to the `heroes$` _observable_.\nThat's the job of the [`AsyncPipe`](#asyncpipe) in the template.\n-->\n<p>컴포넌트 <em>클래스</em> 에서 <code>heroes$</code> <em>옵저버블</em> 을 구독하지 않는 것에 주의하세요.\n<a href=\"tutorial/toh-pt6#asyncpipe\"><code>AsyncPipe</code></a>는 템플릿에서 옵저버블을 구독하기 위해 사용되었습니다.</p>\n<!--\n#### Try it\n-->\n<h4 id=\"동작-확인하기\">동작 확인하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#동작-확인하기\"><i class=\"material-icons\">link</i></a></h4>\n<!--\nRun the app again. In the *Dashboard*, enter some text in the search box.\nIf you enter characters that match any existing hero names, you'll see something like this.\n-->\n<p>애플리케이션을 다시 실행해 보세요.\n<em>대시보드</em> 화면에 있는 검색창에 무언가를 입력했을 때 이 입력값이 포함된 히어로의 이름이 있으면 다음과 같은 모습으로 화면에 표시될 것입니다.</p>\n<figure>\n  <img src=\"generated/images/guide/toh/toh-hero-search.png\" alt=\"Hero Search Component\" width=\"240\" height=\"224\">\n</figure>\n<!--\n## Final code review\n-->\n<h2 id=\"최종코드-리뷰\">최종코드 리뷰<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#최종코드-리뷰\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nYour app should look like this <live-example></live-example>.\n\nHere are the code files discussed on this page (all in the `src/app/` folder).\n-->\n<p>최종 코드는 <live-example></live-example>에서 직접 확인하거나 다운받아 확인할 수 있습니다.</p>\n<p>이 문서에서 다룬 코드들을 확인해 보세요.</p>\n<a id=\"heroservice\"></a>\n<a id=\"inmemorydataservice\"></a>\n<a id=\"appmodule\"></a>\n<h4 id=\"heroservice-inmemorydataservice-appmodule\"><em>HeroService</em>, <em>InMemoryDataService</em>, <em>AppModule</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#heroservice-inmemorydataservice-appmodule\"><i class=\"material-icons\">link</i></a></h4>\n<code-tabs>\n  <code-pane header=\"hero.service.ts\" path=\"toh-pt6/src/app/hero.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>, <a href=\"api/common/http/HttpHeaders\" class=\"code-anchor\">HttpHeaders</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\nimport { Observable, of } from 'rxjs';\nimport { catchError, map, tap } from 'rxjs/operators';\n\nimport { Hero } from './hero';\nimport { MessageService } from './message.service';\n\nconst httpOptions = {\n  headers: new <a href=\"api/common/http/HttpHeaders\" class=\"code-anchor\">HttpHeaders</a>({ 'Content-Type': 'application/json' })\n};\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({ <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root' })\nexport class HeroService {\n\n  private heroesUrl = 'api/heroes';  // 웹 API 형식의 <a href=\"api/core/SecurityContext#URL\" class=\"code-anchor\">URL</a>로 사용\n\n  constructor(\n    private <a href=\"api/common/http\" class=\"code-anchor\">http</a>: <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>,\n    private messageService: MessageService) { }\n\n  /** GET: 서버에서 히어로 목록 가져오기 */\n  getHeroes (): Observable&#x3C;Hero[]> {\n    return this.http.get&#x3C;Hero[]>(this.heroesUrl)\n      .pipe(\n        tap(<a href=\"\" class=\"code-anchor\">_</a> => this.log('fetched heroes')),\n        catchError(this.handleError&#x3C;Hero[]>('getHeroes', []))\n      );\n  }\n\n  /** GET: id에 해당하는 히어로 데이터를 가져옵니다. 존재하지 않으면 `undefined`를 반환합니다. */\n  getHeroNo404&#x3C;Hero>(id: number): Observable&#x3C;Hero> {\n    const url = `${this.heroesUrl}/?id=${id}`;\n    return this.http.get&#x3C;Hero[]>(url)\n      .pipe(\n        map(heroes => heroes[0]), // 배열에 있는 항목 중 하나만 반환합니다.\n        tap(h => {\n          const outcome = h ? `fetched` : `did not find`;\n          this.log(`${outcome} hero id=${id}`);\n        }),\n        catchError(this.handleError&#x3C;Hero>(`getHero id=${id}`))\n      );\n  }\n\n  /** GET: id에 해당하는 히어로 데이터 가져오기. 존재하지 않으면 404를 반환합니다. */\n  getHero(id: number): Observable&#x3C;Hero> {\n    const url = `${this.heroesUrl}/${id}`;\n    return this.http.get&#x3C;Hero>(url).pipe(\n      tap(<a href=\"\" class=\"code-anchor\">_</a> => this.log(`fetched hero id=${id}`)),\n      catchError(this.handleError&#x3C;Hero>(`getHero id=${id}`))\n    );\n  }\n\n  /* GET: 입력된 문구가 이름에 포함된 히어로 목록을 반환합니다. */\n  searchHeroes(term: string): Observable&#x3C;Hero[]> {\n    if (!term.trim()) {\n      // 입력된 내용이 없으면 빈 배열을 반환합니다.\n      return of([]);\n    }\n    return this.http.get&#x3C;Hero[]>(`${this.heroesUrl}/?name=${term}`).pipe(\n      tap(<a href=\"\" class=\"code-anchor\">_</a> => this.log(`found heroes matching \"${term}\"`)),\n      catchError(this.handleError&#x3C;Hero[]>('searchHeroes', []))\n    );\n  }\n\n  //////// 저장 기능 //////////\n\n  /** POST: 서버에 새로운 히어로를 추가합니다. */\n  addHero (hero: Hero): Observable&#x3C;Hero> {\n    return this.http.post&#x3C;Hero>(this.heroesUrl, hero, httpOptions).pipe(\n      tap((newHero: Hero) => this.log(`added hero w/ id=${newHero.id}`)),\n      catchError(this.handleError&#x3C;Hero>('addHero'))\n    );\n  }\n\n  /** DELETE: 서버에서 히어로를 제거합니다. */\n  deleteHero (hero: Hero | number): Observable&#x3C;Hero> {\n    const id = typeof hero === 'number' ? hero : hero.id;\n    const url = `${this.heroesUrl}/${id}`;\n\n    return this.http.delete&#x3C;Hero>(url, httpOptions).pipe(\n      tap(<a href=\"\" class=\"code-anchor\">_</a> => this.log(`deleted hero id=${id}`)),\n      catchError(this.handleError&#x3C;Hero>('deleteHero'))\n    );\n  }\n\n  /** PUT: 서버에 저장된 히어로 데이터를 변경합니다. */\n  updateHero (hero: Hero): Observable&#x3C;any> {\n    return this.http.put(this.heroesUrl, hero, httpOptions).pipe(\n      tap(<a href=\"\" class=\"code-anchor\">_</a> => this.log(`updated hero id=${hero.id}`)),\n      catchError(this.handleError&#x3C;any>('updateHero'))\n    );\n  }\n\n  /**\n   * HTTP 요청이 실패한 경우를 처리합니다.\n   * 애플리케이션 로직 흐름은 그대로 유지됩니다.\n   * @param operation - 실패한 동작의 이름\n   * @param result - 기본값으로 반환할 객체\n   */\n  private handleError&#x3C;T> (operation = 'operation', result?: T) {\n    return (error: any): Observable&#x3C;T> => {\n\n      // TODO: 리모트 서버로 에러 메시지 보내기\n      console.error(error); // 지금은 콘솔에 로그를 출력합니다.\n\n      // TODO: 사용자가 이해할 수 있는 형태로 변환하기\n      this.log(`${operation} failed: ${error.message}`);\n\n      // 애플리케이션 로직이 끊기지 않도록 기본값으로 받은 객체를 반환합니다.\n      return of(result as T);\n    };\n  }\n\n  /** HeroService에서 보내는 메시지는 MessageService가 화면에 표시합니다. */\n  private <a href=\"api/animations/browser/testing/MockAnimationDriver#log\" class=\"code-anchor\">log</a>(<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>: string) {\n    this.messageService.add(`HeroService: ${<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>}`);\n  }\n}\n\n\n</code-pane>\n  <code-pane header=\"in-memory-data.service.ts\" path=\"toh-pt6/src/app/in-memory-data.service.ts\">\nimport { InMemoryDbService } from 'angular-in-memory-web-api';\nimport { Hero } from './hero';\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class InMemoryDataService implements InMemoryDbService {\n  createDb() {\n    const heroes = [\n      { id: 11, name: 'Dr Nice' },\n      { id: 12, name: 'Narco' },\n      { id: 13, name: 'Bombasto' },\n      { id: 14, name: 'Celeritas' },\n      { id: 15, name: 'Magneta' },\n      { id: 16, name: 'RubberMan' },\n      { id: 17, name: 'Dynama' },\n      { id: 18, name: 'Dr IQ' },\n      { id: 19, name: 'Magma' },\n      { id: 20, name: 'Tornado' }\n    ];\n    return {heroes};\n  }\n\n  // 히어로 객체가 항상 id 프로퍼티를 갖도록 getId 메소드를 오버라이드 합니다.\n  // 히어로 목록이 비어있다면 이 메소드는 초기값(11)을 반환합니다.\n  // 히어로 목록이 비어있지 않으면 히어로 id의 최대값에 1을 더해서 반환합니다.\n  genId(heroes: Hero[]): number {\n    return heroes.length > 0 ? Math.max(...heroes.map(hero => hero.id)) + 1 : 11;\n  }\n}\n\n\n</code-pane>\n  <code-pane header=\"app.module.ts\" path=\"toh-pt6/src/app/app.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }       from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> }  from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> }    from '@angular/forms';\nimport { <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a> }    from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\nimport { HttpClientInMemoryWebApiModule } from 'angular-in-memory-web-api';\nimport { InMemoryDataService }  from './in-memory-data.service';\n\nimport { AppRoutingModule }     from './app-routing.module';\n\nimport { AppComponent }         from './app.component';\nimport { DashboardComponent }   from './dashboard/dashboard.component';\nimport { HeroDetailComponent }  from './hero-detail/hero-detail.component';\nimport { HeroesComponent }      from './heroes/heroes.component';\nimport { HeroSearchComponent }  from './hero-search/hero-search.component';\nimport { MessagesComponent }    from './<a href=\"api/service-worker/SwPush#messages\" class=\"code-anchor\">messages</a>/messages.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    AppRoutingModule,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n\n    // HttpClientInMemoryWebApiModule 모듈은 HTTP 요청을 가로채고 서버의 응답을 흉내냅니다.\n    // 실제 서버가 준비되면 이 부분을 제거하면 됩니다.\n    HttpClientInMemoryWebApiModule.forRoot(\n      InMemoryDataService, { dataEncapsulation: false }\n    )\n  ],\n  declarations: [\n    AppComponent,\n    DashboardComponent,\n    HeroesComponent,\n    HeroDetailComponent,\n    MessagesComponent,\n    HeroSearchComponent\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n</code-pane>\n</code-tabs>\n<a id=\"heroescomponent\"></a>\n<h4 id=\"heroescomponent\"><em>HeroesComponent</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#heroescomponent\"><i class=\"material-icons\">link</i></a></h4>\n<code-tabs>\n  <code-pane header=\"heroes/heroes.component.html\" path=\"toh-pt6/src/app/heroes/heroes.component.html\">\n&#x3C;h2>My Heroes&#x3C;/h2>\n\n&#x3C;div>\n  &#x3C;label>Hero name:\n    &#x3C;input #heroName />\n  &#x3C;/label>\n  &#x3C;!-- (click) 이벤트를 감지하면 현재값을 인자로 전달하면서 add() 함수를 실행하고, 입력 필드를 비웁니다. -->\n  &#x3C;button (click)=\"add(heroName.value); heroName.value=''\">\n    add\n  &#x3C;/button>\n&#x3C;/div>\n\n&#x3C;ul class=\"heroes\">\n  &#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">\n    &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/detail/{{hero.id}}\">\n      &#x3C;span class=\"badge\">{{hero.id}}&#x3C;/span> {{hero.name}}\n    &#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n    &#x3C;button class=\"delete\" title=\"delete hero\"\n      (click)=\"delete(hero)\">x&#x3C;/button>\n  &#x3C;/li>\n&#x3C;/ul>\n\n\n</code-pane>\n  <code-pane header=\"heroes/heroes.component.ts\" path=\"toh-pt6/src/app/heroes/heroes.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\n\nimport { Hero } from '../hero';\nimport { HeroService } from '../hero.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-heroes',\n  templateUrl: './heroes.component.html',\n  <a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a>: ['./heroes.component.css']\n})\nexport class HeroesComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  heroes: Hero[];\n\n  constructor(private heroService: HeroService) { }\n\n  ngOnInit() {\n    this.getHeroes();\n  }\n\n  getHeroes(): void {\n    this.heroService.getHeroes()\n    .subscribe(heroes => this.heroes = heroes);\n  }\n\n  add(name: string): void {\n    name = name.trim();\n    if (!name) { return; }\n    this.heroService.addHero({ name } as Hero)\n      .subscribe(hero => {\n        this.heroes.push(hero);\n      });\n  }\n\n  delete(hero: Hero): void {\n    this.heroes = this.heroes.filter(h => h !== hero);\n    this.heroService.deleteHero(hero).subscribe();\n  }\n\n}\n\n\n</code-pane>\n  <code-pane header=\"heroes/heroes.component.css\" path=\"toh-pt6/src/app/heroes/heroes.component.css\">\n/* HeroesComponent 컴포넌트에 적용되는 CSS 스타일 */\n.heroes {\n  margin: 0 0 2em 0;\n  list-style-type: none;\n  padding: 0;\n  width: 15em;\n}\n.heroes li {\n  <a href=\"api/router/Scroll#position\" class=\"code-anchor\">position</a>: relative;\n  cursor: pointer;\n  background-color: #EEE;\n  margin: .5em;\n  padding: .3em 0;\n  height: 1.6em;\n  border-radius: 4px;\n}\n\n.heroes li:hover {\n  color: #607D8B;\n  background-color: #DDD;\n  left: .1em;\n}\n\n.heroes <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> {\n  color: #333;\n  text-decoration: none;\n  <a href=\"api/router/Scroll#position\" class=\"code-anchor\">position</a>: relative;\n  display: block;\n  width: 250px;\n}\n\n.heroes <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>:hover {\n  color:#607D8B;\n}\n\n.heroes .badge {\n  display: inline-block;\n  font-size: small;\n  color: white;\n  padding: 0.8em 0.7em 0 0.7em;\n  background-color:#405061;\n  line-height: 1em;\n  <a href=\"api/router/Scroll#position\" class=\"code-anchor\">position</a>: relative;\n  left: -1px;\n  top: -4px;\n  height: 1.8em;\n  min-width: 16px;\n  text-align: right;\n  margin-right: .8em;\n  border-radius: 4px 0 0 4px;\n}\n\nbutton {\n  background-color: #eee;\n  border: none;\n  padding: 5px 10px;\n  border-radius: 4px;\n  cursor: pointer;\n  cursor: hand;\n  font-family: Arial;\n}\n\nbutton:hover {\n  background-color: #cfd8dc;\n}\n\nbutton.delete {\n  <a href=\"api/router/Scroll#position\" class=\"code-anchor\">position</a>: relative;\n  left: 194px;\n  top: -32px;\n  background-color: gray !important;\n  color: white;\n}\n\n\n\n</code-pane>\n</code-tabs>\n<a id=\"herodetailcomponent\"></a>\n<h4 id=\"herodetailcomponent\"><em>HeroDetailComponent</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#herodetailcomponent\"><i class=\"material-icons\">link</i></a></h4>\n<code-tabs>\n  <code-pane header=\"hero-detail/hero-detail.component.html\" path=\"toh-pt6/src/app/hero-detail/hero-detail.component.html\">\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero\">\n  &#x3C;h2>{{hero.name | <a href=\"api/common/UpperCasePipe\" class=\"code-anchor\">uppercase</a>}} Details&#x3C;/h2>\n  &#x3C;div>&#x3C;span>id: &#x3C;/span>{{hero.id}}&#x3C;/div>\n  &#x3C;div>\n    &#x3C;label>name:\n      &#x3C;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.name\" placeholder=\"name\"/>\n    &#x3C;/label>\n  &#x3C;/div>\n  &#x3C;button (click)=\"goBack()\">go back&#x3C;/button>\n  &#x3C;button (click)=\"save()\">save&#x3C;/button>\n&#x3C;/div>\n\n\n</code-pane>\n  <code-pane header=\"hero-detail/hero-detail.component.ts\" path=\"toh-pt6/src/app/hero-detail/hero-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a> } from '@angular/core';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\nimport { <a href=\"api/common/Location\" class=\"code-anchor\">Location</a> } from '@angular/common';\n\nimport { Hero }         from '../hero';\nimport { HeroService }  from '../hero.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-detail',\n  templateUrl: './hero-detail.component.html',\n  <a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a>: [ './hero-detail.component.css' ]\n})\nexport class HeroDetailComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n\n  constructor(\n    private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>,\n    private heroService: HeroService,\n    private location: <a href=\"api/common/Location\" class=\"code-anchor\">Location</a>\n  ) {}\n\n  ngOnInit(): void {\n    this.getHero();\n  }\n\n  getHero(): void {\n    const id = +this.route.snapshot.paramMap.get('id');\n    this.heroService.getHero(id)\n      .subscribe(hero => this.hero = hero);\n  }\n\n  goBack(): void {\n    this.location.back();\n  }\n\n save(): void {\n    this.heroService.updateHero(this.hero)\n      .subscribe(() => this.goBack());\n  }\n}\n\n\n</code-pane>\n</code-tabs>\n<a id=\"dashboardcomponent\"></a>\n<h4 id=\"dashboardcomponent\"><em>DashboardComponent</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#dashboardcomponent\"><i class=\"material-icons\">link</i></a></h4>\n<code-tabs>\n  <code-pane header=\"src/app/dashboard/dashboard.component.html\" path=\"toh-pt6/src/app/dashboard/dashboard.component.html\">\n&#x3C;h3>Top Heroes&#x3C;/h3>\n&#x3C;div class=\"grid grid-pad\">\n  &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\" class=\"col-1-4\"\n      <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/detail/{{hero.id}}\">\n    &#x3C;div class=\"module hero\">\n      &#x3C;h4>{{hero.name}}&#x3C;/h4>\n    &#x3C;/div>\n  &#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n&#x3C;/div>\n\n&#x3C;app-hero-search>&#x3C;/app-hero-search>\n\n\n</code-pane>\n</code-tabs>\n<a id=\"herosearchcomponent\"></a>\n<h4 id=\"herosearchcomponent\"><em>HeroSearchComponent</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#herosearchcomponent\"><i class=\"material-icons\">link</i></a></h4>\n<code-tabs>\n  <code-pane header=\"hero-search/hero-search.component.html\" path=\"toh-pt6/src/app/hero-search/hero-search.component.html\">\n&#x3C;div id=\"search-component\">\n  &#x3C;h4>&#x3C;label for=\"search-box\">Hero Search&#x3C;/label>&#x3C;/h4>\n\n  &#x3C;input #searchBox id=\"search-box\" (input)=\"search(searchBox.value)\" />\n\n  &#x3C;ul class=\"search-result\">\n    &#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes$ | <a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>\" >\n      &#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/detail/{{hero.id}}\">\n        {{hero.name}}\n      &#x3C;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>>\n    &#x3C;/li>\n  &#x3C;/ul>\n&#x3C;/div>\n\n\n</code-pane>\n  <code-pane header=\"hero-search/hero-search.component.ts\" path=\"toh-pt6/src/app/hero-search/hero-search.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\n\nimport { Observable, Subject } from 'rxjs';\n\nimport {\n   debounceTime, distinctUntilChanged, switchMap\n } from 'rxjs/operators';\n\nimport { Hero } from '../hero';\nimport { HeroService } from '../hero.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-search',\n  templateUrl: './hero-search.component.html',\n  <a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a>: [ './hero-search.component.css' ]\n})\nexport class HeroSearchComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  heroes$: Observable&#x3C;Hero[]>;\n  private searchTerms = new Subject&#x3C;string>();\n\n  constructor(private heroService: HeroService) {}\n\n  // 사용자가 입력한 검색어를 옵저버블 스트림으로 보냅니다.\n  search(term: string): void {\n    this.searchTerms.next(term);\n  }\n\n  ngOnInit(): void {\n    this.heroes$ = this.searchTerms.pipe(\n      // 연속된 키입력을 처리하기 위해 300ms 대기합니다.\n      debounceTime(300),\n\n      // 이전에 입력한 검색어와 같으면 무시합니다.\n      distinctUntilChanged(),\n\n      // 검색어가 변경되면 새로운 옵저버블을 생성합니다.\n      switchMap((term: string) => this.heroService.searchHeroes(term)),\n    );\n  }\n}\n\n\n</code-pane>\n  <code-pane header=\"hero-search/hero-search.component.css\" path=\"toh-pt6/src/app/hero-search/hero-search.component.css\">\n/* HeroSearch 컴포넌트에 적용되는 CSS 스타일 */\n.search-result li {\n  border-bottom: 1px solid gray;\n  border-left: 1px solid gray;\n  border-right: 1px solid gray;\n  width: 195px;\n  height: 16px;\n  padding: 5px;\n  background-color: white;\n  cursor: pointer;\n  list-style-type: none;\n}\n\n.search-result li:hover {\n  background-color: #607D8B;\n}\n\n.search-result li <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> {\n  color: #888;\n  display: block;\n  text-decoration: none;\n}\n\n.search-result li <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>:hover {\n  color: white;\n}\n.search-result li <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>:active {\n  color: white;\n}\n#search-box {\n  width: 200px;\n  height: 20px;\n}\n\n\nul.search-result {\n  margin-top: 0;\n  padding-left: 0;\n}\n\n\n</code-pane>\n</code-tabs>\n<!--\n## Summary\n-->\n<h2 id=\"정리\">정리<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#정리\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nYou're at the end of your journey, and you've accomplished a lot.\n* You added the necessary dependencies to use HTTP in the app.\n* You refactored `HeroService` to load heroes from a web API.\n* You extended `HeroService` to support `post()`, `put()`, and `delete()` methods.\n* You updated the components to allow adding, editing, and deleting of heroes.\n* You configured an in-memory web API.\n* You learned how to use observables.\n\nThis concludes the \"Tour of Heroes\" tutorial.\nYou're ready to learn more about Angular development in the fundamentals section,\nstarting with the [Architecture](guide/architecture \"Architecture\") guide.\n-->\n<p>이번 튜토리얼을 진행하면서 다음과 같은 내용에 대해 알아봤습니다.</p>\n<ul>\n<li>HTTP 요청을 보내는 방법에 대해 알아봤습니다. HTTP 요청은 꼭 필요한 경우에만 보내는 것이 좋습니다.</li>\n<li><code>HeroService</code>가 웹 API를 사용해서 히어로 데이터를 가져오도록 리팩토링했습니다.</li>\n<li><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>가 제공하는 <code><a href=\"api/common/http/HttpClient#post\" class=\"code-anchor\">post()</a></code>, <code><a href=\"api/common/http/HttpClient#put\" class=\"code-anchor\">put()</a></code>, <code>delete()</code> 메소드를 사용해서 <code>HeroService</code>를 확장했습니다.</li>\n<li>히어로를 추가하고, 수정하고, 제거할 수 있도록 컴포넌트를 수정했습니다.</li>\n<li>인-메모리 웹 API를 설정하는 방법에 대해 알아봤습니다.</li>\n<li>옵저버블을 사용하는 방법에 대해 알아봤습니다.</li>\n</ul>\n<p>\"히어로들의 여행\" 튜토리얼에서 다루는 내용은 여기까지입니다.\n이어지는 \"기초 지식\" 문서에서는 Angular를 개발할 때 필요한 내용을 자세하게 설명합니다.\n<a href=\"guide/architecture\" title=\"Architecture\">아키텍처</a> 내용부터 확인해 보세요.</p>\n\n</div>\n\n<!-- links to this doc:\n - tutorial/toh-pt4\n-->\n<!-- links from this doc:\n - api/animations/browser/testing/MockAnimationDriver#log\n - api/common/AsyncPipe\n - api/common/Location\n - api/common/NgForOf\n - api/common/NgIf\n - api/common/UpperCasePipe\n - api/common/http\n - api/common/http/HttpClient\n - api/common/http/HttpClient#get\n - api/common/http/HttpClient#post\n - api/common/http/HttpClient#put\n - api/common/http/HttpClientModule\n - api/common/http/HttpErrorResponse#message\n - api/common/http/HttpHeaders\n - api/common/upgrade/$locationShim#search\n - api/core/Component\n - api/core/Component#styleUrls\n - api/core/ErrorHandler#handleError\n - api/core/Injectable\n - api/core/Injectable#providedIn\n - api/core/Input\n - api/core/NgModule\n - api/core/NgModule#imports\n - api/core/OnInit\n - api/core/SecurityContext#URL\n - api/core/testing/async\n - api/forms/FormsModule\n - api/forms/NgModel\n - api/platform-browser/BrowserModule\n - api/router/ActivatedRoute\n - api/router/RouterLink\n - api/router/RouterLinkWithHref\n - api/router/RouterModule#forRoot\n - api/router/Scroll#position\n - api/service-worker/SwPush#messages\n - guide/architecture\n - tutorial/toh-pt6#asyncpipe\n - tutorial/toh-pt6#dashboardcomponent\n - tutorial/toh-pt6#handleerror\n - tutorial/toh-pt6#herodetailcomponent\n - tutorial/toh-pt6#heroescomponent\n - tutorial/toh-pt6#herosearchcomponent\n - tutorial/toh-pt6#herosearchcomponent-생성하기\n - tutorial/toh-pt6#herosearchcomponent-클래스-수정하기\n - tutorial/toh-pt6#heroservice-inmemorydataservice-appmodule\n - tutorial/toh-pt6#heroserviceaddhero-추가하기\n - tutorial/toh-pt6#heroservicedeletehero-추가하기\n - tutorial/toh-pt6#heroservicesearchheroes\n - tutorial/toh-pt6#heroserviceupdatehero-추가하기\n - tutorial/toh-pt6#http\n - tutorial/toh-pt6#http-메소드는-데이터를-하나만-반환합니다\n - tutorial/toh-pt6#http-서비스-추가하기\n - tutorial/toh-pt6#httpclient-로-히어로-목록-가져오기\n - tutorial/toh-pt6#httpclientget-함수는-응답으로-받은-데이터를-반환합니다\n - tutorial/toh-pt6#id로-히어로-데이터-가져오기\n - tutorial/toh-pt6#import-heroes\n - tutorial/toh-pt6#observable-확인하기\n - tutorial/toh-pt6#rxjs-연산자-체이닝하기\n - tutorial/toh-pt6#search-pipe\n - tutorial/toh-pt6#searchterms-rxjs-subject\n - tutorial/toh-pt6#대시보드에-검색-기능-추가하기\n - tutorial/toh-pt6#데이터-서버-목킹하기\n - tutorial/toh-pt6#동작-확인하기\n - tutorial/toh-pt6#새-히어로-추가하기\n - tutorial/toh-pt6#에러-처리하기\n - tutorial/toh-pt6#이름으로-검색하기\n - tutorial/toh-pt6#정리\n - tutorial/toh-pt6#최종코드-리뷰\n - tutorial/toh-pt6#히어로-데이터-수정하기\n - tutorial/toh-pt6#히어로-데이터와-http\n - tutorial/toh-pt6#히어로-제거하기\n - http://localhost:4800/tutorial/toh-pt6#heroes-and-http\n - http://www.learnrxjs.io/operators/transformation/switchmap.html\n - https://github.com/angular/angular/edit/master/aio/content/tutorial/toh-pt6.md?message=docs%3A%20describe%20your%20change...\n - https://github.com/angular/in-memory-web-api\n-->"
}