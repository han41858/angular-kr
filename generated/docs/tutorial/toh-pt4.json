{
  "id": "tutorial/toh-pt4",
  "title": "서비스",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/tutorial/toh-pt4.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Services\n-->\n<h1 id=\"서비스\">서비스<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#서비스\"><i class=\"material-icons\">link</i></a></h1>\n<!--\nThe Tour of Heroes `HeroesComponent` is currently getting and displaying fake data.\n\nAfter the refactoring in this tutorial, `HeroesComponent` will be lean and focused on supporting the view.\nIt will also be easier to unit-test with a mock service.\n-->\n<p><code>HeroesComponent</code>가 표시하는 데이터는 아직 가짜 데이터입니다.</p>\n<p>이번 튜토리얼에서는 <code>HeroesComponent</code>가 화면을 표시하는 로직에만 집중하도록 가볍게 리팩토링해 봅시다.\n이렇게 수정하면 목 서비스를 사용할 수 있기 때문에 컴포넌트에 유닛 테스트를 적용하기도 쉬워집니다.</p>\n<!--\n## Why services\n-->\n<h2 id=\"왜-서비스를-사용할까요\">왜 서비스를 사용할까요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#왜-서비스를-사용할까요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nComponents shouldn't fetch or save data directly and they certainly shouldn't knowingly present fake data.\nThey should focus on presenting data and delegate data access to a service.\n\nIn this tutorial, you'll create a `HeroService` that all application classes can use to get heroes.\nInstead of creating that service with `new`, \nyou'll rely on Angular [*dependency injection*](guide/dependency-injection) \nto inject it into the `HeroesComponent` constructor.\n-->\n<p>컴포넌트는 데이터를 직접 가져오거나 직접 저장하도록 요청하지 않는 것이 좋습니다. 그리고 사용하는 데이터가 실제 데이터인지 가짜 데이터인지 알 필요도 없습니다.\n컴포넌트는 데이터를 표시하는 것에만 집중하는 것이 좋으며, 데이터를 처리하는 로직은 서비스에게 맡겨두는 것이 좋습니다.</p>\n<p>이 튜토리얼에서는 히어로의 데이터를 처리하는 <code>HeroService</code>를 만들어 봅니다.\n그런데 이 서비스는 <code>new</code> 키워드로 인스턴스를 직접 생성하지 않습니다.\n이 서비스는 Angular가 제공하는 <a href=\"guide/dependency-injection\"><em>의존성 주입</em></a> 메커니즘에 따라 <code>HeroesComponent</code>의 생성자로 주입될 것입니다.</p>\n<!--\nServices are a great way to share information among classes that _don't know each other_.\nYou'll create a `MessageService` and inject it in two places:\n\n1. in `HeroService` which uses the service to send a message.\n2. in `MessagesComponent` which displays that message.\n-->\n<p>여러 클래스에 사용되는 정보를 공유하려면 서비스를 사용하는 방법이 가장 좋습니다.\n<code>MessageService</code>를 만들고 다음 두 곳에 이 서비스를 주입해서 활용해 봅시다:</p>\n<ol>\n<li><code>HeroService</code>가 메시지를 보낼 때 사용합니다.</li>\n<li>이 메시지는 <code>MessagesComponent</code>가 화면에 표시합니다.</li>\n</ol>\n<!--\n## Create the _HeroService_\n-->\n<h2 id=\"heroservice-생성하기\"><em>HeroService</em> 생성하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#heroservice-생성하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nUsing the Angular CLI, create a service called `hero`.\n-->\n<p>Angular CLI로 다음 명령을 실행해서 <code>hero</code> 서비스를 생성합니다.</p>\n<code-example language=\"sh\" class=\"code-shell\">\n  ng generate service hero\n</code-example>\n<!--\nThe command generates skeleton `HeroService` class in `src/app/hero.service.ts`\nThe `HeroService` class should look like the following example.\n-->\n<p>이 명령을 실행하면 <code>src/app/hero.service.ts</code> 파일에 <code>HeroService</code> 클래스가 생성됩니다.\n이 때 Angular CLI가 만든 <code>HeroService</code> 클래스는 다음과 같습니다.</p>\n<!--\n<code-example path=\"toh-pt4/src/app/hero.service.1.ts\" region=\"new\"\n header=\"src/app/hero.service.ts (new service)\" linenums=\"false\">\n-->\n<code-example path=\"toh-pt4/src/app/hero.service.1.ts\" region=\"new\" header=\"src/app/hero.service.ts (새로 만든 서비스)\" linenums=\"false\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class HeroService {\n\n  constructor() { }\n\n}\n\n</code-example>\n<!--\n### _@Injectable()_ services\n-->\n<h3 id=\"injectable-서비스\"><em>@Injectable()</em> 서비스<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#injectable-서비스\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nNotice that the new service imports the Angular `Injectable` symbol and annotates\nthe class with the `@Injectable()` decorator. This marks the class as one that participates in the _dependency injection system_. The `HeroService` class is going to provide an injectable service, and it can also have its own injected dependencies.\nIt doesn't have any dependencies yet, but [it will soon](#inject-message-service).\n\nThe `@Injectable()` decorator accepts a metadata object for the service, the same way the `@Component()` decorator did for your component classes. \n-->\n<p>Angular CLI로 만든 서비스 클래스에는 <code><a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> 심볼이 로드되어 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 데코레이터로 사용되었습니다.\n이 구문은 이 클래스가 <em>의존성 주입 시스템</em> 에 포함되는 클래스라고 선언하는 구문입니다.\n그래서 <code>HeroService</code> 클래스는 의존성으로 주입될 수 있으며 이 클래스도 의존성을 주입받을 수 있습니다.\n아직까지는 이 클래스에 주입되는 의존성 객체가 없지만 <a href=\"tutorial/toh-pt4#inject-message-service\">곧</a> 추가될 것입니다.</p>\n<p><code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 데코레이터는 서비스를 정의하는 메타데이터 객체를 인자로 받습니다.\n<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 데코레이터에 메타데이터를 사용했던 것과 같은 방식입니다.</p>\n<!--\n### Get hero data\n-->\n<h3 id=\"히어로-데이터-가져오기\">히어로 데이터 가져오기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#히어로-데이터-가져오기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe `HeroService` could get hero data from anywhere&mdash;a web service, local storage, or a mock data source. \n\nRemoving data access from components means you can change your mind about the implementation anytime, without touching any components.\nThey don't know how the service works.\n\nThe implementation in _this_ tutorial will continue to deliver _mock heroes_.\n\nImport the `Hero` and `HEROES`.\n-->\n<p><code>HeroService</code>는 —웹 서비스나 로컬 스토리지, 목 데이터 소스 등— 어디에서든 히어로 데이터를 가져올 수 있습니다.</p>\n<p>컴포넌트에서 데이터에 접근하는 로직을 제거하면 컴포넌트는 데이터를 표시하는 목적에만 집중할 수 있으며, 데이터를 가져오는 곳이 변경되더라도 컴포넌트가 이 내용을 신경쓰지 않아도 됩니다.</p>\n<p>이 문서에서는 이전과 마찬가지로 <em>목 데이터</em> 를 가져오도록 구현해 봅시다.</p>\n<p><code>HeroService</code>에 <code>Hero</code> 심볼과 <code>HEROES</code> 배열을 로드합니다.</p>\n<code-example path=\"toh-pt4/src/app/hero.service.ts\" region=\"import-heroes\">\nimport { Hero } from './hero';\nimport { HEROES } from './mock-heroes';\n\n</code-example>\n<!--\nAdd a `getHeroes` method to return the _mock heroes_.\n-->\n<p>그리고 <em>목 히어로 데이터</em> 를 반환하는 <code>getHeroes</code> 메소드를 추가합니다.</p>\n<code-example path=\"toh-pt4/src/app/hero.service.1.ts\" region=\"getHeroes\">\ngetHeroes(): Hero[] {\n  return HEROES;\n}\n\n</code-example>\n<a id=\"provide\"></a>\n<!--\n## Provide the `HeroService`\n-->\n<h2 id=\"heroservice-등록하기\"><code>HeroService</code> 등록하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#heroservice-등록하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nYou must make the `HeroService` available to the dependency injection system \nbefore Angular can _inject_ it into the `HeroesComponent`, \nas you will do [below](#inject). You do this by registering a _provider_. A provider is something that can create or deliver a service; in this case, it instantiates the `HeroService` class to provide the service.\n\nNow, you need to make sure that the `HeroService` is registered as the provider of this service. \nYou are registering it with an _injector_, which is the object that is responsible for choosing and injecting the provider where it is required. \n-->\n<p><code>HeroService</code>를 의존성 주입 시스템에 사용하려면 Angular가 이 서비스를 <code>HeroesComponent</code>에 <a href=\"tutorial/toh-pt4#inject\"><em>주입</em></a> 할 수 있어야 합니다.\n그리고 서비스를 의존성으로 주입하려면 이 서비스에 대한 <em>프로바이더 (provider)</em> 를 등록해야 합니다.\n프로바이더는 서비스의 인스턴스를 생성하거나 어딘가에서 가져오는 역할을 합니다.\n이 예제에서는 프로바이더가 <code>HeroService</code> 클래스의 인스턴스를 생성합니다.</p>\n<p>그래서 <code>HeroService</code>는 프로바이더를 사용해서 등록해야 합니다.\n프로바이더는 서비스를 <em>인젝터</em> 에 등록하는데, 인젝터는 요청받은 객체를 확인하고 요청받은 곳에 의존성으로 주입하는 역할을 합니다.</p>\n<!--\nBy default, the Angular CLI command `ng generate service` registers a provider with the _root injector_ for your service by including provider metadata in the `@Injectable` decorator. \n\nIf you look at the `@Injectable()` statement right before the `HeroService` class definition, you can see that the `providedIn` metadata value is 'root':    \n-->\n<p>기본적으로 Angular CLI로 <code>ng generate service</code> 명령을 실행하면 새로 만드는 서비스를 <em>최상위 인젝터</em> 에 등록하도록 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 데코레이터가 생성됩니다.</p>\n<p>그래서 방금 전에 만들었던 <code>HeroService</code> 클래스에 사용된 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 구문을 살펴보면 <code><a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a></code> 메타데이터의 값이 <code>root</code>로 지정된 것을 확인할 수 있습니다:</p>\n<code-example>\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\n</code-example>\n<!--\nWhen you provide the service at the root level, Angular creates a single, shared instance of `HeroService` and injects into any class that asks for it. \nRegistering the provider in the `@Injectable` metadata also allows Angular to optimize an app by removing the service if it turns out not to be used after all. \n-->\n<p>서비스가 최상위 인젝터에 등록되면 Angular는 <code>HeroService</code>의 인스턴스를 하나만 생성하며, 이 클래스가 주입되는 모든 곳에서 같은 인스턴스를 공유합니다.\n그리고 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 데코레이터는 이 데코레이터가 등록된 클래스가 실제로 사용되지 않으면 이 클래스를 최종 빌드 결과물에서 제거하는 대상으로 등록하는 역할도 합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nTo learn more about providers, see the [Providers section](guide/providers).\nTo learn more about injectors, see the [Dependency Injection guide](guide/dependency-injection).\n-->\n<p>프로바이더에 대해 자세하게 알아보려면 <a href=\"guide/providers\">프로바이더</a> 문서를 참고하세요.\n인젝터에 대해 자세하게 알아보려면 <a href=\"guide/dependency-injection\">Angular의 의존성 주입</a> 문서를 참고하세요.</p>\n</div>\n<!--\nThe `HeroService` is now ready to plug into the `HeroesComponent`.\n-->\n<p><code>HeroService</code>는 이제 <code>HeroesComponent</code>에 주입할 준비가 되었습니다.</p>\n<div class=\"alert is-important\">\n<!--\nThis is an interim code sample that will allow you to provide and use the `HeroService`.  At this point, the code will differ from the `HeroService` in the [\"final code review\"](#final-code-review).\n-->\n<p>지금까지 작성한 코드는 <code>HeroService</code>를 프로바이더로 등록하기 위한 임시 코드입니다.\n<a href=\"tutorial/toh-pt4#final-code-review\">최종코드 리뷰</a>와는 조금 다릅니다.</p>\n</div>\n<!--\n## Update `HeroesComponent`\n-->\n<h2 id=\"heroescomponent-수정하기\"><code>HeroesComponent</code> 수정하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#heroescomponent-수정하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nOpen the `HeroesComponent` class file.\n\nDelete the `HEROES` import, because you won't need that anymore.\nImport the `HeroService` instead.\n-->\n<p><code>HeroesComponent</code> 클래스 파일을 엽니다.</p>\n<p>이 파일에서 <code>HEROES</code>를 로드했던 부분을 제거하고 <code>HeroService</code>를 로드합니다.</p>\n<!--\n<code-example path=\"toh-pt4/src/app/heroes/heroes.component.ts\" header=\"src/app/heroes/heroes.component.ts (import HeroService)\" region=\"hero-service-import\">\n-->\n<code-example path=\"toh-pt4/src/app/heroes/heroes.component.ts\" header=\"src/app/heroes/heroes.component.ts (HeroService 로드하기)\" region=\"hero-service-import\">\nimport { HeroService } from '../hero.service';\n\n</code-example>\n<!--\nReplace the definition of the `heroes` property with a simple declaration.\n-->\n<p>그리고 <code>heroes</code> 프로퍼티 값을 할당하는 부분을 다음과 같이 수정합니다.</p>\n<code-example path=\"toh-pt4/src/app/heroes/heroes.component.ts\" region=\"heroes\">\nheroes: Hero[];\n\n</code-example>\n<a id=\"inject\"></a>\n<!--\n### Inject the `HeroService`\n-->\n<h3 id=\"heroservice-주입하기\"><code>HeroService</code> 주입하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#heroservice-주입하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAdd a private `heroService` parameter of type `HeroService` to the constructor.\n-->\n<p>생성자에 <code>HeroService</code> 타입의 <code>heroService</code> 인자를 선언하고 이 인자를 <code>private</code>으로 지정합니다.</p>\n<code-example path=\"toh-pt4/src/app/heroes/heroes.component.ts\" region=\"ctor\">\nconstructor(private heroService: HeroService) { }\n\n</code-example>\n<!--\nThe parameter simultaneously defines a private `heroService` property and identifies it as a `HeroService` injection site.\n\nWhen Angular creates a `HeroesComponent`, the [Dependency Injection](guide/dependency-injection) system\nsets the `heroService` parameter to the singleton instance of `HeroService`. \n-->\n<p>이렇게 작성하면 <code>heroService</code> 인자를 클래스 프로퍼티로 선언하면서 <code>HeroService</code> 타입의 의존성 객체가 주입되기를 요청한다는 것을 의미합니다.</p>\n<p>그러면 Angular가 <code>HeroesComponent</code>를 생성할 때 <a href=\"guide/dependency-injection\">의존성 주입</a> 시스템이 <code>HeroService</code>의 인스턴스를 찾아서 <code>heroService</code> 라는 인자로 전달할 것입니다.</p>\n<!--\n### Add _getHeroes()_\n-->\n<h3 id=\"getheroes-추가하기\"><em>getHeroes()</em> 추가하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#getheroes-추가하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nCreate a function to retrieve the heroes from the service.\n-->\n<p>이제 서비스에서 히어로 데이터를 전달하는 함수를 정의해 봅시다.</p>\n<code-example path=\"toh-pt4/src/app/heroes/heroes.component.1.ts\" region=\"getHeroes\">\ngetHeroes(): void {\n  this.heroes = this.heroService.getHeroes();\n}\n\n</code-example>\n<a id=\"oninit\"></a>\n<!--\n### Call it in `ngOnInit`\n-->\n<h3 id=\"ngoninit에서-서비스-호출하기\"><code>ngOnInit</code>에서 서비스 호출하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#ngoninit에서-서비스-호출하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nWhile you could call `getHeroes()` in the constructor, that's not the best practice.\n\nReserve the constructor for simple initialization such as wiring constructor parameters to properties.\nThe constructor shouldn't _do anything_.\nIt certainly shouldn't call a function that makes HTTP requests to a remote server as a _real_ data service would.\n\nInstead, call `getHeroes()` inside the [*ngOnInit lifecycle hook*](guide/lifecycle-hooks) and\nlet Angular call `ngOnInit` at an appropriate time _after_ constructing a `HeroesComponent` instance.\n-->\n<p>서비스에 구현한 <code>getHeroes()</code> 함수는 컴포넌트 클래스에서도 호출할 수 있지만, 이 방법은 최선이 아닙니다.</p>\n<p>컴포넌트의 생성자는 생성자로 받은 인자를 클래스 프로퍼티로 연결하는 정도로 간단하게 유지하는 것이 좋습니다.\n생성자에는 이 외의 로직이 <em>들어가지 않는 것이 좋습니다</em>.\n리모트 서버로 HTTP 요청을 보내는 로직도 물론 들어가지 않는 것이 좋습니다.</p>\n<p><code>getHeroes()</code> 함수는 <a href=\"guide/lifecycle-hooks\"><em>ngOnInit 라이프싸이클 후킹 함수</em></a>에서 실행하는 것이 좋습니다.\n<code>ngOnInit</code> 함수는 Angular가 <code>HeroesComponent</code>의 인스턴스를 생성한 <em>직후에</em> 실행되는 함수입니다.</p>\n<code-example path=\"toh-pt4/src/app/heroes/heroes.component.ts\" region=\"ng-on-init\">\nngOnInit() {\n  this.getHeroes();\n}\n\n</code-example>\n<!--\n### See it run\n-->\n<h3 id=\"동작-확인하기\">동작 확인하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#동작-확인하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAfter the browser refreshes, the app should run as before, \nshowing a list of heroes and a hero detail view when you click on a hero name.\n-->\n<p>브라우저가 갱신되고 나면 앱이 이전과 동일하게 동작할 것입니다.\n화면에 히어로의 목록이 표시되고, 사용자가 히어로 중 하나의 이름을 클릭하면 해당 히어로의 상세정보도 화면에 표시됩니다.</p>\n<!--\n## Observable data\n-->\n<h2 id=\"옵저버블-데이터\">옵저버블 데이터<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#옵저버블-데이터\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe `HeroService.getHeroes()` method has a _synchronous signature_,\nwhich implies that the `HeroService` can fetch heroes synchronously.\nThe `HeroesComponent` consumes the `getHeroes()` result \nas if heroes could be fetched synchronously.\n-->\n<p>위에서 작성한 <code>HeroService.getHeroes()</code> 메소드는 <em>동기 방식으로 동작하기 때문에</em>, 이 함수의 실행 결과는 바로 반환됩니다.\n그래서 <code>HeroesComponent</code>의 <code>heroes</code> 프로퍼티에 값이 할당될 때도 동기 방식으로 할당됩니다.</p>\n<code-example path=\"toh-pt4/src/app/heroes/heroes.component.1.ts\" region=\"get-heroes\">\nthis.heroes = this.heroService.getHeroes();\n\n</code-example>\n<!--\nThis will not work in a real app.\nYou're getting away with it now because the service currently returns _mock heroes_.\nBut soon the app will fetch heroes from a remote server, \nwhich is an inherently _asynchronous_ operation.\n\nThe `HeroService` must wait for the server to respond,\n`getHeroes()` cannot return immediately with hero data,\nand the browser will not block while the service waits.\n-->\n<p>하지만 실제로 운영되는 앱에서 이런 방식을 사용하는 경우는 별로 없습니다.\n지금 작성한 코드는 <em>목 데이터</em> 를 가져오기 때문에 유효한 것입니다.\n애플리케이션은 리모트 서버에서 데이터를 가져오는 것이 일반적이기 때문에, <em>비동기</em> 동작을 처리해야 하는 경우가 대부분입니다.</p>\n<p>그래서 <code>HeroService.getHeroes()</code>는 서버의 응답을 기다려야 하며, 히어로 데이터를 즉시 반환할 수 없습니다.\n함수의 실행은 서버의 응답이 올 때까지 기다리지 않고 바로 종료됩니다.</p>\n<!--\n`HeroService.getHeroes()` must have an _asynchronous signature_ of some kind.\n\nIt can take a callback. It could return a `Promise`. It could return an `Observable`.\n\nIn this tutorial, `HeroService.getHeroes()` will return an `Observable`\nin part because it will eventually use the Angular `HttpClient.get` method to fetch the heroes\nand [`HttpClient.get()` returns an `Observable`](guide/http).\n-->\n<p>이런 경우에는 <code>HeroService.getHeroes()</code> 함수가 <em>비동기로 동작해야</em> 합니다.</p>\n<p>비동기 동작은 콜백 함수를 사용해서 처리할 수 있습니다. <code>Promise</code>를 반환하도록 처리할 수도 있습니다. 그리고 <code>Observable</code>을 반환할 수도 있습니다.</p>\n<p>이 튜토리얼에서는 <code>HeroService.getHeroes()</code> 함수가 <code>Observable</code>을 반환하도록 구현해 봅시다.\nAngular가 제공하는 <a href=\"guide/http\"><code>HttpClient.get</code> 메소드는 <code>Observable</code>을 반환하기 때문에</a> 이렇게 구현하는 것이 가장 자연스럽습니다.</p>\n<!--\n### Observable _HeroService_\n-->\n<h3 id=\"옵저버블-heroservice\">옵저버블 <em>HeroService</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#옵저버블-heroservice\"><i class=\"material-icons\">link</i></a></h3>\n<!--\n`Observable` is one of the key classes in the [RxJS library](http://reactivex.io/rxjs/).\n\nIn a [later tutorial on HTTP](tutorial/toh-pt6), you'll learn that Angular's `HttpClient` methods return RxJS `Observable`s.\nIn this tutorial, you'll simulate getting data from the server with the RxJS `of()` function.\n\nOpen the `HeroService` file and import the `Observable` and `of` symbols from RxJS.\n-->\n<p><code>Observable</code>은 <a href=\"http://reactivex.io/rxjs/\">RxJS 라이브러리</a>가 제공하는 클래스 중 가장 중요한 클래스입니다.</p>\n<p><a href=\"tutorial/toh-pt6\">이후에 HTTP에 대해서 알아볼 때</a> Angular의 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 클래스가 제공하는 메소드는 모두 RxJS가 제공하는 <code>Observable</code> 타입을 반환한다는 것을 다시 한 번 살펴볼 것입니다.\n이 튜토리얼에서는 리모트 서버를 사용하지 않고 RxJS의 <code>of()</code> 함수로 데이터를 즉시 반환해 봅시다.</p>\n<!--\n<code-example path=\"toh-pt4/src/app/hero.service.ts\" \nheader=\"src/app/hero.service.ts (Observable imports)\" region=\"import-observable\">\n-->\n<code-example path=\"toh-pt4/src/app/hero.service.ts\" header=\"src/app/hero.service.ts (Observable 로드하기)\" region=\"import-observable\">\nimport { Observable, of } from 'rxjs';\n\n</code-example>\n<!--\nReplace the `getHeroes` method with this one.\n-->\n<p><code>getHeroes</code> 메소드를 다음과 같이 수정합니다.</p>\n<code-example path=\"toh-pt4/src/app/hero.service.ts\" region=\"getHeroes-1\">\ngetHeroes(): Observable&#x3C;Hero[]> {\n  return of(HEROES);\n}\n\n</code-example>\n<!--\n`of(HEROES)` returns an `Observable<Hero[]>` that emits  _a single value_, the array of mock heroes.\n-->\n<p><code>of(HEROES)</code>는 히어로 목 데이터를 <code>Observable&#x3C;Hero[]></code> 타입으로 <em>한번에</em> 반환합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nIn the [HTTP tutorial](tutorial/toh-pt6), you'll call `HttpClient.get<Hero[]>()` which also returns an `Observable<Hero[]>` that emits  _a single value_, an array of heroes from the body of the HTTP response.\n-->\n<p>이후에 살펴볼 <a href=\"tutorial/toh-pt6\">HTTP 튜토리얼</a>에서도 <code>HttpClient.get&#x3C;Hero[]></code>는 이번 예제와 동일하게 <code>Observable&#x3C;Hero[]></code> 타입을 반환하기 때문에, HTTP 응답으로 받은 히어로의 데이터 배열은 <em>한번에</em> 반환됩니다.</p>\n</div>\n<!--\n### Subscribe in _HeroesComponent_\n-->\n<h3 id=\"heroescomponent-에서-옵저버블-구독하기\"><em>HeroesComponent</em> 에서 옵저버블 구독하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#heroescomponent-에서-옵저버블-구독하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe `HeroService.getHeroes` method used to return a `Hero[]`.\nNow it returns an `Observable<Hero[]>`.\n\nYou'll have to adjust to that difference in `HeroesComponent`.\n\nFind the `getHeroes` method and replace it with the following code\n(shown side-by-side with the previous version for comparison)\n-->\n<p>이전까지 <code>HeroService.getHeroes</code> 메소드는 <code>Hero[]</code> 타입을 반환했지만 이제는 <code>Observable&#x3C;Hero[]></code> 타입을 반환합니다.</p>\n<p>그래서 <code>HeroesComponent</code>의 내용을 조금 수정해야 합니다.</p>\n<p><code>getHeroes</code> 메소드를 실행했던 부분을 찾아서 다음과 같이 변경합니다.\n이전에 작성했던 코드와 비교해 보세요.</p>\n<code-tabs>\n\n  <!--\n  <code-pane header=\"heroes.component.ts (Observable)\" path=\"toh-pt4/src/app/heroes/heroes.component.ts\" region=\"getHeroes\">\ngetHeroes(): void {\n  this.heroService.getHeroes()\n      .subscribe(heroes =&gt; this.heroes = heroes);\n}\n\n</code-pane>\n  -->\n  <code-pane header=\"heroes.component.ts (옵저버블을 사용하는 코드)\" path=\"toh-pt4/src/app/heroes/heroes.component.ts\" region=\"getHeroes\">\ngetHeroes(): void {\n  this.heroService.getHeroes()\n      .subscribe(heroes => this.heroes = heroes);\n}\n\n</code-pane>\n\n  <!--\n  <code-pane header=\"heroes.component.ts (Original)\" path=\"toh-pt4/src/app/heroes/heroes.component.1.ts\" region=\"getHeroes\">\ngetHeroes(): void {\n  this.heroes = this.heroService.getHeroes();\n}\n\n</code-pane>\n  -->\n  <code-pane header=\"heroes.component.ts (기존 코드)\" path=\"toh-pt4/src/app/heroes/heroes.component.1.ts\" region=\"getHeroes\">\ngetHeroes(): void {\n  this.heroes = this.heroService.getHeroes();\n}\n\n</code-pane>\n\n</code-tabs>\n<!--\n`Observable.subscribe()` is the critical difference.\n\nThe previous version assigns an array of heroes to the component's `heroes` property.\nThe assignment occurs _synchronously_, as if the server could return heroes instantly\nor the browser could freeze the UI while it waited for the server's response.\n-->\n<p><code>Observable.subscribe()</code>를 사용한 부분이 가장 중요합니다.</p>\n<p>이전 버전에서는 히어로의 데이터를 배열로 가져와서 컴포넌트의 <code>heroes</code> 프로퍼티에 직접 할당했습니다.\n이 동작은 <em>동기 방식으로</em> 동작하기 때문에 서비스가 데이터를 즉시 반환하거나 서버의 응답이 동기 방식으로 전달될 때에만 제대로 동작합니다.</p>\n<!--\nThat _won't work_ when the `HeroService` is actually making requests of a remote server.\n\nThe new version waits for the `Observable` to emit the array of heroes&mdash; \nwhich could happen now or several minutes from now.\nThen `subscribe` passes the emitted array to the callback,\nwhich sets the component's `heroes` property.\n\nThis asynchronous approach _will work_ when\nthe `HeroService` requests heroes from the server.\n-->\n<p>하지만 <code>HeroService</code>는 리모트 서버에 요청을 보내는 방식으로 동작하는 경우에는 이 로직이 제대로 <em>동작하지 않습니다</em>.</p>\n<p>수정한 버전의 코드는 서비스의 함수가 <code>Observable</code> 타입을 반환하는데, 반환 시점은 함수를 실행한 직후일 수도 있고 몇 분이 지난 후일 수도 있습니다.\n서버의 응답이 언제 도착하는지와 관계없이, 이 응답이 도착했을 때 <code>subscribe</code>가 서버에서 받은 응답을 콜백 함수로 전달하고, 컴포넌트는 이렇게 받은 히어로 데이터를 <code>heroes</code> 프로퍼티에 할당합니다.</p>\n<p><code>HeroService</code>가 실제로 서버에 요청을 보낸다면 이렇게 비동기 방식으로 구현해야 <em>제대로 동작합니다</em>.</p>\n<!--\n## Show messages\n-->\n<h2 id=\"메시지-표시하기\">메시지 표시하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#메시지-표시하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nIn this section you will \n\n* add a `MessagesComponent` that displays app messages at the bottom of the screen.\n* create an injectable, app-wide `MessageService` for sending messages to be displayed\n* inject `MessageService` into the `HeroService`\n* display a message when `HeroService` fetches heroes successfully.\n-->\n<p>이번 섹션에서는 다음 내용에 대해 다룹니다.</p>\n<ul>\n<li>애플리케이션에서 발생하는 메시지를 화면 아래쪽에 표시하기 위해 <code>MessagesComponent</code>를 추가해 봅니다.</li>\n<li>앱 전역 범위에 의존성으로 주입할 수 있는 <code>MessageService</code>를 만들고, 이 서비스로 메시지를 보내봅니다.</li>\n<li><code>MessageService</code>를 <code>HeroService</code>에 주입해 봅니다.</li>\n<li><code>HeroService</code>가 서버에서 가져온 히어로 데이터를 화면에 표시해 봅니다.</li>\n</ul>\n<!--\n### Create _MessagesComponent_\n-->\n<h3 id=\"messagescomponent-생성하기\"><em>MessagesComponent</em> 생성하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#messagescomponent-생성하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nUse the CLI to create the `MessagesComponent`.\n-->\n<p>Angular CLI로 다음 명령을 실행해서 <code>MessagesComponent</code>를 생성합니다.</p>\n<code-example language=\"sh\" class=\"code-shell\">\n  ng generate component <a href=\"api/service-worker/SwPush#messages\" class=\"code-anchor\">messages</a>\n</code-example>\n<!--\nThe CLI creates the component files in the `src/app/messages` folder and declares the `MessagesComponent` in `AppModule`.\n\nModify the `AppComponent` template to display the generated `MessagesComponent`\n-->\n<p>그러면 Angular CLI가 <code>src/app/<a href=\"api/service-worker/SwPush#messages\" class=\"code-anchor\">messages</a></code> 폴더에 컴포넌트 파일들을 생성하고 <code>AppModule</code>에 <code>MessagesComponent</code>를 자동으로 등록할 것입니다.</p>\n<p>이렇게 만든 <code>MessagesComponent</code>를 화면에 표시하기 위해 <code>AppComponent</code> 템플릿을 다음과 같이 수정합니다.</p>\n<code-example header=\"/src/app/app.component.html\" path=\"toh-pt4/src/app/app.component.html\">\n&#x3C;h1>{{title}}&#x3C;/h1>\n&#x3C;app-heroes>&#x3C;/app-heroes>\n&#x3C;app-messages>&#x3C;/app-messages>\n\n\n</code-example>\n<!--\nYou should see the default paragraph from `MessagesComponent` at the bottom of the page.\n-->\n<p>브라우저가 갱신되면 화면 아래쪽에 <code>MessagesComponent</code>가 표시되는 것을 확인할 수 있습니다.</p>\n<!--\n### Create the _MessageService_\n-->\n<h3 id=\"messageservice-생성하기\"><em>MessageService</em> 생성하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#messageservice-생성하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nUse the CLI to create the `MessageService` in `src/app`. \n-->\n<p><code>src/app</code> 폴더에서 Angular CLI로 다음 명령을 실행해서 <code>MessageService</code>를 생성합니다.</p>\n<code-example language=\"sh\" class=\"code-shell\">\n  ng generate service <a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>\n</code-example>\n<!--\nOpen `MessageService` and replace its contents with the following.\n-->\n<p>그리고 이렇게 만든 <code>MessageService</code> 파일을 열어서 다음 내용으로 수정합니다.</p>\n<code-example header=\"/src/app/message.service.ts\" path=\"toh-pt4/src/app/message.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class MessageService {\n  <a href=\"api/service-worker/SwPush#messages\" class=\"code-anchor\">messages</a>: string[] = [];\n\n  add(<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>: string) {\n    this.messages.push(<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>);\n  }\n\n  clear() {\n    this.messages = [];\n  }\n}\n\n\n</code-example>\n<!--\nThe service exposes its cache of `messages` and two methods: one to `add()` a message to the cache and another to `clear()` the cache.\n-->\n<p>이 서비스는 <code><a href=\"api/service-worker/SwPush#messages\" class=\"code-anchor\">messages</a></code> 프로퍼티에 메시지를 캐싱하는데, <code>add()</code> 메소드는 프로퍼티에 메시지를 추가하고 <code><a href=\"api/forms/FormArray#clear\" class=\"code-anchor\">clear()</a></code> 메소드는 캐시를 비우는 역할을 합니다.</p>\n<a id=\"inject-message-service\"></a>\n<!--\n### Inject it into the `HeroService`\n-->\n<h3 id=\"heroservice에-의존성으로-주입하기\"><code>HeroService</code>에 의존성으로 주입하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#heroservice에-의존성으로-주입하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nRe-open the `HeroService` and import the `MessageService`.\n-->\n<p><code>HeroService</code> 파일을 다시 열고 <code>MessageService</code>를 로드합니다.</p>\n<!--\n<code-example\n  header = \"/src/app/hero.service.ts (import MessageService)\"\n  path=\"toh-pt4/src/app/hero.service.ts\" region=\"import-message-service\">\n-->\n<code-example header=\"/src/app/hero.service.ts (MessageService 로드하기)\" path=\"toh-pt4/src/app/hero.service.ts\" region=\"import-message-service\">\nimport { MessageService } from './message.service';\n\n</code-example>\n<!--\nModify the constructor with a parameter that declares a private `messageService` property.\nAngular will inject the singleton `MessageService` into that property \nwhen it creates the `HeroService`.\n-->\n<p>그리고 <code>HeroService</code>의 생성자를 수정해서 <code>messageService</code> 프로퍼티를 <code>private</code>으로 선언하도록 합니다.\n그러면 <code>HeroService</code>가 생성될 때 Angular가 <code>MessageService</code>의 싱글턴 인스턴스를 의존성으로 주입할 것입니다.</p>\n<code-example path=\"toh-pt4/src/app/hero.service.ts\" region=\"ctor\">\nconstructor(private messageService: MessageService) { }\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\nThis is a typical \"*service-in-service*\" scenario:\nyou inject the `MessageService` into the `HeroService` which is injected into the `HeroesComponent`.\n-->\n<p>\"<em>서비스 안에 서비스</em>\"가 존재하는 경우는 이렇게 구현합니다.\n<code>MessageService</code>는 <code>HeroService</code>에 의존성으로 주입되고, <code>HeroService</code>는 다시 <code>HeroesComponent</code>에 의존성으로 주입됩니다.</p>\n</div>\n<!--\n### Send a message from `HeroService`\n-->\n<h3 id=\"heroservice에서-메시지-보내기\"><code>HeroService</code>에서 메시지 보내기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#heroservice에서-메시지-보내기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nModify the `getHeroes` method to send a message when the heroes are fetched.\n-->\n<p><code>getHeroes</code> 메소드에서 히어로 데이터를 받아온 뒤에 메시지를 보내도록 다음과 같이 수정합니다.</p>\n<code-example path=\"toh-pt4/src/app/hero.service.ts\" region=\"getHeroes\">\ngetHeroes(): Observable&#x3C;Hero[]> {\n  // TODO: 메시지는 히어로 데이터를 가져온 <a href=\"\" class=\"code-anchor\">_</a>후에<a href=\"\" class=\"code-anchor\">_</a> 보내야 합니다.\n  this.messageService.add('HeroService: fetched heroes');\n  return of(HEROES);\n}\n\n</code-example>\n<!--\n### Display the message from `HeroService`\n-->\n<h3 id=\"heroservice에서-받은-메시지-표시하기\"><code>HeroService</code>에서 받은 메시지 표시하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#heroservice에서-받은-메시지-표시하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe `MessagesComponent` should display all messages, \nincluding the message sent by the `HeroService` when it fetches heroes.\n\nOpen `MessagesComponent` and import the `MessageService`.\n-->\n<p><code>MessagesComponent</code>는 <code>HeroService</code>가 서버에서 히어로 데이터를 가져왔을 때 보냈던 메시지와 같이, <code>MessagesService</code>가 받은 모든 메시지를 표시하려고 합니다.</p>\n<p><code>MessagesComponent</code>를 열어서 <code>MessageService</code>를 로드합니다.</p>\n<!--\n<code-example\n  header = \"/src/app/messages/messages.component.ts (import MessageService)\"\n  path=\"toh-pt4/src/app/messages/messages.component.ts\" region=\"import-message-service\">\n-->\n<code-example header=\"/src/app/messages/messages.component.ts (MessageService 로드하기)\" path=\"toh-pt4/src/app/messages/messages.component.ts\" region=\"import-message-service\">\nimport { MessageService } from '../message.service';\n\n</code-example>\n<!--\nModify the constructor with a parameter that declares a **public** `messageService` property.\nAngular will inject the singleton `MessageService` into that property \nwhen it creates the `MessagesComponent`.\n-->\n<p><code>MessagesComponent</code>의 생성자를 수정해서 <code>messageService</code> 프로퍼티를 <strong>public</strong>으로 할당하도록 다음과 같이 수정합니다.\n이렇게 작성하면 Angular가 <code>MessagesComponent</code>의 인스턴스를 생성할 때 <code>MessageService</code>의 싱글턴 인스턴스를 이 프로퍼티로 전달할 것입니다.</p>\n<code-example path=\"toh-pt4/src/app/messages/messages.component.ts\" region=\"ctor\">\nconstructor(public messageService: MessageService) {}\n\n</code-example>\n<!--\nThe `messageService` property **must be public** because you're about to bind to it in the template.\n-->\n<p>이 때 <code>messageService</code> 프로퍼티는 템플릿에 바인딩되기 때문에 반드시 <strong>public으로 선언되어야</strong> 합니다.</p>\n<div class=\"alert is-important\">\n<!--\nAngular only binds to _public_ component properties.\n-->\n<p>Angular에서는 <em>public</em> 으로 선언된 컴포넌트 프로퍼티만 바인딩할 수 있습니다.</p>\n</div>\n<!--\n### Bind to the _MessageService_\n-->\n<h3 id=\"messageservice-바인딩하기\"><em>MessageService</em> 바인딩하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#messageservice-바인딩하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nReplace the CLI-generated `MessagesComponent` template with the following.\n-->\n<p>Angular CLI가 생성한 <code>MessagesComponent</code>의 템플릿을 다음과 같이 수정합니다.</p>\n<code-example header=\"src/app/messages/messages.component.html\" path=\"toh-pt4/src/app/messages/messages.component.html\">\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"messageService.messages.length\">\n\n  &#x3C;h2>Messages&#x3C;/h2>\n  &#x3C;button class=\"clear\"\n          (click)=\"messageService.clear()\">clear&#x3C;/button>\n  &#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>='let <a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a> of messageService.messages'> {{<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>}} &#x3C;/div>\n\n&#x3C;/div>\n\n\n</code-example>\n<!--\nThis template binds directly to the component's `messageService`.\n\n* The `*ngIf` only displays the messages area if there are messages to show.\n\n\n* An `*ngFor` presents the list of messages in repeated `<div>` elements.\n\n* An Angular [event binding](guide/template-syntax#event-binding) binds the button's click event\nto `MessageService.clear()`.\n-->\n<p>이 템플릿은 컴포넌트에 의존성으로 주입된 <code>messageService</code>를 직접 바인딩합니다.</p>\n<ul>\n<li>\n<p>메시지가 존재할 때만 컴포넌트의 내용을 표시하기 위해 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>를 사용했습니다.</p>\n</li>\n<li>\n<p>리스트에 존재하는 메시지마다 <code>&#x3C;div></code> 엘리먼트를 반복하기 위해 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>를 사용했습니다.</p>\n</li>\n<li>\n<p>버튼을 클릭했을 때 <code>MessageService.clear()</code> 함수를 실행하기 위해 <a href=\"guide/template-syntax#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%B0%94%EC%9D%B8%EB%94%A9\">이벤트 바인딩</a> 문법을 사용했습니다.</p>\n</li>\n</ul>\n<!--\nThe messages will look better when you add the private CSS styles to `messages.component.css`\nas listed in one of the [\"final code review\"](#final-code-review) tabs below.\n\nThe browser refreshes and the page displays the list of heroes.\nScroll to the bottom to see the message from the `HeroService` in the message area.\nClick the \"clear\" button and the message area disappears.\n-->\n<p><a href=\"tutorial/toh-pt4#final-code-review\">최종코드 리뷰</a>에서 확인할 수 있듯이, <code>messages.component.css</code> 파일에 컴포넌트 CSS 스타일을 지정하면 메시지를 좀 더 보기좋게 표시할 수 있습니다.</p>\n<p>브라우저가 갱신되면 화면에 히어로의 목록이 표시됩니다.\n이 화면에서 스크롤을 아래쪽으로 내리면 <code>HeroService</code>에서 보낸 메시지를 확인할 수 있습니다.\n그리고 \"clear\" 버튼을 클릭하면 메시지가 모두 지워지는 것도 확인할 수 있습니다.</p>\n<a id=\"final-code-review\"></a>\n<!--\n## Final code review\n-->\n<h2 id=\"최종코드-리뷰\">최종코드 리뷰<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#최종코드-리뷰\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nHere are the code files discussed on this page and your app should look like this <live-example></live-example>.\n-->\n<p>이 문서에서 다룬 코드의 내용은 다음과 같습니다. 이 코드는 <live-example></live-example>에서 직접 확인하거나 다운받아 확인할 수도 있습니다.</p>\n<code-tabs>\n\n  <code-pane header=\"src/app/hero.service.ts\" path=\"toh-pt4/src/app/hero.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\nimport { Observable, of } from 'rxjs';\n\nimport { Hero } from './hero';\nimport { HEROES } from './mock-heroes';\nimport { MessageService } from './message.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class HeroService {\n\n  constructor(private messageService: MessageService) { }\n\n  getHeroes(): Observable&#x3C;Hero[]> {\n    // TODO: 메시지는 히어로 데이터를 가져온 <a href=\"\" class=\"code-anchor\">_</a>후에<a href=\"\" class=\"code-anchor\">_</a> 보내야 합니다.\n    this.messageService.add('HeroService: fetched heroes');\n    return of(HEROES);\n  }\n}\n\n</code-pane>\n\n  <code-pane header=\"src/app/message.service.ts\" path=\"toh-pt4/src/app/message.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class MessageService {\n  <a href=\"api/service-worker/SwPush#messages\" class=\"code-anchor\">messages</a>: string[] = [];\n\n  add(<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>: string) {\n    this.messages.push(<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>);\n  }\n\n  clear() {\n    this.messages = [];\n  }\n}\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/heroes/heroes.component.ts\" path=\"toh-pt4/src/app/heroes/heroes.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\n\nimport { Hero } from '../hero';\nimport { HeroService } from '../hero.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-heroes',\n  templateUrl: './heroes.component.html',\n  <a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a>: ['./heroes.component.css']\n})\nexport class HeroesComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n\n  selectedHero: Hero;\n\n  heroes: Hero[];\n\n  constructor(private heroService: HeroService) { }\n\n  ngOnInit() {\n    this.getHeroes();\n  }\n\n  onSelect(hero: Hero): void {\n    this.selectedHero = hero;\n  }\n\n  getHeroes(): void {\n    this.heroService.getHeroes()\n        .subscribe(heroes => this.heroes = heroes);\n  }\n}\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/messages/messages.component.ts\" path=\"toh-pt4/src/app/messages/messages.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\nimport { MessageService } from '../message.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-messages',\n  templateUrl: './messages.component.html',\n  <a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a>: ['./messages.component.css']\n})\nexport class MessagesComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n\n  constructor(public messageService: MessageService) {}\n\n  ngOnInit() {\n  }\n\n}\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/messages/messages.component.html\" path=\"toh-pt4/src/app/messages/messages.component.html\">\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"messageService.messages.length\">\n\n  &#x3C;h2>Messages&#x3C;/h2>\n  &#x3C;button class=\"clear\"\n          (click)=\"messageService.clear()\">clear&#x3C;/button>\n  &#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>='let <a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a> of messageService.messages'> {{<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>}} &#x3C;/div>\n\n&#x3C;/div>\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/messages/messages.component.css\" path=\"toh-pt4/src/app/messages/messages.component.css\">\n/* MessagesComponent에 적용되는 CSS 스타일 */\nh2 {\n  color: red;\n  font-family: Arial, Helvetica, sans-serif;\n  font-weight: lighter;\n}\nbody {\n  margin: 2em;\n}\nbody, input[text], button {\n  color: crimson;\n  font-family: Cambria, Georgia;\n}\n\nbutton.clear {\n  font-family: Arial;\n  background-color: #eee;\n  border: none;\n  padding: 5px 10px;\n  border-radius: 4px;\n  cursor: pointer;\n  cursor: hand;\n}\nbutton:hover {\n  background-color: #cfd8dc;\n}\nbutton:disabled {\n  background-color: #eee;\n  color: #aaa;\n  cursor: auto;\n}\nbutton.clear {\n  color: #333;\n  margin-bottom: 12px;\n}\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/app.module.ts\" path=\"toh-pt4/src/app/app.module.ts\">\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { AppComponent } from './app.component';\nimport { HeroesComponent } from './heroes/heroes.component';\nimport { HeroDetailComponent } from './hero-detail/hero-detail.component';\nimport { MessagesComponent } from './<a href=\"api/service-worker/SwPush#messages\" class=\"code-anchor\">messages</a>/messages.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: [\n    AppComponent,\n    HeroesComponent,\n    HeroDetailComponent,\n    MessagesComponent\n  ],\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>\n  ],\n  providers: [\n    // `<a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>`을 사용했기 때문에 프로바이더는 등록하지 않습니다.\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/app.component.html\" path=\"toh-pt4/src/app/app.component.html\">\n&#x3C;h1>{{title}}&#x3C;/h1>\n&#x3C;app-heroes>&#x3C;/app-heroes>\n&#x3C;app-messages>&#x3C;/app-messages>\n\n\n</code-pane>\n\n</code-tabs>\n<!--\n## Summary\n-->\n<h2 id=\"정리\">정리<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#정리\"><i class=\"material-icons\">link</i></a></h2>\n<!--\n* You refactored data access to the `HeroService` class.\n* You registered the `HeroService` as the _provider_ of its service at the root level so that it can be injected anywhere in the app.\n* You used [Angular Dependency Injection](guide/dependency-injection) to inject it into a component.\n* You gave the `HeroService` _get data_ method an asynchronous signature.\n* You discovered `Observable` and the RxJS _Observable_ library.\n* You used RxJS `of()` to return an observable of mock heroes (`Observable<Hero[]>`).\n* The component's `ngOnInit` lifecycle hook calls the `HeroService` method, not the constructor.\n* You created a `MessageService` for loosely-coupled communication between classes.\n* The `HeroService` injected into a component is created with another injected service,\n `MessageService`.\n-->\n<ul>\n<li>컴포넌트가 데이터를 직접 가져오는 방식을 <code>HeroService</code> 클래스가 제공하는 방식으로 변경했습니다.</li>\n<li><em>프로바이더</em> 를 사용해서 <code>HeroService</code>를 최상위 인젝터에 등록했습니다.</li>\n<li><code>HeroService</code>를 컴포넌트에 의존성으로 주입하기 위해 <a href=\"guide/dependency-injection\">Angular의 의존성 주입</a> 시스템을 사용했습니다.</li>\n<li><code>HeroService</code>에서 비동기 방식으로 데이터를 가져오는 메소드를 구현했습니다.</li>\n<li>RxJS가 제공하는 <code>Observable</code>에 대해 간단하게 알아봤습니다.</li>\n<li>히어로 목 데이터(<code>Observable&#x3C;Hero[]></code>)를 반환할 때 RxJS가 제공하는 <code>of()</code> 함수를 사용했습니다.</li>\n<li>컴포넌트가 <code>HeroService</code>를 활용하는 로직은 컴포넌트 생성자가 아니라 <code>ngOnInit</code> 라이프싸이클 후킹 함수에 구현했습니다.</li>\n<li>클래스끼리 데이터를 주고받지만 결합도를 낮추기 위해 <code>MessageService</code>를 만들었습니다.</li>\n<li><code>HeroService</code>는 컴포넌트에 의존성으로 주입되지만 또 다른 서비스인 <code>MessageService</code>를 의존성으로 주입받기도 합니다.</li>\n</ul>\n\n</div>\n\n<!-- links to this doc:\n - guide/lifecycle-hooks\n - guide/router\n - guide/singleton-services\n - tutorial/toh-pt5\n-->\n<!-- links from this doc:\n - api/common/NgForOf\n - api/common/NgIf\n - api/common/http/HttpClient\n - api/common/http/HttpErrorResponse#message\n - api/core/Component\n - api/core/Component#styleUrls\n - api/core/Injectable\n - api/core/Injectable#providedIn\n - api/core/NgModule\n - api/core/OnInit\n - api/forms/FormArray#clear\n - api/forms/FormsModule\n - api/platform-browser/BrowserModule\n - api/service-worker/SwPush#messages\n - guide/dependency-injection\n - guide/http\n - guide/lifecycle-hooks\n - guide/providers\n - guide/template-syntax#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%B0%94%EC%9D%B8%EB%94%A9\n - tutorial/toh-pt4#final-code-review\n - tutorial/toh-pt4#getheroes-추가하기\n - tutorial/toh-pt4#heroescomponent-수정하기\n - tutorial/toh-pt4#heroescomponent-에서-옵저버블-구독하기\n - tutorial/toh-pt4#heroservice-등록하기\n - tutorial/toh-pt4#heroservice-생성하기\n - tutorial/toh-pt4#heroservice-주입하기\n - tutorial/toh-pt4#heroservice에-의존성으로-주입하기\n - tutorial/toh-pt4#heroservice에서-메시지-보내기\n - tutorial/toh-pt4#heroservice에서-받은-메시지-표시하기\n - tutorial/toh-pt4#inject\n - tutorial/toh-pt4#inject-message-service\n - tutorial/toh-pt4#injectable-서비스\n - tutorial/toh-pt4#messagescomponent-생성하기\n - tutorial/toh-pt4#messageservice-바인딩하기\n - tutorial/toh-pt4#messageservice-생성하기\n - tutorial/toh-pt4#ngoninit에서-서비스-호출하기\n - tutorial/toh-pt4#동작-확인하기\n - tutorial/toh-pt4#메시지-표시하기\n - tutorial/toh-pt4#서비스\n - tutorial/toh-pt4#옵저버블-heroservice\n - tutorial/toh-pt4#옵저버블-데이터\n - tutorial/toh-pt4#왜-서비스를-사용할까요\n - tutorial/toh-pt4#정리\n - tutorial/toh-pt4#최종코드-리뷰\n - tutorial/toh-pt4#히어로-데이터-가져오기\n - tutorial/toh-pt6\n - http://reactivex.io/rxjs/\n - https://github.com/angular/angular/edit/master/aio/content/tutorial/toh-pt4.md?message=docs%3A%20describe%20your%20change...\n-->"
}