{
  "id": "tutorial/toh-pt4",
  "title": "서비스 생성하기",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/tutorial/toh-pt4.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<!--\n# Add services\n-->\n<h1 id=\"서비스-생성하기\">서비스 생성하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#서비스-생성하기\"><i class=\"material-icons\">link</i></a></h1>\n<!--\nThe Tour of Heroes `HeroesComponent` is currently getting and displaying fake data.\n\nAfter the refactoring in this tutorial, `HeroesComponent` will be lean and focused on supporting the view.\nIt will also be easier to unit-test with a mock service.\n-->\n<p><code>HeroesComponent</code>가 표시하는 데이터는 아직 가짜 데이터입니다.</p>\n<p>이번 튜토리얼에서는 <code>HeroesComponent</code>가 화면을 표시하는 로직에만 집중하도록 가볍게 리팩토링해 봅시다.\n이렇게 수정하면 목 서비스를 사용할 수 있기 때문에 컴포넌트에 유닛 테스트를 적용하기도 쉬워집니다.</p>\n<!--\n## Why services\n-->\n<h2 id=\"왜-서비스를-사용할까요\">왜 서비스를 사용할까요?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#왜-서비스를-사용할까요\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nComponents shouldn't fetch or save data directly and they certainly shouldn't knowingly present fake data.\nThey should focus on presenting data and delegate data access to a service.\n\nIn this tutorial, you'll create a `HeroService` that all application classes can use to get heroes.\nInstead of creating that service with the [`new` keyword](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new),\nyou'll rely on Angular [*dependency injection*](guide/dependency-injection)\nto inject it into the `HeroesComponent` constructor.\n-->\n<p>컴포넌트는 데이터를 직접 가져오거나 직접 저장하도록 요청하지 않는 것이 좋습니다. 그리고 사용하는 데이터가 실제 데이터인지 가짜 데이터인지 알 필요도 없습니다.\n컴포넌트는 데이터를 표시하는 것에만 집중하는 것이 좋으며, 데이터를 처리하는 로직은 서비스에게 맡겨두는 것이 좋습니다.</p>\n<p>이 튜토리얼에서는 히어로의 데이터를 처리하는 <code>HeroService</code>를 만들어 봅니다.\n그런데 이 서비스는 <code>new</code> 키워드로 인스턴스를 직접 생성하지 않습니다.\n이 서비스는 Angular가 제공하는 <a href=\"guide/dependency-injection\"><em>의존성 주입</em></a> 메커니즘에 따라 <code>HeroesComponent</code>의 생성자로 주입될 것입니다.</p>\n<!--\nServices are a great way to share information among classes that _don't know each other_.\nYou'll create a `MessageService` and inject it in two places.\n\n1. Inject in HeroService, which uses the service to send a message.\n2. Inject in MessagesComponent, which displays that message, and also displays the ID\nwhen the user clicks a hero.\n-->\n<p>여러 클래스에 사용되는 정보를 공유하려면 서비스를 사용하는 방법이 가장 좋습니다.\n<code>MessageService</code>를 만들고 다음 두 곳에 이 서비스를 주입해서 활용해 봅시다:</p>\n<ol>\n<li>\n<p>Inject in HeroService, which uses the service to send a message.</p>\n</li>\n<li>\n<p>Inject in MessagesComponent, which displays that message, and also displays the ID\nwhen the user clicks a hero.</p>\n</li>\n<li>\n<p><code>HeroService</code>가 메시지를 보낼 때 사용합니다.</p>\n</li>\n<li>\n<p>이 메시지는 <code>MessagesComponent</code>가 화면에 표시합니다.</p>\n</li>\n</ol>\n<!--\n## Create the `HeroService`\n-->\n<h2 id=\"heroservice-생성하기\"><code>HeroService</code> 생성하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#heroservice-생성하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nUsing the Angular CLI, create a service called `hero`.\n-->\n<p>Angular CLI로 다음 명령을 실행해서 <code>hero</code> 서비스를 생성합니다.</p>\n<code-example language=\"sh\" class=\"code-shell\">\n  ng generate service hero\n</code-example>\n<!--\nThe command generates a skeleton `HeroService` class in `src/app/hero.service.ts` as follows:\n-->\n<p>이 명령을 실행하면 <code>src/app/hero.service.ts</code> 파일에 <code>HeroService</code> 클래스가 다음과 같이 생성됩니다:</p>\n<!--\n<code-example path=\"toh-pt4/src/app/hero.service.1.ts\" region=\"new\" header=\"src/app/hero.service.ts (new service)\">\nimport { Injectable } from &#39;@angular/core&#39;;\n\n@Injectable({\n  providedIn: &#39;root&#39;,\n})\nexport class HeroService {\n\n  constructor() { }\n\n}\n\n</code-example>\n-->\n<code-example path=\"toh-pt4/src/app/hero.service.1.ts\" region=\"new\" header=\"src/app/hero.service.ts (새로 만든 서비스)\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class HeroService {\n\n  constructor() { }\n\n}\n\n</code-example>\n<!--\n### `@Injectable()` services\n-->\n<h3 id=\"injectable-서비스\"><code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 서비스<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#injectable-서비스\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nNotice that the new service imports the Angular `Injectable` symbol and annotates\nthe class with the `@Injectable()` decorator. This marks the class as one that participates in the _dependency injection system_. The `HeroService` class is going to provide an injectable service, and it can also have its own injected dependencies.\nIt doesn't have any dependencies yet, but [it will soon](#inject-message-service).\n\nThe `@Injectable()` decorator accepts a metadata object for the service, the same way the `@Component()` decorator did for your component classes.\n-->\n<p>Angular CLI로 만든 서비스 클래스에는 <code><a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> 심볼이 로드되어 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 데코레이터로 사용되었습니다.\n이 구문은 이 클래스가 <em>의존성 주입 시스템</em> 에 포함되는 클래스라고 선언하는 구문입니다.\n그래서 <code>HeroService</code> 클래스는 의존성으로 주입될 수 있으며 이 클래스도 의존성을 주입받을 수 있습니다.\n아직까지는 이 클래스에 주입되는 의존성 객체가 없지만 <a href=\"tutorial/toh-pt4#inject-message-service\">곧</a> 추가될 것입니다.</p>\n<p><code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 데코레이터는 서비스를 정의하는 메타데이터 객체를 인자로 받습니다.\n<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 데코레이터에 메타데이터를 사용했던 것과 같은 방식입니다.</p>\n<!--\n### Get hero data\n-->\n<h3 id=\"히어로-데이터-가져오기\">히어로 데이터 가져오기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#히어로-데이터-가져오기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe `HeroService` could get hero data from anywhere&mdash;a web service, local storage, or a mock data source.\n\nRemoving data access from components means you can change your mind about the implementation anytime, without touching any components.\nThey don't know how the service works.\n\nThe implementation in _this_ tutorial will continue to deliver _mock heroes_.\n\nImport the `Hero` and `HEROES`.\n-->\n<p><code>HeroService</code>는 —웹 서비스나 로컬 스토리지, 목 데이터 소스 등— 어디에서든 히어로 데이터를 가져올 수 있습니다.</p>\n<p>컴포넌트에서 데이터에 접근하는 로직을 제거하면 컴포넌트는 데이터를 표시하는 목적에만 집중할 수 있으며, 데이터를 가져오는 곳이 변경되더라도 컴포넌트가 이 내용을 신경쓰지 않아도 됩니다.</p>\n<p>이 문서에서는 이전과 마찬가지로 <em>목 데이터</em> 를 가져오도록 구현해 봅시다.</p>\n<p><code>HeroService</code>에 <code>Hero</code> 심볼과 <code>HEROES</code> 배열을 로드합니다.</p>\n<code-example path=\"toh-pt4/src/app/hero.service.ts\" header=\"src/app/hero.service.ts\" region=\"import-heroes\">\nimport { Hero } from './hero';\nimport { HEROES } from './mock-heroes';\n\n</code-example>\n<!--\nAdd a `getHeroes` method to return the _mock heroes_.\n-->\n<p>그리고 <em>목 히어로 데이터</em> 를 반환하는 <code>getHeroes</code> 메소드를 추가합니다.</p>\n<code-example path=\"toh-pt4/src/app/hero.service.1.ts\" header=\"src/app/hero.service.ts\" region=\"getHeroes\">\ngetHeroes(): Hero[] {\n  return HEROES;\n}\n\n</code-example>\n<a id=\"provide\"></a>\n<!--\n## Provide the `HeroService`\n-->\n<h2 id=\"heroservice-등록하기\"><code>HeroService</code> 등록하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#heroservice-등록하기\"><i class=\"material-icons\">link</i></a></h2>\n<p>You must make the <code>HeroService</code> available to the dependency injection system\nbefore Angular can <em>inject</em> it into the <code>HeroesComponent</code> by registering a <em>provider</em>. A provider is something that can create or deliver a service; in this case, it instantiates the <code>HeroService</code> class to provide the service.</p>\n<p>To make sure that the <code>HeroService</code> can provide this service, register it\nwith the <em>injector</em>, which is the object that is responsible for choosing\nand injecting the provider where the app requires it.</p>\n<p>By default, the Angular CLI command <code>ng generate service</code> registers a provider with the <em>root injector</em> for your service by including provider metadata, that is <code><a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root'</code> in the <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator.</p>\n<code-example>\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\n</code-example>\n<!--\nWhen you provide the service at the root level, Angular creates a single, shared instance of `HeroService` and injects into any class that asks for it.\nRegistering the provider in the `@Injectable` metadata also allows Angular to optimize an app by removing the service if it turns out not to be used after all.\n-->\n<p>서비스가 최상위 인젝터에 등록되면 Angular는 <code>HeroService</code>의 인스턴스를 하나만 생성하며, 이 클래스가 주입되는 모든 곳에서 같은 인스턴스를 공유합니다.\n그리고 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 데코레이터는 이 데코레이터가 등록된 클래스가 실제로 사용되지 않으면 이 클래스를 최종 빌드 결과물에서 제거하는 대상으로 등록하는 역할도 합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nTo learn more about providers, see the [Providers section](guide/providers).\nTo learn more about injectors, see the [Dependency Injection guide](guide/dependency-injection).\n-->\n<p>프로바이더에 대해 자세하게 알아보려면 <a href=\"guide/providers\">프로바이더</a> 문서를 참고하세요.\n인젝터에 대해 자세하게 알아보려면 <a href=\"guide/dependency-injection\">Angular의 의존성 주입</a> 문서를 참고하세요.</p>\n</div>\n<!--\nThe `HeroService` is now ready to plug into the `HeroesComponent`.\n-->\n<p><code>HeroService</code>는 이제 <code>HeroesComponent</code>에 주입할 준비가 되었습니다.</p>\n<div class=\"alert is-important\">\n<!--\nThis is an interim code sample that will allow you to provide and use the `HeroService`. At this point, the code will differ from the `HeroService` in the [\"final code review\"](#final-code-review).\n-->\n<p>지금까지 작성한 코드는 <code>HeroService</code>를 프로바이더로 등록하기 위한 임시 코드입니다.\n<a href=\"tutorial/toh-pt4#final-code-review\">최종코드 리뷰</a>와는 조금 다릅니다.</p>\n</div>\n<!--\n## Update `HeroesComponent`\n-->\n<h2 id=\"heroescomponent-수정하기\"><code>HeroesComponent</code> 수정하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#heroescomponent-수정하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nOpen the `HeroesComponent` class file.\n\nDelete the `HEROES` import, because you won't need that anymore.\nImport the `HeroService` instead.\n-->\n<p><code>HeroesComponent</code> 클래스 파일을 엽니다.</p>\n<p>이 파일에서 <code>HEROES</code>를 로드했던 부분을 제거하고 <code>HeroService</code>를 로드합니다.</p>\n<!--\n<code-example path=\"toh-pt4/src/app/heroes/heroes.component.ts\" header=\"src/app/heroes/heroes.component.ts (import HeroService)\" region=\"hero-service-import\">\n-->\n<code-example path=\"toh-pt4/src/app/heroes/heroes.component.ts\" header=\"src/app/heroes/heroes.component.ts (HeroService 로드하기)\" region=\"hero-service-import\">\nimport { HeroService } from '../hero.service';\n\n</code-example>\n<!--\nReplace the definition of the `heroes` property with a simple declaration.\n-->\n<p>그리고 <code>heroes</code> 프로퍼티 값을 할당하는 부분을 다음과 같이 수정합니다.</p>\n<code-example path=\"toh-pt4/src/app/heroes/heroes.component.ts\" header=\"src/app/heroes/heroes.component.ts\" region=\"heroes\">\nheroes: Hero[];\n\n</code-example>\n<a id=\"inject\"></a>\n<!--\n### Inject the `HeroService`\n-->\n<h3 id=\"heroservice-주입하기\"><code>HeroService</code> 주입하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#heroservice-주입하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAdd a private `heroService` parameter of type `HeroService` to the constructor.\n-->\n<p>생성자에 <code>HeroService</code> 타입의 <code>heroService</code> 인자를 선언하고 이 인자를 <code>private</code>으로 지정합니다.</p>\n<code-example path=\"toh-pt4/src/app/heroes/heroes.component.1.ts\" header=\"src/app/heroes/heroes.component.ts\" region=\"ctor\">\nconstructor(private heroService: HeroService) {}\n\n</code-example>\n<!--\nThe parameter simultaneously defines a private `heroService` property and identifies it as a `HeroService` injection site.\n\nWhen Angular creates a `HeroesComponent`, the [Dependency Injection](guide/dependency-injection) system\nsets the `heroService` parameter to the singleton instance of `HeroService`.\n-->\n<p>이렇게 작성하면 <code>heroService</code> 인자를 클래스 프로퍼티로 선언하면서 <code>HeroService</code> 타입의 의존성 객체가 주입되기를 요청한다는 것을 의미합니다.</p>\n<p>그러면 Angular가 <code>HeroesComponent</code>를 생성할 때 <a href=\"guide/dependency-injection\">의존성 주입</a> 시스템이 <code>HeroService</code>의 인스턴스를 찾아서 <code>heroService</code> 라는 인자로 전달할 것입니다.</p>\n<!--\n### Add `getHeroes()`\n-->\n<h3 id=\"getheroes-추가하기\"><code>getHeroes()</code> 추가하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#getheroes-추가하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nCreate a function to retrieve the heroes from the service.\n-->\n<p>이제 서비스에서 히어로 데이터를 전달하는 함수를 정의해 봅시다.</p>\n<code-example path=\"toh-pt4/src/app/heroes/heroes.component.1.ts\" header=\"src/app/heroes/heroes.component.ts\" region=\"getHeroes\">\ngetHeroes(): void {\n  this.heroes = this.heroService.getHeroes();\n}\n\n</code-example>\n<a id=\"oninit\"></a>\n<!--\n### Call it in `ngOnInit()`\n-->\n<h3 id=\"ngoninit에서-서비스-호출하기\"><code>ngOnInit()</code>에서 서비스 호출하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#ngoninit에서-서비스-호출하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nWhile you could call `getHeroes()` in the constructor, that's not the best practice.\n\nReserve the constructor for simple initialization such as wiring constructor parameters to properties.\nThe constructor shouldn't _do anything_.\nIt certainly shouldn't call a function that makes HTTP requests to a remote server as a _real_ data service would.\n\nInstead, call `getHeroes()` inside the [*ngOnInit lifecycle hook*](guide/lifecycle-hooks) and\nlet Angular call `ngOnInit()` at an appropriate time _after_ constructing a `HeroesComponent` instance.\n-->\n<p>서비스에 구현한 <code>getHeroes()</code> 함수는 컴포넌트 클래스에서도 호출할 수 있지만, 이 방법은 최선이 아닙니다.</p>\n<p>컴포넌트의 생성자는 생성자로 받은 인자를 클래스 프로퍼티로 연결하는 정도로 간단하게 유지하는 것이 좋습니다.\n생성자에는 이 외의 로직이 <em>들어가지 않는 것이 좋습니다</em>.\n리모트 서버로 HTTP 요청을 보내는 로직도 물론 들어가지 않는 것이 좋습니다.</p>\n<p><code>getHeroes()</code> 함수는 <a href=\"guide/lifecycle-hooks\"><em>ngOnInit 라이프싸이클 후킹 함수</em></a>에서 실행하는 것이 좋습니다.\n<code>ngOnInit()</code> 함수는 Angular가 <code>HeroesComponent</code>의 인스턴스를 생성한 <em>직후에</em> 실행되는 함수입니다.</p>\n<code-example path=\"toh-pt4/src/app/heroes/heroes.component.ts\" header=\"src/app/heroes/heroes.component.ts\" region=\"ng-on-init\">\nngOnInit() {\n  this.getHeroes();\n}\n\n</code-example>\n<!--\n### See it run\n-->\n<h3 id=\"동작-확인하기\">동작 확인하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#동작-확인하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nAfter the browser refreshes, the app should run as before,\nshowing a list of heroes and a hero detail view when you click on a hero name.\n-->\n<p>브라우저가 갱신되고 나면 앱이 이전과 동일하게 동작할 것입니다.\n화면에 히어로의 목록이 표시되고, 사용자가 히어로 중 하나의 이름을 클릭하면 해당 히어로의 상세정보도 화면에 표시됩니다.</p>\n<!--\n## Observable data\n-->\n<h2 id=\"옵저버블-데이터\">옵저버블 데이터<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#옵저버블-데이터\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThe `HeroService.getHeroes()` method has a _synchronous signature_,\nwhich implies that the `HeroService` can fetch heroes synchronously.\nThe `HeroesComponent` consumes the `getHeroes()` result\nas if heroes could be fetched synchronously.\n-->\n<p>위에서 작성한 <code>HeroService.getHeroes()</code> 메소드는 <em>동기 방식으로 동작하기 때문에</em>, 이 함수의 실행 결과는 바로 반환됩니다.\n그래서 <code>HeroesComponent</code>의 <code>heroes</code> 프로퍼티에 값이 할당될 때도 동기 방식으로 할당됩니다.</p>\n<code-example path=\"toh-pt4/src/app/heroes/heroes.component.1.ts\" header=\"src/app/heroes/heroes.component.ts\" region=\"get-heroes\">\nthis.heroes = this.heroService.getHeroes();\n\n</code-example>\n<!--\nThis will not work in a real app.\nYou're getting away with it now because the service currently returns _mock heroes_.\nBut soon the app will fetch heroes from a remote server,\nwhich is an inherently _asynchronous_ operation.\n\nThe `HeroService` must wait for the server to respond,\n`getHeroes()` cannot return immediately with hero data,\nand the browser will not block while the service waits.\n-->\n<p>하지만 실제로 운영되는 앱에서 이런 방식을 사용하는 경우는 별로 없습니다.\n지금 작성한 코드는 <em>목 데이터</em> 를 가져오기 때문에 유효한 것입니다.\n애플리케이션은 리모트 서버에서 데이터를 가져오는 것이 일반적이기 때문에, <em>비동기</em> 동작을 처리해야 하는 경우가 대부분입니다.</p>\n<p>그래서 <code>HeroService.getHeroes()</code>는 서버의 응답을 기다려야 하며, 히어로 데이터를 즉시 반환할 수 없습니다.\n함수의 실행은 서버의 응답이 올 때까지 기다리지 않고 바로 종료됩니다.</p>\n<!--\n`HeroService.getHeroes()` must have an _asynchronous signature_ of some kind.\n\nIn this tutorial, `HeroService.getHeroes()` will return an `Observable`\nbecause it will eventually use the Angular `HttpClient.get` method to fetch the heroes\nand [`HttpClient.get()` returns an `Observable`](guide/http).\n-->\n<p>이런 경우에는 <code>HeroService.getHeroes()</code> 함수가 <em>비동기로 동작해야</em> 합니다.</p>\n<p>비동기 동작은 콜백 함수를 사용해서 처리할 수 있습니다. <code>Promise</code>를 반환하도록 처리할 수도 있습니다. 그리고 <code>Observable</code>을 반환할 수도 있습니다.</p>\n<p>이 튜토리얼에서는 <code>HeroService.getHeroes()</code> 함수가 <code>Observable</code>을 반환하도록 구현해 봅시다.\nAngular가 제공하는 <a href=\"guide/http\"><code>HttpClient.get</code> 메소드는 <code>Observable</code>을 반환하기 때문에</a> 이렇게 구현하는 것이 가장 자연스럽습니다.</p>\n<!--\n### Observable `HeroService`\n-->\n<h3 id=\"옵저버블-heroservice\">옵저버블 <code>HeroService</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#옵저버블-heroservice\"><i class=\"material-icons\">link</i></a></h3>\n<!--\n`Observable` is one of the key classes in the [RxJS library](http://reactivex.io/rxjs/).\n\nIn a [later tutorial on HTTP](tutorial/toh-pt6), you'll learn that Angular's `HttpClient` methods return RxJS `Observable`s.\nIn this tutorial, you'll simulate getting data from the server with the RxJS `of()` function.\n\nOpen the `HeroService` file and import the `Observable` and `of` symbols from RxJS.\n-->\n<p><code>Observable</code>은 <a href=\"http://reactivex.io/rxjs/\">RxJS 라이브러리</a>가 제공하는 클래스 중 가장 중요한 클래스입니다.</p>\n<p><a href=\"tutorial/toh-pt6\">이후에 HTTP에 대해서 알아볼 때</a> Angular의 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 클래스가 제공하는 메소드는 모두 RxJS가 제공하는 <code>Observable</code> 타입을 반환한다는 것을 다시 한 번 살펴볼 것입니다.\n이 튜토리얼에서는 리모트 서버를 사용하지 않고 RxJS의 <code>of()</code> 함수로 데이터를 즉시 반환해 봅시다.</p>\n<!--\n<code-example path=\"toh-pt4/src/app/hero.service.ts\" header=\"src/app/hero.service.ts (Observable imports)\" region=\"import-observable\">\nimport { Observable, of } from &#39;rxjs&#39;;\n\n</code-example>\n-->\n<code-example path=\"toh-pt4/src/app/hero.service.ts\" header=\"src/app/hero.service.ts (Observable 로드하기)\" region=\"import-observable\">\nimport { Observable, of } from 'rxjs';\n\n</code-example>\n<!--\nReplace the `getHeroes()` method with the following:\n-->\n<p><code>getHeroes()</code> 메소드를 다음과 같이 수정합니다:</p>\n<code-example path=\"toh-pt4/src/app/hero.service.ts\" header=\"src/app/hero.service.ts\" region=\"getHeroes-1\">\ngetHeroes(): Observable&#x3C;Hero[]> {\n  return of(HEROES);\n}\n\n</code-example>\n<!--\n`of(HEROES)` returns an `Observable<Hero[]>` that emits  _a single value_, the array of mock heroes.\n-->\n<p><code>of(HEROES)</code>는 히어로 목 데이터를 <code>Observable&#x3C;Hero[]></code> 타입으로 <em>한번에</em> 반환합니다.</p>\n<div class=\"alert is-helpful\">\n<!--\nIn the [HTTP tutorial](tutorial/toh-pt6), you'll call `HttpClient.get<Hero[]>()` which also returns an `Observable<Hero[]>` that emits  _a single value_, an array of heroes from the body of the HTTP response.\n-->\n<p>이후에 살펴볼 <a href=\"tutorial/toh-pt6\">HTTP 튜토리얼</a>에서도 <code>HttpClient.get&#x3C;Hero[]></code>는 이번 예제와 동일하게 <code>Observable&#x3C;Hero[]></code> 타입을 반환하기 때문에, HTTP 응답으로 받은 히어로의 데이터 배열은 <em>한번에</em> 반환됩니다.</p>\n</div>\n<!--\n### Subscribe in `HeroesComponent`\n-->\n<h3 id=\"heroescomponent-에서-옵저버블-구독하기\"><code>HeroesComponent</code> 에서 옵저버블 구독하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#heroescomponent-에서-옵저버블-구독하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe `HeroService.getHeroes` method used to return a `Hero[]`.\nNow it returns an `Observable<Hero[]>`.\n\nYou'll have to adjust to that difference in `HeroesComponent`.\n\nFind the `getHeroes` method and replace it with the following code\n(shown side-by-side with the previous version for comparison)\n-->\n<p>이전까지 <code>HeroService.getHeroes</code> 메소드는 <code>Hero[]</code> 타입을 반환했지만 이제는 <code>Observable&#x3C;Hero[]></code> 타입을 반환합니다.</p>\n<p>그래서 <code>HeroesComponent</code>의 내용을 조금 수정해야 합니다.</p>\n<p><code>getHeroes</code> 메소드를 실행했던 부분을 찾아서 다음과 같이 변경합니다.\n이전에 작성했던 코드와 비교해 보세요.</p>\n<code-tabs>\n\n  <!--\n  <code-pane header=\"heroes.component.ts (Observable)\" path=\"toh-pt4/src/app/heroes/heroes.component.ts\" region=\"getHeroes\">\ngetHeroes(): void {\n  this.heroService.getHeroes()\n      .subscribe(heroes =&gt; this.heroes = heroes);\n}\n\n</code-pane>\n  -->\n  <code-pane header=\"heroes.component.ts (옵저버블을 사용하는 코드)\" path=\"toh-pt4/src/app/heroes/heroes.component.ts\" region=\"getHeroes\">\ngetHeroes(): void {\n  this.heroService.getHeroes()\n      .subscribe(heroes => this.heroes = heroes);\n}\n\n</code-pane>\n\n  <!--\n  <code-pane header=\"heroes.component.ts (Original)\" path=\"toh-pt4/src/app/heroes/heroes.component.1.ts\" region=\"getHeroes\">\ngetHeroes(): void {\n  this.heroes = this.heroService.getHeroes();\n}\n\n</code-pane>\n  -->\n  <code-pane header=\"heroes.component.ts (기존 코드)\" path=\"toh-pt4/src/app/heroes/heroes.component.1.ts\" region=\"getHeroes\">\ngetHeroes(): void {\n  this.heroes = this.heroService.getHeroes();\n}\n\n</code-pane>\n\n</code-tabs>\n<!--\n`Observable.subscribe()` is the critical difference.\n\nThe previous version assigns an array of heroes to the component's `heroes` property.\nThe assignment occurs _synchronously_, as if the server could return heroes instantly\nor the browser could freeze the UI while it waited for the server's response.\n-->\n<p><code>Observable.subscribe()</code>를 사용한 부분이 가장 중요합니다.</p>\n<p>이전 버전에서는 히어로의 데이터를 배열로 가져와서 컴포넌트의 <code>heroes</code> 프로퍼티에 직접 할당했습니다.\n이 동작은 <em>동기 방식으로</em> 동작하기 때문에 서비스가 데이터를 즉시 반환하거나 서버의 응답이 동기 방식으로 전달될 때에만 제대로 동작합니다.</p>\n<!--\nThat _won't work_ when the `HeroService` is actually making requests of a remote server.\n\nThe new version waits for the `Observable` to emit the array of heroes&mdash;which\ncould happen now or several minutes from now.\nThe `subscribe()` method passes the emitted array to the callback,\nwhich sets the component's `heroes` property.\n\nThis asynchronous approach _will work_ when\nthe `HeroService` requests heroes from the server.\n-->\n<p>하지만 <code>HeroService</code>는 리모트 서버에 요청을 보내는 방식으로 동작하는 경우에는 이 로직이 제대로 <em>동작하지 않습니다</em>.</p>\n<p>수정한 버전의 코드는 서비스의 함수가 <code>Observable</code> 타입을 반환하는데, 반환 시점은 함수를 실행한 직후일 수도 있고 몇 분이 지난 후일 수도 있습니다.\n서버의 응답이 언제 도착하는지와 관계없이, 이 응답이 도착했을 때 <code>subscribe</code>가 서버에서 받은 응답을 콜백 함수로 전달하고, 컴포넌트는 이렇게 받은 히어로 데이터를 <code>heroes</code> 프로퍼티에 할당합니다.</p>\n<p><code>HeroService</code>가 실제로 서버에 요청을 보낸다면 이렇게 비동기 방식으로 구현해야 <em>제대로 동작합니다</em>.</p>\n<!--\n## Show messages\n-->\n<h2 id=\"메시지-표시하기\">메시지 표시하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#메시지-표시하기\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nThis section guides you through the following:\n\n* adding a `MessagesComponent` that displays app messages at the bottom of the screen\n* creating an injectable, app-wide `MessageService` for sending messages to be displayed\n* injecting `MessageService` into the `HeroService`\n* displaying a message when `HeroService` fetches heroes successfully\n-->\n<p>이번 섹션에서는 다음 내용에 대해 다룹니다.</p>\n<ul>\n<li>애플리케이션에서 발생하는 메시지를 화면 아래쪽에 표시하기 위해 <code>MessagesComponent</code>를 추가해 봅니다.</li>\n<li>앱 전역 범위에 의존성으로 주입할 수 있는 <code>MessageService</code>를 만들고, 이 서비스로 메시지를 보내봅니다.</li>\n<li><code>MessageService</code>를 <code>HeroService</code>에 주입해 봅니다.</li>\n<li><code>HeroService</code>가 서버에서 가져온 히어로 데이터를 화면에 표시해 봅니다.</li>\n</ul>\n<!--\n### Create `MessagesComponent`\n-->\n<h3 id=\"messagescomponent-생성하기\"><code>MessagesComponent</code> 생성하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#messagescomponent-생성하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nUse the CLI to create the `MessagesComponent`.\n-->\n<p>Angular CLI로 다음 명령을 실행해서 <code>MessagesComponent</code>를 생성합니다.</p>\n<code-example language=\"sh\" class=\"code-shell\">\n  ng generate component messages\n</code-example>\n<!--\nThe CLI creates the component files in the `src/app/messages` folder and declares the `MessagesComponent` in `AppModule`.\n\nModify the `AppComponent` template to display the generated `MessagesComponent`.\n-->\n<p>그러면 Angular CLI가 <code>src/app/<a href=\"api/service-worker/SwPush#messages\" class=\"code-anchor\">messages</a></code> 폴더에 컴포넌트 파일들을 생성하고 <code>AppModule</code>에 <code>MessagesComponent</code>를 자동으로 등록할 것입니다.</p>\n<p>이렇게 만든 <code>MessagesComponent</code>를 화면에 표시하기 위해 <code>AppComponent</code> 템플릿을 다음과 같이 수정합니다.</p>\n<code-example header=\"src/app/app.component.html\" path=\"toh-pt4/src/app/app.component.html\">\n&#x3C;h1>{{title}}&#x3C;/h1>\n&#x3C;app-heroes>&#x3C;/app-heroes>\n&#x3C;app-messages>&#x3C;/app-messages>\n\n\n</code-example>\n<!--\nYou should see the default paragraph from `MessagesComponent` at the bottom of the page.\n-->\n<p>브라우저가 갱신되면 화면 아래쪽에 <code>MessagesComponent</code>가 표시되는 것을 확인할 수 있습니다.</p>\n<!--\n### Create the `MessageService`\n-->\n<h3 id=\"messageservice-생성하기\"><code>MessageService</code> 생성하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#messageservice-생성하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nUse the CLI to create the `MessageService` in `src/app`.\n-->\n<p><code>src/app</code> 폴더에서 Angular CLI로 다음 명령을 실행해서 <code>MessageService</code>를 생성합니다.</p>\n<code-example language=\"sh\" class=\"code-shell\">\n  ng generate service message\n</code-example>\n<!--\nOpen `MessageService` and replace its contents with the following.\n-->\n<p>그리고 이렇게 만든 <code>MessageService</code> 파일을 열어서 다음 내용으로 수정합니다.</p>\n<code-example header=\"src/app/message.service.ts\" path=\"toh-pt4/src/app/message.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class MessageService {\n  <a href=\"api/service-worker/SwPush#messages\" class=\"code-anchor\">messages</a>: string[] = [];\n\n  add(<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>: string) {\n    this.messages.push(<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>);\n  }\n\n  clear() {\n    this.messages = [];\n  }\n}\n\n\n</code-example>\n<!--\nThe service exposes its cache of `messages` and two methods: one to `add()` a message to the cache and another to `clear()` the cache.\n-->\n<p>이 서비스는 <code><a href=\"api/service-worker/SwPush#messages\" class=\"code-anchor\">messages</a></code> 프로퍼티에 메시지를 캐싱하는데, <code>add()</code> 메소드는 프로퍼티에 메시지를 추가하고 <code><a href=\"api/forms/FormArray#clear\" class=\"code-anchor\">clear()</a></code> 메소드는 캐시를 비우는 역할을 합니다.</p>\n<a id=\"inject-message-service\"></a>\n<!--\n### Inject it into the `HeroService`\n-->\n<h3 id=\"heroservice에-의존성으로-주입하기\"><code>HeroService</code>에 의존성으로 주입하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#heroservice에-의존성으로-주입하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nIn `HeroService`, import the `MessageService`.\n-->\n<p><code>HeroService</code> 파일을 다시 열고 <code>MessageService</code>를 로드합니다.</p>\n<!--\n<code-example\n  header = \"src/app/hero.service.ts (import MessageService)\"\n  path=\"toh-pt4/src/app/hero.service.ts\" region=\"import-message-service\">\n-->\n<code-example header=\"/src/app/hero.service.ts (MessageService 로드하기)\" path=\"toh-pt4/src/app/hero.service.ts\" region=\"import-message-service\">\nimport { MessageService } from './message.service';\n\n</code-example>\n<!--\nModify the constructor with a parameter that declares a private `messageService` property.\nAngular will inject the singleton `MessageService` into that property\nwhen it creates the `HeroService`.\n-->\n<p>그리고 <code>HeroService</code>의 생성자를 수정해서 <code>messageService</code> 프로퍼티를 <code>private</code>으로 선언하도록 합니다.\n그러면 <code>HeroService</code>가 생성될 때 Angular가 <code>MessageService</code>의 싱글턴 인스턴스를 의존성으로 주입할 것입니다.</p>\n<code-example path=\"toh-pt4/src/app/hero.service.ts\" header=\"src/app/hero.service.ts\" region=\"ctor\">\nconstructor(private messageService: MessageService) { }\n\n</code-example>\n<div class=\"alert is-helpful\">\n<!--\nThis is a typical \"*service-in-service*\" scenario:\nyou inject the `MessageService` into the `HeroService` which is injected into the `HeroesComponent`.\n-->\n<p>\"<em>서비스 안에 서비스</em>\"가 존재하는 경우는 이렇게 구현합니다.\n<code>MessageService</code>는 <code>HeroService</code>에 의존성으로 주입되고, <code>HeroService</code>는 다시 <code>HeroesComponent</code>에 의존성으로 주입됩니다.</p>\n</div>\n<!--\n### Send a message from `HeroService`\n-->\n<h3 id=\"heroservice에서-메시지-보내기\"><code>HeroService</code>에서 메시지 보내기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#heroservice에서-메시지-보내기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nModify the `getHeroes()` method to send a message when the heroes are fetched.\n-->\n<p><code>getHeroes()</code> 메소드에서 히어로 데이터를 받아온 뒤에 메시지를 보내도록 다음과 같이 수정합니다.</p>\n<code-example path=\"toh-pt4/src/app/hero.service.ts\" header=\"src/app/hero.service.ts\" region=\"getHeroes\">\ngetHeroes(): Observable&#x3C;Hero[]> {\n  // TODO: 메시지는 히어로 데이터를 가져온 <a href=\"\" class=\"code-anchor\">_</a>후에<a href=\"\" class=\"code-anchor\">_</a> 보내야 합니다.\n  this.messageService.add('HeroService: fetched heroes');\n  return of(HEROES);\n}\n\n</code-example>\n<!--\n### Display the message from `HeroService`\n-->\n<h3 id=\"heroservice에서-받은-메시지-표시하기\"><code>HeroService</code>에서 받은 메시지 표시하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#heroservice에서-받은-메시지-표시하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nThe `MessagesComponent` should display all messages,\nincluding the message sent by the `HeroService` when it fetches heroes.\n\nOpen `MessagesComponent` and import the `MessageService`.\n-->\n<p><code>MessagesComponent</code>는 <code>HeroService</code>가 서버에서 히어로 데이터를 가져왔을 때 보냈던 메시지와 같이, <code>MessagesService</code>가 받은 모든 메시지를 표시하려고 합니다.</p>\n<p><code>MessagesComponent</code>를 열어서 <code>MessageService</code>를 로드합니다.</p>\n<!--\n<code-example header=\"src/app/messages/messages.component.ts (import MessageService)\" path=\"toh-pt4/src/app/messages/messages.component.ts\" region=\"import-message-service\">\n-->\n<code-example header=\"src/app/messages/messages.component.ts (MessageService 로드하기)\" path=\"toh-pt4/src/app/messages/messages.component.ts\" region=\"import-message-service\">\nimport { MessageService } from '../message.service';\n\n</code-example>\n<!--\nModify the constructor with a parameter that declares a **public** `messageService` property.\nAngular will inject the singleton `MessageService` into that property\nwhen it creates the `MessagesComponent`.\n-->\n<p><code>MessagesComponent</code>의 생성자를 수정해서 <code>messageService</code> 프로퍼티를 <strong>public</strong>으로 할당하도록 다음과 같이 수정합니다.\n이렇게 작성하면 Angular가 <code>MessagesComponent</code>의 인스턴스를 생성할 때 <code>MessageService</code>의 싱글턴 인스턴스를 이 프로퍼티로 전달할 것입니다.</p>\n<code-example path=\"toh-pt4/src/app/messages/messages.component.ts\" header=\"src/app/messages/messages.component.ts\" region=\"ctor\">\nconstructor(public messageService: MessageService) {}\n\n</code-example>\n<!--\nThe `messageService` property **must be public** because you're going to bind to it in the template.\n-->\n<p>이 때 <code>messageService</code> 프로퍼티는 템플릿에 바인딩되기 때문에 반드시 <strong>public으로 선언되어야</strong> 합니다.</p>\n<div class=\"alert is-important\">\n<!--\nAngular only binds to _public_ component properties.\n-->\n<p>Angular에서는 <em>public</em> 으로 선언된 컴포넌트 프로퍼티만 바인딩할 수 있습니다.</p>\n</div>\n<!--\n### Bind to the `MessageService`\n-->\n<h3 id=\"messageservice-바인딩하기\"><code>MessageService</code> 바인딩하기<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#messageservice-바인딩하기\"><i class=\"material-icons\">link</i></a></h3>\n<!--\nReplace the CLI-generated `MessagesComponent` template with the following.\n-->\n<p>Angular CLI가 생성한 <code>MessagesComponent</code>의 템플릿을 다음과 같이 수정합니다.</p>\n<code-example header=\"src/app/messages/messages.component.html\" path=\"toh-pt4/src/app/messages/messages.component.html\">\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"messageService.messages.length\">\n\n  &#x3C;h2>Messages&#x3C;/h2>\n  &#x3C;button class=\"clear\"\n          (click)=\"messageService.clear()\">clear&#x3C;/button>\n  &#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>='let <a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a> of messageService.messages'> {{<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>}} &#x3C;/div>\n\n&#x3C;/div>\n\n\n</code-example>\n<!--\nThis template binds directly to the component's `messageService`.\n\n* The `*ngIf` only displays the messages area if there are messages to show.\n\n\n* An `*ngFor` presents the list of messages in repeated `<div>` elements.\n\n\n* An Angular [event binding](guide/template-syntax#event-binding) binds the button's click event\nto `MessageService.clear()`.\n\nThe messages will look better when you add the private CSS styles to `messages.component.css`\nas listed in one of the [\"final code review\"](#final-code-review) tabs below.\n-->\n<p>이 템플릿은 컴포넌트에 의존성으로 주입된 <code>messageService</code>를 직접 바인딩합니다.</p>\n<ul>\n<li>\n<p>메시지가 존재할 때만 컴포넌트의 내용을 표시하기 위해 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>를 사용했습니다.</p>\n</li>\n<li>\n<p>리스트에 존재하는 메시지마다 <code>&#x3C;div></code> 엘리먼트를 반복하기 위해 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>를 사용했습니다.</p>\n</li>\n<li>\n<p>버튼을 클릭했을 때 <code>MessageService.clear()</code> 함수를 실행하기 위해 <a href=\"guide/template-syntax#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%B0%94%EC%9D%B8%EB%94%A9\">이벤트 바인딩</a> 문법을 사용했습니다.\nThe messages will look better when you add the private CSS styles to <code>messages.component.css</code>\nas listed in one of the <a href=\"tutorial/toh-pt4#final-code-review\">\"final code review\"</a> tabs below.</p>\n</li>\n</ul>\n<h2 id=\"add-additional-messages-to-hero-service\">Add additional messages to hero service<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#add-additional-messages-to-hero-service\"><i class=\"material-icons\">link</i></a></h2>\n<p>The following example shows how to send and display a message each time the user clicks on\na hero, showing a history of the user's selections. This will be helpful when you get to the\nnext section on <a href=\"tutorial/toh-pt5\">Routing</a>.</p>\n<code-example header=\"src/app/heroes/heroes.component.ts\" path=\"toh-pt4/src/app/heroes/heroes.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\n\nimport { Hero } from '../hero';\nimport { HeroService } from '../hero.service';\nimport { MessageService } from '../message.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-heroes',\n  <a href=\"api/core/Component#templateUrl\" class=\"code-anchor\">templateUrl</a>: './heroes.component.html',\n  <a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a>: ['./heroes.component.css']\n})\nexport class HeroesComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n\n  selectedHero: Hero;\n\n  heroes: Hero[];\n\n  constructor(private heroService: HeroService, private messageService: MessageService) { }\n\n  ngOnInit() {\n    this.getHeroes();\n  }\n\n  onSelect(hero: Hero): void {\n    this.selectedHero = hero;\n    this.messageService.add(`HeroService: Selected hero id=${hero.id}`);\n  }\n\n  getHeroes(): void {\n    this.heroService.getHeroes()\n        .subscribe(heroes => this.heroes = heroes);\n  }\n}\n\n\n</code-example>\n<p>The browser refreshes and the page displays the list of heroes.\nRefresh the browser to see the list of heroes, and scroll to the bottom to see the\nmessages from the HeroService. Each time you click a hero, a new message appears to record\nthe selection. Use the \"clear\" button to clear the message history.</p>\n<a id=\"final-code-review\"></a>\n<!--\n## Final code review\n-->\n<h2 id=\"최종코드-리뷰\">최종코드 리뷰<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#최종코드-리뷰\"><i class=\"material-icons\">link</i></a></h2>\n<!--\nHere are the code files discussed on this page and your app should look like this <live-example></live-example>.\n-->\n<p>이 문서에서 다룬 코드의 내용은 다음과 같습니다. 이 코드는 <live-example></live-example>에서 직접 확인하거나 다운받아 확인할 수도 있습니다.</p>\n<code-tabs>\n\n  <code-pane header=\"src/app/hero.service.ts\" path=\"toh-pt4/src/app/hero.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\nimport { Observable, of } from 'rxjs';\n\nimport { Hero } from './hero';\nimport { HEROES } from './mock-heroes';\nimport { MessageService } from './message.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class HeroService {\n\n  constructor(private messageService: MessageService) { }\n\n  getHeroes(): Observable&#x3C;Hero[]> {\n    // TODO: 메시지는 히어로 데이터를 가져온 <a href=\"\" class=\"code-anchor\">_</a>후에<a href=\"\" class=\"code-anchor\">_</a> 보내야 합니다.\n    this.messageService.add('HeroService: fetched heroes');\n    return of(HEROES);\n  }\n}\n\n</code-pane>\n\n  <code-pane header=\"src/app/message.service.ts\" path=\"toh-pt4/src/app/message.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class MessageService {\n  <a href=\"api/service-worker/SwPush#messages\" class=\"code-anchor\">messages</a>: string[] = [];\n\n  add(<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>: string) {\n    this.messages.push(<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>);\n  }\n\n  clear() {\n    this.messages = [];\n  }\n}\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/heroes/heroes.component.ts\" path=\"toh-pt4/src/app/heroes/heroes.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\n\nimport { Hero } from '../hero';\nimport { HeroService } from '../hero.service';\nimport { MessageService } from '../message.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-heroes',\n  <a href=\"api/core/Component#templateUrl\" class=\"code-anchor\">templateUrl</a>: './heroes.component.html',\n  <a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a>: ['./heroes.component.css']\n})\nexport class HeroesComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n\n  selectedHero: Hero;\n\n  heroes: Hero[];\n\n  constructor(private heroService: HeroService, private messageService: MessageService) { }\n\n  ngOnInit() {\n    this.getHeroes();\n  }\n\n  onSelect(hero: Hero): void {\n    this.selectedHero = hero;\n    this.messageService.add(`HeroService: Selected hero id=${hero.id}`);\n  }\n\n  getHeroes(): void {\n    this.heroService.getHeroes()\n        .subscribe(heroes => this.heroes = heroes);\n  }\n}\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/messages/messages.component.ts\" path=\"toh-pt4/src/app/messages/messages.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\nimport { MessageService } from '../message.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-messages',\n  <a href=\"api/core/Component#templateUrl\" class=\"code-anchor\">templateUrl</a>: './messages.component.html',\n  <a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a>: ['./messages.component.css']\n})\nexport class MessagesComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n\n  constructor(public messageService: MessageService) {}\n\n  ngOnInit() {\n  }\n\n}\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/messages/messages.component.html\" path=\"toh-pt4/src/app/messages/messages.component.html\">\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"messageService.messages.length\">\n\n  &#x3C;h2>Messages&#x3C;/h2>\n  &#x3C;button class=\"clear\"\n          (click)=\"messageService.clear()\">clear&#x3C;/button>\n  &#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>='let <a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a> of messageService.messages'> {{<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>}} &#x3C;/div>\n\n&#x3C;/div>\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/messages/messages.component.css\" path=\"toh-pt4/src/app/messages/messages.component.css\">\n/* MessagesComponent에 적용되는 CSS 스타일 */\nh2 {\n  color: red;\n  font-family: Arial, Helvetica, sans-serif;\n  font-weight: lighter;\n}\nbody {\n  margin: 2em;\n}\nbody, input[text], button {\n  color: crimson;\n  font-family: Cambria, Georgia;\n}\n\nbutton.clear {\n  font-family: Arial;\n  background-color: #eee;\n  border: none;\n  padding: 5px 10px;\n  border-radius: 4px;\n  cursor: pointer;\n  cursor: hand;\n}\nbutton:hover {\n  background-color: #cfd8dc;\n}\nbutton:disabled {\n  background-color: #eee;\n  color: #aaa;\n  cursor: auto;\n}\nbutton.clear {\n  color: #333;\n  margin-bottom: 12px;\n}\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/app.module.ts\" path=\"toh-pt4/src/app/app.module.ts\">\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { AppComponent } from './app.component';\nimport { HeroesComponent } from './heroes/heroes.component';\nimport { HeroDetailComponent } from './hero-detail/hero-detail.component';\nimport { MessagesComponent } from './<a href=\"api/service-worker/SwPush#messages\" class=\"code-anchor\">messages</a>/messages.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: [\n    AppComponent,\n    HeroesComponent,\n    HeroDetailComponent,\n    MessagesComponent\n  ],\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>\n  ],\n  providers: [\n    // `<a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>`을 사용했기 때문에 프로바이더는 등록하지 않습니다.\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/app.component.html\" path=\"toh-pt4/src/app/app.component.html\">\n&#x3C;h1>{{title}}&#x3C;/h1>\n&#x3C;app-heroes>&#x3C;/app-heroes>\n&#x3C;app-messages>&#x3C;/app-messages>\n\n\n</code-pane>\n\n</code-tabs>\n<!--\n## Summary\n-->\n<h2 id=\"정리\">정리<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt4#정리\"><i class=\"material-icons\">link</i></a></h2>\n<!--\n* You refactored data access to the `HeroService` class.\n* You registered the `HeroService` as the _provider_ of its service at the root level so that it can be injected anywhere in the app.\n* You used [Angular Dependency Injection](guide/dependency-injection) to inject it into a component.\n* You gave the `HeroService` _get data_ method an asynchronous signature.\n* You discovered `Observable` and the RxJS _Observable_ library.\n* You used RxJS `of()` to return an observable of mock heroes (`Observable<Hero[]>`).\n* The component's `ngOnInit` lifecycle hook calls the `HeroService` method, not the constructor.\n* You created a `MessageService` for loosely-coupled communication between classes.\n* The `HeroService` injected into a component is created with another injected service,\n `MessageService`.\n-->\n<ul>\n<li>컴포넌트가 데이터를 직접 가져오는 방식을 <code>HeroService</code> 클래스가 제공하는 방식으로 변경했습니다.</li>\n<li><em>프로바이더</em> 를 사용해서 <code>HeroService</code>를 최상위 인젝터에 등록했습니다.</li>\n<li><code>HeroService</code>를 컴포넌트에 의존성으로 주입하기 위해 <a href=\"guide/dependency-injection\">Angular의 의존성 주입</a> 시스템을 사용했습니다.</li>\n<li><code>HeroService</code>에서 비동기 방식으로 데이터를 가져오는 메소드를 구현했습니다.</li>\n<li>RxJS가 제공하는 <code>Observable</code>에 대해 간단하게 알아봤습니다.</li>\n<li>히어로 목 데이터(<code>Observable&#x3C;Hero[]></code>)를 반환할 때 RxJS가 제공하는 <code>of()</code> 함수를 사용했습니다.</li>\n<li>컴포넌트가 <code>HeroService</code>를 활용하는 로직은 컴포넌트 생성자가 아니라 <code>ngOnInit</code> 라이프싸이클 후킹 함수에 구현했습니다.</li>\n<li>클래스끼리 데이터를 주고받지만 결합도를 낮추기 위해 <code>MessageService</code>를 만들었습니다.</li>\n<li><code>HeroService</code>는 컴포넌트에 의존성으로 주입되지만 또 다른 서비스인 <code>MessageService</code>를 의존성으로 주입받기도 합니다.</li>\n</ul>\n\n</div>\n\n<!-- links to this doc:\n - guide/lifecycle-hooks\n - guide/router\n - guide/singleton-services\n - tutorial/toh-pt5\n-->\n<!-- links from this doc:\n - api/common/NgForOf\n - api/common/NgIf\n - api/common/http/HttpClient\n - api/common/http/HttpErrorResponse#message\n - api/core/Component\n - api/core/Component#styleUrls\n - api/core/Component#templateUrl\n - api/core/Injectable\n - api/core/Injectable#providedIn\n - api/core/NgModule\n - api/core/OnInit\n - api/forms/FormArray#clear\n - api/forms/FormsModule\n - api/platform-browser/BrowserModule\n - api/service-worker/SwPush#messages\n - guide/dependency-injection\n - guide/http\n - guide/lifecycle-hooks\n - guide/providers\n - guide/template-syntax#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%B0%94%EC%9D%B8%EB%94%A9\n - tutorial/toh-pt4#add-additional-messages-to-hero-service\n - tutorial/toh-pt4#final-code-review\n - tutorial/toh-pt4#getheroes-추가하기\n - tutorial/toh-pt4#heroescomponent-수정하기\n - tutorial/toh-pt4#heroescomponent-에서-옵저버블-구독하기\n - tutorial/toh-pt4#heroservice-등록하기\n - tutorial/toh-pt4#heroservice-생성하기\n - tutorial/toh-pt4#heroservice-주입하기\n - tutorial/toh-pt4#heroservice에-의존성으로-주입하기\n - tutorial/toh-pt4#heroservice에서-메시지-보내기\n - tutorial/toh-pt4#heroservice에서-받은-메시지-표시하기\n - tutorial/toh-pt4#inject-message-service\n - tutorial/toh-pt4#injectable-서비스\n - tutorial/toh-pt4#messagescomponent-생성하기\n - tutorial/toh-pt4#messageservice-바인딩하기\n - tutorial/toh-pt4#messageservice-생성하기\n - tutorial/toh-pt4#ngoninit에서-서비스-호출하기\n - tutorial/toh-pt4#동작-확인하기\n - tutorial/toh-pt4#메시지-표시하기\n - tutorial/toh-pt4#서비스-생성하기\n - tutorial/toh-pt4#옵저버블-heroservice\n - tutorial/toh-pt4#옵저버블-데이터\n - tutorial/toh-pt4#왜-서비스를-사용할까요\n - tutorial/toh-pt4#정리\n - tutorial/toh-pt4#최종코드-리뷰\n - tutorial/toh-pt4#히어로-데이터-가져오기\n - tutorial/toh-pt5\n - tutorial/toh-pt6\n - http://reactivex.io/rxjs/\n - https://github.com/angular/angular/edit/master/aio/content/tutorial/toh-pt4.md?message=docs%3A%20describe%20your%20change...\n-->"
}